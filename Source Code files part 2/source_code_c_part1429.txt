or);
    FreeWellKnownSid(&psidLocalSystem);
    FreeWellKnownSid(&psidAdmin);

    if (pACL) 
    {
        LocalFree(pACL);
        pACL = NULL;
    }
    
    return hr;

}  // end PERF_MANAGER::LaunchPerfCounterWaitingThread


/***************************************************************************++

Routine Description:

    Routine will force the counter update to complete if the 
    counter update is still going on, any counters not in at this
    point will be counted in the next gathering.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::ProcessPerfCounterGatheringTimerFired(
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // If we are still waiting, go ahead and complete
    // the counter gathering.  This will mean any worker
    // process that has not answered will be ignored.
    //
    if ( m_State == GatheringPerfManagerState )
    {
        CompleteCounterUpdate();
    }
    else
    {
        // 
        // Cancel the timer that got us here.
        // Ignore the error, because the most we will do is do
        // a spew message and that has been done for us.
        //
        CancelPerfCounterGatheringTimer();
    }

    return hr;
}

/***************************************************************************++

Routine Description:

    Routine handles a request for performance counter updates.

    If an update is all ready going on it will simply ignore the new request.

    Runs only on the main thread, using the sites table and app pool tables
    as well as the worker process objects to coordinate gathering of the counters.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::ProcessPerfCounterPingFired(
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    if ( m_State != IdlePerfManagerState )
    {
        //
        // It is not really an error to request an update at any 
        // point.  However we may not really do anything if we 
        // are not in the idle state.
        //
        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Not kicking off a counter gathering because"
                " the state was not idle m_State: %d\n",
                (DWORD) m_State
                ));
        }

        return S_OK;
    }

    //
    // Transition the state so that we know we 
    // have begun updating counters.  Note that 
    // m_State should only be changed the main thread
    //
    m_State = GatheringPerfManagerState;

    //
    // Send out a message to every active worker process
    // and ask that we get it's counters now.
    //
    hr = RequestWorkerProcessGatherCounters();
    if ( FAILED (hr) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not gather counters from worker process\n"
            ));

        goto exit;
    }

    //
    // Get UL's counters.
    //
    hr = RequestAndProcessULCounters();
    if ( FAILED (hr) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not gather counters from worker process\n"
            ));

        goto exit;
    }

    //
    // There are no worker processes to wait for.
    // 
    if (  m_NumProcessesToWaitFor == 0 )
    {
        CompleteCounterUpdate();
    }


exit:

    return hr;

}

/***************************************************************************++

Routine Description:

    Routine will ask all the worker process objects to send an IPM 
    request to each worker process requesting their counters.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::RequestWorkerProcessGatherCounters(
    )
{
    HRESULT hr = S_OK;
    DWORD NumProcessesToWaitFor = 0;

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_NumProcessesToWaitFor == 0 );

    hr = GetWebAdminService()->
         GetUlAndWorkerManager()->
         RequestCountersFromWorkerProcesses(&NumProcessesToWaitFor);

    if ( FAILED (hr) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not gather counters from worker process\n"
            ));

        goto exit;
    }

    IF_DEBUG ( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Number of process to wait for is = %d \n",
            NumProcessesToWaitFor
            ));
    }

    //
    // Since we have possesion of the main thread, so no I/O operations could
    // of been handled yet, we do not need to worry about synchronizing the
    // this increment.
    //

    m_NumProcessesToWaitFor = NumProcessesToWaitFor;

    //
    // Ignore a failure here.  If it failed then we will
    // spew it (within this call), and continue without the timer.
    //
    BeginPerfCounterGatheringTimer();

exit:

    return hr;

}

/***************************************************************************++

Routine Description:

  Routine loops through the site counters provided by HTTP.SYS and aggregates
  them into the appropriate site values.

Arguments:

  DWORD SizeOfBuffer is the size that HTTP.SYS says it used of the buffer.
  DWORD NumInstances is the number of instances that the buffer contains.

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::RecordHttpSiteCounters(
    DWORD SizeOfBuffer,
    DWORD NumInstances
    )
{
    //
    // Counters can only come in from HTTP.SYS while
    // we are in the gathering mode.
    //
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // First assert that the Site buffer actually exists.
    //

    DBG_ASSERT( m_pHttpSiteBuffer != NULL || ( SizeOfBuffer == 0 && NumInstances == 0 ));

    //
    // Next reference the first set of site counters.
    //
    HTTP_SITE_COUNTERS* pSiteCounters = 
                (HTTP_SITE_COUNTERS*) m_pHttpSiteBuffer;

    //
    // Loop through all instances processing the counters into 
    // the virtual site objects.
    //
    for (DWORD i = 0; i < NumInstances; i++, pSiteCounters++)
    {
        //
        // Make sure there is enough message left to really contain
        // the site counter information.  It is really bad if we think
        // we have more instances than we do data.
        //
        DBG_ASSERT ( SizeOfBuffer >= 
                                sizeof( HTTP_SITE_COUNTERS ) * (i + 1));

        //
        // Debug mode printing of counter values.
        //
        DumpULSiteCounters( pSiteCounters );

        //
        // Once we have verified we have enough room, we can then
        // process the counters.
        //
        FindAndAggregateSiteCounters( ULCOUNTERS, 
                                      pSiteCounters->SiteId, 
                                      pSiteCounters );       
    }

} // End of PERF_MANAGER::RecordHttpSiteCounters

/***************************************************************************++

Routine Description:

    Routine will ask UL for it's counters and compile them into the
    correct places in shared memory.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::RequestAndProcessULCounters(
    )
{
    DWORD Win32Error = NO_ERROR;
    HRESULT hr       = S_OK;
    DWORD NumInstances = 0;
    DWORD SizeOfBuffer = sizeof( HTTP_GLOBAL_COUNTERS );

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    HTTP_GLOBAL_COUNTERS GlobalBlock;

    //
    // Clear the memory block we will be giving to UL
    // so we know any values in here were set by UL.
    //
    memset ( &GlobalBlock, 0, sizeof( HTTP_GLOBAL_COUNTERS ) );

    //
    // Make a request of from UL for the Global Counters
    //

    HANDLE hControlChannel = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetUlControlChannel();

    Win32Error = HttpGetCounters(hControlChannel,
                  HttpCounterGroupGlobal, 
                  &SizeOfBuffer,
                  &GlobalBlock,
                  &NumInstances);

    if ( Win32Error != NO_ERROR )
    {
        //
        // When asking for globals, we are out of sync if we 
        // don't all ready know the size of the buffer to provide.
        //

        DBG_ASSERT ( Win32Error != ERROR_MORE_DATA );

        //
        //Issue-10/06/2000-EmilyK  Should we log an event if we can't get the ul counters?
        //

        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Retrieving global counters from ul failed. \n"
            ));

    }
    else
    {
        //
        // Global better only return 1 instance.
        //

        DBG_ASSERT ( NumInstances == 1 );
        DBG_ASSERT ( SizeOfBuffer == sizeof ( HTTP_GLOBAL_COUNTERS ) );

        //
        // Debug pring of counters.
        //
        DumpULGlobalCounters(&GlobalBlock);

        // 
        // Once we have the counters we need to process them.
        //
        AggregateGlobalCounters ( ULCOUNTERS, (LPVOID) &GlobalBlock );

    }

    // 
    // Make a request of UL for the Site counters
    //

    //
    // Figure out the buffering size and get the counters from HttpSys.
    hr = RequestSiteHttpCounters(hControlChannel, &SizeOfBuffer, &NumInstances);
    if ( FAILED (hr) )
    {
        goto exit;
    }
   
    //
    // Global better only return 1 instance.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Got site counters:  \n"
            "   NumInstances = %d  \n"
            "   SizeOfBuffer used = %d \n"
            "   ActualSizeOfBuffer = %d \n",
            NumInstances,
            SizeOfBuffer,
            m_HttpSiteBufferLen
            ));
    }

    RecordHttpSiteCounters(SizeOfBuffer, NumInstances);

exit:
    return S_OK;
}

/***************************************************************************++

Routine Description:

    Routine will request the site counters from HTTP.SYS.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
PERF_MANAGER::RequestSiteHttpCounters(
    HANDLE hControlChannel,
    DWORD* pSpaceNeeded,
    DWORD* pNumInstances
    )
{
    DWORD Win32Error = NO_ERROR;
    HRESULT hr       = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pNumInstances );
    DBG_ASSERT( pSpaceNeeded );

    *pNumInstances = 0;
    *pSpaceNeeded = 0;

    //
    // First we must make sure we have enough space for the site
    // counters in the buffer.  We will only reallocate memory
    // if we don't have enough memory in the first place.  HTTP.SYS
    // can still tell us we have too little memory, if we guess wrong.
    //
    DWORD NumSites = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetNumberofVirtualSites();

    *pSpaceNeeded = NumSites * sizeof ( HTTP_SITE_COUNTERS );

    //
    // Since we remember how much space we have allocated for this
    // we can check to see if it is enough to collect the counters
    // we expect.  
    //
    hr = SizeHttpSitesBuffer( pSpaceNeeded );
    if ( FAILED (hr) )
    {
        //
        // We have all ready spewed the problem out and now 
        // we just want to get out of this function without
        // dealing with the counters.
        //

        hr = S_OK;
        goto exit;
    }

    DBG_ASSERT ( m_pHttpSiteBuffer );
    //
    // Make a request of from UL for the Site Counters
    //
    //
    // Note, since WAS configures the number of sites HTTP
    // knows about we are assuming that WAS will always be able
    // to calculate the correct buffer size.  It might become
    // apparent that this assumption is false, but until it
    // does we are intentionally not handling the case where
    // the buffer size is too small.
    Win32Error = HttpGetCounters(hControlChannel,
                  HttpCounterGroupSite, 
                  pSpaceNeeded,
                  m_pHttpSiteBuffer,
                  pNumInstances);

    if ( Win32Error != NO_ERROR )
    {

        //
        //Issue-10/06/2000-EmilyK  Should we log an event if we can't get the ul counters?
        //

        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Retrieving site counters from HTTP.SYS failed. \n"
            ));

    }

exit:
    return hr;
}

/***************************************************************************++

Routine Description:

    Routine alters the m_pHttpSitesBuffer to be of the size requested.
    If the buffer is all ready bigger than the size requested no changes
    are made, however the size requested is altered so we are aware that
    we are actually passing more space than expected.

Arguments:

    DWORD* pSpaceNeeded - Coming in it is the size we expect to need
                          Going out it is the size we actually have

Return Value:

    HRESULT - Can return E_OUTOFMEMORY if allocations failed.

--***************************************************************************/
HRESULT
PERF_MANAGER::SizeHttpSitesBuffer(
    DWORD* pSpaceNeeded
    )
{
    HRESULT hr = S_OK;
    DBG_ASSERT ( pSpaceNeeded );

    if ( *pSpaceNeeded > m_HttpSiteBufferLen )
    {
        //
        // If we all ready have allocated space, 
        // get rid of it.
        //
        if ( m_pHttpSiteBuffer )
        {
            delete[] m_pHttpSiteBuffer;
        }

        //
        // allocate the new space, if this fails,
        // we should not go on with getting counters
        // from HTTP.SYS.  
        //
        // if we don't have enough memory we will
        // just not get the counters
        //
        m_pHttpSiteBuffer = new BYTE[*pSpaceNeeded];
        if ( m_pHttpSiteBuffer == NULL )
        {
            // Not good, we can't complete getting
            // counters here.

            // need to set the BufferLen to zero as
            // well so we can recover next time.
            m_HttpSiteBufferLen = 0;

            DPERROR((
                DBG_CONTEXT,
                E_OUTOFMEMORY,
                "Error allocating space to get HTTP.SYS site "
                "counters in. \n"
                ));

            hr = E_OUTOFMEMORY;
            goto exit;

        }

        m_HttpSiteBufferLen = *pSpaceNeeded;
    }
    else
    {
        //
        // Issue-10/23/2000-EmilyK Shrink the site buffer?
        // 
        // Do we want to shrink the site buffer, if we are
        // extremely larger than expected?
        //

        //
        // Change space needed to correctly tell HTTP.SYS how
        // much space they are being passed.
        //
        *pSpaceNeeded = m_HttpSiteBufferLen;
    }

    //
    // Assuming we have a buffer, we should clear the buffer
    // before passing it down to the Http.sys.
    //
    if ( m_pHttpSiteBuffer )
    {
        //
        // Clear the memory block we will be giving to UL
        // so we know any values in here were set by UL.
        //
        memset ( m_pHttpSiteBuffer, 0, m_HttpSiteBufferLen );
    }


exit:

    return hr;
}

/***************************************************************************++

Routine Description:

    Routine runs when we have completed updating counters.  It will
    fix the maximum values and will change the control information to
    point to the new active counters.  It will also change state so 
    new requests can be received.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::CompleteCounterUpdate(
    )
{
    DBG_ASSERT ( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( m_State == GatheringPerfManagerState );

    //
    // If the timer is still running then we should cancel it.
    // Ignore the error, because the most we will do is do
    // a spew message and that has been done for us.
    CancelPerfCounterGatheringTimer();

    //
    // Now that we have gotten all the performance counters
    // we need to do the following:
    //
    // 1)  Figure out if we need more memory allocated. (StructChanged)
    // 2)  Figure out if sites have gone away. (StructChanged)
    // 3)  Walk the sites table (for each site do):
    //       a)  pass in the current offset for the memory.
    //       b)  if there has been a struct change copy in
    //           the instance information. store the offset.
    //       c)  adjust max values (as well as store back adjusted values)
    //       d)  copy in the counters
    //       g)  increment the _Total with the new values.
    //       h)  zero out the appropriate site counters.
    // 4)  Publish the new page to the user.
    // 5)  Copy the page over if update was needed.

    // 
    // Figure out if any sites have been deleted 
    // or added since the last time we got counters.
    // 
    BOOL SiteStructChanged = GetWebAdminService()->
                             GetUlAndWorkerManager()->
                             CheckAndResetSiteChangeFlag(); 
    
    //
    // If they have then we may need to re-allocate memory.
    //
    if ( SiteStructChanged )
    {

        //
        // Tell shared memory the new number of instances that we now have and
        // let it reallocate the memory if neccessary.  Remember that we also need
        // space for the _Total instance.
        // 
        DWORD NumVirtualSites = GetWebAdminService()->
                                GetUlAndWorkerManager()->
                                GetNumberofVirtualSites();

        HRESULT hr = m_SharedManager.ReallocSharedMemIfNeccessary( 
                                                            SITE_COUNTER_SET, 
                                                            NumVirtualSites + 1);
        if ( FAILED ( hr ) )
        {
            //
            // If we fail to re-allocate memory, 
            // then we can not really go on, because
            // the next time through we will assume 
            // that we atleast started with valid memory
            // which if no new changes had come in, we 
            // will try to write to the invalid memory.
            // For now we will simply turn off counters 
            // if this fails.  If we find there are valid
            // ways to get into this state, we can re-look 
            // at being able to suspend counter publishing
            // and have it turn back on.
            //

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Error reallocating the shared memory, turning of perf counter publishing, you must restart w3svc to reactivate them\n"
                ));

            m_State = TerminallyIllPerfManagerState;           

            return;
        }
    }


    //
    // Now let UL walk through the tables and 
    // have each one of the sites report to 
    // the perf manager their values.
    //

    GetWebAdminService()->
    GetUlAndWorkerManager()->
    ReportVirtualSitePerfInfo( this , SiteStructChanged );
    
    //
    // Fix the actual service uptime now.
    //
    m_SharedManager.UpdateTotalServiceTime( GetCurrentTimeInSeconds() 
                           - GetWebAdminService()->ServiceStartTime() );

    // 
    // Need to report the Global Counters as well.
    //
    ReportGlobalPerfInfo();

    //
    // Now that the counters have been placed in
    // shared memory, and the hold tanks have been
    // adjusted for new counters to come in, we 
    // can go ahead and tell all the worker processes
    // that they can accept new counters.
    //
    GetWebAdminService()->
    GetUlAndWorkerManager()->
    ResetAllWorkerProcessPerfCounterState();

    //
    // Once the information has all been reported
    // then we can publish the page.
    //

    m_SharedManager.PublishCounters();

    m_State = IdlePerfManagerState;
}

/***************************************************************************++

Routine Description:

    Routine take the global counters that we have gathered and 
    places them into shared memory.

Arguments:

    None.

Return Value:

    None

--***************************************************************************/
VOID
PERF_MANAGER::ReportGlobalPerfInfo()
{

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // Since we are done we can now adjust any max values.
    //
    AdjustMaxValues();
    
    // 
    // Setup the Instance Counter Information
    // This will copy in the instance name, as well as zero'ing
    // all the counter values and correctly adjusting byte lengths
    // in the data header.
    // 

    ULONG Unused = 0;

    m_SharedManager.CopyInstanceInformation( 
                                  GLOBAL_COUNTER_SET 
                                , NULL
                                , 0
                                , &m_GlobalCounters
                                , NULL
                                , 0
                                , FALSE
                                , &Unused );
                                  


    //
    // Clear the appropriate values from the site so that we are
    // ready to get the next set of counters in.
    //
    ClearAppropriatePerfValues();


} // end of PERF_MANAGER::ReportGlobalPerfInfo

/***************************************************************************++

Routine Description:

    Routine figures out the maximum value for the counters
    and saves it back into the MaxCounters Structure.

Arguments:

    NONE

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_MANAGER::AdjustMaxValues(
    )
{
    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // Walk through all the MAX property descriptions.
    //
    for (   ULONG PropMaxId = 0 ; 
            PropMaxId < g_cIISGlobalMaxDescriptions; 
            PropMaxId++ )
    {

        if ( g_aIISGlobalMaxDescriptions[PropMaxId].size == sizeof( DWORD ) )
        {
            DWORD* pDWORDAsIs = (DWORD*) ( (LPBYTE) &m_GlobalCounters 
                       + g_aIISGlobalMaxDescriptions[PropMaxId].DisplayOffset );

            DWORD* pDWORDToSwapWith =  (DWORD*) ( (LPBYTE) &m_MaxGlobalCounters 
                        + g_aIISGlobalMaxDescriptions[PropMaxId].SafetyOffset );

            
            if ( *pDWORDAsIs < *pDWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pDWORDAsIs = *pDWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pDWORDToSwapWith = *pDWORDAsIs;
            }

        }
        else
        {
            DBG_ASSERT ( g_aIISGlobalMaxDescriptions[PropMaxId].size == 
                                                                sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDAsIs = (ULONGLONG*) ( (LPBYTE) &m_GlobalCounters 
                         + g_aIISGlobalMaxDescriptions[PropMaxId].DisplayOffset );

            ULONGLONG* pQWORDToSwapWith =  (ULONGLONG*) ( (LPBYTE) &m_MaxGlobalCounters 
                         + g_aIISGlobalMaxDescriptions[PropMaxId].SafetyOffset );

            
            if ( *pQWORDAsIs < *pQWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pQWORDAsIs = *pQWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pQWORDToSwapWith = *pQWORDAsIs;
            }

        }  // end of decision on which size of data we are dealing with
            
    } // end of for loop
    
} // end of PERF_MANAGER::AdjustMaxValues


/***************************************************************************++

Routine Description:

    Routine clears out the appropriate global values so that we are 
    ready to gather perf counters again.

Arguments:

    None.

Return Value:

    None

--***************************************************************************/
VOID
PERF_MANAGER::ClearAppropriatePerfValues()
{
    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;
    DWORD           PropInputId = 0;
    DWORD           PropDisplayId = 0;
    LPVOID          pCounterBlock = &m_GlobalCounters;

    DBG_ASSERT ( m_State == GatheringPerfManagerState );

    //
    // First walk through the WP Counters and Zero appropriately
    //
    pInputPropDesc = aIISWPGlobalDescription;
    pPropMap = g_aIISWPGlobalMappings;
    MaxCounters = g_cIISWPGlobalMappings; 

    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }

    //
    // Now walk through the UL Counters and Zero appropriately
    //
    pInputPropDesc = aIISULGlobalDescription;
    pPropMap = g_aIISULGlobalMappings;
    MaxCounters = g_cIISULGlobalMappings; 

    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }


} // end of PERF_MANAGER::ClearAppropriatePerfValues

/***************************************************************************++

Routine Description:

    Start a perf counter timer to make sure we don't wait forever for
    counters to be returned.  If any worker process does not return in 
    the time allowed then there numbers will be left out of the total.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::BeginPerfCounterGatheringTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( m_PerfCounterGatheringTimerHandle == NULL );

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Beginning perf counter gathering timer\n"
            ));
    }

    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                            // timer queue
                    &m_PerfCounterGatheringTimerHandle,     // returned timer handle
                    PerfCounterTimerCallback,               // callback function
                    this,                                   // context
                    PERF_COUNTER_GATHERING_TIMER_PERIOD,    // initial firing time
                    0,                                      // subsequent firing period
                    WT_EXECUTEINWAITTHREAD                  // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create perf counter gathering timer\n"
            ));

    }

    return hr;

}   // PERF_MANAGER::BeginPerfCounterGatheringTimer



/***************************************************************************++

Routine Description:

    Stop the perf counter gathering timer, if present

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::CancelPerfCounterGatheringTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    //
    // If the timer is not present, we're done here.
    //

    if ( m_PerfCounterGatheringTimerHandle == NULL )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Cancelling perf counter timer\n"
            ));
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    // Otherwise, there could be a race where the callback runs after
    // this worker process instance has been deleted, and so gives out
    // a bad pointer.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                          // the owning timer queue
                    m_PerfCounterGatheringTimerHandle,             // timer to cancel
                    INVALID_HANDLE_VALUE                  // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel perf counter gathering timer\n"
            ));

        goto exit;
    }

    m_PerfCounterGatheringTimerHandle = NULL;


exit:

    return hr;

}   // PERF_MANAGER::CancelPerfCounterGatheringTimer

/***************************************************************************++

Routine Description:

    Start the perf counter timer, to make sure we are gathering counters
    ever so often regardless of whether or not they are being asked for.  

    This is so we do not lose too many counters if a process crashes.  We will
    not lose any counters on a regular shutdown because the process will
    deliver it's counters before it shutsdown.

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::BeginPerfCounterTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( m_PerfCounterTimerHandle == NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Beginning perf counter gathering timer\n"
            ));
    }


    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                            // timer queue
                    &m_PerfCounterTimerHandle,              // returned timer handle
                    PerfCounterTimerCallback,               // callback function
                    this,                                   // context
                    PERF_COUNTER_TIMER_PERIOD,              // initial firing time
                    PERF_COUNTER_TIMER_PERIOD,              // subsequent firing period
                    WT_EXECUTEINWAITTHREAD                  // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create perf counter timer\n"
            ));

    }


    return hr;

}   // PERF_MANAGER::BeginPerfCounterTimer

/***************************************************************************++

Routine Description:

    Stop the perf counter timer, if present

Arguments:

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_MANAGER::CancelPerfCounterTimer(
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );


    //
    // If the timer is not present, we're done here.
    //

    if ( m_PerfCounterTimerHandle == NULL )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Cancelling perf counter timer\n"
            ));
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    // Otherwise, there could be a race where the callback runs after
    // this worker process instance has been deleted, and so gives out
    // a bad pointer.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                          // the owning timer queue
                    m_PerfCounterTimerHandle,             // timer to cancel
                    INVALID_HANDLE_VALUE                  // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel perf counter timer\n"
            ));

        goto exit;
    }

    m_PerfCounterTimerHandle = NULL;


exit:

    return hr;

}   // PERF_MANAGER::CancelPerfCounterTimer


//
// Private (debug) PERF_MANAGER functions
//

/***************************************************************************++

Routine Description:

    Debug dumps all the UL Cache counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::DumpULGlobalCounters(
    HTTP_GLOBAL_COUNTERS* pCounters
    )
{
    DBG_ASSERT (pCounters);

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "UL Counters for global\n"
            "   :  CurrentUrisCached %d\n"
            "   :  TotalUrisCached %d\n"
            "   :  UriCacheHits %d\n"
            "   :  UriCacheMisses %d\n"
            "   :  UriCacheFlushes %d\n"
            "   :  TotalFlushedUris %d\n",
            pCounters->CurrentUrisCached,
            pCounters->TotalUrisCached,
            pCounters->UriCacheHits,
            pCounters->UriCacheMisses,
            pCounters->UriCacheFlushes,
            pCounters->TotalFlushedUris
            ));

    }
}

/***************************************************************************++

Routine Description:

    Debug dumps all the UL Site counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::DumpULSiteCounters(
    HTTP_SITE_COUNTERS* pCounters
    )
{
    DBG_ASSERT (pCounters);

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "UL Counters for site %d\n"
            "   :  BytesSent %I64d\n"
            "   :  BytesReceived %I64d\n"
            "   :  BytesTransfered %I64d\n"
            "   :  CurrentConns %d\n"
            "   :  MaxConnections %d\n"
            "   :  ConnAttempts %d\n"
            "   :  GetReqs %d\n"
            "   :  HeadReqs %d\n"
            "   :  AllReqs %d\n"
            "   :  MeasuredIoBandwidthUsage %d\n"
            "   :  CurrentBlockedBandwidthBytes %d\n"
            "   :  TotalBlockedBandwidthBytes %d\n\n",
            pCounters->SiteId,
            pCounters->BytesSent,
            pCounters->BytesReceived,
            pCounters->BytesTransfered,
            pCounters->CurrentConns,
            pCounters->MaxConnections,
            pCounters->ConnAttempts,
            pCounters->GetReqs,
            pCounters->HeadReqs,
            pCounters->AllReqs,
            pCounters->MeasuredIoBandwidthUsage,
            pCounters->CurrentBlockedBandwidthBytes,
            pCounters->TotalBlockedBandwidthBytes
            ));

    }

}

/***************************************************************************++

Routine Description:

    Debug dumps all the WP Cache counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::DumpWPGlobalCounters(
    IISWPGlobalCounters* pCounters
    )
{
    DBG_ASSERT (pCounters);

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "WP Counters for global\n"
            "   :   CurrentFilesCached %d \n"
            "   :   TotalFilesCached %d \n"
            "   :   FileCacheHits %d \n"
            "   :   FileCacheMisses %d \n"
            "   :   FileCacheFlushes %d \n"
            "   :   CurrentFileCacheMemoryUsage %I64d \n"
            "   :   MaxFileCacheMemoryUsage %I64d \n"
            "   :   ActiveFlushedFiles %d \n"
            "   :   TotalFlushedFiles %d \n"
            "   :   CurrentUrisCached %d \n"
            "   :   TotalUrisCached %d \n"
            "   :   UriCacheHits %d \n"
            "   :   UriCacheMisses %d \n"
            "   :   UriCacheFlushes %d \n"
            "   :   TotalFlushedUris %d \n"
            "   :   CurrentBlobsCached %d \n"
            "   :   TotalBlobsCached %d \n"
            "   :   BlobCacheHits %d \n"
            "   :   BlobCacheMisses %d \n"
            "   :   BlobCacheFlushes %d \n"
            "   :   TotalFlushedBlobs %d \n",
            pCounters-> CurrentFilesCached,
            pCounters-> TotalFilesCached,
            pCounters-> FileCacheHits,
            pCounters-> FileCacheMisses,
            pCounters-> FileCacheFlushes,
            pCounters-> CurrentFileCacheMemoryUsage,
            pCounters-> MaxFileCacheMemoryUsage,
            pCounters-> ActiveFlushedFiles,
            pCounters-> TotalFlushedFiles,
            pCounters-> CurrentUrisCached,
            pCounters-> TotalUrisCached,
            pCounters-> UriCacheHits,
            pCounters-> UriCacheMisses,
            pCounters-> UriCacheFlushes,
            pCounters-> TotalFlushedUris,
            pCounters-> CurrentBlobsCached,
            pCounters-> TotalBlobsCached,
            pCounters-> BlobCacheHits,
            pCounters-> BlobCacheMisses,
            pCounters-> BlobCacheFlushes,
            pCounters-> TotalFlushedBlobs
            ));

    }



}

/***************************************************************************++

Routine Description:

    Debug dumps all the WP Site counters exactly as retrieved from UL.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID 
PERF_MANAGER::DumpWPSiteCounters(
    IISWPSiteCounters* pCounters
    )
{
    DBG_ASSERT (pCounters);

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "WP Counters for site %d\n"
            "   :  FilesSent  %d\n"
            "   :  FilesReceived  %d\n"
            "   :  FilesTransferred  %d\n"
            "   :  CurrentAnonUsers  %d\n"
            "   :  CurrentNonAnonUsers  %d\n"
            "   :  AnonUsers  %d\n"
            "   :  NonAnonUsers  %d\n"
            "   :  MaxAnonUsers  %d\n"
            "   :  MaxNonAnonUsers  %d\n"
            "   :  LogonAttempts  %d\n"
            "   :  GetReqs  %d\n"
            "   :  OptionsReqs  %d\n"
            "   :  PostReqs  %d\n"
            "   :  HeadReqs  %d\n"
            "   :  PutReqs  %d\n"
            "   :  DeleteReqs  %d\n"
            "   :  TraceReqs  %d\n"
            "   :  MoveReqs  %d\n"
            "   :  CopyReqs  %d\n"
            "   :  MkcolReqs  %d\n"
            "   :  PropfindReqs  %d\n"
            "   :  ProppatchReqs  %d\n"
            "   :  SearchReqs  %d\n"
            "   :  LockReqs  %d\n"
            "   :  UnlockReqs  %d\n"
            "   :  OtherReqs  %d\n"
            "   :  CurrentCgiReqs  %d\n"
            "   :  CgiReqs  %d\n"
            "   :  MaxCgiReqs  %d\n"
            "   :  CurrentIsapiExtReqs  %d\n"
            "   :  IsapiExtReqs  %d\n"
            "   :  MaxIsapiExtReqs  %d\n",
            pCounters->SiteID,
            pCounters->FilesSent,
            pCounters->FilesReceived,
            pCounters->FilesTransferred,
            pCounters->CurrentAnonUsers,
            pCounters->CurrentNonAnonUsers,
            pCounters->AnonUsers,
            pCounters->NonAnonUsers,
            pCounters->MaxAnonUsers,
            pCounters->MaxNonAnonUsers,
            pCounters->LogonAttempts,
            pCounters->GetReqs,
            pCounters->OptionsReqs,
            pCounters->PostReqs,
            pCounters->HeadReqs,
            pCounters->PutReqs,
            pCounters->DeleteReqs,
            pCounters->TraceReqs,
            pCounters->MoveReqs,
            pCounters->CopyReqs,
            pCounters->MkcolReqs,
            pCounters->PropfindReqs,
            pCounters->ProppatchReqs,
            pCounters->SearchReqs,
            pCounters->LockReqs,
            pCounters->UnlockReqs,
            pCounters->OtherReqs,
            pCounters->CurrentCgiReqs,
            pCounters->CgiReqs,
            pCounters->MaxCgiReqs,
            pCounters->CurrentIsapiExtReqs,
            pCounters->IsapiExtReqs,
            pCounters->MaxIsapiExtReqs
            ));

    }
}

//
// global routines
//

/***************************************************************************++

Routine Description:

    Routine is launched on the perf counter thread.  It will spin until
    it is told to shutdown by the PERF_MANAGER termination routine.

Arguments:

    LPVOID lpParameter - Pointer to PERF_MANAGER.

Return Value:

    HRESULT

--***************************************************************************/
DWORD WINAPI PerfCountPing(
    LPVOID lpParameter
    )
{
    PERF_MANAGER* pManager = (PERF_MANAGER*) lpParameter;
    DWORD dwErr = ERROR_SUCCESS;

    DBG_ASSERT (pManager);

    PERF_MANAGER_STATE state = pManager->GetPerfState();

    // Wait on the WASPerfCountEvent
    // If we are in shutdown mode just end, otherwise 
    // tick off a gathering of perf counters (if we
    // are not all ready gathering) and then wait again.

    while ( state != TerminatingPerfManagerState )
    {
        // Do not care what the wait returns, 
        // just know that we did signal so we should
        // either end or start gathering perf counters.
        WaitForSingleObject(pManager->GetPerfEvent(), INFINITE);

        IF_DEBUG ( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "PerfCounters signaled CTC = %d \n",
                GetTickCount()
                ));
        }

        // Once we have heard the event reset it.
        if (!ResetEvent(pManager->GetPerfEvent()))
        {
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(GetLastError()),
                "Could not reset the perf counter event\n"
                ));
            break;
        }

        //
        // Get the new state so we know if we should
        // continue processing or not.
        //
        state = pManager->GetPerfState();
        
        //
        // Since we are still running we need
        // to start up the W3WP code now.
        // 
        // The function on the main thread will determine
        // if we actually want to gather now or just dismiss
        // the request.
        //
        if ( state != TerminatingPerfManagerState )
        {
            QueueWorkItemFromSecondaryThread(
                       reinterpret_cast<WORK_DISPATCH*>( pManager ),
                       PerfCounterPingFiredWorkItem
                );
        }
    }

    return dwErr;
}

/***************************************************************************++

Routine Description:

    The callback function invoked by the perf counter timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    PERF_MANAGER object.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
PerfCounterTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    PERF_MANAGER* pManager = reinterpret_cast<PERF_MANAGER*>( Context );
    
    DBG_ASSERT ( pManager->CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for perf "
            "counters to be gathered (timer fired) (ptr: %p)\n",
            pManager
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        PerfCounterPingFiredWorkItem
        );


    return;

}   // PerfCounterTimerCallback

/***************************************************************************++

Routine Description:

    The callback function invoked by the perf counter gathering timer. It 
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    PERF_MANAGER object.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
PerfCounterGatheringTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    PERF_MANAGER* pManager = reinterpret_cast<PERF_MANAGER*>( Context );
    
    DBG_ASSERT ( pManager->CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for perf "
            "counters to be gathered (timer fired) (ptr: %p)\n",
            pManager
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        PerfCounterGatheringTimerFiredWorkItem
        );


    return;

}   // PerfCounterGatheringTimerCallback


/***************************************************************************++

Routine Description:

    Supporting function that alters the security of the process to 
    allow the perf lib processes to monitor when this process goes away.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
AdjustProcessSecurityToAllowPowerUsersToWait(
    )
{
    HRESULT hr = S_OK;
    DWORD   dwErr = ERROR_SUCCESS;
    EXPLICIT_ACCESS ea[2];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    PSID psidPowerUser = NULL;
    PSID psidSystemOperator = NULL;
    PACL pNewDACL = NULL;
    PACL pOldDACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    HANDLE hProcess = GetCurrentProcess();

    //
    // Get a sid that represents the POWER_USERS group.
    //
    //
    // Get a sid that represents the POWER_USERS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPowerUsersSid,
                                        &psidPowerUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the SYSTEM_OPERATORS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinSystemOperatorsSid, 
                                        &psidSystemOperator );
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwErr );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating System Operators SID failed\n"
            ));

        goto exit;
    }
    

    //
    // Now Get the SD for the Process.
    //

    //
    // The pOldDACL is just a pointer into memory owned 
    // by the pSD, so only free the pSD.
    //
    dwErr = GetSecurityInfo( hProcess,
                                  SE_FILE_OBJECT, 
                                  DACL_SECURITY_INFORMATION,
                                  NULL,        // owner SID
                                  NULL,        // primary group SID
                                  &pOldDACL,   // PACL*
                                  NULL,        // PACL*
                                  &pSD );      // Security Descriptor 
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get security info for the current process \n"
            ));

        goto exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for the new ACE. 

    ZeroMemory(&ea, sizeof(ea));
    SetExplicitAccessSettings(  &(ea[0]), 
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidPowerUser );

    SetExplicitAccessSettings(  &(ea[1]), 
                                SYNCHRONIZE,
                                GRANT_ACCESS,
                                psidSystemOperator );

    //
    // Add the power user acl to the list.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS), 
                            ea, 
                            pOldDACL, 
                            &pNewDACL);

    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not set Acls into security descriptor \n"
            ));

        goto exit;
    }

    //
    // Attach the new ACL as the object's DACL.
    //
    dwErr = SetSecurityInfo(hProcess, 
                                  SE_FILE_OBJECT, 
                                  DACL_SECURITY_INFORMATION,
                                  NULL, 
                                  NULL, 
                                  pNewDACL, 
                                  NULL);
    if ( dwErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not set process security info \n"
            ));

        goto exit;
    }

exit:

    FreeWellKnownSid(&psidPowerUser);
    FreeWellKnownSid(&psidSystemOperator);

    if( pSD != NULL ) 
    {
        LocalFree((HLOCAL) pSD); 
        pSD = NULL;
    }

    if( pNewDACL != NULL ) 
    {
        LocalFree((HLOCAL) pNewDACL); 
        pNewDACL = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_manager.h

Abstract:

    The IIS web admin service perf manager class definition.

Author:

    Emily Kruglick (EmilyK)        29-Aug-2000

Revision History:

--*/


#ifndef _PERF_MANAGER_H_
#define _PERF_MANAGER_H_



//
// common #defines
//

#define PERF_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'PRFC' )
#define PERF_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'prfX' )

#define PERF_COUNTER_TIMER_PERIOD ( 300 * ONE_SECOND_IN_MILLISECONDS )  // 5 minutes

#define PERF_COUNTER_GATHERING_TIMER_PERIOD ( 60 * ONE_SECOND_IN_MILLISECONDS )  // 1 minute

//
// structs, enums, etc.
//

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Holding spot for the maximum cache counters.
//
typedef struct _GLOBAL_MAX_DATA
{
    ULONGLONG MaxFileCacheMemoryUsage;
} GLOBAL_MAX_DATA;

//
// Perf manager state
// 
typedef enum _PERF_MANAGER_STATE
{

    //
    // Has not been initialized yet.
    // 
    UninitializedPerfManagerState = 1,

    //
    // Has been initialized and has
    // data waiting for the grabbing
    // and is not in the middle of updating
    // the counter values.
    //
    IdlePerfManagerState,

    //
    // Is in the middle of grabbing new
    // perf counter data from the worker 
    // processes and from UL.  
    //
    GatheringPerfManagerState,

    //
    // We have started the shutdown phase
    // this object will do no more work but
    // clean it'self up and die.
    //
    TerminatingPerfManagerState,

    //
    // If we suffer a failure that prevents
    // us from being able to gather counters 
    // in the future than the perf manager can
    // be considered in a terminally ill state 
    // and will not gather or publish counters 
    // until the server has been stopped and restarted.
    //
    TerminallyIllPerfManagerState

} PERF_MANAGER_STATE;

// PERF_MANAGER work items
typedef enum _PERF_MANAGER_WORK_ITEM
{

    //
    // Time to gather performance counters.
    //
    PerfCounterPingFiredWorkItem = 1,

    //
    // Timer fired to finish collecting perf counters.
    //
    PerfCounterGatheringTimerFiredWorkItem

} PERF_MANAGER_WORK_ITEM;

//
// prototypes
//

class PERF_MANAGER
    : public WORK_DISPATCH
{
public:

    PERF_MANAGER(
        );

    virtual
    ~PERF_MANAGER(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );


    HRESULT
    Initialize(
        );

    VOID
    Terminate(
        );

    VOID
    SetupVirtualSite(
        IN VIRTUAL_SITE* pVirtualSite
        );

    VOID
    SetupTotalSite(
        IN BOOL          StructChanged
        );

    HRESULT
    Shutdown(
        );

    HANDLE
    GetPerfEvent(
        )
    { return m_hWASPerfCountEvent; };

    PERF_MANAGER_STATE
    GetPerfState(
        )
    { return m_State; };

    VOID 
    RecordCounters(
        IN DWORD MessageLength,
        IN const BYTE* pMessageData
        );

    BOOL
    CheckSignature(
        )
    { return (m_Signature == PERF_MANAGER_SIGNATURE); }

private:

    VOID
    DumpWPSiteCounters(
        IISWPSiteCounters* pCounters
        );

    VOID 
    DumpWPGlobalCounters(
        IISWPGlobalCounters* pCounters
        );

    VOID
    DumpULGlobalCounters(
        HTTP_GLOBAL_COUNTERS* pCounters
        );

    VOID 
    DumpULSiteCounters(
        HTTP_SITE_COUNTERS* pCounters
        );

    HRESULT
    LaunchPerfCounterWaitingThread(
        );

    HRESULT
    ProcessPerfCounterPingFired(
        );

    HRESULT
    RequestWorkerProcessGatherCounters(
        );

    HRESULT
    RequestAndProcessULCounters(
        );

    VOID
    CompleteCounterUpdate(
        );

    VOID
    FindAndAggregateSiteCounters(
        COUNTER_SOURCE_ENUM CounterSource,
        DWORD SiteId,
        IN LPVOID pCounters
        );

    VOID
    AggregateGlobalCounters(
        COUNTER_SOURCE_ENUM CounterSource,
        IN LPVOID pCounters
        );

    VOID
    ReportGlobalPerfInfo(
        );

    VOID
    ClearAppropriatePerfValues(
        );

    VOID 
    DecrementWaitingProcesses(
        );

    HRESULT
    BeginPerfCounterTimer(
        );

    HRESULT
    CancelPerfCounterTimer(
        );

    HRESULT
    BeginPerfCounterGatheringTimer(
        );

    HRESULT
    CancelPerfCounterGatheringTimer(
        );

    HRESULT
    ProcessPerfCounterGatheringTimerFired(
        );

    VOID
    AdjustMaxValues(
        );

    HRESULT
    RequestSiteHttpCounters(
        HANDLE hControlChannel,
        DWORD* pSpaceNeeded,
        DWORD* pNumInstances
        );

    HRESULT
    SizeHttpSitesBuffer(
        DWORD* pSpaceNeeded
        );

    VOID 
    RecordHttpSiteCounters(
        DWORD SizeOfBuffer,
        DWORD NumInstances
        );


    DWORD m_Signature;

    // Only changeable on the main thread
    PERF_MANAGER_STATE m_State;

    LONG m_RefCount;

    //
    // Shared Manager for counter shared memory.
    //
    PERF_SM_MANAGER m_SharedManager;

    //
    // Event to know that it's time to refresh 
    // counters.
    //
    HANDLE m_hWASPerfCountEvent;

    //
    // Handle to the pref count thread
    // that is waiting on pings to request 
    // counter refreshes.
    //
    HANDLE m_hPerfCountThread;

    //
    // The Thread Id for the perf thread
    //
    DWORD  m_PerfCountThreadId;

    //
    // Contains the number of processes
    // we are waiting to hear from.
    //
    DWORD m_NumProcessesToWaitFor;

    //
    // saftey for global counters;
    W3_GLOBAL_COUNTER_BLOCK m_GlobalCounters;

    //
    // saftey for max values.
    GLOBAL_MAX_DATA m_MaxGlobalCounters;

    //
    // Handle to the timer that is causing us to gather counters.
    //
    HANDLE m_PerfCounterTimerHandle;

    //
    // Handle to the timer that is causing us to finish gather counters
    // if the wp's are not responsive enough.
    //
    HANDLE m_PerfCounterGatheringTimerHandle;

    //
    // Block of memory for retrieving site counters from HTTP.SYS.
    //

    LPBYTE m_pHttpSiteBuffer;

    //
    // Size (bytes) of the site counter retrieval block.
    //
    DWORD m_HttpSiteBufferLen;

    // 
    // These two member variables must be initalized in a SetupTotal
    // call before being used in the SetupInstance calls that follow.
    //
    //
    // Holds the next valid offset to start counters at, for use
    // during copying of counters to shared memory.
    //
    ULONG m_NextValidOffset;

    //
    // Rememmbers if instance numbers or definitions have changed 
    // since last gathering.  If they have then during the current
    // gathering all counter offsets must be recalcualated.
    //
    BOOL m_InstanceInfoHaveChanged;

};  // class PERF_MANAGER



#endif  // _PERF_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_virtual_site_table.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    PERF_VIRTUAL_SITE_table.cxx

Abstract:

    This class is a hashtable which manages the set of virtual sites.
    It is a snapshot of the virtual sites when the perf gathering started.
    It is only used for performance gathering.

    Threading: Adds and Deletes are always done on the main thread, the 
    rest can be done on other threads. Abstract synchronization keeps
    Adds and Deletes from ocurring at the same time as other changes.

Author:

    Emily Kruglick (emilyk)        30-Aug-2000

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_VIRTUAL_SITE_TABLE::Terminate(
    )
{

    //
    // Will delete all the entries in the hash table.
    //

    CleanupHash(TRUE);

    return;

}   // PERF_VIRTUAL_SITE_TABLE::Terminate

/***************************************************************************++

Routine Description:

    Cleans up the hash table and throws out any entries that are no 
    longer valid.  If the flag to throw out all has been given then 
    it will do just that.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_VIRTUAL_SITE_TABLE::CleanupHash(
    BOOL fAll
    )
{
    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    PERF_VIRTUAL_SITE * pPerfVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeletePerfVirtualSiteAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, clean it up, remove it from the table, and delete it
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pPerfVirtualSite = PERF_VIRTUAL_SITE::PerfVirtualSiteFromListEntry( pDeleteListEntry );

        if ( fAll || pPerfVirtualSite->IsNotActive() )
        {
            // remove it from the table

            ReturnCode = DeleteRecord( pPerfVirtualSite );

            if ( ReturnCode != LK_SUCCESS )
            {

                hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Removing perf virtual site from hashtable failed\n"
                    ));
            }

            IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Deleting perf virtual site with id of %d\n",
                    pPerfVirtualSite->GetVirtualSiteId()
                    ));
            }

            //
            // All remaining shutdown work for the virtual site is done 
            // in it's destructor.
            //

            delete pPerfVirtualSite;
        }
        else
        {
            // Reset it to false so that the next time 
            // through we will need to touch it if we 
            // want to keep it as a valid site.
            pPerfVirtualSite->SetActive(FALSE);
        }
    }

    return;

}   // PERF_VIRTUAL_SITE_TABLE::Terminate

/***************************************************************************++

Routine Description:

    A routine that may be applied to all VIRTUAL_SITEs in the hashtable
    to prepare for termination. Conforms to the PFnRecordAction prototype.

Arguments:

    pVirtualSite - The virtual site.

    pDeleteListHead - List head into which to insert the virtual site for
    later deletion.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/
// note: static!
LK_ACTION
PERF_VIRTUAL_SITE_TABLE::DeletePerfVirtualSiteAction(
    IN PERF_VIRTUAL_SITE * pPerfVirtualSite, 
    IN VOID * pDeleteListHead
    )
{

    DBG_ASSERT( pPerfVirtualSite != NULL );
    DBG_ASSERT( pDeleteListHead != NULL );


    InsertHeadList( 
        ( PLIST_ENTRY ) pDeleteListHead,
        pPerfVirtualSite->GetListEntry()
        );


    return LKA_SUCCEEDED;
    
}   // PERF_VIRTUAL_SITE_TABLE::DeletePerfVirtualSiteAction




#if DBG
/***************************************************************************++

Routine Description:

    Debug dump the table.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
PERF_VIRTUAL_SITE_TABLE::DebugDump(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dumping virtual site table; total count: %lu\n",
            CountOfElementsInTable
            ));
    }


    SuccessCount = Apply( 
                        DebugDumpVirtualSiteAction,
                        NULL
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // PERF_VIRTUAL_SITE_TABLE::DebugDump



/***************************************************************************++

Routine Description:

    A routine that may be applied to all PERF_VIRTUAL_SITEs in the hashtable
    to perform a debug dump. Conforms to the PFnRecordAction prototype.

Arguments:

    pVirtualSite - The virtual site.

    pIgnored - Ignored.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
PERF_VIRTUAL_SITE_TABLE::DebugDumpVirtualSiteAction(
    IN PERF_VIRTUAL_SITE * pPerfVirtualSite, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pPerfVirtualSite != NULL );
    UNREFERENCED_PARAMETER( pIgnored );


    pPerfVirtualSite->DebugDump();
    

    return LKA_SUCCEEDED;
    
}   // PERF_VIRTUAL_SITE_TABLE::DebugDumpVirtualSiteAction
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\precomp.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        22-Jul-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_



// ensure that all GUIDs are initialized
#define INITGUID


// main project include
#include <iis.h>


// other standard includes
#include <winsvc.h>


// local debug header
#include "wasdbgut.h"


// other project includes
#include <httpapi.h>
#include <lkrhash.h>
#include <multisz.hxx>
#include <lock.hxx>
#include <eventlog.hxx>
#include <ipm.hxx>
#include <useracl.h>
#include <wpif.h>
#include <w3ctrlps.h>
#include <winperf.h>
#include <perf_sm.h>
#include <timer.h>
#include <streamfilt.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <iiscnfgp.h>
#include <inetinfo.h>
#include <secfcns.h>
#include <adminmonitor.h>
#include "tokencache.hxx"
#include "regconst.h"

// imported includes
#include <catalog.h>
#include <catmeta.h>

// local includes
#include "main.h"
#include "work_dispatch.h"
#include "ipm_io_s.h"
#include "messaging_handler.h"
#include "work_item.h"
#include "work_queue.h"
#include "application.h"
#include "application_table.h"
#include "wpcounters.h"
#include "perfcount.h"
#include "virtual_site.h"
#include "virtual_site_table.h"
#include "job_object.h"
#include "app_pool.h"
#include "app_pool_table.h"
#include "worker_process.h"
#include "perf_manager.h"
#include "ul_and_worker_manager.h"
#include "control_api_call.h"
#include "control_api.h"
#include "control_api_class_factory.h"
#include "config_change.h"
#include "config_change_sink.h"
#include "config_manager.h"
#include "config_and_control_manager.h"
#include "low_memory_detector.h"
#include "web_admin_service.h"
#include "wasmsg.h"


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\perf_virtual_site_table.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_virtual_site_table.h

Abstract:

    This is a private performance counter hash table
    that contains a snapshot of the sites data to be 
    used for gathering performance counters.  Adds and 
    Deletes are only valid on the Main thread, however
    accessing objects and writing to objects are valid
    on all objects.

Author:

    Emily Kruglick (emilyk)        30-Aug-2000

Revision History:

--*/


#ifndef _perf_virtual_site_table_H_
#define _perf_virtual_site_table_H_

//
// prototypes
//

class PERF_VIRTUAL_SITE_TABLE
    : public CTypedHashTable< PERF_VIRTUAL_SITE_TABLE, PERF_VIRTUAL_SITE, DWORD >
{

public:

    PERF_VIRTUAL_SITE_TABLE(
        )
        : CTypedHashTable< PERF_VIRTUAL_SITE_TABLE, PERF_VIRTUAL_SITE, DWORD >
                ( "PERF_VIRTUAL_SITE_TABLE" )
    { 
    }

    ~PERF_VIRTUAL_SITE_TABLE(
        )
    { 
        DBG_ASSERT( Size() == 0 ); 
    }

    static
    DWORD
    ExtractKey(
        IN const PERF_VIRTUAL_SITE * pPerfVirtualSite
        )  
    { return pPerfVirtualSite->GetVirtualSiteId(); }
    
    static
    DWORD
    CalcKeyHash(
        IN DWORD Key
        ) 
    { return Hash( Key ); }
    
    static
    bool
    EqualKeys(
        IN DWORD Key1,
        IN DWORD Key2
        )
    { return (  Key1 == Key2 ); }
    
    static
    void
    AddRefRecord(
        IN PERF_VIRTUAL_SITE * pPerfVirtualSite,
        IN int IncrementAmount
        ) 
    { /* do nothing*/ }

    VOID
    Terminate(
        );

    static
    LK_ACTION
    DeletePerfVirtualSiteAction(
        IN PERF_VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pDeleteListHead
        );

#if DBG
    VOID
    DebugDump(
        );

    static
    LK_ACTION
    DebugDumpVirtualSiteAction(
        IN PERF_VIRTUAL_SITE * pPerfVirtualSite, 
        IN VOID * pIgnored
        );
#endif  // DBG

private:
    PERF_VIRTUAL_SITE m_AllPerfVirtualSites;

    VOID
    CleanupHash(
        BOOL fAll
        );

};  // perf_virtual_site_table



#endif  // _perf_virtual_site_table_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\ul_and_worker_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ul_and_worker_manager.h

Abstract:

    The IIS web admin service UL and worker manager class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _UL_AND_WORKER_MANAGER_H_
#define _UL_AND_WORKER_MANAGER_H_



//
// forward references
//

class WEB_ADMIN_SERVICE;



//
// common #defines
//

#define UL_AND_WORKER_MANAGER_SIGNATURE         CREATE_SIGNATURE( 'ULWM' )
#define UL_AND_WORKER_MANAGER_SIGNATURE_FREED   CREATE_SIGNATURE( 'ulwX' )



//
// structs, enums, etc.
//

// UL&WM states
typedef enum _UL_AND_WORKER_MANAGER_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedUlAndWorkerManagerState = 1,

    //
    // The UL&WM is running normally.
    //
    RunningUlAndWorkerManagerState,

    //
    // The UL&WM is shutting down. It may be waiting for it's 
    // app pools to shut down too. 
    //
    ShutdownPendingUlAndWorkerManagerState,

    //
    // The UL&WM is now doing it's termination cleanup work. 
    //
    TerminatingUlAndWorkerManagerState,

} UL_AND_WORKER_MANAGER_STATE;

// configuration data for the whole server
// if you add a value here you need to add
// it also to the change flags below.
typedef struct _GLOBAL_SERVER_CONFIG
{
    DWORD MaxConnections;
    DWORD MaxBandwidth;
    DWORD FilterFlags;
    DWORD ConnectionTimeout;
    DWORD MinFileKbSec;
    DWORD HeaderWaitTimeout;
    BOOL  LogInUTF8;

} GLOBAL_SERVER_CONFIG;

// global configuration change flags
typedef struct _GLOBAL_SERVER_CONFIG_CHANGE_FLAGS
{

    DWORD_PTR MaxConnections : 1;
    DWORD_PTR MaxBandwidth : 1;
    DWORD_PTR FilterFlags : 1;
    DWORD_PTR ConnectionTimeout : 1;
    DWORD_PTR MinFileKbSec : 1;
    DWORD_PTR HeaderWaitTimeout : 1;
    DWORD_PTR LogInUTF8 : 1;

} GLOBAL_SERVER_CONFIG_CHANGE_FLAGS;

//
// prototypes
//

class UL_AND_WORKER_MANAGER
{

public:

    UL_AND_WORKER_MANAGER(
        );

    virtual
    ~UL_AND_WORKER_MANAGER(
        );

    HRESULT
    Initialize(
        );

    HRESULT
    CreateAppPool(
        IN LPCWSTR pAppPoolId,
        IN APP_POOL_CONFIG * pAppPoolConfig
        );

    HRESULT
    CreateVirtualSite(
        IN DWORD VirtualSiteId,
        IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig
        );

    HRESULT
    CreateApplication(
        IN DWORD VirtualSiteId,
        IN LPCWSTR pApplicationUrl,
        IN APPLICATION_CONFIG * pApplicationConfig
        );

    HRESULT
    DeleteAppPool(
        IN LPCWSTR pAppPoolId
        );

    HRESULT
    DeleteVirtualSite(
        IN DWORD VirtualSiteId
        );

    HRESULT
    DeleteApplication(
        IN DWORD VirtualSiteId,
        IN LPCWSTR pApplicationUrl
        );

    HRESULT
    ModifyAppPool(
        IN LPCWSTR pAppPoolId,
        IN APP_POOL_CONFIG * pNewAppPoolConfig,
        IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged
        );

    HRESULT
    ModifyVirtualSite(
        IN DWORD VirtualSiteId,
        IN VIRTUAL_SITE_CONFIG * pNewVirtualSiteConfig,
        IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged
        );

    HRESULT
    ModifyApplication(
        IN DWORD VirtualSiteId,
        IN LPCWSTR pApplicationUrl,
        IN APPLICATION_CONFIG * pNewApplicationConfig,
        IN APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged
        );

    HRESULT
    ModifyGlobalData(
        IN GLOBAL_SERVER_CONFIG* pGlobalConfig,
        IN GLOBAL_SERVER_CONFIG_CHANGE_FLAGS* pWhatHasChanged
        );

    HRESULT
    RecycleAppPool(
        IN LPCWSTR pAppPoolId
        );

    HRESULT
    ControlSite(
        IN DWORD VirtualSiteId,
        IN DWORD Command,
        OUT DWORD * pNewState
        );

    HRESULT
    QuerySiteStatus(
        IN DWORD VirtualSiteId,
        OUT DWORD * pCurrentState
        );

    HRESULT
    ControlAllSites(
        IN DWORD Command
        );

    HRESULT
    ActivateUl(
        );

    HRESULT
    DeactivateUl(
        );

    inline
    HANDLE
    GetUlControlChannel(
        )
        const
    {
        DBG_ASSERT( m_UlControlChannel != NULL );
        return m_UlControlChannel;
    }

    HRESULT
    Shutdown(
        );

    VOID
    Terminate(
        );

    HRESULT 
    StartInetinfoWorkerProcess(
        );
     

#if DBG
    VOID
    DebugDump(
        );
#endif  // DBG

    HRESULT
    RemoveAppPoolFromTable(
        IN APP_POOL * pAppPool
        );

    HRESULT
    LeavingLowMemoryCondition(
        );

    HRESULT
    ActivatePerfCounters(
        );

    PERF_MANAGER*
    GetPerfManager(
        )
    { 
        //
        // Note this can be null 
        // if perf counters are not
        // enabled.
        // 

        return m_pPerfManager;
    }

    HRESULT
    RequestCountersFromWorkerProcesses(
        DWORD* pNumberOfProcessesToWaitFor
        )
    {
        return m_AppPoolTable.RequestCounters(pNumberOfProcessesToWaitFor);
    }

    VOID
    ResetAllWorkerProcessPerfCounterState(
        )
    {
        //
        // Ignore the return value.  If there was a
        // failure then there really is nothing we can
        // do to recover, and we are still ok to continue.
        //
        m_AppPoolTable.ResetAllWorkerProcessPerfCounterState();
    }

    VOID
    ReportVirtualSitePerfInfo(
        PERF_MANAGER* pManager,
        BOOL          StructChanged
        )
    {
        m_VirtualSiteTable.ReportPerformanceInfo(pManager, StructChanged);
    }

    DWORD
    GetNumberofVirtualSites(
        )
    {
        return m_VirtualSiteTable.Size();
    }

    VIRTUAL_SITE*
    GetVirtualSite(
        IN DWORD SiteId
        );

    BOOL 
    CheckAndResetSiteChangeFlag(
        )
    {
        //
        // Save the server comment setting
        //
        BOOL SitesHaveChanged = m_SitesHaveChanged;

        //
        // reset it appropriately.
        //
        m_SitesHaveChanged = FALSE;

        //
        // now return the value we saved.
        //
        return SitesHaveChanged;
    }

    HRESULT
    RecoverFromInetinfoCrash(
        );

    BOOL
    AppPoolsExist(
        )
    {
        return ( m_AppPoolTable.Size() > 0 );
    }

private:

    HRESULT
    SetUlMasterState(
        IN HTTP_ENABLED_STATE NewState
        );

    HRESULT
    CheckIfShutdownUnderwayAndNowCompleted(
        );


    DWORD m_Signature;

    // object state
    UL_AND_WORKER_MANAGER_STATE m_State;

    // hashtable of app pools
    APP_POOL_TABLE m_AppPoolTable;

    // hashtable of virtual sites
    VIRTUAL_SITE_TABLE m_VirtualSiteTable;

    // hashtable of applications
    APPLICATION_TABLE m_ApplicationTable;

    // performance counters manager
    PERF_MANAGER* m_pPerfManager;

    // has UL been initialized
    BOOL m_UlInitialized;

    // UL control
    HANDLE m_UlControlChannel;

    // UL filter channel
    HANDLE m_UlFilterChannel;

    BOOL m_SitesHaveChanged;
};  // class UL_AND_WORKER_MANAGER



#endif  // _UL_AND_WORKER_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site.cxx

Abstract:

    This class encapsulates a single virtual site. 

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/



#include "precomp.h"
#include "ilogobj.hxx"
#include <limits.h>

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Structure for mapping counters from the structure they come
// in as to the structure they go out as.
//
typedef struct _PROP_MAP
{
    DWORD PropDisplayOffset;
    DWORD PropInputId;
} PROP_MAP;

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Structure for mapping MAX counters from the structure they are
// stored as to the structure they go out as.
//
typedef struct _PROP_MAX_DESC
{
    ULONG SafetyOffset;
    ULONG DisplayOffset;
    ULONG size;
} PROP_MAX_DESC;


#define LOG_FILE_DIRECTORY_DEFAULT L"%windir%\\system32\\logfiles"

// 
// 16384 bytes = 16 kb
//
#define SMALLEST_TRUNCATE_SIZE 16384

//
// Default connection timeout for sites.
//
#define DEFAULT_CONNECTION_TIMEOUT 900

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Macro for defining mapping of MAX site counters.
//
#define DECLARE_MAX_SITE(Counter)  \
        {   \
        FIELD_OFFSET( W3_MAX_DATA, Counter ),\
        FIELD_OFFSET( W3_COUNTER_BLOCK, Counter ),\
        RTL_FIELD_SIZE( W3_COUNTER_BLOCK, Counter )\
    }

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of Site MAX Fields as they are passed in from
// the perf manager to how the fields are displayed out.
//
PROP_MAX_DESC g_aIISSiteMaxDescriptions[] =
{
    DECLARE_MAX_SITE ( MaxAnonymous ),
    DECLARE_MAX_SITE ( MaxConnections ),
    DECLARE_MAX_SITE ( MaxCGIRequests ),
    DECLARE_MAX_SITE ( MaxBGIRequests ),
    DECLARE_MAX_SITE ( MaxNonAnonymous )
};
DWORD g_cIISSiteMaxDescriptions = sizeof (g_aIISSiteMaxDescriptions) / sizeof( PROP_MAX_DESC );


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of performance counter data from the form it comes in
// as to the form that it goes out to perfmon as.
//
PROP_MAP g_aIISWPSiteMappings[] =
{
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesSent), WPSiteCtrsFilesSent },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesReceived), WPSiteCtrsFilesReceived },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesTotal), WPSiteCtrsFilesTransferred },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentAnonymous), WPSiteCtrsCurrentAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentNonAnonymous), WPSiteCtrsCurrentNonAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalAnonymous), WPSiteCtrsAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNonAnonymous), WPSiteCtrsAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxAnonymous), WPSiteCtrsMaxAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxNonAnonymous), WPSiteCtrsMaxNonAnonUsers },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, LogonAttempts), WPSiteCtrsLogonAttempts },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOptions), WPSiteCtrsOptionsReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPosts), WPSiteCtrsPostReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalGets), WPSiteCtrsGetReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalHeads), WPSiteCtrsHeadReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPuts), WPSiteCtrsPutReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalDeletes), WPSiteCtrsDeleteReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalTraces), WPSiteCtrsTraceReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMove), WPSiteCtrsMoveReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCopy), WPSiteCtrsCopyReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMkcol), WPSiteCtrsMkcolReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPropfind), WPSiteCtrsPropfindReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalProppatch), WPSiteCtrsProppatchReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalSearch), WPSiteCtrsSearchReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLock), WPSiteCtrsLockReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalUnlock), WPSiteCtrsUnlockReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOthers), WPSiteCtrsOtherReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCGIRequests), WPSiteCtrsCgiReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalBGIRequests), WPSiteCtrsIsapiExtReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentCGIRequests), WPSiteCtrsCurrentCgiReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentBGIRequests), WPSiteCtrsCurrentIsapiExtReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxCGIRequests), WPSiteCtrsMaxCgiReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxBGIRequests), WPSiteCtrsMaxIsapiExtReqs },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNotFoundErrors), WPSiteCtrsNotFoundErrors },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLockedErrors), WPSiteCtrsLockedErrors },
};
DWORD g_cIISWPSiteMappings = sizeof (g_aIISWPSiteMappings) / sizeof( PROP_MAP );


//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
#define ULSiteMapMacro(display_counter, ul_counter) \
    { FIELD_OFFSET( W3_COUNTER_BLOCK, display_counter), HttpSiteCounter ## ul_counter }

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of site data in the form it comes from UL to the form
// it goes out to be displayed in.
//
PROP_MAP aIISULSiteMappings[] =
{
    ULSiteMapMacro ( BytesSent, BytesSent ),
    ULSiteMapMacro ( BytesReceived, BytesReceived ),
    ULSiteMapMacro ( BytesTotal, BytesTransfered ),
    ULSiteMapMacro ( CurrentConnections, CurrentConns ),
    ULSiteMapMacro ( MaxConnections, MaxConnections ),

    ULSiteMapMacro ( ConnectionAttempts, ConnAttempts ),
    ULSiteMapMacro ( TotalGets, GetReqs ),
    ULSiteMapMacro ( TotalHeads, HeadReqs ),
    
    ULSiteMapMacro ( TotalRequests, AllReqs ),
    ULSiteMapMacro ( MeasuredBandwidth, MeasuredIoBandwidthUsage ),
    ULSiteMapMacro ( TotalBlockedBandwidthBytes, TotalBlockedBandwidthBytes ),
    ULSiteMapMacro ( CurrentBlockedBandwidthBytes, CurrentBlockedBandwidthBytes ),

};
DWORD cIISULSiteMappings = sizeof (aIISULSiteMappings) / sizeof( PROP_MAP );

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Mapping of performance counter data in the form it goes out,
// this is used to handle calculating totals.
//
PROP_DISPLAY_DESC aIISSiteDescription[] =
{
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesSent),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, FilesSent) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesReceived),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, FilesReceived) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, FilesTotal),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, FilesTotal) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentNonAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentNonAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNonAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalNonAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxNonAnonymous),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxNonAnonymous) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, LogonAttempts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, LogonAttempts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOptions),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalOptions) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPosts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalPosts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalGets),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalGets) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalHeads),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalHeads) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPuts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalPuts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalDeletes),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalDeletes) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalTraces),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalTraces) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMove),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalMove) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCopy),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalCopy) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalMkcol),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalMkcol) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalPropfind),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalPropfind) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalProppatch),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalProppatch) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalSearch),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalSearch) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLock),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalLock) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalUnlock),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalUnlock) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalOthers),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalOthers) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalCGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalCGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalBGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalBGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalLockedErrors),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalLockedErrors) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentCGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentCGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentBGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentBGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxCGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxCGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxBGIRequests),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxBGIRequests) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalNotFoundErrors),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalNotFoundErrors) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, BytesSent),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, BytesSent) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, BytesReceived),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, BytesReceived) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, BytesTotal),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, BytesTotal) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentConnections),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentConnections) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MaxConnections),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MaxConnections) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, ConnectionAttempts),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, ConnectionAttempts) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, MeasuredBandwidth),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, MeasuredBandwidth) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, TotalBlockedBandwidthBytes),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, TotalBlockedBandwidthBytes) },
    { FIELD_OFFSET( W3_COUNTER_BLOCK, CurrentBlockedBandwidthBytes),  RTL_FIELD_SIZE(W3_COUNTER_BLOCK, CurrentBlockedBandwidthBytes) },
};
DWORD cIISSiteDescription = sizeof (aIISSiteDescription) / sizeof( PROP_DISPLAY_DESC );


/***************************************************************************++

Routine Description:

    Constructor for the VIRTUAL_SITE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VIRTUAL_SITE::VIRTUAL_SITE(
    )
{

    m_VirtualSiteId = INVALID_VIRTUAL_SITE_ID;

    m_State = W3_CONTROL_STATE_STOPPED; 

    InitializeListHead( &m_ApplicationListHead );

    m_ApplicationCount = 0;

    m_pBindings = NULL;

    m_pIteratorPosition = NULL;

    m_Autostart = TRUE;

    m_DeleteListEntry.Flink = NULL;
    m_DeleteListEntry.Blink = NULL; 

    m_LogFileDirectory = NULL;

    memset(m_VirtualSiteDirectory, 0, MAX_SIZE_OF_SITE_DIRECTORY_NAME);

    m_LoggingEnabled = FALSE;

    m_LoggingFormat = HttpLoggingTypeMaximum;

    m_LoggingFilePeriod = 0;

    m_LoggingFileTruncateSize = 0;

    m_LoggingExtFileFlags = 0;

    m_LogFileLocaltimeRollover = 0;

    m_ServerCommentChanged = FALSE;

    m_MemoryOffset = NULL;

    //
    // Assume all created sites are
    // in the metabase.
    //
    m_VirtualSiteInMetabase = TRUE;

    //
    // Tracks start time of the virtual site.
    //
    m_SiteStartTime = 0;

    //
    // Clear out all the counter data
    // and then set the size of the counter data into
    // the structure.
    //
    memset ( &m_MaxSiteCounters, 0, sizeof( W3_MAX_DATA ) );

    memset ( &m_SiteCounters, 0, sizeof( W3_COUNTER_BLOCK ) );

    m_SiteCounters.PerfCounterBlock.ByteLength = sizeof ( W3_COUNTER_BLOCK );

    //
    // Make sure the root application for the site is set to NULL.
    //
    m_pRootApplication = NULL;

    m_MaxConnections = ULONG_MAX;

    m_MaxBandwidth = ULONG_MAX;

    m_ConnectionTimeout = DEFAULT_CONNECTION_TIMEOUT;

    m_Signature = VIRTUAL_SITE_SIGNATURE;

}   // VIRTUAL_SITE::VIRTUAL_SITE



/***************************************************************************++

Routine Description:

    Destructor for the VIRTUAL_SITE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VIRTUAL_SITE::~VIRTUAL_SITE(
    )
{

    DBG_ASSERT( m_Signature == VIRTUAL_SITE_SIGNATURE );

    m_Signature = VIRTUAL_SITE_SIGNATURE_FREED;

    //
    // Set the virtual site state to stopped.  (In Metabase does not affect UL)
    //

    DBG_REQUIRE( SUCCEEDED( ChangeState( W3_CONTROL_STATE_STOPPED, S_OK, m_VirtualSiteInMetabase ) ) );


    //
    // The virtual site should not go away with any applications still 
    // referring to it.
    //
    
    DBG_ASSERT( IsListEmpty( &m_ApplicationListHead ) );
    DBG_ASSERT( m_ApplicationCount == 0 );
    DBG_ASSERT( m_pRootApplication == NULL );


    if ( m_pBindings != NULL )
    {
        delete m_pBindings;
        m_pBindings = NULL;
    }

    if (m_LogFileDirectory)
    {
        DBG_REQUIRE( GlobalFree( m_LogFileDirectory ) == NULL );
        m_LogFileDirectory = NULL;  
    }

}   // VIRTUAL_SITE::~VIRTUAL_SITE



/***************************************************************************++

Routine Description:

    Initialize the virtual site instance.

Arguments:

    VirtualSiteId - ID for the virtual site.

    pVirtualSiteConfig - The configuration for this virtual site. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::Initialize(
    IN DWORD VirtualSiteId,
    IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig
    )
{

    HRESULT hr = S_OK;
    DWORD NewState = W3_CONTROL_STATE_INVALID; 


    DBG_ASSERT( pVirtualSiteConfig != NULL );


    m_VirtualSiteId = VirtualSiteId;


    //
    // Allocate the object that will hold this site's bindings.
    //

    //
    // BUGBUG Should we just make this a member of this object,
    // instead of a separate allocation? 
    //

    m_pBindings = new MULTISZ();

    if ( m_pBindings == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }


    //
    // Set the initial configuration.
    //

    hr = SetConfiguration( pVirtualSiteConfig, NULL );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting virtual site configuration failed\n"
            ));

        goto exit;
    }


    //
    // Finally, attempt to start the virtual site. Note that this
    // is not a direct command, because it is happening due to service
    // startup, site addition, etc.
    //

    hr = ProcessStateChangeCommand( W3_CONTROL_COMMAND_START, FALSE, &NewState );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Changing state failed\n"
            ));

        goto exit;
    }


exit:

    return hr;
    
}   // VIRTUAL_SITE::Initialize



/***************************************************************************++

Routine Description:

    Accept a set of configuration parameters for this virtual site. 

Arguments:

    pVirtualSiteConfig - The configuration for this virtual site. 

    pWhatHasChanged - Which particular configuration values were changed.
    This is always provided in change notify cases; it is always NULL in
    initial read cases. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::SetConfiguration(
    IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig,
    IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;


    DBG_ASSERT( pVirtualSiteConfig != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New configuration for virtual site %lu\n",
            m_VirtualSiteId            
            ));
    }


    //
    // On initial startup only, read the auto start flag.
    //

    if ( pWhatHasChanged == NULL )
    {
        m_Autostart = pVirtualSiteConfig->Autostart;
    }


    //
    // CODEWORK Eventually other site properties will have to be dealt 
    // with here too. 
    //

    //
    // See if the bindings have been set or changed, and if so, handle it.
    //

    if ( ( pWhatHasChanged == NULL ) || ( pWhatHasChanged->pBindingsStrings ) )
    {

        //
        // Copy the bindings. Note that this automatically frees any old  
        // bindings being held. 
        //

        Success = m_pBindings->Copy( 
                                    pVirtualSiteConfig->pBindingsStrings, 
                                    pVirtualSiteConfig->BindingsStringsCountOfBytes 
                                    );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() ); 

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying bindings failed\n"
                ));

            goto exit;
        }


        //
        // Since the bindings changed, inform all apps in this virtual site
        // to re-register their fully qualified URLs with UL.
        //

        hr = NotifyApplicationsOfBindingChange();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Notifying apps of binding change failed\n"
                ));

            goto exit;

        }

    }

    if (  pWhatHasChanged == NULL || pWhatHasChanged->MaxBandwidth )
    {
        m_MaxBandwidth = pVirtualSiteConfig->MaxBandwidth;

        if ( m_pRootApplication )
        {
            //
            // if we have the root application we can now set
            // the properties.  if not, it will be taken care
            // of when the root application is configured.
            //

            hr = m_pRootApplication->ConfigureMaxBandwidth();
            if ( FAILED( hr ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Notifying default app of bandwidth changes failed\n"
                    ));

                goto exit;
            }
        }
    }

    if (  pWhatHasChanged == NULL || pWhatHasChanged->MaxConnections )
    {
        m_MaxConnections = pVirtualSiteConfig->MaxConnections;

        if ( m_pRootApplication )
        {
            //
            // if we have the root application we can now set
            // the properties.  if not, it will be taken care
            // of when the root application is configured.
            //

            hr = m_pRootApplication->ConfigureMaxConnections();
            if ( FAILED( hr ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Notifying default app of max connections changes failed\n"
                    ));

                goto exit;
            }
        }

    }

    if (  pWhatHasChanged == NULL || pWhatHasChanged->ConnectionTimeout )
    {
        m_ConnectionTimeout = pVirtualSiteConfig->ConnectionTimeout;

        if ( m_pRootApplication )
        {
            //
            // if we have the root application we can now set
            // the properties.  if not, it will be taken care
            // of when the root application is configured.
            //

            hr = m_pRootApplication->ConfigureConnectionTimeout();
            if ( FAILED( hr ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Notifying default app of connection timeout changes failed\n"
                    ));

                goto exit;
            }
        }

    }

    if ( ( pWhatHasChanged == NULL ) || (pWhatHasChanged->pServerComment) )
    {

        
        if ( pVirtualSiteConfig->pServerComment != NULL && 
             pVirtualSiteConfig->pServerComment[0] != '\0' )
        {
            DWORD len = wcslen ( pVirtualSiteConfig->pServerComment ) + 1;

            //
            // Based on the if above, we should never get a length of 
            // less than one.
            //
            DBG_ASSERT (len > 1);

            //
            // Truncate if the comment is too long.
            //
            if ( len > MAX_INSTANCE_NAME )
            {
                len = MAX_INSTANCE_NAME;
            }

            wcsncpy ( m_ServerComment, pVirtualSiteConfig->pServerComment, len );

            // 
            // null terminate the last character if we need 
            // just in case we copied all the way to the end.
            //
            m_ServerComment[ MAX_INSTANCE_NAME - 1 ] = '\0';

        }
        else
        {
            //
            // If there is no server comment then use W3SVC and the site id.
            //
            wsprintf( m_ServerComment, L"W3SVC%d", m_VirtualSiteId );
        }
        
        // save the new server comment and mark it
        // as not updated in perf counters.

        m_ServerCommentChanged = TRUE;

    }

    hr = EvaluateLoggingChanges(pVirtualSiteConfig, pWhatHasChanged);
    if ( FAILED(hr) )
    {
        DPERROR(( 
        DBG_CONTEXT,
        hr,
        "Evaluating changes in logging properties failed\n"
        ));

        goto exit;
    }

    // Only notify the default application of logging changes 
    // if some logging changes were made.  If none were made
    // than EvaluateLoggingChanges will return S_FALSE.
    if ( hr == S_OK )
    {
        // Need to refresh the default application log information in UL.
        hr = NotifyDefaultApplicationOfLoggingChanges();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Notifying default app of logging changes failed\n"
                ));

            goto exit;
        }
    }
    else
    {
        DBG_ASSERT ( hr == S_FALSE );

        // If hr was S_FALSE, we don't want to pass it
        // back out of this function, so reset it.
        hr = S_OK;
    }


#if DBG
    //
    // Dump the configuration.
    //

    DebugDump();
#endif  // DBG


exit:

    return hr;

}   // VIRTUAL_SITE::SetConfiguration

/***************************************************************************++

Routine Description:

    Routine adds the counters sent in to the counters the site is holding.

Arguments:

    COUNTER_SOURCE_ENUM CounterSource - Identifier of the where
                                        the counters are coming from.
    IN LPVOID pCountersToAddIn - Pointer to the counters to add in.


Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::AggregateCounters(
    IN COUNTER_SOURCE_ENUM CounterSource,
    IN LPVOID pCountersToAddIn
    )
{

    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;

    DBG_ASSERT ( pCountersToAddIn );

    //
    // Determine what mapping arrays to use.
    //
    if ( CounterSource == WPCOUNTERS )
    {
        pInputPropDesc = aIISWPSiteDescription;
        pPropMap = g_aIISWPSiteMappings;
        MaxCounters = g_cIISWPSiteMappings; 
    }
    else
    {
        DBG_ASSERT ( CounterSource == ULCOUNTERS );

        pInputPropDesc = aIISULSiteDescription;
        pPropMap = aIISULSiteMappings;
        MaxCounters = cIISULSiteMappings; 
    }

    LPVOID pCounterBlock = &m_SiteCounters;

    DWORD  PropInputId = 0;
    DWORD  PropDisplayId = 0;

    //
    // Go through each counter and handle it appropriately.
    //
    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].Size == sizeof( DWORD ) )
        {
            DWORD* pDWORDToUpdate = (DWORD*) ( (LPBYTE) pCounterBlock 
                                    + pPropMap[PropDisplayId].PropDisplayOffset );

            DWORD* pDWORDToUpdateWith =  (DWORD*) ( (LPBYTE) pCountersToAddIn 
                                    + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not happen 
            // at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pDWORDToUpdate = *pDWORDToUpdate + *pDWORDToUpdateWith;


        }
        else
        {
            DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDToUpdate = (ULONGLONG*) ( (LPBYTE) pCounterBlock 
                                    + pPropMap[PropDisplayId].PropDisplayOffset );

            ULONGLONG* pQWORDToUpdateWith =  (ULONGLONG*) ( (LPBYTE) pCountersToAddIn 
                                    + pInputPropDesc[PropInputId].Offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not happen 
            // at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pQWORDToUpdate = *pQWORDToUpdate + *pQWORDToUpdateWith;

        }
            
    }
    
}  // VIRTUAL_SITE::AggregateCounters

/***************************************************************************++

Routine Description:

    Routine figures out the maximum value for the counters
    and saves it back into the MaxCounters Structure.

Arguments:

    NONE

Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::AdjustMaxValues(
    )
{

    for (   ULONG PropMaxId = 0 ; 
            PropMaxId < g_cIISSiteMaxDescriptions; 
            PropMaxId++ )
    {

        if ( g_aIISSiteMaxDescriptions[PropMaxId].size == sizeof( DWORD ) )
        {
            DWORD* pDWORDAsIs = (DWORD*) ( (LPBYTE) &m_SiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].DisplayOffset );

            DWORD* pDWORDToSwapWith =  (DWORD*) ( (LPBYTE) &m_MaxSiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].SafetyOffset );

            
            if ( *pDWORDAsIs < *pDWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pDWORDAsIs = *pDWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pDWORDToSwapWith = *pDWORDAsIs;
            }

        }
        else
        {
            DBG_ASSERT ( g_aIISSiteMaxDescriptions[PropMaxId].size == sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDAsIs = (ULONGLONG*) ( (LPBYTE) &m_SiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].DisplayOffset );

            ULONGLONG* pQWORDToSwapWith =  (ULONGLONG*) ( (LPBYTE) &m_MaxSiteCounters 
                                    + g_aIISSiteMaxDescriptions[PropMaxId].SafetyOffset );

            
            if ( *pQWORDAsIs < *pQWORDToSwapWith )
            {
                //
                // We have seen a max that is greater than the
                // max we are now viewing.
                //
                *pQWORDAsIs = *pQWORDToSwapWith;
            }
            else
            {
                //
                // We have a new max so save it in the safety structure
                //
                *pQWORDToSwapWith = *pQWORDAsIs;
            }

        }  // end of decision on which size of data we are dealing with
            
    } // end of for loop

    //
    // Figure out the appropriate ServiceUptime and save it in as well.
    //

    if (  m_SiteStartTime != 0 )
    {
        m_SiteCounters.ServiceUptime = GetCurrentTimeInSeconds() - m_SiteStartTime;
    }
    else
    {
        m_SiteCounters.ServiceUptime = 0;
    }
    
} // end of VIRTUAL_SITE::AdjustMaxValues

/***************************************************************************++

Routine Description:

    Routine will zero out any values that should be zero'd before we
    gather performance counters again.

Arguments:

    None

Return Value:

    VOID

--***************************************************************************/
VOID
VIRTUAL_SITE::ClearAppropriatePerfValues(
    )
{

    HTTP_PROP_DESC* pInputPropDesc = NULL;
    PROP_MAP*       pPropMap = NULL;
    DWORD           MaxCounters = 0;
    DWORD           PropInputId = 0;
    DWORD           PropDisplayId = 0;
    LPVOID          pCounterBlock = &m_SiteCounters;

    //
    // First walk through the WP Counters and Zero appropriately
    //
    pInputPropDesc = aIISWPSiteDescription;
    pPropMap = g_aIISWPSiteMappings;
    MaxCounters = g_cIISWPSiteMappings; 

    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + 
                                        pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + 
                                        pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }

    //
    // Now walk through the UL Counters and Zero appropriately
    //
    pInputPropDesc = aIISULSiteDescription;
    pPropMap = aIISULSiteMappings;
    MaxCounters = cIISULSiteMappings; 

    for (   PropDisplayId = 0 ; 
            PropDisplayId < MaxCounters; 
            PropDisplayId++ )
    {
        PropInputId = pPropMap[PropDisplayId].PropInputId;

        if ( pInputPropDesc[PropInputId].WPZeros == FALSE )
        {
            if ( pInputPropDesc[PropInputId].Size == sizeof ( DWORD ) )
            {
                *((DWORD*)( (LPBYTE) pCounterBlock + 
                                         pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
            else // Handle QWORD
            {
                DBG_ASSERT ( pInputPropDesc[PropInputId].Size == sizeof ( ULONGLONG ) );

                *((ULONGLONG*)( (LPBYTE) pCounterBlock + 
                                         pPropMap[PropDisplayId].PropDisplayOffset )) = 0;
            }
        }
    }
    
}  // VIRTUAL_SITE::ClearAppropriatePerfValues

/***************************************************************************++

Routine Description:

    Routine returns the display map for sites.

Arguments:

    None

Return Value:

    PROP_DISPLAY_DESC*

--***************************************************************************/
PROP_DISPLAY_DESC*
VIRTUAL_SITE::GetDisplayMap(
    )
{

    return aIISSiteDescription;

} // VIRTUAL_SITE::GetDisplayMap


/***************************************************************************++

Routine Description:

    Routine returns the size of the display map.

Arguments:

    None

Return Value:

    DWORD

--***************************************************************************/
DWORD
VIRTUAL_SITE::GetSizeOfDisplayMap(
        )
{

    return cIISSiteDescription;

} // VIRTUAL_SITE::GetSizeOfDisplayMap



/***************************************************************************++

Routine Description:

    Register an application as being part of this virtual site.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::AssociateApplication(
    IN APPLICATION * pApplication
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pApplication != NULL );


    InsertHeadList( 
        &m_ApplicationListHead, 
        pApplication->GetVirtualSiteListEntry() 
        );
        
    m_ApplicationCount++;

    //
    // If we do not know which is the root application,
    // we should check to see if this might be it.
    //
    if ( m_pRootApplication == NULL )
    {
        LPCWSTR pApplicationUrl = pApplication->GetApplicationId()->pApplicationUrl;

        if (pApplicationUrl && wcscmp(pApplicationUrl, L"/") == 0)
        {
            m_pRootApplication = pApplication;
        }
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Associated application %lu:\"%S\" with virtual site %lu; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->pApplicationUrl,
            m_VirtualSiteId,
            m_ApplicationCount
            ));
    }


    return hr;
    
}   // VIRTUAL_SITE::AssociateApplication



/***************************************************************************++

Routine Description:

    Remove the registration of an application that is part of this virtual 
    site.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::DissociateApplication(
    IN APPLICATION * pApplication
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pApplication != NULL );


    RemoveEntryList( pApplication->GetVirtualSiteListEntry() );
    ( pApplication->GetVirtualSiteListEntry() )->Flink = NULL; 
    ( pApplication->GetVirtualSiteListEntry() )->Blink = NULL; 
    
    m_ApplicationCount--;

    //
    // If we are holding the root application, verify
    // that this is not it. Otherwise we should release
    // it as well.
    //
    if ( m_pRootApplication != NULL )
    {
        if ( m_pRootApplication == pApplication )
        {
            // if the pointer was the same application
            // we are working on, then let go of the 
            // application.

            m_pRootApplication = NULL;
        }
    }
    
    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dissociated application %lu:\"%S\" from virtual site %lu; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->pApplicationUrl,
            m_VirtualSiteId,
            m_ApplicationCount
            ));
    }


    return hr;
    
}   // VIRTUAL_SITE::DissociateApplication



/***************************************************************************++

Routine Description:

    Reset the URL prefix iterator for this virtual site back to the 
    beginning of the list of prefixes.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE::ResetUrlPrefixIterator(
    )
{

    m_pIteratorPosition = NULL;

    return;

}   // VIRTUAL_SITE::ResetUrlPrefixIterator



/***************************************************************************++

Routine Description:

    Return the next URL prefix, and advance the position of the iterator. 
    If there are no prefixes left, return NULL.

Arguments:

    None.

Return Value:

    LPCWSTR - The URL prefix, or NULL if the iterator is that the end of the
    list.

--***************************************************************************/

LPCWSTR
VIRTUAL_SITE::GetNextUrlPrefix(
    )
{

    LPCWSTR pUrlPrefixToReturn = NULL;


    DBG_ASSERT( m_pBindings != NULL );


    //
    // See if we are at the beginning, or already part way through
    // the sequence.
    //

    if ( m_pIteratorPosition == NULL )
    {
        pUrlPrefixToReturn = m_pBindings->First();
    }
    else
    {
        pUrlPrefixToReturn = m_pBindings->Next( m_pIteratorPosition );
    }


    //
    // Remember where we are in the sequence for next time.
    //

    m_pIteratorPosition = pUrlPrefixToReturn;


    return pUrlPrefixToReturn;

}   // VIRTUAL_SITE::GetNextUrlPrefix



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the delete list LIST_ENTRY 
    pointer of a VIRTUAL_SITE to the VIRTUAL_SITE as a whole.

Arguments:

    pDeleteListEntry - A pointer to the m_DeleteListEntry member of a 
    VIRTUAL_SITE.

Return Value:

    The pointer to the containing VIRTUAL_SITE.

--***************************************************************************/

// note: static!
VIRTUAL_SITE *
VIRTUAL_SITE::VirtualSiteFromDeleteListEntry(
    IN const LIST_ENTRY * pDeleteListEntry
)
{

    VIRTUAL_SITE * pVirtualSite = NULL;

    DBG_ASSERT( pDeleteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pVirtualSite = CONTAINING_RECORD(
                            pDeleteListEntry,
                            VIRTUAL_SITE,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pVirtualSite->m_Signature == VIRTUAL_SITE_SIGNATURE );

    return pVirtualSite;

}   // VIRTUAL_SITE::VirtualSiteFromDeleteListEntry



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE::DebugDump(
    )
{

    LPCWSTR pPrefix = NULL;
    PLIST_ENTRY pListEntry = NULL;
    APPLICATION * pApplication = NULL;


    //
    // Output the site id, and its set of URL prefixes.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "\n********Virtual site id: %lu; \n"
            "         ConnectionTimeout: %u\n"
            "         MaxConnections: %u\n"
            "         MaxBandwidth: %u\n"
            "         Url prefixes:\n",
            GetVirtualSiteId(),
            m_ConnectionTimeout,
            m_MaxConnections,
            m_MaxBandwidth
            ));
    }

    ResetUrlPrefixIterator();

    while ( ( pPrefix = GetNextUrlPrefix() ) != NULL )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                ">>>>>>>>%S\n",
                pPrefix
                ));
        }

    }


    //
    // List config for this site.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Autostart: %S\n",
            ( m_Autostart ? L"TRUE" : L"FALSE" )
            ));

    }


    //
    // List the applications of this site.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            ">>>>Virtual site's applications:\n"
            ));
    }


    pListEntry = m_ApplicationListHead.Flink;

    while ( pListEntry != &m_ApplicationListHead )
    {
    
        DBG_ASSERT( pListEntry != NULL );

        pApplication = APPLICATION::ApplicationFromVirtualSiteListEntry( pListEntry );


        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                ">>>>>>>>%S\n",
                pApplication->GetApplicationId()->pApplicationUrl
                ));
        }


        pListEntry = pListEntry->Flink;

    }


    return;
    
}   // VIRTUAL_SITE::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Attempt to apply a state change command to this object. This could
    fail if the state change is invalid. 

Arguments:

    Command - The requested state change command.

    DirectCommand - TRUE if the command was targetted directly at this
    virtual site, FALSE if it is an inherited command due to a direct 
    command to the service. 

    pNewState - The state of this object after attempting to apply the 
    command.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::ProcessStateChangeCommand(
    IN DWORD Command,
    IN BOOL DirectCommand,
    OUT DWORD * pNewState
    )
{

    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;
    DWORD VirtualSiteState = W3_CONTROL_STATE_INVALID;
    DWORD ServiceState = 0;


    //
    // Determine the current state of affairs.
    //

    VirtualSiteState = GetState();
    ServiceState = GetWebAdminService()->GetServiceState();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Received state change command for virtual site: %lu; command: %lu, site state: %lu, service state: %lu\n",
            m_VirtualSiteId,
            Command,
            VirtualSiteState,
            ServiceState
            ));
    }


    //
    // Update the autostart setting if appropriate.
    //

    if ( DirectCommand && 
         ( ( Command == W3_CONTROL_COMMAND_START ) || 
           ( Command == W3_CONTROL_COMMAND_STOP ) ) )
    {

        //
        // Set autostart to TRUE for a direct start command; set it
        // to FALSE for a direct stop command.
        //

        m_Autostart = ( Command == W3_CONTROL_COMMAND_START ) ? TRUE : FALSE;

        hr = GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
            SetVirtualSiteAutostart(
                m_VirtualSiteId,
                m_Autostart
                );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting autostart in config store for virtual site failed\n"
                ));

            //
            // Press on in the face of errors.
            //

            hr = S_OK;

        }

    }


    //
    // Figure out which command has been issued, and see if it should
    // be acted on or ignored, given the current state.
    //
    // There is a general rule of thumb that a child entity (such as
    // an virtual site) cannot be made more "active" than it's parent
    // entity currently is (the service). 
    //

    switch ( Command )
    {

    case W3_CONTROL_COMMAND_START:

        //
        // If the site is stopped, then start it. If it's in any other state,
        // this is an invalid state transition.
        //
        // Note that the service must be in the started or starting state in 
        // order to start a site.
        //

        if ( VirtualSiteState == W3_CONTROL_STATE_STOPPED &&
             ( ( ServiceState == SERVICE_RUNNING ) || ( ServiceState == SERVICE_START_PENDING ) ) )
        {

            //
            // If this is a flowed (not direct) command, and autostart is false, 
            // then ignore this command. In other words, the user has indicated
            // that this site should not be started at service startup, etc.
            //

            if ( ( ! DirectCommand ) && ( ! m_Autostart ) )
            {

                IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
                {
                    DBGPRINTF((
                        DBG_CONTEXT, 
                        "Ignoring flowed site start command because autostart is false for virtual site: %lu\n",
                        m_VirtualSiteId
                        ));
                }

            }
            else
            {

                hr = ApplyStateChangeCommand(
                        W3_CONTROL_COMMAND_START,
                        DirectCommand,
                        W3_CONTROL_STATE_STARTED
                        );

            }

        }
        else 
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SERVICE_CONTROL );
        }

        break;

    case W3_CONTROL_COMMAND_STOP:

        //
        // If the site is started or paused, then stop it. If it's in 
        // any other state, this is an invalid state transition.
        //
        // Note that since we are making the site less active,
        // we can ignore the state of the service.  
        //

        if ( ( VirtualSiteState == W3_CONTROL_STATE_STARTED ) ||
             ( VirtualSiteState == W3_CONTROL_STATE_PAUSED ) )
        {

            //
            // CODEWORK Consider only changing the state to be 
            // W3_CONTROL_STATE_STOPPING here, and then waiting until
            // all current worker processes have been rotated or shut
            // down (in order to unload components) before setting the
            // W3_CONTROL_STATE_STOPPED state. 
            //

            hr = ApplyStateChangeCommand(
                    W3_CONTROL_COMMAND_STOP,
                    DirectCommand,
                    W3_CONTROL_STATE_STOPPED
                    );

        } 
        else 
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SERVICE_CONTROL );
        }

        break;

    case W3_CONTROL_COMMAND_PAUSE:

        //
        // If the site is started, then pause it. If it's in any other
        // state, this is an invalid state transition.
        //
        // Note that since we are making the site less active,
        // we can ignore the state of the service.  
        //

        if ( VirtualSiteState == W3_CONTROL_STATE_STARTED ) 
        {

            hr = ApplyStateChangeCommand(
                    W3_CONTROL_COMMAND_PAUSE,
                    DirectCommand,
                    W3_CONTROL_STATE_PAUSED
                    );

        } 
        else 
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SERVICE_CONTROL );
        }

        break;

    case W3_CONTROL_COMMAND_CONTINUE:

        //
        // If the site is paused, then continue it. If it's in any other 
        // state, this is an invalid state transition.
        //
        // Note that the service must be in the started or continuing state 
        // in order to start a site.
        //

        if ( VirtualSiteState == W3_CONTROL_STATE_PAUSED &&
             ( ( ServiceState == SERVICE_RUNNING ) || ( ServiceState == SERVICE_CONTINUE_PENDING ) ) )
        {

            hr = ApplyStateChangeCommand(
                    W3_CONTROL_COMMAND_CONTINUE,
                    DirectCommand,
                    W3_CONTROL_STATE_STARTED
                    );

        } 
        else 
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SERVICE_CONTROL );
        }

        break;

    default:

        //
        // Invalid command!
        //

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing virtual site state change command failed\n"
            ));


        //
        // In case of failure, reset to the state we were in to start with,
        // and update the config store appropriately with the error value.
        //

        hr2 = ChangeState( VirtualSiteState, hr, TRUE );

        if ( FAILED( hr2 ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr2,
                "Changing virtual site state failed\n"
                ));

            //
            // Ignore failures here and press on...
            //

        }

    }


    //
    // Set the out parameter.
    //

    *pNewState = GetState();


    return hr;

}   // VIRTUAL_SITE::ProcessStateChangeCommand



/***************************************************************************++

Routine Description:

    Apply a state change command that has already been validated, by updating
    the state of this site, and also flowing the command to this site's apps.

Arguments:

    Command - The requested state change command.

    DirectCommand - TRUE if the command was targetted directly at this
    virtual site, FALSE if it is an inherited command due to a direct 
    command to the service. 

    NewState - The new state of this object. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::ApplyStateChangeCommand(
    IN DWORD Command,
    IN BOOL DirectCommand,
    IN DWORD NewState
    )
{

    HRESULT hr = S_OK;

    hr = ChangeState( NewState, S_OK, TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Changing virtual site state failed\n"
            ));

        goto exit;
    }


    //
    // Alter the urls to either be there or not
    // be there based on the new settings of the site.
    //
    // This will fail if we are starting and we 
    // have invalid sites, in that case we do want
    // to jump over setting up the start time for 
    // the virtual site. 
    //

    hr = NotifyApplicationsOfBindingChange( );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reregistering all applications of virtual site failed\n"
            ));

        goto exit;
    }

    //
    // Need to update the start tick time if we are starting  
    // or stopping a virtual site.
    //
   
    if ( Command == W3_CONTROL_COMMAND_STOP )
    {
        m_SiteStartTime =  0;
    }
  
    if ( Command == W3_CONTROL_COMMAND_START )
    {
        m_SiteStartTime = GetCurrentTimeInSeconds();
    }

exit:

    return hr;

}   // VIRTUAL_SITE::ApplyStateChangeCommand

/***************************************************************************++

Routine Description:

    Changes the state of the virtual server when we fail to bind the urls
    in the metabase.

Arguments:

    HRESULT hrReturned

Return Value:

    HRESULT

--***************************************************************************/

VOID
VIRTUAL_SITE::FailedToBindUrlsForSite(
    HRESULT hrReturned
    )
{

    HRESULT hr = S_OK;

    hr = ChangeState( W3_CONTROL_STATE_STOPPED, hrReturned, TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Changing virtual site state failed\n"
            ));

        goto exit;
    }


    //
    // Alter the urls to either be there or not
    // be there based on the new settings of the site.
    //

    hr = NotifyApplicationsOfBindingChange( );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reregistering all applications of virtual site failed\n"
            ));

        goto exit;
    }

exit:

    return;


}   // VIRTUAL_SITE::FailedToBindUrlsForSite


/***************************************************************************++

Routine Description:

    Update the state of this object.

Arguments:

    NewState - The new state of this object. 

    Error - The error value, if any, to be written out to the config store
    for compatibility. 

    WriteToMetabase - Flag to notify if we should actually update the metabase 
                      with the new state or not.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::ChangeState(
    IN DWORD NewState,
    IN HRESULT Error,
    IN BOOL WriteToMetabase
    )
{

    HRESULT hr = S_OK;

    m_State = NewState;

    if ( WriteToMetabase )
    {

        hr = RecordState(Error);

        if ( FAILED( hr ) )
        {   

            //
            // Press on in the face of errors.
            //

            hr = S_OK;
        }

    }

    return hr;

}   // VIRTUAL_SITE::ChangeState

/***************************************************************************++

Routine Description:

    Update the state of this object in the metabase

Arguments:

    Error - The Win32Error for the site, causing the state to change

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::RecordState(
    HRESULT Error
    )
{

    HRESULT hr = S_OK;

    hr = GetWebAdminService()->GetConfigAndControlManager()->GetConfigManager()->
        SetVirtualSiteStateAndError(
            m_VirtualSiteId,
            m_State,
            ( FAILED( Error ) ? WIN32_FROM_HRESULT( Error ) : NO_ERROR )
            );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting state and error in config store for virtual site failed\n"
            ));

    }

    return hr;

}   // VIRTUAL_SITE::RecordState



/***************************************************************************++

Routine Description:

    Notify default application to update it's logging information.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::NotifyDefaultApplicationOfLoggingChanges(
    )
{

    HRESULT hr = S_OK;
    //
    // if we have a root application then tell
    // the application about the properties.  If not
    // we will find out about them when we configure
    // the application for the first time.
    //
    if ( m_pRootApplication )
    {
        hr = m_pRootApplication->RegisterLoggingProperties();

        if ( FAILED( hr ) )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Re-registering application's logging properties failed\n"
                ));

            //
            // Press on in the face of errors on a particular application.
            //

            hr = S_OK;
        }
        
    }

    return hr;

}   // VIRTUAL_SITE::NotifyDefaultApplicationOfLoggingChanges


/***************************************************************************++

Routine Description:

    Notify all applications in this site that the site bindings have changed.

    Note: This is also used if we are trying to remove or add all urls for the site.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE::NotifyApplicationsOfBindingChange(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    APPLICATION * pApplication = NULL;


    pListEntry = m_ApplicationListHead.Flink;

    while ( pListEntry != &m_ApplicationListHead )
    {
        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pApplication = APPLICATION::ApplicationFromVirtualSiteListEntry( pListEntry );


        //
        // Tell the application to re-register it's fully qualified URLs.
        //

        hr = pApplication->ReregisterURLs();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Re-registering application's URLs (due to a site bindings change) failed\n"
                ));

            //
            // we expect the errors in Reregister to come from adding the urls.  if
            // adding the urls fails then the application will make this site stop
            // before it returns.
            //
            DBG_ASSERT ( m_State == W3_CONTROL_STATE_STOPPED );

            // 
            // we can lose the error since the site has been stopped for us.
            //
            hr = S_OK;

            break;
        }

        pListEntry = pNextListEntry;
        
    }

    return hr;

}   // VIRTUAL_SITE::NotifyApplicationsOfBindingChange


/***************************************************************************++

Routine Description:

    Evaluate (and process) any log file changes.

Arguments:

    None.

Return Value:

    HRESULT
        S_FALSE = No Logging Changes
        S_OK    = Logging Changes ocurred

--***************************************************************************/

HRESULT
VIRTUAL_SITE::EvaluateLoggingChanges(
    IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig,
    IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{
    BOOL LoggingHasChanged = FALSE;

    // LogType
    if ( ( pWhatHasChanged == NULL ) || ( pWhatHasChanged->LogType ) )
    {
        m_LoggingEnabled = (pVirtualSiteConfig->LogType == 1);
        LoggingHasChanged = TRUE;
    }

    // LogFormat
    if ( ( pWhatHasChanged == NULL ) || ( pWhatHasChanged->pLogPluginClsid ) )
    {
        // If the logging type is set to maximum then we don't support
        // the particular type of logging that has been asked for.
        m_LoggingFormat = HttpLoggingTypeMaximum;

        // Validate that the clsid actually exists before using it.
        if (pVirtualSiteConfig->pLogPluginClsid)
        {
            if (_wcsicmp (pVirtualSiteConfig->pLogPluginClsid
                        , EXTLOG_CLSID) == 0)
            {
                m_LoggingFormat = HttpLoggingTypeW3C;
            }
            else if (_wcsicmp (pVirtualSiteConfig->pLogPluginClsid
                            , ASCLOG_CLSID) == 0)
            {
                m_LoggingFormat = HttpLoggingTypeIIS;
            }
            else if (_wcsicmp (pVirtualSiteConfig->pLogPluginClsid
                            , NCSALOG_CLSID) == 0)
            {
                m_LoggingFormat = HttpLoggingTypeNCSA;
            }
        }

        LoggingHasChanged = TRUE;
    }

    // LogFileDirectory
    if (( pWhatHasChanged == NULL) || (pWhatHasChanged->pLogFileDirectory))
    {
        // First cleanup if we all ready had a log file directory stored.
        if (m_LogFileDirectory != NULL)
        {
            DBG_REQUIRE( GlobalFree( m_LogFileDirectory ) == NULL );
            m_LogFileDirectory = NULL;  
        }

        DBG_ASSERT ( pVirtualSiteConfig->pLogFileDirectory );
        DBG_ASSERT ( GetVirtualSiteDirectory() );

        LPCWSTR pLogFileDirectory = pVirtualSiteConfig->pLogFileDirectory;

        // Figure out what the length of the new directory path is that 
        // the config store is giving us.
        DWORD ConfigLogFileDirLength = 
              ExpandEnvironmentStrings(pLogFileDirectory, NULL, 0);

        //
        // The catalog should always give me a valid log file directory.
        //
        DBG_ASSERT ( ConfigLogFileDirLength > 0 );

        // Figure out the length of the directory path that we will be
        // appending to the config store's path.
        DWORD VirtualSiteDirLength = wcslen(GetVirtualSiteDirectory());

        DBG_ASSERT ( VirtualSiteDirLength > 0 );

        // Allocate enough space for the new directory path.
        // If this fails than we know that we have a memory issue.

        // ExpandEnvironmentStrings gives back a length including the null termination,
        // so we do not need an extra space for the terminator.
        
        m_LogFileDirectory = 
            ( LPWSTR )GlobalAlloc( GMEM_FIXED
                                , (ConfigLogFileDirLength + VirtualSiteDirLength) * sizeof(WCHAR)
                                );

        if ( m_LogFileDirectory )
        { 
            // Copy over the original part of the directory path from the config file
            DWORD cchInExpandedString = 
                ExpandEnvironmentStrings (    pLogFileDirectory
                                            , m_LogFileDirectory
                                            , ConfigLogFileDirLength);

            DBG_ASSERT (cchInExpandedString == ConfigLogFileDirLength);

            // First make sure that there is atleast one character
            // besides the null (that is included in the ConfigLogFileDirLength
            // before checking that the last character (back one to access the zero based
            // array and back a second one to avoid the terminating NULL) is
            // a slash.  If it is than change it to a null, since we are going
            // to add a slash with the \\W3SVC directory name anyway.
            if ( ConfigLogFileDirLength > 1 
                && m_LogFileDirectory[ConfigLogFileDirLength-2] == L'\\')
            {
                m_LogFileDirectory[ConfigLogFileDirLength-2] = '\0';
            }

            DBG_REQUIRE( wcscat( m_LogFileDirectory,
                                 GetVirtualSiteDirectory()) 
                            == m_LogFileDirectory);

            LoggingHasChanged = TRUE;
        }
        else
        {      
            DPERROR(( 
                DBG_CONTEXT,
                E_OUTOFMEMORY,
                "Allocating memory failed\n"
                ));
        }
    }

    // LogFilePeriod
    if ( ( pWhatHasChanged == NULL ) 
        || ( pWhatHasChanged->LogFilePeriod ) )
    {
        m_LoggingFilePeriod = pVirtualSiteConfig->LogFilePeriod;
        LoggingHasChanged = TRUE;
    }

    // LogFileTrucateSize
    if ( ( pWhatHasChanged == NULL ) 
        || ( pWhatHasChanged->LogFileTruncateSize ) )
    {
        m_LoggingFileTruncateSize = pVirtualSiteConfig->LogFileTruncateSize;
             
        LoggingHasChanged = TRUE;
    }

    // LogExtFileFlags
    if ( ( pWhatHasChanged == NULL ) 
        || ( pWhatHasChanged->LogExtFileFlags ) )
    {
        m_LoggingExtFileFlags = pVirtualSiteConfig->LogExtFileFlags;
        LoggingHasChanged = TRUE;
    }

    // LogFileLocaltimeRollover
    if ( ( pWhatHasChanged == NULL ) 
        || ( pWhatHasChanged->LogFileLocaltimeRollover ) )
    {
        m_LogFileLocaltimeRollover = pVirtualSiteConfig->LogFileLocaltimeRollover;
        LoggingHasChanged = TRUE;
    }

    //
    // If there have been some logging changes
    // then we must first make sure the logging values
    // are acceptable.
    //
    if (LoggingHasChanged)
    {
        if ( m_LoggingFileTruncateSize < SMALLEST_TRUNCATE_SIZE && 
             m_LoggingFilePeriod == HttpLoggingPeriodMaxSize &&
             m_LoggingFormat < HttpLoggingTypeMaximum)
        {
            WCHAR SizeLog[MAX_SIZE_BUFFER_FOR_ITOW];
            _itow(m_LoggingFileTruncateSize, SizeLog, 10);

            // Log an error.
            const WCHAR * EventLogStrings[2];

            EventLogStrings[0] = GetVirtualSiteName();
            EventLogStrings[1] = SizeLog;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_LOG_FILE_TRUNCATE_SIZE,        // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

            //
            // Set it to a default of 16 kb.
            //
            m_LoggingFileTruncateSize = SMALLEST_TRUNCATE_SIZE;
        
        }

        
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site_table.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site_table.cxx

Abstract:

    This class is a hashtable which manages the set of virtual sites.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE_TABLE::Terminate(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;

    
    //
    // BUGBUG Iterating in order to clean up, remove, and delete each 
    // element of the table is difficult to do with lkhash today.
    // GeorgeRe plans to fix this eventually. For now, the alternative
    // is to iterate through the table building up in list of all the 
    // elements, and then go through the list and shutdown, remove, and
    // delete each element -- yuck!!
    //
    // Once this gets fixed, we can see if it is valuable to unify any
    // table management code between the app pool, virtual site,
    // and application tables.
    //
    LIST_ENTRY DeleteListHead;
    PLIST_ENTRY pDeleteListEntry = NULL;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    HRESULT hr = S_OK;


    InitializeListHead( &DeleteListHead );

    
    CountOfElementsInTable = Size();


    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    
    SuccessCount = Apply( 
                        DeleteVirtualSiteAction,
                        &DeleteListHead,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    // now for each, clean it up, remove it from the table, and delete it
    
    while (  ! IsListEmpty( &DeleteListHead )  )
    {
    
        pDeleteListEntry = RemoveHeadList( &DeleteListHead );

        DBG_ASSERT( pDeleteListEntry != NULL );

        pVirtualSite = VIRTUAL_SITE::VirtualSiteFromDeleteListEntry( pDeleteListEntry );

        // remove it from the table

        ReturnCode = DeleteRecord( pVirtualSite );

        if ( ReturnCode != LK_SUCCESS )
        {

            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Removing virtual site from hashtable failed\n"
                ));

        }


        //
        // All remaining shutdown work for the virtual site is done 
        // in it's destructor.
        //

        delete pVirtualSite;

    }


    return;

}   // VIRTUAL_SITE_TABLE::Terminate

/***************************************************************************++

Routine Description:

    Setup the _Total counters instance and then walk through each of the 
    sites and let them dump their counters shared memory.

Arguments:

    PERF_MANAGER* pManager - The perf manager that controls the shared memory.
    BOOL StructChanged     - whether or not we need to resetup all the shared memory.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE_TABLE::ReportPerformanceInfo(
    PERF_MANAGER* pManager,
    BOOL StructChanged
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;
 

    //
    // Need to add in an entry for the _Total counters
    // even if we aren't going to have any sites.
    //
    pManager->SetupTotalSite( StructChanged );

    CountOfElementsInTable = Size();

    //
    // Note that for good form we grab the write lock since we will be 
    // modifying objects in the table (although no other thread should 
    // touch this data structure anyways).
    //
    SuccessCount = Apply( 
                        ReportCountersVirtualSiteAction,
                        (LPVOID) pManager,
                        LKL_WRITELOCK
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // VIRTUAL_SITE_TABLE::ReportPerformanceInfo


/***************************************************************************++

Routine Description:

    A routine that may be applied to all VIRTUAL_SITEs in the hashtable
    to prepare for termination. Conforms to the PFnRecordAction prototype.

Arguments:

    pVirtualSite - The virtual site.

    pDeleteListHead - List head into which to insert the virtual site for
    later deletion.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::DeleteVirtualSiteAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pDeleteListHead
    )
{

    DBG_ASSERT( pVirtualSite != NULL );
    DBG_ASSERT( pDeleteListHead != NULL );


    InsertHeadList( 
        ( PLIST_ENTRY ) pDeleteListHead,
        pVirtualSite->GetDeleteListEntry()
        );


    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::DeleteVirtualSiteAction

/***************************************************************************++

Routine Description:

    Has the virtual site record it's current state in the metabase.

Arguments:

    pVirtualSite - The virtual site.

    pIgnored - Needed for signature but not used.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/
// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::RehookVirtualSiteAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pIgnored
    )
{

    HRESULT hr = S_OK;
    LK_ACTION LkAction = LKA_SUCCEEDED;


    DBG_ASSERT( pVirtualSite != NULL );
    UNREFERENCED_PARAMETER( pIgnored );

    // let the metabase know that the state of the app pool has changed
    hr = pVirtualSite->RecordState(S_OK);
    if ( FAILED ( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Recyceling the worker process failed\n"
            ));

        LkAction = LKA_FAILED;

        goto exit;
    }

exit:

    return LkAction;
    
}   // VIRTUAL_SITE_TABLE::RehookAppPoolAction


/***************************************************************************++

Routine Description:

    A routine that may be applied to all VIRTUAL_SITEs in the hashtable
    to report perf counters.

Arguments:

    pVirtualSite - The virtual site.

    VOID* pManagerVoid - The perf manager used to process the site info.


Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::ReportCountersVirtualSiteAction(
    IN VIRTUAL_SITE* pVirtualSite, 
    IN LPVOID pManagerVoid
    )
{

    DBG_ASSERT( pVirtualSite != NULL );
    DBG_ASSERT( pManagerVoid != NULL );

    PERF_MANAGER* pManager = (PERF_MANAGER*) pManagerVoid;

    DBG_ASSERT(pManager->CheckSignature());

    // For each site we want to do:
    //
    //       a)  adjust the max values of the site counters
    //       b)  if there has been a struct change copy in
    //           the instance information and store the offset.
    //       c)  copy in the counter values
    //       d)  increment the _Total with the new values.
    //       e)  zero out the appropriate sites counters

    //
    // First let the site adjust it's MaxValues
    //
    pVirtualSite->AdjustMaxValues();

    //
    // The OffsetInMemory will be incremented each time 
    // we assign a new site space in the block.  So the 
    // next site can use the Offset to find it's spot.
    //
    pManager->SetupVirtualSite( pVirtualSite );

    //
    // Now that the counters have been reported we can
    // zero out the appropriate ones.
    //
    pVirtualSite->ClearAppropriatePerfValues();

    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::ReportCountersVirtualSiteAction


#if DBG
/***************************************************************************++

Routine Description:

    Debug dump the table.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
VIRTUAL_SITE_TABLE::DebugDump(
    )
{

    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dumping virtual site table; total count: %lu\n",
            CountOfElementsInTable
            ));
    }


    SuccessCount = Apply( 
                        DebugDumpVirtualSiteAction,
                        NULL
                        );
    
    DBG_ASSERT( SuccessCount == CountOfElementsInTable );


    return;

}   // VIRTUAL_SITE_TABLE::DebugDump



/***************************************************************************++

Routine Description:

    A routine that may be applied to all VIRTUAL_SITEs in the hashtable
    to perform a debug dump. Conforms to the PFnRecordAction prototype.

Arguments:

    pVirtualSite - The virtual site.

    pIgnored - Ignored.

Return Value:

    LK_ACTION - LKA_SUCCEEDED always.

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::DebugDumpVirtualSiteAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pIgnored
    )
{

    DBG_ASSERT( pVirtualSite != NULL );
    UNREFERENCED_PARAMETER( pIgnored );


    pVirtualSite->DebugDump();
    

    return LKA_SUCCEEDED;
    
}   // VIRTUAL_SITE_TABLE::DebugDumpVirtualSiteAction
#endif  // DBG



/***************************************************************************++

Routine Description:

    Process a site control operation, for all sites. 

Arguments:

    Command - The command issued.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
VIRTUAL_SITE_TABLE::ControlAllSites(
    IN DWORD Command
    )
{

    HRESULT hr = S_OK;
    DWORD SuccessCount = 0;
    DWORD CountOfElementsInTable = 0;


    CountOfElementsInTable = Size();


    SuccessCount = Apply( 
                        ControlAllSitesVirtualSiteAction,
                        &Command
                        );


    //
    // Control operations can reasonably fail, depending on the current
    // state of a particular site. So ignore errors here. 
    //


    return hr;

}   // VIRTUAL_SITE_TABLE::ControlAllSites



/***************************************************************************++

Routine Description:

    A routine that may be applied to all virtual sites in the hashtable
    to send a state control command. Conforms to the PFnRecordAction 
    prototype.

Arguments:

    pVirtualSite - The app pool.

    pCommand - The command to apply to the site.

Return Value:

    LK_ACTION

--***************************************************************************/

// note: static!
LK_ACTION
VIRTUAL_SITE_TABLE::ControlAllSitesVirtualSiteAction(
    IN VIRTUAL_SITE * pVirtualSite, 
    IN VOID * pCommand
    )
{

    HRESULT hr = S_OK;
    DWORD NewState = W3_CONTROL_STATE_INVALID;
    LK_ACTION LkAction = LKA_SUCCEEDED;


    DBG_ASSERT( pVirtualSite != NULL );
    DBG_ASSERT( pCommand != NULL );


    //
    // Process the state change command. 
    //

    hr = pVirtualSite->ProcessStateChangeCommand( * ( reinterpret_cast<DWORD*>( pCommand ) ), FALSE, &NewState );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Processing state change command failed\n"
            ));

        LkAction = LKA_FAILED;
    }


    return LkAction;
    
}   // VIRTUAL_SITE_TABLE::ControlAllSitesVirtualSiteAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\ul_and_worker_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ul_and_worker_manager.cxx

Abstract:

    This class manages all the major run-time state, and drives UL.sys and
    the worker processes.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"

#include <httpfilt.h>

HRESULT
AlterDesktopForWPGUsers();


/***************************************************************************++

Routine Description:

    Constructor for the UL_AND_WORKER_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

UL_AND_WORKER_MANAGER::UL_AND_WORKER_MANAGER(
    )
    :
    m_AppPoolTable(),
    m_VirtualSiteTable(),
    m_ApplicationTable()
{


    m_State = UninitializedUlAndWorkerManagerState;
    
    m_pPerfManager = NULL;

    m_UlInitialized = FALSE;

    m_UlControlChannel = NULL;
    
    m_UlFilterChannel = NULL;

    m_SitesHaveChanged = TRUE;

    m_Signature = UL_AND_WORKER_MANAGER_SIGNATURE;

}   // UL_AND_WORKER_MANAGER::UL_AND_WORKER_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the UL_AND_WORKER_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

UL_AND_WORKER_MANAGER::~UL_AND_WORKER_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == UL_AND_WORKER_MANAGER_SIGNATURE );

    m_Signature = UL_AND_WORKER_MANAGER_SIGNATURE_FREED;

    DBG_ASSERT( m_State == TerminatingUlAndWorkerManagerState );

    if ( m_pPerfManager )
    {
        m_pPerfManager->Dereference();
        m_pPerfManager = NULL;
    }

    if ( m_UlFilterChannel != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_UlFilterChannel ) );
        m_UlFilterChannel = NULL;
    }


    if ( m_UlControlChannel != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_UlControlChannel ) );
        m_UlControlChannel = NULL;
    }


    if ( m_UlInitialized )
    {
        HttpTerminate();
        m_UlInitialized = FALSE;
    }


}   // UL_AND_WORKER_MANAGER::~UL_AND_WORKER_MANAGER



/***************************************************************************++

Routine Description:

    Initialize by opening the UL control channel.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    DWORD NumTries = 1;

    Win32Error = HttpInitialize(
                        0                           // reserved
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't initialize UL\n"
            ));

        goto exit;
    }

    m_UlInitialized = TRUE;

    Win32Error = HttpOpenControlChannel(
                        &m_UlControlChannel,        // returned handle
                        0                           // synchronous i/o
                        );

    //
    // We might get access denied if we tried to
    // open the control channel too soon after closing it.
    //
    while ( Win32Error == ERROR_ACCESS_DENIED && NumTries <= 5 )
    {

        Sleep ( 1000 );  // 1 second

        Win32Error = HttpOpenControlChannel(
                            &m_UlControlChannel,        // returned handle
                            0                           // synchronous i/o
                            );

        NumTries++;
    }

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't open UL control channel\n"
            ));

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_HTTP_CONTROL_CHANNEL_OPEN_FAILED,                  // message id
                0,                                                     // count of strings
                NULL,                                                  // array of strings
                hr                                                     // error code
                );

        goto exit;
    }
    
    //
    // Just create a SSL filter channel.  
    // W3SSL service should have created Filter Channel so first try 
    // to open it
    //
    
    Win32Error = HttpOpenFilter(
                        &m_UlFilterChannel,         // filter handle
                        SSL_FILTER_CHANNEL_NAME,    // filter name
                        HTTP_OPTION_OVERLAPPED      // options
                        );

    if ( Win32Error != NO_ERROR )
    {
        //
        // If open failed, try to create Filter Channel
        //
        
        Win32Error = HttpCreateFilter( 
                            &m_UlFilterChannel,
                            SSL_FILTER_CHANNEL_NAME,
                            NULL,
                            HTTP_OPTION_OVERLAPPED );
        if ( Win32Error != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );
    
            DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Couldn't open/create filter channel\n"
            ));
            goto exit;
        }
    }
    
    DBG_ASSERT( m_UlFilterChannel != NULL );

    //
    // Make the current desktop accessible by users in the IIS_WPG group
    // BUGBUG: revert this change on terminate
    //
    hr = AlterDesktopForWPGUsers();
    if (FAILED(hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to configure desktop\n"
            ));

        goto exit;
    }

    m_State = RunningUlAndWorkerManagerState;


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Create a new app pool.

Arguments:

    pAppPoolId - ID for the app pool to be created.

    pAppPoolConfig - The configuration parameters for this app pool. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CreateAppPool(
    IN LPCWSTR pAppPoolId,
    IN APP_POOL_CONFIG * pAppPoolConfig
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    APP_POOL * pExistingAppPool = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );
    DBG_ASSERT( pAppPoolConfig != NULL );


    // ensure that we're not creating a app pool that already exists
    DBG_ASSERT( m_AppPoolTable.FindKey( 
                                    pAppPoolId, 
                                    &pExistingAppPool
                                    ) 
                == LK_NO_SUCH_KEY );


    pAppPool = new APP_POOL();

    if ( pAppPool == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating APP_POOL failed\n"
            ));

        goto exit;
    }


    hr = pAppPool->Initialize( pAppPoolId, pAppPoolConfig );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing app pool object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_AppPoolTable.InsertRecord( pAppPool );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Inserting app pool into hashtable failed\n"
            ));

        goto exit;
    }


    pAppPool->MarkAsInAppPoolTable();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New app pool: %S added to app pool hashtable; total number now: %lu\n",
            pAppPoolId,
            m_AppPoolTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pAppPool != NULL ) )
    {

        //
        // Terminate and dereference pAppPool now, since we won't be able to 
        // find it in the table later. 
        //

        DBG_ASSERT( ! ( pAppPool->IsInAppPoolTable() ) );

        pAppPool->Terminate( TRUE );

        pAppPool->Dereference();

        pAppPool = NULL;

    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::CreateAppPool



/***************************************************************************++

Routine Description:

    Create a virtual site. 

Arguments:

    VirtualSiteId - ID for the virtual site to create.

    pVirtualSiteConfig - The configuration for this virtual site. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CreateVirtualSite(
    IN DWORD VirtualSiteId,
    IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    VIRTUAL_SITE * pExistingVirtualSite = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pVirtualSiteConfig != NULL );


    // ensure that we're not creating a virtual site that already exists
    DBG_ASSERT( m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pExistingVirtualSite
                                        ) 
                == LK_NO_SUCH_KEY );


    pVirtualSite = new VIRTUAL_SITE();

    if ( pVirtualSite == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating VIRTUAL_SITE failed\n"
            ));

        goto exit;
    }


    hr = pVirtualSite->Initialize( VirtualSiteId, pVirtualSiteConfig );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing virtual site object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_VirtualSiteTable.InsertRecord( pVirtualSite );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Inserting virtual site into hashtable failed\n"
            ));

        goto exit;
    }

    m_SitesHaveChanged = TRUE;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New virtual site: %lu added to virtual site hashtable; total number now: %lu\n",
            VirtualSiteId,
            m_VirtualSiteTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pVirtualSite != NULL ) )
    {

        //
        // Clean up pVirtualSite now, since we won't be able to find it 
        // in the table later. All shutdown work is done in it's destructor.
        //
        
        delete pVirtualSite;

        pVirtualSite = NULL;
    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::CreateVirtualSite



/***************************************************************************++

Routine Description:

    Create an application. This may only be done after the virtual site and 
    the app pool used by this application have been created.

Arguments:

    VirtualSiteId - The virtual site to which this application belongs.

    pApplicationUrl - The site relative URL prefix which identifies
    this application.

    pApplicationConfig - The configuration parameters for this application. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CreateApplication(
    IN DWORD VirtualSiteId,
    IN LPCWSTR pApplicationUrl,
    IN APPLICATION_CONFIG * pApplicationConfig
    )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    VIRTUAL_SITE * pVirtualSite = NULL;
    APP_POOL * pAppPool = NULL;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    APPLICATION * pExistingApplication = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplicationUrl != NULL );
    DBG_ASSERT( pApplicationConfig != NULL );
    DBG_ASSERT( pApplicationConfig->pAppPoolId != NULL );


    ApplicationId.VirtualSiteId = VirtualSiteId;
    ApplicationId.pApplicationUrl = pApplicationUrl;


    // ensure that we're not creating an application that already exists
    DBG_ASSERT( m_ApplicationTable.FindKey( 
                                        &ApplicationId, 
                                        &pExistingApplication
                                        ) 
                == LK_NO_SUCH_KEY );


    //
    // Look up the virtual site and app pool. These must already 
    // exist.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        if ( ReturnCode == LK_NO_SUCH_KEY )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Attempting to create application that references a non-existent virtual site\n"
                ));

            DBG_ASSERT( FALSE );

        }
        else
        {
            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Looking up virtual site referenced by application failed\n"
                ));
        }
        
        goto exit;
    }


    ReturnCode = m_AppPoolTable.FindKey( 
                                    pApplicationConfig->pAppPoolId, 
                                    & ( pApplicationConfig->pAppPool )
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {

        if ( ReturnCode == LK_NO_SUCH_KEY )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Attempting to create application that references a non-existent app pool\n"
                ));

            DBG_ASSERT( FALSE );

        }
        else
        {
            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Looking up app pool referenced by application failed\n"
                ));
        }
        
        goto exit;
    }


    pApplication = new APPLICATION();

    if ( pApplication == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating APPLICATION failed\n"
            ));

        goto exit;
    }


    hr = pApplication->Initialize(
                            &ApplicationId, 
                            pVirtualSite, 
                            pApplicationConfig
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing application object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_ApplicationTable.InsertRecord( pApplication );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Inserting application into hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New application in site: %lu with path: %S, assigned to app pool: %S, with app index %lu, added to application hashtable; total number now: %lu\n",
            VirtualSiteId,
            pApplicationUrl,
            pApplicationConfig->pAppPoolId,
            m_ApplicationTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pApplication != NULL ) )
    {

        //
        // Clean up pApplication now, since we won't be able to find it 
        // in the table later. All shutdown work is done in it's destructor.
        //
        
        delete pApplication;

        pApplication = NULL;
    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::CreateApplication



/***************************************************************************++

Routine Description:

    Delete an app pool. 

Arguments:

    pAppPoolId - ID for the app pool to be deleted.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeleteAppPool(
    IN LPCWSTR pAppPoolId
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );


    //
    // Look up the app pool in our data structures.
    //
    
    ReturnCode = m_AppPoolTable.FindKey( 
                                    pAppPoolId, 
                                    &pAppPool
                                    ); 

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding app pool to delete in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Terminate the app pool object. As part of the object's cleanup,  
    // it will call RemoveAppPoolFromTable() to remove itself from the 
    // app pool hashtable. 
    //
    // Termination (as opposed to clean shutdown) is slightly rude, but
    // doing shutdown here introduces a number of nasty races and other
    // problems. For example, someone could delete an app pool, 
    // then re-add an app pool with the same name immediately after. 
    // If the original app pool hasn't shut down yet, then the two 
    // id's will conflict in the table (not to mention conflicting on 
    // trying to grab the same app pool id in UL). We could just fail
    // such config change calls, but then our WAS internal state gets
    // out of sync with the config store state, without any easy way
    // for the customer to figure out what's going on.
    //
    // BUGBUG Can we live with terminating instead of clean shutdown in
    // this scenario? EricDe says yes, 1/20/00. 
    //
    // Note that at this point there should not be any applications  
    // still assigned to this app pool. 
    //

    pAppPool->Terminate( FALSE );


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::DeleteAppPool



/***************************************************************************++

Routine Description:

    Delete a virtual site. 

Arguments:

    VirtualSiteId - ID for the virtual site to delete.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeleteVirtualSite(
    IN DWORD VirtualSiteId
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Look up the virtual site in our data structures.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding virtual site to delete in hashtable failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_VirtualSiteTable.DeleteRecord( pVirtualSite );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Removing virtual site from hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Virtual site: %lu removed from hashtable; total number now: %lu\n",
            VirtualSiteId,
            m_VirtualSiteTable.Size()
            ));
    }


    //
    // Mark the virtual site as no longer in the metabase
    // so we do not attempt to write it's update information
    // and in turn create the site by accident.
    //
    pVirtualSite->MarkSiteAsNotInMetabase();

    //
    // Clean up and delete the virtual site object. All shutdown work is 
    // done in it's destructor.
    //

    //
    // Note that any apps in this site must already have been deleted.
    // The destructor for this object will assert if this is not the case. 
    //
    
    delete pVirtualSite;

    m_SitesHaveChanged = TRUE;

exit:

    return hr;
    
}   // UL_AND_WORKER_MANAGER::DeleteVirtualSite



/***************************************************************************++

Routine Description:

    Delete an application. 

Arguments:

    VirtualSiteId - The virtual site to which this application belongs.

    pApplicationUrl - The site relative URL prefix which identifies
    this application.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeleteApplication(
    IN DWORD VirtualSiteId,
    IN LPCWSTR pApplicationUrl
    )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplicationUrl != NULL );


    ApplicationId.VirtualSiteId = VirtualSiteId;
    ApplicationId.pApplicationUrl = pApplicationUrl;


    //
    // Look up the application in our data structures.
    //
    
    ReturnCode = m_ApplicationTable.FindKey( 
                                        &ApplicationId, 
                                        &pApplication
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding application to delete in hashtable failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_ApplicationTable.DeleteRecord( pApplication );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Removing application from hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Application in site: %lu with path: %S, removed from hashtable; total number now: %lu\n",
            VirtualSiteId,
            pApplicationUrl,
            m_ApplicationTable.Size()
            ));
    }

    //
    // Clean up and delete the application object. All shutdown work is 
    // done in it's destructor.
    //
    
    delete pApplication;


exit:

    return hr;
    
}   // UL_AND_WORKER_MANAGER::DeleteApplication


/***************************************************************************++

Routine Description:

    Modify the global data for the server.

Arguments:

    pGlobalConfig - The new configuration values for the server.

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ModifyGlobalData(
    IN GLOBAL_SERVER_CONFIG* pGlobalConfig,
    IN GLOBAL_SERVER_CONFIG_CHANGE_FLAGS* pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    DWORD   Win32Error = ERROR_SUCCESS;

    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pGlobalConfig != NULL );

    //
    // Make the configuration changes. 
    //

    //
    // If logging in UTF 8 has changed then tell UL.
    //
    if ( pWhatHasChanged == NULL || pWhatHasChanged->LogInUTF8 )
    {
        HTTP_CONTROL_CHANNEL_UTF8_LOGGING LogInUTF8 = 
                            ( pGlobalConfig->LogInUTF8 == TRUE );

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Configuring control channel for logging in UTF8 %S\n",
                pGlobalConfig->LogInUTF8 ? L"TRUE" : L"FALSE"
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                    // control channel
                            HttpControlChannelUTF8Logging,  // information class
                            &LogInUTF8,                          // data to set
                            sizeof( LogInUTF8 )                  // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = L"LogInUTF8";

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                    1,                                                     // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel logging in utf8 failed\n"
                ));

        }
    }

    //
    // If max connections has changed then tell UL about it.
    //
    if ( pWhatHasChanged == NULL || pWhatHasChanged->MaxConnections )
    {
        HTTP_CONNECTION_LIMIT connections = pGlobalConfig->MaxConnections;

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Configuring control channel MaxConnections to %u\n",
                pGlobalConfig->MaxConnections
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                    // control channel
                            HttpControlChannelConnectionInformation,  // information class
                            &connections,                          // data to set
                            sizeof( connections )                  // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = L"MaxConnections";

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                    1,                                                     // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel max connections failed\n"
                ));

        }
    }

    //
    // If max bandwidth has changed then tell UL about it.
    //
    if ( pWhatHasChanged == NULL || pWhatHasChanged->MaxBandwidth )
    {

        HTTP_BANDWIDTH_LIMIT bandwidth = pGlobalConfig->MaxBandwidth;;

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Configuring control channel MaxBandwidth to %u\n",
                pGlobalConfig->MaxBandwidth
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                     // control channel
                            HttpControlChannelBandwidthInformation, // information class
                            &bandwidth,                             // data to set
                            sizeof( bandwidth )                     // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = L"MaxBandwidth";

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                    1,                                                     // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel max bandwidth failed\n"
                ));

        }
    }

    //
    // If any of the connection info has changed then
    // pass the info on down to UL.
    //
    if ( pWhatHasChanged == NULL || 
         pWhatHasChanged->ConnectionTimeout || 
         pWhatHasChanged->MinFileKbSec ||
         pWhatHasChanged->HeaderWaitTimeout )
    {
        HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT ConnectionInfo;

        ConnectionInfo.ConnectionTimeout = pGlobalConfig->ConnectionTimeout;  // Seconds
        ConnectionInfo.HeaderWaitTimeout = pGlobalConfig->HeaderWaitTimeout;  // Seconds
        ConnectionInfo.MinFileKbSec      = pGlobalConfig->MinFileKbSec;       // Bytes/Seconds

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Configuring control channel ConnectionInfo\n"
                "       ConnectionTimeout = %u\n"
                "       HeaderWaitTimeout = %u\n"
                "       MinFileKbSec = %u\n",
                pGlobalConfig->ConnectionTimeout,
                pGlobalConfig->HeaderWaitTimeout,
                pGlobalConfig->MinFileKbSec
                ));
        }

        //
        // let http.sys know about it.
        //
        Win32Error = HttpSetControlChannelInformation(
                            m_UlControlChannel,                    // control channel
                            HttpControlChannelTimeoutInformation,  // information class
                            &ConnectionInfo,                          // data to set
                            sizeof( ConnectionInfo )                  // data length
                            );

        if ( Win32Error != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( Win32Error );

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = L"Connection Info";

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_HTTP_CONTROL_CHANNEL_CONFIG_FAILED,                // message id
                    1,                                                     // count of strings
                    EventLogStrings,                                       // array of strings
                    hr                                                     // error code
                    );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Changing control channel connection info failed\n"
                ));

        }
    }

    //
    // If the filter flags have changed send them back down.
    //
    if ( ( pWhatHasChanged == NULL || pWhatHasChanged->FilterFlags ) )
    {
        DBG_ASSERT ( m_UlFilterChannel != NULL );

        HTTP_CONTROL_CHANNEL_FILTER controlFilter;

        //
        // Attach the filter to the control channel.
        //

        ZeroMemory(&controlFilter, sizeof(controlFilter));
            
        controlFilter.Flags.Present = 1;
        controlFilter.FilterHandle = m_UlFilterChannel;
        controlFilter.FilterOnlySsl = 
            (( pGlobalConfig->FilterFlags & SF_NOTIFY_READ_RAW_DATA ) 
                                                     ? FALSE : TRUE );

        IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Configuring control channel Filter settings \n"
                "   FilterHandle to %x"
                "   FilterOnlySsl to %u\n",
                m_UlFilterChannel,
                controlFilter.FilterOnlySsl
                ));
        }

        
        Win32Error = HttpSetControlChannelInformation(
                                m_UlControlChannel,
                                HttpControlChannelFilterInformation,
                                &controlFilter,
                                sizeof(controlFilter)
                                );
    
        if ( Win32Error != NO_ERROR )
        {
       
            hr = HRESULT_FROM_WIN32( Win32Error );
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Couldn't attach the filter to control channel\n"
                ));

        }

    }

    //
    // Don't propogate the error here, because not being able to handle an
    // update, should not shut was down.
    //
    return S_OK;

}   // UL_AND_WORKER_MANAGER::ModifyGlobalData


/***************************************************************************++

Routine Description:

    Modify an app pool. 

Arguments:

    pAppPoolId - ID for the app pool to be modified.

    pNewAppPoolConfig - The new configuration values for the app pool. 

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ModifyAppPool(
    IN LPCWSTR pAppPoolId,
    IN APP_POOL_CONFIG * pNewAppPoolConfig,
    IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );
    DBG_ASSERT( pNewAppPoolConfig != NULL );
    DBG_ASSERT( pWhatHasChanged != NULL );


    //
    // Look up the app pool in our data structures.
    //
    
    ReturnCode = m_AppPoolTable.FindKey( 
                                    pAppPoolId, 
                                    &pAppPool
                                    ); 

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding app pool to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Make the configuration changes. 
    //

    hr = pAppPool->SetConfiguration( pNewAppPoolConfig, pWhatHasChanged );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new app pool configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::ModifyAppPool



/***************************************************************************++

Routine Description:

    Modify a virtual site. 

Arguments:

    VirtualSiteId - ID for the virtual site to be modified.

    pNewVirtualSiteConfig - The new configuration values for the virtual 
    site. 

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ModifyVirtualSite(
    IN DWORD VirtualSiteId,
    IN VIRTUAL_SITE_CONFIG * pNewVirtualSiteConfig,
    IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pNewVirtualSiteConfig != NULL );
    DBG_ASSERT( pWhatHasChanged != NULL );


    //
    // Look up the virtual site in our data structures.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        ); 

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding virtual site to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Make the configuration changes. 
    //

    hr = pVirtualSite->SetConfiguration( pNewVirtualSiteConfig, pWhatHasChanged );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new virtual site configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::ModifyVirtualSite



/***************************************************************************++

Routine Description:

    Modify an application. 

Arguments:

    VirtualSiteId - The virtual site to which this application belongs.

    pApplicationUrl - The site relative URL prefix which identifies
    this application.

    pNewApplicationConfig - The new configuration values for the application. 

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ModifyApplication(
    IN DWORD VirtualSiteId,
    IN LPCWSTR pApplicationUrl,
    IN APPLICATION_CONFIG * pNewApplicationConfig,
    IN APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplicationUrl != NULL );
    DBG_ASSERT( pNewApplicationConfig != NULL );
    DBG_ASSERT( pWhatHasChanged != NULL );


    ApplicationId.VirtualSiteId = VirtualSiteId;
    ApplicationId.pApplicationUrl = pApplicationUrl;


    //
    // Look up the application in our data structures.
    //
    
    ReturnCode = m_ApplicationTable.FindKey( 
                                        &ApplicationId, 
                                        &pApplication
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding application to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Resolve the app pool id to it's corresponding app pool object.
    //

    ReturnCode = m_AppPoolTable.FindKey( 
                                    pNewApplicationConfig->pAppPoolId, 
                                    & ( pNewApplicationConfig->pAppPool )
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Looking up app pool referenced by application failed\n"
            ));

        goto exit;
    }


    //
    // Make the configuration changes. 
    //

    hr = pApplication->SetConfiguration( pNewApplicationConfig, pWhatHasChanged );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new application configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::ModifyApplication

/***************************************************************************++

Routine Description:

    Routine will ask all the worker processes to recycle.

Arguments:

    None

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
UL_AND_WORKER_MANAGER::RecoverFromInetinfoCrash(
    )
{
    HRESULT hr = S_OK;
    DWORD SuccessCount = 0;

    // 1) In BC mode launch a worker process.
    // 2) In FC mode recycle all worker processes.
    // 3) Write all the states of the app pools to the metabase.


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // Step 1 & 2, decide which mode and what we should be doing to the worker 
    // processes.  
    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        hr = StartInetinfoWorkerProcess();
        
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to start the worker process in inetinfo\n"
                ));

            goto exit;
        }
    }
    else
    {
        // Note, it is ok that we only write the state data
        // for the app pool to the metabase in FC mode, because
        // in BC mode we don't use the app pool in the
        // metabase.

        // Not in BC Mode so recycle the app pools.
        // Note that this will also record the app pool states
        // in the metabase.

        // Have the table recycle all app pools.
        SuccessCount = m_AppPoolTable.Apply( APP_POOL_TABLE::RehookAppPoolAction,
                                             NULL );

        DBG_ASSERT ( SuccessCount == m_AppPoolTable.Size() );
    }

    SuccessCount = m_VirtualSiteTable.Apply( VIRTUAL_SITE_TABLE::RehookVirtualSiteAction,
                                   NULL );

    DBG_ASSERT ( SuccessCount == m_VirtualSiteTable.Size() );

exit:

    return S_OK;

} // UL_AND_WORKER_MANAGER::RecoverFromInetinfoCrash


/***************************************************************************++

Routine Description:

    Recycle a specific application pool

Arguments:

    IN LPCWSTR pAppPoolId = The app pool id we want to recycle.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
UL_AND_WORKER_MANAGER::RecycleAppPool(
    IN LPCWSTR pAppPoolId
    )
{
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );
    DBG_ASSERT ( pAppPoolId );

    HRESULT hr = S_OK;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    APP_POOL* pAppPool = NULL;
    
    if ( GetWebAdminService()->IsBackwardCompatibilityEnabled() )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Tried to recycle the default app pool \n"
            ));

        goto exit;
    }

    // 
    // Find the default app pool from the app pool table.
    // 

    ReturnCode = m_AppPoolTable.FindKey(pAppPoolId, &pAppPool);
    if ( ReturnCode != LK_SUCCESS )
    {
        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding default application in hashtable failed\n"
            ));

        //
        // If there is a problem getting the object from the
        // hash table assume that the object is not found.
        //
        hr = HRESULT_FROM_WIN32( ERROR_OBJECT_NOT_FOUND );

        goto exit;
    }


    hr = pAppPool->RecycleWorkerProcesses();
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Recycling the app pool failed \n"
            ));

        goto exit;
    }

exit:

    return hr;
}


/***************************************************************************++

Routine Description:

    Process a site control request. 

Arguments:

    VirtualSiteId - The site to control.

    Command - The command issued.

    pNewState - The returned new state. This may be a pending state if 
    completing the operation might take some time. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ControlSite(
    IN DWORD VirtualSiteId,
    IN DWORD Command,
    OUT DWORD * pNewState
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    DBG_ASSERT( pNewState != NULL );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Call received to UL_AND_WORKER_MANAGER::ControlSite()\n"
            ));
    }


    //
    // Look up the virtual site in our data structures.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        ); 

    if ( ReturnCode != LK_SUCCESS )
    {
        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding virtual site in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Process the state change command. 
    //

    hr = pVirtualSite->ProcessStateChangeCommand( Command, TRUE, pNewState );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Processing state change command failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::ControlSite



/***************************************************************************++

Routine Description:

    Process a site status query request. 

Arguments:

    VirtualSiteId - The site.

    Command - The command issued.

    pCurrentState - The returned current site state. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::QuerySiteStatus(
    IN DWORD VirtualSiteId,
    OUT DWORD * pCurrentState
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    DBG_ASSERT( pCurrentState != NULL );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Call received to UL_AND_WORKER_MANAGER::QuerySiteStatus()\n"
            ));
    }


    //
    // Look up the virtual site in our data structures.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        ); 

    if ( ReturnCode != LK_SUCCESS )
    {
        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding virtual site in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Query the current state. 
    //

    *pCurrentState = pVirtualSite->GetState();


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::QuerySiteStatus

/***************************************************************************++

Routine Description:

    Process a site control operation, for all sites. 

Arguments:

    Command - The command issued.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ControlAllSites(
    IN DWORD Command
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    return m_VirtualSiteTable.ControlAllSites( Command );

}   // UL_AND_WORKER_MANAGER::ControlSite



/***************************************************************************++

Routine Description:

    Turn UL's HTTP request handling on.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ActivateUl(
    )
{

    return SetUlMasterState( HttpEnabledStateActive );

}   // UL_AND_WORKER_MANAGER::ActivateUl



/***************************************************************************++

Routine Description:

    Turn UL's HTTP request handling off.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeactivateUl(
    )
{

    return SetUlMasterState( HttpEnabledStateInactive );

}   // UL_AND_WORKER_MANAGER::DeactivateUl



/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of the UL&WM.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::Shutdown(
    )
{

    HRESULT hr = S_OK;


    m_State = ShutdownPendingUlAndWorkerManagerState;


    //
    // Tell UL to stop processing new requests.
    //

    hr = DeactivateUl();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Deactivating UL failed\n"
            ));

        goto exit;
    }


    //
    // Kick off clean shutdown of all app pools. Once all the app pools
    // have shut down (meaning that all of their worker processes have
    // shut down too), we will call back into the web admin service 
    // object to complete shutdown. 
    //

    hr = m_AppPoolTable.Shutdown();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Shutting down all app pools failed\n"
            ));

        goto exit;
    }


    //
    // See if shutdown has already completed. This could happen if we have
    // no app pools that have any real shutdown work to do. 
    //

    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::Shutdown



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::Terminate(
    )
{

    HRESULT hr = S_OK;


    m_State = TerminatingUlAndWorkerManagerState;


    //
    // Tell UL to stop processing new requests.
    //

    hr = DeactivateUl();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Deactivating UL failed\n"
            ));

    }


    //
    // Note that we must clean up applications before the virtual sites 
    // and app pools with which they are associated.
    //

    m_ApplicationTable.Terminate();

    m_VirtualSiteTable.Terminate();

    m_AppPoolTable.Terminate();

    if ( m_pPerfManager )
    {
        m_pPerfManager->Terminate();
    }


    return;

}   // UL_AND_WORKER_MANAGER::Terminate

/***************************************************************************++

Routine Description:

    In backward compatibility mode this function will find the Default App
    Pool entry from the table and will request that it launches the inetinfo
    worker process.  All timer work is handled by the worker process and 
    app pool objects 

    This function is not used in Forward Compatibility mode.  

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::StartInetinfoWorkerProcess(
    )
{

    HRESULT hr = S_OK;
    LK_RETCODE ReturnCode = LK_SUCCESS;
    APP_POOL* pDefaultAppPool = NULL;
    
    // 
    // Find the default app pool from the app pool table.
    // 

    ReturnCode = m_AppPoolTable.FindKey(wszDEFAULT_APP_POOL, &pDefaultAppPool);
    if ( ReturnCode != LK_SUCCESS )
    {
        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding default application in hashtable failed\n"
            ));

        goto exit;
    }

    //
    // Now tell the default app pool that it should demand
    // start a worker process in inetinfo.
    //

    hr = pDefaultAppPool->DemandStartInBackwardCompatibilityMode();

    if (FAILED(hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Starting Inetinfo's worker process failed\n"
            ));

        goto exit;
    }


exit:
    return hr;

}   // UL_AND_WORKER_MANAGER::StartInetinfoWorkerProcess



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::DebugDump(
    )
{

    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "******************************\n"
            ));
    }


    m_AppPoolTable.DebugDump();

    m_VirtualSiteTable.DebugDump();

    m_ApplicationTable.DebugDump();


    IF_DEBUG( WEB_ADMIN_SERVICE_DUMP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "******************************\n"
            ));
    }


    return;
    
}   // UL_AND_WORKER_MANAGER::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Remove an app pool object from the table of app pools. This method is
    used by app pool objects to remove themselves once they are done 
    cleaning up. It should not be called outside of UL&WM owned code. 

Arguments:

    pAppPool - The app pool object to remove.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::RemoveAppPoolFromTable(
    IN APP_POOL * pAppPool
    )
{

    HRESULT hr = S_OK;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    DBG_ASSERT( pAppPool != NULL );


    //
    // Remove the app pool from the table.
    //

    ReturnCode = m_AppPoolTable.DeleteRecord( pAppPool );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Removing app pool from hashtable failed\n"
            ));

        //
        // Assert in debug builds. In retail, press on...
        //

        DBG_ASSERT( FALSE );

        hr = S_OK;
    }


    pAppPool->MarkAsNotInAppPoolTable();


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "App pool: %S deleted from app pool hashtable; total number now: %lu\n",
            pAppPool->GetAppPoolId(),
            m_AppPoolTable.Size()
            ));
    }


    //
    // Clean up the reference. Because each app pool is reference counted,
    // it will delete itself as soon as it's reference count hits zero.
    //

    pAppPool->Dereference();


    //
    // See if shutdown is underway, and if so if it has completed now 
    // that this app pool is gone. 
    //
    
    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::RemoveAppPoolFromTable



/***************************************************************************++

Routine Description:

    Respond to the fact that we have left the low memory condition.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::LeavingLowMemoryCondition(
    )
{

    return m_AppPoolTable.LeavingLowMemoryCondition();

}   // UL_AND_WORKER_MANAGER::LeavingLowMemoryCondition

/***************************************************************************++

Routine Description:

    Sets up performance counter structures using the virtual site's table.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ActivatePerfCounters(
    )
{
    HRESULT hr = S_OK;
    DBG_ASSERT ( m_pPerfManager == NULL );

    m_pPerfManager = new PERF_MANAGER;
    if ( m_pPerfManager == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    hr = m_pPerfManager->Initialize();
    if ( FAILED (hr) )
    {
        m_pPerfManager->Dereference();
        m_pPerfManager = NULL;
        goto exit;
    }

exit:
    return hr;

}   // UL_AND_WORKER_MANAGER::ActivatePerfCounters


/***************************************************************************++

Routine Description:

    Activate or deactivate UL's HTTP request handling.

Arguments:

    NewState - The new state to set, from the UL_ENABLED_STATE enum.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::SetUlMasterState(
    IN HTTP_ENABLED_STATE NewState
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    

    Win32Error = HttpSetControlChannelInformation(
                        m_UlControlChannel,                 // control channel
                        HttpControlChannelStateInformation, // information class
                        &NewState,                          // data to set
                        sizeof( NewState )                  // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Changing control channel state failed\n"
            ));

    }


    return hr;

}   // UL_AND_WORKER_MANAGER::SetUlMasterState

/***************************************************************************++

Routine Description:

    See if shutdown is underway. If it is, see if shutdown has finished. If
    it has, then call back to the web admin service to tell it that we are
    done. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CheckIfShutdownUnderwayAndNowCompleted(
    )
{

    HRESULT hr = S_OK;


    //
    // Are we shutting down?
    //

    if ( m_State == ShutdownPendingUlAndWorkerManagerState )
    {

        //
        // If so, have all the app pools gone away, meaning that we are
        // done?
        //

        if ( m_AppPoolTable.Size() == 0 )
        {

            //
            // Tell the web admin service that we are done with shutdown.
            //

            hr = GetWebAdminService()->UlAndWorkerManagerShutdownDone();

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Finishing stop service state transition failed\n"
                    ));

                goto exit;
            }

        }

    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::CheckIfShutdownUnderwayAndNowCompleted

/***************************************************************************++

Routine Description:

    Lookup a virtual site and return a pointer to it.
Arguments:

    IN DWORD SiteId  -  The key to find the site by.

Return Value:

    VIRTUAL_SITE* A pointer to the virtual site 
                  represented by the SiteId passed in.  

    Note:  The VIRTUAL_SITE returned is not ref counted
           so it is only valid to use on the main thread
           during this work item.

    Note2: This can and will return a NULL if the site is not found.

--***************************************************************************/
VIRTUAL_SITE*
UL_AND_WORKER_MANAGER::GetVirtualSite(
    IN DWORD SiteId
    )
{
    VIRTUAL_SITE* pVirtualSite = NULL;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    LK_RETCODE ReturnCode = LK_SUCCESS;

    // Need to look up the site pointer.

    ReturnCode = m_VirtualSiteTable.FindKey(SiteId,
                                  &pVirtualSite);

    //
    // Since we are dependent on the id's that
    // the worker process sends us, it is entirely possible
    // that we can not find the site.  There for if spewing is
    // on just tell us about it and go on.
    //
    if ( ReturnCode != LK_SUCCESS )
    {
  
        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Did not find site %d in the hash table "
                "(this can happen if the site was deleted but the wp had all ready accessed it)\n",
                SiteId
                ));
        }

        // Just make sure that the virtual site still is null
        DBG_ASSERT ( pVirtualSite == NULL );

        goto exit;
    }

exit:

    return pVirtualSite;
}


/***************************************************************************++

Routine Description:

    Adds the WPG group as well as the LocalService and NetworkService to 
    the Desktop so we can access the worker processes with debuggers.

Arguments:

    None

Return Value:

    HRESULT
--***************************************************************************/
HRESULT
AlterDesktopForWPGUsers()
{
    HRESULT hr = S_OK;
    BUFFER buffSid;
    DWORD cbSid = buffSid.QuerySize();
    BUFFER buffDomainName;
    DWORD cchDomainName = buffDomainName.QuerySize() / sizeof(WCHAR);
    SID_NAME_USE peUse;

    HWINSTA hwinsta = GetProcessWindowStation();
    DBG_ASSERT(hwinsta != NULL);

    // 
    // obtain a handle to the desktop
    // 
    HDESK hdesk = GetThreadDesktop(GetCurrentThreadId());
    DBG_ASSERT(hdesk != NULL);

    //
    // obtain the logon sid of the IIS_WPG group
    //
    while(!LookupAccountName(NULL,
                             L"IIS_WPG",
                             buffSid.QueryPtr(),
                             &cbSid,
                             (LPWSTR)buffDomainName.QueryPtr(),
                             &cchDomainName,
                             &peUse))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not look up the IIS_WPG group sid.\n"
                ));

            goto Exit;
        }

        if (!buffSid.Resize(cbSid) ||
            !buffDomainName.Resize(cchDomainName * sizeof(WCHAR)))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to allocate appropriate space for the WPG sid\n"
                ));

            goto Exit;
        }
    }

    // 
    // add the user to the windowstation
    // 
    if (!AddTheAceWindowStation(hwinsta,
                                buffSid.QueryPtr()))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the IIS_WPG Ace to the Window Station\n"
            ));

        goto Exit;
    }

    // 
    // add user to the desktop
    // 
    if (!AddTheAceDesktop(hdesk,
                          buffSid.QueryPtr()))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the IIS_WPG Ace to the Desktop\n"
            ));

        goto Exit;
    }

    // 
    // Now add the LocalService SID
    //
    while(!CreateWellKnownSid(WinLocalServiceSid, 
                              NULL, 
                              buffSid.QueryPtr(), 
                              &cbSid) )
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not look up the LocalService sid.\n"
                ));

            goto Exit;
        }

        if (!buffSid.Resize(cbSid))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to allocate appropriate space for the LocalService sid\n"
                ));

            goto Exit;
        }
    }

    // 
    // add local service to the windowstation
    // 
    if (!AddTheAceWindowStation(hwinsta,
                                buffSid.QueryPtr()))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the LocalService Ace to the Window Station\n"
            ));

        goto Exit;
    }

    // 
    // add local service to the desktop
    // 
    if (!AddTheAceDesktop(hdesk,
                          buffSid.QueryPtr()))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the LocalService Ace to the Desktop\n"
            ));

        goto Exit;
    }

    //
    // Now add the NetworkService SID
    //
    while(!CreateWellKnownSid(WinNetworkServiceSid, 
                              NULL, 
                              buffSid.QueryPtr(), 
                              &cbSid) )
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not look up the NetworkService sid.\n"
                ));

            goto Exit;
        }

        if (!buffSid.Resize(cbSid))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to allocate appropriate space for the NetworkService sid\n"
                ));

            goto Exit;
        }
    }

    // 
    // add network service to the windowstation
    // 
    if (!AddTheAceWindowStation(hwinsta,
                                buffSid.QueryPtr()))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the NetworkService Ace to the Window Station\n"
            ));

        goto Exit;
    }

    // 
    // add network service to the desktop
    // 
    if (!AddTheAceDesktop(hdesk,
                          buffSid.QueryPtr()))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not add the NetworkService Ace to the Desktop\n"
            ));

        goto Exit;
    }


 Exit:
    // 
    // close the handles to the windowstation and desktop
    // 
    CloseWindowStation(hwinsta);

    CloseDesktop(hdesk);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site.h

Abstract:

    The IIS web admin service virtual site class definition.

Author:

    Seth Pollack (sethp)        04-Nov-1998

Revision History:

--*/


#ifndef _VIRTUAL_SITE_H_
#define _VIRTUAL_SITE_H_


//
// common #defines
//

#define VIRTUAL_SITE_SIGNATURE          CREATE_SIGNATURE( 'VSTE' )
#define VIRTUAL_SITE_SIGNATURE_FREED    CREATE_SIGNATURE( 'vstX' )


#define INVALID_VIRTUAL_SITE_ID 0xFFFFFFFF

// Virtual Site Directory Name is the W3SVC key with the 
// virtual site id appended.
#define VIRTUAL_SITE_DIRECTORY_NAME_PREFIX L"\\W3SVC"

// Size in characters, not including the NULL terminator.
#define CCH_IN_VIRTUAL_SITE_DIRECTORY_NAME_PREFIX (sizeof(VIRTUAL_SITE_DIRECTORY_NAME_PREFIX) / sizeof(WCHAR)) - 1

// This value is the maximum size of data returned but 
// _itow.  It does include the NULL terminator.
#define MAX_SIZE_BUFFER_FOR_ITOW 64

// MAX_SIZE_OF_SITE_DIRECTORY is equal to size of the 
// Directory Name Prefix plus the maximum number size
// that itow can return when converting an integer into
// a wchar (this includes null termination.
#define MAX_SIZE_OF_SITE_DIRECTORY_NAME sizeof(VIRTUAL_SITE_DIRECTORY_NAME_PREFIX) + MAX_SIZE_BUFFER_FOR_ITOW

//
// structs, enums, etc.
//

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
// Structure for handling maximum
// values of the site perf counters.
//
typedef struct _W3_MAX_DATA
{
    DWORD MaxAnonymous;
    DWORD MaxConnections;
    DWORD MaxCGIRequests;
    DWORD MaxBGIRequests;
    DWORD MaxNonAnonymous;
} W3_MAX_DATA;

//
// Issue 10/16/2000 EmilyK  Move to CounterObject when it exists.
//
typedef enum _COUNTER_SOURCE_ENUM
{
    ULCOUNTERS = 0,
    WPCOUNTERS = 1
} COUNTER_SOURCE_ENUM;

// virtual site configuration
typedef struct _VIRTUAL_SITE_CONFIG
{

    //
    // The network bindings for the site, organized as a Unicode multisz
    // of binding strings (a set of contiguous Unicode strings, 
    // terminated by an extra Unicode null). Each binding string is of  
    // the format "[http|https]://[ip-address|host-name|*]:ip-port". 
    // All pieces of information (protocol, address information, and port)
    // must be present. The "*" means accept any ip-address or host-name.
    // The first member below is the pointer to the multisz; the second
    // is the total count of bytes of the multisz.
    //
    WCHAR * pBindingsStrings;
    ULONG BindingsStringsCountOfBytes;

    //
    // Whether the site should be started at service startup, or not.
    //
    BOOL Autostart;


    //
    // CODEWORK Eventually other site config like logging, etc. will
    // go here. 
    //

    // Logging Properties (passed to UL on the default application).
    DWORD LogType;
    DWORD LogFilePeriod;
    DWORD LogFileTruncateSize;
    DWORD LogExtFileFlags;
    BOOL  LogFileLocaltimeRollover;

    LPCWSTR pLogPluginClsid;
    LPCWSTR pLogFileDirectory;

    //
    // Server comment is used to display which site the counters
    // are from.
    //
    LPCWSTR pServerComment;

    // 
    // Max bandwidth allowed for this site.
    //
    DWORD MaxBandwidth;

    //
    // Max connections allowed for this site.
    //
    DWORD MaxConnections;

    //
    // ConnectionTimeout for this site.
    //
    DWORD ConnectionTimeout;

    //
    // READ THIS: If you add to or modify this structure, be sure to 
    // update the change flags structure below to match. 
    //

} VIRTUAL_SITE_CONFIG;


// virtual site configuration change flags
typedef struct _VIRTUAL_SITE_CONFIG_CHANGE_FLAGS
{

    DWORD_PTR pBindingsStrings : 1;
    // Flag not needed for BindingsStringsCountOfBytes, it is tied to pBindingsStrings
    // Flag not neded for Autostart, we ignore changes on it
    DWORD_PTR LogType : 1;
    DWORD_PTR LogFilePeriod : 1;
    DWORD_PTR LogFileTruncateSize : 1;
    DWORD_PTR LogExtFileFlags : 1;
    DWORD_PTR LogFileLocaltimeRollover : 1;
    DWORD_PTR pLogPluginClsid : 1;
    DWORD_PTR pLogFileDirectory : 1;
    DWORD_PTR pServerComment : 1;
    DWORD_PTR MaxBandwidth : 1;
    DWORD_PTR MaxConnections : 1;
    DWORD_PTR ConnectionTimeout : 1;

} VIRTUAL_SITE_CONFIG_CHANGE_FLAGS;



//
// prototypes
//

class VIRTUAL_SITE
{

public:

    VIRTUAL_SITE(
        );

    virtual
    ~VIRTUAL_SITE(
        );

    HRESULT
    Initialize(
        IN DWORD VirtualSiteId,
        IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig
        );

    HRESULT
    SetConfiguration(
        IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig,
        IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    VOID
    AggregateCounters(
        IN COUNTER_SOURCE_ENUM CounterSource,
        IN LPVOID pCountersToAddIn
        );

    VOID
    AdjustMaxValues(
        );


    VOID
    ClearAppropriatePerfValues(
        );

    inline
    DWORD
    GetVirtualSiteId(
        )
        const
    { return m_VirtualSiteId; }

    LPWSTR
    GetVirtualSiteDirectory(
        )
    {
        if (m_VirtualSiteDirectory[0] == L'\0')
        {
            // Copy in the prefix.
            wcscpy(m_VirtualSiteDirectory, VIRTUAL_SITE_DIRECTORY_NAME_PREFIX);

            // Copy in the virtual site id (in wchar form).
            _itow(m_VirtualSiteId
                , m_VirtualSiteDirectory + CCH_IN_VIRTUAL_SITE_DIRECTORY_NAME_PREFIX
                , 10);
        }

        return m_VirtualSiteDirectory;
    }

    LPWSTR
    GetVirtualSiteName(
        )
    {  
        return m_ServerComment;
    }


    HRESULT
    AssociateApplication(
        IN APPLICATION * pApplication
        );

    HRESULT
    DissociateApplication(
        IN APPLICATION * pApplication
        );

    VOID
    ResetUrlPrefixIterator(
        );

    LPCWSTR
    GetNextUrlPrefix(
        );

    HRESULT
    RecordState(
        HRESULT Error
        );

    inline
    PLIST_ENTRY
    GetDeleteListEntry(
        )
    { return &m_DeleteListEntry; }

    static
    VIRTUAL_SITE *
    VirtualSiteFromDeleteListEntry(
        IN const LIST_ENTRY * pDeleteListEntry
        );


#if DBG
    VOID
    DebugDump(
        );

#endif  // DBG


    HRESULT
    ProcessStateChangeCommand(
        IN DWORD Command,
        IN BOOL DirectCommand,
        OUT DWORD * pNewState
        );

   
    inline
    DWORD
    GetState(
        )
        const
    { return m_State; }


    BOOL 
    LoggingEnabled(
        )
    {
        return (( m_LoggingFormat < HttpLoggingTypeMaximum )
                 && ( m_LoggingEnabled ));
    }

    HTTP_LOGGING_TYPE
    GetLogFileFormat(
        )
    { return m_LoggingFormat; }


    LPWSTR 
    GetLogFileDirectory(
        )
    {   return m_LogFileDirectory;   }

    DWORD
    GetLogPeriod(
        )
    { return m_LoggingFilePeriod; }

    DWORD
    GetLogFileTruncateSize(
        )
    { return m_LoggingFileTruncateSize; }
        
    DWORD
    GetLogExtFileFlags(
        )
    { return m_LoggingExtFileFlags; }

    DWORD
    GetLogFileLocaltimeRollover(
        )
    { return m_LogFileLocaltimeRollover; }

    VOID
    MarkSiteAsNotInMetabase(
        )
    { m_VirtualSiteInMetabase = FALSE; }
    
    BOOL    
    CheckAndResetServerCommentChanged(
        )
    {
        //
        // Save the server comment setting
        //
        BOOL ServerCommentChanged = m_ServerCommentChanged;

        //
        // reset it appropriately.
        //
        m_ServerCommentChanged = FALSE;

        //
        // now return the value we saved.
        //
        return ServerCommentChanged;
    }

    VOID
    SetMemoryOffset(
        IN ULONG MemoryOffset
        )
    {
        //
        // A memory offset of zero means that
        // we have not set the offset yet.  
        // 
        // Zero is reserved for _Total.
        // 
        DBG_ASSERT ( MemoryOffset != 0 );
        m_MemoryOffset = MemoryOffset;
    }

    ULONG
    GetMemoryOffset(
        )
    { 
        //
        // A memory offset of zero means that
        // we have not set the offset yet.  If
        // we attempt to get it and have not set
        // it then we are in trouble.
        // 
        // Zero is reserved for _Total.
        // 
        DBG_ASSERT ( m_MemoryOffset != 0 );
        return m_MemoryOffset; 
    }


    W3_COUNTER_BLOCK*
    GetCountersPtr(
        )
    { return &m_SiteCounters; }

    PROP_DISPLAY_DESC*
    GetDisplayMap(
        );

    DWORD
    GetSizeOfDisplayMap(
        );

    DWORD
    GetMaxBandwidth(
        )
    { return m_MaxBandwidth; }

    DWORD
    GetMaxConnections(
        )
    { return m_MaxConnections; }

    DWORD
    GetConnectionTimeout(
        )
    { return m_ConnectionTimeout; }

    VOID
    FailedToBindUrlsForSite(
        HRESULT hrReturned
        );

private:

    HRESULT
    ApplyStateChangeCommand(
        IN DWORD Command,
        IN BOOL DirectCommand,
        IN DWORD NewState
        );

    HRESULT
    ChangeState(
        IN DWORD NewState,
        IN HRESULT Error,
        IN BOOL WriteToMetabase
        );

    HRESULT
    ControlAllApplicationsOfSite(
        IN DWORD Command
        );

    HRESULT
    NotifyApplicationsOfBindingChange(
        );

    HRESULT
    NotifyDefaultApplicationOfLoggingChanges(
        );

    HRESULT
    EvaluateLoggingChanges(
        IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig,
        IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );
    
    DWORD m_Signature;

    DWORD m_VirtualSiteId;

    WCHAR m_VirtualSiteDirectory[MAX_SIZE_OF_SITE_DIRECTORY_NAME];

    // ServerComment is truncated at the max name length for
    // a perf counter instance, this is all it is used for.
    WCHAR m_ServerComment[MAX_INSTANCE_NAME];

    // current state for this site, set to a W3_CONTROL_STATE_xxx value
    DWORD m_State;

    // applications associated with this virtual site
    LIST_ENTRY m_ApplicationListHead;

    ULONG m_ApplicationCount;

    // virtual site bindings (aka URL prefixes)
    MULTISZ * m_pBindings;

    // current position of the iterator
    LPCWSTR m_pIteratorPosition;

    // autostart state
    BOOL m_Autostart;

    // Is Logging Enabled for the site?
    BOOL m_LoggingEnabled;

    // Type of logging
    HTTP_LOGGING_TYPE m_LoggingFormat;

    // The log file directory in the form
    // appropriate for passing to UL.
    LPWSTR m_LogFileDirectory;

    // The log file period for the site.
    DWORD m_LoggingFilePeriod;

    // The log file truncation size.
    DWORD m_LoggingFileTruncateSize;

    // The log file extension flags
    DWORD m_LoggingExtFileFlags;

    // Whether to roll the time over according to
    // local time.
    BOOL m_LogFileLocaltimeRollover;

    //
    // The MaxBandwidth allowed for the site.
    //
    DWORD m_MaxBandwidth;

    // 
    // The MaxConnections allowed for the site.
    //
    DWORD m_MaxConnections;

    //
    // The Connection timeout for the site.
    //
    DWORD m_ConnectionTimeout;

    // used for building a list of VIRTUAL_SITEs to delete
    LIST_ENTRY m_DeleteListEntry;

    // used to let the destructor know that we do not want
    // to update the metabase about this site because the 
    // site has been deleted from the metabase.
    BOOL m_VirtualSiteInMetabase;

    // track if the server comment has changed since the 
    // last time perf counters were given out.
    BOOL m_ServerCommentChanged;

    // memory reference pointer to perf counter
    // data.
    ULONG m_MemoryOffset;

    //
    // saftey counter block for the site.
    W3_COUNTER_BLOCK m_SiteCounters;

    //
    // saftey for max values.
    W3_MAX_DATA m_MaxSiteCounters;

    //
    // Site Start Time
    //
    DWORD m_SiteStartTime;

    //
    // Root application for the site.
    //
    APPLICATION* m_pRootApplication;

};  // class VIRTUAL_SITE



#endif  // _VIRTUAL_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\virtual_site_table.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    virtual_site_table.h

Abstract:

    The IIS web admin service virtual site table class definition.

Author:

    Seth Pollack (sethp)        03-Nov-1998

Revision History:

--*/


#ifndef _VIRTUAL_SITE_TABLE_H_
#define _VIRTUAL_SITE_TABLE_H_

class PERF_MANAGER;

//
// prototypes
//

class VIRTUAL_SITE_TABLE
    : public CTypedHashTable< VIRTUAL_SITE_TABLE, VIRTUAL_SITE, DWORD >
{

public:

    VIRTUAL_SITE_TABLE(
        )
        : CTypedHashTable< VIRTUAL_SITE_TABLE, VIRTUAL_SITE, DWORD >
                ( "VIRTUAL_SITE_TABLE" )
    { /* do nothing*/ }

    virtual
    ~VIRTUAL_SITE_TABLE(
        )
    { DBG_ASSERT( Size() == 0 ); }

    static
    DWORD
    ExtractKey(
        IN const VIRTUAL_SITE * pVirtualSite
        )  
    { return pVirtualSite->GetVirtualSiteId(); }
    
    static
    DWORD
    CalcKeyHash(
        IN DWORD Key
        ) 
    { return Hash( Key ); }
    
    static
    bool
    EqualKeys(
        IN DWORD Key1,
        IN DWORD Key2
        )
    { return (  Key1 == Key2 ); }
    
    static
    void
    AddRefRecord(
        IN VIRTUAL_SITE * pVirtualSite,
        IN int IncrementAmount
        ) 
    { /* do nothing*/ }

    VOID
    Terminate(
        );

    static
    LK_ACTION
    DeleteVirtualSiteAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pDeleteListHead
        );

    static
    LK_ACTION
    RehookVirtualSiteAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pIgnored
        );

    VOID
    ReportPerformanceInfo(
        IN PERF_MANAGER* pManager,
        IN BOOL          StructChanged
        );

#if DBG
    VOID
    DebugDump(
        );

    static
    LK_ACTION
    DebugDumpVirtualSiteAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pIgnored
        );
#endif  // DBG


    HRESULT
    ControlAllSites(
        IN DWORD Command
        );

    static
    LK_ACTION
    ControlAllSitesVirtualSiteAction(
        IN VIRTUAL_SITE * pVirtualSite, 
        IN VOID * pCommand
        );

    static
    LK_ACTION
    ReportCountersVirtualSiteAction(
        IN VIRTUAL_SITE* pVirtualSite, 
        IN LPVOID pManagerVoid
        );

private:

    BOOL m_SitesHaveChanged;

};  // VIRTUAL_SITE_TABLE



#endif  // _VIRTUAL_SITE_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\web_admin_service.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    web_admin_service.cxx

Abstract:

    The IIS web admin service class implementation.  

    Threading: The following public methods may be called on any thread:
        ~WEB_ADMIN_SERVICE()
        Reference()
        Dereference()
        GetWorkQueue()
        GetMainWorkerThreadId()
        GetServiceState()
        FatalErrorOnSecondaryThread()
        InterrogateService()
        InitiateStopService()
        InitiatePauseService()
        InitiateContinueService()
        UpdatePendingServiceStatus()
    All other public methods may be called only on the main worker thread.
    The ServiceControlHandler() and UpdatePendingServiceStatusCallback() 
    functions are called on secondary threads. 


Author:

    Seth Pollack (sethp)        23-Jul-1998

Revision History:

--*/



#include "precomp.h"



//
// local prototypes
//

// service control callback
VOID
ServiceControlHandler(
    IN DWORD OpCode
    );


// service status pending timer callback
VOID
UpdatePendingServiceStatusCallback(
    IN PVOID Ignored1,
    IN BOOLEAN Ignored2
    );

// callback for inetinfo monitor.
HRESULT
NotifyOfInetinfoFailure(
    INETINFO_CRASH_ACTION CrashAction
    );



/***************************************************************************++

Routine Description:

    Constructor for the WEB_ADMIN_SERVICE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WEB_ADMIN_SERVICE::WEB_ADMIN_SERVICE(
    )
    :
    m_WorkQueue(),
    m_UlAndWorkerManager(),
    m_ConfigAndControlManager(),
    m_EventLog( WEB_ADMIN_SERVICE_EVENT_SOURCE_NAME ),
    m_ServiceStateTransitionLock(),
    m_hrToReportToSCM ( S_OK )
{

    m_StoppingInProgress = FALSE;

    m_UseTestW3WP = FALSE;
    

    //
    // BUGBUG The event log constructor can fail. Lame. Best approach is 
    // to fix the EVENT_LOG class. On retail builds, we silently ignore;
    // the EVENT_LOG class does verify whether it has initialized correctly
    // when you try to log an event.
    //

    DBG_ASSERT( m_EventLog.Success() );


    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_pMessageGlobal = NULL; 
    
    m_pIoFactoryS = NULL;

    m_pLowMemoryDetector = NULL;

    m_fMetabaseCrashed = FALSE;


    m_ServiceStatusHandle = NULL_SERVICE_STATUS_HANDLE;


    //
    // Initialize the service status structure.
    //
    
    m_ServiceStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    m_ServiceStatus.dwCurrentState            = SERVICE_STOPPED;
    m_ServiceStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;
    m_ServiceStatus.dwWin32ExitCode           = NO_ERROR;
    m_ServiceStatus.dwServiceSpecificExitCode = NO_ERROR;
    m_ServiceStatus.dwCheckPoint              = 0;
    m_ServiceStatus.dwWaitHint                = 0;


    m_PendingServiceStatusTimerHandle = NULL;

    m_SharedTimerQueueHandle = NULL;


    m_ExitWorkLoop = FALSE;


    // the initializing main service thread will become our main worker thread
    m_MainWorkerThreadId = GetCurrentThreadId();


    m_SecondaryThreadError = S_OK;


    m_pCurrentDirectory = NULL; 

    m_pLocalSystemTokenCacheEntry = NULL;

    m_pLocalServiceTokenCacheEntry = NULL;

    m_pNetworkServiceTokenCacheEntry = NULL;
    
    m_InetinfoLaunchEvent = NULL;

    m_BackwardCompatibilityEnabled = ENABLED_INVALID;

    m_WorkerProcessProfilingEnabled = FALSE;

    m_FilterAllData = FALSE;

    m_ServiceStartTime = 0;

    m_Signature = WEB_ADMIN_SERVICE_SIGNATURE;

}   // WEB_ADMIN_SERVICE::WEB_ADMIN_SERVICE



/***************************************************************************++

Routine Description:

    Destructor for the WEB_ADMIN_SERVICE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WEB_ADMIN_SERVICE::~WEB_ADMIN_SERVICE(
    )
{

    DBG_ASSERT( m_Signature == WEB_ADMIN_SERVICE_SIGNATURE );

    m_Signature = WEB_ADMIN_SERVICE_SIGNATURE_FREED;

    DBG_ASSERT( m_RefCount == 0 );


    DBG_ASSERT( m_pMessageGlobal == NULL );


    DBG_ASSERT( m_pLowMemoryDetector == NULL );


    //
    // Note that m_ServiceStatusHandle doesn't have to be closed.
    //


    DBG_ASSERT( m_PendingServiceStatusTimerHandle == NULL );


    m_ServiceStateTransitionLock.Terminate();


    delete m_pCurrentDirectory;
    m_pCurrentDirectory = NULL;

    if ( m_pLocalSystemTokenCacheEntry != NULL )
    {
        m_pLocalSystemTokenCacheEntry->DereferenceCacheEntry();
        m_pLocalSystemTokenCacheEntry = NULL;
    }

    if ( m_pLocalServiceTokenCacheEntry != NULL )
    {
        m_pLocalServiceTokenCacheEntry->DereferenceCacheEntry();
        m_pLocalServiceTokenCacheEntry = NULL;
    }

    if ( m_pNetworkServiceTokenCacheEntry != NULL )
    {
        m_pNetworkServiceTokenCacheEntry->DereferenceCacheEntry();
        m_pNetworkServiceTokenCacheEntry = NULL;
    }

    m_TokenCache.Clear();
    //
    // CAUTION: this is a static call - it Terminates all token caches in the process
    //
    m_TokenCache.Terminate();

    if (m_InetinfoLaunchEvent != NULL)
    {
        DBG_REQUIRE( CloseHandle( m_InetinfoLaunchEvent ) );
        m_InetinfoLaunchEvent = NULL;
    }

}   // WEB_ADMIN_SERVICE::~WEB_ADMIN_SERVICE



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // WEB_ADMIN_SERVICE::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_REFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in WEB_ADMIN_SERVICE, deleting, ptr: %p\n",
                this
                ));
        }


        //
        // Say goodbye.
        //

        delete this;
        
    }
    

    return;
    
}   // WEB_ADMIN_SERVICE::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in WEB_ADMIN_SERVICE: %p with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case StartWebAdminServiceWorkItem:
        hr = StartServiceWorkItem();
        break;

    case StopWebAdminServiceWorkItem:
        hr = StopServiceWorkItem();
        break;

    case PauseWebAdminServiceWorkItem:
        hr = PauseServiceWorkItem();
        break;

    case ContinueWebAdminServiceWorkItem:
        hr = ContinueServiceWorkItem();
        break;

    case RecoverFromInetinfoCrashWebAdminServiceWorkItem:
        hr = RecoverFromInetinfoCrash();
        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );
            
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
            
    }

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing work item on WEB_ADMIN_SERVICE failed\n"
            ));

    }

    return hr;
    
}   // WEB_ADMIN_SERVICE::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Execute the web admin service.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::ExecuteService(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = StartWorkQueue();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not start work queue\n"
            ));

        goto exit;
    }


    //
    // Enter the main work loop.
    //
    
    hr = MainWorkerThread();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Main work loop function returned an error\n"
            ));

        goto exit;
    }


exit:

    //
    // Need to flag that we are stopping the w3svc so we
    // don't attempt to stop it again.  This is because we may
    // not have told the w3svc that we intend on stopping, if we
    // are stopping due to an error.
    //
    m_StoppingInProgress = TRUE;

    //
    // Do final service cleanup.
    //

    TerminateServiceAndReportFinalStatus( hr );


    return;
    
}   // WEB_ADMIN_SERVICE::ExecuteService



/***************************************************************************++

Routine Description:

    Report a failure which occurred on a secondary thread, i.e. some thread 
    besides the main worker thread. The main worker thread will deal with 
    this error later.

    Note that this routine may be called from any thread. It should not be 
    called by the main work thread however; errors on the main worker thread
    are dealt with in the main work loop.

Arguments:

    SecondaryThreadError - The error which occurred on the secondary thread.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::FatalErrorOnSecondaryThread(
    IN HRESULT SecondaryThreadError
    )
{

    // verify we are NOT on the main worker thread
    DBG_ASSERT( ! ON_MAIN_WORKER_THREAD );

    //
    // Note that we only capture the most recent error, not the first one
    // that occurred.
    //
    // Also, no explicit synchronization is necessary on this thread-shared 
    // variable because this is an aligned 32-bit write.
    //

    m_SecondaryThreadError = SecondaryThreadError;

    return;

}   // WEB_ADMIN_SERVICE::FatalErrorOnSecondaryThread



/***************************************************************************++

Routine Description:

    Handle a request for a status update from the service controller. Done
    directly on a secondary thread. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InterrogateService(
    )
{

    HRESULT hr = S_OK;


    m_ServiceStateTransitionLock.Lock();


    //
    // Note: this command is accepted while the service is in any state.
    //


    hr = ReportServiceStatus();
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't report the service status\n"
            ));

    }


    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::InterrogateService

/***************************************************************************++

Routine Description:

    If we are in backward compatible mode this will either tell the service
    that we failed to start and gracefully get us out of any situation we
    are in, or it will register that we have started successfully.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::InetinfoRegistered(
    )
{
    HRESULT hr;
    DBG_ASSERT(m_BackwardCompatibilityEnabled == ENABLED_TRUE);

    // 
    // Only notify the service control manager that 
    // the service has finished starting, if the
    // service is is still sitting in the pending state.
    // 
    // If inetinfo recycles this code will get called
    // but since we have not told the service to stop
    // while inetinfo is recycling we don't want to tell
    // it that it has started again.
    //
    
    // ISSUE-2000/07/21-emilyk:  Use Service Pending?
    //          Maybe we want to change the service to 
    //          paused and back again when inetinfo recycles.

    if (m_ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        hr = FinishStartService();
        if ( FAILED( hr ) )
        {

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Couldn't finish the start service\n"
                ));

        }
    }


}   // WEB_ADMIN_SERVICE::InetinfoRegistered

/***************************************************************************++

Routine Description:

    Begin stopping the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitiateStopService(
    )
{
    
    return RequestStopService ( TRUE );

}   // WEB_ADMIN_SERVICE::InitiateStopService

/***************************************************************************++

Routine Description:

    Begin stopping the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    EnableStateCheck - lets us know if we want to only allow this call when
                       the service is not in a pending state.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::RequestStopService(
    BOOL EnableStateCheck
    )
{

    HRESULT hr = S_OK;

    //
    // If we are all ready stopping then we don't need to 
    // initiate another stop.
    //
    if ( m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ||
         m_StoppingInProgress ) 
    {
        return S_OK;
    }

    hr = BeginStateTransition( SERVICE_STOP_PENDING, EnableStateCheck );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't transition to service stop pending\n"
            ));

        goto exit;
    }

    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            StopWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue stop service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::RequestStopService

/***************************************************************************++

Routine Description:

    Begin pausing the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitiatePauseService(
    )
{

    HRESULT hr = S_OK;


    hr = BeginStateTransition( SERVICE_PAUSE_PENDING, TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't transition to service pause pending\n"
            ));

        goto exit;
    }


    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            PauseWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue pause service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitiatePauseService



/***************************************************************************++

Routine Description:

    Begin continuing the web admin service, by setting the service status to
    pending, and posting a work item to the main thread to do the real work. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitiateContinueService(
    )
{

    HRESULT hr = S_OK;


    hr = BeginStateTransition( SERVICE_CONTINUE_PENDING, TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't transition to service continue pending\n"
            ));

        goto exit;
    }


    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            ContinueWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue continue service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitiateContinueService



/***************************************************************************++

Routine Description:

    Keep the service controller happy by continuing to update it regularly
    on the status of any pending service state transition.

    There are several possible cases. If we are still in a pending state
    (whether it is the original pending state, or even a different pending 
    state which can arise because a new operation was started), we go ahead
    and update the service controller. However, it is also possible that the
    state transition just finished, but that this call was already underway. 
    In this case, we do nothing here.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::UpdatePendingServiceStatus(
    )
{

    HRESULT hr = S_OK;


    m_ServiceStateTransitionLock.Lock();


    // see if we are still in a pending service state

    if ( IsServiceStateChangePending() )
    {

        m_ServiceStatus.dwCheckPoint++;


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Updating the service state checkpoint to: %lu\n",
                m_ServiceStatus.dwCheckPoint
                ));
        }


        //
        // If the checkpoint gets really high, then probably something 
        // is broken... on debug builds, assert to get our attention. 
        //

        DBG_ASSERT( m_BackwardCompatibilityEnabled || m_ServiceStatus.dwCheckPoint < 60 );


        hr = ReportServiceStatus();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not report service status\n"
                ));

        }

    }
    else
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Ignoring pending service status timer, not in pending state. State: %lu\n",
                m_ServiceStatus.dwCurrentState
                ));
        }

    }


    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::UpdatePendingServiceStatus

/***************************************************************************++

Routine Description:

    Queues a work item to recover from the inetinfo crash.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::QueueRecoveryFromInetinfoCrash(
    )
{

    HRESULT hr = S_OK;

    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            RecoverFromInetinfoCrashWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue the recovery from the inetinfo crash \n"
            ));

    }


    return hr;

}   // WEB_ADMIN_SERVICE::RequestStopService


/***************************************************************************++

Routine Description:

    Used by the UL&WM to notify that it has finished it's shutdown work. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::UlAndWorkerManagerShutdownDone(
    )
{
    return FinishStopService();

}   // WEB_ADMIN_SERVICE::UlAndWorkerManagerShutdownDone



/***************************************************************************++

Routine Description:

    Initializes the work queue, and then posts the work item to start the 
    service.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::StartWorkQueue(
    )
{

    HRESULT hr = S_OK;


    // 
    // Just initialize the work queue here. Postpone all other initialization
    // until we're in StartServiceWorkItem().
    //
    
    hr = m_WorkQueue.Initialize();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't initialize work queue\n"
            ));

        goto exit;
    }


    hr = m_WorkQueue.GetAndQueueWorkItem(
                            this,
                            StartWebAdminServiceWorkItem
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't queue start service work item\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::StartWorkQueue



/***************************************************************************++

Routine Description:

    The work loop for the main worker thread.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::MainWorkerThread(
    )
{

    HRESULT hr = S_OK;


    //
    // CODEWORK Consider changing error handling strategy to not exit in
    // the case of an error that bubbles up here, to the top of the loop. 
    //


    while ( ! m_ExitWorkLoop )
    {

        hr = m_WorkQueue.ProcessWorkItem();


        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Processing work item failed\n"
                ));


            //
            // If there was an unhandled error while processing the work item,
            // bail out of the work loop.
            //

            m_ExitWorkLoop = TRUE;

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Exiting main work loop due to error on main worker thread\n"
                ));

        }
        else
        {

            //
            // See how the other threads are doing.
            //
            // If there has been an unhandled error on a secondary thread
            // (i.e. other threads besides the main worker thread) since the 
            // last trip through the work loop, get the error and bail out of 
            // the work loop.
            //
            // This means that a secondary thread error may not be processed
            // for some time after it happens, because something else has to
            // wake up the main worker thread off of its completion port to
            // send it back through this loop. This seems preferable however
            // to making the main worker thread wake up periodically to check,
            // which would prevent it from getting paged out.
            //
            // Note that no explicit synchronization is used in accessing this 
            // thread-shared variable, because it is an aligned 32-bit read.
            //

            if ( FAILED( m_SecondaryThreadError ) )
            {
            
                hr = m_SecondaryThreadError;
                
                m_ExitWorkLoop = TRUE;

                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Exiting main work loop due to error on secondary thread\n"
                    ));

            }
            
        }
        
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Main worker thread has exited it's work loop\n"
            ));
    }


    return hr;

}   // WEB_ADMIN_SERVICE::MainWorkerThread



/***************************************************************************++

Routine Description:

    Begin starting the web admin service. Register the service control 
    handler, set the service state to pending, and then kick off the real 
    work.
    
Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::StartServiceWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = InitializeInternalComponents();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing internal components failed\n"
            ));

        goto exit;
    }


    hr = BeginStateTransition( SERVICE_START_PENDING, TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't transition to service start pending\n"
            ));

        goto exit;
    }

    //
    // Start up the other components of the service.
    //

    hr = InitializeOtherComponents();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't initialize subcomponents\n"
            ));

        goto exit;
    }

    if (m_BackwardCompatibilityEnabled == ENABLED_FALSE)
    {
        //
        // Only finish starting the service if we are not
        // in backward compatibility mode.  If we are then 
        // we need to wait to finish until the worker process
        // answers back.
        //

        hr = FinishStartService();

        if ( FAILED( hr ) )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Finishing start service state transition failed\n"
                ));

            goto exit;
        }
    }
    else
    {
        //
        // Demand start the worker process before marking the
        // service as started.  If there is a problem with the 
        // worker process coming up, then the service will be shutdown.
        //

        hr = m_UlAndWorkerManager.StartInetinfoWorkerProcess();
        
        if ( FAILED( hr ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Failed to start the worker process in inetinfo\n"
                ));

            goto exit;
        }
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::StartServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the started state.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishStartService(
    )
{

    HRESULT hr = S_OK;

    hr = FinishStateTransition( SERVICE_RUNNING, SERVICE_START_PENDING );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't finish transition into the running state\n"
            ));

    }

    m_ServiceStartTime = GetCurrentTimeInSeconds();

    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishStartService



/***************************************************************************++

Routine Description:

    Stop the web admin service. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::StopServiceWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // If we are all ready stopping don't go
    // through these stopping steps.  We can't use
    // the state of the service here because 
    // it is not deterministic of whether we have
    // all ready gone to far in the stopping 
    // stages to start stopping again.
    //

    if ( m_StoppingInProgress )
    {
        goto exit;
    }

    m_StoppingInProgress = TRUE;

    hr = Shutdown();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Kicking off service shutdown failed\n"
            ));

        goto exit;
    }


    //
    // Note that FinishStopService() will be called by the method
    // UlAndWorkerManagerShutdownDone() once the UL&WM's shutdown work 
    // is complete.
    //


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::StopServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the stopped state.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishStopService(
    )
{

    HRESULT hr = S_OK;


    //
    // Since we are done with regular service spindown, its time to exit
    // the main work loop, so that we can do our final cleanup. 
    //

    m_ExitWorkLoop = TRUE;


    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishStopService



/***************************************************************************++

Routine Description:

    Begin pausing the web admin service. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::PauseServiceWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = m_UlAndWorkerManager.ControlAllSites( W3_CONTROL_COMMAND_PAUSE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Pausing all sites for service pause failed\n"
            ));

        goto exit;
    }


    hr = FinishPauseService();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finishing pause service state transition failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::PauseServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the paused state.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishPauseService(
    )
{

    HRESULT hr = S_OK;


    hr = FinishStateTransition( SERVICE_PAUSED, SERVICE_PAUSE_PENDING );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't finish transition into the paused state\n"
            ));

    }


    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishPauseService



/***************************************************************************++

Routine Description:

    Begin continuing the web admin service. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::ContinueServiceWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = m_UlAndWorkerManager.ControlAllSites( W3_CONTROL_COMMAND_CONTINUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Continuing all sites for service continue failed\n"
            ));

        goto exit;
    }


    hr = FinishContinueService();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finishing continue service state transition failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::ContinueServiceWorkItem



/***************************************************************************++

Routine Description:

    Finish the service state transition into the running state via continue.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishContinueService(
    )
{

    HRESULT hr = S_OK;


    hr = FinishStateTransition( SERVICE_RUNNING, SERVICE_CONTINUE_PENDING );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't finish transition into the running state\n"
            ));

    }


    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishContinueService



/***************************************************************************++

Routine Description:

    Set the new service (pending) state, and start the timer to keep the 
    service controller happy while the state transition is pending.

Arguments:

    NewState - The pending state into which to transition.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::BeginStateTransition(
    IN DWORD NewState,
    IN BOOL  EnableStateCheck
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    // default the wait hint to the wait hint for everything
    // except the start up wait hint.
    DWORD dwWaitHint = WEB_ADMIN_SERVICE_STATE_CHANGE_WAIT_HINT;

    //
    // If we are starting then we are in a special case
    // we are not going to use the timers to keep us alive
    // we are just going to set a really large wait hint.
    //
    if ( NewState == SERVICE_START_PENDING )
    {
        //
        // Since we only start the service once for life of the svchost, 
        // we will only read from the registry once.
        //
        dwWaitHint = ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_STARTUP_WAIT_HINT, 0 );
        if ( dwWaitHint == 0 )
        {
            dwWaitHint = WEB_ADMIN_SERVICE_STARTUP_WAIT_HINT;
        }

    }
        
    m_ServiceStateTransitionLock.Lock();

    if ( IsServiceStateChangePending() && EnableStateCheck )
    {
        hr = HRESULT_FROM_WIN32( ERROR_SERVICE_CANNOT_ACCEPT_CTRL );
        goto exit;
    }

    hr = UpdateServiceStatus(
                NewState,
                NO_ERROR,
                NO_ERROR,
                1,
                dwWaitHint
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't set service status\n"
            ));

            goto exit;
    }
    
    if ( m_PendingServiceStatusTimerHandle != NULL ||
         NewState == SERVICE_START_PENDING )
    {
        //
        // If we all ready have a timer or if we are doing a start
        // we don't need to start a new timer.  The only place where
        // we may end up using the old timer is if we start shutting down 
        // due to a WP error in BC mode and are currently all ready in 
        // the middle of a continue or pause operation.
        //

        // Issue-EmilyK-3/13/2001  Service state changing investigation
        //      :  Have not actually checked how well this works if we do
        //         get a shutdown while in middle of a continue or pause.
        //         Then again, continue and pause still need attention in 
        //         general.
        
        goto exit;
    }

    // start the service status pending update timer

    DBG_ASSERT( m_SharedTimerQueueHandle != NULL );

    //
    // we have had one av from here, so I am be cautious.  I have also fixed
    // the reason we hit here with a null handle.
    // if we skip this we just won't update our stopping wait hints. better than
    // av'ing...
    //
    if ( m_SharedTimerQueueHandle )
    {
        Status = RtlCreateTimer(
                        m_SharedTimerQueueHandle,   // timer queue
                        &m_PendingServiceStatusTimerHandle,         
                                                    // returned timer handle
                        &UpdatePendingServiceStatusCallback,
                                                    // callback function
                        this,                       // context
                        WEB_ADMIN_SERVICE_STATE_CHANGE_TIMER_PERIOD,
                                                    // initial firing time
                        WEB_ADMIN_SERVICE_STATE_CHANGE_TIMER_PERIOD,
                                                    // subsequent firing period
                        WT_EXECUTEINWAITTHREAD      // execute callback directly
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not create timer\n"
                ));

            goto exit;
        }
    }


exit:

    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::BeginStateTransition



/***************************************************************************++

Routine Description:

    Complete the service state change from one of the pending states into
    the matching completed state. Note that it is possible that another, 
    different service state change operation has happened in the meantime.
    In this case, we detect that another operation has happened, and bail
    out without doing anything. In the standard case however, we shut down 
    the timer which was keeping the service controller happy during the 
    pending state, and set the new service state.

Arguments:

    NewState - The new service state to change to, if the service state is 
    still as expected.

    ExpectedPreviousState - What the service state must currently be in order
    to make the change.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::FinishStateTransition(
    IN DWORD NewState,
    IN DWORD ExpectedPreviousState
    )
{

    HRESULT hr = S_OK;


    m_ServiceStateTransitionLock.Lock();


    // 
    // See if we're still in the expected pending state, or if some other
    // state transition has occurred in the meantime.
    //
    
    if ( m_ServiceStatus.dwCurrentState != ExpectedPreviousState )
    {
    
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Not changing service state to: %lu, because current state is: %lu, was expected to be: %lu\n",
                NewState,
                m_ServiceStatus.dwCurrentState,
                ExpectedPreviousState
                ));
        }

        goto exit;
    }


    hr = CancelPendingServiceStatusTimer( FALSE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not cancel timer\n"
            ));

        goto exit;
    }


    hr = UpdateServiceStatus(
                NewState,
                NO_ERROR,
                NO_ERROR,
                0,
                0
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not update service status\n"
            ));

        goto exit;
    }


exit:

    m_ServiceStateTransitionLock.Unlock();


    return hr;
    
}   // WEB_ADMIN_SERVICE::FinishStateTransition



/***************************************************************************++

Routine Description:

    Determine whether the service is in a pending state.

Arguments:

    None.

Return Value:

    BOOL - TRUE if the service is in a pending state, FALSE otherwise.

--***************************************************************************/

BOOL
WEB_ADMIN_SERVICE::IsServiceStateChangePending(
    )
    const
{

    if ( m_ServiceStatus.dwCurrentState == SERVICE_START_PENDING   ||
         m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING    ||
         m_ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING   ||
         m_ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}   // WEB_ADMIN_SERVICE::IsServiceStateChangePending



/***************************************************************************++

Routine Description:

    Update the local copy of the service status structure, and report it 
    to the service controller.

Arguments:

    State - The service state.

    Win32ExitCode - Service error exit code. NO_ERROR when not used.

    ServiceSpecificExitCode - A service specific error exit code. If this 
    field is used, the Win32ExitCode parameter above must be set to the
    value ERROR_SERVICE_SPECIFIC_ERROR. This parameter should be set to
    NO_ERROR when not used.

    CheckPoint - Check point for lengthy state transitions. Should be
    incremented periodically during pending operations, and zero otherwise.

    WaitHint - Wait hint in milliseconds for lengthy state transitions.
    Should be zero otherwise.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::UpdateServiceStatus(
    IN DWORD State,
    IN DWORD Win32ExitCode,
    IN DWORD ServiceSpecificExitCode,
    IN DWORD CheckPoint,
    IN DWORD WaitHint
    )
{

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Setting service state to: %lu; state was: %lu\n",
            State,
            m_ServiceStatus.dwCurrentState
            ));
    }


    m_ServiceStatus.dwCurrentState = State;
    m_ServiceStatus.dwWin32ExitCode = Win32ExitCode;
    m_ServiceStatus.dwServiceSpecificExitCode = ServiceSpecificExitCode;
    m_ServiceStatus.dwCheckPoint = CheckPoint;
    m_ServiceStatus.dwWaitHint = WaitHint;


    return ReportServiceStatus();

} // WEB_ADMIN_SERVICE::UpdateServiceStatus()



/***************************************************************************++

Routine Description:

    Wraps the call to the SetServiceStatus() function, passing in the local 
    copy of the service status structure.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::ReportServiceStatus(
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;


    // ensure the service status handle has been initialized
    if ( m_ServiceStatusHandle == NULL_SERVICE_STATUS_HANDLE )
    {
    
        DBGPRINTF(( 
            DBG_CONTEXT,
            "Can't report service status because m_ServiceStatusHandle is null\n"
            ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE );

        goto exit;
    }


    //
    // Note: If we are setting the state to SERVICE_STOPPED, and we are
    // currently the only active service in this process, then at any
    // point after this call svchost.exe may call TerminateProcess(), thus
    // preventing our service from finishing its cleanup. As they say, 
    // that's just the way it is...
    //
    // GeorgeRe, 2000/08/10: This assertion appears to be ill-founded.
    // svchost.exe calls ExitProcess, not TerminateProcess. This provides
    // a more graceful shutdown path.
    //

    if ( m_ServiceStatus.dwCurrentState == SERVICE_STOPPED )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Setting SERVICE_STOPPED state, process may now exit at will\n"
                ));
        }
    }


    Success = SetServiceStatus(
                    m_ServiceStatusHandle, 
                    &m_ServiceStatus
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting service state failed\n"
            ));

        goto exit;
    }


exit:

    return hr;
    
}   // WEB_ADMIN_SERVICE::ReportServiceStatus()


/***************************************************************************++

Routine Description:

    Initialize internal components of this instance. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::InitializeInternalComponents(
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // Determine if we should break here early in startup for debugging
    // purposes. 
    //

    //
    // BUGBUG Currently this works in retail builds too. Should we keep
    // it this way?
    //

    if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_STARTUP_W, 0 ) )
    {
        DebugBreak();
    }



    //
    // Bump up the priority of the main worker thread slightly. We want to
    // make sure it is responsive to the degree possible (even in the face
    // of runaway worker processes, etc.).
    //

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    Success = SetThreadPriority(
                    GetCurrentThread(),             // handle to the thread
                    THREAD_PRIORITY_ABOVE_NORMAL    // thread priority level
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Setting thread priority failed\n"
            ));

        goto exit;
    }


    //
    // Initialize the service state lock.
    //

    hr = m_ServiceStateTransitionLock.Initialize();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Lock initialization failed\n"
            ));

        goto exit;
    }


    //
    // Register the service control handler.
    //

    m_ServiceStatusHandle = RegisterServiceCtrlHandler(
                                WEB_ADMIN_SERVICE_NAME_W,   // service name
                                ServiceControlHandler       // handler function
                                );

    if ( m_ServiceStatusHandle == NULL_SERVICE_STATUS_HANDLE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't register service control handler\n"
            ));

        goto exit;
    }


    //
    // Create the timer queue.
    //

    Status = RtlCreateTimerQueue( &m_SharedTimerQueueHandle );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not create timer queue\n"
            ));

        goto exit;
    }


    //
    // Determine and cache the path to where our service DLL lives.
    //

    hr = DetermineCurrentDirectory();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Determining current directory failed\n"
            ));

        goto exit;
    }


    //
    // Create and cache the various tokens with which we can create worker 
    // processes.
    //

    hr = CreateCachedWorkerProcessTokens();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating cached worker process tokens failed\n"
            ));

        goto exit;
    }


    //
    // Determine if we should start worker processes in performance
    // profiling mode. Profiling is off by default. 
    //

    m_WorkerProcessProfilingEnabled = 
        ( BOOL )ReadDwordParameterValueFromRegistry(
                    REGISTRY_VALUE_W3SVC_PROFILE_WORKER_PROCESSES_W,
                    0
                    );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Worker process profiling is: %s\n",
            ( m_WorkerProcessProfilingEnabled ? "ON" : "OFF" )
            ));
    }
    
    //
    // Determine if we should launch test worker process 
    // instead of real worker process.
    //
    m_UseTestW3WP = 
        ( BOOL )ReadDwordParameterValueFromRegistry(
                    REGISTRY_VALUE_W3SVC_USE_TEST_W3WP,
                    0
                    );

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Using the test twp.exe worker process: %s\n",
            ( m_UseTestW3WP ? "Yes" : "No" )
            ));
    }
    
    //
    // Should we filter all data or just SSL
    // 
    // CODEWORK Once catalog reads the ISAPI filter notification flag from
    //          the metabase, we will switch this property on the fly as
    //          needed
    //

    m_FilterAllData = 
        ( BOOL )ReadDwordParameterValueFromRegistry(
                    REGISTRY_VALUE_W3SVC_FILTER_ALL_DATA_W,
                    0
                    );
    
    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF(( 
            DBG_CONTEXT,
            "Filtering all data is: %s\n",
            ( m_FilterAllData ? "ON" : "OFF" )
            ));
    }


    //
    // IISUtil initialization 
    //

    Success = InitializeIISUtil();
    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not initialize iisutil\n"
            ));

        goto exit;
    }

    hr = StartIISAdminMonitor(&NotifyOfInetinfoFailure);
    if ( FAILED ( hr ) )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not initialize iisadmin monitor\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitializeInternalComponents


/***************************************************************************++

Routine Description:

    Called only once, this routine will remember if we are in backward
    compatibility mode or not.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::SetBackwardCompatibility(
    BOOL BackwardCompatibility
    )
{

    HRESULT hr = S_OK;

    //
    //  Since this function is called only once, we should
    //  assert that no one else has enabled our flag yet.
    //

    DBG_ASSERT(m_BackwardCompatibilityEnabled == ENABLED_INVALID);

    if (BackwardCompatibility)
    {
        // First remember if we are in backward compatibility mode.
        m_BackwardCompatibilityEnabled = ENABLED_TRUE;

        //
        // Then make sure we have an event to fire when we need it.
        // Since we want it to only be accessible by local system, we 
        // do not need to set the SD here.  It will be inherited by the
        // CreateEvent call from the process which is running as local system.
        //
        m_InetinfoLaunchEvent = CreateEvent(NULL, TRUE, FALSE, WEB_ADMIN_SERVICE_START_EVENT_W);
        if (!m_InetinfoLaunchEvent)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not open/create the Start W3WP event\n"
                ));
        }

    }
    else
    {

        //Flag that we are not in BC Mode.
        m_BackwardCompatibilityEnabled = ENABLED_FALSE;
    }

    return hr;

}   // WEB_ADMIN_SERVICE::SetBackwardCompatibility

/***************************************************************************++

Routine Description:

    Determine and cache the path to where this service DLL resides. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::DetermineCurrentDirectory(
    )
{

    HRESULT hr = S_OK;
    HMODULE ModuleHandle = NULL;
    WCHAR ModulePath[ MAX_PATH ];
    DWORD Length = 0;
    LPWSTR pEnd = NULL;


    //
    // Determine the directory where our service DLL lives. 
    // Do this by finding the fully qualified path to our DLL, then
    // trimming. 
    //

    ModuleHandle = GetModuleHandle( WEB_ADMIN_SERVICE_DLL_NAME_W );

    if ( ModuleHandle == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't get module handle\n"
            ));

        goto exit;
    }
    

    Length = GetModuleFileNameW(
                ModuleHandle,
                ModulePath,
                sizeof( ModulePath ) / sizeof( ModulePath[0] )
                );

    if ( Length == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Getting module file name failed\n"
            ));

        goto exit;
    }


    //
    // Truncate it just past the final separator.
    //

    pEnd = wcsrchr( ModulePath, L'\\' );

    if ( pEnd == NULL )
    {
        DBG_ASSERT( pEnd != NULL );

        // We expect to find the last separator.  If
        // we don't something is really wrong.
        hr = E_UNEXPECTED;

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed finding the final separator.\n"
            ));

        goto exit;

    }

    pEnd[1] = L'\0';


    //
    // Build a STRU object representing it.
    //

    m_pCurrentDirectory = new STRU;

    if ( m_pCurrentDirectory == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating STRU failed\n"
            ));

        goto exit;
    }


    hr = m_pCurrentDirectory->Append( ModulePath );

    if (FAILED(hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }


    DBG_ASSERT( m_pCurrentDirectory != NULL );
    DBG_ASSERT( m_pCurrentDirectory->QueryCCH() > 0 );
    DBG_ASSERT( m_pCurrentDirectory->QueryStr()[ m_pCurrentDirectory->QueryCCH() - 1 ] == L'\\' );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Current directory: %S\n",
            m_pCurrentDirectory->QueryStr()
            ));
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::DetermineCurrentDirectory



/***************************************************************************++

Routine Description:

    Create and cache the two tokens under which we might create worker 
    processes: the LocalSystem token, and a reduced privilege token. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::CreateCachedWorkerProcessTokens(
    )
{

    HRESULT hr = S_OK;
    BOOL    Success = TRUE;
    DWORD   dwLogonError;

    hr = m_TokenCache.Initialize();
    if (FAILED(hr))
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to initialize the TokenCache\n"
            ));

        goto exit;
    }

    //
    // First, get and cache the LocalSystem token. For this, we simply
    // use our own process token (i.e. LocalSystem).
    //

    DBG_ASSERT( m_pLocalSystemTokenCacheEntry == NULL );

    hr = m_TokenCache.GetCachedToken(
                    L"LocalSystem",             // user name
                    L"NT AUTHORITY",            // domain
                    L"",                        // password
                    LOGON32_LOGON_SERVICE,      // type of logon
                    FALSE,                      // not UPN logon
                    &m_pLocalSystemTokenCacheEntry,        // returned token handle
                    &dwLogonError,              // LogonError storage
                    TRUE                        // Allow LocalSystem token to be created
                    );

    DBG_ASSERT(NULL != m_pLocalSystemTokenCacheEntry || 
              (NULL == m_pLocalSystemTokenCacheEntry && 0 != dwLogonError));
    if ( FAILED(hr) || 
         ( NULL == m_pLocalSystemTokenCacheEntry &&
           FAILED( hr = HRESULT_FROM_WIN32( dwLogonError ) ) )
       )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to get the LocalSystem Token\n"
            ));

        goto exit;
    }

    //
    // Save tokens for the LocalService user
    //
    DBG_ASSERT( m_pLocalServiceTokenCacheEntry == NULL );
    
    hr = m_TokenCache.GetCachedToken(
                    L"LocalService",            // user name
                    L"NT AUTHORITY",            // domain
                    L"",                        // password
                    LOGON32_LOGON_SERVICE,      // type of logon
                    FALSE,                      // not UPN logon
                    &m_pLocalServiceTokenCacheEntry,        // returned token handle
                    &dwLogonError              // LogonError storage
                    );
    DBG_ASSERT(NULL != m_pLocalServiceTokenCacheEntry || 
              (NULL == m_pLocalServiceTokenCacheEntry && 0 != dwLogonError));
    if ( FAILED(hr) || 
         ( NULL == m_pLocalServiceTokenCacheEntry &&
           FAILED( hr = HRESULT_FROM_WIN32( dwLogonError ) ) )
       )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to get the LocalService token.\n"
            ));

        goto exit;
    }

    // 
    // Save tokens for the Network_Service user.
    //

    DBG_ASSERT( m_pNetworkServiceTokenCacheEntry == NULL );
    
    hr = m_TokenCache.GetCachedToken(
                    L"NetworkService",          // user name
                    L"NT AUTHORITY",            // domain
                    L"",                        // password
                    LOGON32_LOGON_SERVICE,      // type of logon
                    FALSE,                      // not UPN logon
                    &m_pNetworkServiceTokenCacheEntry,        // returned token handle
                    &dwLogonError              // LogonError Storage
                    );
    DBG_ASSERT(NULL != m_pNetworkServiceTokenCacheEntry || 
              (NULL == m_pNetworkServiceTokenCacheEntry && 0 != dwLogonError));
    if ( FAILED(hr) || 
         ( NULL == m_pNetworkServiceTokenCacheEntry &&
           FAILED( hr = HRESULT_FROM_WIN32( dwLogonError ) ) )
       )
    {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Failed to get the NetworkService token.\n"
            ));

        goto exit;
    }


    hr = S_OK;
exit:

    return hr;

}   // WEB_ADMIN_SERVICE::CreateCachedWorkerProcessTokens

/***************************************************************************++

Routine Description:

    Initialize sub-components of the web admin service.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WEB_ADMIN_SERVICE::InitializeOtherComponents(
    )
{

    HRESULT hr = S_OK;


    //
    // Create and initialize IPM objects.
    //
    
    m_pIoFactoryS = new IO_FACTORY_S();

    if ( m_pIoFactoryS == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating IO_FACTORY_S failed\n"
            ));

        goto exit;
    }


    m_pMessageGlobal = new MESSAGE_GLOBAL( m_pIoFactoryS ); 

    if ( m_pMessageGlobal == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating MESSAGE_GLOBAL failed\n"
            ));


        //
        // Get rid of m_pIoFactoryS, since we won't be able to transfer
        // ownership to m_pMessageGlobal.
        //

        delete m_pIoFactoryS;
        m_pIoFactoryS = NULL; 

        goto exit;
    }


    hr = m_pMessageGlobal->InitializeMessageGlobal();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing IPM failed\n"
            ));

        goto exit;
    }


    //
    // Create the low memory detector.
    //
    
    m_pLowMemoryDetector = new LOW_MEMORY_DETECTOR();

    if ( m_pLowMemoryDetector == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating LOW_MEMORY_DETECTOR failed\n"
            ));

        goto exit;
    }
    
    //
    // Set up structures to manage UL and the worker processes.
    //

    hr = m_UlAndWorkerManager.Initialize( );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing UL & Worker manager failed\n"
            ));

        goto exit;
    }


    //
    // Read the initial configuration.
    //

    hr = m_ConfigAndControlManager.Initialize();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing configuration manager failed\n"
            ));

        goto exit;
    }

    if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_PERF_COUNT_DISABLED_W, 0 ) == 0 )
    {

        hr = m_UlAndWorkerManager.ActivatePerfCounters();
        if ( FAILED ( hr ) )
        {

            //
            // Write an event log but do not
            // block the service from starting.
            //

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_PERF_COUNTER_INITIALIZATION_FAILURE,               // message id
                    0,                                                     // count of strings
                    NULL,                                                  // array of strings
                    hr                                                     // error code
                    );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Initializing perf counters failed\n"
                ));

            hr = S_OK;

        }

    }

#if DBG
    //
    // Dump the configured state we read from the config store.
    //

    m_UlAndWorkerManager.DebugDump();
#endif  // DBG
    

    //
    // Now start UL.
    //

    hr = m_UlAndWorkerManager.ActivateUl();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Activating UL failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::InitializeOtherComponents


/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of the service.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::Shutdown(
    )
{

    HRESULT hr = S_OK;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initiating web admin service (gentle) shutdown\n"
            ));
    }


    //
    // Turn off config change and control operation processing.
    //

    hr = m_ConfigAndControlManager.StopChangeProcessing();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Stopping config change processing failed\n"
            ));

        goto exit;
    }


    hr = m_UlAndWorkerManager.Shutdown();    

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Starting shutdown of UL&WM failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WEB_ADMIN_SERVICE::Shutdown

/***************************************************************************++

Routine Description:

    Tell inetinfo to launch a worker process.

Arguments:

    None.

Return Value:

    VOID

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::LaunchInetinfo(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( m_InetinfoLaunchEvent );
    if ( m_InetinfoLaunchEvent )
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {

            DBGPRINTF((
                DBG_CONTEXT, 
                "Launching Inetinfo CTC = %d \n",
                GetTickCount()
                ));
        }

        if (!SetEvent(m_InetinfoLaunchEvent))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not set the Start W3WP event\n"
                ));
        }
    }
    else
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Tried to launch a worker process in inetinfo but the event handle was null.\n"
            ));

        hr = E_FAIL;
    }

    return hr;
}   // WEB_ADMIN_SERVICE::LaunchInetinfo

/***************************************************************************++

Routine Description:

    Routine runs on main thread and handles doing all the operations
    that need to ocurr once inetinfo has come back up after it has crashed.

Arguments:

    None.

Return Value:

    HRESULT -- If this is a failed result the service will shutdown.

--***************************************************************************/
HRESULT 
WEB_ADMIN_SERVICE::RecoverFromInetinfoCrash(
    )
{ 
    HRESULT hr = S_OK;

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // Need to do the following.
    // 0) Turn off the restriction on using the metabase 
    // 1) Have the ULAndWorkerManager handle recycling and reporting of state.
    // 2) request the catalog rehookup ( do this after 1 because the catalog will
    //    expect them to say what I am resetting them to.

    // Step 0, turn off the restriction.

    // Note, while any thread can set this to true, only this thread can set it
    // to false.  This does not need to be protected against race conditions because
    // if another thread resets it before we are done, we are in another crash state
    // and we will need to process it.
    m_fMetabaseCrashed = FALSE; 

    // Step 1, have the Worker Manager Recycle all the worker processes
    //         and have it re-record all site and app pool data.
    hr = m_UlAndWorkerManager.RecoverFromInetinfoCrash();
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed having the ULAndWorkerManager recover from inetinfo crash\n"
            ));

        goto exit;
    }

    // Step 2, have the catalog rehookup for notifications.
    hr = m_ConfigAndControlManager.RehookChangeProcessing();
    if ( FAILED( hr ) )
    {
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Failed having the ConfigAndControlManager rehook the change processing\n"
            ));

        goto exit;
    }

exit:

    return hr;
} // WEB_ADMIN_SERVICE::RecoverFromInetinfoCrash

/***************************************************************************++

Routine Description:


Arguments:


Return Value:

    PSID - The Local System SID

--***************************************************************************/

PSID
WEB_ADMIN_SERVICE::GetLocalSystemSid(
    )
{   
    DWORD dwErr = ERROR_SUCCESS;
    PSID pSid = NULL;

    dwErr = m_SecurityDispenser.GetSID( WinLocalSystemSid
                                        ,&pSid);
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Fatal service error, shutting down\n"
            ));

        return NULL;
    }

    return pSid;
}


/***************************************************************************++

Routine Description:

    Do final service cleanup, and then tell the service controller that the 
    service has stopped as well as providing it with the service's error 
    exit value.

Arguments:

    ServiceExitCode - The exit code for the service.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::TerminateServiceAndReportFinalStatus(
    IN HRESULT ServiceExitCode
    )
{

    DWORD Win32Error = NO_ERROR;
    DWORD ServiceSpecificError = NO_ERROR;
    HRESULT hr = S_OK;


    //
    // If we got here on a success code, make sure no other code left
    // us an hresult that we should be processing.
    //

    if ( SUCCEEDED ( ServiceExitCode ) )
    {
        ServiceExitCode = m_hrToReportToSCM;
    }

    if ( FAILED( ServiceExitCode ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            ServiceExitCode,
            "Fatal service error, shutting down\n"
            ));

        if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_FAILURE_CAUSING_SHUTDOWN_W, 0 ) )
        {
            DBG_ASSERT ( FALSE );
        }


        //
        // Log an event: WAS shutting down due to error.
        //

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_ERROR_SHUTDOWN,               // message id
                0,                                      // count of strings
                NULL,                                   // array of strings
                ServiceExitCode                         // error code
                );


        if ( HRESULT_FACILITY( ServiceExitCode ) == FACILITY_WIN32 )
        {
            Win32Error = WIN32_FROM_HRESULT( ServiceExitCode );
        }
        else
        {
            Win32Error = ERROR_SERVICE_SPECIFIC_ERROR;
            ServiceSpecificError = ServiceExitCode;
        }

    }
    else
    {
        if ( m_fMetabaseCrashed )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32( ERROR_SERVICE_DEPENDENCY_FAIL ),
                "Inetinfo crashed, shutting down service\n"
                ));

            if ( ReadDwordParameterValueFromRegistry( REGISTRY_VALUE_W3SVC_BREAK_ON_FAILURE_CAUSING_SHUTDOWN_W, 0 ) )
            {
                DBG_ASSERT ( FALSE );
            }

            //
            // Log an event: WAS shutting down due to error.
            //

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_INETINFO_CRASH_SHUTDOWN,      // message id
                    0,                                      // count of strings
                    NULL,                                   // array of strings
                    0                                       // error code
                    );


            Win32Error = ERROR_SERVICE_DEPENDENCY_FAIL;

        }

    }


    //
    // Clean up everything that's left of the service.
    //
    
    Terminate();

    //
    //
    // Report the SERVICE_STOPPED status to the service controller.
    //

    //
    // Note that unfortunately the NT5 SCM service failure actions (such as
    // automatically restarting the service) work only if the service process
    // terminates without setting the service status to SERVICE_STOPPED, and
    // not if it exits cleanly with an error exit code, as we may do here.
    // They are going to consider adding this post-NT5.
    //

    m_ServiceStateTransitionLock.Lock();


    hr = UpdateServiceStatus(
                SERVICE_STOPPED,
                Win32Error,
                ServiceSpecificError,
                0,
                0
                );


    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "couldn't update service status\n"
            ));

    }


    m_ServiceStateTransitionLock.Unlock();


    return;

}   // WEB_ADMIN_SERVICE::TerminateServiceAndReportFinalStatus



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WEB_ADMIN_SERVICE::Terminate(
    )
{

    HRESULT hr = S_OK;
    

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initiating web admin service termination\n"
            ));
    }


    //
    // Stop config change and control operation processing, as those could 
    // generate new WORK_ITEMs.
    //
    
    DBG_REQUIRE( SUCCEEDED( m_ConfigAndControlManager.StopChangeProcessing() ) );

    //
    // Terminate the UL and worker manager.
    //

    m_UlAndWorkerManager.Terminate();


    //
    // Terminate the config and control manager.
    //
    
    m_ConfigAndControlManager.Terminate();


    //
    // Terminate IPM.
    //

    if ( m_pMessageGlobal != NULL )
    {
    
        //
        // Note that m_pIoFactoryS is cleaned up for us within this call.
        //


        hr = m_pMessageGlobal->TerminateMessageGlobal();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Terminating IPM failed\n"
                ));

        }


        delete m_pMessageGlobal;
        m_pMessageGlobal = NULL; 
    }


    //
    // Terminate the low memory detector, to flush out any WORK_ITEMs it has.
    //

    if ( m_pLowMemoryDetector != NULL )
    {

        m_pLowMemoryDetector->Terminate();


        //
        // We can't get rid of the m_pLowMemoryDetector object yet, as pending
        // work items may need to reference it. So wait until after the work
        // queue is done processing any remaining work items.
        //

    }


    //
    // Shut down the work queue. This must be done after all things which can 
    // generate new work items are shut down, as this operation will free any 
    // remaining work items. This includes for example work items that were 
    // pending on real async i/o; in such cases the i/o must be canceled first, 
    // in order to complete the i/o and release the work item, so that we can 
    // then clean it up here.
    //
    // Once this has completed, we are also guaranteed that no more work items
    // can be created. 
    //
    
    m_WorkQueue.Terminate();


    //
    // Now we can dereference the low memory detector and clean up our pointer.
    //

    if ( m_pLowMemoryDetector != NULL )
    {
        m_pLowMemoryDetector->Dereference();
        m_pLowMemoryDetector = NULL;
    }


    //
    // Cancel the pending service status timer, if present. We can do this
    // even after cleaning up the work queue, because it does not use 
    // work items. We have it block for any callbacks to finish, so that
    // the callbacks can't complete later, once this instance goes away!
    //

    hr = CancelPendingServiceStatusTimer( TRUE );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not cancel pending service status timer\n"
            ));

    }
    

    //
    // Close the timer queue (if present).
    //

    DBG_REQUIRE( SUCCEEDED( DeleteTimerQueue() ) );

    StopIISAdminMonitor();

    //
    // At this point we are done using IISUtil
    //
    
    TerminateIISUtil();
    
    return;

}   // WEB_ADMIN_SERVICE::Terminate



/***************************************************************************++

Routine Description:

    Cancel the pending service status timer.

Arguments:

    BlockOnCallbacks - Whether the cancel call should block waiting for
    callbacks to complete, or return immediately. If this method is called
    with the m_ServiceStateTransitionLock held, then DO NOT block on
    callbacks, as you can deadlock. (Instead, the callback to update the
    service pending status is designed to be harmless if called after the
    state transition completes.) 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::CancelPendingServiceStatusTimer(
    IN BOOL BlockOnCallbacks
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;


    DBG_ASSERT( m_SharedTimerQueueHandle != NULL );


    if ( m_PendingServiceStatusTimerHandle != NULL )
    {

        Status = RtlDeleteTimer(
                        m_SharedTimerQueueHandle,   // the owning timer queue
                        m_PendingServiceStatusTimerHandle,          
                                                    // timer to cancel
                         ( BlockOnCallbacks ? ( ( HANDLE ) -1 ) : NULL )
                                                    // block on callbacks or not
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not cancel timer\n"
                ));

            goto exit;
        }

        m_PendingServiceStatusTimerHandle = NULL;

    }
    

exit:

    return hr;
    
}   // WEB_ADMIN_SERVICE::CancelPendingServiceStatusTimer



/***************************************************************************++

Routine Description:

    Delete the timer queue.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WEB_ADMIN_SERVICE::DeleteTimerQueue(
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;


    if ( m_SharedTimerQueueHandle != NULL )
    {

        Status = RtlDeleteTimerQueueEx( 
                        m_SharedTimerQueueHandle,   // timer queue to delete
                        ( HANDLE ) -1               // block until callbacks finish
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Could not delete timer queue\n"
                ));

            goto exit;
        }

        m_SharedTimerQueueHandle = NULL;

    }
    

exit:

    return hr;
    
}   // WEB_ADMIN_SERVICE::DeleteTimerQueue



/***************************************************************************++

Routine Description:

    Read a DWORD value from the parameters key for this service.

Arguments:

    RegistryValueName - The value to read.

    DefaultValue - The default value to return if the registry value is 
    not present or cannot be read.

Return Value:

    DWORD - The parameter value.

--***************************************************************************/

DWORD
ReadDwordParameterValueFromRegistry(
    IN LPCWSTR RegistryValueName,
    IN DWORD DefaultValue
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    HKEY KeyHandle = NULL;
    DWORD DataType = 0;
    DWORD Buffer = 0;
    DWORD DataLength = sizeof( Buffer );
    DWORD Result = DefaultValue;


    DBG_ASSERT( RegistryValueName != NULL );


    Win32Error = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,             // base key
                        REGISTRY_KEY_W3SVC_PARAMETERS_W,// path
                        0,                              // reserved
                        KEY_READ,                       // access
                        &KeyHandle                      // returned key handle
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Opening registry key failed\n"
            ));

        goto exit;
    }


    //
    // Try to read the value; it may not be present.
    //

    Win32Error = RegQueryValueEx(
                        KeyHandle,                      // key handle
                        RegistryValueName,              // value name
                        NULL,                           // reserved
                        &DataType,                      // output datatype
                        ( LPBYTE ) &Buffer,             // data buffer
                        &DataLength                     // buffer/data length
                        );

    if ( Win32Error != NO_ERROR )
    {

        hr = HRESULT_FROM_WIN32( Win32Error );

        if ( hr  != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Reading registry value failed\n"
                ));
        }

        goto exit;
    }


    if ( DataType == REG_DWORD )
    {

        //
        // Return the value read.
        //

        Result = Buffer;

    }

exit:

    if ( KeyHandle != NULL )
    {
        DBG_REQUIRE( RegCloseKey( KeyHandle ) == NO_ERROR );
        KeyHandle = NULL;
    }


    return Result;

}   // ReadDwordValueFromRegistry



/***************************************************************************++

Routine Description:

    The service control handler function called by the service controller,
    on its thread. Posts a work item to the main worker thread to actually
    handle the request.

Arguments:

    OpCode - The requested operation, from the SERVICE_CONTROL_* constants.

Return Value:

    None

--***************************************************************************/

VOID
ServiceControlHandler(
    IN DWORD OpCode
    )
{

    HRESULT hr = S_OK;


    switch( OpCode ) 
    {

    case SERVICE_CONTROL_INTERROGATE:

        hr = GetWebAdminService()->InterrogateService();
        break;

    //
    // CODEWORK Review if we need to support SERVICE_CONTROL_SHUTDOWN.
    // We only need this if we have persistent state to write out on
    // shutdown. If not, remove this to speed up overall NT shutdown.
    // Note that even if we don't internally have persistent state to 
    // write out, we might still want to attempt clean shutdown, so 
    // that application code running in worker processes get a chance
    // to write out their persistent state.
    //
    
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        hr = GetWebAdminService()->InitiateStopService();
        break;

    case SERVICE_CONTROL_PAUSE:

        hr = GetWebAdminService()->InitiatePauseService();
        break;

    case SERVICE_CONTROL_CONTINUE:

        hr = GetWebAdminService()->InitiateContinueService();
        break;

    default:
    
        DBGPRINTF(( 
            DBG_CONTEXT,
            "Service control ignored, OpCode: %lu\n",
            OpCode 
            ));
            
        break;
        
    }

    //
    // It's possible to have rejected the service control call
    // but not want the service to actually shutdown.
    //
    if ( FAILED( hr ) && 
         hr != HRESULT_FROM_WIN32( ERROR_SERVICE_CANNOT_ACCEPT_CTRL ))
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Service control operation failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );
    }


    return;
    
    }   // ServiceControlHandler



/***************************************************************************++

Routine Description:

    The callback function invoked by the pending service status timer, on
    an RTL thread. It updates the pending service status, and reports the
    new status to the SCM. This work is done directly on this thread, so 
    that the service will not time out during very long single work item
    operations, such as service initialization. 

Arguments:

    Ignored1 - Ignored.

    Ignored2 - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
UpdatePendingServiceStatusCallback(
    IN PVOID Ignored1,
    IN BOOLEAN Ignored2
    )
{

    HRESULT hr = S_OK;


    UNREFERENCED_PARAMETER( Ignored1 );
    UNREFERENCED_PARAMETER( Ignored2 );


    hr = GetWebAdminService()->UpdatePendingServiceStatus();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Updating pending service status failed\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );
    }


    return;

}   // UpdatePendingServiceStatusCallback


/***************************************************************************++

Routine Description:

    Callback function to handle the different issues arrising from inetinfo
    crashing.

Arguments:

    INETINFO_CRASH_ACTION CrashAction

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
NotifyOfInetinfoFailure(
    INETINFO_CRASH_ACTION CrashAction
    )
{
    HRESULT hr = S_OK;

    switch ( CrashAction)
    {
        case ( NotifyAfterInetinfoCrash ):

            // we want to stop from letting any worker processes launch
            // we want to refuse to write to the metabase.

            // we need to mark the service as experiencing a inetinfo crash.
            // note, this function returns a VOID.
            GetWebAdminService()->RecordInetinfoCrash();

        break;

        case ( ShutdownAfterInetinfoCrash ):

            // we need to call shutdown ( we will all ready
            // have flagged that inetinfo crashed ).

            hr = GetWebAdminService()->RequestStopService( FALSE );
            if ( FAILED ( hr ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Stopping the service due to inetinfo crash had a problem\n"
                    ));
            }

        break;

        case ( RehookAfterInetinfoCrash ):

            hr = GetWebAdminService()->QueueRecoveryFromInetinfoCrash();
            if ( FAILED ( hr ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Recovering from inetinfo crash had a problem\n"
                    ));
            }

        break;
        default:
            DBG_ASSERT( 0 );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\web_admin_service.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    web_admin_service.h

Abstract:

    The IIS web admin service class definition. 

Author:

    Seth Pollack (sethp)        23-Jul-1998

Revision History:

--*/


#ifndef _WEB_ADMIN_SERVICE_H_
#define _WEB_ADMIN_SERVICE_H_

// registry helper
DWORD
ReadDwordParameterValueFromRegistry(
    IN LPCWSTR RegistryValueName,
    IN DWORD DefaultValue
    );


//
// common #defines
//

#define WEB_ADMIN_SERVICE_SIGNATURE         CREATE_SIGNATURE( 'WASV' )
#define WEB_ADMIN_SERVICE_SIGNATURE_FREED   CREATE_SIGNATURE( 'wasX' )


//
// BUGBUG The service, dll, event source, etc. names are likely to change;
// decide on the real ones. 
//

#define WEB_ADMIN_SERVICE_NAME_W    L"w3svc"
#define WEB_ADMIN_SERVICE_NAME_A    "w3svc"

#define WEB_ADMIN_SERVICE_DLL_NAME_W    L"iisw3adm.dll"

#define WEB_ADMIN_SERVICE_EVENT_SOURCE_NAME L"WAS"

#define WEB_ADMIN_SERVICE_STARTUP_WAIT_HINT         ( 180 * ONE_SECOND_IN_MILLISECONDS )  // 3 minutes
#define WEB_ADMIN_SERVICE_STATE_CHANGE_WAIT_HINT    ( 20 * ONE_SECOND_IN_MILLISECONDS ) // 20 seconds
#define WEB_ADMIN_SERVICE_STATE_CHANGE_TIMER_PERIOD \
            ( WEB_ADMIN_SERVICE_STATE_CHANGE_WAIT_HINT / 2 )


#define NULL_SERVICE_STATUS_HANDLE  ( ( SERVICE_STATUS_HANDLE ) NULL )



//
// structs, enums, etc.
//

// WEB_ADMIN_SERVICE work items
typedef enum _WEB_ADMIN_SERVICE_WORK_ITEM
{

    //
    // Start the service.
    //
    StartWebAdminServiceWorkItem = 1,

    //
    // Stop the service.
    //
    StopWebAdminServiceWorkItem,

    //
    // Pause the service.
    //
    PauseWebAdminServiceWorkItem,

    //
    // Continue the service.
    //
    ContinueWebAdminServiceWorkItem,

    //
    // Recover from inetinfo crash.
    //
    RecoverFromInetinfoCrashWebAdminServiceWorkItem,
    
} WEB_ADMIN_SERVICE_WORK_ITEM;

// WEB_ADMIN_SERVICE work items
typedef enum _ENABLED_ENUM
{
    //
    // Flag has not been set.
    //
    ENABLED_INVALID = -1,

    //
    // Flag is disabled
    //
    ENABLED_FALSE,

    //
    // Flag is enabled.
    //
    ENABLED_TRUE,
    
} ENABLED_ENUM;


//
// prototypes
//

class WEB_ADMIN_SERVICE 
    : public WORK_DISPATCH
{

public:

    WEB_ADMIN_SERVICE(
        );

    virtual
    ~WEB_ADMIN_SERVICE(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    VOID
    ExecuteService(
        );

    inline
    WORK_QUEUE *
    GetWorkQueue(
        )
    { return &m_WorkQueue; }

    inline
    UL_AND_WORKER_MANAGER *
    GetUlAndWorkerManager(
        )
    { 
        DBG_ASSERT( ON_MAIN_WORKER_THREAD );
        return &m_UlAndWorkerManager;
    }

    inline
    CONFIG_AND_CONTROL_MANAGER *
    GetConfigAndControlManager(
        )
    { 
        return &m_ConfigAndControlManager;
    }

    inline
    MESSAGE_GLOBAL *
    GetMessageGlobal(
        )
    {
        DBG_ASSERT( m_pMessageGlobal != NULL );
        return m_pMessageGlobal;
    }

    inline
    EVENT_LOG *
    GetEventLog(
        )
    { return &m_EventLog; }

    inline
    LOW_MEMORY_DETECTOR *
    GetLowMemoryDetector(
        )
    {
        DBG_ASSERT( m_pLowMemoryDetector != NULL );
        return m_pLowMemoryDetector;
    }

    inline
    HANDLE
    GetSharedTimerQueue(
        )
    { return m_SharedTimerQueueHandle; }

    inline
    LPCWSTR
    GetCurrentDirectory(
        )
        const
    {
        DBG_ASSERT( m_pCurrentDirectory != NULL );
        return m_pCurrentDirectory->QueryStr();
    }

    inline
    TOKEN_CACHE&
    GetTokenCache(
        )         
    {
        return m_TokenCache;
    }

    inline
    TOKEN_CACHE_ENTRY *
    GetLocalSystemTokenCacheEntry(
        )
        const
    {
        DBG_ASSERT( m_pLocalSystemTokenCacheEntry != NULL );
        return m_pLocalSystemTokenCacheEntry;
    }

    inline
    TOKEN_CACHE_ENTRY *
    GetLocalServiceTokenCacheEntry(
        )
        const
    {
        DBG_ASSERT( m_pLocalServiceTokenCacheEntry != NULL );
        return m_pLocalServiceTokenCacheEntry;
    }

    inline
    TOKEN_CACHE_ENTRY *
    GetNetworkServiceTokenCacheEntry(
        )
        const
    {
        DBG_ASSERT( m_pNetworkServiceTokenCacheEntry != NULL );
        return m_pNetworkServiceTokenCacheEntry;
    }

    inline
    BOOL
    IsWorkerProcessProfilingEnabled(
        )
        const
    {
        return m_WorkerProcessProfilingEnabled;
    }

    inline
    BOOL
    IsBackwardCompatibilityEnabled(
        )
        const
    {
        // Compatibilty should always be set before this function is called.
        DBG_ASSERT( m_BackwardCompatibilityEnabled != ENABLED_INVALID);

        return (m_BackwardCompatibilityEnabled == ENABLED_TRUE);
    }

    inline
    BOOL
    IsFilteringAllData(
        )
        const
    {
        return m_FilterAllData;
    }

    HRESULT
    SetBackwardCompatibility(
        BOOL BackwardCompatibility
        );     

    inline
    DWORD
    GetMainWorkerThreadId(
        )
        const
    { return m_MainWorkerThreadId; }

    inline
    DWORD
    GetServiceState(
        )
        const
    {
        //
        // Note: no explicit synchronization is necessary on this thread-
        // shared variable because this is an aligned 32-bit read.
        //

        return m_ServiceStatus.dwCurrentState;
    }

    VOID
    FatalErrorOnSecondaryThread(
            IN HRESULT SecondaryThreadError
        );

    HRESULT
    InterrogateService(
        );

    HRESULT
    InitiateStopService(
        );

    HRESULT
    InitiatePauseService(
        );

    HRESULT
    InitiateContinueService(
        );

    HRESULT
    UpdatePendingServiceStatus(
        );

    HRESULT
    UlAndWorkerManagerShutdownDone(
        );

    VOID 
    InetinfoRegistered(
        );

    HRESULT 
    LaunchInetinfo(
        );

    BOOL
    DontWriteToMetabase(
        )
    { 
        return m_fMetabaseCrashed; 
    }

    DWORD
    ServiceStartTime(
        )
    { 
        return m_ServiceStartTime; 
    }

    BOOL
    UseTestW3WP(
        )
    {
        return m_UseTestW3WP; 
    }

    HRESULT
    RequestStopService(
        IN BOOL EnableStateCheck
        );

    VOID 
    RecordInetinfoCrash(
        )
    { m_fMetabaseCrashed = TRUE; }

    HRESULT 
    RecoverFromInetinfoCrash(
        );

    HRESULT
    QueueRecoveryFromInetinfoCrash(
        );

    PSID
    GetLocalSystemSid(
        );


    VOID 
    SetHrToReportToSCM(
        HRESULT hrToReport
        )
    {
        m_hrToReportToSCM = hrToReport;
    }
private:

    HRESULT
    StartWorkQueue(
        );

    HRESULT
    MainWorkerThread(
        );

    HRESULT
    StartServiceWorkItem(
        );

    HRESULT
    FinishStartService(
        );

    HRESULT
    StopServiceWorkItem(
        );

    HRESULT
    FinishStopService(
        );

    HRESULT
    PauseServiceWorkItem(
        );

    HRESULT
    FinishPauseService(
        );

    HRESULT
    ContinueServiceWorkItem(
        );

    HRESULT
    FinishContinueService(
        );

    HRESULT
    BeginStateTransition(
        IN DWORD NewState,
        IN BOOL  EnableStateCheck
        );

    HRESULT
    FinishStateTransition(
        IN DWORD NewState,
        IN DWORD ExpectedPreviousState
        );

    BOOL
    IsServiceStateChangePending(
        )
        const;

    HRESULT
    UpdateServiceStatus(
        IN DWORD State,
        IN DWORD Win32ExitCode,
        IN DWORD ServiceSpecificExitCode,
        IN DWORD CheckPoint,
        IN DWORD WaitHint
        );
        
    HRESULT
    ReportServiceStatus(
        );

    HRESULT
    InitializeInternalComponents(
        );

    HRESULT
    DetermineCurrentDirectory(
        );

    HRESULT
    CreateCachedWorkerProcessTokens(
        );

    HRESULT
    InitializeOtherComponents(
        );
        
    HRESULT
    Shutdown(
        );

    VOID
    TerminateServiceAndReportFinalStatus(
        IN HRESULT Error
        );

    VOID
    Terminate(
        );

    HRESULT
    CancelPendingServiceStatusTimer(
        IN BOOL BlockOnCallbacks
        );

    HRESULT
    DeleteTimerQueue(
        );


    DWORD m_Signature;


    LONG m_RefCount;


    // the work queue
    WORK_QUEUE m_WorkQueue;


    // drives UL.sys and worker processes
    UL_AND_WORKER_MANAGER m_UlAndWorkerManager;


    // brokers configuration state and changes, as well as control operations
    CONFIG_AND_CONTROL_MANAGER m_ConfigAndControlManager;


    // IPM (inter-process messaging) support
    MESSAGE_GLOBAL * m_pMessageGlobal;


    // i/o abstraction layer used by IPM
    IO_FACTORY_S * m_pIoFactoryS;


    // event logging
    EVENT_LOG m_EventLog;


    // low memory detection
    LOW_MEMORY_DETECTOR * m_pLowMemoryDetector;


    //
    // Prevent races in accessing the service state structure,
    // as well as the pending service state transition timer.
    //
    LOCK m_ServiceStateTransitionLock;


    // service state
    SERVICE_STATUS_HANDLE m_ServiceStatusHandle;
    SERVICE_STATUS m_ServiceStatus;


    // pending service state transition timer
    HANDLE m_PendingServiceStatusTimerHandle;


    // shared timer queue
    HANDLE m_SharedTimerQueueHandle;


    // time to exit work loop?
    BOOL m_ExitWorkLoop;


    // main worker thread ID
    DWORD m_MainWorkerThreadId;


    // for errors which occur on secondary threads
    HRESULT m_SecondaryThreadError;


    // tuck away the path to our DLL
    STRU * m_pCurrentDirectory;

    // Token Cache so we don't over duplicate token creation
    TOKEN_CACHE m_TokenCache;

    // the LocalSystem token we can use for starting worker processes
    TOKEN_CACHE_ENTRY * m_pLocalSystemTokenCacheEntry;

    // the LocalService token we can use for starting worker processes
    TOKEN_CACHE_ENTRY * m_pLocalServiceTokenCacheEntry;

    // the NetworkService token we can use for starting worker processes
    TOKEN_CACHE_ENTRY * m_pNetworkServiceTokenCacheEntry;


    // is profiling enabled for worker processes?
    BOOL m_WorkerProcessProfilingEnabled;

    // are we running in backward compatible mode?
    ENABLED_ENUM m_BackwardCompatibilityEnabled;

    // handle to the event used to launch inetinfo.
    HANDLE m_InetinfoLaunchEvent;

    // if inetinfo has crashed then mark it so
    // we don't write to the metabase during this
    // time period.
    BOOL m_fMetabaseCrashed;
    //
    // CODEWORK Consider splitting out service state management as a separate
    // object from the global context/bag object; right now this class 
    // contains both. 
    //

    // should we filter all data (as opposed to just SSL data)
    BOOL m_FilterAllData;

    //
    // Remembers when the service started (in seconds)
    //
    DWORD m_ServiceStartTime;

    //
    // Flag set in the registry, that allows test to swap in a twp.exe worker
    // process instead of the W3WP.exe worker process.  The flag is under
    // WAS\Parameters called UseTestWP.
    BOOL m_UseTestW3WP;

    //
    // Dispenser for getting things like the local system sid.
    CSecurityDispenser m_SecurityDispenser;

    //
    // HRESULT to report back if no other error is being reported on shutdown.
    HRESULT m_hrToReportToSCM;

    //
    // Flag that let's us know we are currently in the stopping code for the 
    // service and we should not try to attempt a new stop.
    //
    BOOL m_StoppingInProgress;

};  // class WEB_ADMIN_SERVICE



#endif  // _WEB_ADMIN_SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_item.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_item.h

Abstract:

    The IIS web admin service work item class definition.

Author:

    Seth Pollack (sethp)        26-Aug-1998

Revision History:

--*/


#ifndef _WORK_ITEM_H_
#define _WORK_ITEM_H_



//
// common #defines
//

#define WORK_ITEM_SIGNATURE         CREATE_SIGNATURE( 'WITM' )
#define WORK_ITEM_SIGNATURE_FREED   CREATE_SIGNATURE( 'witX' )


//
// prototypes
//

class WORK_ITEM
{

public:

    WORK_ITEM(
        );

    virtual
    ~WORK_ITEM(
        );

    HRESULT
    Execute(
        );

    // "downcast" from a WORK_ITEM to an OVERLAPPED
    inline
    LPOVERLAPPED
    GetOverlapped(
        )
    { return &m_Overlapped; }

    // "upcast" from an OVERLAPPED to a WORK_ITEM
    static
    WORK_ITEM *
    WorkItemFromOverlapped(
        IN const OVERLAPPED * pOverlapped
        );

    VOID
    SetWorkDispatchPointer(
        IN WORK_DISPATCH * pWorkDispatch
        );

    inline
    VOID
    SetOpCode(
        IN ULONG_PTR OpCode
        )
    { m_OpCode = OpCode; }

    inline
    ULONG_PTR
    GetOpCode(
        )
        const
    { return m_OpCode; }

    inline
    VOID
    SetNumberOfBytesTransferred(
        IN DWORD NumberOfBytesTransferred
        )
    { m_NumberOfBytesTransferred = NumberOfBytesTransferred; }

    inline
    DWORD
    GetNumberOfBytesTransferred(
        )
        const
    { return m_NumberOfBytesTransferred; }

    inline
    VOID
    SetCompletionKey(
        IN ULONG_PTR CompletionKey
        )
    { m_CompletionKey = CompletionKey; }

    inline
    ULONG_PTR
    GetCompletionKey(
        )
        const
    { return m_CompletionKey; }

    inline
    VOID
    SetIoError(
        IN HRESULT IoError
        )
    { m_IoError = IoError; }

    inline
    HRESULT
    GetIoError(
        )
        const
    { return m_IoError; }

    BOOL 
    DeleteWhenDone(
        )
    { return m_AutomaticDelete; }

    VOID
    MarkToNotAutoDelete(
        )
    { m_AutomaticDelete = FALSE; }


#if DBG

    inline
    VOID
    SetSerialNumber(
        IN ULONG SerialNumber
        )
    { m_SerialNumber = SerialNumber; }

    inline
    ULONG
    GetSerialNumber(
        )
        const
    { return m_SerialNumber; }

    inline
    PLIST_ENTRY
    GetListEntry(
        )
    { return &m_ListEntry; }
    
#endif  // DBG


private:

    DWORD m_Signature;


#if DBG
    // used for keeping a list of work items outstanding
    LIST_ENTRY m_ListEntry;
#endif  // DBG


    //
    // Members used by work items that are real i/o completions. These do
    // not need to be set for non-i/o work items.
    //
    
    DWORD m_NumberOfBytesTransferred;
    ULONG_PTR m_CompletionKey;
    HRESULT m_IoError;


    // opcode for work dispatch
    ULONG_PTR m_OpCode;


    // pointer for work dispatch
    WORK_DISPATCH * m_pWorkDispatch;


    // for queuing on the completion port
    OVERLAPPED m_Overlapped;


    BOOL m_AutomaticDelete;

#if DBG
    LONG m_SerialNumber;
#endif  // DBG


};  // class WORK_ITEM



#endif  // _WORK_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_dispatch.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_dispatch.h

Abstract:

    The IIS web admin service header for the work item dispatch interface. 
    Classes which perform work queued via a WORK_ITEM must implement this 
    interface. 

    Threading: In derived classes, Reference() and Dereference() must be
    implemented thread-safe, as they may be called by any thread. 
    ExecuteWorkItem() will only be called on the main worker thread.

Author:

    Seth Pollack (sethp)        13-Nov-1998

Revision History:

--*/


#ifndef _WORK_DISPATCH_H_
#define _WORK_DISPATCH_H_



//
// forward references
//

class WORK_ITEM;



//
// prototypes
//

class WORK_DISPATCH
{

public:

    virtual
    VOID
    Reference(
        ) = 0;

    virtual
    VOID
    Dereference(
        ) = 0;

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        ) = 0;


};  // class WORK_DISPATCH



#endif  // _WORK_DISPATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_item.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_item.cxx

Abstract:

    The class which encapsulates a work item, which is the unit of work
    placed on the WORK_QUEUE. 

    Threading: The work item can be filled out and submitted by any one 
    thread, but it will only be executed on the main worker thread.

Author:

    Seth Pollack (sethp)        26-Aug-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the WORK_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_ITEM::WORK_ITEM(
    )
{

#if DBG
    m_ListEntry.Flink = NULL;
    m_ListEntry.Blink = NULL; 
#endif  // DBG

    
    m_NumberOfBytesTransferred = 0;
    m_CompletionKey = 0;
    m_IoError = S_OK;


    m_OpCode = 0;

    m_pWorkDispatch = NULL;
    
    // By default all work items should be deleted
    // once they have been processed.
    m_AutomaticDelete = TRUE;


    ZeroMemory( &m_Overlapped, sizeof( m_Overlapped ) );


#if DBG
    m_SerialNumber = 0;
#endif  // DBG

    m_Signature = WORK_ITEM_SIGNATURE;

}   // WORK_ITEM::WORK_ITEM



/***************************************************************************++

Routine Description:

    Destructor for the WORK_ITEM class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_ITEM::~WORK_ITEM(
    )
{

    DBG_ASSERT( m_Signature == WORK_ITEM_SIGNATURE );
    
    m_Signature = WORK_ITEM_SIGNATURE_FREED;

    if ( m_pWorkDispatch != NULL )
    {

        //
        // Now that the work item is done, dereference the work dispatch 
        // object. 
        //

        m_pWorkDispatch->Dereference();
        m_pWorkDispatch = NULL;

    }
    
}   // WORK_ITEM::~WORK_ITEM



/***************************************************************************++

Routine Description:

    Execute the work item.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_ITEM::Execute(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( m_pWorkDispatch != NULL );


    // execute the work item
    hr = m_pWorkDispatch->ExecuteWorkItem( this );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Work item execution returned an error\n"
            ));

    }


    return hr;
    
}   // WORK_ITEM::Execute



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from an OVERLAPPED to a WORK_ITEM.

Arguments:

    pOverlapped - A pointer to the m_Overlapped member of a WORK_ITEM.

Return Value:

    The pointer to the containing WORK_ITEM.

--***************************************************************************/

// note: static!
WORK_ITEM *
WORK_ITEM::WorkItemFromOverlapped(
    IN const OVERLAPPED * pOverlapped
    )
{

    WORK_ITEM * pWorkItem = NULL;


    DBG_ASSERT( pOverlapped != NULL );


    //  get the containing structure, then verify the signature
    
    pWorkItem = CONTAINING_RECORD( pOverlapped, WORK_ITEM, m_Overlapped );

    DBG_ASSERT( pWorkItem->m_Signature == WORK_ITEM_SIGNATURE );


    return pWorkItem;

}   // WORK_ITEM::WorkItemFromOverlapped



/***************************************************************************++

Routine Description:

    Set the pointer to the WORK_DISPATCH-derived instance which will execute 
    this work item, and reference it appropriately.

Arguments:

    pWorkDispatch - The WORK_DISPATCH-derived instance which will be 
    responsible for executing the work item. Must be valid (non-NULL). 
    A Reference() call will be made to this instance inside this call.

Return Value:

    None.

--***************************************************************************/

VOID
WORK_ITEM::SetWorkDispatchPointer(
    IN WORK_DISPATCH * pWorkDispatch
    )
{

    DBG_ASSERT( pWorkDispatch != NULL );


    if ( m_pWorkDispatch != NULL )
    {

        //
        // This field is already set to something else, so dereference the 
        // old work dispatch pointer before overwriting it.
        //

        m_pWorkDispatch->Dereference();

    }


    //
    // Record and reference the new pointer so that it will stay around while 
    // the async work item is pending.
    //
    
    m_pWorkDispatch = pWorkDispatch; 

    m_pWorkDispatch->Reference();


    return;
    
}   // WORK_ITEM::SetWorkDispatchPointer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_queue.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_queue.h

Abstract:

    The IIS web admin service work queue class definition.

Author:

    Seth Pollack (sethp)        25-Aug-1998

Revision History:

--*/


#ifndef _WORK_QUEUE_H_
#define _WORK_QUEUE_H_



//
// common #defines
//

#define WORK_QUEUE_SIGNATURE        CREATE_SIGNATURE( 'WRKQ' )
#define WORK_QUEUE_SIGNATURE_FREED  CREATE_SIGNATURE( 'wrkX' )



//
// prototypes
//

class WORK_QUEUE
{

public:

    WORK_QUEUE(
        );

    virtual
    ~WORK_QUEUE(
        );

    HRESULT
    Initialize(
        );

    HRESULT
    GetBlankWorkItem(
        OUT WORK_ITEM ** ppWorkItem
        );

    HRESULT
    QueueWorkItem(
        IN WORK_ITEM * pWorkItem
        );

    HRESULT
    GetAndQueueWorkItem(
        IN WORK_DISPATCH * pWorkDispatch,
        IN ULONG_PTR OpCode
        );

    HRESULT
    BindHandleToCompletionPort(
        IN HANDLE HandleToBind,
        IN ULONG_PTR CompletionKey OPTIONAL
        );

    HRESULT
    BindJobToCompletionPort(
        IN HANDLE JobToBind,
        IN LPOVERLAPPED pOverlapped
        );

    VOID
    FreeWorkItem(
        IN WORK_ITEM * pWorkItem
        );

    HRESULT
    ProcessWorkItem(
        );

    VOID
    Terminate(
        );


private:

    HRESULT
    DequeueWorkItem(
        IN DWORD Timeout,
        OUT WORK_ITEM ** ppWorkItem
        );


    DWORD m_Signature;

    HANDLE m_CompletionPort;

    //
    // Prevent races between the shutdown code and other threads
    // attempting to get new blank work items; as well as
    // protecting access to the count of work items outstanding. 
    //
    LOCK m_DispenseWorkItemLock;

    BOOL m_DeletePending;
    
    ULONG m_CountWorkItemsOutstanding;

#if DBG
    LIST_ENTRY m_WorkItemsOutstandingListHead;

    ULONG m_CountWorkItemsGivenOut;
#endif  // DBG
    

};  // class WORK_QUEUE



//
// helper functions
//


VOID
QueueWorkItemFromSecondaryThread(
    IN WORK_DISPATCH * pWorkDispatch,
    IN ULONG_PTR OpCode
    );



#endif  // _WORK_QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\worker_process.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    worker_process.h

Abstract:

    The IIS web admin service worker process class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _WORKER_PROCESS_H_
#define _WORKER_PROCESS_H_



//
// common #defines
//

#define WORKER_PROCESS_SIGNATURE        CREATE_SIGNATURE( 'WPRC' )
#define WORKER_PROCESS_SIGNATURE_FREED  CREATE_SIGNATURE( 'wprX' )


#define INVALID_PROCESS_ID 0



//
// structs, enums, etc.
//

// worker process states
typedef enum _WORKER_PROCESS_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedWorkerProcessState = 1,

    //
    // The process has been created, and we are waiting for it to
    // call back and register over the IPC channel.
    //
    RegistrationPendingWorkerProcessState,

    //
    // As per RegistrationPendingWorkerProcessState above, but as soon
    // as the process registers, we should begin shutting it down.
    //
    RegistrationPendingShutdownPendingWorkerProcessState,

    //
    // The process is running normally.
    //
    RunningWorkerProcessState,

    //
    // We have requested that the process shut down, and are waiting
    // for it to do so.
    //
    ShutdownPendingWorkerProcessState,

    //
    // The process has shut down or been killed. This object instance
    // can go away as soon as it's reference count hits zero.
    //
    DeletePendingWorkerProcessState,

} WORKER_PROCESS_STATE;

// worker process counter gathering states
typedef enum _WORKER_PROCESS_PERF_COUNTER_STATE
{

    //
    // The object is not waiting for counters to 
    // come in, nor have counters arrived for the
    // current request.
    //
    IdleWorkerProcessPerfCounterState = 1,

    //
    // The object is waiting for a perf counter
    // message from the process.
    //
    WaitingWorkerProcessPerfCounterState,

    //
    // The object has received a response for
    // this counter request, do we should not
    // gather any more counters.
    //
    AnsweredWorkerProcessPerfCounterState,


} WORKER_PROCESS_PERF_COUNTER_STATE;


// worker process health states
typedef enum _WORKER_PROCESS_HEALTH_STATE
{

    //
    // The worker process is fine, as far as we know.
    //
    OkWorkerProcessHealthState = 1,

    //
    // The worker process is still functioning, but appears unhealthy
    // in some way, and so needs to be replaced.
    //
    UnhealthyWorkerProcessHealthState,

    //
    // The worker process is a lost cause. Clean things up. This
    // overrides being just unhealthy.
    //
    TerminallyIllWorkerProcessHealthState,

} WORKER_PROCESS_HEALTH_STATE;


// worker process unhealthiness reasons
typedef enum _WORKER_PROCESS_UNHEALTHY_REASON
{

    //
    // CODEWORK: not used right now. Leave it, or remove?
    //
    NYI = 1,

} WORKER_PROCESS_UNHEALTHY_REASON;


// worker process terminal illness reasons
typedef enum _WORKER_PROCESS_TERMINAL_ILLNESS_REASON
{

    //
    // The worker process crashed, exited, or somehow went away.
    //
    CrashWorkerProcessTerminalIllnessReason = 1,

    //
    // The worker process failed to respond to a ping.
    //
    PingFailureProcessTerminalIllnessReason,

    //
    // An IPM error occurred with this worker process. 
    //
    IPMErrorWorkerProcessTerminalIllnessReason,

    //
    // The worker process took too long to start up.
    //
    StartupTookTooLongWorkerProcessTerminalIllnessReason,

    //
    // The worker process took too long to shut down.
    //
    ShutdownTookTooLongWorkerProcessTerminalIllnessReason,

    //
    // An internal error occurred.
    //
    InternalErrorWorkerProcessTerminalIllnessReason,

    //
    // A bad hresult was received from the worker process
    //
    WorkerProcessPassedBadHresult

} WORKER_PROCESS_TERMINAL_ILLNESS_REASON;


// WORKER_PROCESS work items
typedef enum _WORKER_PROCESS_WORK_ITEM
{

    //
    // The process has gone away.
    //
    ProcessHandleSignaledWorkerProcessWorkItem = 1,

    //
    // The process has taken too long to start up.
    //
    StartupTimerExpiredWorkerProcessWorkItem,

    //
    // The process has taken too long to shut down.
    //
    ShutdownTimerExpiredWorkerProcessWorkItem,

    //
    // It is time to rotate the worker process.
    //
    PeriodicRestartTimerWorkerProcessWorkItem,

    //
    // It is time to send a ping.
    //
    SendPingWorkerProcessWorkItem,

    //
    // The process has taken too long to respond to a ping.
    //
    PingResponseTimerExpiredWorkerProcessWorkItem,

} WORKER_PROCESS_WORK_ITEM;



//
// prototypes
//

class WORKER_PROCESS
    : public WORK_DISPATCH
{


//
// The  MESSAGING_HANDLER class is really a part of this class.
//

friend class MESSAGING_HANDLER;


public:

    WORKER_PROCESS(
        IN APP_POOL * pAppPool,
        IN WORKER_PROCESS_START_REASON StartReason,
        IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL,
        IN DWORD_PTR ProcessAffinityMask OPTIONAL
       );

    virtual
    ~WORKER_PROCESS(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        );

    HRESULT
    Shutdown(
        BOOL ShutdownImmediately
        );

    VOID
    Terminate(
        );

    HRESULT
    InitiateReplacement(
        );

    inline
    PLIST_ENTRY
    GetListEntry(
        )
    { return &m_ListEntry; }

    static
    WORKER_PROCESS *
    WorkerProcessFromListEntry(
        IN const LIST_ENTRY * pListEntry
        );

    inline
    DWORD
    GetProcessId(
        )
        const
    { return m_ProcessId; }

    inline
    HANDLE
    GetProcessHandle(
        )
        const
    { return m_ProcessHandle; }

    inline
    DWORD
    GetRegisteredProcessId(
        )
        const
    { return m_RegisteredProcessId; }

    inline
    DWORD_PTR
    GetProcessAffinityMask(
        )
        const
    { return m_ProcessAffinityMask; }

    BOOL
    IsGoingAwaySoon(
        )
        const;

    HRESULT
    RequestCounters(
        );

    HRESULT
    ResetPerfCounterState(
        );

    VOID
    RecordCounters(
        DWORD MessageLength,
        const BYTE* pMessage
        );

    HRESULT
    HandleHresult(
        HRESULT hrToHandle 
        );


    HRESULT
    SendWorkerProcessRecyclerParameters(
        IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged = NULL
    );

    BOOL
    CheckSignature( 
        ) const
    { return ( m_Signature == WORKER_PROCESS_SIGNATURE ); }

private:


    HRESULT
    WorkerProcessRegistrationReceived(
        IN DWORD RegisteredProcessId
        );

    HRESULT
    WorkerProcessStartupSucceeded(
        );


    HRESULT
    PingReplyReceived(
        );

    HRESULT
    ShutdownRequestReceived(
        IN IPM_WP_SHUTDOWN_MSG ShutdownRequestReason
        );

    HRESULT
    IpmErrorOccurred(
        IN HRESULT Error
        );

    HRESULT
    StartProcess(
        );

    HRESULT
    StartProcessInInetinfo(
        );

    HRESULT
    CreateCommandLine(
        OUT STRU * pExeWithPath,
        OUT STRU * pCommandLineArgs
        );

    HRESULT
    MarkAsUnhealthy(
        IN WORKER_PROCESS_UNHEALTHY_REASON UnhealthyReason
        );

    HRESULT
    MarkAsTerminallyIll(
        IN WORKER_PROCESS_TERMINAL_ILLNESS_REASON TerminalIllnessReason,
        IN DWORD ProcessExitCode,
        IN HRESULT ErrorCode
        );

    HRESULT
    KillProcess(
        );

    HRESULT
    RunOrphanAction(
        );

    HRESULT
    InitiateProcessShutdown(
        BOOL ShutdownImmediately
        );

    HRESULT
    RegisterProcessWait(
        );

    HRESULT
    DeregisterProcessWait(
        );

    HRESULT
    ProcessHandleSignaledWorkItem(
        );

    HRESULT
    StartupTimerExpiredWorkItem(
        );

    HRESULT
    ShutdownTimerExpiredWorkItem(
        );

    HRESULT
    PeriodicRestartTimerWorkItem(
        );

    HRESULT
    SendPingWorkItem(
        );

    HRESULT
    PingResponseTimerExpiredWorkItem(
        );

    HRESULT
    BeginStartupTimer(
        );

    HRESULT
    CancelStartupTimer(
        );

    HRESULT
    BeginShutdownTimer(
        IN ULONG ShutdownTimeLimitInMilliseconds
        );

    HRESULT
    CancelShutdownTimer(
        );

    HRESULT
    BeginPeriodicRestartTimer(
        );

    HRESULT
    CancelPeriodicRestartTimer(
        );

    HRESULT
    BeginSendPingTimer(
        );

    HRESULT
    CancelSendPingTimer(
        );

    HRESULT
    BeginPingResponseTimer(
        );

    HRESULT
    CancelPingResponseTimer(
        );

    HRESULT
    BeginTimer(
        IN OUT HANDLE * pTimerHandle,
        IN WAITORTIMERCALLBACKFUNC pCallbackFunction,
        IN ULONG InitialFiringTime
        );

    HRESULT
    CancelTimer(
        IN OUT HANDLE * pTimerHandle
        );

    VOID
    DealWithInternalWorkerProcessFailure(
        IN HRESULT Error
        );


    DWORD m_Signature;

    // used by the owning APP_POOL to keep a list of its WORKER_PROCESSes
    LIST_ENTRY m_ListEntry;

    LONG m_RefCount;

    // for communication with the worker process
    MESSAGING_HANDLER m_MessagingHandler;

    // registration id used by the IPM layer to associate the process
    DWORD m_RegistrationId;

    WORKER_PROCESS_STATE m_State;

    // back pointer
    APP_POOL * m_pAppPool;

    // pid returned from CreateProcess
    DWORD m_ProcessId;

    //
    // The pid passed back by the worker process via IPM. This pid is
    // different that the pid returned by CreateProcess in one case,
    // namely when running worker processes under a debugger via 
    // ImageFileExecutionOptions. In this case CreateProcess returns
    // the pid of the debugger process, not the pid of the worker
    // process. 
    // 
    DWORD m_RegisteredProcessId;

    HANDLE m_ProcessHandle;

    // watching for the process to go away
    HANDLE m_ProcessWaitHandle;

    //
    // This flag remembers if the process is alive. We can't just set the
    // process handle to a valid handle vs. an invalid sentinel for this
    // purpose, because we will hold the handle open even after the process
    // dies. Doing this prevents the process id from being reused, which
    // would cause problems.
    //
    BOOL m_ProcessAlive;

    WORKER_PROCESS_HEALTH_STATE m_Health;

    BOOL m_BeingReplaced;

    BOOL m_NotifiedAppPoolThatStartupAttemptDone;

    // startup timer
    HANDLE m_StartupTimerHandle;
    DWORD m_StartupBeganTickCount;

    // shutdown timer
    HANDLE m_ShutdownTimerHandle;
    DWORD m_ShutdownBeganTickCount;

    // periodic restart timer
    HANDLE m_PeriodicRestartTimerHandle;

    // send ping timer
    HANDLE m_SendPingTimerHandle;

    // ping response timer
    HANDLE m_PingResponseTimerHandle;
    DWORD m_PingBeganTickCount;

    BOOL m_AwaitingPingReply;

    // why was this worker process started?
    WORKER_PROCESS_START_REASON m_StartReason;

    // for replacement processes, who is the predecessor we need to retire?
    WORKER_PROCESS * m_pWorkerProcessToReplace;

    // if this worker process is affinitized, which processor is it bound to?
    DWORD_PTR m_ProcessAffinityMask;

    // remembers if the server is in backward compatibility mode.
    BOOL m_BackwardCompatibilityEnabled;

    // remembers what state this worker process is in
    // when it comes to perf counters.
    WORKER_PROCESS_PERF_COUNTER_STATE m_PerfCounterState;

    // if we are remembering a request to shutdown we need to know the type 
    // of request.
    BOOL m_ShutdownType;

};  // class WORKER_PROCESS



#endif  // _WORKER_PROCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\worker_process.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    worker_process.cxx

Abstract:

    This class encapsulates the management of a single worker process.

    Threading: For the class itself, Reference(), Dereference(), and the
    destructor may be called on any thread; all other work is done on the
    main worker thread.
    The various timer and wait callbacks are called on secondary threads.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"


//
// local prototypes
//

VOID
StartupTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
ShutdownTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
PeriodicRestartTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
SendPingTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
PingResponseTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );

VOID
ProcessHandleSignaledCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    );


/***************************************************************************++

Routine Description:

    Constructor for the WORKER_PROCESS class.

Arguments:

    pAppPool - The app pool which owns this worker process.

    StartReason - The reason this worker process is being started.

    pWorkerProcessToReplace - If this worker process is being created to
    replace an existing worker process, this parameter identifies that
    predecessor process. May be NULL.

    ProcessAffinityMask - If this worker process is to run on a particular
    processor, this mask specifies which one. If this parameter is zero, this
    worker process is not affinitized.

Return Value:

    None.

--***************************************************************************/

WORKER_PROCESS::WORKER_PROCESS(
    IN APP_POOL * pAppPool,
    IN WORKER_PROCESS_START_REASON StartReason,
    IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL,
    IN DWORD_PTR ProcessAffinityMask OPTIONAL
    )
    :
    m_MessagingHandler()
{


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPool != NULL );


    m_ListEntry.Flink = NULL;
    m_ListEntry.Blink = NULL;


    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_RegistrationId = 0;

    m_State = UninitializedWorkerProcessState;

    // Remember if backward compatibility is enabled.
    m_BackwardCompatibilityEnabled = GetWebAdminService()->IsBackwardCompatibilityEnabled();

    // reference the parent app pool, since we'll hold its pointer
    m_pAppPool = pAppPool;
    m_pAppPool->Reference();

    m_ProcessId = INVALID_PROCESS_ID;
    m_RegisteredProcessId = INVALID_PROCESS_ID;

    m_Health = OkWorkerProcessHealthState;

    m_BeingReplaced = FALSE;

    m_NotifiedAppPoolThatStartupAttemptDone = FALSE;

    m_StartReason = StartReason;

    m_StartupTimerHandle = NULL;
    m_StartupBeganTickCount = 0;

    m_ShutdownTimerHandle = NULL;
    m_ShutdownBeganTickCount = 0;

    m_PeriodicRestartTimerHandle = NULL;

    m_SendPingTimerHandle = NULL;

    m_PingResponseTimerHandle = NULL;
    m_PingBeganTickCount = 0;

    m_AwaitingPingReply = FALSE;

    // ======
    // Not changed in backward compatibility mode
    m_ProcessHandle = NULL;      

    m_ProcessWaitHandle = NULL;   

    m_ProcessAlive = FALSE;
    // End of not used section
    // ========

    m_pWorkerProcessToReplace = pWorkerProcessToReplace;


    //
    // If there is a worker process to replace, our start reason
    // better be ReplaceWorkerProcessStartReason, and vice versa.
    //

    DBG_ASSERT( ( m_pWorkerProcessToReplace != NULL ) == ( m_StartReason == ReplaceWorkerProcessStartReason ) );


    //
    // If we are replacing another worker process, then reference it
    // to keep it around until our startup attempt is done.
    //

    if ( m_pWorkerProcessToReplace != NULL )
    {
        m_pWorkerProcessToReplace->Reference();
    }

    m_PerfCounterState = IdleWorkerProcessPerfCounterState;

    m_ProcessAffinityMask = ProcessAffinityMask;

    // defaults to shutting down immediately when a shutdown is requested.
    m_ShutdownType = TRUE;

    m_Signature = WORKER_PROCESS_SIGNATURE;
}   // WORKER_PROCESS::WORKER_PROCESS



/***************************************************************************++

Routine Description:

    Destructor for the WORKER_PROCESS class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORKER_PROCESS::~WORKER_PROCESS(
    )
{

    DBG_ASSERT( m_Signature == WORKER_PROCESS_SIGNATURE );

    m_Signature = WORKER_PROCESS_SIGNATURE_FREED;

    DBG_ASSERT( m_ListEntry.Flink == NULL );
    DBG_ASSERT( m_ListEntry.Blink == NULL );

    DBG_ASSERT( m_RefCount == 0 );

    DBG_ASSERT( m_State == DeletePendingWorkerProcessState );

    DBG_ASSERT( m_ProcessWaitHandle == NULL );

    DBG_ASSERT( ! m_ProcessAlive );

    DBG_ASSERT( m_NotifiedAppPoolThatStartupAttemptDone );

    DBG_ASSERT( m_StartupTimerHandle == NULL );

    DBG_ASSERT( m_ShutdownTimerHandle == NULL );

    DBG_ASSERT( m_PeriodicRestartTimerHandle == NULL );

    DBG_ASSERT( m_SendPingTimerHandle == NULL );

    DBG_ASSERT( m_PingResponseTimerHandle == NULL );

    DBG_ASSERT( m_pWorkerProcessToReplace == NULL );


    //
    // Dereference the parent app pool.
    //

    DBG_ASSERT( m_pAppPool != NULL );

    m_pAppPool->Dereference();
    m_pAppPool = NULL;


    //
    // We don't close the process handle until here in the destructor,
    // because that prevents the process id from getting reused while this
    // instance is still around. Having more than one WORKER_PROCESS instance
    // with the same process id could lead to weird behavior.
    //

    if ( m_ProcessHandle != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_ProcessHandle ) );
        m_ProcessHandle = NULL;
    }

    //
    // Clean up any issues with perf counters.
    //
    if ( m_PerfCounterState == WaitingWorkerProcessPerfCounterState )
    {
        //
        // If we are waiting on counters from this object and it is being
        // released then the least we can do is tell the perf manager not to
        // wait any more.
        //

        PERF_MANAGER* pManager = GetWebAdminService()->
           GetUlAndWorkerManager()->
           GetPerfManager();

        //
        // If we don't have a perf manager than no one is waiting on
        // these counters, so we can go ahead and forget about sending
        // back anything.
        //
        if ( pManager )
        {
            //
            // By sending a zero length message, the perf manager
            // will just decrement the number of counters, if it 
            // is waiting on counters.
            //
            pManager->RecordCounters(0, NULL);
        }

        m_PerfCounterState = IdleWorkerProcessPerfCounterState;

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process counter after cleanup is %d\n",
                m_PerfCounterState
                ));
        }

    }

}   // WORKER_PROCESS::~WORKER_PROCESS



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must
    be thread safe, and must not be able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    //
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // WORKER_PROCESS::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count
    hits zero. Note that this method must be thread safe, and must not be
    able to fail.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Reference count has hit zero in WORKER_PROCESS instance, deleting (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        delete this;


    }


    return;

}   // WORKER_PROCESS::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Executing work item with serial number: %lu in WORKER_PROCESS (ptr: %p; pid: %lu; realpid: %lu) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case ProcessHandleSignaledWorkerProcessWorkItem:
        hr = ProcessHandleSignaledWorkItem();
        break;

    case StartupTimerExpiredWorkerProcessWorkItem:
        hr = StartupTimerExpiredWorkItem();
        break;

    case ShutdownTimerExpiredWorkerProcessWorkItem:
        hr = ShutdownTimerExpiredWorkItem();
        break;

    case PeriodicRestartTimerWorkerProcessWorkItem:
        hr = PeriodicRestartTimerWorkItem();
        break;

    case SendPingWorkerProcessWorkItem:
        hr = SendPingWorkItem();
        break;

    case PingResponseTimerExpiredWorkerProcessWorkItem:
        hr = PingResponseTimerExpiredWorkItem();
        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Executing work item on WORKER_PROCESS failed\n"
            ));

        //
        // Need to grab this value before calling DealWithInternalWorkerProcessFailue
        // because it may cause this object to get destroyed.
        //

        BOOL BackwardCompatibilityEnabled = m_BackwardCompatibilityEnabled;

        DealWithInternalWorkerProcessFailure( hr );

        //
        // Bubbling up the failed HRESULT further will make this a service
        // fatal error; but since we've handled it locally, return S_OK
        // instead, unless we are in backward compatibile mode than it 
        // is a service wide error to have the worker process not start.
        //

        if (!BackwardCompatibilityEnabled)
        {
            hr = S_OK;
        }

    }

    return hr;

}   // WORKER_PROCESS::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize this instance by creating it's actual process, and setting up
    other required machinery.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::Initialize(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( CheckSignature() );


    //
    // CODEWORK Consider making this registration id bigger and more random,
    // to make registration spoofing harder. Note that this would require some
    // enhancements in the IPM library as well, as today it assumes that
    // the registration id is a DWORD.
    //

    // note: static!
    static DWORD NextWorkerProcessProcessRegistrationId = 1;


    //
    // Assign a unique registration id for this worker process.
    //

    // If we are in backward compatibility mode than we really 
    // need the registration number not to change or else we end
    // up with inetinfo not being able to tell us it has registered.
    if (m_BackwardCompatibilityEnabled)
    {
        m_RegistrationId = 1;
    }
    else
    {
        m_RegistrationId = NextWorkerProcessProcessRegistrationId;

        //
        // Increment the counter for the next user. Also, make sure that if it
        // rolls over, zero is never used as an id value. (The worker process
        // code will not accept zero as a valid id).
        //

        NextWorkerProcessProcessRegistrationId++;

        if ( NextWorkerProcessProcessRegistrationId == 0 )
        {
            NextWorkerProcessProcessRegistrationId = 1;
        }
    }


    //
    // Initialize the messaging handler.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Initializing message handler\n"
            ));
    }

    hr = m_MessagingHandler.Initialize( this );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing messaging handler failed\n"
            ));

        goto exit;
    }


    //
    // Tell the messaging infrastructure to expect a connection from our
    // about to be created process, and to associate it with this messaging
    // handler.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Accepting messages\n"
            ));
    }
    hr = m_MessagingHandler.AcceptMessagePipeConnection( m_RegistrationId );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Accepting message pipe connection failed\n"
            ));

        goto exit;
    }


    //
    // Create the actual process.
    //

    if (m_BackwardCompatibilityEnabled)
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Starting Inetinfo W3WP Process\n"
                ));
        }
        hr = StartProcessInInetinfo();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not start process\n"
                ));

            goto exit;
        }

    }
    else
    {
        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Starting W3WP process\n"
                ));
        }
        hr = StartProcess();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not create process, shutting down app pool\n"
                ));


            goto exit;
        }


        hr = RegisterProcessWait();
        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not register wait on process handle\n"
                ));

            goto exit;
        }
    
    }

    hr = BeginStartupTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Beginning worker process startup timer failed\n"
            ));

        goto exit;
    }


    m_State = RegistrationPendingWorkerProcessState;


exit:

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initializing WORKER_PROCESS failed\n"
            ));

        //
        // Need to grab this value before calling DealWithInternalWorkerProcessFailue
        // because it may cause this object to get destroyed.
        //

        BOOL BackwardCompatibilityEnabled = m_BackwardCompatibilityEnabled;

        DealWithInternalWorkerProcessFailure( hr );

        //
        // Bubbling up the failed HRESULT further will make this a service
        // fatal error; but since we've handled it locally, return S_OK
        // instead, unless we are in backward compatibile mode than it 
        // is a service wide error to have the worker process not start.
        //

        if (!BackwardCompatibilityEnabled)
        {
            hr = S_OK;
        }

    }


    return hr;

}   // WORKER_PROCESS::Initialize



/***************************************************************************++

Routine Description:

    Shut down the worker process. This can safely be called multiple times
    on an instance.

Arguments:

    BOOL ShutdownImmediately = tell worker processes to shutdown immediately.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::Shutdown(
    BOOL ShutdownImmediately
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    // take a reference, because we do not want to end up marking the
    // worker process as terminal and releasing it before we are done 
    // working with it here.
    Reference();

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // The actions needed for shutdown depend on the current state of
    // this object.
    //


    switch ( m_State )
    {

    case UninitializedWorkerProcessState:

        //
        // If we haven't even initialized this instance successfully, then
        // we don't need to do any work here. 
        //

        break;

    case RegistrationPendingWorkerProcessState:

        //
        // We can't tell the worker process to shut down right away,
        // because it hasn't yet called back to register with us, and thus
        // we have no means to communicate with it. However, we also
        // shouldn't just blow it away, because it may have already
        // started processing requests, or perhaps application running
        // inside of it may have modified persistent or shared state.
        // Therefore, remember that we are waiting to shut down, and once
        // the worker process registers, immediately start the shutdown
        // procedure.
        //

        m_State = RegistrationPendingShutdownPendingWorkerProcessState;
        m_ShutdownType = ShutdownImmediately;

        break;

    case RegistrationPendingShutdownPendingWorkerProcessState:

        //
        // We are already waiting to start shutdown as soon as possible;
        // no need for further action.
        //

        break;

    case RunningWorkerProcessState:

        //
        // Tell the worker process to shut down. Note that if starting
        // clean shutdown fails, the method will go ahead and Terminate()
        // the instance.
        //

        hr = InitiateProcessShutdown( ShutdownImmediately );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating process shutdown failed\n"
                ));

        }

        break;

    case ShutdownPendingWorkerProcessState:

        //
        // We are already shutting down; no need for further action.
        //

        break;

    case DeletePendingWorkerProcessState:

        //
        // We are already waiting to go away as soon as our ref count
        // hits zero; no need for further action.
        //

        break;

    default:

        //
        // Invalid state!
        //

        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initiating clean worker process shutdown failed\n"
            ));

        DealWithInternalWorkerProcessFailure( hr );

        //
        // Bubbling up the failed HRESULT further will make this a service
        // fatal error; but since we've handled it locally, return S_OK
        // instead, unless we are in backward compatibile mode than it 
        // is a service wide error to have the worker process not start.
        //

        if (!m_BackwardCompatibilityEnabled)
        {
            hr = S_OK;
        }

    }

    // Now if it wants to go away, that is fine with us.
    Dereference();

    return hr;

}   // WORKER_PROCESS::Shutdown


/***************************************************************************++

Routine Description:

    RequestCounters from the worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::RequestCounters(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    //
    // Only request counters if the worker process is in a running state
    // and if we aren't all ready waiting for the worker process to provide
    // counters.
    //

    if ( m_State == RunningWorkerProcessState && m_PerfCounterState == IdleWorkerProcessPerfCounterState )
    {

        hr = m_MessagingHandler.RequestCounters();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "RequestCounters message failed\n"
                ));
 
            goto exit;
        }

        m_PerfCounterState = WaitingWorkerProcessPerfCounterState;    

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker Process counter state after requesting counters is now %d\n",
                m_PerfCounterState
                ));
        }

    }
    else
    {
        //
        // Only if we are not waiting for counters to be returned
        // should we remove ourselves from the count of worker processes
        // to be waited on.
        //
        if ( m_PerfCounterState != WaitingWorkerProcessPerfCounterState )
        {
            hr = S_FALSE;
        }
    }

exit:

    return hr;

}   // WORKER_PROCESS::RequestCounters

/***************************************************************************++

Routine Description:

    Have the worker process reset it's perf counter state
    if the state is set to answered.  If we are still waiting
    then leave it's state as waiting.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ResetPerfCounterState(
    )
{

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    DBG_ASSERT ( CheckSignature() );

    //
    // Only reset the state if the state is answered.
    // If it is waiting or idle then it should stay 
    // that way.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Worker process counter state before reseting is: %d\n",
            m_PerfCounterState
            ));
    }

    if ( m_PerfCounterState == AnsweredWorkerProcessPerfCounterState )
    {
        m_PerfCounterState = IdleWorkerProcessPerfCounterState;
    }

    return S_OK;

}   // WORKER_PROCESS::ResetPerfCounterState


/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities
    which may hold a reference to this object to release that reference
    (and not take any more), in order to break reference cycles.

    Note that this function may cause the instance to delete itself;
    instance state should not be accessed when unwinding from this call.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::Terminate(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Only clean up if we haven't done so already.
    //

    if ( m_State != DeletePendingWorkerProcessState )
    {

        //
        // Set the state to show we're dead, and just waiting for our ref
        // count to hit zero.
        //

        m_State = DeletePendingWorkerProcessState;


        //
        // Cancel the startup timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelStartupTimer() ) );


        //
        // Cancel the shutdown timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelShutdownTimer() ) );


        //
        // Cancel the periodic restart timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelPeriodicRestartTimer() ) );


        //
        // Cancel the send ping timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelSendPingTimer() ) );


        //
        // Cancel the ping response timer, if present.
        //

        DBG_REQUIRE( SUCCEEDED( CancelPingResponseTimer() ) );


        //
        // Close down the named pipe.
        //
        m_MessagingHandler.Terminate();


        //
        // Cancel the process handle wait, if present.
        //

        DBG_REQUIRE( SUCCEEDED( DeregisterProcessWait() ) );


        if ( m_ProcessAlive )
        {

            //
            // Blow away the process.
            //

            DBG_REQUIRE( SUCCEEDED( KillProcess() ) );

        }


        //
        // If we are still holding a reference to a worker process to replace,
        // tell it to shut down, and clean up the reference.
        //

        if ( m_pWorkerProcessToReplace != NULL )
        {
            hr = m_pWorkerProcessToReplace->Shutdown( FALSE );

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Shutting down worker process to replace failed\n"
                    ));

                //
                // Press on in the face of errors.
                //

                hr = S_OK;
            }


            m_pWorkerProcessToReplace->Dereference();
            m_pWorkerProcessToReplace = NULL;
        }


        //
        // If we haven't already told the parent app pool that our startup
        // attempt is over, we do so now.
        //

        if ( ! m_NotifiedAppPoolThatStartupAttemptDone )
        {
            hr = m_pAppPool->WorkerProcessStartupAttemptDone( m_StartReason, NULL );

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Notifying app pool that worker process startup attempt done failed\n"
                    ));

                //
                // Press on in the face of errors.
                //

                hr = S_OK;
            }


            m_NotifiedAppPoolThatStartupAttemptDone = TRUE;
        }


        //
        // Tell our parent to remove this instance from it's data structures,
        // and dereference the instance.
        //

        hr = m_pAppPool->RemoveWorkerProcessFromList( this );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Removing worker process from app pool's list failed\n"
                ));

            //
            // Press on in the face of errors.
            //

            hr = S_OK;
        }


        //
        // Note: that may have been our last reference, so don't do any
        // more work here.
        //

    }


    return;

}   // WORKER_PROCESS::Terminate



/***************************************************************************++

Routine Description:

    Request a replacement for this worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::InitiateReplacement(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    //
    // Check if we are already being replaced; if so, we ignore this new
    // request to do so.
    //


    if ( m_BeingReplaced )
    {
        goto exit;
    }


    hr = m_pAppPool->RequestReplacementWorkerProcess( this );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Requesting replacement worker process failed or replacement was disallowed\n"
            ));

        //
        // Since creating the replacement worker process failed, it may
        // not be calling back later to tell this instance to start
        // shutting down. Therefore, start shutdown ourselves. Note that
        // calling Shutdown() multiple times is ok.
        //

        hr = Shutdown( FALSE );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Shutting down worker process failed\n"
                ));

        }


        goto exit;
    }


    //
    // Now that we are being replaced, our replacer will tell us to begin
    // our shutdown once it's start-up attempt is complete.
    //

    m_BeingReplaced = TRUE;


exit:


    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initiating worker process replacement failed\n"
            ));


        DealWithInternalWorkerProcessFailure( hr );


        //
        // Bubbling up the failed HRESULT further will make this a service
        // fatal error; but since we've handled it locally, return S_OK
        // instead.
        //

        hr = S_OK;

    }


    return hr;

}   // WORKER_PROCESS::InitiateReplacement



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from a LIST_ENTRY to a WORKER_PROCESS.

Arguments:

    pListEntry - A pointer to the m_ListEntry member of a WORKER_PROCESS.

Return Value:

    The pointer to the containing WORKER_PROCESS.

--***************************************************************************/

// note: static!
WORKER_PROCESS *
WORKER_PROCESS::WorkerProcessFromListEntry(
    IN const LIST_ENTRY * pListEntry
)
{

    WORKER_PROCESS * pWorkerProcess = NULL;

    DBG_ASSERT( pListEntry != NULL );

    //  get the containing structure, then verify the signature
    pWorkerProcess = CONTAINING_RECORD( pListEntry, WORKER_PROCESS, m_ListEntry );

    DBG_ASSERT( pWorkerProcess->m_Signature == WORKER_PROCESS_SIGNATURE );

    return pWorkerProcess;

}   // WORKER_PROCESS::WorkerProcessFromListEntry



/***************************************************************************++

Routine Description:

    Determine whether this process is going to go away soon, i.e. if it is
    in the process of being replaced or shutting down. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if this worker process will go away soon, FALSE otherwise.

--***************************************************************************/

BOOL
WORKER_PROCESS::IsGoingAwaySoon(
    )
    const
{

    DBG_ASSERT ( CheckSignature() );

    //
    // If this instance is in a shutdown pending or delete pending state, or
    // if it is being replaced (and so is guaranteed to get shutdown soon) 
    // then we pronounce that it is going away soon.
    //

    return ( ( m_BeingReplaced ) ||
             ( m_State == RegistrationPendingShutdownPendingWorkerProcessState ) ||
             ( m_State == ShutdownPendingWorkerProcessState ) ||
             ( m_State == DeletePendingWorkerProcessState ) );

}   // WORKER_PROCESS::IsGoingAwaySoon



/***************************************************************************++

Routine Description:

    Handle the fact that the worker process has registered successfully
    via IPM. This does not mean that the worker process is up and running,
    it means that the pipe is connected and we now know the pid.

Arguments:

    RegisteredProcessId - The pid of the worker process, as communicated
    back via IPM during its registration. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::WorkerProcessRegistrationReceived(
    IN DWORD RegisteredProcessId
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    m_RegisteredProcessId = RegisteredProcessId;

    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Registration received from worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }

    return hr;

}   // WORKER_PROCESS::WorkerProcessRegistrationReceived


/***************************************************************************++

Routine Description:

    Handle the fact that the worker process has reported a successful startup,
    at this point we stop the timers, and can shutdown other worker processes,
    even let the app pool know that we are up.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::WorkerProcessStartupSucceeded(
    )
{

    HRESULT hr = S_OK;
    WORKER_PROCESS_STATE PreviousState = UninitializedWorkerProcessState;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    PreviousState = m_State;


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Worker process entering running state (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    m_State = RunningWorkerProcessState;


    //
    // We've received the message, so get rid of the timer.
    //
    
    hr = CancelStartupTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling startup timer failed\n"
            ));

        goto exit;
    }


    //
    // Check to see if we were waiting to shut down as soon as
    // registration happened.
    //

    if ( PreviousState == RegistrationPendingShutdownPendingWorkerProcessState )
    {


        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process shutdown was pending on registration; start now (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }

        hr = Shutdown( m_ShutdownType );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating shutdown failed\n"
                ));

            goto exit;
        }

    }
    else
    {

        //
        // This is the normal path; as such, we should have been in
        // the registration pending state.
        //

        DBG_ASSERT( PreviousState == RegistrationPendingWorkerProcessState );


        //
        // Notify the app pool that our startup is done.
        //
        hr = m_pAppPool->WorkerProcessStartupAttemptDone( m_StartReason,  this );

        m_NotifiedAppPoolThatStartupAttemptDone = TRUE;

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Notifying app pool that worker process startup attempt is done failed\n"
                ));

            goto exit;
        }


        if ( m_pWorkerProcessToReplace != NULL )
        {
            //
            // If we were replacing another worker process, then shut it down
            // and clean up our reference to it.
            //

            hr = m_pWorkerProcessToReplace->Shutdown( FALSE );

            if ( FAILED( hr ) )
            {

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Shutting down replaced worker process failed\n"
                    ));

            }

            m_pWorkerProcessToReplace->Dereference();
            m_pWorkerProcessToReplace = NULL;
        }

        //
        // Initiate starting of WP recycler
        //

        hr = SendWorkerProcessRecyclerParameters();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating start of worker process recycler failed\n"
                ));

            goto exit;
        }


        hr = BeginPeriodicRestartTimer();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Starting periodic restart timer failed\n"
                ));

            goto exit;
        }


        hr = BeginSendPingTimer();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Starting send ping timer failed\n"
                ));

            goto exit;
        }

    }

exit:

    return hr;

}   // WORKER_PROCESS::WorkerProcessStartupSucceeded


/***************************************************************************++

Routine Description:

    Handle a response from the worker process to a previous ping message.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::PingReplyReceived(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( !m_BackwardCompatibilityEnabled);
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Ping reply received from worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    //
    // A screwy worker process could potentially send us a ping response
    // without us having pinged it in the first place. For debug builds,
    // print a warning (not an assert, as this creates problems for testing);
    // for retail, ignore gracefully.
    //

    if ( ! m_AwaitingPingReply )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Warning - unexpected ping reply received from worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        goto exit;
    }


    m_AwaitingPingReply = FALSE;


    //
    // Cancel the timer that enforces a timely ping response; then start
    // the timer that will tell us when to ping again.
    //

    hr = CancelPingResponseTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling ping response timer failed\n"
            ));

        goto exit;
    }


    hr = BeginSendPingTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Starting send ping timer failed\n"
            ));

        goto exit;
    }


exit:

    return hr;
}   // WORKER_PROCESS::PingReplyReceived

/***************************************************************************++

Routine Description:

    Records that a worker processes counters have been received.

Arguments:

    DWORD MessageLength - Length of message containing counters.
    const BYTE* pMessage - the counters themselves.

Return Value:

    VOID

--***************************************************************************/

VOID
WORKER_PROCESS::RecordCounters(
    DWORD MessageLength,
    const BYTE* pMessage
    )
{

    HRESULT hr = S_OK;
    PERF_MANAGER* pManager = NULL;

    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Counters received from worker process (ptr: %p; pid: %lu; realpid: %lu; perf state: %d)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            m_PerfCounterState
            ));
    }


    //
    // If the worker process has not all ready answered then we 
    // can record counters.  
    //
    if ( m_PerfCounterState != AnsweredWorkerProcessPerfCounterState )
    {
        //
        // Remember that we have recorded counters for this worker 
        // process so we don't do it again.
        //
        m_PerfCounterState = AnsweredWorkerProcessPerfCounterState;

        //
        // This will let the performance manager know that it is waiting for
        // one less worker process to produce numbers.  When this hits Zero 
        // we will publish.
        //
        pManager = GetWebAdminService()->
                   GetUlAndWorkerManager()->
                   GetPerfManager();

        //
        // We could receive counters from a worker process and not
        // have a perf manager.  In this case, just ignor the message.
        //
        if ( pManager )
        {
            pManager->RecordCounters(MessageLength, pMessage);
        }
    }



}   // WORKER_PROCESS::RecordCountersReceived

/***************************************************************************++

Routine Description:

    Handles an hresult being sent in by the worker process

Arguments:

    HRESULT hrToHandle - the hresult to process

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::HandleHresult(
    HRESULT hrToHandle 
    )
{
    HRESULT hr = S_OK;

    // Need to determine if we are attempting to startup the worker process,
    // if we are then if this is successful, we need to call the startup complete.
    if ( ( m_State == RegistrationPendingWorkerProcessState ) ||
         ( m_State == RegistrationPendingShutdownPendingWorkerProcessState ) )
    {
        if ( SUCCEEDED ( hrToHandle ) )
        {
            hr = WorkerProcessStartupSucceeded();

            if ( FAILED ( hr ) )
            {

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Failed to startup the worker process \n"
                    ));
            }

            goto exit;

        }

    }

    //
    // We don't worry about the case where we got an S_OK but were not in the middle of
    // starting up.  I think this might be able to happen if we timeout right before we 
    // get the S_OK sent.
    //

    if ( FAILED ( hrToHandle ) ) 
    {
        //
        // Need to mark the worker process as terminally ill, this
        // may be during startup, or it may be anytime during the worker
        // processes lifetime.
        //
        hr = MarkAsTerminallyIll( WorkerProcessPassedBadHresult, 0, hrToHandle );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Marking worker process as terminally ill failed\n"
                ));

        }

    }

exit:

    return hr;

}   // WORKER_PROCESS::HandleHresult

/***************************************************************************++

Routine Description:

    Handle a request from the worker process to shut down. The response can
    either be to ignore it, if the shutdown request is refused, or to send
    a shutdown message if it is granted.

Arguments:

    ShutdownRequestReason - The reason the worker process is requesting
    shutdown.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ShutdownRequestReceived(
    IN IPM_WP_SHUTDOWN_MSG ShutdownRequestReason
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );

    // Only requests below are if the wp has gone idle or if 
    // the wp has processed too many requests.  Neither of these
    // should ever happen in backward compatibile mode.
    DBG_ASSERT( !m_BackwardCompatibilityEnabled);


    //
    // Ignore shutdown requests from the worker process if we are not
    // currently in the running state.
    //

    if ( m_State != RunningWorkerProcessState )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Process shutdown request received from worker process (ptr: %p; pid: %lu; realpid: %lu), reason: %lu\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            ShutdownRequestReason
            ));
    }


    if ( ShutdownRequestReason == IPM_WP_RESTART_COUNT_REACHED ||
         ShutdownRequestReason == IPM_WP_RESTART_SCHEDULED_TIME_REACHED ||
         ShutdownRequestReason == IPM_WP_RESTART_ELAPSED_TIME_REACHED ||
         ShutdownRequestReason == IPM_WP_RESTART_MEMORY_LIMIT_REACHED )
    {
        //
        // CODEWORK: Reason for restarting is currently ignored
        // it could potentially be interesting to log reason to event log
        //


        //
        // Time to replace this worker process. Request a replacement;
        // this instance will be informed to shut down later.
        //

        hr = InitiateReplacement();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating process replacement failed\n"
                ));

            goto exit;
        }

    }
    else if ( ShutdownRequestReason == IPM_WP_IDLE_TIME_REACHED )
    {

        //
        // This worker process is idle; tell it to shut down.
        //

        hr = Shutdown( FALSE );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating worker process shutdown failed\n"
                ));

            goto exit;
        }

    }
    else
    {

        //
        // Invalid shutdown request reason!
        //

        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        goto exit;

    }


exit:

    return hr;

}   // WORKER_PROCESS::ShutdownRequestReceived



/***************************************************************************++

Routine Description:

    Handle an error from the IPM layer.

Arguments:

    Error - The error code from IPM.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::IpmErrorOccurred(
    IN HRESULT Error
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( ( m_State == ShutdownPendingWorkerProcessState ) && 
         ( ( Error == HRESULT_FROM_NT ( STATUS_PIPE_BROKEN ) ) ||
           ( Error == HRESULT_FROM_WIN32 ( ERROR_BROKEN_PIPE ) ) ) )
     {

        //
        // If we've asked the worker process to shut down, we expect
        // it to break off the pipe. Therefore, in this case, ignore
        // it unless we are in backward compatiblity mode.  If we are 
        // than this is the signal that the wp has shutdown so we need
        // to Terminate the worker process before ignoring the IPM call.
        //

        if (m_BackwardCompatibilityEnabled)
        {
            Terminate();
        }
        
        goto exit;
     }


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "IPM error occurred with worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    //
    // Losing communication with the worker process is bad. We consider
    // this a terminal condition.
    //

    hr = MarkAsTerminallyIll( IPMErrorWorkerProcessTerminalIllnessReason, 0, Error );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Marking worker process as terminally ill failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORKER_PROCESS::IpmErrorOccurred


/***************************************************************************++

Routine Description:

    Spin up a worker process in inetinfo.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::StartProcessInInetinfo(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    // Function should only be called in 
    // backward compatibility mode.
    DBG_ASSERT(m_BackwardCompatibilityEnabled);

    // Tell the Admin Service to signal inetinfo to 
    // launch the worker process.  The worker process
    // will signal us back by connecting to the ipm.
    // if it fails to we will time out the worker process.
    hr = GetWebAdminService()->LaunchInetinfo();

    return hr;
}

/***************************************************************************++

Routine Description:

    Spin up the actual process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::StartProcess(
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    STRU ExeWithPath;
    STRU ArgsForCommandLine;
    HANDLE Token = NULL;
    DWORD ReturnCode = 0;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);

    DBG_ASSERT( m_pAppPool );

    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );

    ZeroMemory( &ProcessInfo, sizeof( ProcessInfo ) );


    //
    // Create the command line.
    //

    hr = CreateCommandLine( &ExeWithPath, &ArgsForCommandLine );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating command line failed\n"
            ));

        goto exit;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Launching worker process with command line of %S\n",
            ArgsForCommandLine.QueryStr()
            ));
    }

    Token = m_pAppPool->GetWorkerProcessToken();
    if ( Token == NULL )
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);

        DPERROR((
            DBG_CONTEXT,
            hr,
            "No configured identity to run worker process under.\n"
            ));

        goto exit;
    }

    //
    // Create the actual process.
    //
    // We create the process suspended so that, if necessary, we can
    // affinitize it to a particular processor.
    //
    // We pass as the current directory the current directory of the
    // web admin service DLL; the worker process EXE and its components
    // live in the same directory.
    //

    Success = CreateProcessAsUser(
                    Token,                  // security token for new process
                    ExeWithPath.QueryStr(), // program name
                    ArgsForCommandLine.QueryStr(), // command line
                    NULL,                   // process security attributes
                    NULL,                   // thread security attributes
                    FALSE,                  // handle inheritance flag
                    CREATE_SUSPENDED | DETACHED_PROCESS,
                                            // creation flags
                    NULL,                   // environment block
                    GetWebAdminService()->GetCurrentDirectory(),
                                            // current directory name
                    &StartupInfo,           // STARTUPINFO
                    &ProcessInfo            // PROCESS_INFORMATION
                    );

    if ( ! Success )
    {

        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create process\n"
            ));

        //
        // if we could not create the process at all, then something
        // is just not right.  Tell the App Pool to shutdown so
        // we don't keep trying to get the process up.
        //
        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = m_pAppPool->GetAppPoolId();

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_FAILED_PROCESS_CREATION,        // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                       // error code
                );


        HRESULT hr2 = m_pAppPool->ProcessStateChangeCommand( MD_APPPOOL_COMMAND_STOP 
                                                           , FALSE );
        if ( FAILED (hr2) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr2,
                "Could not shutdown app pool\n"
                ));
        }

        goto exit;

    }


    m_ProcessId = ProcessInfo.dwProcessId;
    m_ProcessHandle = ProcessInfo.hProcess;


    m_ProcessAlive = TRUE;


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "New worker process created (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }

    //
    // If this worker process should be affinitized, do it now.
    //

    if ( m_ProcessAffinityMask )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Affinitizing new process with mask: %p\n",
                m_ProcessAffinityMask
                ));
        }


        Success = SetProcessAffinityMask(
                        m_ProcessHandle,        // handle to process
                        m_ProcessAffinityMask   // process affinity mask
                        );

        if ( ! Success )
        {

            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not set process affinity mask\n"
                ));

            goto exit;

        }

    }

    //
    // Before we let the process run, we need to add it to the Job Object
    //
    hr = m_pAppPool->AddWorkerProcessToJobObject( this );
    if ( FAILED ( hr ) )
    {
        //
        // AddWorkerProcessToJobObject ignores errors,
        // so if it fails, then this is a real problem.
        // Go ahead and let the error flow up.
        //

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not add worker process to job object\n"
            ));

        goto exit;
    }

    //
    // Let the process run.
    //
    // Note that ResumeThread returns 0xFFFFFFFF to signal an error, or
    // the previous suspend count otherwise (which should always be one
    // in this case).
    //

    ReturnCode = ResumeThread( ProcessInfo.hThread );

    if ( ReturnCode == 0xFFFFFFFF )
    {

        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not resume thread\n"
            ));

        goto exit;

    }
    else
    {
        DBG_ASSERT( ReturnCode == 1 );
    }


exit:


    if ( ProcessInfo.hThread != NULL )
    {
        DBG_REQUIRE( CloseHandle( ProcessInfo.hThread ) );
        ProcessInfo.hThread = NULL;
    }


    return hr;

}   // WORKER_PROCESS::StartProcess



/***************************************************************************++

Routine Description:

    Create the command line to pass to the worker process. It is of the
    form:
    "WorkerProcessExePath -a RegistationId [-r RestartRequestCount] [-t IdleTimeout] AppPoolId".

Arguments:

    pExeWithPath - The returned executable including it's path to launch.

    pCommandLineArgs - The arguments to be passed to the executable on launch.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CreateCommandLine(
    OUT STRU * pExeWithPath,
    OUT STRU * pCommandLineArgs
    )
{

    HRESULT hr = S_OK;
    ULONG PeriodicProcessRestartRequestCount = 0;
    ULONG IdleTimeoutInMinutes = 0;

    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);

    //
    // Buffer must be long enough to hold " -a [stringized registration id]".
    //
    WCHAR RegistrationIdSwitch[ 4 + MAX_STRINGIZED_ULONG_CHAR_COUNT + 1 ];

    //
    // Buffer must be long enough to hold " -r [stringized restart request count]".
    //
    WCHAR RestartRequestCountSwitch[ 4 + MAX_STRINGIZED_ULONG_CHAR_COUNT + 1 ];

    //
    // Buffer must be long enough to hold " -t [stringized idle timeout]".
    //
    WCHAR IdleTimoutSwitch[ 4 + MAX_STRINGIZED_ULONG_CHAR_COUNT + 1 ];


    DBG_ASSERT( pExeWithPath != NULL && pCommandLineArgs != NULL );


    //
    // Put in the path to the EXE.
    //

    hr = pExeWithPath->Append( GetWebAdminService()->GetCurrentDirectory() );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }

    //
    // Put in the EXE name.
    //

    if ( GetWebAdminService()->UseTestW3WP() )
    {
        hr = pExeWithPath->Append( WORKER_PROCESS_TEST_EXE_NAME );
    }
    else
    {
        hr = pExeWithPath->Append( WORKER_PROCESS_EXE_NAME );
    }

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }

    // 
    // Now also copy the file name into the arg list because that is what the system expects.
    //
    hr = pCommandLineArgs->Append( pExeWithPath->QueryStr() );
    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to exe into the variable failed\n"
            ));

        goto exit;
    }


    //
    // Pass the registration id.
    //

    _snwprintf( RegistrationIdSwitch, sizeof( RegistrationIdSwitch ) / sizeof ( WCHAR ), L" -a %lu", m_RegistrationId );


    hr = pCommandLineArgs->Append( RegistrationIdSwitch );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }


    //
    // If a periodic restart request count has been set (non-zero), then
    // put that information in the command line for the worker process.
    //

    PeriodicProcessRestartRequestCount = m_pAppPool->GetPeriodicProcessRestartRequestCount();

    if ( PeriodicProcessRestartRequestCount != 0 )
    {

        _snwprintf( RestartRequestCountSwitch, sizeof( RestartRequestCountSwitch ) / sizeof ( WCHAR ), L" -r %lu", PeriodicProcessRestartRequestCount );


        hr = pCommandLineArgs->Append( RestartRequestCountSwitch );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying to string failed\n"
                ));

            goto exit;
        }

    }


    //
    // If an idle timeout has been set (non-zero), then put that information
    // in the command line for the worker process.
    //

    IdleTimeoutInMinutes = m_pAppPool->GetIdleTimeoutInMinutes();

    if ( IdleTimeoutInMinutes != 0 )
    {

        _snwprintf( IdleTimoutSwitch, sizeof( IdleTimoutSwitch ) / sizeof ( WCHAR ), L" -t %lu", IdleTimeoutInMinutes );


        hr = pCommandLineArgs->Append( IdleTimoutSwitch );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying to string failed\n"
                ));

            goto exit;
        }

    }


    //
    // If worker process profiling is enabled, then add that switch to the 
    // command line.
    //

    if ( GetWebAdminService()->IsWorkerProcessProfilingEnabled() )
    {

        hr = pCommandLineArgs->Append( L" -p" );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Copying to string failed\n"
                ));

            goto exit;
        }

    }


    hr = pCommandLineArgs->Append( L" " );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }


    hr = pCommandLineArgs->Append( m_pAppPool->GetAppPoolId() );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Copying to string failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORKER_PROCESS::CreateCommandLine


/***************************************************************************++

Routine Description:

    Handle the fact that this worker process has become unhealthy. This
    means that the worker process should be replaced, but since its at
    least still limping, we won't shut it down until we have its replacement
    up and ready (or failed trying).

Arguments:

    UnhealthyReason - The reason the process is being declared unhealthy. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::MarkAsUnhealthy(
    IN WORKER_PROCESS_UNHEALTHY_REASON UnhealthyReason
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    // Flag if anything actually tries to use this.
    DBG_ASSERT(FALSE);

    //
    // CODEWORK: Nothing uses this right now. The intent is for things
    // like noticing that a worker process is using a huge amount of
    // memory, or a huge number of handles; it is sick, but we still 
    // might want to try to shut it down cleanly. 
    // Leave this support here, or remove?
    //


    //
    // If this instance is not in a healthy state to begin with, ignore
    // the new symptom of unhealthiness.
    //


    if ( m_Health != OkWorkerProcessHealthState )
    {
        goto exit;
    }


    m_Health = UnhealthyWorkerProcessHealthState;


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Marking worker process (ptr: %p; pid: %lu; realpid: %lu) as unhealthy; reason: %lu\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            UnhealthyReason
            ));
    }


    switch ( UnhealthyReason )
    {

    case NYI:
    default:

        //
        // Invalid state!
        //

        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        //
        // Press on, and try to initiate replacement.
        //

        break;

    }


    //
    // Request a replacement; this instance will be informed to
    // shut down in both the success or failure cases.
    //

    hr = InitiateReplacement();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Initiating process replacement failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORKER_PROCESS::MarkAsUnhealthy



/***************************************************************************++

Routine Description:

    Handle the fact that this worker process is a lost cause. Clean it up.
    It will get replaced eventually if needed via demand starting or other
    mechanisms implemented by the app pool.

Arguments:

    TerminalIllnessReason - The reason the process is being declared 
    terminally ill.
    
    ProcessExitCode - The process exit code, if applicable; zero otherwise.

    ErrorCode       - HResult showing the process is having problems.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::MarkAsTerminallyIll(
    IN WORKER_PROCESS_TERMINAL_ILLNESS_REASON TerminalIllnessReason,
    IN DWORD ProcessExitCode,
    IN HRESULT ErrorCode
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    // These are the only reasons that should be possible in BC mode.
    // If another reason fires, we will end up with the worker process 
    DBG_ASSERT ( !m_BackwardCompatibilityEnabled ||
                 TerminalIllnessReason == IPMErrorWorkerProcessTerminalIllnessReason ||
                 TerminalIllnessReason == StartupTookTooLongWorkerProcessTerminalIllnessReason ||
                 TerminalIllnessReason == InternalErrorWorkerProcessTerminalIllnessReason ||
                 TerminalIllnessReason == WorkerProcessPassedBadHresult );
    //
    // If we are already terminally ill, then don't do any more work here.
    //

    if ( m_Health == TerminallyIllWorkerProcessHealthState )
    {
        goto exit;
    }


    m_Health = TerminallyIllWorkerProcessHealthState;


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Marking worker process (ptr: %p; pid: %lu; realpid: %lu) as terminally ill; reason: %lu\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            TerminalIllnessReason
            ));
    }

    const WCHAR * EventLogStrings[3];
    WCHAR StringizedProcessId[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    WCHAR StringizedProcessExitCode[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    DWORD MessageId;

    _snwprintf( StringizedProcessId, sizeof( StringizedProcessId ) / sizeof ( WCHAR ), L"%lu", ( m_RegisteredProcessId ? m_RegisteredProcessId : m_ProcessId ) );
    _snwprintf( StringizedProcessExitCode, sizeof( StringizedProcessExitCode ) / sizeof ( WCHAR ), L"%x", ProcessExitCode );

    EventLogStrings[0] = m_pAppPool->GetAppPoolId();
    EventLogStrings[1] = StringizedProcessId;
    EventLogStrings[2] = StringizedProcessExitCode;


    switch ( TerminalIllnessReason )
    {

    case CrashWorkerProcessTerminalIllnessReason:

        MessageId = WAS_EVENT_WORKER_PROCESS_CRASH;
        break;

    case PingFailureProcessTerminalIllnessReason:

        MessageId = WAS_EVENT_WORKER_PROCESS_PING_FAILURE;
        break;

    case IPMErrorWorkerProcessTerminalIllnessReason:

        MessageId = WAS_EVENT_WORKER_PROCESS_IPM_ERROR;
        break;

    case StartupTookTooLongWorkerProcessTerminalIllnessReason:

        if ( ErrorCode == 0 )
        {
            ErrorCode = HRESULT_FROM_WIN32 ( ERROR_TIMEOUT );
        }

        MessageId = WAS_EVENT_WORKER_PROCESS_STARTUP_TIMEOUT;
        break;

    case ShutdownTookTooLongWorkerProcessTerminalIllnessReason:

        MessageId = WAS_EVENT_WORKER_PROCESS_SHUTDOWN_TIMEOUT;
        break;

    case InternalErrorWorkerProcessTerminalIllnessReason:

        MessageId = WAS_EVENT_WORKER_PROCESS_INTERNAL_ERROR;
        break;

    case WorkerProcessPassedBadHresult:

        MessageId = WAS_EVENT_WORKER_PROCESS_BAD_HRESULT;
        break;

    default:

        //
        // Invalid state!
        //

        MessageId = 0;

        DBG_ASSERT( FALSE );

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;

    }


    if ( MessageId != 0 )
    {

    GetWebAdminService()->GetEventLog()->
        LogEvent(
            MessageId,                              // message id
            sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                    // count of strings
            EventLogStrings,                        // array of strings
            ErrorCode                               // error code
            );
    }
 
    // 
    // If we are not in backward compatiblity mode
    // then report the worker process failure to the
    // app pool.
    //

    if ( !m_BackwardCompatibilityEnabled )
    {
        //
        // Report the failure to the app pool.
        //

        hr = m_pAppPool->ReportWorkerProcessFailure();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Reporting worker process failure failed\n"
                ));

            //
            // Press on even if we got an error here...
            //
        }
    }
    else  // in BC mode, determine if we should trigger a shutdown
          // and log the fact that we are shutting down to the
          // event viewer.
    {

        //
        // If it is an ipm disconnect, then we assume inetinfo crashed and the 
        // inetinfo monitor will decide what to do with the W3SVC.  If inetinfo
        // did not crash but some how the ipm disconnected, then we will be left
        // in a state with the W3WP shutdown but the W3SVC up.  However, this
        // is not expected to happen.  ( Discussed with BAlam, TaylorW, 
        // and BillKar on 3/29/00 ).
        //
        if ( TerminalIllnessReason != IPMErrorWorkerProcessTerminalIllnessReason ||
             ( ( ErrorCode != HRESULT_FROM_WIN32( ERROR_BROKEN_PIPE ) ) &&
               ( ErrorCode != HRESULT_FROM_NT ( STATUS_PIPE_BROKEN ) ) ) )
        {
            //
            // Log an event declaring we are shutting down the 
            // W3SVC because of a failure with the worker process
            // currently running in inetinfo.
            //
            IF_DEBUG( WEB_ADMIN_SERVICE_GENERAL )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Shutting down service due to failure in WP in inetinfo\n"
                    ));
            }

            //
            // Log an event: worker process failure shutting down the server.
            //

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_WP_FAILURE_BC,     // message id
                    0,                           // count of strings
                    NULL,                        // array of strings
                    0                            // error code
                    );

            // 
            // Tell the service to shutdown.
            //

            DBG_REQUIRE ( GetWebAdminService()->RequestStopService(FALSE) == S_OK );

            // Tell WAS what to tell the SCM when we shutdown.
            GetWebAdminService()->SetHrToReportToSCM( ErrorCode );

        }  // End of shutting down the service

    } // end of bc mode worker process failure handling.

    //
    // Clean this baby up.
    //

    Terminate();

exit:

    return hr;

}   // WORKER_PROCESS::MarkAsTerminallyIll



/***************************************************************************++

Routine Description:

    Immediately terminate the actual process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::KillProcess(
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    DBG_ASSERT( m_ProcessAlive );
    DBG_ASSERT( m_ProcessHandle != NULL );
    DBG_ASSERT( m_ProcessId != INVALID_PROCESS_ID );


    //
    // If this worker process is to be killed because it is terminally ill, 
    // and orphaning is enabled, then orphan the process. However, if it
    // is being killed for other reasons (say, fatal error service shutdown),
    // or if orphaning is not enabled, then actually kill the process. 
    //

    if ( ( m_Health == TerminallyIllWorkerProcessHealthState ) && m_pAppPool->IsOrphaningProcessesForDebuggingEnabled() )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "ORPHANING worker process instead of terminating (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        hr = RunOrphanAction();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Running orphan action failed\n"
                ));

            //
            // Not considered fatal if the orphan action failed to run. 
            //

            hr = S_OK;

        }

    }
    else
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Terminating worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }

        Success = TerminateProcess(
                        m_ProcessHandle,                // handle of process to terminate
                        KILLED_WORKER_PROCESS_EXIT_CODE // exit code for the process
                        );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Terminating process failed\n"
                ));


            //
            // This can potentially fail if the process died by some other
            // means before we got a chance to kill it; therefore, we
            // continue on without considering this a fatal error.
            //

            hr = S_OK;
        }

    }


    //
    // The process as gone (at least as far as we're concerned).
    //

    m_ProcessAlive = FALSE;

    //
    // Note: we don't want to clear m_ProcessHandle or m_ProcessId;
    // see the comment at the declaration of m_ProcessAlive in the
    // header file.
    //


    return hr;

}   // WORKER_PROCESS::KillProcess



/***************************************************************************++

Routine Description:

    Perform the configured action (if any) on the orphaned process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::RunOrphanAction(
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
    UNICODE_STRING Unformatted;
    UNICODE_STRING Formatted;
    WCHAR Environment[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
    NTSTATUS Status = STATUS_SUCCESS;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;

    DBG_ASSERT ( CheckSignature() );


    RtlInitUnicodeString( &Unformatted, NULL );
    RtlInitUnicodeString( &Formatted, NULL );


    //
    // If no orphan action is configured, then we're done.
    //

    if ( ( m_pAppPool->GetOrphanAction() == NULL ) ||
         ( _wcsicmp( m_pAppPool->GetOrphanAction(), L"" ) == 0 ) )
    {
        goto exit;
    }


    //
    // Expand the orphan action by stuffing in the process id of the orphaned
    // process. Any %1% sequences in the orphan action are replaced. Note that
    // that sequence does not need to be present.
    //
    // Note that FormatMessage(), _snwprintf(), etc. all are not suitable for
    // this task, because they can spew garbage or AV if the orphan action
    // contains unexpected formatting commands.
    //

    //
    // CODEWORK It might be nice to match the semantics of AeDebug, in terms
    // of using sprintf formatting sequences like %ld to mark replacements, 
    // instead of %1%. However, that would likely require writing our own 
    // replacement function. Could be done if needed, though. As it is, we
    // match the SCM service failure action semantics for replacements.
    //

    RtlInitUnicodeString( &Unformatted, m_pAppPool->GetOrphanAction() );

    Formatted.Length = 0;
    Formatted.MaximumLength = Unformatted.MaximumLength + 256;

    Formatted.Buffer = ( LPWSTR )GlobalAlloc( GMEM_FIXED, Formatted.MaximumLength );

    if ( Formatted.Buffer == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }


    //
    // Set up an environment block with just the one expansion we want, namely
    // that %1% expands to the process id of the orphaned worker process.
    //

    _snwprintf( 
        Environment, 
        sizeof( Environment ) / sizeof ( WCHAR ), 
        L"1=%lu%c", 
        ( m_RegisteredProcessId ? m_RegisteredProcessId : m_ProcessId ), 
        L'\0'
        );


    Status = RtlExpandEnvironmentStrings_U(
                    Environment,
                    &Unformatted,
                    &Formatted,
                    NULL
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not expand environment strings\n"
            ));

        goto exit;
    }


    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );

    ZeroMemory( &ProcessInfo, sizeof( ProcessInfo ) );


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Running orphan action on worker process (ptr: %p; pid: %lu; realpid: %lu): '%S'\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId,
            Formatted.Buffer
            ));
    }


    //
    // Run the command. We pass CREATE_NEW_CONSOLE to make sure that
    // if a batch file is specified, it has a console in which to execute.
    //

    //
    // CODEWORK For now, we always run the command in the account that 
    // WAS is running under (typically LocalSystem). This is probably 
    // ok for the usage patterns we envision. If desired, if we implement
    // per-apppool accounts to run under, we could use that same
    // account to run the action under too. 
    //

    Success = CreateProcess(
                    NULL,                   // program name
                    Formatted.Buffer,       // command line
                    NULL,                   // process security attributes
                    NULL,                   // thread security attributes
                    FALSE,                  // handle inheritance flag
                    CREATE_NEW_CONSOLE,     // creation flags
                    NULL,                   // environment block
                    NULL,                   // current directory name
                    &StartupInfo,           // STARTUPINFO
                    &ProcessInfo            // PROCESS_INFORMATION
                    );

    if ( ! Success )
    {

        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not run orphan action\n"
            ));

        goto exit;

    }


    DBG_REQUIRE( CloseHandle( ProcessInfo.hThread ) );
    DBG_REQUIRE( CloseHandle( ProcessInfo.hProcess ) );


exit:

    if ( FAILED( hr ) )
    {

        //
        // Log an event: Running orphan action failed.
        //

        const WCHAR * EventLogStrings[2];

        EventLogStrings[0] = m_pAppPool->GetAppPoolId();
        EventLogStrings[1] = ( Formatted.Buffer != NULL ? Formatted.Buffer : L"" );

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_ORPHAN_ACTION_FAILED,         // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                hr                                      // error code
                );

    }


    if ( Formatted.Buffer != NULL )
    {
        DBG_REQUIRE( GlobalFree( Formatted.Buffer ) == NULL );
        Formatted.Buffer = NULL;
    }


    return hr;

}   // WORKER_PROCESS::RunOrphanAction


/***************************************************************************++

Routine Description:

    Initiate clean shutdown by sending the shutdown message to the worker
    process, and starting the timer to ensure it shuts down in time.
    Note that if starting clean shutdown fails, the method will go ahead
    and Terminate() the instance.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::InitiateProcessShutdown(
    BOOL ShutdownImmediately
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    //
    // We should never request a worker process shutdown, unless we are in 
    // FC mode, or if the W3SVC is stopping.
    //
    DBG_ASSERT ( !m_BackwardCompatibilityEnabled ||
                 GetWebAdminService()->GetServiceState() == SERVICE_STOP_PENDING );

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Beginning shutdown for worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    //
    // Tell the worker process to shut down.
    //

    m_State = ShutdownPendingWorkerProcessState;

    hr = m_MessagingHandler.SendShutdown( ShutdownImmediately );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Sending shutdown message failed\n"
            ));

        goto exit;
    }


    if ( !m_BackwardCompatibilityEnabled )
    {
        hr = BeginShutdownTimer( m_pAppPool->GetShutdownTimeLimitInSeconds() 
                                 * ONE_SECOND_IN_MILLISECONDS );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Beginning worker process shutdown timer failed\n"
                ));

            goto exit;
        }
    }


exit:

    return hr;

}   // WORKER_PROCESS::InitiateProcessShutdown



/***************************************************************************++

Routine Description:

    Set up a wait on the handle of the worker process, so that we will know
    if it crashes or otherwise goes away.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::RegisterProcessWait(
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    DBG_ASSERT( m_ProcessWaitHandle == NULL );


    Status = RtlRegisterWait(
                    &m_ProcessWaitHandle,       // returned wait handle
                    m_ProcessHandle,            // handle to wait on
                    &ProcessHandleSignaledCallback,
                                                // callback function
                    this,                       // context
                    INFINITE,                   // no timeout on wait
                    WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD
                                                // call once, in wait thread
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not register wait on process handle\n"
            ));

    }


    return hr;

}   // WORKER_PROCESS::RegisterProcessWait



/***************************************************************************++

Routine Description:

    Tear down the wait on the handle of the worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::DeregisterProcessWait(
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    if ( m_ProcessWaitHandle != NULL )
    {

        Status = RtlDeregisterWaitEx(
                        m_ProcessWaitHandle,    // handle of wait to cancel
                        ( HANDLE ) -1           // block until callbacks finish
                        );

        if ( ! NT_SUCCESS ( Status ) )
        {
            hr = HRESULT_FROM_NT( Status );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Could not de-register wait on process handle\n"
                ));

            goto exit;
        }

        m_ProcessWaitHandle = NULL;

    }


exit:

    return hr;

}   // WORKER_PROCESS::DeregisterProcessWait



/***************************************************************************++

Routine Description:

    This routine is called when the process handle has been signaled. This
    means the worker process went away, via a crash or otherwise. Therefore,
    clean up appropriately.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ProcessHandleSignaledWorkItem(
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    DWORD ProcessExitCode = 0;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Process handle has been signaled (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    m_ProcessAlive = FALSE;


    //
    // There are several reasons the process may have exited:
    // 1) The WAS may have killed it. If so, the exit code from the
    // process is the sentinel value that means it was killed.
    // 2) It may have correctly shut down as requested. To detect
    // this, we check if shutdown is pending, and if so, if the exit
    // code from the process is the sentinel value that means it was
    // a clean exit.
    // 3) It may have died on it's own (crash, termination on error,
    // etc.).
    //


    Success = GetExitCodeProcess(
                    m_ProcessHandle,    // process handle
                    &ProcessExitCode    // returned process exit code
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Getting process exit code failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Process exit code was: %x\n",
            ProcessExitCode
            ));
    }


    if ( ProcessExitCode == KILLED_WORKER_PROCESS_EXIT_CODE )
    {

        //
        // We killed it; take no further action here.
        //

        //
        // Sanity check: we should only have killed the worker process
        // as part of Terminate(), and so we should be in the delete
        // pending state.
        //
        // Potentially the worker process could incorrectly return this
        // error code, so in retail builds make sure we at least clean
        // up.
        //

        DBG_ASSERT( m_State == DeletePendingWorkerProcessState );

        if ( m_State != DeletePendingWorkerProcessState )
        {
            hr = MarkAsTerminallyIll( CrashWorkerProcessTerminalIllnessReason, ProcessExitCode, 0 );

            if ( FAILED( hr ) )
            {

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Marking worker process as terminally ill failed\n"
                    ));

            }

        }


        goto exit;

    }
    else if ( ( m_State == ShutdownPendingWorkerProcessState ) &&
              ( ProcessExitCode == CLEAN_WORKER_PROCESS_EXIT_CODE ) )
    {

        //
        // It shut down correctly as requested. Now we can clean up
        // this instance.
        //
        // Note that the shutdown timer will be cancelled in the
        // Terminate() method.
        //

        Terminate();

    }
    else
    {

        //
        // The worker process must have crashed, exited due to error,
        // or otherwise misbehaved.
        //


        hr = MarkAsTerminallyIll( CrashWorkerProcessTerminalIllnessReason, ProcessExitCode, 0 );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Marking worker process as terminally ill failed\n"
                ));

            goto exit;
        }

    }


exit:

    return hr;

}   // WORKER_PROCESS::ProcessHandleSignaledWorkItem



/***************************************************************************++

Routine Description:

    If the worker process has taken too long to start up, then
    deal with it accordingly.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::StartupTimerExpiredWorkItem(
    )
{

    HRESULT hr = S_OK;
    //
    // See if we are still in a startup pending state.
    // If we are, then the worker process has taken too long. If not, then
    // either the state transition completed just as the timer expired, and
    // we should ignore this; or something else has happened to change the
    // state (for example, a crash), in which case we also ignore this.
    //

    DBG_ASSERT ( CheckSignature() );

    if ( ( m_State == RegistrationPendingWorkerProcessState ) ||
         ( m_State == RegistrationPendingShutdownPendingWorkerProcessState ) )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process has taken too long to start up (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        hr = MarkAsTerminallyIll( StartupTookTooLongWorkerProcessTerminalIllnessReason, 0, 0 );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Marking as terminally ill failed\n"
                ));

        }

    }


    return hr;

}   // WORKER_PROCESS::StartupTimerExpiredWorkItem



/***************************************************************************++

Routine Description:

    If the worker process has taken too long to shut down, then
    deal with it accordingly.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::ShutdownTimerExpiredWorkItem(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );


    //
    // See if we are still in a shutdown pending state.
    // If we are, then the worker process has taken too long. If not, then
    // either the state transition completed just as the timer expired, and
    // we should ignore this; or something else has happened to change the
    // state (for example, a crash), in which case we also ignore this.
    //

    if ( m_State == ShutdownPendingWorkerProcessState ) 
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process has taken too long to shut down (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        hr = MarkAsTerminallyIll( ShutdownTookTooLongWorkerProcessTerminalIllnessReason, 0, 0 );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Marking as terminally ill failed\n"
                ));

        }

    }


    return hr;

}   // WORKER_PROCESS::ShutdownTimerExpiredWorkItem



/***************************************************************************++

Routine Description:

    Based on periodic restart configuration, it's time to replace this
    process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::PeriodicRestartTimerWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);

    //
    // Only follow through on the periodic process replacement if we are
    // currently in the running state.
    //

    if ( m_State == RunningWorkerProcessState )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Starting periodic process replacement (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        //
        // Request a replacement; this instance will be informed to
        // shut down in both the success and failure cases.
        //

        hr = InitiateReplacement();

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Initiating process replacement failed\n"
                ));

            goto exit;
        }

    }


exit:

    return hr;

}   // WORKER_PROCESS::PeriodicRestartTimerWorkItem



/***************************************************************************++

Routine Description:

    Initiate a ping to the worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::SendPingWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    //
    // Clean up the timer that got us here.
    //

    hr = CancelSendPingTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling send ping timer failed\n"
            ));

        goto exit;
    }


    //
    // Only start a ping if we are currently in the running state.
    //

    if ( m_State != RunningWorkerProcessState )
    {
        goto exit;
    }


    DBG_ASSERT( ! m_AwaitingPingReply );


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Pinging worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            this,
            m_ProcessId,
            m_RegisteredProcessId
            ));
    }


    //
    // Send the ping message via IPM.
    //

    hr = m_MessagingHandler.SendPing();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Sending ping message failed\n"
            ));

        goto exit;
    }


    m_AwaitingPingReply = TRUE;


    //
    // Make sure the worker process responds in a timely manner.
    //

    hr = BeginPingResponseTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Starting ping response timer failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORKER_PROCESS::SendPingWorkItem



/***************************************************************************++

Routine Description:

    Handle the fact that the worker process has not responded to the ping
    within the time allowed.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::PingResponseTimerExpiredWorkItem(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);
    //
    // Clean up the timer that got us here.
    //

    hr = CancelPingResponseTimer();

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Canceling ping response timer failed\n"
            ));

        goto exit;
    }


    //
    // If we aren't currently in the running state, then ignore the fact
    // that this timer expired. We may already be in the midst of shutting
    // down.
    //

    if ( m_State != RunningWorkerProcessState )
    {
        goto exit;
    }


    //
    // If we are still awaiting a reply, then the worker process hasn't
    // responded in a timely manner.
    //

    if ( m_AwaitingPingReply )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_WP )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Worker process has not responded to ping within time limit (ptr: %p; pid: %lu; realpid: %lu)\n",
                this,
                m_ProcessId,
                m_RegisteredProcessId
                ));
        }


        hr = MarkAsTerminallyIll( PingFailureProcessTerminalIllnessReason, 0, 0 );

        if ( FAILED( hr ) )
        {

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Marking worker process as terminally ill failed\n"
                ));

            goto exit;
        }

    }


exit:

    return hr;

}   // WORKER_PROCESS::PingResponseTimerExpiredWorkItem



/***************************************************************************++

Routine Description:

    Start the timer which ensures that process initialization happens in
    a timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginStartupTimer(
    )
{

    //
    // Record when startup wait began.
    //

    DBG_ASSERT ( CheckSignature() );

    m_StartupBeganTickCount = GetTickCount();


    return BeginTimer(
                &m_StartupTimerHandle,                  // timer handle
                &StartupTimerExpiredCallback,           // callback
                m_pAppPool->GetStartupTimeLimitInSeconds() * ONE_SECOND_IN_MILLISECONDS
                                                        // fire time
                );

}   // WORKER_PROCESS::BeginStartupTimer



/***************************************************************************++

Routine Description:

    Stop the timer which ensures that process initialization happens in
    a timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelStartupTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );

    if ( m_StartupTimerHandle != NULL )
    {

        //
        // If we really are cancelling the timer, determine the elapsed time.
        //
        // Note that tick counts are in milliseconds. Tick counts roll over 
        // every 49.7 days, but the arithmetic operation works correctly 
        // anyways in this case.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Cancelling startup timer; response time was: %lu milliseconds\n",
                GetTickCount() - m_StartupBeganTickCount
                ));
        }

    }


    return CancelTimer( &m_StartupTimerHandle );

}   // WORKER_PROCESS::CancelStartupTimer



/***************************************************************************++

Routine Description:

    Start the timer which ensures that process shutdown happens in a
    timely manner.

Arguments:

    ShutdownTimeLimitInMilliseconds - Number of milliseconds that this 
    worker process has in which to complete clean shutdown. If this time 
    is exceeded, the worker process will be terminated. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginShutdownTimer(
    IN ULONG ShutdownTimeLimitInMilliseconds
    )
{

    //
    // Record when shutdown wait began.
    //

    DBG_ASSERT ( CheckSignature() );


    m_ShutdownBeganTickCount = GetTickCount();


    return BeginTimer(
                &m_ShutdownTimerHandle,                 // timer handle
                &ShutdownTimerExpiredCallback,          // callback
                ShutdownTimeLimitInMilliseconds         // fire time
                );

}   // WORKER_PROCESS::BeginShutdownTimer



/***************************************************************************++

Routine Description:

    Stop the timer which ensures that process shutdown happens in a
    timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelShutdownTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );

    if ( m_ShutdownTimerHandle != NULL )
    {

        //
        // If we really are cancelling the timer, determine the elapsed time.
        //
        // Note that tick counts are in milliseconds. Tick counts roll over 
        // every 49.7 days, but the arithmetic operation works correctly 
        // anyways in this case.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Cancelling shutdown timer; response time was: %lu milliseconds\n",
                GetTickCount() - m_ShutdownBeganTickCount
                ));
        }

    }


    return CancelTimer( &m_ShutdownTimerHandle );

}   // WORKER_PROCESS::CancelShutdownTimer



/***************************************************************************++

Routine Description:

    Start the timer used for periodic process restarts.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginPeriodicRestartTimer(
    )
{

    HRESULT hr = S_OK;
    ULONG PeriodicProcessRestartPeriodInMinutes = 0;
    ULONG PeriodicProcessRestartPeriodInMilliseconds = 0;

    DBG_ASSERT ( CheckSignature() );

    PeriodicProcessRestartPeriodInMinutes = m_pAppPool->GetPeriodicProcessRestartPeriodInMinutes();


    // Don't start the Restart timer if we are in backward compatibility mode.
    if ( PeriodicProcessRestartPeriodInMinutes == 0 
        || m_BackwardCompatibilityEnabled)
    {
        //
        // If the period is set to zero, the feature has been disabled.
        //

        goto exit;
    }


    if ( PeriodicProcessRestartPeriodInMinutes > MAX_MINUTES_IN_ULONG_OF_MILLISECONDS )
    {
        PeriodicProcessRestartPeriodInMinutes = MAX_MINUTES_IN_ULONG_OF_MILLISECONDS;
    }


    PeriodicProcessRestartPeriodInMilliseconds =
        PeriodicProcessRestartPeriodInMinutes * SECONDS_PER_MINUTE * ONE_SECOND_IN_MILLISECONDS;


    hr = BeginTimer(
                &m_PeriodicRestartTimerHandle,              // timer handle
                &PeriodicRestartTimerCallback,              // callback
                PeriodicProcessRestartPeriodInMilliseconds  // fire time
                );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating periodic restart timer failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORKER_PROCESS::BeginPeriodicRestartTimer



/***************************************************************************++

Routine Description:

    Stop the timer used for periodic process restarts.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelPeriodicRestartTimer(
    )
{
    DBG_ASSERT ( CheckSignature() );

    return CancelTimer( &m_PeriodicRestartTimerHandle );

}   // WORKER_PROCESS::CancelPeriodicRestartTimer



/***************************************************************************++

Routine Description:

    Start the timer which tells us when to initiate a ping to the worker
    process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginSendPingTimer(
    )
{

    HRESULT hr = S_OK;

    DBG_ASSERT ( CheckSignature() );

    //
    // Only start the ping timer if pinging is enabled.
    // It is not enabled if we are in backward compatible mode.
    //

    if ( ! m_pAppPool->IsPingingEnabled() 
        || m_BackwardCompatibilityEnabled)
    {
        goto exit;
    }


    return BeginTimer(
                &m_SendPingTimerHandle,                 // timer handle
                &SendPingTimerCallback,                 // callback
                m_pAppPool->GetPingIntervalInSeconds() * ONE_SECOND_IN_MILLISECONDS
                                                        // fire time
                );


exit:

    return hr;

}   // WORKER_PROCESS::BeginSendPingTimer



/***************************************************************************++

Routine Description:

    Stop the timer which tells us when to initiate a ping to the worker
    process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelSendPingTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );

    return CancelTimer( &m_SendPingTimerHandle );

}   // WORKER_PROCESS::CancelSendPingTimer



/***************************************************************************++

Routine Description:

    Start the timer which ensures that a ping response arrives in a
    timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginPingResponseTimer(
    )
{

    //
    // Record when the ping response wait began.
    //

    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT(!m_BackwardCompatibilityEnabled);

    m_PingBeganTickCount = GetTickCount();


    return BeginTimer(
                &m_PingResponseTimerHandle,             // timer handle
                &PingResponseTimerExpiredCallback,      // callback
                m_pAppPool->GetPingResponseTimeLimitInSeconds() * ONE_SECOND_IN_MILLISECONDS
                                                        // fire time
                );

}   // WORKER_PROCESS::BeginPingResponseTimer



/***************************************************************************++

Routine Description:

    Stop the timer which ensures that a ping response arrives in a
    timely manner.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelPingResponseTimer(
    )
{

    DBG_ASSERT ( CheckSignature() );

    if ( m_PingResponseTimerHandle != NULL )
    {

        //
        // If we really are cancelling the timer, determine the elapsed time.
        //
        // Note that tick counts are in milliseconds. Tick counts roll over 
        // every 49.7 days, but the arithmetic operation works correctly 
        // anyways in this case.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Cancelling ping response timer; response time was: %lu milliseconds\n",
                GetTickCount() - m_PingBeganTickCount
                ));
        }

    }


    return CancelTimer( &m_PingResponseTimerHandle );

}   // WORKER_PROCESS::CancelPingResponseTimer



/***************************************************************************++

Routine Description:

    Start one of the built in timers.

Arguments:

    pTimerHandle - Address of the timer handle to start.

    pCallbackFunction - Function to call when the timer fires.

    InitialFiringTime - Time in milliseconds before firing the timer.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::BeginTimer(
    IN OUT HANDLE * pTimerHandle,
    IN WAITORTIMERCALLBACKFUNC pCallbackFunction,
    IN ULONG InitialFiringTime
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT ( CheckSignature() );


    DBG_ASSERT( pTimerHandle != NULL );
    DBG_ASSERT( pCallbackFunction != NULL );
    DBG_ASSERT( InitialFiringTime > 0 );


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );

    DBG_ASSERT( *pTimerHandle == NULL );


    Status = RtlCreateTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                                // timer queue
                    pTimerHandle,               // returned timer handle
                    pCallbackFunction,          // callback function
                    this,                       // context
                    InitialFiringTime,          // initial firing time
                    0,                          // subsequent firing period
                    WT_EXECUTEINWAITTHREAD      // execute callback directly
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not create timer\n"
            ));

    }


    return hr;

}   // WORKER_PROCESS::BeginTimer



/***************************************************************************++

Routine Description:

    Stop one of the built in timers.

Arguments:

    pTimerHandle - Address of the timer handle to stop.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORKER_PROCESS::CancelTimer(
    IN OUT HANDLE * pTimerHandle
    )
{

    HRESULT hr = S_OK;
    NTSTATUS Status = STATUS_SUCCESS;


    DBG_ASSERT ( CheckSignature() );

    DBG_ASSERT( pTimerHandle != NULL );


    DBG_ASSERT( GetWebAdminService()->GetSharedTimerQueue() != NULL );


    //
    // If the timer is not present, we're done here.
    //

    if ( *pTimerHandle == NULL )
    {
        goto exit;
    }


    //
    // Note that we wait for any running timer callbacks to finish.
    // Otherwise, there could be a race where the callback runs after
    // this worker process instance has been deleted, and so gives out
    // a bad pointer.
    //

    Status = RtlDeleteTimer(
                    GetWebAdminService()->GetSharedTimerQueue(),
                                            // the owning timer queue
                    *pTimerHandle,          // timer to cancel
                    ( HANDLE ) -1           // wait for callbacks to finish
                    );

    if ( ! NT_SUCCESS ( Status ) )
    {
        hr = HRESULT_FROM_NT( Status );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Could not cancel timer\n"
            ));

        goto exit;
    }

    *pTimerHandle = NULL;


exit:

    return hr;

}   // WORKER_PROCESS::CancelTimer



/***************************************************************************++

Routine Description:

    Deal with a failure internal to this worker process instance by marking
    this instance as terminally ill.

    Note: this method should be called in the case of failure at the end of
    all HRESULT-returning public methods of this class!!!

Arguments:

    Error - The failed HRESULT.

Return Value:

    None.

--***************************************************************************/

VOID
WORKER_PROCESS::DealWithInternalWorkerProcessFailure(
    IN HRESULT Error
    )
{

    DBG_ASSERT ( CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Internal WORKER_PROCESS error; marking as terminally ill: %lu\n",
            Error
            ));
    }


    //
    // If we had a failure bubble to here (which is shouldn't in "normal"
    // scenarios) then mark this instance as terminally ill. This will
    // terminate this instance.
    //

    DBG_REQUIRE( SUCCEEDED( MarkAsTerminallyIll( InternalErrorWorkerProcessTerminalIllnessReason, 0, Error ) ) );


    return;

}   // WORKER_PROCESS::DealWithInternalWorkerProcessFailure


/***************************************************************************++

Routine Description:

    Send process recycler related parameters to worker process.


Arguments:

    pWhatHasChanged - bit array of changed properties. If is is NULL then all the
    configuration values will be sent. If not then only those parameters will 
    be sent that have changed

    m_pAppPool will be used to retrieve the AppPool configuration values


Return Value:

    HRESULT

--***************************************************************************/


HRESULT
WORKER_PROCESS::SendWorkerProcessRecyclerParameters(
    IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged
)
{
    HRESULT hr  = S_OK;

    DBG_ASSERT ( CheckSignature() );

    if( m_BackwardCompatibilityEnabled )
    {
        //
        // Do not do anything in backward compatibily mode
        // recycling applies only to new process mode
        //
        return NO_ERROR;
    }

    //
    // m_pAppPool must be valid when in new process mode
    //
    DBG_ASSERT( m_pAppPool != NULL );

    if ( pWhatHasChanged == NULL ||
         pWhatHasChanged->PeriodicProcessRestartPeriodInMinutes ) 
    {
        DWORD PeriodicProcessRestartPeriodInMinutes = 
                m_pAppPool->GetPeriodicProcessRestartPeriodInMinutes();
                
        hr = m_MessagingHandler.SendPeriodicProcessRestartPeriodInMinutes(
                PeriodicProcessRestartPeriodInMinutes
                );
                
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Executing m_MessagingHandler.SendPeriodicProcessRestartPeriodInMinutes() failed\n"
            ));
        }
    }

    if ( pWhatHasChanged == NULL ||
         pWhatHasChanged->PeriodicProcessRestartRequestCount ) 
    {
        DWORD PeriodicProcessRestartRequestCount = 
                m_pAppPool->GetPeriodicProcessRestartRequestCount();
                
        hr = m_MessagingHandler.SendPeriodicProcessRestartRequestCount(
                PeriodicProcessRestartRequestCount
                );
                                
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Executing m_MessagingHandler.SendPeriodicProcessRestartRequestCount() failed\n"
            ));
        }

    }

    if ( pWhatHasChanged == NULL ||
         pWhatHasChanged->pPeriodicProcessRestartSchedule ) 
    {
        LPWSTR pPeriodicProcessRestartSchedule = 
                m_pAppPool->GetPeriodicProcessRestartSchedule();
                
        hr = m_MessagingHandler.SendPeriodicProcessRestartSchedule(
                pPeriodicProcessRestartSchedule
                );
                                
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Executing m_MessagingHandler.SendPeriodicProcessRestartSchedule() failed\n"
            ));
        }

    }

    if ( pWhatHasChanged == NULL ||
         pWhatHasChanged->PeriodicProcessRestartMemoryUsageInKB ) 
    {
        DWORD PeriodicProcessRestartMemoryUsageInKB = 
                m_pAppPool->GetPeriodicProcessRestartMemoryUsageInKB();
                
        hr = m_MessagingHandler.SendPeriodicProcessRestartMemoryUsageInKB(
                PeriodicProcessRestartMemoryUsageInKB
                );
                                
        if ( FAILED( hr ) )
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Executing m_MessagingHandler.SendPeriodicProcessRestartMemoryUsageInKB() failed\n"
            ));
        }
    }

    //
    // CODEWORK this function may want to handle errors differently
    // Right now any error while sending recycler related parameters
    // to worker process will be ignored
    //

    return S_OK;
} //WORKER_PROCESS::SendWorkerProcessRecyclerParameters


/***************************************************************************++

Routine Description:

    The callback function invoked by the startup timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
StartupTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for startup timer expired on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        StartupTimerExpiredWorkerProcessWorkItem
        );


    return;

}   // StartupTimerExpiredCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the shutdown timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
ShutdownTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for shutdown timer expired on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        ShutdownTimerExpiredWorkerProcessWorkItem
        );


    return;

}   // ShutdownTimerExpiredCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the periodic restart timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
PeriodicRestartTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for periodic restart timer on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        PeriodicRestartTimerWorkerProcessWorkItem
        );


    return;

}   // PeriodicRestartTimerCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the send ping timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
SendPingTimerCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for ping timer on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        SendPingWorkerProcessWorkItem
        );


    return;

}   // SendPingTimerCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the  ping response timer. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
PingResponseTimerExpiredCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for ping response timer on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        PingResponseTimerExpiredWorkerProcessWorkItem
        );


    return;

}   // PingResponseTimerExpiredCallback



/***************************************************************************++

Routine Description:

    The callback function invoked by the process handle wait. It simply
    posts a work item for the main worker thread.

Arguments:

    Context - A context value, used to pass the "this" pointer of the
    WORKER_PROCESS object in question.

    Ignored - Ignored.

Return Value:

    None.

--***************************************************************************/

VOID
ProcessHandleSignaledCallback(
    IN PVOID Context,
    IN BOOLEAN Ignored
    )
{

    UNREFERENCED_PARAMETER( Ignored );

    DBG_ASSERT ( Context != NULL );

    WORKER_PROCESS* pWorkerProcess = reinterpret_cast<WORKER_PROCESS*>( Context );
    
    DBG_ASSERT ( pWorkerProcess->CheckSignature() );

    IF_DEBUG( WEB_ADMIN_SERVICE_WP )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "About to create/queue work item for process handle signaled on worker process (ptr: %p; pid: %lu; realpid: %lu)\n",
            pWorkerProcess,
            pWorkerProcess->GetProcessId(),
            pWorkerProcess->GetRegisteredProcessId()
            ));
    }


    QueueWorkItemFromSecondaryThread(
        reinterpret_cast<WORK_DISPATCH*>( Context ),
        ProcessHandleSignaledWorkerProcessWorkItem
        );


    return;

}   // ProcessHandleSignaledCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\work_queue.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    work_queue.cxx

Abstract:

    The IIS web admin service work queue class implementation. The queue is 
    simply a completion port which is managed by this class. Work may be 
    put on the queue either by associating a handle with this port, in 
    which case the handle's asynchronous i/o operations will complete here, 
    or by explicitly posting work items.

    All work on the queue is serviced by the one main worker thread. This 
    prevents a number of race conditions, and allows us to avoid taking locks 
    around state which is only accessed on this thread. It means however that 
    all "interesting" work in the web admin service must be packaged as work 
    items, i.e. classes which implement the WORK_DISPATCH interface. If a 
    different thread has work to do, it must queue it as a work item so that
    it will be executed on the main worker thread.
    
    Furthermore, these work items cannot do long-running operations, as 
    that would block other work in the queue. Instead, an asynchronous 
    approach (posting more work items later) must be taken for such 
    long-running tasks.

    Threading: Work can be enqueued from any thread. However, the main 
    worker thread is the only one who processes work items.

Author:

    Seth Pollack (sethp)        25-Aug-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the WORK_QUEUE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_QUEUE::WORK_QUEUE(
    )
    :
    m_DispenseWorkItemLock()
{

    m_CompletionPort = NULL;

    m_DeletePending = FALSE;

    m_CountWorkItemsOutstanding = 0;


#if DBG
    InitializeListHead( &m_WorkItemsOutstandingListHead );

    m_CountWorkItemsGivenOut = 0;
#endif  // DBG

    m_Signature = WORK_QUEUE_SIGNATURE;

}   // WORK_QUEUE::WORK_QUEUE



/***************************************************************************++

Routine Description:

    Destructor for the WORK_QUEUE class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

WORK_QUEUE::~WORK_QUEUE(
    )
{

    DBG_ASSERT( m_Signature == WORK_QUEUE_SIGNATURE );

    m_Signature = WORK_QUEUE_SIGNATURE_FREED;


    // verify that we have processed all outstanding work items
    DBG_ASSERT( m_CountWorkItemsOutstanding == 0 );


#if DBG
    DBG_ASSERT( IsListEmpty( &m_WorkItemsOutstandingListHead ) );
#endif  // DBG


    if ( m_CompletionPort != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_CompletionPort ) );
        m_CompletionPort = NULL;
    }


    m_DispenseWorkItemLock.Terminate();

}   // WORK_QUEUE::~WORK_QUEUE



/***************************************************************************++

Routine Description:

    Initialize the work queue by creating the i/o completion port.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::Initialize(
    )
{

    HRESULT hr = S_OK;


    //
    // Initialize the lock.
    //

    hr = m_DispenseWorkItemLock.Initialize();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Lock initialization failed\n"
            ));

        goto exit;
    }


    //
    // Create a new completion port.
    //
    // Note that we will only have the one main worker thread service this 
    // port, so the parameter passed here for the number of concurrent threads 
    // is unimportant.
    //
    
    m_CompletionPort = CreateIoCompletionPort(
                            INVALID_HANDLE_VALUE,   // file handle to associate
                            NULL,                   // existing completion port
                            0,                      // completion key
                            0                       // max threads == #processors
                            );


    if ( m_CompletionPort == NULL )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Creating completion port failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // WORK_QUEUE::Initialize



/***************************************************************************++

Routine Description:

    Return a blank work item to the caller. 

    In the case of explicitly queued (i.e. not real async i/o) work items, 
    ownership of this WORK_ITEM is automatically transferred back to the 
    work queue via the later call to QueueWorkItem() (even if that method 
    returns failure), and so therefore the WORK_ITEM instance must not be
    explicitly freed by the caller. 

    In the case of true async i/o work items, if the async i/o call succeeds,
    ownership of this WORK_ITEM is automatically transferred back to the 
    work queue. However, if initiating the async i/o call fails, the caller
    must free this WORK_ITEM via FreeWorkItem().

Arguments:

    ppWorkItem - Pointer to the place to put the new work item pointer; 
    a NULL pointer is returned on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::GetBlankWorkItem(
    OUT WORK_ITEM ** ppWorkItem
    )
{

    WORK_ITEM * pNewWorkItem = NULL; 
    HRESULT hr = S_OK;

    
    DBG_ASSERT( ppWorkItem != NULL );

    *ppWorkItem = NULL;


    // 
    // Allocate the new instance up front, before we take the critical section,
    // in order to reduce the time we hold that critical section.
    //


    // CODEWORK allocation cache for WORK_ITEMs?

    pNewWorkItem = new WORK_ITEM();

    if ( pNewWorkItem == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Allocating WORK_ITEM failed\n"
            ));

        // note: early function exit
        return hr;
    }

    
    //
    // Prevent races with the shutdown code. Specifically we must
    // guarantee that once m_DeletePending is set, no other threads may
    // get further blank work items; and furthermore, that the count of 
    // outstanding work items is set atomically with the check of that
    // flag.
    //

    m_DispenseWorkItemLock.Lock();


    if ( m_DeletePending )
    {

        // 
        // Stop handing out work items in the shutdown case, so that we 
        // are guaranteed to quiesce.
        //
        
        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Not returning blank work item because work queue is shutting down\n"
                ));
        }

        hr = HRESULT_FROM_WIN32( ERROR_BUSY );

        // clean up the new instance, since we can't give it out
        delete pNewWorkItem;

        goto exit;
    }


    *ppWorkItem = pNewWorkItem;

    m_CountWorkItemsOutstanding++;


#if DBG

    //
    // Set the serial number.
    //
    
    m_CountWorkItemsGivenOut++;

    ( *ppWorkItem )->SetSerialNumber( m_CountWorkItemsGivenOut );


    //
    // Add to the work items outstanding list.
    //
    
    InsertHeadList( &m_WorkItemsOutstandingListHead, ( *ppWorkItem )->GetListEntry() );

#endif  // DBG

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Created work item with serial number: %li; work items outstanding: %li\n",
            ( *ppWorkItem )->GetSerialNumber(),
            m_CountWorkItemsOutstanding
            ));
    }


exit:

    m_DispenseWorkItemLock.Unlock();


    return hr;
    
}   // WORK_QUEUE::GetBlankWorkItem



/***************************************************************************++

Routine Description:

    Explicitly queue a work item. In both success and failure cases, the 
    ownership of the WORK_ITEM is transferred to this class, and therefore
    the client may not free it, nor may the client access it after this call.

Arguments:

    pWorkItem - The work item. It must have originally come from a call to
    GetBlankWorkItem().

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::QueueWorkItem(
    IN WORK_ITEM * pWorkItem
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
#if DBG
    ULONG SerialNumber = 0;
#endif  // DBG



    DBG_ASSERT( pWorkItem != NULL );


#if DBG
    // remember serial number to prevent race later
    SerialNumber = pWorkItem->GetSerialNumber();
#endif  // DBG
    

    Success = PostQueuedCompletionStatus(
                    m_CompletionPort,                           // completion port
                    pWorkItem->GetNumberOfBytesTransferred(),   // #bytes transferred
                    pWorkItem->GetCompletionKey(),              // completion key
                    pWorkItem->GetOverlapped()                  // OVERLAPPED
                    );


    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Queueing work item failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "Queued work item with serial number: %li\n",
            SerialNumber
            ));

    }


exit:

    if ( FAILED( hr ) )
    {
    
        //
        // If queueing failed, free the work item here. (In the success case,
        // it will be freed once it is serviced.)
        //
        FreeWorkItem( pWorkItem );

    }


    return hr;

}   // WORK_QUEUE::QueueWorkItem



/***************************************************************************++

Routine Description:

    A shortcut routine for the common case of getting a work item, setting 
    the entry point and completion key, and submitting the work item.

Arguments:

    pWorkDispatch - The WORK_DISPATCH-derived instance which will be 
    responsible for executing the work item. Must be valid (non-NULL).
    
    OpCode - The opcode to set for this work item. 

Return Value:

    HRESULT. 

--***************************************************************************/

HRESULT
WORK_QUEUE::GetAndQueueWorkItem(
    IN WORK_DISPATCH * pWorkDispatch,
    IN ULONG_PTR OpCode
    )
{

    HRESULT hr = S_OK;
    WORK_ITEM * pWorkItem = NULL; 
    

    DBG_ASSERT( pWorkDispatch != NULL );


    hr = GetBlankWorkItem( &pWorkItem );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get a blank work item\n"
            ));

        goto exit;
    }


    pWorkItem->SetWorkDispatchPointer( pWorkDispatch );
    pWorkItem->SetOpCode( OpCode );


    hr = QueueWorkItem( pWorkItem );
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not queue work item\n"
            ));

        //
        // Note that in this failure case, pWorkItem was freed for us
        // by the QueueWorkItem() call.
        //
    
        goto exit;
    }


exit:

    return hr;
    
}   // WORK_QUEUE::GetAndQueueWorkItem



/***************************************************************************++

Routine Description:

    Associates an asynchronous i/o handle with the completion port of this
    work queue.

    Note that all subsequent asynchronous i/o operations on that handle must
    be done using WORK_ITEM instances to get the OVERLAPPED structure.

Arguments:

    HandleToBind - The i/o handle to associate with the completion port.
    
    CompletionKey - The key to return with i/o completions from this handle.
    Optional.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::BindHandleToCompletionPort(
    IN HANDLE HandleToBind,
    IN ULONG_PTR CompletionKey OPTIONAL
    )
{

    HANDLE ResultHandle = NULL;
    HRESULT hr = S_OK;


    DBG_ASSERT( HandleToBind != INVALID_HANDLE_VALUE );
    
    ResultHandle = CreateIoCompletionPort(
                        HandleToBind,       // file i/o handle
                        m_CompletionPort,   // completion port
                        CompletionKey,      // completion key
                        0                   // max threads == #processors
                        );


    if ( ResultHandle == NULL )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Binding handle to completion port failed\n"
            ));

    }


    // 
    // Note that in the success case, we do not need to do a CloseHandle()
    // on ResultHandle.
    //


    return hr;

}   // WORK_QUEUE::BindHandleToCompletionPort

/***************************************************************************++

Routine Description:

    Associates a job object with the completion port of this
    work queue.

    Note that all subsequent asynchronous i/o operations on that handle must
    be done using WORK_ITEM instances to get the OVERLAPPED structure.

Arguments:

    HandleToBind - The i/o handle to associate with the completion port.
    
    CompletionKey - The key to return with i/o completions from this handle.
    Optional.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::BindJobToCompletionPort(
    IN HANDLE JobToBind,
    IN LPOVERLAPPED pOverlapped
    )
{

    HRESULT hr = S_OK;
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT port;

    DBG_ASSERT ( m_CompletionPort );
    DBG_ASSERT ( JobToBind );
    DBG_ASSERT ( pOverlapped );

    port.CompletionKey = (LPVOID) pOverlapped;
    port.CompletionPort = m_CompletionPort;

    if ( ! SetInformationJobObject( JobToBind,
                                    JobObjectAssociateCompletionPortInformation,
                                    &port,
                                    sizeof( port ) ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Binding a completion port to a job object failed\n"
            ));

        goto exit;

    }

exit:

    return hr;

}   // WORK_QUEUE::BindJobToCompletionPort


/***************************************************************************++

Routine Description:

    Free a completed work item.

Arguments:

    pWorkItem - Pointer to the work item to free.

Return Value:

    None.

--***************************************************************************/

VOID
WORK_QUEUE::FreeWorkItem(
    IN WORK_ITEM * pWorkItem
    )
{

    DBG_ASSERT( pWorkItem != NULL );


    //
    // Synchronize, since the count of work items outstanding can be updated 
    // by multiple threads getting blank work items.
    //
    m_DispenseWorkItemLock.Lock();
    
    m_CountWorkItemsOutstanding--;


#if DBG

    //
    // Remove from the work items outstanding list.
    //

    RemoveEntryList( pWorkItem->GetListEntry() );
    ( pWorkItem->GetListEntry() )->Flink = NULL; 
    ( pWorkItem->GetListEntry() )->Blink = NULL; 

#endif  // DBG


    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Freeing work item with serial number: %li; work items outstanding: %li\n",
            pWorkItem->GetSerialNumber(),
            m_CountWorkItemsOutstanding
            ));
    }


    m_DispenseWorkItemLock.Unlock();


    delete pWorkItem;
    
}   // WORK_QUEUE::FreeWorkItem



/***************************************************************************++

Routine Description:

    Dequeue, execute, and free a work item.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
WORK_QUEUE::ProcessWorkItem(
    )
{

    HRESULT hr = S_OK;
    WORK_ITEM * pWorkItem = NULL;


    hr = DequeueWorkItem( INFINITE, &pWorkItem );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Dequeuing a work item failed\n"
            ));

        goto exit;
    }


    hr = pWorkItem->Execute();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Work item execution failed\n"
            ));

    }


    //
    // Whether it succeeded or failed, always free the work item
    // if the work item is to be deleted.
    //

    if ( pWorkItem->DeleteWhenDone() )
    {
        FreeWorkItem( pWorkItem );
    }


exit:

    return hr;

}   // WORK_QUEUE::ProcessWorkItem



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
WORK_QUEUE::Terminate(
    )
{

    HRESULT hr = S_OK;
    WORK_ITEM * pWorkItem = NULL;
    ULONG DequeueFailCount = 0;


    // prevent races with other threads attempting to get blank work items
    m_DispenseWorkItemLock.Lock();

    // prevent any more blank work items from being dispensed
    m_DeletePending = TRUE;

    m_DispenseWorkItemLock.Unlock();

    
    //
    // Dequeue, execute, and free all remaining work items, in order to free 
    // all resources. 
    //
    // We wake up periodically to check the count of work items outstanding 
    // because some work items might get explicitly freed via FreeWorkItem() 
    // on error paths, and never make it onto the queue for us to dequeue.
    //
    // Also, no explicit synchronization is necessary on this thread-shared 
    // variable because this is an aligned 32-bit read (and we are
    // guaranteed that this count cannot go back up once it has hit zero).
    //


    while ( m_CountWorkItemsOutstanding > 0 )
    {
    
        hr = DequeueWorkItem( ONE_SECOND_IN_MILLISECONDS, &pWorkItem );

        if ( FAILED( hr ) )
        {


            DBG_ASSERT( pWorkItem == NULL );


            if ( hr == HRESULT_FROM_WIN32( WAIT_TIMEOUT ) )
            {
            
                DBGPRINTF(( 
                    DBG_CONTEXT,
                    "Dequeuing work item timed out; work items still outstanding: %lu\n",
                    m_CountWorkItemsOutstanding 
                    ));

            } 
            else
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Couldn't dequeue a work item\n"
                    ));

            }

            DequeueFailCount++;

            if ( DequeueFailCount > 30 )
            {

                //
                // Forget about it; let's get out of here.
                //

                DBGPRINTF(( 
                    DBG_CONTEXT,
                    "Giving up waiting to dequeue remaining work items; work items still outstanding: %lu\n",
                    m_CountWorkItemsOutstanding 
                    ));


                //
                // On debug builds, assert if we are going to bail with work 
                // items still outstanding; it might signify a bug.
                //

                DBG_ASSERT( FALSE );


                break;
            }
        }


        if ( pWorkItem != NULL )
        {
            //
            // Execute the work item. Ignore failures. 
            //

            hr = pWorkItem->Execute();

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Work item execution failed\n"
                    ));

            }

            //
            // We might be cleaning the queue but not have
            // gotten to the item to release the work_items
            // from the job objects, so we still need to do
            // the check if we really want to delete the 
            // work_item.
            //
            if ( pWorkItem->DeleteWhenDone() )
            {

                //
                // Free the work item. 
                //

                FreeWorkItem( pWorkItem );
            }
        }

    }


    return;    
    
}   // WORK_QUEUE::Terminate



/***************************************************************************++

Routine Description:

    Dequeue the next work item. Called by the main thread only. The thread
    will block on the completion port until a work item is available or the
    timeout is reached.

Arguments:

    Timeout - Time in milliseconds to wait for a work item, or INFINITE.

    ppWorkItem - Outputs the work item, or NULL on failure. 

Return Value:

    HRESULT. This method returns an error only if the dequeued failed (which 
    includes timeouts, where HRESULT_FROM_WIN32( WAIT_TIMEOUT ) is returned). 
    If instead the dequeue succeeded but returned a completion of a failed 
    i/o, this method returns S_OK, but records the i/o error in the work item.

--***************************************************************************/

HRESULT
WORK_QUEUE::DequeueWorkItem(
    IN DWORD Timeout,
    OUT WORK_ITEM ** ppWorkItem
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;
    DWORD NumberOfBytesTransferred = 0;
    ULONG_PTR CompletionKey = 0;
    LPOVERLAPPED pOverlapped = NULL;


    DBG_ASSERT( ppWorkItem != NULL );

    *ppWorkItem = NULL;
    

    Success = GetQueuedCompletionStatus(
                    m_CompletionPort,           // completion port
                    &NumberOfBytesTransferred,  // #bytes transferred
                    &CompletionKey,             // completion key
                    &pOverlapped,               // OVERLAPPED
                    Timeout                     // time to wait
                    );


    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 


        //
        // If pOverlapped isn't NULL, then the GetQueuedCompletionStatus
        // call succeeded, it's just that the i/o operation that generated
        // the completion failed. If it is NULL, then we have a timeout or
        // a real failure.
        //

        if ( pOverlapped == NULL )
        {
            // dequeue failed


            if ( hr == HRESULT_FROM_WIN32( WAIT_TIMEOUT ) )
            {
            
                IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
                {
                    DBGPRINTF((
                        DBG_CONTEXT, 
                        "Dequeuing work item timed out\n"
                        ));
                }

            } 
            else
            {
            
                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Dequeueing work item failed\n"
                    ));

            }

            goto exit;

        } 
    }


    if ( CompletionKey == 0 )
    {
        *ppWorkItem = WORK_ITEM::WorkItemFromOverlapped( pOverlapped );
    }
    else
    {

        IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
        {

            DBGPRINTF((
                DBG_CONTEXT, 
                "CompletionKey = %08x\n"
                "pOverlapped = %08x\n"
                "size = %d \n",
                CompletionKey,
                pOverlapped,
                NumberOfBytesTransferred
                ));

        }

        // if we do have a CompletionKey, then it
        // is the address of the overlapped member in the
        // job object that we want to process.
        //
        // We are forced to handle this this way by the fact that the
        // Job Objects will send this pointer value back to us

        *ppWorkItem = WORK_ITEM::WorkItemFromOverlapped( ( LPOVERLAPPED ) CompletionKey );
    }

    DBG_ASSERT( *ppWorkItem != NULL );


    ( *ppWorkItem )->SetNumberOfBytesTransferred( NumberOfBytesTransferred );
    ( *ppWorkItem )->SetCompletionKey( CompletionKey );


    //
    // If the dequeue succeeded, but we got a failed i/o completion,
    // set the i/o error in the work item, but don't return an error.
    //

    if ( hr != S_OK )
    {
        ( *ppWorkItem )->SetIoError( hr );

        hr = S_OK;
    }
    

    IF_DEBUG( WEB_ADMIN_SERVICE_TIMER_QUEUE )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "Dequeued work item with serial number: %li\n",
            ( *ppWorkItem )->GetSerialNumber()
            ));

    }


exit:

    return hr;

}   // WORK_QUEUE::DequeueWorkItem



/***************************************************************************++

Routine Description:

    Attempt to queue a work item from a secondary thread (i.e., not the main
    worker thread). If this fails, report a fatal error.

Arguments:

    pWorkDispatch - The WORK_DISPATCH-derived instance which will be 
    responsible for executing the work item. Must be valid (non-NULL).
    
    OpCode - The opcode to set for this work item. 

Return Value:

    None.

--***************************************************************************/

VOID
QueueWorkItemFromSecondaryThread(
    IN WORK_DISPATCH * pWorkDispatch,
    IN ULONG_PTR OpCode
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pWorkDispatch != NULL );


    hr = GetWebAdminService()->GetWorkQueue()->GetAndQueueWorkItem(
                                                    pWorkDispatch,
                                                    OpCode
                                                    );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not queue work item from secondary thread\n"
            ));

        GetWebAdminService()->FatalErrorOnSecondaryThread( hr );

    }


    return;
    
}   // QueueWorkItemFromSecondaryThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\archive\metabase\config_manager.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    config_manager.cxx

Abstract:

    The IIS web admin service configuration manager class implementation. 
    This class manages access to configuration metadata, as well as 
    handling dynamic configuration changes.

    Threading: Access to configuration metadata is done on the main worker 
    thread. Configuration changes arrive on COM threads (i.e., secondary 
    threads), and so they post work items to process the changes on the main 
    worker thread.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::CONFIG_MANAGER(
    )
{

    m_Signature = CONFIG_MANAGER_SIGNATURE;


    m_CoInitialized = FALSE;

    m_pIMSAdminBase = NULL;

}   // CONFIG_MANAGER::CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::~CONFIG_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == CONFIG_MANAGER_SIGNATURE );


    if ( m_pIMSAdminBase != NULL )
    {
        m_pIMSAdminBase->Release();
        m_pIMSAdminBase = NULL;
    }


    //
    // Make sure we CoUninitialize on the same thread we CoInitialize'd on
    // originally.
    //

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_CoInitialized )
    {
        CoUninitialize();
        m_CoInitialized = FALSE;
    }


    m_Signature = CONFIG_MANAGER_SIGNATURE_FREED;

}   // CONFIG_MANAGER::~CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Initialize the configuration manager.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }

    m_CoInitialized = TRUE;
    

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &m_pIMSAdminBase )   // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }


    hr = ReadAllConfiguration();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading initial configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Read the initial web server configuration from the metabase.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllConfiguration(
    )
{

    HRESULT hr = S_OK;
    MB Metabase( m_pIMSAdminBase );
    BOOL Success = TRUE;


    //
    // Open the metabase to the key containing configuration for the web
    // service on the local machine.
    //
    
    Success = Metabase.Open( IIS_MD_W3SVC );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Opening metabase failed\n"
            ));

        goto exit;
    }


    hr = ReadAllAppPools( &Metabase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading app pools failed\n"
            ));

        goto exit;
    }


    hr = ReadAllVirtualSites( &Metabase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading virtual sites failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::ReadAllConfiguration



/***************************************************************************++

Routine Description:

    Enumerate and read all app pools configured in the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllAppPools(
    IN MB * pMetabase
    )
{

    DWORD EnumIndex = 0;
    WCHAR AppPoolId[ METADATA_MAX_NAME_LEN ];
    DWORD ValidAppPoolCount = 0;    
    HRESULT hr = S_OK;


    DBG_ASSERT( pMetabase != NULL );


    //
    // Enumerate all keys under IIS_MD_APP_POOLS below IIS_MD_W3SVC.
    //
    
    while ( pMetabase->EnumObjects( 
                            IIS_MD_APP_POOLS,
                            AppPoolId,
                            EnumIndex
                            ) )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reading from metabase app pool with ID: %S\n",
                AppPoolId
                ));
        }


        hr = ReadAppPool( pMetabase, AppPoolId ); 

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Reading app pool failed\n"
                ));

            //
            // Note: keep trying to read other app pools.
            //

            hr = S_OK;
        }
        else
        {
            //
            // If we read and created one successfully, bump our count.
            //
            
            ValidAppPoolCount++;
        }


        EnumIndex++;

    }
    

    //
    // Make sure we ran out of items, as opposed to a real error, such
    // as the IIS_MD_APP_POOLS key being missing entirely.
    //

    if ( GetLastError() != ERROR_NO_MORE_ITEMS ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Enumerating application pools in metabase failed\n"
            ));

        goto exit;
    }


    //
    // Make sure we found at least one app pool; if not, it is 
    // a fatal error.
    //
    //
    // CODEWORK Consider: perhaps we should continue to run (idle) in 
    // cases like this where the configured metadata does not actually
    // have a useful set of app pools/sites/apps defined, and just
    // wait around for if and when the metadata changes and becomes 
    // valid. This would be the more system-component-like thing to do
    // (say, like SMB waiting to see if any directories are shared), as
    // opposed to the current behavior, which follows previous IIS. 
    //

    if ( ValidAppPoolCount == 0 )
    {
    
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "No valid app pools found in metabase\n"
            ));

        goto exit;
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ReadAllAppPools



/***************************************************************************++

Routine Description:

    Read the configuration for a particular app pool from the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    VirtualSiteId - The id for the app pool being read.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAppPool(
    IN MB * pMetabase,
    IN LPCWSTR pAppPoolId
    )
{

    HRESULT hr = S_OK;
    APP_POOL_CONFIG AppPoolConfig;

    //
    // Buffer must be long enough to hold "/AppPools/[app pool id]".
    //
    WCHAR AppPoolPath[ ( sizeof( IIS_MD_APP_POOLS ) / sizeof ( WCHAR ) ) + 1 + METADATA_MAX_NAME_LEN + 1 ];


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pAppPoolId != NULL );


    ZeroMemory( &AppPoolConfig, sizeof( AppPoolConfig ) );


    _snwprintf( AppPoolPath, sizeof( AppPoolPath ) / sizeof ( WCHAR ), L"%s/%s", IIS_MD_APP_POOLS, pAppPoolId );


    //
    // Read other app pool config.
    //


    //
    // Read the periodic restart time property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_PERIODIC_RESTART_TIME,
                    ALL_METADATA,
                    APPPOOL_PERIODIC_RESTART_TIME_DEFAULT,
                    &AppPoolConfig.PeriodicProcessRestartPeriodInMinutes
                    );


    //
    // Read the periodic restart request count property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT,
                    ALL_METADATA,
                    APPPOOL_PERIODIC_RESTART_REQUEST_COUNT_DEFAULT,
                    &AppPoolConfig.PeriodicProcessRestartRequestCount
                    );


    //
    // Read the maximum number of processes property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_MAX_PROCESS_COUNT,
                    ALL_METADATA,
                    APPPOOL_MAX_PROCESS_COUNT_DEFAULT,
                    &AppPoolConfig.MaxSteadyStateProcessCount
                    );

//
// paulmcd (9/23/99) removed to allow 0 processes so that unmanaged processes 
// can open the app pool and manage their own lifetime
//

#if 0
    //
    // Enforce constraints: The number of processes must be greater than 
    // zero. 
    //

    if ( AppPoolConfig.MaxSteadyStateProcessCount < 1 )
    {
        AppPoolConfig.MaxSteadyStateProcessCount = 1;
    }
#endif

    //
    // Read the pinging enabled property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_PINGING_ENABLED,
                    ALL_METADATA,
                    APPPOOL_PINGING_ENABLED_DEFAULT,
                    &AppPoolConfig.PingingEnabled
                    );


    //
    // Read the idle timeout property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_IDLE_TIMEOUT,
                    ALL_METADATA,
                    APPPOOL_IDLE_TIMEOUT_DEFAULT,
                    &AppPoolConfig.IdleTimeoutInMinutes
                    );


    //
    // Read the rapid, repeated failure protection enabled property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED,
                    ALL_METADATA,
                    APPPOOL_RAPID_FAIL_PROTECTION_ENABLED_DEFAULT,
                    &AppPoolConfig.RapidFailProtectionEnabled
                    );


    //
    // Read the SMP affinitization enabled property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_SMP_AFFINITIZED,
                    ALL_METADATA,
                    APPPOOL_SMP_AFFINITIZED_DEFAULT,
                    &AppPoolConfig.SMPAffinitized
                    );


    //
    // Read the SMP affinitization processor mask property. 
    // A default value is supplied, so the call always succeeds.
    //

    //
    // CODEWORK Enforce that this mask is non-zero. 
    //

    //
    // BUGBUG The metabase doesn't have a way to read things of type
    // DWORD_PTR. Make sure this works with the new config store when
    // we switch over. 
    //

    DWORD Temp;

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK,
                    ALL_METADATA,
                    APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK_DEFAULT,
                    &Temp
                    );

    AppPoolConfig.SMPAffinitizedProcessorMask = ( DWORD_PTR ) Temp;


    //
    // Read the orphan worker processes for debugging enabled property. 
    // A default value is supplied, so the call always succeeds.
    //

    pMetabase->GetDword(
                    AppPoolPath,
                    MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING,
                    ALL_METADATA,
                    APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING_DEFAULT,
                    &AppPoolConfig.OrphanProcessesForDebuggingEnabled
                    );


    //
    // Call the UL&WM to create the app pool.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateAppPool( pAppPoolId, &AppPoolConfig );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating app pool failed\n"
            ));

    }


    return hr;

}   // CONFIG_MANAGER::ReadAppPool



/***************************************************************************++

Routine Description:

    Enumerate and read all virtual sites configured in the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllVirtualSites(
    IN MB * pMetabase
    )
{

    DWORD EnumIndex = 0;
    WCHAR KeyName[ METADATA_MAX_NAME_LEN ];
    DWORD VirtualSiteId = 0;
    DWORD ValidVirtualSiteCount = 0;
    HRESULT hr = S_OK;
    
#if DBG
    WCHAR Buffer[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];
#endif  // DBG


    DBG_ASSERT( pMetabase != NULL );


    // enumerate all keys under IIS_MD_W3SVC
    
    while ( pMetabase->EnumObjects( 
                            NULL,
                            KeyName,
                            EnumIndex
                            ) )
    {

        //
        // See if we have a virtual site, as opposed to some other key, 
        // by checking if the key name is numeric (and greater than zero). 
        // Ignore other keys.
        //
        // Note that _wtol returns zero if the string passed to it is not 
        // numeric. 
        //
        // Note also that using _wtol we will mistake a key that starts 
        // numeric but then has non-numeric characters as a number, leading 
        // us to try to read it as a virtual site. This is harmless though 
        // because it will not contain valid site properties, so we will
        // end up ignoring it in the end. In any case, such site names
        // are illegal in previous IIS versions anyways. We also check in
        // debug builds for this case.
        //
        
        VirtualSiteId = _wtol( KeyName );


        if ( VirtualSiteId > 0 )
        {
            DBG_ASSERT( wcscmp( KeyName, _ltow( VirtualSiteId, Buffer, 10 ) ) == 0 );

            //
            // Got one!
            //

            IF_DEBUG( WEB_ADMIN_SERVICE )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Reading from metabase virtual site with ID: %lu\n",
                    VirtualSiteId
                    ));
            }


            hr = ReadVirtualSite( pMetabase, KeyName, VirtualSiteId ); 

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Reading virtual site failed\n"
                    ));

                //
                // Note: keep trying to read other virtual sites.
                //

                hr = S_OK;
            }
            else
            {
                //
                // If we read and created one successfully, bump our count.
                //

                ValidVirtualSiteCount++;
            }

        }
        else
        {
            IF_DEBUG( WEB_ADMIN_SERVICE )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "Ignoring key under /LM/W3SVC while looking for virtual sites: %S\n",
                    KeyName
                    ));
            }
        }

        EnumIndex++;

    }


    // make sure we ran out of items, as opposed to a real error

    if ( GetLastError() != ERROR_NO_MORE_ITEMS ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Enumerating virtual sites in metabase failed\n"
            ));
        
        goto exit;
    }


    //
    // Make sure we found at least one virtual site; if not, it is 
    // a fatal error.
    //
    
    if ( ValidVirtualSiteCount == 0 )
    {
    
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "No valid virtual sites found in metabase\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Total number of valid virtual sites found: %lu\n",
            ValidVirtualSiteCount
            ));
    }


exit: 

    return hr;

}   // CONFIG_MANAGER::ReadAllVirtualSites



/***************************************************************************++

Routine Description:

    Read the configuration for a particular virtual site from the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pVirtualSiteKeyName - The metabase key name for the virtual site being 
    read.

    VirtualSiteId - The id for the virtual site being read.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadVirtualSite(
    IN MB * pMetabase,
    IN LPCWSTR pVirtualSiteKeyName,
    IN DWORD VirtualSiteId
    )
{

    HRESULT hr = S_OK;
    MULTISZ UrlPrefixes;
    BOOL ValidRootApplicationExists = FALSE;
    

    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pVirtualSiteKeyName != NULL );


    hr = ReadAllBindingsAndReturnUrlPrefixes( pMetabase, pVirtualSiteKeyName, &UrlPrefixes );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Building URL prefixes for virtual site failed\n"
            ));

        goto exit;
    }


    //
    // A virtual site must have at least one binding; if not, we can't 
    // create it.
    //
    
    if ( UrlPrefixes.IsEmpty() )
    {
    
        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "No bindings found for virtual site with id: %lu; can't start site\n",
                VirtualSiteId
                ));
        }


        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA ); 
        

        //
        // Log an event: no bindings for site, can't start it.
        //

        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = pVirtualSiteKeyName;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_CONFIG_NO_BINDINGS_FOR_SITE,  // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                0                                       // error code
                );


        goto exit;
    }


    // CODEWORK read other virtual site config

    
    //
    // Call the UL&WM to create the virtual site.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->
                CreateVirtualSite(
                    VirtualSiteId,
                    &UrlPrefixes
                    );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating virtual site failed\n"
            ));

        goto exit;
    }


    //
    // Read and create the applications of this virtual site.
    //

    hr = ReadAllApplicationsInVirtualSite( 
                pMetabase, 
                pVirtualSiteKeyName, 
                VirtualSiteId, 
                &ValidRootApplicationExists
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading all applications in site failed\n"
            ));

        goto exit;
    }


    //
    // Make sure that the root application exists for this site and is
    // valid; if not, the site is considered invalid. 
    //

    if ( ! ValidRootApplicationExists )
    {
        
        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Missing or invalid root application for virtual site with id: %lu; can't start site\n",
                VirtualSiteId
                ));
        }


        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA ); 


        //
        // Log an event: Missing or invalid root application for site, 
        // can't start it.
        //

        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = pVirtualSiteKeyName;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_CONFIG_NO_ROOT_APP_FOR_SITE,  // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                0                                       // error code
                );


        //
        // BUGBUG Should we delete the site we just created? If so, we also
        // need to have that operation clean up any apps that were read and 
        // created for this site. 
        //
    
        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::ReadVirtualSite



/***************************************************************************++

Routine Description:

    Read the metabase properties containing binding strings, and convert 
    them into UL style URL prefixes and aggregate them into a single MULTISZ.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pVirtualSiteKeyName - The metabase key name for the virtual site being 
    read.

    pUrlPrefixes - The returned set of URL prefixes. See comments for the
    function BindingStringToUrlPrefix() for details on the format. May be
    returned empty if no valid bindings are found. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllBindingsAndReturnUrlPrefixes(
    IN MB * pMetabase,
    IN LPCWSTR pVirtualSiteKeyName,
    OUT MULTISZ * pUrlPrefixes
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    MULTISZ ServerBindings;
    MULTISZ SecureBindings;


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pVirtualSiteKeyName != NULL );
    DBG_ASSERT( pUrlPrefixes != NULL );


    //
    // Read the server binding information for this virtual site from the 
    // metabase. This property is not required.
    //

    Success = pMetabase->GetMultisz(
                                pVirtualSiteKeyName,
                                MD_SERVER_BINDINGS,
                                IIS_MD_UT_SERVER,
                                &ServerBindings
                                );

    if ( ! Success )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 


        //
        // It's ok if the server bindings just weren't present; but
        // check for other errors.
        //

        if ( hr == MD_ERROR_DATA_NOT_FOUND )
        {
            hr = S_OK;
        }
        else
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Reading server bindings from metabase failed\n"
                ));

            goto exit;
        }

    }
    else
    {

        //
        // Convert the set of bindings from metabase format to UL URL prefix 
        // format.
        //

        hr = ConvertBindingsToUrlPrefixes( 
                    &ServerBindings, 
                    PROTOCOL_STRING_HTTP,
                    PROTOCOL_STRING_HTTP_CHAR_COUNT_SANS_TERMINATION,
                    pUrlPrefixes 
                    );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Converting format of server bindings failed\n"
                ));

            goto exit;
        }

    }
    

    //
    // Read the secure bindings, if any, and process them similarly
    // to the regular bindings. This property is not required.
    //
    
    Success = pMetabase->GetMultisz(
                                pVirtualSiteKeyName,
                                MD_SECURE_BINDINGS,
                                IIS_MD_UT_SERVER,
                                &SecureBindings
                                );

    if ( ! Success )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        //
        // It's ok if the secure bindings just weren't present; but
        // check for other errors.
        //

        if ( hr == MD_ERROR_DATA_NOT_FOUND )
        {
            hr = S_OK;
        }
        else
        {
            DPERROR((
                DBG_CONTEXT,
                hr,
                "Reading secure bindings from metabase failed\n"
                ));

            goto exit;
        }
        
    }
    else
    {

        //
        // Again, convert the set of bindings from metabase format to UL URL 
        // prefix format. Note that results are appended onto the second 
        // parameter, so now we have collected all of the bindings into one 
        // list.
        //

        hr = ConvertBindingsToUrlPrefixes( 
                    &SecureBindings, 
                    PROTOCOL_STRING_HTTPS,
                    PROTOCOL_STRING_HTTPS_CHAR_COUNT_SANS_TERMINATION,
                    pUrlPrefixes
                    );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Converting format of secure bindings failed\n"
                ));

            goto exit;
        }

    }


exit:

    return hr;

}   // CONFIG_MANAGER::ReadAllBindingsAndReturnUrlPrefixes



/***************************************************************************++

Routine Description:

    Convert each of the metabase style binding strings in the input MULTISZ 
    into UL style URL prefixes. Each of these resulting strings is added onto 
    the output MULTISZ. 

Arguments:

    pBindingStrings - The set of bindings to convert. Must contain
    at least one binding.

    pProtocolString - The protocol string, for example "http://".

    ProtocolStringCharCountSansTermination - The count of characters in
    the protocol string, without the terminating null.

    pUrlPrefixes - The results. Note that the results are added to
    any strings already existing in this MULTISZ. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ConvertBindingsToUrlPrefixes(
    IN const MULTISZ * pBindingStrings,
    IN LPCWSTR pProtocolString, 
    IN ULONG ProtocolStringCharCountSansTermination,
    IN OUT MULTISZ * pUrlPrefixes
    )
    const
{

    LPCWSTR pBindingToConvert = NULL;
    STRU Result;
    HRESULT hr = S_OK;
    BOOL Success = TRUE;


    DBG_ASSERT( pBindingStrings != NULL );
    DBG_ASSERT( pUrlPrefixes != NULL );


    pBindingToConvert = pBindingStrings->First();
    

    while ( pBindingToConvert != NULL )
    {
        
        hr = BindingStringToUrlPrefix(
                    pBindingToConvert, 
                    pProtocolString,
                    ProtocolStringCharCountSansTermination,
                    &Result
                    );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Converting binding string to URL prefix failed\n"
                ));

            //
            // Note: keep trying to convert other bindings.
            //

            hr = S_OK;
        }
        else
        {
            //
            // If we converted one successfully, append it to our result.
            //
        
            Success = pUrlPrefixes->Append( Result );

            if ( ! Success )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() ); 

                DPERROR((
                    DBG_CONTEXT,
                    hr,
                    "Appending to string failed\n"
                    ));

                //
                // Note: keep trying to convert other bindings.
                //

                hr = S_OK;
            }
            
        }


        Result.Reset();

        pBindingToConvert = pBindingStrings->Next( pBindingToConvert );

    }


    return hr;

}   // CONFIG_MANAGER::ConvertBindingsToUrlPrefixes



/***************************************************************************++

Routine Description:

    Convert a single metabase style binding string into the UL format
    used for URL prefixes.

    The metabase format is "ip-address:ip-port:host-name". The port must 
    always be present; the ip-address and host-name are both optional, 
    and may be left empty. However, it is illegal to specify both (this is 
    a slight restriction over what we allowed in earlier versions of IIS). 

    The UL format is "[http|https]://[ip-address|host-name|*]:ip-port". 
    All pieces of information (protocol, address information, and port)
    must be present. The "*" means accept any ip-address or host-name.

Arguments:

    pBindingString - The metabase style binding string to convert.

    pProtocolString - The protocol string, for example "http://".

    ProtocolStringCharCountSansTermination - The count of characters in
    the protocol string, without the terminating null.

    pUrlPrefix - The resulting UL format URL prefix.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::BindingStringToUrlPrefix(
    IN LPCWSTR pBindingString,
    IN LPCWSTR pProtocolString, 
    IN ULONG ProtocolStringCharCountSansTermination,
    OUT STRU * pUrlPrefix
    )
    const
{

    HRESULT hr = S_OK;
    LPCWSTR IpAddress = NULL;
    LPCWSTR IpPort = NULL;
    LPCWSTR HostName = NULL;
    ULONG IpAddressCharCountSansTermination = 0;
    ULONG IpPortCharCountSansTermination = 0;
    BOOL Success = TRUE;


    DBG_ASSERT( pBindingString != NULL );
    DBG_ASSERT( pProtocolString != NULL );
    DBG_ASSERT( pUrlPrefix != NULL );


    //
    // Find the various parts of the binding.
    //

    IpAddress = pBindingString;

    IpPort = wcschr( IpAddress, L':' );

    if ( IpPort == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        goto exit;
    }

    IpPort++;

    HostName = wcschr( IpPort, L':' );

    if ( HostName == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        goto exit;
    }

    HostName++;


    //
    // Validate the ip address.
    //

    if ( *IpAddress == L':' )
    {
        // no ip address specified
        
        IpAddress = NULL;
    }
    else
    {
        IpAddressCharCountSansTermination = DIFF( IpPort - IpAddress ) - 1;
    }


    //
    // Validate the ip port.
    //

    if ( *IpPort == L':' )
    {
        // no ip port specified in binding string

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        goto exit;
    }
    
    IpPortCharCountSansTermination = DIFF( HostName - IpPort ) - 1;


    //
    // Validate the host-name.
    //

    if ( *HostName == L'\0' )
    {
        // no host-name specified
        
        HostName = NULL;
    }


    //
    // Now create the UL-style URL prefix.
    //

    hr = pUrlPrefix->Append( pProtocolString, ProtocolStringCharCountSansTermination );

    if ( FAILED( hr ) )
    {
    
        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }


    //
    // Determine whether to use host-name, ip address, or "*".
    //

    if ( IpAddress != NULL )
    {
        if ( HostName != NULL )
        {
            //
            // It is illegal for both host-name and ip address to be specified.
            //

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

            goto exit;
        }
        else
        {
            hr = pUrlPrefix->Append( IpAddress, IpAddressCharCountSansTermination );
        }
    }
    else
    {
        if ( HostName != NULL )
        {
            hr = pUrlPrefix->Append( HostName );
        }
        else
        {
            hr = pUrlPrefix->Append( L"*", 1 );
        }
    }

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }


    hr = pUrlPrefix->Append( L":", 1 );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }


    hr = pUrlPrefix->Append( IpPort, IpPortCharCountSansTermination );

    if ( FAILED( hr ) )
    {

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Appending to string failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Converted metabase binding: '%S' to UL binding: '%S'\n",
            pBindingString,
            pUrlPrefix->QueryStr()
            ));
    }


exit:

    //
    // CODEWORK log an event if there was a bad binding string? If so, 
    // need to pass down the site information so we can log which site
    // has the bad binding. 
    //

    return hr;

}   // CONFIG_MANAGER::BindingStringToUrlPrefix



/***************************************************************************++

Routine Description:

    Find, read, and create all of the applications of a particular virtual 
    site.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pVirtualSiteKeyName - The metabase key name for the virtual site being 
    read.

    VirtualSiteId - The id for the virtual site which contains these
    applications.

    pValidRootApplicationExists - Returns TRUE if the root application (the 
    one at the URL "/" within the site) exists and is valid, FALSE otherwise.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllApplicationsInVirtualSite(
    IN MB * pMetabase,
    IN LPCWSTR pVirtualSiteKeyName,
    IN DWORD VirtualSiteId,
    OUT BOOL * pValidRootApplicationExists
    )
{

    HRESULT hr = S_OK;
    MULTISZ ApplicationPaths;

    //
    // Buffer must be long enough to hold "/[stringized virtual site id]/Root".
    //
    WCHAR SiteRootPath[ 1 + MAX_STRINGIZED_ULONG_CHAR_COUNT + ( sizeof( IIS_MD_VIRTUAL_SITE_ROOT ) / sizeof ( WCHAR ) ) + 1 ];


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pVirtualSiteKeyName != NULL );
    DBG_ASSERT( pValidRootApplicationExists != NULL );


    *pValidRootApplicationExists = FALSE;
    

    _snwprintf( SiteRootPath, sizeof( SiteRootPath ) / sizeof ( WCHAR ), L"/%s%s", pVirtualSiteKeyName, IIS_MD_VIRTUAL_SITE_ROOT );


    //
    // Enumerate all the applications in this virtual site. 
    //

    hr = EnumAllApplicationsInVirtualSite( pMetabase, SiteRootPath, &ApplicationPaths );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Enumerating all applications in virtual site failed\n"
            ));

        goto exit;
    }


    //
    // Read and create the applications of this virtual site.
    //

    hr = ReadApplications(
                pMetabase, 
                VirtualSiteId, 
                &ApplicationPaths, 
                SiteRootPath, 
                pValidRootApplicationExists
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading applications failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::ReadAllApplicationsInVirtualSite



/***************************************************************************++

Routine Description:

    Enumerate and read all applications configured in the metabase under
    a particular virtual site.


Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pSiteRootPath - The metabase path fragment containing "/<SiteId>/Root".

    pApplicationPaths - The returned MULTISZ containing the metabase paths
    to the applications under the virtual site specified by pSiteRootPath.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::EnumAllApplicationsInVirtualSite(
    IN MB * pMetabase,
    IN LPCWSTR pSiteRootPath,
    OUT MULTISZ * pApplicationPaths
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pSiteRootPath != NULL );
    DBG_ASSERT( pApplicationPaths != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Scanning for all applications under: %S\n",
            pSiteRootPath
            ));
    }


    //
    // Find the paths of all applications in this site. We do this by 
    // asking for the paths to all metabase nodes which define the
    // MD_APP_APPPOOL property. This must be present on any application.
    //
    // Note that currently the metabase GetDataPaths() call does a tree walk
    // of all nodes below the starting point, which is simply not going to 
    // scale up. We are counting here on improvements in the speed of this 
    // operation, whether via adding rudimentary indexing support to the 
    // metabase, or changing the metabase story completely.
    //

    Success = pMetabase->GetDataPaths(
                                pSiteRootPath,
                                MD_APP_APPPOOL,
                                ALL_METADATA,
                                pApplicationPaths
                                );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting paths of applications under site failed\n"
            ));

        goto exit;
    }


    // get the MULTISZ in sync with its internal BUFFER
    pApplicationPaths->RecalcLen();


exit:

    return hr;

}   // CONFIG_MANAGER::EnumAllApplicationsInVirtualSite



/***************************************************************************++

Routine Description:

    Read and create a set of applications of a site.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    VirtualSiteId - The id for the virtual site which contains these
    applications.

    pApplicationPaths - A MULTISZ containing the metabase paths to the 
    applications under a virtual site.

    pSiteRootPath - The metabase path fragment containing "/<SiteId>/Root".

    pValidRootApplicationExists - Returns TRUE if the root application (the 
    one at the URL "/" within the site) exists and is valid, FALSE otherwise.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadApplications(
    IN MB * pMetabase,
    IN DWORD VirtualSiteId,
    IN MULTISZ * pApplicationPaths,
    IN LPCWSTR pSiteRootPath,
    OUT BOOL * pValidRootApplicationExists
    )
{

    HRESULT hr = S_OK;
    LPCWSTR pApplicationPath;
    BOOL IsRootApplication = FALSE;
    ULONG ValidApplicationCount = 0;


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPaths != NULL );
    DBG_ASSERT( pSiteRootPath != NULL );
    DBG_ASSERT( pValidRootApplicationExists != NULL );


    *pValidRootApplicationExists = FALSE;


    pApplicationPath = pApplicationPaths->First();
    
    while ( pApplicationPath != NULL )
    {
        hr = ReadApplication(
                    pMetabase, 
                    VirtualSiteId, 
                    pApplicationPath, 
                    pSiteRootPath, 
                    &IsRootApplication
                    );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Reading application failed\n"
                ));

            //
            // Note: keep trying to read other applications.
            //

            hr = S_OK;
        }
        else
        {
            //
            // If we read and created one successfully, bump our count,
            // and if it was the root application, set the output flag.
            //

            ValidApplicationCount++;

            if ( IsRootApplication )
            {
                *pValidRootApplicationExists = TRUE;
            }
        }


        pApplicationPath = pApplicationPaths->Next( pApplicationPath );
    }
    

    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Number of valid apps (including root app if present) found for site: %lu was: %lu\n",
            VirtualSiteId,
            ValidApplicationCount
            ));
    }


    return hr;

}   // CONFIG_MANAGER::ReadApplications



/***************************************************************************++

Routine Description:

    Read and create an application of a site.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    VirtualSiteId - The id for the virtual site which contains these
    applications.

    pApplicationPaths - The metabase path to the application starting from
    the site, for example "/<SiteId>/Root/MyApplication".

    pSiteRootPath - The metabase path fragment containing "/<SiteId>/Root".

    pIsRootApplication - Returns TRUE if this is the root application (the 
    one at "/") for this virtual site, FALSE otherwise.
    
Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadApplication(
    IN MB * pMetabase,
    IN DWORD VirtualSiteId,
    IN LPCWSTR pApplicationPath,
    IN LPCWSTR pSiteRootPath,
    OUT BOOL * pIsRootApplication
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    STRU AppPoolId;
    LPCWSTR pApplicationUrl = NULL;
    

    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPath != NULL );
    DBG_ASSERT( pSiteRootPath != NULL );
    DBG_ASSERT( pIsRootApplication != NULL );


    *pIsRootApplication = FALSE;


    //
    // Read the app pool property for this application. This property
    // is required, and in fact it must exist since we got this
    // application path by querying for this same property earlier
    // (while under the same metabase read lock).
    //
    
    Success = pMetabase->GetStr(
                                pApplicationPath,
                                MD_APP_APPPOOL,
                                IIS_MD_UT_WAM,
                                &AppPoolId
                                );

    if ( ! Success )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // if the property wasn't present, something is screwy
        DBG_ASSERT( hr != MD_ERROR_DATA_NOT_FOUND );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading app pool property of application failed\n"
            ));

        goto exit;

    }


    //
    // CODEWORK read other application config.
    //


    //
    // To get the (site-relative) application URL, lop off the front of
    // the application path, which is exactly the site root path.
    //

    DBG_ASSERT( _wcsnicmp( pApplicationPath, pSiteRootPath, wcslen( pSiteRootPath ) ) == 0 );
    
    pApplicationUrl = pApplicationPath + wcslen( pSiteRootPath );


    //
    // Check if this is the root application for the site, i.e. "/".
    //

    if ( ( *pApplicationUrl == L'/' ) && ( *( pApplicationUrl + 1 ) == L'\0' ) )
    {
        *pIsRootApplication = TRUE;
    }
    

    //
    // Call the UL&WM to create the application.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->
            CreateApplication( VirtualSiteId, pApplicationUrl, AppPoolId.QueryStr() );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating application failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::ReadApplication
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\archive\shutdownlist\app_pool.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool.cxx

Abstract:

    This class encapsulates a single app pool. 

    Threading: For the class itself, Reference(), Dereference(), and the
    destructor may be called on any thread; all other work is done on the 
    main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"



//
// local prototypes
//

ULONG
CountOfBitsSet(
    IN DWORD_PTR Value
    );



/***************************************************************************++

Routine Description:

    Constructor for the APP_POOL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL::APP_POOL(
    )
{

    m_Signature = APP_POOL_SIGNATURE;


    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //

    m_RefCount = 1;


    m_State = UninitializedAppPoolState; 

    m_OwningDataStructure = NoneAppPoolOwningDataStructure;

    m_pAppPoolId = NULL;

    ZeroMemory( &m_Config, sizeof( m_Config ) );

    m_AppPoolHandle = NULL;

    m_WaitingForDemandStart = FALSE;

    InitializeListHead( &m_WorkerProcessListHead );
    m_WorkerProcessCount = 0;

    m_AdjustedMaxSteadyStateProcessCount = 0;

    m_AvailableProcessorMask = 0;

    InitializeListHead( &m_ApplicationListHead );
    m_ApplicationCount = 0;

    m_TotalWorkerProcessRotations = 0;

    m_TotalWorkerProcessFailures = 0;
    
    m_RecentWorkerProcessFailures = 0;
    m_RecentFailuresWindowBeganTickCount = 0;

    m_ShutdownListEntry.Flink = NULL;
    m_ShutdownListEntry.Blink = NULL; 

    m_DeleteListEntry.Flink = NULL;
    m_DeleteListEntry.Blink = NULL; 


}   // APP_POOL::APP_POOL



/***************************************************************************++

Routine Description:

    Destructor for the APP_POOL class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

APP_POOL::~APP_POOL(
    )
{

    DBG_ASSERT( m_Signature == APP_POOL_SIGNATURE );

    DBG_ASSERT( m_RefCount == 0 );

    DBG_ASSERT( m_State == DeletePendingAppPoolState );

    DBG_ASSERT( m_OwningDataStructure == NoneAppPoolOwningDataStructure );

    DBG_ASSERT( m_AppPoolHandle == NULL );

    DBG_ASSERT( ! m_WaitingForDemandStart );

    DBG_ASSERT( m_ShutdownListEntry.Flink == NULL );
    DBG_ASSERT( m_ShutdownListEntry.Blink == NULL );


    //
    // This should not go away with any of its worker processes still around.
    //

    DBG_ASSERT( IsListEmpty( &m_WorkerProcessListHead ) );
    DBG_ASSERT( m_WorkerProcessCount == 0 );


    //
    // This should not go away with any applications still referring to it.
    //

    DBG_ASSERT( IsListEmpty( &m_ApplicationListHead ) );
    DBG_ASSERT( m_ApplicationCount == 0 );


    //
    // Free any separately allocated config.
    //

    if ( m_Config.pOrphanAction != NULL )
    {
        DBG_REQUIRE( GlobalFree( m_Config.pOrphanAction ) == NULL );
        m_Config.pOrphanAction = NULL;
    }


    if ( m_pAppPoolId != NULL )
    {
        DBG_REQUIRE( GlobalFree( m_pAppPoolId ) == NULL );
        m_pAppPoolId = NULL;
    }

    
    m_Signature = APP_POOL_SIGNATURE_FREED;

}   // APP_POOL::~APP_POOL



/***************************************************************************++

Routine Description:

    Increment the reference count for this object. Note that this method must 
    be thread safe, and must not be able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Reference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedIncrement( &m_RefCount );


    // 
    // The reference count should never have been less than zero; and
    // furthermore once it has hit zero it should never bounce back up;
    // given these conditions, it better be greater than one now.
    //
    
    DBG_ASSERT( NewRefCount > 1 );


    return;

}   // APP_POOL::Reference



/***************************************************************************++

Routine Description:

    Decrement the reference count for this object, and cleanup if the count 
    hits zero. Note that this method must be thread safe, and must not be
    able to fail. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Dereference(
    )
{

    LONG NewRefCount = 0;


    NewRefCount = InterlockedDecrement( &m_RefCount );

    // ref count should never go negative
    DBG_ASSERT( NewRefCount >= 0 );

    if ( NewRefCount == 0 )
    {
        // time to go away

        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reference count has hit zero in APP_POOL instance, deleting (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }


        delete this;


    }
    

    return;
    
}   // APP_POOL::Dereference



/***************************************************************************++

Routine Description:

    Execute a work item on this object.

Arguments:

    pWorkItem - The work item to execute.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ExecuteWorkItem(
    IN const WORK_ITEM * pWorkItem
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pWorkItem != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Executing work item with serial number: %lu in APP_POOL (ptr: %p; id: %S) with operation: %p\n",
            pWorkItem->GetSerialNumber(),
            this,
            GetAppPoolId(),
            pWorkItem->GetOpCode()
            ));
    }


    switch ( pWorkItem->GetOpCode() )
    {

    case DemandStartAppPoolWorkItem:
        hr = DemandStartWorkItem();
        break;

    default:

        // invalid work item!
        DBG_ASSERT( FALSE );
            
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
            
    }


    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Executing work item on APP_POOL failed\n"
            ));

    }


    return hr;
    
}   // APP_POOL::ExecuteWorkItem



/***************************************************************************++

Routine Description:

    Initialize the app pool instance.

Arguments:

    pAppPoolId - ID string for the app pool.

    pAppPoolConfig - The configuration parameters for this app pool. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::Initialize(
    IN LPCWSTR pAppPoolId,
    IN APP_POOL_CONFIG * pAppPoolConfig
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    ULONG NumberOfCharacters = 0;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );
    DBG_ASSERT( pAppPoolConfig != NULL );


    //
    // First, make copy of the ID string.
    //

    // count the characters, and add 1 for the terminating null
    NumberOfCharacters = wcslen( pAppPoolId ) + 1;

    m_pAppPoolId = ( LPWSTR )GlobalAlloc( GMEM_FIXED, ( sizeof( WCHAR ) * NumberOfCharacters ) );

    if ( m_pAppPoolId == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating memory failed\n"
            ));

        goto exit;
    }


    wcscpy( m_pAppPoolId, pAppPoolId );


    //
    // Set the configuration information.
    //


    hr = SetConfiguration( pAppPoolConfig, NULL ); 

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Accepting configuration failed\n"
            ));

        goto exit;
    }


    //
    // Next, open the UL app pool handle.
    //

    Win32Error = UlCreateAppPool(
                        &m_AppPoolHandle,           // returned handle
                        m_pAppPoolId,               // app pool ID
                        NULL,                       // security attributes
                        UL_OPTION_OVERLAPPED        // async i/o
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't create app pool handle\n"
            ));

        goto exit;
    }


    //
    // Associate the app pool handle with the work queue's completion port.
    //
    
    hr = GetWebAdminService()->GetWorkQueue()->
                BindHandleToCompletionPort( 
                    m_AppPoolHandle, 
                    0
                    );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Binding app pool handle to completion port failed\n"
            ));

        goto exit;
    }


    //
    // Set the state to running. We must do this before posting the
    // demand start wait, as demand start requests are only acted on
    // if the app pool is in the running state. 
    //

    m_State = RunningAppPoolState; 


    //
    // See if we should wait asynchronously for a demand start notification
    // from UL for this app pool.
    //

    hr = WaitForDemandStartIfNeeded();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Waiting for demand start notification if needed failed\n"
            ));

        goto exit;
    }


exit:

    return hr;
    
}   // APP_POOL::Initialize



/***************************************************************************++

Routine Description:

    Accept a set of configuration parameters for this app pool. 

Arguments:

    pAppPoolConfig - The configuration for this app pool. 

    pWhatHasChanged - Which particular configuration values were changed.
    This is optional; if not present, we assume that all configuration
    values may have changed. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::SetConfiguration(
    IN APP_POOL_CONFIG * pAppPoolConfig,
    IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
    )
{

    HRESULT hr = S_OK;
    SYSTEM_INFO SystemInfo;
    ULONG NumberOfAvailableProcessors = 0;
    

    DBG_ASSERT( pAppPoolConfig != NULL );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New configuration for app pool (ptr: %p; id: %S)\n",
            this,
            GetAppPoolId()
            ));
    }


    //
    // Note that we rely on the config store to ensure that the configuration
    // data are valid. 
    //


    //
    // Free any old separately allocated config.
    //

    if ( m_Config.pOrphanAction != NULL )
    {
        DBG_REQUIRE( GlobalFree( m_Config.pOrphanAction ) == NULL );
        m_Config.pOrphanAction = NULL;
    }


    //
    // Copy the inline config parameters into this instance. 
    //

    CopyMemory( &m_Config, pAppPoolConfig, sizeof( m_Config ) );


    //
    // Copy any referenced config parameters.
    //

    if ( pAppPoolConfig->pOrphanAction != NULL )
    {

        m_Config.pOrphanAction = ( LPWSTR )GlobalAlloc( GMEM_FIXED, ( wcslen( pAppPoolConfig->pOrphanAction ) + 1 ) * sizeof( WCHAR ) );

        if ( m_Config.pOrphanAction == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Allocating memory failed\n"
                ));

            //
            // If there is no memory, then we can live with no orphan action.
            // Press on, so that we don't leave our config in a half-baked
            // state.
            //

        }
        else
        {

            wcscpy( m_Config.pOrphanAction, pAppPoolConfig->pOrphanAction );

        }
    }


    //
    // Initialize our private variable for the max steady state process count. 
    //

    m_AdjustedMaxSteadyStateProcessCount = m_Config.MaxSteadyStateProcessCount;


    if ( m_Config.SMPAffinitized )
    {

        //
        // Initialize the available processor mask to be the system processor
        // mask, restricted by the per app pool processor mask.
        //

        ZeroMemory( &SystemInfo, sizeof( SystemInfo ) );


        GetSystemInfo( &SystemInfo );

        DBG_ASSERT( CountOfBitsSet( SystemInfo.dwActiveProcessorMask ) == SystemInfo.dwNumberOfProcessors );


        m_AvailableProcessorMask = SystemInfo.dwActiveProcessorMask & m_Config.SMPAffinitizedProcessorMask;


        //
        // Restrict the max steady state process count based on the number
        // of available processors.
        //

        NumberOfAvailableProcessors = CountOfBitsSet( m_AvailableProcessorMask );


        if ( m_AdjustedMaxSteadyStateProcessCount > NumberOfAvailableProcessors )
        {
            m_AdjustedMaxSteadyStateProcessCount = NumberOfAvailableProcessors; 
        }


        //
        // Validate that the config is reasonable.
        //

        //
        // BUGBUG Should this check be done in the config store as part of
        // it's validation code? 
        //

        if ( NumberOfAvailableProcessors == 0 )
        {

            //
            // Log an event: SMP affinitization mask set such that no processors
            // may be used.
            //

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPoolId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_SMP_MASK_NO_PROCESSORS,       // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );

        }


        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "SMP Affinitization enabled for app pool (ptr: %p; id: %S), available processors mask: %p\n",
                this,
                GetAppPoolId(),
                m_AvailableProcessorMask
                ));
        }

    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "App pool's (ptr: %p; id: %S) adjusted max (steady state) process count: %lu\n",
            this,
            GetAppPoolId(),
            m_AdjustedMaxSteadyStateProcessCount
            ));
    }


#if DBG
    //
    // Dump the configuration.
    //

    DebugDump();
#endif  // DBG


    //
    // Rotate all worker processes to ensure that the config changes take 
    // effect. 
    //

    //
    // CODEWORK We only need to do this for certain property changes; others
    // don't require rotating running processes. Should we be smarter here
    // and only rotate when needed? 
    // Right now (12/3/99) the only app pool config properties that don't 
    // require rotation to take full effect are: pinging enabled, rapid fail
    // protection enabled, and orphaning. (12/21/99 also shutdown time limit,
    // ping interval, ping time limit.) (1/11/00 also disallow overlapping
    // rotation, orphan action).
    // As it stands, it doesn't seem worth it to special case this; so for 
    // now we'll just always rotate. EricDe agrees with this (12/6/99).
    //

    hr = ReplaceAllWorkerProcesses();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Replacing all worker processes failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::SetConfiguration



/***************************************************************************++

Routine Description:

    Register an application as being part of this app pool.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::AssociateApplication(
    IN APPLICATION * pApplication
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplication != NULL );


    InsertHeadList( 
        &m_ApplicationListHead, 
        pApplication->GetAppPoolListEntry() 
        );
        
    m_ApplicationCount++;


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Associated application %lu:\"%S\" with app pool \"%S\"; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->pApplicationUrl,
            m_pAppPoolId,
            m_ApplicationCount
            ));
    }


    return hr;
    
}   // APP_POOL::AssociateApplication



/***************************************************************************++

Routine Description:

    Remove the registration of an application that is part of this app
    pool.

Arguments:

    pApplication - Pointer to the APPLICATION instance.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::DissociateApplication(
    IN APPLICATION * pApplication
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplication != NULL );


    RemoveEntryList( pApplication->GetAppPoolListEntry() );
    ( pApplication->GetAppPoolListEntry() )->Flink = NULL; 
    ( pApplication->GetAppPoolListEntry() )->Blink = NULL; 

    m_ApplicationCount--;


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Dissociated application %lu:\"%S\" from app pool \"%S\"; app count now: %lu\n",
            ( pApplication->GetApplicationId() )->VirtualSiteId,
            ( pApplication->GetApplicationId() )->pApplicationUrl,
            m_pAppPoolId,
            m_ApplicationCount
            ));
    }


    return hr;
    
}   // APP_POOL::DissociateApplication



/***************************************************************************++

Routine Description:

    Handle the fact that there has been an unplanned worker process failure.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ReportWorkerProcessFailure(
    )
{

    HRESULT hr = S_OK;
    DWORD TickCount = 0;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // See if it's time to reset the tick count which is used to remember
    // when the time window began that we use for counting recent rapid
    // failures. 
    // Note that tick counts are in milliseconds. Tick counts roll over 
    // every 49.7 days, but the arithmetic operation works correctly 
    // anyways in this case.
    //

    TickCount = GetTickCount();

    if ( ( TickCount - m_RecentFailuresWindowBeganTickCount ) > RAPID_REPEATED_FAILURE_TIME_WINDOW )
    {

        //
        // It's time to reset the time window, and the recent fail count.
        //

        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Resetting rapid repeated failure count and time window in app pool (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }


        m_RecentFailuresWindowBeganTickCount = TickCount;

        m_RecentWorkerProcessFailures = 0;
    }


    //
    // Update counters.
    //

    m_TotalWorkerProcessFailures++;

    m_RecentWorkerProcessFailures++;


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Total WP failures: %lu; recent WP failures: %lu for app pool (ptr: %p; id: %S)\n",
            m_TotalWorkerProcessFailures,
            m_RecentWorkerProcessFailures,
            this,
            GetAppPoolId()
            ));
    }


    //
    // Check the recent fail count against the limit. When it hits the
    // threshold, take action. We only do this when it firsts hits the
    // limit. 
    //

    if ( m_RecentWorkerProcessFailures == RAPID_REPEATED_FAILURE_LIMIT )
    {

        //
        // We've had a rash of recent failures. Take action. 
        //

        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Rapid repeated failure limit hit in app pool (ptr: %p; id: %S)\n",
                this,
                GetAppPoolId()
                ));
        }


        //
        // Log an event: flurry of worker process failures detected.
        //

        const WCHAR * EventLogStrings[1];

        EventLogStrings[0] = m_pAppPoolId;

        GetWebAdminService()->GetEventLog()->
            LogEvent(
                WAS_EVENT_RAPID_REPEATED_FAILURE,       // message id
                sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                        // count of strings
                EventLogStrings,                        // array of strings
                0                                       // error code
                );


        if ( m_Config.RapidFailProtectionEnabled ) 
        {

            //
            // CODEWORK Automated out of service support.
            // Until then, this LogEvent call is commented out.
            //
/*
            //
            // Log an event: doing automated out of service.
            //

            const WCHAR * EventLogStrings[1];

            EventLogStrings[0] = m_pAppPoolId;

            GetWebAdminService()->GetEventLog()->
                LogEvent(
                    WAS_EVENT_AUTOMATED_OUT_OF_SERVICE,     // message id
                    sizeof( EventLogStrings ) / sizeof( const WCHAR * ),
                                                            // count of strings
                    EventLogStrings,                        // array of strings
                    0                                       // error code
                    );
*/


            //
            // Put this app pool out of service.
            //

            hr = PutOutOfService();

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Putting app pool out of service failed\n"
                    ));

                goto exit;
            }

        }

    }


exit:

    return hr;

}   // APP_POOL::ReportWorkerProcessFailure



/***************************************************************************++

Routine Description:

    Start the new worker process which will replace a currently running one.
    Once the new worker process is ready (or if it failed to start 
    correctly), we begin shutdown of the old worker process.

Arguments:

    pWorkerProcessToReplace - Pointer to the worker process to replace,
    once we have started its replacement. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::RequestReplacementWorkerProcess(
    IN WORKER_PROCESS * pWorkerProcessToReplace
    )
{

    HRESULT hr = S_OK;
    DWORD_PTR ProcessorMask = 0;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pWorkerProcessToReplace != NULL );


    //
    // Check to see if we should actually create the new replacement process. 
    //

    if ( ! IsOkToReplaceWorkerProcess() )
    {
        //
        // Signal to callers that we are not going to replace.
        //
        
        hr = E_FAIL;

        goto exit;
    }


    //
    // Get the affinity mask to use. This can fail if the affinity mask 
    // of the previous process is no longer valid, and so cannot be used
    // for the replacement process. 
    //

    hr = GetAffinityMaskForReplacementProcess(
                pWorkerProcessToReplace->GetProcessAffinityMask(),
                &ProcessorMask
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Can't replace process because the affinity mask of the previous process is no longer valid\n"
            ));

        goto exit;
    }


    //
    // Create a replacement. 
    //

    hr = CreateWorkerProcess( 
                ReplaceWorkerProcessStartReason, 
                pWorkerProcessToReplace, 
                ProcessorMask
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating worker process failed\n"
            ));

        goto exit;
    }


    //
    // Update counters.
    //

    m_TotalWorkerProcessRotations++;


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Total WP rotations: %lu for app pool (ptr: %p; id: %S)\n",
            m_TotalWorkerProcessRotations,
            this,
            GetAppPoolId()
            ));
    }


exit:

    return hr;
    
}   // APP_POOL::RequestReplacementWorkerProcess



/***************************************************************************++

Routine Description:

    Informs this app pool that one of its worker processes has 
    completed its start-up attempt. This means that the worker process has
    either reached the running state correctly, or suffered an error which
    prevented it from doing so (but was not fatal to the service as a whole). 

    This notification allows the app pool to do any processing that
    was pending on the start-up of a worker process.

Arguments:

    StartReason - The reason the worker process was started.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::WorkerProcessStartupAttemptDone(
    IN WORKER_PROCESS_START_REASON StartReason
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    switch( StartReason )
    {

    case ReplaceWorkerProcessStartReason:

        //
        // Nothing to do here.
        //

        break;


    case DemandStartWorkerProcessStartReason:

        //
        // See if we should start waiting for another demand start notification
        // from UL for this app pool.
        //

        hr = WaitForDemandStartIfNeeded();
        
        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Waiting for demand start notification if needed failed\n"
                ));

        }
        
        break;


    default:

        // invalid start reason!
        DBG_ASSERT( FALSE );
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    
        break;
        
    }


    return hr;
    
}   // APP_POOL::WorkerProcessStartupAttemptDone



/***************************************************************************++

Routine Description:

    Remove a worker process object from the list on this app pool object. 

Arguments:

    pWorkerProcess - The worker process object to remove.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::RemoveWorkerProcessFromList(
    IN WORKER_PROCESS * pWorkerProcess
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pWorkerProcess != NULL );


    RemoveEntryList( pWorkerProcess->GetListEntry() );
    ( pWorkerProcess->GetListEntry() )->Flink = NULL; 
    ( pWorkerProcess->GetListEntry() )->Blink = NULL; 

    m_WorkerProcessCount--;


    //
    // Clean up the reference to the worker process that the app 
    // pool holds. Because each worker process is reference counted, it 
    // will delete itself as soon as it's reference count hits zero.
    //

    pWorkerProcess->Dereference();


    //
    // See if we should start waiting for another demand start notification
    // from UL for this app pool.
    //

    hr = WaitForDemandStartIfNeeded();
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Waiting for demand start notification if needed failed\n"
            ));

    }


    //
    // See if shutdown is underway, and if so if it has completed now 
    // that this worker process is gone. 
    //
    
    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

        goto exit;
    }


exit:

    return hr;
    
}   // APP_POOL::RemoveWorkerProcessFromList



/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of this app pool, by telling all of its worker
    processes to shut down. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::Shutdown(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Update our state to remember that we are shutting down.
    //

    m_State = ShutdownPendingAppPoolState; 


    //
    // Remove this app pool from the main app pool table, and put
    // in on the shutdown list instead.
    //

    hr = GetWebAdminService()->GetUlAndWorkerManager()->TransferAppPoolFromTableToShutdownList( this );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Transferring app pool from table to shutdown list failed\n"
            ));

        goto exit;

    }


    //
    // Shut down the worker processes belonging to this app pool.
    //

    hr = ShutdownAllWorkerProcesses();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Shutting down worker processes for app pool failed\n"
            ));

        goto exit;
    }


    //
    // See if shutdown has already completed. This could happen if we have
    // no worker processes that need to go through the clean shutdown 
    // handshaking. 
    //
    
    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::Shutdown



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

    Note that this function may cause the instance to delete itself; 
    instance state should not be accessed when unwinding from this call. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::Terminate(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Only clean up if we haven't done so already.
    //

    if ( m_State != DeletePendingAppPoolState )
    {
        
        m_State = DeletePendingAppPoolState;


        while ( m_WorkerProcessCount > 0 )
        {
        
            pListEntry = m_WorkerProcessListHead.Flink;

            //
            // The list shouldn't be empty, since the count was greater than zero.
            //
            
            DBG_ASSERT( pListEntry != &m_WorkerProcessListHead );


            pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


            //
            // Terminate the worker process. Note that the worker process 
            // will call back to remove itself from this list inside this call.
            //

            pWorkerProcess->Terminate();

        }

        DBG_ASSERT( IsListEmpty( &m_WorkerProcessListHead ) );


        //
        // Note that closing the handle will cause the demand start i/o 
        // (if any) to complete as cancelled, allowing us to at that point
        // clean up its reference count.
        //
        
        if ( m_AppPoolHandle != NULL )
        {
            DBG_REQUIRE( CloseHandle( m_AppPoolHandle ) );
            m_AppPoolHandle = NULL;
        }


        //
        // Tell our parent to remove this instance from it's data structures,
        // and dereference the instance. 
        //

        switch ( GetAppPoolOwningDataStructure() )
        {

        case NoneAppPoolOwningDataStructure:

            //
            // Nothing to do.
            //

            break;

        case TableAppPoolOwningDataStructure:

            hr = GetWebAdminService()->GetUlAndWorkerManager()->RemoveAppPoolFromTable( this );

            if ( FAILED( hr ) )
            {

                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Removing app pool from table failed\n"
                    ));

            }

            break;

        case ShutdownListAppPoolOwningDataStructure:

            hr = GetWebAdminService()->GetUlAndWorkerManager()->RemoveAppPoolFromShutdownList( this );

            if ( FAILED( hr ) )
            {

                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Removing app pool from shutdown list failed\n"
                    ));

            }

            break;

        default:

            //
            // Invalid owning data structure! Someone must be holding
            // onto this instance.
            //

            DBG_ASSERT( FALSE );
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            break;

        }

        //
        // Note: that may have been our last reference, so don't do any
        // more work here.
        //

    }


    return;
    
}   // APP_POOL::Terminate



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the shutdown list LIST_ENTRY 
    pointer of a APP_POOL to the APP_POOL as a whole.

Arguments:

    pShutdownListEntry - A pointer to the m_ShutdownListEntry member of a 
    APP_POOL.

Return Value:

    The pointer to the containing APP_POOL.

--***************************************************************************/

// note: static!
APP_POOL *
APP_POOL::AppPoolFromShutdownListEntry(
    IN const LIST_ENTRY * pShutdownListEntry
)
{

    APP_POOL * pAppPool = NULL;

    DBG_ASSERT( pShutdownListEntry != NULL );

    //  get the containing structure, then verify the signature
    pAppPool = CONTAINING_RECORD(
                            pShutdownListEntry,
                            APP_POOL,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pAppPool->m_Signature == APP_POOL_SIGNATURE );

    return pAppPool;

}   // APP_POOL::AppPoolFromShutdownListEntry



/***************************************************************************++

Routine Description:

    A static class method to "upcast" from the delete list LIST_ENTRY 
    pointer of a APP_POOL to the APP_POOL as a whole.

Arguments:

    pDeleteListEntry - A pointer to the m_DeleteListEntry member of a 
    APP_POOL.

Return Value:

    The pointer to the containing APP_POOL.

--***************************************************************************/

// note: static!
APP_POOL *
APP_POOL::AppPoolFromDeleteListEntry(
    IN const LIST_ENTRY * pDeleteListEntry
)
{

    APP_POOL * pAppPool = NULL;

    DBG_ASSERT( pDeleteListEntry != NULL );

    //  get the containing structure, then verify the signature
    pAppPool = CONTAINING_RECORD(
                            pDeleteListEntry,
                            APP_POOL,
                            m_DeleteListEntry
                            );

    DBG_ASSERT( pAppPool->m_Signature == APP_POOL_SIGNATURE );

    return pAppPool;

}   // APP_POOL::AppPoolFromDeleteListEntry



/***************************************************************************++

Routine Description:

    Check whether this app pool should be waiting to receive demand start
    requests, and if so, issue the wait.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::WaitForDemandStartIfNeeded(
    )
{

    HRESULT hr = S_OK;


    //
    // Check to see if we are in a state where we should even bother 
    // waiting for a demand start notification.
    //

    if ( ! IsOkToCreateWorkerProcess() )
    {
        goto exit;
    }


    //
    // If we are already waiting for a demand start, don't wait again.
    //

    if ( m_WaitingForDemandStart )
    {
        goto exit;
    }


    hr = WaitForDemandStart();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Preparing to receive demand start notification failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::WaitForDemandStartIfNeeded



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
APP_POOL::DebugDump(
    )
{

    PLIST_ENTRY pListEntry = NULL;
    APPLICATION * pApplication = NULL;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "App pool (ptr: %p; id: %S)\n",
            this,
            GetAppPoolId()
            ));
    }
    

    //
    // List config for this app pool.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE )
    {

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart period (in minutes; zero means disabled): %lu\n",
            m_Config.PeriodicProcessRestartPeriodInMinutes
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Periodic restart request count (zero means disabled): %lu\n",
            m_Config.PeriodicProcessRestartRequestCount
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Max (steady state) process count: %lu\n",
            m_Config.MaxSteadyStateProcessCount
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--SMP affinitization enabled (zero means disabled): %lu\n",
            m_Config.SMPAffinitized
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--SMP affinitization processor mask: %p\n",
            m_Config.SMPAffinitizedProcessorMask
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Pinging enabled (zero means disabled): %lu\n",
            m_Config.PingingEnabled
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Idle timeout (zero means disabled): %lu\n",
            m_Config.IdleTimeoutInMinutes
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Rapid fail protection enabled (zero means disabled): %lu\n",
            m_Config.RapidFailProtectionEnabled
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Orphan processes for debugging enabled (zero means disabled): %lu\n",
            m_Config.OrphanProcessesForDebuggingEnabled
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Start worker processes as LocalSystem (zero means disabled): %lu\n",
            m_Config.StartWorkerProcessesAsLocalSystem
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Startup time limit (in seconds): %lu\n",
            m_Config.StartupTimeLimitInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Shutdown time limit (in seconds): %lu\n",
            m_Config.ShutdownTimeLimitInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Ping interval (in seconds): %lu\n",
            m_Config.PingIntervalInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Ping response time limit (in seconds): %lu\n",
            m_Config.PingResponseTimeLimitInSeconds
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Disallow overlapping rotation (zero means overlap is ok): %lu\n",
            m_Config.DisallowOverlappingRotation
            ));

        DBGPRINTF((
            DBG_CONTEXT, 
            "--Orphan action: %S\n",
            ( m_Config.pOrphanAction ? m_Config.pOrphanAction : L"<none>" )
            ));

    }

    //
    // List the applications of this app pool.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            ">>>>App pool's applications:\n"
            ));
    }


    pListEntry = m_ApplicationListHead.Flink;

    while ( pListEntry != &m_ApplicationListHead )
    {
    
        DBG_ASSERT( pListEntry != NULL );

        pApplication = APPLICATION::ApplicationFromAppPoolListEntry( pListEntry );


        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                ">>>>>>>>Application of site: %lu with path: %S\n",
                pApplication->GetApplicationId()->VirtualSiteId,
                pApplication->GetApplicationId()->pApplicationUrl
                ));
        }


        pListEntry = pListEntry->Flink;

    }


    return;
    
}   // APP_POOL::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Wait asynchronously for a demand start request from UL for this app 
    pool. This is done by posting an async i/o to UL. This i/o will be 
    completed by UL to request that a worker process be started for this
    app pool.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::WaitForDemandStart(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    WORK_ITEM * pWorkItem = NULL; 


    //
    // Create a work item to use for the async i/o, so that the resulting
    // work can be serviced on the main worker thread via the work queue.
    // 

    hr = GetWebAdminService()->GetWorkQueue()->GetBlankWorkItem( &pWorkItem );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not get a blank work item\n"
            ));

        goto exit;
    }


    pWorkItem->SetWorkDispatchPointer( this );
    
    pWorkItem->SetOpCode( DemandStartAppPoolWorkItem );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "About to issue demand start for app pool (ptr: %p; id: %S) using work item with serial number: %li\n",
            this,
            GetAppPoolId(),
            pWorkItem->GetSerialNumber()
            ));
    }


    Win32Error = UlWaitForDemandStart(
                        m_AppPoolHandle,            // app pool handle
                        NULL,                       // buffer (not needed)
                        0,                          // buffer length (not needed)
                        NULL,                       // bytes returned (not needed)
                        pWorkItem->GetOverlapped()  // OVERLAPPED
                        );

    if ( Win32Error != ERROR_IO_PENDING )
    {
        //
        // The UL api specifies that we always get pending here on success,
        // and so will receive a completion later (as opposed to potentially
        // completing immediately, with NO_ERROR). Assert just to confirm this.
        //

        DBG_ASSERT( Win32Error != NO_ERROR );


        hr = HRESULT_FROM_WIN32( Win32Error );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Issuing demand start async i/o failed\n"
            ));


        //
        // If queueing failed, free the work item here. (In the success case,
        // it will be freed once it is serviced.)
        //
        GetWebAdminService()->GetWorkQueue()->FreeWorkItem( pWorkItem );

        goto exit;
    }


    m_WaitingForDemandStart = TRUE;


exit:

    return hr;

}   // APP_POOL::WaitForDemandStart



/***************************************************************************++

Routine Description:

    Respond to a demand start request from UL by attempting to start a new 
    worker process.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::DemandStartWorkItem(
    )
{

    HRESULT hr = S_OK;


    //
    // Since we've come out of the wait for demand start, clear the flag.
    //

    m_WaitingForDemandStart = FALSE;


    //
    // Check to see if we should actually create the new process. 
    //

    if ( ! IsOkToCreateWorkerProcess() )
    {
        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Demand start request received for app pool (ptr: %p; id: %S); creating worker process\n",
            this,
            GetAppPoolId()
            ));
    }


    //
    // Create the process.
    //

    hr = CreateWorkerProcess( 
                DemandStartWorkerProcessStartReason, 
                NULL,
                GetAffinityMaskForNewProcess()
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Could not create worker process\n"
            ));


        //
        // We've made an effort to demand start a process. Generally this
        // won't fail, but in a weird case where it does (say for example
        // that the worker process exe can't find a dependent dll), then
        // don't treat this as a service-fatal error. Instead, return S_OK.
        //

        hr = S_OK;

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::DemandStartWorkItem



/***************************************************************************++

Routine Description:

    Check whether it is ok to create a new worker process. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if it is ok to create a worker process, FALSE if not.

--***************************************************************************/

BOOL
APP_POOL::IsOkToCreateWorkerProcess(
    )
    const
{

    BOOL OkToCreate = TRUE; 

    
    //
    // If we are in some state other than the normal running state (for
    // example, if we are shutting down), don't create more worker 
    // processes.
    //

    if ( m_State != RunningAppPoolState )
    {
        OkToCreate = FALSE; 
    }


    //
    // Don't create new processes if we would exceed the configured limit.
    //

    if ( m_WorkerProcessCount >= m_AdjustedMaxSteadyStateProcessCount )
    {
        OkToCreate = FALSE; 
    }


    //
    // If the system is experiencing extreme memory pressure, then 
    // don't worsen the situation by creating more worker processes.
    // 

    if ( GetWebAdminService()->GetLowMemoryDetector()->IsSystemInLowMemoryCondition() )
    {
        OkToCreate = FALSE; 
    }


    return OkToCreate; 

}   // APP_POOL::IsOkToCreateWorkerProcess



/***************************************************************************++

Routine Description:

    Check whether it is ok to replace a worker process. 

Arguments:

    None.

Return Value:

    BOOL - TRUE if it is ok to replace a worker process, FALSE if not.

--***************************************************************************/

BOOL
APP_POOL::IsOkToReplaceWorkerProcess(
    )
    const
{

    BOOL OkToReplace = TRUE; 
    ULONG ProcessesGoingAwaySoon = 0;
    ULONG SteadyStateProcessCount = 0;

    
    //
    // If we are in some state other than the normal running state (for
    // example, if we are shutting down), don't replace processes.
    //

    if ( m_State != RunningAppPoolState )
    {
        OkToReplace = FALSE; 

        goto exit;
    }


    if ( m_Config.DisallowOverlappingRotation )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "For app pool (ptr: %p; id: %S), disallowing replace because overlapping replacement not allowed\n",
                this,
                GetAppPoolId()
                ));
        }

        OkToReplace = FALSE; 

        goto exit;
    }


    //
    // If the maximum number of processes has been adjusted down on 
    // the fly, we disallow replacement of processes while the steady
    // state process count remains over the new maximum. (This will
    // casue a process requesting replacement to instead just spin 
    // down, helping us throttle down to the new max.) To do this, we 
    // check the current number of processes that are *not* being 
    // replaced against the current max. 
    //

    ProcessesGoingAwaySoon = GetCountOfProcessesGoingAwaySoon();

    SteadyStateProcessCount = m_WorkerProcessCount - ProcessesGoingAwaySoon;

    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "For app pool (ptr: %p; id: %S), total WPs: %lu; steady state WPs: %lu; WPs going away soon: %lu; max steady state allowed: %lu\n",
            this,
            GetAppPoolId(),
            m_WorkerProcessCount,
            SteadyStateProcessCount,
            ProcessesGoingAwaySoon,
            m_AdjustedMaxSteadyStateProcessCount
            ));
    }


    if ( SteadyStateProcessCount > m_AdjustedMaxSteadyStateProcessCount )
    {

        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "For app pool (ptr: %p; id: %S), disallowing replace because we are over the process count limit\n",
                this,
                GetAppPoolId()
                ));
        }

        OkToReplace = FALSE; 

        goto exit;
    }


exit:

    return OkToReplace; 

}   // APP_POOL::IsOkToReplaceWorkerProcess



/***************************************************************************++

Routine Description:

    Determine the set of worker processes that are currently being replaced.

Arguments:

    None.

Return Value:

    ULONG - The count of processes being replaced. 

--***************************************************************************/

ULONG
APP_POOL::GetCountOfProcessesGoingAwaySoon(
    )
    const
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    ULONG ProcessesGoingAwaySoon = 0;


    //
    // Count the number of processes being replaced.
    //


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        if ( pWorkerProcess->IsGoingAwaySoon() )
        {
            ProcessesGoingAwaySoon++;
        }


        pListEntry = pNextListEntry;
        
    }


    return ProcessesGoingAwaySoon;

}   // APP_POOL::GetCountOfProcessesGoingAwaySoon



/***************************************************************************++

Routine Description:

    Create a new worker process for this app pool.

Arguments:

    StartReason - The reason the worker process is being started.

    pWorkerProcessToReplace - If the worker process is being created to replace
    an existing worker process, this parameter identifies that predecessor 
    process; NULL otherwise.

    ProcessAffinityMask - If this worker process is to run on a particular
    processor, this mask specifies which one. If this parameter is zero, this 
    worker process will not be affinitized. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::CreateWorkerProcess(
    IN WORKER_PROCESS_START_REASON StartReason,
    IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL,
    IN DWORD_PTR ProcessAffinityMask OPTIONAL
    )
{

    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pWorkerProcess = new WORKER_PROCESS( 
                                this,
                                StartReason,
                                pWorkerProcessToReplace,
                                ProcessAffinityMask
                                );

    if ( pWorkerProcess == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating WORKER_PROCESS failed\n"
            ));


        //
        // If we couldn't even create the object, then it certainly isn't
        // going to be able to tell us when it's startup attempt is done;
        // so instead we attempt to do it here.
        //

        hr2 = WorkerProcessStartupAttemptDone( DemandStartWorkerProcessStartReason );

        if ( FAILED( hr2 ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr2,
                "Notifying that worker process startup attempt is done failed\n"
                ));

        }


        goto exit;
    }


    InsertHeadList( &m_WorkerProcessListHead, pWorkerProcess->GetListEntry() );
    m_WorkerProcessCount++;


    hr = pWorkerProcess->Initialize();
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing worker process object failed\n"
            ));

        //
        // Note that if worker process initialization fails, it will
        // mark itself as terminally ill, and terminate itself. That
        // Terminate method will call back into this app pool instance
        // to remove it from the datastructure, and dereference it.
        //

        goto exit;
    }


exit:

    return hr;
    
}   // APP_POOL::CreateWorkerProcess



/***************************************************************************++

Routine Description:

    Determine what affinity mask to use for a new process. If we are running
    in SMP affinitized mode, then find an unused processor. Otherwise, 
    return an empty mask. 

Arguments:

    None.

Return Value:

    DWORD_PTR - The new affinity mask to use. 

--***************************************************************************/

DWORD_PTR
APP_POOL::GetAffinityMaskForNewProcess(
    )
    const
{

    if ( m_Config.SMPAffinitized )
    {

        //
        // Find a free processor for this new worker process.
        //

        return ChooseFreeProcessor();

    }
    else
    {

        //
        // We are not running affinitized, so use the empty mask.
        //

        return 0;

    }

}   // APP_POOL::GetAffinityMaskForNewProcess



/***************************************************************************++

Routine Description:

    Find an unused processor for a new worker process.

Arguments:

    None.

Return Value:

    DWORD_PTR - The new affinity mask to use. 

--***************************************************************************/

DWORD_PTR
APP_POOL::ChooseFreeProcessor(
    )
    const
{

    DWORD_PTR ProcessorsCurrentlyInUse = 0;
    DWORD_PTR AvailableProcessorsNotInUse = 0;
    DWORD_PTR ProcessorMask = 1;


    //
    // Find the set of processors that we are allowed to use, but that
    // are not currently in use.
    //

    ProcessorsCurrentlyInUse = GetProcessorsCurrentlyInUse();

    AvailableProcessorsNotInUse = m_AvailableProcessorMask & ( ~ ProcessorsCurrentlyInUse );


    //
    // There should be at least one free processor.
    //
    
    DBG_ASSERT( CountOfBitsSet( AvailableProcessorsNotInUse ) >= 1 );


    //
    // Now find a free processor.
    //

    while ( ProcessorMask )
    {
    
        if ( AvailableProcessorsNotInUse & ProcessorMask )
        {
            break;
        }

        ProcessorMask <<= 1;
        
    }


    DBG_ASSERT( ProcessorMask != 0 );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "SMP affinitization: processors currently in use: %p; available processors not in use: %p; free processor selected: %p\n",
            ProcessorsCurrentlyInUse,
            AvailableProcessorsNotInUse,
            ProcessorMask
            ));
    }


    return ProcessorMask;

}   // APP_POOL::ChooseFreeProcessor



/***************************************************************************++

Routine Description:

    Determine the set of processors in currently in use by worker processes
    of this app pool.

Arguments:

    None.

Return Value:

    DWORD_PTR - The set of processors in use. 

--***************************************************************************/

DWORD_PTR
APP_POOL::GetProcessorsCurrentlyInUse(
    )
    const
{

    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;
    DWORD_PTR ProcessorsCurrentlyInUse = 0;


    //
    // Logical OR the affinity masks of all current worker processes of this
    // app pool together, in order to get the set of processors in use.
    //


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Update the mask. Note that some processes might be affinitized to 
        // the same processor. This is because during process rotation, the 
        // replacement process will start up with the same affinitization as
        // the process it is retiring. Also note that a process which is not
        // affinitized will return 0 for its mask, which does the right thing.
        //

        ProcessorsCurrentlyInUse |= pWorkerProcess->GetProcessAffinityMask();


        pListEntry = pNextListEntry;
        
    }


    return ProcessorsCurrentlyInUse;

}   // APP_POOL::GetProcessorsCurrentlyInUse



/***************************************************************************++

Routine Description:

    Determine what affinity mask to use for a replacement process. 

Arguments:

    PreviousProcessAffinityMask - The process affinity mask for the process
    being replaced.

    pReplacementProcessAffinityMask - The process affinity mask to use for
    the replacement process.

Return Value:

    HRESULT 

--***************************************************************************/

HRESULT
APP_POOL::GetAffinityMaskForReplacementProcess(
    IN DWORD_PTR PreviousProcessAffinityMask,
    OUT DWORD_PTR * pReplacementProcessAffinityMask
    )
    const
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pReplacementProcessAffinityMask != NULL );


    //
    // Initialize output parameters.
    //

    *pReplacementProcessAffinityMask = 0;


    if ( m_Config.SMPAffinitized )
    {

        //
        // Affinitization is on. 
        //

        if ( ! PreviousProcessAffinityMask )
        {

            //
            // The previous process was not affinitized. Find a free 
            // processor to affinitize this replacement worker process. 
            // There should always be one available in this case (since
            // we know that if we made it this far, then the current 
            // steady state count of processes is within the bounds set
            // by the available processor mask; so there must be at least
            // one processor that has no processes affinitized to it).
            //

            *pReplacementProcessAffinityMask = ChooseFreeProcessor();

        }
        else if ( PreviousProcessAffinityMask & m_AvailableProcessorMask )
        {
        
            //
            // The old mask is still valid. Follow suit with the new one.
            //

            *pReplacementProcessAffinityMask = PreviousProcessAffinityMask;
            
        }
        else
        {
            //
            // The old mask is no longer valid. Signal to callers that we 
            // are not going to replace.
            //

            hr = E_FAIL;

            IF_DEBUG( WEB_ADMIN_SERVICE )
            {
                DBGPRINTF((
                    DBG_CONTEXT, 
                    "For app pool (ptr: %p; id: %S), not replacing worker process because its affinity mask is no longer valid\n",
                    this,
                    GetAppPoolId()
                    ));
            }

        }

    }
    else
    {

        //
        // We are not running affinitized, so use the empty mask.
        //

        *pReplacementProcessAffinityMask = 0;

    }


    return hr;

}   // APP_POOL::GetAffinityMaskForReplacementProcess



/***************************************************************************++

Routine Description:

    Look up a WORKER_PROCESS object associated with this app pool by
    process id.

Arguments:

    ProcessId - The process id of the worker process to locate.

Return Value:

    WORKER_PROCESS * - Pointer to the located WORKER_PROCESS, or NULL if not
    found.

--***************************************************************************/

WORKER_PROCESS *
APP_POOL::FindWorkerProcess(
    IN DWORD ProcessId
    )
{

    PLIST_ENTRY pListEntry = m_WorkerProcessListHead.Flink;
    WORKER_PROCESS * pWorkerProcess = NULL;
    BOOL FoundIt = FALSE;
    

    while ( pListEntry != &m_WorkerProcessListHead )
    {
    
        DBG_ASSERT( pListEntry != NULL );

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );

        if ( pWorkerProcess->GetProcessId() == ProcessId )
        {
            FoundIt = TRUE;
            break;
        }

        pListEntry = pListEntry->Flink;

    }


    return ( FoundIt ? pWorkerProcess : NULL );
    
}   // APP_POOL::FindWorkerProcess



/***************************************************************************++

Routine Description:

    Activate this app pool in UL. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::PutInService(
    )
{

    HRESULT hr = S_OK;


    //
    // CODEWORK To be implemented.
    //


    return hr;

}   // APP_POOL::PutInService



/***************************************************************************++

Routine Description:

    Dectivate this app pool in UL, and shut down any running worker 
    processes. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::PutOutOfService(
    )
{

    HRESULT hr = S_OK;


    //
    // CODEWORK To be implemented: put the app pool out of service in UL.
    // w.r.t. UL cache entries, we are relying on cache entries going 
    // away when the owning process does.
    //


    //
    // CODEWORK make sure the config store is updated appropriately. 
    //


    //
    // Shut down any worker processes currently running.
    //

    hr = ShutdownAllWorkerProcesses();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Shutting down app pool's worker processes failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // APP_POOL::PutOutOfService



/***************************************************************************++

Routine Description:

    Shut down all worker processes serving this app pool.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ShutdownAllWorkerProcesses(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Shutdown the worker process. Note that the worker process will
        // eventually clean itself up and remove itself from this list;
        // this could happen later, but it also could happen immediately!
        // This is the reason we captured the next list entry pointer 
        // above, instead of trying to access the memory after the object
        // may have gone away.
        //

        hr = pWorkerProcess->Shutdown();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Shutdown of worker process failed\n"
                ));

            //
            // Press on in the face of errors on a particular worker process.
            //

            hr = S_OK;
        }

        pListEntry = pNextListEntry;
        
    }


    return hr;

}   // APP_POOL::ShutdownAllWorkerProcesses



/***************************************************************************++

Routine Description:

    Rotate all worker processes serving this app pool.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::ReplaceAllWorkerProcesses(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    WORKER_PROCESS * pWorkerProcess = NULL;


    pListEntry = m_WorkerProcessListHead.Flink;


    while ( pListEntry != &m_WorkerProcessListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pWorkerProcess = WORKER_PROCESS::WorkerProcessFromListEntry( pListEntry );


        //
        // Tell the worker process to get itself replaced.
        //

        hr = pWorkerProcess->InitiateReplacement();

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Initiating process replacement failed\n"
                ));

            //
            // Press on in the face of errors on a particular worker process.
            //

            hr = S_OK;
        }

        pListEntry = pNextListEntry;
        
    }


    return hr;

}   // APP_POOL::ReplaceAllWorkerProcesses



/***************************************************************************++

Routine Description:

    See if shutdown is underway. If it is, see if shutdown has finished. If
    it has, clean up this instance. 

    Note that this function may cause the instance to delete itself; 
    instance state should not be accessed when unwinding from this call. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
APP_POOL::CheckIfShutdownUnderwayAndNowCompleted(
    )
{

    HRESULT hr = S_OK;


    //
    // Are we shutting down?
    //

    if ( m_State == ShutdownPendingAppPoolState )
    {

        //
        // If so, have all the worker processes gone away, meaning that 
        // we are done?
        //

        if ( m_WorkerProcessCount == 0 )
        {

            //
            // Clean up this instance.
            //

            Terminate();

        }

    }


    return hr;

}   // APP_POOL::CheckIfShutdownUnderwayAndNowCompleted



/***************************************************************************++

Routine Description:

    Return the count of bits set to 1 in the input parameter. 

Arguments:

    Value - The target value on which to count set bits. 

Return Value:

    ULONG - The number of bits that were set. 

--***************************************************************************/

ULONG
CountOfBitsSet(
    IN DWORD_PTR Value
    )
{

    ULONG Count = 0;


    //
    // Note: designed to work independent of the size in bits of the value.
    //

    while ( Value )
    {
    
        if ( Value & 1 )
        {
            Count++;
        }

        Value >>= 1;
        
    }

    return Count;

}   // CountOfBitsSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\archive\shutdownlist\ul_and_worker_manager.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ul_and_worker_manager.h

Abstract:

    The IIS web admin service UL and worker manager class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _UL_AND_WORKER_MANAGER_H_
#define _UL_AND_WORKER_MANAGER_H_



//
// forward references
//

class WEB_ADMIN_SERVICE;



//
// common #defines
//

#define UL_AND_WORKER_MANAGER_SIGNATURE         CREATE_SIGNATURE( 'ULWM' )
#define UL_AND_WORKER_MANAGER_SIGNATURE_FREED   CREATE_SIGNATURE( 'ulwX' )



//
// structs, enums, etc.
//

// UL&WM states
typedef enum _UL_AND_WORKER_MANAGER_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedUlAndWorkerManagerState = 1,

    //
    // The UL&WM is running normally.
    //
    RunningUlAndWorkerManagerState,

    //
    // The UL&WM is shutting down. It may be waiting for it's 
    // app pools to shut down too. 
    //
    ShutdownPendingUlAndWorkerManagerState,

    //
    // The UL&WM is now doing it's termination cleanup work. 
    //
    TerminatingUlAndWorkerManagerState,

} UL_AND_WORKER_MANAGER_STATE;



//
// prototypes
//

class UL_AND_WORKER_MANAGER
{

public:

    UL_AND_WORKER_MANAGER(
        );

    ~UL_AND_WORKER_MANAGER(
        );

    HRESULT
    Initialize(
        );

    HRESULT
    CreateAppPool(
        IN LPCWSTR pAppPoolId,
        IN APP_POOL_CONFIG * pAppPoolConfig
        );

    HRESULT
    CreateVirtualSite(
        IN DWORD VirtualSiteId,
        IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig
        );

    HRESULT
    CreateApplication(
        IN DWORD VirtualSiteId,
        IN LPCWSTR pApplicationUrl,
        IN DWORD AppIndex,
        IN APPLICATION_CONFIG * pApplicationConfig
        );

    HRESULT
    DeleteAppPool(
        IN LPCWSTR pAppPoolId
        );

    HRESULT
    DeleteVirtualSite(
        IN DWORD VirtualSiteId
        );

    HRESULT
    DeleteApplication(
        IN DWORD VirtualSiteId,
        IN LPCWSTR pApplicationUrl
        );

    HRESULT
    ModifyAppPool(
        IN LPCWSTR pAppPoolId,
        IN APP_POOL_CONFIG * pNewAppPoolConfig,
        IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged
        );

    HRESULT
    ModifyVirtualSite(
        IN DWORD VirtualSiteId,
        IN VIRTUAL_SITE_CONFIG * pNewVirtualSiteConfig,
        IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged
        );

    HRESULT
    ModifyApplication(
        IN DWORD VirtualSiteId,
        IN LPCWSTR pApplicationUrl,
        IN APPLICATION_CONFIG * pNewApplicationConfig,
        IN APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged
        );

    HRESULT
    ActivateUl(
        );

    HRESULT
    DeactivateUl(
        );

    inline
    HANDLE
    GetUlControlChannel(
        )
        const
    {
        DBG_ASSERT( m_UlControlChannel != NULL );
        return m_UlControlChannel;
    }

    HRESULT
    Shutdown(
        );

    VOID
    Terminate(
        );

#if DBG
    VOID
    DebugDump(
        );
#endif  // DBG

    HRESULT
    RemoveAppPoolFromTable(
        IN APP_POOL * pAppPool
        );

    HRESULT
    TransferAppPoolFromTableToShutdownList(
        IN APP_POOL * pAppPool
        );

    HRESULT
    RemoveAppPoolFromShutdownList(
        IN APP_POOL * pAppPool
        );

    HRESULT
    LeavingLowMemoryCondition(
        );


private:

    HRESULT
    SetUlMasterState(
        IN UL_ENABLED_STATE NewState
        );

    HRESULT
    CheckIfShutdownUnderwayAndNowCompleted(
        );


    DWORD m_Signature;

    // object state
    UL_AND_WORKER_MANAGER_STATE m_State;

    // hashtable of app pools
    APP_POOL_TABLE m_AppPoolTable;

    //
    // List of app pools that are in the process of being shut down. 
    // We need to remove these from the main table, to prevent race 
    // conditions. For example, someone could delete an app pool, 
    // then re-add an app pool with the same name immediately after. 
    // If the original app pool hasn't shut down yet, then the two 
    // id's will conflict in the table.
    //
    LIST_ENTRY m_AppPoolShutdownListHead;
    ULONG m_AppPoolShutdownCount;

    // hashtable of virtual sites
    VIRTUAL_SITE_TABLE m_VirtualSiteTable;

    // hashtable of applications
    APPLICATION_TABLE m_ApplicationTable;

    // has UL been initialized
    BOOL m_UlInitialized;

    // UL control
    HANDLE m_UlControlChannel;


};  // class UL_AND_WORKER_MANAGER



#endif  // _UL_AND_WORKER_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\archive\shutdownlist\app_pool.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    app_pool.h

Abstract:

    The IIS web admin service app pool class definition.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/


#ifndef _APP_POOL_H_
#define _APP_POOL_H_



//
// forward references
//

class WORKER_PROCESS;
class UL_AND_WORKER_MANAGER;



//
// common #defines
//

#define APP_POOL_SIGNATURE       CREATE_SIGNATURE( 'APOL' )
#define APP_POOL_SIGNATURE_FREED CREATE_SIGNATURE( 'apoX' )


//
// BUGBUG Come up with real default settings. 
//


//
// If there are this many worker process failures in this time window
// for a particular app pool, then we take action.
//

#define RAPID_REPEATED_FAILURE_LIMIT 5
#define RAPID_REPEATED_FAILURE_TIME_WINDOW  ( 10 * 60 * 1000 )  // 10 minutes



//
// structs, enums, etc.
//

//
// App pool states.
//

typedef enum _APP_POOL_STATE
{

    //
    // The object is not yet initialized.
    //
    UninitializedAppPoolState = 1,

    //
    // The app pool is running normally.
    //
    RunningAppPoolState,

    //
    // The app pool is shutting down. It may be waiting for it's 
    // worker processes to shut down too. 
    //
    ShutdownPendingAppPoolState,

    //
    // This object instance can go away as soon as it's reference 
    // count hits zero.
    //
    DeletePendingAppPoolState,

} APP_POOL_STATE;

//
// Which data structure owns the app pool.
//

typedef enum _APP_POOL_OWNING_DATA_STRUCTURE
{

    //
    // The app pool is not contained in any parent data structure.
    //
    NoneAppPoolOwningDataStructure = 1,

    //
    // The app pool is in the normal app pool table.
    //
    TableAppPoolOwningDataStructure,

    //
    // The app pool is in the list of app pools shutting down. 
    //
    ShutdownListAppPoolOwningDataStructure,

} APP_POOL_OWNING_DATA_STRUCTURE;


//
// Reasons to start a worker process.
//

typedef enum _WORKER_PROCESS_START_REASON
{

    //
    // Starting because of a demand start notification from UL.
    //
    DemandStartWorkerProcessStartReason = 1,

    //
    // Starting as a replacement for an another running worker process.
    //
    ReplaceWorkerProcessStartReason,

} WORKER_PROCESS_START_REASON;


// APP_POOL work items
typedef enum _APP_POOL_WORK_ITEM
{

    //
    // Process a request from UL to demand start a new worker process.
    //
    DemandStartAppPoolWorkItem = 1,
    
} APP_POOL_WORK_ITEM;


//
// App pool configuration.
//

typedef struct _APP_POOL_CONFIG
{

    //
    // How often to rotate worker processes based on time, in minutes. 
    // Zero means disabled.
    //
    ULONG PeriodicProcessRestartPeriodInMinutes;

    //
    // How often to rotate worker processes based on requests handled. 
    // Zero means disabled.
    //
    ULONG PeriodicProcessRestartRequestCount;

    //
    // The maximum number of worker processes (in a steady state; 
    // transiently, there may be more than this number running during 
    // process rotation). In a typical configuration this is set to one. 
    // A number greater than one is used for web gardens.
    //
    ULONG MaxSteadyStateProcessCount;

    //
    // Whether worker processes for this app pool should be hard affinitized 
    // to processors. If this option is enabled, then the max steady state
    // process count is cropped down to the number of processors configured 
    // to be used (if the configured max exceeds that count of processors). 
    // Non-zero means enabled. Zero means disabled. 
    //
    ULONG SMPAffinitized;

    //
    // If this app pool is running in SMP affinitized mode, this mask can be
    // used to limit which of the processors on the machine are used by this
    // app pool. 
    //
    DWORD_PTR SMPAffinitizedProcessorMask;

    //
    // Whether pinging is enabled. Non-zero means enabled.
    // Zero means disabled.
    //
    ULONG PingingEnabled;

    //
    // The idle timeout period for worker processes, in minutes. 
    // Zero means disabled.
    //
    ULONG IdleTimeoutInMinutes;

    //
    // Whether rapid, repeated failure protection is enabled (by 
    // automatically putting the app pool out of service in such cases.)
    // Non-zero means enabled. Zero means disabled.
    //
    ULONG RapidFailProtectionEnabled;

    //
    // Whether orphaning of worker processes for debugging is enabled. 
    // Non-zero means enabled. Zero means disabled.
    //
    ULONG OrphanProcessesForDebuggingEnabled;

    //
    // Whether to start worker processes under the LocalSystem token,
    // as opposed to the normal limited privilege token. Non-zero means
    // use LocalSystem; zero means use the limited privilege token. 
    //
    ULONG StartWorkerProcessesAsLocalSystem;

    //
    // How long a worker process is given to start up, in seconds. 
    // This is measured from when the process is launched, until it
    // registers with the Web Admin Service. 
    //
    ULONG StartupTimeLimitInSeconds;

    //
    // How long a worker process is given to shut down, in seconds. 
    // This is measured from when the process is asked to shut down, 
    // until it finishes and exits. 
    //
    ULONG ShutdownTimeLimitInSeconds;

    //
    // The ping interval for worker processes, in seconds. 
    // This is the interval between ping cycles. This value is ignored
    // if pinging is not enabled. 
    //
    ULONG PingIntervalInSeconds;

    //
    // The ping response time limit for worker processes, in seconds. 
    // This value is ignored if pinging is not enabled. 
    //
    ULONG PingResponseTimeLimitInSeconds;

    //
    // Whether a replacement worker process can be created while the
    // one being replaced is still alive. Non-zero means this overlap
    // is not allowed; zero means it is allowed.
    //
    ULONG DisallowOverlappingRotation;

    //
    // The command to run on an orphaned worker process. Only used
    // if orphaning is enabled, and if this field is non-NULL.
    //
    LPWSTR pOrphanAction;

} APP_POOL_CONFIG;


//
// App pool configuration change flags.
//

typedef struct _APP_POOL_CONFIG_CHANGE_FLAGS
{

    DWORD_PTR PeriodicProcessRestartPeriodInMinutes : 1;
    DWORD_PTR PeriodicProcessRestartRequestCount : 1;
    DWORD_PTR MaxSteadyStateProcessCount : 1;
    DWORD_PTR SMPAffinitized : 1;
    DWORD_PTR SMPAffinitizedProcessorMask : 1;
    DWORD_PTR PingingEnabled : 1;
    DWORD_PTR IdleTimeoutInMinutes : 1;
    DWORD_PTR RapidFailProtectionEnabled : 1;
    DWORD_PTR OrphanProcessesForDebuggingEnabled : 1;
    DWORD_PTR StartWorkerProcessesAsLocalSystem : 1;
    DWORD_PTR StartupTimeLimitInSeconds : 1;
    DWORD_PTR ShutdownTimeLimitInSeconds : 1;
    DWORD_PTR PingIntervalInSeconds : 1;
    DWORD_PTR PingResponseTimeLimitInSeconds : 1;
    DWORD_PTR DisallowOverlappingRotation : 1;
    DWORD_PTR pOrphanAction : 1;

} APP_POOL_CONFIG_CHANGE_FLAGS;



//
// prototypes
//

class APP_POOL
    : public WORK_DISPATCH
{

public:

    APP_POOL(
        );

    ~APP_POOL(
        );

    virtual
    VOID
    Reference(
        );

    virtual
    VOID
    Dereference(
        );

    virtual
    HRESULT
    ExecuteWorkItem(
        IN const WORK_ITEM * pWorkItem
        );

    HRESULT
    Initialize(
        IN LPCWSTR pAppPoolId,
        IN APP_POOL_CONFIG * pAppPoolConfig
        );

    HRESULT
    SetConfiguration(
        IN APP_POOL_CONFIG * pAppPoolConfig,
        IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged OPTIONAL
        );

    inline
    VOID
    MarkAppPoolOwningDataStructure(
        IN APP_POOL_OWNING_DATA_STRUCTURE OwningDataStructure
        )
    { m_OwningDataStructure = OwningDataStructure; }

    inline
    APP_POOL_OWNING_DATA_STRUCTURE
    GetAppPoolOwningDataStructure(
        )
        const
    { return m_OwningDataStructure; }

    inline
    LPCWSTR
    GetAppPoolId(
        )
        const
    { return m_pAppPoolId; }

    inline
    HANDLE
    GetAppPoolHandle(
        )
        const
    { return m_AppPoolHandle; }

    inline
    ULONG
    GetPeriodicProcessRestartPeriodInMinutes(
        )
        const
    { return m_Config.PeriodicProcessRestartPeriodInMinutes; }

    inline
    ULONG
    GetPeriodicProcessRestartRequestCount(
        )
        const
    { return m_Config.PeriodicProcessRestartRequestCount; }

    inline
    BOOL
    IsPingingEnabled(
        )
        const
    { return ( BOOL ) m_Config.PingingEnabled; }

    inline
    ULONG
    GetPingIntervalInSeconds(
        )
        const
    { return m_Config.PingIntervalInSeconds; }

    inline
    ULONG
    GetPingResponseTimeLimitInSeconds(
        )
        const
    { return m_Config.PingResponseTimeLimitInSeconds; }

    inline
    ULONG
    GetStartupTimeLimitInSeconds(
        )
        const
    { return m_Config.StartupTimeLimitInSeconds; }

    inline
    ULONG
    GetShutdownTimeLimitInSeconds(
        )
        const
    { return m_Config.ShutdownTimeLimitInSeconds; }

    inline
    BOOL
    IsOrphaningProcessesForDebuggingEnabled(
        )
        const
    { return ( BOOL ) m_Config.OrphanProcessesForDebuggingEnabled; }

    inline
    LPWSTR
    GetOrphanAction(
        )
        const
    { return m_Config.pOrphanAction; }

    inline
    BOOL
    StartWorkerProcessesAsLocalSystem(
        )
        const
    { return ( BOOL ) m_Config.StartWorkerProcessesAsLocalSystem; }

    inline
    ULONG
    GetIdleTimeoutInMinutes(
        )
        const
    { return m_Config.IdleTimeoutInMinutes; }

    HRESULT
    AssociateApplication(
        IN APPLICATION * pApplication
        );

    HRESULT
    DissociateApplication(
        IN APPLICATION * pApplication
        );

    HRESULT
    ReportWorkerProcessFailure(
        );

    HRESULT
    RequestReplacementWorkerProcess(
        IN WORKER_PROCESS * pWorkerProcessToReplace
        );

    HRESULT
    WorkerProcessStartupAttemptDone(
        IN WORKER_PROCESS_START_REASON StartReason
        );

    HRESULT
    RemoveWorkerProcessFromList(
        IN WORKER_PROCESS * pWorkerProcess
        );
        
    HRESULT
    Shutdown(
        );

    VOID
    Terminate(
        );

    inline
    PLIST_ENTRY
    GetShutdownListEntry(
        )
    { return &m_ShutdownListEntry; }

    static
    APP_POOL *
    AppPoolFromShutdownListEntry(
        IN const LIST_ENTRY * pShutdownListEntry
        );

    inline
    PLIST_ENTRY
    GetDeleteListEntry(
        )
    { return &m_DeleteListEntry; }

    static
    APP_POOL *
    AppPoolFromDeleteListEntry(
        IN const LIST_ENTRY * pDeleteListEntry
        );

    HRESULT
    WaitForDemandStartIfNeeded(
        );


#if DBG
    VOID
    DebugDump(
        );
#endif  // DBG


private:

    HRESULT
    WaitForDemandStart(
        );

    HRESULT
    DemandStartWorkItem(
        );

    BOOL
    IsOkToCreateWorkerProcess(
        )
        const;

    BOOL
    IsOkToReplaceWorkerProcess(
        )
        const;

    ULONG
    GetCountOfProcessesGoingAwaySoon(
        )
        const;

    HRESULT
    CreateWorkerProcess(
        IN WORKER_PROCESS_START_REASON StartReason,
        IN WORKER_PROCESS * pWorkerProcessToReplace OPTIONAL,
        IN DWORD_PTR ProcessAffinityMask OPTIONAL
        );

    DWORD_PTR
    GetAffinityMaskForNewProcess(
        )
        const;

    DWORD_PTR
    ChooseFreeProcessor(
        )
        const;

    DWORD_PTR
    GetProcessorsCurrentlyInUse(
        )
        const;

    HRESULT
    GetAffinityMaskForReplacementProcess(
        IN DWORD_PTR PreviousProcessAffinityMask,
        OUT DWORD_PTR * pReplacementProcessAffinityMask
        )
        const;

    //
    // BUGBUG This method isn't currently used. Do we need it?
    //
    WORKER_PROCESS *
    FindWorkerProcess(
        IN DWORD ProcessId
        );

    HRESULT
    PutInService(
        );

    HRESULT
    PutOutOfService(
        );

    HRESULT
    ShutdownAllWorkerProcesses(
        );

    HRESULT
    ReplaceAllWorkerProcesses(
        );

    HRESULT
    CheckIfShutdownUnderwayAndNowCompleted(
        );


    DWORD m_Signature;

    LONG m_RefCount;

    APP_POOL_STATE m_State;

    APP_POOL_OWNING_DATA_STRUCTURE m_OwningDataStructure;

    LPWSTR m_pAppPoolId;

    APP_POOL_CONFIG m_Config;

    // UL app pool handle
    HANDLE m_AppPoolHandle;

    BOOL m_WaitingForDemandStart;

    // worker processes for this app pool
    LIST_ENTRY m_WorkerProcessListHead;
    ULONG m_WorkerProcessCount;

    //
    // The maximum number of worker processes (in a steady state; 
    // transiently, there may be more than this number running during 
    // process rotation). In a typical configuration this is set to one. 
    // A number greater than one is used for web gardens. This value is
    // initialized to the value for max processes set in the configuration 
    // store, unless the app pool is running in SMP affinitized mode, in  
    // which case the number is capped at the number of processors configured 
    // to be used. 
    //
    ULONG m_AdjustedMaxSteadyStateProcessCount;

    //
    // A mask of which processors are available for use by this app pool, 
    // used for the SMP affinitized case. A bit set to 1 means that the 
    // processor may be used; a bit set to 0 means that it may not. 
    //
    DWORD_PTR m_AvailableProcessorMask;

    // applications associated with this app pool
    //
    // BUGBUG do we really need to keep a list, or just the various counts?
    //
    LIST_ENTRY m_ApplicationListHead;
    ULONG m_ApplicationCount;
    
    //
    // CODEWORK eventually add ULONG m_StoppedApplicationCount to know
    // when to shut down the app pool because no applications 
    // are active in it.
    //

    // number of planned process rotations done
    ULONG m_TotalWorkerProcessRotations;

    // keep track of worker process failures
    ULONG m_TotalWorkerProcessFailures;
    
    ULONG m_RecentWorkerProcessFailures;
    DWORD m_RecentFailuresWindowBeganTickCount;
    
    // used for keeping the list of APP_POOLs that are shutting down
    LIST_ENTRY m_ShutdownListEntry;
    
    // used for building a list of APP_POOLs to delete
    LIST_ENTRY m_DeleteListEntry;


};  // class APP_POOL



#endif  // _APP_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\archive\metabase\config_manager.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    config_manager.h

Abstract:

    The IIS web admin service configuration manager class definition.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/


#ifndef _CONFIG_MANAGER_H_
#define _CONFIG_MANAGER_H_



//
// common #defines
//

#define CONFIG_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'CFGM' )
#define CONFIG_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'cfgX' )


#define PROTOCOL_STRING_HTTP L"http://"

#define PROTOCOL_STRING_HTTP_CHAR_COUNT_SANS_TERMINATION                \
    ( sizeof( PROTOCOL_STRING_HTTP ) / sizeof( WCHAR ) ) - 1

#define PROTOCOL_STRING_HTTPS L"https://"

#define PROTOCOL_STRING_HTTPS_CHAR_COUNT_SANS_TERMINATION               \
    ( sizeof( PROTOCOL_STRING_HTTPS ) / sizeof( WCHAR ) ) - 1



//
// metabase paths, properties, etc.
//

//
// Note: IIS_MD_W3SVC has been re-defined here, so that Duct-Tape metadata
// doesn't comingle with IIS metadata in the metabase.
//

#define IIS_MD_W3SVC L"/LM/URT"

#define IIS_MD_APP_POOLS L"/AppPools"

#define IIS_MD_VIRTUAL_SITE_ROOT L"/Root"


//
// BUGBUG All these need to move to iiscnfg.h eventually (if we stick to the
// metabase as a store). 
//

#define MD_APP_APPPOOL                              ( IIS_MD_HTTP_BASE + 111 )

#define IIS_MD_APPPOOL_BASE 9000

#define MD_APPPOOL_PERIODIC_RESTART_TIME            ( IIS_MD_APPPOOL_BASE + 1 )
#define MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT   ( IIS_MD_APPPOOL_BASE + 2 )
#define MD_APPPOOL_MAX_PROCESS_COUNT                ( IIS_MD_APPPOOL_BASE + 3 )
#define MD_APPPOOL_PINGING_ENABLED                  ( IIS_MD_APPPOOL_BASE + 4 )
#define MD_APPPOOL_IDLE_TIMEOUT                     ( IIS_MD_APPPOOL_BASE + 5 )
#define MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED    ( IIS_MD_APPPOOL_BASE + 6 )
#define MD_APPPOOL_SMP_AFFINITIZED                  ( IIS_MD_APPPOOL_BASE + 7 )
#define MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK   ( IIS_MD_APPPOOL_BASE + 8 )
#define MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING   ( IIS_MD_APPPOOL_BASE + 9 )



//
// Default values.
//

//
// BUGBUG Come up with real default settings. 
//

#define APPPOOL_PERIODIC_RESTART_TIME_DEFAULT           0               // i.e. disabled
#define APPPOOL_PERIODIC_RESTART_REQUEST_COUNT_DEFAULT  0               // i.e. disabled
#define APPPOOL_MAX_PROCESS_COUNT_DEFAULT               1               // one process
#define APPPOOL_PINGING_ENABLED_DEFAULT                 0               // i.e. disabled
#define APPPOOL_IDLE_TIMEOUT_DEFAULT                    0               // i.e. disabled
#define APPPOOL_RAPID_FAIL_PROTECTION_ENABLED_DEFAULT   0               // i.e. disabled
#define APPPOOL_SMP_AFFINITIZED_DEFAULT                 0               // i.e. disabled
#define APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK_DEFAULT  MAXULONG_PTR    // any processor
#define APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING_DEFAULT  0               // i.e. disabled



//
// prototypes
//

class CONFIG_MANAGER
{

public:

    CONFIG_MANAGER(
        );

    ~CONFIG_MANAGER(
        );

    HRESULT
    Initialize(
        );


private:

    HRESULT
    ReadAllConfiguration(
        );

    HRESULT
    ReadAllAppPools(
        IN MB * pMetabase
        );

    HRESULT
    ReadAppPool(
        IN MB * pMetabase,
        IN LPCWSTR pAppPoolId
        );

    HRESULT
    ReadAllVirtualSites(
        IN MB * pMetabase
        );

    HRESULT
    ReadVirtualSite(
        IN MB * pMetabase,
        IN LPCWSTR pVirtualSiteKeyName,
        IN DWORD VirtualSiteId
        );

    HRESULT
    ReadAllBindingsAndReturnUrlPrefixes(
        IN MB * pMetabase,
        IN LPCWSTR pVirtualSiteKeyName,
        OUT MULTISZ * pUrlPrefixes
        );

    HRESULT
    ConvertBindingsToUrlPrefixes(
        IN const MULTISZ * pBindingStrings,
        IN LPCWSTR pProtocolString, 
        IN ULONG ProtocolStringCharCountSansTermination,
        IN OUT MULTISZ * pUrlPrefixes
        )
        const;

    HRESULT
    BindingStringToUrlPrefix(
        IN LPCWSTR pBindingString,
        IN LPCWSTR pProtocolString, 
        IN ULONG ProtocolStringCharCountSansTermination,
        OUT STRU * pUrlPrefix
        )
        const;

    HRESULT
    ReadAllApplicationsInVirtualSite(
        IN MB * pMetabase,
        IN LPCWSTR pVirtualSiteKeyName,
        IN DWORD VirtualSiteId,
        OUT BOOL * pValidRootApplicationExists
        );

    HRESULT
    EnumAllApplicationsInVirtualSite(
        IN MB * pMetabase,
        IN LPCWSTR pSiteRootPath,
        OUT MULTISZ * pApplicationPaths
        );

    HRESULT
    ReadApplications(
        IN MB * pMetabase,
        IN DWORD VirtualSiteId,
        IN MULTISZ * pApplicationPaths,
        IN LPCWSTR pSiteRootPath,
        OUT BOOL * pValidRootApplicationExists
        );

    HRESULT
    ReadApplication(
        IN MB * pMetabase,
        IN DWORD VirtualSiteId,
        IN LPCWSTR pApplicationPath,
        IN LPCWSTR pSiteRootPath,
        OUT BOOL * pIsRootApplication
        );


    DWORD m_Signature;

    BOOL m_CoInitialized;

    IMSAdminBase * m_pIMSAdminBase;


};  // class CONFIG_MANAGER



#endif  // _CONFIG_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\dll\archive\shutdownlist\ul_and_worker_manager.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ul_and_worker_manager.cxx

Abstract:

    This class manages all the major run-time state, and drives UL.sys and
    the worker processes.

    Threading: Always called on the main worker thread.

Author:

    Seth Pollack (sethp)        01-Oct-1998

Revision History:

--*/



#include "precomp.h"



/***************************************************************************++

Routine Description:

    Constructor for the UL_AND_WORKER_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

UL_AND_WORKER_MANAGER::UL_AND_WORKER_MANAGER(
    )
    :
    m_AppPoolTable(),
    m_VirtualSiteTable(),
    m_ApplicationTable()
{

    m_Signature = UL_AND_WORKER_MANAGER_SIGNATURE;


    m_State = UninitializedUlAndWorkerManagerState;


    InitializeListHead( &m_AppPoolShutdownListHead );
    m_AppPoolShutdownCount = 0;


    m_UlInitialized = FALSE;

    m_UlControlChannel = NULL;

}   // UL_AND_WORKER_MANAGER::UL_AND_WORKER_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the UL_AND_WORKER_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

UL_AND_WORKER_MANAGER::~UL_AND_WORKER_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == UL_AND_WORKER_MANAGER_SIGNATURE );


    DBG_ASSERT( m_State == TerminatingUlAndWorkerManagerState );


    // 
    // We should not go away with any app pools still shutting down.
    //

    DBG_ASSERT( IsListEmpty( &m_AppPoolShutdownListHead ) );
    DBG_ASSERT( m_AppPoolShutdownCount == 0 );


    if ( m_UlControlChannel != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_UlControlChannel ) );
        m_UlControlChannel = NULL;
    }


    if ( m_UlInitialized )
    {
        UlTerminate();
        m_UlInitialized = FALSE;
    }


    m_Signature = UL_AND_WORKER_MANAGER_SIGNATURE_FREED;

}   // UL_AND_WORKER_MANAGER::~UL_AND_WORKER_MANAGER



/***************************************************************************++

Routine Description:

    Initialize by opening the UL control channel.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;


    Win32Error = UlInitialize(
                        0                           // reserved
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't initialize UL\n"
            ));

        goto exit;
    }

    m_UlInitialized = TRUE;


    Win32Error = UlOpenControlChannel(
                        &m_UlControlChannel,        // returned handle
                        0                           // synchronous i/o
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Couldn't open UL control channel\n"
            ));

        goto exit;
    }


    m_State = RunningUlAndWorkerManagerState;


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Create a new app pool.

Arguments:

    pAppPoolId - ID for the app pool to be created.

    pAppPoolConfig - The configuration parameters for this app pool. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CreateAppPool(
    IN LPCWSTR pAppPoolId,
    IN APP_POOL_CONFIG * pAppPoolConfig
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    APP_POOL * pExistingAppPool = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );
    DBG_ASSERT( pAppPoolConfig != NULL );


    // ensure that we're not creating a app pool that already exists
    DBG_ASSERT( m_AppPoolTable.FindKey( 
                                    pAppPoolId, 
                                    &pExistingAppPool
                                    ) 
                == LK_NO_SUCH_KEY );


    pAppPool = new APP_POOL();

    if ( pAppPool == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating APP_POOL failed\n"
            ));

        goto exit;
    }


    hr = pAppPool->Initialize( pAppPoolId, pAppPoolConfig );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing app pool object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_AppPoolTable.InsertRecord( pAppPool );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Inserting app pool into hashtable failed\n"
            ));

        goto exit;
    }


    pAppPool->MarkAppPoolOwningDataStructure( TableAppPoolOwningDataStructure );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New app pool: %S added to app pool hashtable; total number now: %lu\n",
            pAppPoolId,
            m_AppPoolTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pAppPool != NULL ) )
    {

        //
        // Terminate and dereference pAppPool now, since we won't be able to 
        // find it in the table later. 
        //

        DBG_ASSERT( pAppPool->GetAppPoolOwningDataStructure() == NoneAppPoolOwningDataStructure );

        pAppPool->Terminate();

        pAppPool->Dereference();

        pAppPool = NULL;

    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::CreateAppPool



/***************************************************************************++

Routine Description:

    Create a virtual site. 

Arguments:

    VirtualSiteId - ID for the virtual site to create.

    pVirtualSiteConfig - The configuration for this virtual site. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CreateVirtualSite(
    IN DWORD VirtualSiteId,
    IN VIRTUAL_SITE_CONFIG * pVirtualSiteConfig
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    VIRTUAL_SITE * pExistingVirtualSite = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pVirtualSiteConfig != NULL );


    // ensure that we're not creating a virtual site that already exists
    DBG_ASSERT( m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pExistingVirtualSite
                                        ) 
                == LK_NO_SUCH_KEY );


    pVirtualSite = new VIRTUAL_SITE();

    if ( pVirtualSite == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating VIRTUAL_SITE failed\n"
            ));

        goto exit;
    }


    hr = pVirtualSite->Initialize( VirtualSiteId, pVirtualSiteConfig );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing virtual site object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_VirtualSiteTable.InsertRecord( pVirtualSite );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Inserting virtual site into hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New virtual site: %lu added to virtual site hashtable; total number now: %lu\n",
            VirtualSiteId,
            m_VirtualSiteTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pVirtualSite != NULL ) )
    {

        //
        // Clean up pVirtualSite now, since we won't be able to find it 
        // in the table later. All shutdown work is done in it's destructor.
        //
        
        delete pVirtualSite;

        pVirtualSite = NULL;
    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::CreateVirtualSite



/***************************************************************************++

Routine Description:

    Create an application. This may only be done after the virtual site and 
    the app pool used by this application have been created.

Arguments:

    VirtualSiteId - The virtual site to which this application belongs.

    pApplicationUrl - The site relative URL prefix which identifies
    this application.

    AppIndex - A unique index value for this application. 

    pApplicationConfig - The configuration parameters for this application. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CreateApplication(
    IN DWORD VirtualSiteId,
    IN LPCWSTR pApplicationUrl,
    IN DWORD AppIndex,
    IN APPLICATION_CONFIG * pApplicationConfig
    )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    VIRTUAL_SITE * pVirtualSite = NULL;
    APP_POOL * pAppPool = NULL;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;

#if DBG
    APPLICATION * pExistingApplication = NULL;
#endif  // DBG


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplicationUrl != NULL );
    DBG_ASSERT( pApplicationConfig != NULL );
    DBG_ASSERT( pApplicationConfig->pAppPoolId != NULL );


    ApplicationId.VirtualSiteId = VirtualSiteId;
    ApplicationId.pApplicationUrl = pApplicationUrl;


    // ensure that we're not creating an application that already exists
    DBG_ASSERT( m_ApplicationTable.FindKey( 
                                        &ApplicationId, 
                                        &pExistingApplication
                                        ) 
                == LK_NO_SUCH_KEY );


    //
    // Look up the virtual site and app pool. These must already 
    // exist.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        if ( ReturnCode == LK_NO_SUCH_KEY )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Attempting to create application that references a non-existent virtual site\n"
                ));

            DBG_ASSERT( FALSE );

        }
        else
        {
            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Looking up virtual site referenced by application failed\n"
                ));
        }
        
        goto exit;
    }


    ReturnCode = m_AppPoolTable.FindKey( 
                                    pApplicationConfig->pAppPoolId, 
                                    & ( pApplicationConfig->pAppPool )
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {

        if ( ReturnCode == LK_NO_SUCH_KEY )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Attempting to create application that references a non-existent app pool\n"
                ));

            DBG_ASSERT( FALSE );

        }
        else
        {
            hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Looking up app pool referenced by application failed\n"
                ));
        }
        
        goto exit;
    }


    pApplication = new APPLICATION();

    if ( pApplication == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Allocating APPLICATION failed\n"
            ));

        goto exit;
    }


    hr = pApplication->Initialize(
                            &ApplicationId, 
                            pVirtualSite, 
                            AppIndex,
                            pApplicationConfig
                            );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing application object failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_ApplicationTable.InsertRecord( pApplication );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Inserting application into hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "New application in site: %lu with path: %S, assigned to app pool: %S, with app index %lu, added to application hashtable; total number now: %lu\n",
            VirtualSiteId,
            pApplicationUrl,
            pApplicationConfig->pAppPoolId,
            AppIndex,
            m_ApplicationTable.Size()
            ));
    }


exit:

    if ( FAILED( hr ) && ( pApplication != NULL ) )
    {

        //
        // Clean up pApplication now, since we won't be able to find it 
        // in the table later. All shutdown work is done in it's destructor.
        //
        
        delete pApplication;

        pApplication = NULL;
    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::CreateApplication



/***************************************************************************++

Routine Description:

    Delete an app pool. 

Arguments:

    pAppPoolId - ID for the app pool to be deleted.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeleteAppPool(
    IN LPCWSTR pAppPoolId
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );


    //
    // Look up the app pool in our data structures.
    //
    
    ReturnCode = m_AppPoolTable.FindKey( 
                                    pAppPoolId, 
                                    &pAppPool
                                    ); 

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding app pool to delete in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Shutdown the app pool object. As part of that work, it will 
    // remove itself from the app pool hashtable.
    //

    //
    // Note that at this point there should not be any applications  
    // still assigned to this app pool. 
    //

    hr = pAppPool->Shutdown();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Shutting down app pool failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::DeleteAppPool



/***************************************************************************++

Routine Description:

    Delete a virtual site. 

Arguments:

    VirtualSiteId - ID for the virtual site to delete.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeleteVirtualSite(
    IN DWORD VirtualSiteId
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    //
    // Look up the virtual site in our data structures.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding virtual site to delete in hashtable failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_VirtualSiteTable.DeleteRecord( pVirtualSite );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Removing virtual site from hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Virtual site: %lu removed from hashtable; total number now: %lu\n",
            VirtualSiteId,
            m_VirtualSiteTable.Size()
            ));
    }


    //
    // Clean up and delete the virtual site object. All shutdown work is 
    // done in it's destructor.
    //

    //
    // Note that any apps in this site must already have been deleted.
    // The destructor for this object will assert if this is not the case. 
    //
    
    delete pVirtualSite;


exit:

    return hr;
    
}   // UL_AND_WORKER_MANAGER::DeleteVirtualSite



/***************************************************************************++

Routine Description:

    Delete an application. 

Arguments:

    VirtualSiteId - The virtual site to which this application belongs.

    pApplicationUrl - The site relative URL prefix which identifies
    this application.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeleteApplication(
    IN DWORD VirtualSiteId,
    IN LPCWSTR pApplicationUrl
    )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplicationUrl != NULL );


    ApplicationId.VirtualSiteId = VirtualSiteId;
    ApplicationId.pApplicationUrl = pApplicationUrl;


    //
    // Look up the application in our data structures.
    //
    
    ReturnCode = m_ApplicationTable.FindKey( 
                                        &ApplicationId, 
                                        &pApplication
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding application to delete in hashtable failed\n"
            ));

        goto exit;
    }


    ReturnCode = m_ApplicationTable.DeleteRecord( pApplication );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Removing application from hashtable failed\n"
            ));

        goto exit;
    }


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Application in site: %lu with path: %S, removed from hashtable; total number now: %lu\n",
            VirtualSiteId,
            pApplicationUrl,
            m_ApplicationTable.Size()
            ));
    }


    //
    // Clean up and delete the application object. All shutdown work is 
    // done in it's destructor.
    //
    
    delete pApplication;


exit:

    return hr;
    
}   // UL_AND_WORKER_MANAGER::DeleteApplication



/***************************************************************************++

Routine Description:

    Modify an app pool. 

Arguments:

    pAppPoolId - ID for the app pool to be modified.

    pNewAppPoolConfig - The new configuration values for the app pool. 

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ModifyAppPool(
    IN LPCWSTR pAppPoolId,
    IN APP_POOL_CONFIG * pNewAppPoolConfig,
    IN APP_POOL_CONFIG_CHANGE_FLAGS * pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    APP_POOL * pAppPool = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pAppPoolId != NULL );
    DBG_ASSERT( pNewAppPoolConfig != NULL );
    DBG_ASSERT( pWhatHasChanged != NULL );


    //
    // Look up the app pool in our data structures.
    //
    
    ReturnCode = m_AppPoolTable.FindKey( 
                                    pAppPoolId, 
                                    &pAppPool
                                    ); 

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding app pool to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Make the configuration changes. 
    //

    hr = pAppPool->SetConfiguration( pNewAppPoolConfig, pWhatHasChanged );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new app pool configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::ModifyAppPool



/***************************************************************************++

Routine Description:

    Modify a virtual site. 

Arguments:

    VirtualSiteId - ID for the virtual site to be modified.

    pNewVirtualSiteConfig - The new configuration values for the virtual 
    site. 

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ModifyVirtualSite(
    IN DWORD VirtualSiteId,
    IN VIRTUAL_SITE_CONFIG * pNewVirtualSiteConfig,
    IN VIRTUAL_SITE_CONFIG_CHANGE_FLAGS * pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    VIRTUAL_SITE * pVirtualSite = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pNewVirtualSiteConfig != NULL );
    DBG_ASSERT( pWhatHasChanged != NULL );


    //
    // Look up the virtual site in our data structures.
    //
    
    ReturnCode = m_VirtualSiteTable.FindKey( 
                                        VirtualSiteId, 
                                        &pVirtualSite
                                        ); 

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding virtual site to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Make the configuration changes. 
    //

    hr = pVirtualSite->SetConfiguration( pNewVirtualSiteConfig, pWhatHasChanged );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new virtual site configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::ModifyVirtualSite



/***************************************************************************++

Routine Description:

    Modify an application. 

Arguments:

    VirtualSiteId - The virtual site to which this application belongs.

    pApplicationUrl - The site relative URL prefix which identifies
    this application.

    pNewApplicationConfig - The new configuration values for the application. 

    pWhatHasChanged - Which particular configuration values were changed.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ModifyApplication(
    IN DWORD VirtualSiteId,
    IN LPCWSTR pApplicationUrl,
    IN APPLICATION_CONFIG * pNewApplicationConfig,
    IN APPLICATION_CONFIG_CHANGE_FLAGS * pWhatHasChanged
    )
{

    HRESULT hr = S_OK;
    APPLICATION_ID ApplicationId;
    APPLICATION * pApplication = NULL;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    // verify we are on the main worker thread
    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    DBG_ASSERT( pApplicationUrl != NULL );
    DBG_ASSERT( pNewApplicationConfig != NULL );
    DBG_ASSERT( pWhatHasChanged != NULL );


    ApplicationId.VirtualSiteId = VirtualSiteId;
    ApplicationId.pApplicationUrl = pApplicationUrl;


    //
    // Look up the application in our data structures.
    //
    
    ReturnCode = m_ApplicationTable.FindKey( 
                                        &ApplicationId, 
                                        &pApplication
                                        );

    if ( ReturnCode != LK_SUCCESS )
    {

        //
        // It should be there! Assert in debug builds.
        //
        DBG_ASSERT( ReturnCode != LK_NO_SUCH_KEY );


        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Finding application to modify in hashtable failed\n"
            ));

        goto exit;
    }


    //
    // Resolve the app pool id to it's corresponding app pool object.
    //

    ReturnCode = m_AppPoolTable.FindKey( 
                                    pNewApplicationConfig->pAppPoolId, 
                                    & ( pNewApplicationConfig->pAppPool )
                                    );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Looking up app pool referenced by application failed\n"
            ));

        goto exit;
    }


    //
    // Make the configuration changes. 
    //

    hr = pApplication->SetConfiguration( pNewApplicationConfig, pWhatHasChanged );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new application configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::ModifyApplication



/***************************************************************************++

Routine Description:

    Turn UL's HTTP request handling on.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::ActivateUl(
    )
{

    return SetUlMasterState( UlEnabledStateActive );

}   // UL_AND_WORKER_MANAGER::ActivateUl



/***************************************************************************++

Routine Description:

    Turn UL's HTTP request handling off.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::DeactivateUl(
    )
{

    return SetUlMasterState( UlEnabledStateInactive );

}   // UL_AND_WORKER_MANAGER::DeactivateUl



/***************************************************************************++

Routine Description:

    Kick off gentle shutdown of the UL&WM.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::Shutdown(
    )
{

    HRESULT hr = S_OK;


    m_State = ShutdownPendingUlAndWorkerManagerState;


    //
    // Tell UL to stop processing new requests.
    //

    hr = DeactivateUl();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Deactivating UL failed\n"
            ));

        goto exit;
    }


    //
    // Kick off clean shutdown of all app pools. Once all the app pools
    // have shut down (meaning that all of their worker processes have
    // shut down too), we will call back into the web admin service 
    // object to complete shutdown. 
    //
    // Note that we don't need to take any further action on app pools
    // already in the shutdown list.
    //

    hr = m_AppPoolTable.Shutdown();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Shutting down all app pools failed\n"
            ));

        goto exit;
    }


    //
    // See if shutdown has already completed. This could happen if we have
    // no app pools that have any real shutdown work to do. 
    //

    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::Shutdown



/***************************************************************************++

Routine Description:

    Begin termination of this object. Tell all referenced or owned entities 
    which may hold a reference to this object to release that reference 
    (and not take any more), in order to break reference cycles. 

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::Terminate(
    )
{

    HRESULT hr = S_OK;
    PLIST_ENTRY pListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    APP_POOL * pAppPool = NULL; 


    //
    // Set out new state.
    //

    m_State = TerminatingUlAndWorkerManagerState;


    //
    // Tell UL to stop processing new requests.
    //

    hr = DeactivateUl();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Deactivating UL failed\n"
            ));

    }


    //
    // Note that we must clean up applications before the virtual sites 
    // and app pools with which they are associated.
    //

    m_ApplicationTable.Terminate();

    m_VirtualSiteTable.Terminate();

    m_AppPoolTable.Terminate();


    //
    // Terminate any app pools in the shutdown list too.
    //

    pListEntry = m_AppPoolShutdownListHead.Flink;


    while ( pListEntry != &m_AppPoolShutdownListHead )
    {

        DBG_ASSERT( pListEntry != NULL );

        pNextListEntry = pListEntry->Flink;

        pAppPool = APP_POOL::AppPoolFromShutdownListEntry( pListEntry );


        //
        // Terminate the app pool. Note that the app pool will clean 
        // itself up and remove itself from this list inside this call. 
        // This is the reason we captured the next list entry pointer 
        // above, instead of trying to access the memory after the object
        // may have gone away.
        //

        pAppPool->Terminate();


        pListEntry = pNextListEntry;
        
    }


    return;

}   // UL_AND_WORKER_MANAGER::Terminate



#if DBG
/***************************************************************************++

Routine Description:

    Dump out key internal data structures.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

VOID
UL_AND_WORKER_MANAGER::DebugDump(
    )
{

    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "******************************\n"
            ));
    }


    //
    // Note that we don't bother dumping app pools in the shutdown list.
    //

    m_AppPoolTable.DebugDump();

    m_VirtualSiteTable.DebugDump();

    m_ApplicationTable.DebugDump();


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "******************************\n"
            ));
    }


    return;
    
}   // UL_AND_WORKER_MANAGER::DebugDump
#endif  // DBG



/***************************************************************************++

Routine Description:

    Remove an app pool object from the table of app pools. This method is
    used by app pool objects to remove themselves once they are done 
    cleaning up. It should not be called outside of UL&WM owned code. 

Arguments:

    pAppPool - The app pool object to remove.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::RemoveAppPoolFromTable(
    IN APP_POOL * pAppPool
    )
{

    HRESULT hr = S_OK;
    LK_RETCODE ReturnCode = LK_SUCCESS;


    DBG_ASSERT( pAppPool != NULL );
    DBG_ASSERT( pAppPool->GetAppPoolOwningDataStructure() == TableAppPoolOwningDataStructure );


    //
    // Remove the app pool from the table.
    //

    ReturnCode = m_AppPoolTable.DeleteRecord( pAppPool );

    if ( ReturnCode != LK_SUCCESS )
    {

        hr = HRESULT_FROM_LK_RETCODE( ReturnCode );
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Removing app pool from hashtable failed\n"
            ));

        //
        // Assert in debug builds. In retail, press on...
        //

        DBG_ASSERT( FALSE );

        hr = S_OK;
    }


    pAppPool->MarkAppPoolOwningDataStructure( NoneAppPoolOwningDataStructure );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "App pool: %S removed from app pool hashtable; total number in table now: %lu\n",
            pAppPool->GetAppPoolId(),
            m_AppPoolTable.Size()
            ));
    }


    //
    // Clean up the reference. Because each app pool is reference counted,
    // it will delete itself as soon as it's reference count hits zero.
    //

    pAppPool->Dereference();


    //
    // See if shutdown is underway, and if so if it has completed now 
    // that this app pool is gone. 
    //
    
    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

    }


    return hr;
    
}   // UL_AND_WORKER_MANAGER::RemoveAppPoolFromTable



/***************************************************************************++

Routine Description:

    Move an app pool out of the normal app pool table and onto the shutdown



/***************************************************************************++

Routine Description:

    Move an app pool out of the normal app pool table and onto the shutdown
    list.

Arguments:

    pAppPool - The app pool to transfer. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::TransferAppPoolFromTableToShutdownList(
    IN APP_POOL * pAppPool
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pAppPool != NULL );
    DBG_ASSERT( pAppPool->GetAppPoolOwningDataStructure() == TableAppPoolOwningDataStructure );


    //
    // Insert the app pool into the shutdown list first, so that the 
    // app pool ref count doesn't fall to zero accidentally, and so if
    // the service is shutting down, UL&WM doesn't get fooled into 
    // thinking that shutdown is done because all the app pools are gone. 
    //


    InsertHeadList( &m_AppPoolShutdownListHead, pAppPool->GetShutdownListEntry() );
    m_AppPoolShutdownCount++;

    pAppPool->Reference();


    //
    // Remove the app pool from the table.
    //

    hr = RemoveAppPoolFromTable( pAppPool );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Removing app pool from table failed\n"
            ));

        //
        // Assert in debug builds. In retail, press on...
        //

        DBG_ASSERT( FALSE );

        hr = S_OK;
    }


    //
    // Set the new owning data structure. We have to do this after
    // removing the app pool from the table, so that that function
    // doesn't overwrite the owning data structure field. 
    //

    pAppPool->MarkAppPoolOwningDataStructure( ShutdownListAppPoolOwningDataStructure );


    return hr;

}   // UL_AND_WORKER_MANAGER::TransferAppPoolFromTableToShutdownList



/***************************************************************************++

Routine Description:

    Move an app pool out of the normal app pool table and onto the shutdown
    list.

Arguments:

    pAppPool - The app pool to transfer. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::RemoveAppPoolFromShutdownList(
    IN APP_POOL * pAppPool
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( pAppPool != NULL );
    DBG_ASSERT( pAppPool->GetAppPoolOwningDataStructure() == ShutdownListAppPoolOwningDataStructure );


    //
    // Remove the app pool from the shutdown list.
    //


    RemoveEntryList( pAppPool->GetShutdownListEntry() );
    ( pAppPool->GetShutdownListEntry() )->Flink = NULL; 
    ( pAppPool->GetShutdownListEntry() )->Blink = NULL; 

    m_AppPoolShutdownCount--;


    pAppPool->MarkAppPoolOwningDataStructure( NoneAppPoolOwningDataStructure );


    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "App pool: %S removed from app pool shutdown list; total number on list now: %lu\n",
            pAppPool->GetAppPoolId(),
            m_AppPoolShutdownCount
            ));
    }


    //
    // Clean up the reference. Because each app pool is reference counted,
    // it will delete itself as soon as it's reference count hits zero.
    //

    pAppPool->Dereference();


    //
    // See if shutdown is underway, and if so if it has completed now 
    // that this app pool is gone. 
    //
    
    hr = CheckIfShutdownUnderwayAndNowCompleted();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Checking if shutdown is underway and now completed failed\n"
            ));

    }


    return hr;

}   // UL_AND_WORKER_MANAGER::RemoveAppPoolFromShutdownList



/***************************************************************************++

Routine Description:

    Respond to the fact that we have left the low memory condition.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::LeavingLowMemoryCondition(
    )
{

    //
    // Note that we don't bother informing app pools in the shutdown list.
    //

    return m_AppPoolTable.LeavingLowMemoryCondition();

}   // UL_AND_WORKER_MANAGER::LeavingLowMemoryCondition



/***************************************************************************++

Routine Description:

    Activate or deactivate UL's HTTP request handling.

Arguments:

    NewState - The new state to set, from the UL_ENABLED_STATE enum.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::SetUlMasterState(
    IN UL_ENABLED_STATE NewState
    )
{

    HRESULT hr = S_OK;
    DWORD Win32Error = NO_ERROR;
    

    Win32Error = UlSetControlChannelInformation(
                        m_UlControlChannel,                 // control channel
                        UlControlChannelStateInformation,   // information class
                        &NewState,                          // data to set
                        sizeof( NewState )                  // data length
                        );

    if ( Win32Error != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Win32Error );

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Changing control channel state failed\n"
            ));

    }


    return hr;

}   // UL_AND_WORKER_MANAGER::SetUlMasterState



/***************************************************************************++

Routine Description:

    See if shutdown is underway. If it is, see if shutdown has finished. If
    it has, then call back to the web admin service to tell it that we are
    done. 

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
UL_AND_WORKER_MANAGER::CheckIfShutdownUnderwayAndNowCompleted(
    )
{

    HRESULT hr = S_OK;


    //
    // Are we shutting down?
    //

    if ( m_State == ShutdownPendingUlAndWorkerManagerState )
    {

        //
        // If so, have all the app pools gone away, meaning that we are
        // done?
        //

        if ( ( m_AppPoolShutdownCount == 0 ) && ( m_AppPoolTable.Size() == 0 ) )
        {

            //
            // Tell the web admin service that we are done with shutdown.
            //

            hr = GetWebAdminService()->UlAndWorkerManagerShutdownDone();

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "Finishing stop service state transition failed\n"
                    ));

                goto exit;
            }

        }

    }


exit:

    return hr;

}   // UL_AND_WORKER_MANAGER::CheckIfShutdownUnderwayAndNowCompleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\makefile.inc ===
$(O)\baseobj.res: baseobj.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\fakewp\makefile.inc ===
$(O)\sausage.res: sausage.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\precomp.h ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        21-Feb-2000

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

extern "C" {

//
// System include files.
//

// ensure that all GUIDs are initialized
#define INITGUID

// main project include
#include <iis.h>

#include <dbgutil.h>

// other standard includes
#include <stdio.h>
#include <stdlib.h>

// other project includes
#include <iadmw.h>

#include <iiscnfg.h>

//#include <mb.hxx>



//
// Local prototypes.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    );

}   // extern "C"

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\baseobj\baseobj.cxx ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Baseobj modifies properties using the admin base objects

Author:

    Emily Kruglick (EmilyK) 11/28/2000

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//



// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();



//
// Public functions.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;

    CREATE_DEBUG_PRINT_OBJECT( "baseobj" );
        
    if ( ! VALID_DEBUG_PRINT_OBJECT() )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Debug print object is not valid\n"
            ));
    }

    IMSAdminBase * pIMSAdminBase = NULL;
    BOOL fCoInit = FALSE;
    BOOL fCloseSiteKey = FALSE;
    METADATA_HANDLE hW3SVC = NULL;
    METADATA_RECORD mdrMDData;

    

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }
    
    fCoInit = TRUE;

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }


    //
    // Open the Sites Key so we can change the app pool
    //
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                    L"LM\\W3SVC",
                                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                    10,
                                    &hW3SVC );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Openning the site key failed\n"
            ));

        goto exit;
    }

    fCloseSiteKey = TRUE;

    mdrMDData.dwMDIdentifier    = MD_APPPOOL_APPPOOL_ID;
    mdrMDData.dwMDAttributes    = METADATA_NO_ATTRIBUTES;
    mdrMDData.dwMDUserType      = IIS_MD_UT_SERVER;
    mdrMDData.dwMDDataType      = STRING_METADATA;
    mdrMDData.dwMDDataLen       =( wcslen(L"DefaultAppPool") + 1 ) * sizeof (WCHAR); 
    mdrMDData.pbMDData          = (BYTE *) L"DefaultAppPool"; 

    hr = pIMSAdminBase->SetData(hW3SVC, L"1", &mdrMDData);
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting new app pool failed\n"
            ));

        goto exit;
    }

    hr = pIMSAdminBase->DeleteKey( hW3SVC, L"apppools\\otheremspool");
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "deleting app pool failed\n"
            "apppools\\otheremspool"
            ));

        goto exit;
    }




exit:

    if ( fCloseSiteKey )
    {
        hr = pIMSAdminBase->CloseKey( hW3SVC );
        if ( FAILED( hr ) )
        {
    
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "closing the site key failed\n"
                ));

            goto exit;
        }
    }

    if (pIMSAdminBase)
    {
       pIMSAdminBase->Release();
    }

    if ( fCoInit )
    {
        CoUninitialize();
    }

    return hr;

}   // wmain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\fakewp\sausage.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    sausage.c

Abstract:

    Test exe code for the worker process. 

Author:

    Seth Pollack (sethp)        20-Jul-1998

Revision History:

--*/


#include "precomp.h"


/***************************************************************************++

Routine Description:

    The main entry point for the worker process.

Arguments:

    argc - Count of command line arguments.

    argv - Array of command line argument strings.

Return Value:

    INT

--***************************************************************************/

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    MessageBox(
        NULL,
        GetCommandLine(),
        GetCommandLine(),
        MB_OK
        );
                
    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\upmbtodt\makefile.inc ===
$(O)\upmbtodt.res: upmbtodt.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\fakewp\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        20-Jul-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <windows.h>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\w3control\precomp.h ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        21-Feb-2000

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

extern "C" {

//
// System include files.
//

// ensure that all GUIDs are initialized
#define INITGUID

// main project include
#include <iis.h>

// other standard includes
#include <stdio.h>
#include <stdlib.h>

// other project includes
#include <dbgutil.h>
#include <w3ctrlps.h>



//
// Local prototypes.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    );

}   // extern "C"

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\upmbtodt\upmbtodt.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    upmbtodt.cxx

Abstract:

    Tool to upgrade an existing IIS metabase to duct-tape, by adding app 
    pool information.

Author:

    Seth Pollack (sethp)        28-Jan-1999

Revision History:

--*/



#include "precomp.h"



//
// common #defines
//

#define APP_POOL_FORMERLY_INPROC L"DefaultAppPool1"
#define APP_POOL_FORMERLY_OUTOFPROCPOOLED L"DefaultAppPool2"
#define APP_POOL_ISOLATED_PREFIX L"IsolatedAppPool"


#define MAX_STRINGIZED_ULONG_CHAR_COUNT 11



//
// metabase paths, properties, etc.
//

// BUGBUG all copied from config_manager.h -- keep in sync

#define IIS_MD_W3SVC L"/LM/W3SVC"

#define IIS_MD_APP_POOLS L"/AppPools"

#define IIS_MD_VIRTUAL_SITE_ROOT L"/Root"

#define MD_APP_APPPOOL ( IIS_MD_HTTP_BASE + 111 )



//
// local prototypes
//

HRESULT
DoWork(
    );

HRESULT
DoWorkHelper(
    IN IMSAdminBase * pIMSAdminBase
    );

HRESULT
EnsureAllSitesHaveRootApplications(
    IN MB * pMetabase
    );

HRESULT
EnsureSiteHasRootApplication(
    IN MB * pMetabase,
    IN LPCWSTR pVirtualSiteKeyName,
    IN DWORD VirtualSiteId,
    OUT BOOL * pFixedVirtualSite
    );

HRESULT
CreateStandardAppPools(
    IN MB * pMetabase
    );

HRESULT
CreateAppPool(
    IN MB * pMetabase,
    LPCWSTR pAppPoolId
    );

HRESULT
SetAppPoolPropertyOnEachApplcation(
    IN MB * pMetabase
    );

HRESULT
EnumAllApplications(
    IN MB * pMetabase,
    OUT MULTISZ * pApplicationPaths
    );

HRESULT
StampApplicationsWithAppPools(
    IN MB * pMetabase,
    IN MULTISZ * pApplicationPaths
    );

HRESULT
StampApplicationWithAppPool(
    IN MB * pMetabase,
    IN LPCWSTR pApplicationPath
    );



//
// global variables
//

// usage information
const CHAR g_Usage[] = 
"Usage: upmbtodt [no flags supported] \n"
" \n"
"Stamp the necessary app pool information for duct-tape into the metabase. \n"
"In essence, this allows you to take an existing IIS installation's \n"
"metabase, with it's configured sites, apps, etc., and 'upgrade' it for use \n"
"with duct-tape. \n"
"In detail, what it does: \n"
"1) 'Fix' any sites with a missing root app (the app at '/' within a site), \n"
"by creating a root app for that site.\n"
"2) Add some standard app pools to the metabase. \n"
"3) For each app in the metabase, stamp it with an app pool property based \n"
"on its current AppIsolated property: If in-proc or out-of-proc-pooled, \n"
"assign to the appropriate standard app pool; if out-of-proc-isolated, \n"
"create a new app pool in the metabase, and assign this app to it. \n"
"Note: this tool may be run multiple times, however, if the set of apps \n"
"in the metabase has changed in the interim, app pools may be orphaned, \n"
"and isolated apps may be reassigned to different app pools. \n"
" \n"
;


// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();



/***************************************************************************++

Routine Description:

    The main entry point.

Arguments:

    argc - Count of command line arguments.

    argv - Array of command line argument strings.

Return Value:

    INT

--***************************************************************************/

extern "C"
INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;


    if ( argc > 1 )
    {
        //
        // Display usage information, and exit.
        //

        printf( g_Usage );

        return 0;
    }

    
    printf( "Starting...\n" );


    CREATE_DEBUG_PRINT_OBJECT( "upmbtodt" );
        
    if ( ! VALID_DEBUG_PRINT_OBJECT() )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Debug print object is not valid\n"
            ));
    }
        

    hr = DoWork();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "DoWork() failed\n"
            ));

    }


    DELETE_DEBUG_PRINT_OBJECT();


    return ( INT ) hr;

}   // wmain



/***************************************************************************++

Routine Description:



Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
DoWork(
    )
{

    HRESULT hr = S_OK;
    IMSAdminBase * pIMSAdminBase = NULL;
    

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }
    

    hr = CoCreateInstance( 
                CLSID_MSAdminBase,                  // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IMSAdminBase,                   // IID
                ( VOID * * ) ( &pIMSAdminBase )     // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating metabase base object failed\n"
            ));

        goto exit;
    }


    hr = DoWorkHelper( pIMSAdminBase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "DoWorkHelper() failed\n"
            ));

        goto exit;
    }


    pIMSAdminBase->Release();

    CoUninitialize();


exit:

    return hr;

}   // DoWork



/***************************************************************************++

Routine Description:

    

Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
DoWorkHelper(
    IN IMSAdminBase * pIMSAdminBase
    )
{

    HRESULT hr = S_OK;
    MB Metabase( pIMSAdminBase );
    BOOL Success = TRUE;


    //
    // Open the metabase to the key containing configuration for the web
    // service on the local machine.
    //
    
    Success = Metabase.Open(
                    IIS_MD_W3SVC,
                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
                    );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR((
            DBG_CONTEXT,
            hr,
            "Opening metabase failed\n"
            ));

        goto exit;
    }


    hr = EnsureAllSitesHaveRootApplications( &Metabase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "EnsureAllSitesHaveRootApplications() failed\n"
            ));

    }


    hr = CreateStandardAppPools( &Metabase );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "CreateStandardAppPools() failed\n"
            ));

    }


    hr = SetAppPoolPropertyOnEachApplcation( &Metabase );
    
    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "SetAppPoolPropertyOnEachApplcation() failed\n"
            ));

    }


exit:

    return hr;

}   // DoWorkHelper

    

/***************************************************************************++

Routine Description:



Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
EnsureAllSitesHaveRootApplications(
    IN MB * pMetabase
    )
{

    DWORD EnumIndex = 0;
    WCHAR KeyName[ METADATA_MAX_NAME_LEN ];
    DWORD VirtualSiteId = 0;
    DWORD FixedVirtualSiteCount = 0;
    BOOL FixedVirtualSite = FALSE;
    HRESULT hr = S_OK;


    DBG_ASSERT( pMetabase != NULL );


    printf( "Scanning for missing site root applications...\n" );


    // enumerate all keys under IIS_MD_W3SVC
    
    while ( pMetabase->EnumObjects( 
                            NULL,
                            KeyName,
                            EnumIndex
                            ) )
    {

        //
        // See if we have a virtual site, as opposed to some other key, 
        // by checking if the key name is numeric (and greater than zero). 
        // Ignore other keys.
        //
        // Note that _wtol returns zero if the string passed to it is not 
        // numeric.
        //
        
        VirtualSiteId = _wtol( KeyName );

        if ( VirtualSiteId > 0 )
        {
            // got one

            hr = EnsureSiteHasRootApplication( pMetabase, KeyName, VirtualSiteId, &FixedVirtualSite ); 

            if ( FAILED( hr ) )
            {
            
                DPERROR(( 
                    DBG_CONTEXT,
                    hr,
                    "EnsureSiteHasRootApplication() failed\n"
                    ));

                goto exit;
            }

            if ( FixedVirtualSite )
            {
                FixedVirtualSiteCount++;
            }

        }

        EnumIndex++;

    }


    // make sure we ran out of items, as opposed to a real error

    if ( GetLastError() != ERROR_NO_MORE_ITEMS ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
        
        goto exit;
    }


    printf( 
        "Total number of virtual sites fixed by adding a root application: %lu\n", 
        FixedVirtualSiteCount 
        );


exit: 

    return hr;

}   // EnsureAllSitesHaveRootApplications



/***************************************************************************++

Routine Description:

    Read the configuration for a particular virtual site from the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pVirtualSiteKeyName - The metabase key name for the virtual site being 
    read.

    VirtualSiteId - The id for the virtual site being read.

    pFixedVirtualSite - Returns FALSE if the metadata for the site was 
    sufficiently invalid that the site was not able to be started, TRUE 
    otherwise. Note that a FALSE value here does not by itself cause this 
    function to return an error. 

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
EnsureSiteHasRootApplication(
    IN MB * pMetabase,
    IN LPCWSTR pVirtualSiteKeyName,
    IN DWORD VirtualSiteId,
    OUT BOOL * pFixedVirtualSite
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    BOOL ValidRootApplicationExists = TRUE;
    //
    // Buffer must be long enough to hold "/[stringized virtual site id]/Root".
    //
    WCHAR SiteRootPath[ 1 + MAX_STRINGIZED_ULONG_CHAR_COUNT + ( sizeof( IIS_MD_VIRTUAL_SITE_ROOT ) / sizeof ( WCHAR ) ) + 1 ];
    //
    // Buffer must be long enough to hold "/LM/W3SVC/[stringized virtual site id]/Root".
    //
    WCHAR FullSiteRootPath[ ( sizeof( IIS_MD_W3SVC ) / sizeof ( WCHAR ) ) + ( sizeof( SiteRootPath ) / sizeof ( WCHAR ) ) ];
    STRU AppRoot;
    DWORD AppIsolated = 0;
    

    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pVirtualSiteKeyName != NULL );
    DBG_ASSERT( pFixedVirtualSite != NULL );


    *pFixedVirtualSite = FALSE; 


    _snwprintf( SiteRootPath, sizeof( SiteRootPath ) / sizeof ( WCHAR ), L"/%s%s", pVirtualSiteKeyName, IIS_MD_VIRTUAL_SITE_ROOT );


    //
    // Make sure that the root application exists for this site. 
    //

    Success = pMetabase->GetStr(
                                SiteRootPath,
                                MD_APP_ROOT,
                                IIS_MD_UT_WAM,
                                &AppRoot
                                );

    if ( ! Success )
    {

        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // check for "real" errors
        if ( hr != MD_ERROR_DATA_NOT_FOUND )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Reading app root property of application failed\n"
                ));

            goto exit;
        }

        hr = S_OK;
        
        ValidRootApplicationExists = FALSE;
    }


    Success = pMetabase->GetDword(
                                SiteRootPath,
                                MD_APP_ISOLATED,
                                IIS_MD_UT_WAM,
                                &AppIsolated
                                );

    if ( ! Success )
    {

        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // check for "real" errors
        if ( hr != MD_ERROR_DATA_NOT_FOUND )
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Reading app isolated property of application failed\n"
                ));

            goto exit;
        }

        hr = S_OK;

        ValidRootApplicationExists = FALSE;
    }


    if ( ! ValidRootApplicationExists )
    {

        //
        // Fix it.
        //


        _snwprintf( FullSiteRootPath, sizeof( FullSiteRootPath ) / sizeof ( WCHAR ), L"%s%s", IIS_MD_W3SVC, SiteRootPath );


        Success = pMetabase->SetString(
                                SiteRootPath,
                                MD_APP_ROOT,
                                IIS_MD_UT_WAM,
                                FullSiteRootPath
                                );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() ); 

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting app root property of application failed\n"
                ));

            goto exit;
        }


        Success = pMetabase->SetDword(
                                SiteRootPath,
                                MD_APP_ISOLATED,
                                IIS_MD_UT_WAM,
                                0
                                );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() ); 

            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Setting app isolated property of application failed\n"
                ));

            goto exit;
        }


        printf( 
            "Added a root application to virtual site: %lu\n", 
            VirtualSiteId
            );

        *pFixedVirtualSite = TRUE; 

    }


exit:

    return hr;

}   // EnsureSiteHasRootApplication



/***************************************************************************++

Routine Description:

    

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CreateStandardAppPools(
    IN MB * pMetabase
    )
{

    HRESULT hr = S_OK;


    printf( "Creating standard app pools...\n" );


    hr = CreateAppPool( pMetabase, APP_POOL_FORMERLY_INPROC );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "CreateAppPool() failed\n"
            ));

        goto exit;
    }


    hr = CreateAppPool( pMetabase, APP_POOL_FORMERLY_OUTOFPROCPOOLED );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "CreateAppPool() failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CreateStandardAppPools



/***************************************************************************++

Routine Description:

    

Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CreateAppPool(
    IN MB * pMetabase,
    LPCWSTR pAppPoolId
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    //
    // Buffer must be long enough to hold "/AppPools/[app pool id]".
    //
    WCHAR AppPoolPath[ ( sizeof( IIS_MD_APP_POOLS ) / sizeof ( WCHAR ) ) + 1 + METADATA_MAX_NAME_LEN ];


    _snwprintf( AppPoolPath, sizeof( AppPoolPath ) / sizeof ( WCHAR ), L"%s/%s", IIS_MD_APP_POOLS, pAppPoolId );


    //
    // Add the key for the new app pool.
    //

    Success = pMetabase->AddObject( AppPoolPath );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        if ( hr == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) )
        {
            // keep going if its already there

            hr = S_OK;
        }
        else
        {
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "Creating app pool failed\n"
                ));

            goto exit;
        }
    }


    printf( 
        "Created app pool with id: %S\n", 
        pAppPoolId
        );


exit:

    return hr;

}   // CreateAppPool



/***************************************************************************++

Routine Description:

    

Arguments:

    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
SetAppPoolPropertyOnEachApplcation(
    IN MB * pMetabase
    )
{

    HRESULT hr = S_OK;
    MULTISZ ApplicationPaths;


    printf( "Stamping the app pool property on each application...\n" );


    //
    // Enumerate all the applications. 
    //

    hr = EnumAllApplications( pMetabase, &ApplicationPaths );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Enumerating all applications failed\n"
            ));

        goto exit;
    }


    //
    // Now fix them up with app pool information.
    //

    hr = StampApplicationsWithAppPools(
                pMetabase, 
                &ApplicationPaths
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "StampApplicationsWithAppPools() failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // SetAppPoolPropertyOnEachApplcation



/***************************************************************************++

Routine Description:

    Enumerate and read all applications configured in the metabase.


Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pApplicationPaths - The returned MULTISZ containing the metabase paths
    to the applications.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
EnumAllApplications(
    IN MB * pMetabase,
    OUT MULTISZ * pApplicationPaths
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPaths != NULL );


    //
    // Find the paths of all applications in the metabase. We do this by 
    // asking for the paths to all metabase nodes which define the
    // MD_APP_ISOLATED property. This must be present on any application.
    //

    Success = pMetabase->GetDataPaths(
                                NULL,
                                MD_APP_ISOLATED,
                                ALL_METADATA,
                                pApplicationPaths
                                );

    if ( ! Success )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() ); 
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Getting paths of all applications failed\n"
            ));

        goto exit;
    }


    // get the MULTISZ in sync with its internal BUFFER
    pApplicationPaths->RecalcLen();


exit:

    return hr;

}   // EnumAllApplications



/***************************************************************************++

Routine Description:

    

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pApplicationPaths - A MULTISZ containing the metabase paths to the 
    applications.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
StampApplicationsWithAppPools(
    IN MB * pMetabase,
    IN MULTISZ * pApplicationPaths
    )
{

    HRESULT hr = S_OK;
    LPCWSTR pApplicationPath;


    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPaths != NULL );


    pApplicationPath = pApplicationPaths->First();
    
    while ( pApplicationPath != NULL )
    {
        hr = StampApplicationWithAppPool(
                    pMetabase, 
                    pApplicationPath
                    );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "StampApplicationWithAppPool() failed\n"
                ));

            goto exit;
        }


        pApplicationPath = pApplicationPaths->Next( pApplicationPath );
    }


exit:

    return hr;

}   // StampApplicationsWithAppPools



/***************************************************************************++

Routine Description:



Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    pApplicationPaths - The metabase path to the application starting from
    IIS_MD_W3SVC.
    
Return Value:

    HRESULT

--***************************************************************************/

HRESULT
StampApplicationWithAppPool(
    IN MB * pMetabase,
    IN LPCWSTR pApplicationPath
    )
{

    HRESULT hr = S_OK;
    BOOL Success = TRUE;
    DWORD AppIsolated = 0;
    LPWSTR AppPoolId = NULL;
    //
    // Buffer must be long enough to hold "IsolatedAppPool[number]".
    //
    WCHAR NewAppPoolId[ ( sizeof( APP_POOL_ISOLATED_PREFIX ) / sizeof( WCHAR ) ) + MAX_STRINGIZED_ULONG_CHAR_COUNT + 1 ];
    static ULONG NewAppPoolIdNumber = 1;            // note: static!
    

    DBG_ASSERT( pMetabase != NULL );
    DBG_ASSERT( pApplicationPath != NULL );


    //
    // Check if this is the application at lm/w3svc, i.e. "/"; if so,
    // ignore it.
    //

    if ( ( *pApplicationPath == L'/' ) && ( *( pApplicationPath + 1 ) == L'\0' ) )
    {
        goto exit;
    }


    //
    // Read the MD_APP_ISOLATED property for this application. This property
    // is required, and in fact it must exist since we got this
    // application path by querying for this same property earlier
    // (while under the same metabase read lock).
    //

    Success = pMetabase->GetDword(
                                pApplicationPath,
                                MD_APP_ISOLATED,
                                IIS_MD_UT_WAM,
                                &AppIsolated
                                );

    if ( ! Success )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        // if the property wasn't present, something is screwy
        DBG_ASSERT( hr != MD_ERROR_DATA_NOT_FOUND );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading app isolated property of application failed\n"
            ));

        goto exit;

    }


    //
    // Determine which app pool to assign.
    //

    switch ( AppIsolated ) 
    {

    case 0:         // in-proc

        AppPoolId = APP_POOL_FORMERLY_INPROC;
        
        break;

    case 1:         // out-of-proc isolated

        //
        // Generate a unique new app pool id, and create that new app pool.
        //
        // Note that this approach is simple, but doesn't support running 
        // the tool again later very well (after the set of apps may have 
        // changed), as app pools may be orphaned, and custom-configured
        // isolated app pools may be reassigned to different apps.
        //
        // In the future, consider using the app path, package name, or app
        // friendly name to generate the app pool id.
        //
        
        _snwprintf( NewAppPoolId, sizeof( NewAppPoolId ) / sizeof ( WCHAR ), L"%s%lu", APP_POOL_ISOLATED_PREFIX, NewAppPoolIdNumber );


        hr = CreateAppPool( pMetabase, NewAppPoolId );

        if ( FAILED( hr ) )
        {
        
            DPERROR(( 
                DBG_CONTEXT,
                hr,
                "CreateAppPool() failed\n"
                ));

            goto exit;
        }


        AppPoolId = NewAppPoolId;

        NewAppPoolIdNumber++;
        
        break;

    case 2:         // out-of-proc pooled

        AppPoolId = APP_POOL_FORMERLY_OUTOFPROCPOOLED;
        
        break;

    default:
    
        break;
            
    }


    //
    // Set the new property.
    //

    Success = pMetabase->SetString(
                                pApplicationPath,
                                MD_APP_APPPOOL,
                                IIS_MD_UT_WAM,
                                AppPoolId
                                );

    if ( ! Success )
    {
    
        hr = HRESULT_FROM_WIN32( GetLastError() ); 

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Setting app pool property of application failed\n"
            ));

        goto exit;

    }


    printf( 
        "Stamped app at path: %S with new app pool id: %S\n", 
        pApplicationPath,
        AppPoolId
        );


exit:

    return hr;

}   // StampApplicationWithAppPool
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\upmbtodt\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file.

Author:

    Seth Pollack (sethp)        28-Jan-1999

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <iis.h>

#include <dbgutil.h>

#include <stdio.h>

#undef DEFINE_GUID
#define INITGUID
#include <ole2.h>

#include <iadmw.h>

#include <iiscnfg.h>

#include <mb.hxx>


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\w3control\makefile.inc ===
$(O)\w3control.res: w3control.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ap\was\test\w3control\w3control.cxx ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    w3control.cxx

Abstract:

    IW3Control interface test app.

Author:

    Seth Pollack (sethp)        21-Feb-2000

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//

// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();


// usage information
const WCHAR g_Usage[] = 
L"Usage: w3control [start|stop|pause|continue|query|getmode|recycle] [site|app|apppool] [siteID] <appURL|apppoolId>\n";

#define W3_CONTROL_COMMAND_GETMODE W3_CONTROL_COMMAND_CONTINUE + 1
#define W3_CONTROL_COMMAND_RECYCLE W3_CONTROL_COMMAND_CONTINUE + 2

//
// Public functions.
//

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;
    BOOL QueryOperation = FALSE;    // TRUE for query op, FALSE for other ops
    DWORD SiteId = 0;
    LPWSTR AppUrl = NULL;
    LPWSTR AppPoolId = NULL;
    DWORD Command = W3_CONTROL_COMMAND_INVALID;
    IW3Control * pIW3Control = NULL;
    DWORD State = 0;
    LPWSTR NewStateName = NULL;


    CREATE_DEBUG_PRINT_OBJECT( "w3control" );


    //
    // Validate and parse parameters.
    //

    if ( ( argc < 4 ) || ( argc > 5 ) )
    {
        wprintf( g_Usage );
        goto exit;
    }

    if ( _wcsicmp( argv[1], L"query" ) == 0 )
    {
        QueryOperation = TRUE;
    }
    else if ( _wcsicmp( argv[1], L"start" ) == 0 )
    {
        Command = W3_CONTROL_COMMAND_START; 
    }
    else if ( _wcsicmp( argv[1], L"stop" ) == 0 )
    {
        Command = W3_CONTROL_COMMAND_STOP; 
    }
    else if ( _wcsicmp( argv[1], L"pause" ) == 0 )
    {
        Command = W3_CONTROL_COMMAND_PAUSE; 
    }
    else if ( _wcsicmp( argv[1], L"continue" ) == 0 )
    {
        Command = W3_CONTROL_COMMAND_CONTINUE; 
    }
    else if ( _wcsicmp( argv[1], L"getmode" ) == 0 )
    {
        Command = W3_CONTROL_COMMAND_GETMODE; 
    }
    else if ( _wcsicmp( argv[1], L"recycle" ) == 0 )
    {
        Command = W3_CONTROL_COMMAND_RECYCLE; 
    }
    else
    {
        wprintf( g_Usage );
        goto exit;
    }


    if (     Command != W3_CONTROL_COMMAND_GETMODE  && 
             Command != W3_CONTROL_COMMAND_RECYCLE )
    {

        if ( ( _wcsicmp( argv[2], L"site" ) != 0 ) || ( argc != 4 ) )
        {
            wprintf( g_Usage );
            goto exit;
        }
    }
    else
    {
        if ( Command == W3_CONTROL_COMMAND_RECYCLE )
        {
            if ( argc == 5 )
            {
                AppPoolId = argv[4];
            }
            else
            {
                wprintf( g_Usage );
                goto exit;
            }
        }
    }


    SiteId = _wtoi( argv[3] );


    //
    // Prepare to make the call.
    //

    hr = CoInitializeEx(
                NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));

        goto exit;
    }


/*
    DBGPRINTF((
        DBG_CONTEXT, 
        "About to create instance\n"
        ));
*/

    hr = CoCreateInstance( 
                CLSID_W3Control,                    // CLSID
                NULL,                               // controlling unknown
                CLSCTX_SERVER,                      // desired context
                IID_IW3Control,                     // IID
                ( VOID * * ) ( &pIW3Control )       // returned interface
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Creating instance of IW3Control failed\n"
            ));

        goto exit;
    }


    //
    // Call the appropriate method.
    //

/*
    DBGPRINTF((
        DBG_CONTEXT, 
        "About to call method\n"
        ));
*/

    if ( Command == W3_CONTROL_COMMAND_RECYCLE )
    {
        hr = pIW3Control->RecycleAppPool( AppPoolId );
    }
    else if ( Command == W3_CONTROL_COMMAND_GETMODE )
    {
        hr = pIW3Control->GetCurrentMode( &State );
    }
    else if ( QueryOperation )
    {
        hr = pIW3Control->QuerySiteStatus( SiteId, &State );
    }
    else
    {
        hr = pIW3Control->ControlSite( SiteId, Command, &State );
    }


    if ( FAILED( hr ) )
    {
        wprintf( L"call failed, hr=%x\n", hr );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Calling method on IW3Control failed\n"
            ));

        goto exit;
    }


    //
    // Report the new state.
    //

    if ( Command == W3_CONTROL_COMMAND_GETMODE )
    {
        wprintf( L"current mode is now: %s\n", ( State == 1 ) ? L"FC" : L"BC" );
    }
    else if ( Command != W3_CONTROL_COMMAND_RECYCLE)
    {
        switch ( State )
        {
        case W3_CONTROL_STATE_STARTING:
            NewStateName = L"starting";
            break;
        case W3_CONTROL_STATE_STARTED:
            NewStateName = L"started";
            break;
        case W3_CONTROL_STATE_STOPPING:
            NewStateName = L"stopping";
            break;
        case W3_CONTROL_STATE_STOPPED:
            NewStateName = L"stopped";
            break;
        case W3_CONTROL_STATE_PAUSING:
            NewStateName = L"pausing";
            break;
        case W3_CONTROL_STATE_PAUSED:
            NewStateName = L"paused";
            break;
        case W3_CONTROL_STATE_CONTINUING:
            NewStateName = L"continuing";
            break;
        default:
            NewStateName = L"ERROR!";
            break;
        }

        wprintf( L"state is now: %s\n", NewStateName );
    }


    pIW3Control->Release();


    CoUninitialize();


    DELETE_DEBUG_PRINT_OBJECT();


exit:

    return ( INT ) hr;

}   // wmain


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Version 5.0 (using 32-bit types)
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned short	_2BYTEPAD;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_RESERVED   3L  // All signatures from 3 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))




// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types


#define T_NOTYPE        0x0000      // uncharacterized type (no type)
#define T_ABS           0x0001      // absolute symbol
#define T_SEGMENT       0x0002      // segment type
#define T_VOID          0x0003      // void
#define T_PVOID         0x0103      // near pointer to void
#define T_PFVOID        0x0203      // far pointer to void
#define T_PHVOID        0x0303      // huge pointer to void
#define T_32PVOID       0x0403      // 16:32 near pointer to void
#define T_32PFVOID      0x0503      // 16:32 far pointer to void
#define T_64PVOID       0x0603      // 64 bit pointer to void
#define T_CURRENCY      0x0004      // BASIC 8 byte currency value
#define T_NBASICSTR     0x0005      // Near BASIC string
#define T_FBASICSTR     0x0006      // Far BASIC string
#define T_NOTTRANS      0x0007      // type not translated by cvpack
#define T_BIT           0x0060      // bit
#define T_PASCHAR       0x0061      // Pascal CHAR



//      Character types


#define T_CHAR          0x0010      // 8 bit signed
#define T_UCHAR         0x0020      // 8 bit unsigned
#define T_PCHAR         0x0110      // near pointer to 8 bit signed
#define T_PUCHAR        0x0120      // near pointer to 8 bit unsigned
#define T_PFCHAR        0x0210      // far pointer to 8 bit signed
#define T_PFUCHAR       0x0220      // far pointer to 8 bit unsigned
#define T_PHCHAR        0x0310      // huge pointer to 8 bit signed
#define T_PHUCHAR       0x0320      // huge pointer to 8 bit unsigned
#define T_32PCHAR       0x0410      // 16:32 near pointer to 8 bit signed
#define T_32PUCHAR      0x0420      // 16:32 near pointer to 8 bit unsigned
#define T_32PFCHAR      0x0510      // 16:32 far pointer to 8 bit signed
#define T_32PFUCHAR     0x0520      // 16:32 far pointer to 8 bit unsigned
#define T_64PCHAR       0X0610      // 64 bit pointer to 8 bit signed
#define T_64PUCHAR      0X0620      // 64 bit pointer to 8 bit unsigned




//      really a character types

#define T_RCHAR         0x0070      // really a char
#define T_PRCHAR        0x0170      // 16:16 near pointer to a real char
#define T_PFRCHAR       0x0270      // 16:16 far pointer to a real char
#define T_PHRCHAR       0x0370      // 16:16 huge pointer to a real char
#define T_32PRCHAR      0x0470      // 16:32 near pointer to a real char
#define T_32PFRCHAR     0x0570      // 16:32 far pointer to a real char
#define T_64PRCHAR      0x0670      // 64 bit pointer to a real char



//      really a wide character types

#define T_WCHAR         0x0071      // wide char
#define T_PWCHAR        0x0171      // 16:16 near pointer to a wide char
#define T_PFWCHAR       0x0271      // 16:16 far pointer to a wide char
#define T_PHWCHAR       0x0371      // 16:16 huge pointer to a wide char
#define T_32PWCHAR      0x0471      // 16:32 near pointer to a wide char
#define T_32PFWCHAR     0x0571      // 16:32 far pointer to a wide char
#define T_64PWCHAR      0x0671      // 64 bit pointer to a wide char


//      8 bit int types


#define T_INT1          0x0068      // 8 bit signed int
#define T_UINT1         0x0069      // 8 bit unsigned int
#define T_PINT1         0x0168      // near pointer to 8 bit signed int
#define T_PUINT1        0x0169      // near pointer to 8 bit unsigned int
#define T_PFINT1        0x0268      // far pointer to 8 bit signed int
#define T_PFUINT1       0x0269      // far pointer to 8 bit unsigned int
#define T_PHINT1        0x0368      // huge pointer to 8 bit signed int
#define T_PHUINT1       0x0369      // huge pointer to 8 bit unsigned int

#define T_32PINT1       0x0468      // 16:32 near pointer to 8 bit signed int
#define T_32PUINT1      0x0469      // 16:32 near pointer to 8 bit unsigned int
#define T_32PFINT1      0x0568      // 16:32 far pointer to 8 bit signed int
#define T_32PFUINT1     0x0569      // 16:32 far pointer to 8 bit unsigned int
#define T_64PINT1       0x0668      // 64 bit pointer to 8 bit signed int
#define T_64PUINT1      0x0669      // 64 bit pointer to 8 bit unsigned int


//      16 bit short types


#define T_SHORT         0x0011      // 16 bit signed
#define T_USHORT        0x0021      // 16 bit unsigned
#define T_PSHORT        0x0111      // near pointer to 16 bit signed
#define T_PUSHORT       0x0121      // near pointer to 16 bit unsigned
#define T_PFSHORT       0x0211      // far pointer to 16 bit signed
#define T_PFUSHORT      0x0221      // far pointer to 16 bit unsigned
#define T_PHSHORT       0x0311      // huge pointer to 16 bit signed
#define T_PHUSHORT      0x0321      // huge pointer to 16 bit unsigned

#define T_32PSHORT      0x0411      // 16:32 near pointer to 16 bit signed
#define T_32PUSHORT     0x0421      // 16:32 near pointer to 16 bit unsigned
#define T_32PFSHORT     0x0511      // 16:32 far pointer to 16 bit signed
#define T_32PFUSHORT    0x0521      // 16:32 far pointer to 16 bit unsigned
#define T_64PSHORT      0x0611      // 64 bit pointer to 16 bit signed
#define T_64PUSHORT     0x0621      // 64 bit pointer to 16 bit unsigned




//      16 bit int types


#define T_INT2          0x0072      // 16 bit signed int
#define T_UINT2         0x0073      // 16 bit unsigned int
#define T_PINT2         0x0172      // near pointer to 16 bit signed int
#define T_PUINT2        0x0173      // near pointer to 16 bit unsigned int
#define T_PFINT2        0x0272      // far pointer to 16 bit signed int
#define T_PFUINT2       0x0273      // far pointer to 16 bit unsigned int
#define T_PHINT2        0x0372      // huge pointer to 16 bit signed int
#define T_PHUINT2       0x0373      // huge pointer to 16 bit unsigned int

#define T_32PINT2       0x0472      // 16:32 near pointer to 16 bit signed int
#define T_32PUINT2      0x0473      // 16:32 near pointer to 16 bit unsigned int
#define T_32PFINT2      0x0572      // 16:32 far pointer to 16 bit signed int
#define T_32PFUINT2     0x0573      // 16:32 far pointer to 16 bit unsigned int
#define T_64PINT2       0x0672      // 64 bit pointer to 16 bit signed int
#define T_64PUINT2      0x0673      // 64 bit pointer to 16 bit unsigned int




//      32 bit long types


#define T_LONG          0x0012      // 32 bit signed
#define T_ULONG         0x0022      // 32 bit unsigned
#define T_PLONG         0x0112      // near pointer to 32 bit signed
#define T_PULONG        0x0122      // near pointer to 32 bit unsigned
#define T_PFLONG        0x0212      // far pointer to 32 bit signed
#define T_PFULONG       0x0222      // far pointer to 32 bit unsigned
#define T_PHLONG        0x0312      // huge pointer to 32 bit signed
#define T_PHULONG       0x0322      // huge pointer to 32 bit unsigned

#define T_32PLONG       0x0412      // 16:32 near pointer to 32 bit signed
#define T_32PULONG      0x0422      // 16:32 near pointer to 32 bit unsigned
#define T_32PFLONG      0x0512      // 16:32 far pointer to 32 bit signed
#define T_32PFULONG     0x0522      // 16:32 far pointer to 32 bit unsigned
#define T_64PLONG       0x0612      // 64 bit pointer to 32 bit signed
#define T_64PULONG      0x0622      // 64 bit pointer to 32 bit unsigned




//      32 bit int types


#define T_INT4          0x0074      // 32 bit signed int
#define T_UINT4         0x0075      // 32 bit unsigned int
#define T_PINT4         0x0174      // near pointer to 32 bit signed int
#define T_PUINT4        0x0175      // near pointer to 32 bit unsigned int
#define T_PFINT4        0x0274      // far pointer to 32 bit signed int
#define T_PFUINT4       0x0275      // far pointer to 32 bit unsigned int
#define T_PHINT4        0x0374      // huge pointer to 32 bit signed int
#define T_PHUINT4       0x0375      // huge pointer to 32 bit unsigned int

#define T_32PINT4       0x0474      // 16:32 near pointer to 32 bit signed int
#define T_32PUINT4      0x0475      // 16:32 near pointer to 32 bit unsigned int
#define T_32PFINT4      0x0574      // 16:32 far pointer to 32 bit signed int
#define T_32PFUINT4     0x0575      // 16:32 far pointer to 32 bit unsigned int
#define T_64PINT4       0x0674      // 64 bit pointer to 32 bit signed int
#define T_64PUINT4      0x0675      // 64 bit pointer to 32 bit unsigned int




//      64 bit quad types


#define T_QUAD          0x0013      // 64 bit signed
#define T_UQUAD         0x0023      // 64 bit unsigned
#define T_PQUAD         0x0113      // near pointer to 64 bit signed
#define T_PUQUAD        0x0123      // near pointer to 64 bit unsigned
#define T_PFQUAD        0x0213      // far pointer to 64 bit signed
#define T_PFUQUAD       0x0223      // far pointer to 64 bit unsigned
#define T_PHQUAD        0x0313      // huge pointer to 64 bit signed
#define T_PHUQUAD       0x0323      // huge pointer to 64 bit unsigned
#define T_32PQUAD       0x0413      // 16:32 near pointer to 64 bit signed
#define T_32PUQUAD      0x0423      // 16:32 near pointer to 64 bit unsigned
#define T_32PFQUAD      0x0513      // 16:32 far pointer to 64 bit signed
#define T_32PFUQUAD     0x0523      // 16:32 far pointer to 64 bit unsigned
#define T_64PQUAD       0x0613      // 64 bit pointer to 64 bit signed
#define T_64PUQUAD      0x0623      // 64 bit pointer to 64 bit unsigned



//      64 bit int types


#define T_INT8          0x0076      // 64 bit signed int
#define T_UINT8         0x0077      // 64 bit unsigned int
#define T_PINT8         0x0176      // near pointer to 64 bit signed int
#define T_PUINT8        0x0177      // near pointer to 64 bit unsigned int
#define T_PFINT8        0x0276      // far pointer to 64 bit signed int
#define T_PFUINT8       0x0277      // far pointer to 64 bit unsigned int
#define T_PHINT8        0x0376      // huge pointer to 64 bit signed int
#define T_PHUINT8       0x0377      // huge pointer to 64 bit unsigned int

#define T_32PINT8       0x0476      // 16:32 near pointer to 64 bit signed int
#define T_32PUINT8      0x0477      // 16:32 near pointer to 64 bit unsigned int
#define T_32PFINT8      0x0576      // 16:32 far pointer to 64 bit signed int
#define T_32PFUINT8     0x0577      // 16:32 far pointer to 64 bit unsigned int
#define T_64PINT8       0x0676      // 64 bit pointer to 64 bit signed int
#define T_64PUINT8      0x0677      // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types


#define T_OCT           0x0014      // 128 bit signed
#define T_UOCT          0x0024      // 128 bit unsigned
#define T_POCT          0x0114      // near pointer to 128 bit signed
#define T_PUOCT         0x0124      // near pointer to 128 bit unsigned
#define T_PFOCT         0x0214      // far pointer to 128 bit signed
#define T_PFUOCT        0x0224      // far pointer to 128 bit unsigned
#define T_PHOCT         0x0314      // huge pointer to 128 bit signed
#define T_PHUOCT        0x0324      // huge pointer to 128 bit unsigned

#define T_32POCT        0x0414      // 16:32 near pointer to 128 bit signed
#define T_32PUOCT       0x0424      // 16:32 near pointer to 128 bit unsigned
#define T_32PFOCT       0x0514      // 16:32 far pointer to 128 bit signed
#define T_32PFUOCT      0x0524      // 16:32 far pointer to 128 bit unsigned
#define T_64POCT        0x0614      // 64 bit pointer to 128 bit signed
#define T_64PUOCT       0x0624      // 64 bit pointer to 128 bit unsigned

//      128 bit int types


#define T_INT16         0x0078      // 128 bit signed int
#define T_UINT16        0x0079      // 128 bit unsigned int
#define T_PINT16        0x0178      // near pointer to 128 bit signed int
#define T_PUINT16       0x0179      // near pointer to 128 bit unsigned int
#define T_PFINT16       0x0278      // far pointer to 128 bit signed int
#define T_PFUINT16      0x0279      // far pointer to 128 bit unsigned int
#define T_PHINT16       0x0378      // huge pointer to 128 bit signed int
#define T_PHUINT16      0x0379      // huge pointer to 128 bit unsigned int

#define T_32PINT16      0x0478      // 16:32 near pointer to 128 bit signed int
#define T_32PUINT16     0x0479      // 16:32 near pointer to 128 bit unsigned int
#define T_32PFINT16     0x0578      // 16:32 far pointer to 128 bit signed int
#define T_32PFUINT16    0x0579      // 16:32 far pointer to 128 bit unsigned int
#define T_64PINT16      0x0678      // 64 bit pointer to 128 bit signed int
#define T_64PUINT16     0x0679      // 64 bit pointer to 128 bit unsigned int





//      32 bit real types


#define T_REAL32        0x0040      // 32 bit real
#define T_PREAL32       0x0140      // near pointer to 32 bit real
#define T_PFREAL32      0x0240      // far pointer to 32 bit real
#define T_PHREAL32      0x0340      // huge pointer to 32 bit real
#define T_32PREAL32     0x0440      // 16:32 near pointer to 32 bit real
#define T_32PFREAL32    0x0540      // 16:32 far pointer to 32 bit real
#define T_64PREAL32     0x0640      // 64 bit pointer to 32 bit real



//      48 bit real types


#define T_REAL48        0x0044      // 48 bit real
#define T_PREAL48       0x0144      // near pointer to 48 bit real
#define T_PFREAL48      0x0244      // far pointer to 48 bit real
#define T_PHREAL48      0x0344      // huge pointer to 48 bit real
#define T_32PREAL48     0x0444      // 16:32 near pointer to 48 bit real
#define T_32PFREAL48    0x0544      // 16:32 far pointer to 48 bit real
#define T_64PREAL48     0x0644      // 64 bit pointer to 48 bit real




//      64 bit real types


#define T_REAL64        0x0041      // 64 bit real
#define T_PREAL64       0x0141      // near pointer to 64 bit real
#define T_PFREAL64      0x0241      // far pointer to 64 bit real
#define T_PHREAL64      0x0341      // huge pointer to 64 bit real
#define T_32PREAL64     0x0441      // 16:32 near pointer to 64 bit real
#define T_32PFREAL64    0x0541      // 16:32 far pointer to 64 bit real
#define T_64PREAL64     0x0641      // 64 bit pointer to 64 bit real




//      80 bit real types


#define T_REAL80        0x0042      // 80 bit real
#define T_PREAL80       0x0142      // near pointer to 80 bit real
#define T_PFREAL80      0x0242      // far pointer to 80 bit real
#define T_PHREAL80      0x0342      // huge pointer to 80 bit real
#define T_32PREAL80     0x0442      // 16:32 near pointer to 80 bit real
#define T_32PFREAL80    0x0542      // 16:32 far pointer to 80 bit real
#define T_64PREAL80     0x0642      // 64 bit pointer to 80 bit real




//      128 bit real types


#define T_REAL128       0x0043      // 128 bit real
#define T_PREAL128      0x0143      // near pointer to 128 bit real
#define T_PFREAL128     0x0243      // far pointer to 128 bit real
#define T_PHREAL128     0x0343      // huge pointer to 128 bit real
#define T_32PREAL128    0x0443      // 16:32 near pointer to 128 bit real
#define T_32PFREAL128   0x0543      // 16:32 far pointer to 128 bit real
#define T_64PREAL128    0x0643      // 64 bit pointer to 128 bit real




//      32 bit complex types


#define T_CPLX32        0x0050      // 32 bit complex
#define T_PCPLX32       0x0150      // near pointer to 32 bit complex
#define T_PFCPLX32      0x0250      // far pointer to 32 bit complex
#define T_PHCPLX32      0x0350      // huge pointer to 32 bit complex
#define T_32PCPLX32     0x0450      // 16:32 near pointer to 32 bit complex
#define T_32PFCPLX32    0x0550      // 16:32 far pointer to 32 bit complex
#define T_64PCPLX32     0x0650      // 64 bit pointer to 32 bit complex




//      64 bit complex types


#define T_CPLX64        0x0051      // 64 bit complex
#define T_PCPLX64       0x0151      // near pointer to 64 bit complex
#define T_PFCPLX64      0x0251      // far pointer to 64 bit complex
#define T_PHCPLX64      0x0351      // huge pointer to 64 bit complex
#define T_32PCPLX64     0x0451      // 16:32 near pointer to 64 bit complex
#define T_32PFCPLX64    0x0551      // 16:32 far pointer to 64 bit complex
#define T_64PCPLX64     0x0651      // 64 bit pointer to 64 bit complex




//      80 bit complex types


#define T_CPLX80        0x0052      // 80 bit complex
#define T_PCPLX80       0x0152      // near pointer to 80 bit complex
#define T_PFCPLX80      0x0252      // far pointer to 80 bit complex
#define T_PHCPLX80      0x0352      // huge pointer to 80 bit complex
#define T_32PCPLX80     0x0452      // 16:32 near pointer to 80 bit complex
#define T_32PFCPLX80    0x0552      // 16:32 far pointer to 80 bit complex
#define T_64PCPLX80     0x0652      // 64 bit pointer to 80 bit complex




//      128 bit complex types


#define T_CPLX128       0x0053      // 128 bit complex
#define T_PCPLX128      0x0153      // near pointer to 128 bit complex
#define T_PFCPLX128     0x0253      // far pointer to 128 bit complex
#define T_PHCPLX128     0x0353      // huge pointer to 128 bit real
#define T_32PCPLX128    0x0453      // 16:32 near pointer to 128 bit complex
#define T_32PFCPLX128   0x0553      // 16:32 far pointer to 128 bit complex
#define T_64PCPLX128    0x0653      // 64 bit pointer to 128 bit complex




//      boolean types


#define T_BOOL08        0x0030      // 8 bit boolean
#define T_BOOL16        0x0031      // 16 bit boolean
#define T_BOOL32        0x0032      // 32 bit boolean
#define T_BOOL64        0x0033      // 64 bit boolean
#define T_PBOOL08       0x0130      // near pointer to  8 bit boolean
#define T_PBOOL16       0x0131      // near pointer to 16 bit boolean
#define T_PBOOL32       0x0132      // near pointer to 32 bit boolean
#define T_PBOOL64       0x0133      // near pointer to 64 bit boolean
#define T_PFBOOL08      0x0230      // far pointer to  8 bit boolean
#define T_PFBOOL16      0x0231      // far pointer to 16 bit boolean
#define T_PFBOOL32      0x0232      // far pointer to 32 bit boolean
#define T_PFBOOL64      0x0233      // far pointer to 64 bit boolean
#define T_PHBOOL08      0x0330      // huge pointer to  8 bit boolean
#define T_PHBOOL16      0x0331      // huge pointer to 16 bit boolean
#define T_PHBOOL32      0x0332      // huge pointer to 32 bit boolean
#define T_PHBOOL64      0x0333      // huge pointer to 64 bit boolean

#define T_32PBOOL08     0x0430      // 16:32 near pointer to 8 bit boolean
#define T_32PFBOOL08    0x0530      // 16:32 far pointer to 8 bit boolean
#define T_32PBOOL16     0x0431      // 16:32 near pointer to 18 bit boolean
#define T_32PFBOOL16    0x0531      // 16:32 far pointer to 16 bit boolean
#define T_32PBOOL32     0x0432      // 16:32 near pointer to 32 bit boolean
#define T_32PFBOOL32    0x0532      // 16:32 far pointer to 32 bit boolean
#define T_32PBOOL64     0x0433      // 16:32 near pointer to 64 bit boolean
#define T_32PFBOOL64    0x0533      // 16:32 far pointer to 64 bit boolean

#define T_64PBOOL08     0x0630      // 64 bit pointer to 8 bit boolean
#define T_64PBOOL16     0x0631      // 64 bit pointer to 18 bit boolean
#define T_64PBOOL32     0x0632      // 64 bit pointer to 32 bit boolean
#define T_64PBOOL64     0x0633      // 64 bit pointer to 64 bit boolean


#define T_NCVPTR        0x01f0      // CV Internal type for created near pointers
#define T_FCVPTR        0x02f0      // CV Internal type for created far pointers
#define T_HCVPTR        0x03f0      // CV Internal type for created huge pointers
#define T_32NCVPTR      0x04f0      // CV Internal type for created near 32-bit pointers
#define T_32FCVPTR      0x05f0      // CV Internal type for created far 32-bit pointers
#define T_64NCVPTR      0x06f0      // CV Internal type for created near 64-bit pointers

#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))


/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */



    // leaf indices starting records but referenced from symbol records

#define LF_MODIFIER_16t     0x0001
#define LF_POINTER_16t      0x0002
#define LF_ARRAY_16t        0x0003
#define LF_CLASS_16t        0x0004
#define LF_STRUCTURE_16t    0x0005
#define LF_UNION_16t        0x0006
#define LF_ENUM_16t         0x0007
#define LF_PROCEDURE_16t    0x0008
#define LF_MFUNCTION_16t    0x0009
#define LF_VTSHAPE          0x000a
#define LF_COBOL0_16t       0x000b
#define LF_COBOL1           0x000c
#define LF_BARRAY_16t       0x000d
#define LF_LABEL            0x000e
#define LF_NULL             0x000f
#define LF_NOTTRAN          0x0010
#define LF_DIMARRAY_16t     0x0011
#define LF_VFTPATH_16t      0x0012
#define LF_PRECOMP_16t      0x0013      // not referenced from symbol
#define LF_ENDPRECOMP       0x0014      // not referenced from symbol
#define LF_OEM_16t          0x0015      // oem definable type string
#define LF_TYPESERVER       0x0016      // not referenced from symbol

    // leaf indices starting records but referenced only from type records

#define LF_SKIP_16t         0x0200
#define LF_ARGLIST_16t      0x0201
#define LF_DEFARG_16t       0x0202
#define LF_LIST             0x0203
#define LF_FIELDLIST_16t    0x0204
#define LF_DERIVED_16t      0x0205
#define LF_BITFIELD_16t     0x0206
#define LF_METHODLIST_16t   0x0207
#define LF_DIMCONU_16t      0x0208
#define LF_DIMCONLU_16t     0x0209
#define LF_DIMVARU_16t      0x020a
#define LF_DIMVARLU_16t     0x020b
#define LF_REFSYM           0x020c
                            
#define LF_BCLASS_16t       0x0400
#define LF_VBCLASS_16t      0x0401
#define LF_IVBCLASS_16t     0x0402
#define LF_ENUMERATE        0x0403
#define LF_FRIENDFCN_16t    0x0404
#define LF_INDEX_16t        0x0405
#define LF_MEMBER_16t       0x0406
#define LF_STMEMBER_16t     0x0407
#define LF_METHOD_16t       0x0408
#define LF_NESTTYPE_16t     0x0409
#define LF_VFUNCTAB_16t     0x040a
#define LF_FRIENDCLS_16t    0x040b
#define LF_ONEMETHOD_16t    0x040c
#define LF_VFUNCOFF_16t     0x040d

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
#define LF_TI16_MAX         0x1000

#define LF_MODIFIER         0x1001
#define LF_POINTER          0x1002
#define LF_ARRAY            0x1003
#define LF_CLASS            0x1004
#define LF_STRUCTURE        0x1005
#define LF_UNION            0x1006
#define LF_ENUM             0x1007
#define LF_PROCEDURE        0x1008
#define LF_MFUNCTION        0x1009
#define LF_COBOL0           0x100a
#define LF_BARRAY           0x100b
#define LF_DIMARRAY         0x100c
#define LF_VFTPATH          0x100d
#define LF_PRECOMP          0x100e      // not referenced from symbol
#define LF_OEM              0x100f      // oem definable type string
                            
    // leaf indices starting records but referenced only from type records
                            
#define LF_SKIP             0x1200
#define LF_ARGLIST          0x1201
#define LF_DEFARG           0x1202
#define LF_FIELDLIST        0x1203
#define LF_DERIVED          0x1204
#define LF_BITFIELD         0x1205
#define LF_METHODLIST       0x1206
#define LF_DIMCONU          0x1207
#define LF_DIMCONLU         0x1208
#define LF_DIMVARU          0x1209
#define LF_DIMVARLU         0x120a
                            
#define LF_BCLASS           0x1400
#define LF_VBCLASS          0x1401
#define LF_IVBCLASS         0x1402
#define LF_FRIENDFCN        0x1403
#define LF_INDEX            0x1404
#define LF_MEMBER           0x1405
#define LF_STMEMBER         0x1406
#define LF_METHOD           0x1407
#define LF_NESTTYPE         0x1408
#define LF_VFUNCTAB         0x1409
#define LF_FRIENDCLS        0x140a
#define LF_ONEMETHOD        0x140b
#define LF_VFUNCOFF         0x140c
#define LF_NESTTYPEEX       0x140d
#define LF_MEMBERMODIFY     0x140e




#define LF_NUMERIC          0x8000
#define LF_CHAR             0x8000
#define LF_SHORT            0x8001
#define LF_USHORT           0x8002
#define LF_LONG             0x8003
#define LF_ULONG            0x8004
#define LF_REAL32           0x8005
#define LF_REAL64           0x8006
#define LF_REAL80           0x8007
#define LF_REAL128          0x8008
#define LF_QUADWORD         0x8009
#define LF_UQUADWORD        0x800a
#define LF_REAL48           0x800b
#define LF_COMPLEX32        0x800c
#define LF_COMPLEX64        0x800d
#define LF_COMPLEX80        0x800e
#define LF_COMPLEX128       0x800f
#define LF_VARSTRING        0x8010
                            
#define LF_OCTWORD          0x8017
#define LF_UOCTWORD         0x8018
                            
#define LF_PAD0             0xf0
#define LF_PAD1             0xf1
#define LF_PAD2             0xf2
#define LF_PAD3             0xf3
#define LF_PAD4             0xf4
#define LF_PAD5             0xf5
#define LF_PAD6             0xf6
#define LF_PAD7             0xf7
#define LF_PAD8             0xf8
#define LF_PAD9             0xf9
#define LF_PAD10            0xfa
#define LF_PAD11            0xfb
#define LF_PAD12            0xfc
#define LF_PAD13            0xfd
#define LF_PAD14            0xfe
#define LF_PAD15            0xff

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_RESERVED    = 0x10  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**		Notes on alignment
 *		Alignment of the fields in most of the type records is done on the 
 *		basis of the TYPTYPE record base.  That is why in most of the lf*
 *		records that the CV_typ_t (32-bit types) is located on what appears to
 *		be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *		records that are in a list (lfFieldList, lfMethodList), which are
 *		aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

	Record type			Change (f == field arrangement, p = padding added)
	----------------------------------------------------------------------
	lfModifer			f
	lfPointer			fp
	lfClass				f
	lfStructure			f
	lfUnion				f
	lfEnum				f
	lfVFTPath			p
    lfPreComp           p
	lfOEM				p
	lfArgList			p
	lfDerived			p
	mlMethod			p	(method list member)
	lfBitField			f
	lfDimCon			f
	lfDimVar			p
	lfIndex				p	(field list member)
	lfBClass			f	(field list member)
	lfVBClass			f	(field list member)
	lfFriendCls			p	(field list member)
	lfFriendFcn			p	(field list member)
	lfMember			f	(field list member)
	lfSTMember			f	(field list member)
	lfVFuncTab			p	(field list member)
	lfVFuncOff			p	(field list member)
	lfNestType			p	(field list member)

	DATASYM32			f
	PROCSYM32			f
	VPATHSYM32			f
	REGREL32			f
	THREADSYM32			f
	PROCSYMMIPS			f

	
*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union  {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t			utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union  {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t	attr;           // method attribute
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t		index;          // index to type record for procedure
    unsigned long	vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
	                                // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
	                                // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
	_2BYTEPAD       pad0;			// internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
	_2BYTEPAD       pad0;		// internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
	S_REGISTER_16t	=  0x0002, // Register variable
	S_CONSTANT_16t	=  0x0003, // constant symbol
	S_UDT_16t		=  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME       =  0x0009, // path to object file name
    S_ENDARG        =  0x000a, // end of argument/return list
	S_COBOLUDT_16t	=  0x000b, // special UDT for cobol that does not symbol pack
	S_MANYREG_16t	=  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry
                       
    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address
                       
    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation
                       
    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start
                       
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
    S_ALIGN         =  0x0402, // Used for page alignment of symbols
    S_LPROCREF      =  0x0403, // Local Reference to a procedure

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
S_TI16_MAX          =  0x1000,
	S_REGISTER		=  0x1001, // Register variable
	S_CONSTANT		=  0x1002, // constant symbol
	S_UDT			=  0x1003, // User defined type
	S_COBOLUDT		=  0x1004, // special UDT for cobol that does not symbol pack
	S_MANYREG		=  0x1005, // multiple register variable
	S_BPREL32		=  0x1006, // BP-relative
	S_LDATA32		=  0x1007, // Module-local symbol
	S_GDATA32		=  0x1008, // Global data symbol
	S_PUB32 		=  0x1009, // a public symbol (CV internal reserved)
	S_LPROC32		=  0x100a, // Local procedure start
	S_GPROC32		=  0x100b, // Global procedure start
	S_VFTABLE32 	=  0x100c, // address of virtual function table
	S_REGREL32		=  0x100d, // register relative address
	S_LTHREAD32 	=  0x100e, // local thread storage
	S_GTHREAD32 	=  0x100f, // global thread storage

	S_LPROCMIPS 	=  0x1010, // Local procedure start
	S_GPROCMIPS 	=  0x1011, // Global procedure start
                       
} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMPRO   = 0x06,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43

} CV_CPU_TYPE_e;




//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO:1; // frame pointer present
            unsigned char CV_PFLAG_INT  :1; // interrupt return
            unsigned char CV_PFLAG_FAR  :1; // far return
            unsigned char CV_PFLAG_NEVER:1; // function does not return
            unsigned char unused        :4; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_REGISTER_16t
	CV_typ16_t		typind; 	// Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_MANYREG_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;



typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_CONSTANT_16t
	CV_typ16_t		typind; 	// Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_UDT_16t | S_COBOLUDT_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;





typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    CV_GENERIC_STYLE_e style;   // return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,
    THUNK_ORDINAL_ADJUSTOR,
    THUNK_ORDINAL_VCALL,
    THUNK_ORDINAL_PCODE
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table			= 0x00,	// not executable
    CEXM_MDL_jumptable		= 0x01, // Compiler generated jump table
    CEXM_MDL_datapad		= 0x02, // Data padding for alignment
    CEXM_MDL_native			= 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol			= 0x21, // cobol
    CEXM_MDL_codepad		= 0x22, // Code padding for alignment
    CEXM_MDL_code			= 0x23, // code
	CEXM_MDL_sql			= 0x30,	// sql
    CEXM_MDL_pcode			= 0x40, // pcode
    CEXM_MDL_pcode32Mac		= 0x41,	// macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var16 {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
	CV_typ16_t		root;		// type index of the root of path
	CV_typ16_t		path;		// type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;




typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var32 {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;


typedef enum CV_HREG_e {
    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

	//
	// JAVA VM registers
	//

	CV_JAVA_PC		= 1,


} CV_HREG_e;

#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\acache.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    acache.cxx
    
Abstract:

    ALLOC_CACHE_HANDLER dumpers

Author:

Revision History:

--*/

#include "precomp.hxx"

/************************************************************
 * Allocation cache Related functions
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig,
    IN BOOL  fEnableCleanupAsserts)
{}

ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{}


VOID
PrintAcacheHandler( IN ALLOC_CACHE_HANDLER * pachDebuggee,
                    IN ALLOC_CACHE_HANDLER * pachDebugger,
                    IN CHAR chVerbostity);

VOID
DumpAcacheGlobals( VOID );


VOID
DumpAcacheList(
    CHAR Verbosity
    );


DECLARE_API( acache )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    BOOL          fRet;
    ALLOC_CACHE_HANDLER * pach;

    //
    // Since ALLOC_CACHE_HANDLER is a C++ object with a non-void
    //  constructor, we will have to copy the contents to a temporary
    //  buffer and cast the value appropriately.
    //
    CHAR                 achItem[sizeof(ALLOC_CACHE_HANDLER)];
    ALLOC_CACHE_HANDLER * pachCopy = (ALLOC_CACHE_HANDLER *) achItem;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "acache" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "acache" );
            return;
        }

        if ( *lpArgumentString == 'g' )
        {
            DumpAcacheGlobals();
            return;
        }

        if ( *lpArgumentString == 'l' ) {

            DumpAcacheList( lpArgumentString[1] );
            return;
        }

    } // while

    //
    //  Treat the argument as the address of an AtqContext
    //

    dprintf( "inetdbg.acache: Trying to access %s\n",
             lpArgumentString );

    pach = (ALLOC_CACHE_HANDLER * ) GetExpression( lpArgumentString );

    if ( !pach )
    {
        dprintf( "inetdbg.acache: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    moveBlock( achItem, pach, sizeof(ALLOC_CACHE_HANDLER));
    PrintAcacheHandler( pach, pachCopy, '2' );

    return;
} // DECLARE_API( acache )


VOID
PrintAcacheHandler( ALLOC_CACHE_HANDLER * pachDebuggee,
                    ALLOC_CACHE_HANDLER * pachDebugger,
                    CHAR  chVerbosity)
{
    if ( chVerbosity >= '0') {
        dprintf(
                "ACACHE[%8p] "
                , pachDebuggee
                );
        dstring( "Name", (PVOID) pachDebugger->m_pszName, 40);
    }

    if ( chVerbosity >= '1') {
        dprintf("\t(Size=%d bytes, Concurrency=%d, Threshold=%u)"
                " FillPattern=%08lX\n"
                "\tTotal=%d."
                " Calls:(Alloc=%d, Free=%d)"
                " FreeEntries=%d. Heap=%p\n"
                ,
                pachDebugger->m_acConfig.cbSize,
                pachDebugger->m_acConfig.nConcurrency,
                pachDebugger->m_acConfig.nThreshold,
                pachDebugger->m_nFillPattern,
                pachDebugger->m_nTotal,
                pachDebugger->m_nAllocCalls, pachDebugger->m_nFreeCalls,
                pachDebugger->m_nFreeEntries, pachDebugger->m_hHeap
                );
    }

    return;
} // PrintAcacheHandler()

VOID
PrintAcacheHandlerThunk( PVOID pachDebuggee,
                         PVOID pachDebugger,
                         CHAR  chVerbosity,
                         DWORD iCount)
{
    dprintf( "[%d] ", iCount);
    PrintAcacheHandler( (ALLOC_CACHE_HANDLER *) pachDebuggee,
                        (ALLOC_CACHE_HANDLER *) pachDebugger,
                        chVerbosity);
    return;
} // PrintAcacheHandlerThunk()

VOID
DumpAcacheGlobals( VOID )
{
    LIST_ENTRY * pachList;
    LIST_ENTRY   achList;

    dprintf("Allocation Cache Globals:\n");

    pachList = (LIST_ENTRY *)
        GetExpression( "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");

    if ( NULL == pachList) {

        dprintf( " Unable to get Allocation cache list object, %s\n",
                 "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");
        return;
    }

    move( achList, pachList);

    dprintf( " AllocCacheList  Flink = %08p  Blink = %08p\n",
             achList.Flink, achList.Blink
             );

    dprintf("\tsizeof(ALLOC_CACHE_HANDLER) = %d\n",
            sizeof(ALLOC_CACHE_HANDLER));
    return;
} // DumpAcacheGlobals()




VOID
DumpAcacheList(
    CHAR Verbosity
    )
{
    LIST_ENTRY *         pachListHead;

    pachListHead = (LIST_ENTRY *)
        GetExpression( "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");

    if ( NULL == pachListHead) {

        dprintf( " Unable to get Alloc Cache List object, %s\n",
                 "&iisutil!ALLOC_CACHE_HANDLER__sm_lItemsHead");
        return;
    }

    EnumLinkedList( pachListHead, PrintAcacheHandlerThunk, Verbosity,
                    sizeof( ALLOC_CACHE_HANDLER),
                    FIELD_OFFSET( ALLOC_CACHE_HANDLER, m_lItemsEntry)
                    );
    return;
} // DumpAcacheList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\dbginet.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbginet.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    Internet Information Server

Author:

    Murali R. Krishnan (MuraliK)  16-Sept-1996

Revision History:

--*/

#include "precomp.hxx"



/************************************************************
 * Dump Symbols from stack
 ************************************************************/


DECLARE_API( ds )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    symbols on the stack.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR startingAddress;
    ULONG_PTR stack;
    ULONG_PTR i;
    UCHAR symbol[MAX_SYMBOL_LEN];
    ULONG_PTR offset;
    PCHAR format;
    BOOL validSymbolsOnly = FALSE;
    MODULE_INFO moduleInfo;


    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '-' ) {
        lpArgumentString++;
        switch( *lpArgumentString ) {
        case 'v' :
        case 'V' :
            validSymbolsOnly = TRUE;
            lpArgumentString++;
            break;

        default :
            PrintUsage( "ds" );
            return;
        }
    }

    while( *lpArgumentString == ' ' ) {
        lpArgumentString++;
    }

    //
    // By default, start at the current stack location. Otherwise,
    // start at the given address.
    //

    if( !*lpArgumentString ) {
#if defined(_X86_)
        lpArgumentString = "esp";
#elif defined(_AMD64_)
        lpArgumentString = "rsp";
#elif defined(_IA64_)
        lpArgumentString = "sp";
#else
#error "unsupported CPU"
#endif
    }

    startingAddress = GetExpression( lpArgumentString );

    if( startingAddress == 0 ) {

        dprintf(
            "dtext!ds: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Ensure startingAddress is properly aligned.
    //

    startingAddress &= ~(sizeof(PVOID)-1);

    //
    // Read the stack.
    //

    for( i = 0 ; i < NUM_STACK_SYMBOLS_TO_DUMP ; startingAddress += sizeof(PVOID) ) {

        if( CheckControlC() ) {
            break;
        }

        if( ReadMemory(
                startingAddress,
                &stack,
                sizeof(stack),
                NULL
                ) ) {

            GetSymbol(
                stack,
                symbol,
                &offset
                );

            if( symbol[0] == '\0' ) {
                if( FindModuleByAddress(
                        stack,
                        &moduleInfo
                        ) ) {
                    strcpy( (CHAR *)symbol, moduleInfo.FullName );
                    offset = DIFF(stack - moduleInfo.DllBase);
                }
            }

            if( symbol[0] == '\0' ) {
                if( validSymbolsOnly ) {
                    continue;
                }
                format = "%08p : %08p\n";
            } else
            if( offset == 0 ) {
                format = "%08p : %08p : %s\n";
            } else {
                format = "%08p : %08p : %s+0x%p\n";
            }

            dprintf(
                format,
                startingAddress,
                stack,
                symbol,
                offset
                );

            i++;

        } else {

            dprintf(
                "dtext!ds: cannot read memory @ %lx\n",
                startingAddress
                );

            return;

        }

    }

    dprintf(
        "!dtext.ds %s%lx to dump next block\n",
        validSymbolsOnly ? "-v " : "",
        startingAddress
        );

} // DECLARE_API( ds )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\dbgirtl.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbgirtl.cxx

Abstract:

    This module contains the iisrtl-related ntsd debugger extensions for
    Internet Information Server

Author:

    George V. Reilly (georgere)   24-Mar-1998

Revision History:

--*/


#include "precomp.hxx"


//
// Worker routines.
//



//
// NTSD extension entrypoints.
//

DECLARE_API( lkhash )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an LKHash table

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG address;
    BOOLEAN verbose;

    INIT_API();

    //
    // Establish defaults.
    //

    verbose = FALSE;

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    //
    // Process switches.
    //

    while( *lpArgumentString == '-' ) {

        lpArgumentString++;

        while( *lpArgumentString != ' ' &&
               *lpArgumentString != '\t' &&
               *lpArgumentString != '\0' ) {

            switch( *lpArgumentString ) {
            case 'v' :
            case 'V' :
                verbose = !verbose;
                break;

            case '-' :  // Set the switches the way I like them. --keithmo
                verbose = TRUE;
                break;

            default :
                PrintUsage( "lkhash" );
                return;

            }

            lpArgumentString++;

        }

        while( *lpArgumentString == ' ' ||
               *lpArgumentString == '\t' ) {
            lpArgumentString++;
        }

    }

    if( *lpArgumentString != '\0' ) {

        //
        // Dump a single object.
        //

        address = GetExpression( lpArgumentString );

        if( address == 0 ) {

            dprintf(
                "dtext: cannot evaluate \"%s\"\n",
                lpArgumentString
                );

            return;

        }


        return;

    }


} // DECLARE_API( fcache )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\dbglkrh.cxx ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    dbglkrh.cxx

Abstract:

    LKRhash support

Author:

    George V. Reilly (GeorgeRe)  22-Feb-1999

Revision History:

--*/

#include "precomp.hxx"

#include "lkrcust.h"

#define LKR_CUST_DECLARE_TABLE
#include "lkrcust.h"

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets = 0;
LONG CLKRLinearHashTable::sm_cTables           = 0;
#endif // LOCK_INSTRUMENTATION

#define CMDNAME "lkrhash"

// There are several different DLLs in the IISRTL family. This is to
// allow us to set the name of the DLL on the fly.
// TODO: add a command to set this name dynamically.

#ifndef LKRHASH_NAME
# define LKRHASH_NAME "iisutil"
#endif // LKRHASH_NAME

CHAR g_szLKRhashDllName[MAX_PATH] = LKRHASH_NAME;

// sprintf-formatted string, e.g., "&%s!CLKRHashTable__sm_llGlobalList"
// Has to return LPSTR, not LPCSTR, because GetExpression is not const-correct
LPSTR
LKRhashDllVar(
    LPCSTR pszFormat)
{
    // we can get away with a static CHAR[] because debugger extensions
    // are single-threaded
    static CHAR szSymbol[MAX_SYMBOL_LEN];

    sprintf(szSymbol, pszFormat, g_szLKRhashDllName);
    return szSymbol;
}

#ifndef __LKRHASH_NO_NAMESPACE__
 #define STR_LKRHASH_NS "LKRhash__"
#else
 #define STR_LKRHASH_NS ""
#endif // !__LKRHASH_NO_NAMESPACE__

// Dummy implementations so that we can link

LKRHASH_NS::CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double   maxload,               // Upperbound on average chain length
    DWORD    initsize,              // Initial size of hash table.
    DWORD    num_subtbls,           // for signature compatiblity
                                    // with CLKRHashTable
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    : m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL),
      m_fMultiKeys(fMultiKeys)
{}

LKRHASH_NS::CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    : m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL),
      m_fMultiKeys(fMultiKeys)
{}

LKRHASH_NS::CLKRLinearHashTable::~CLKRLinearHashTable()
{}

LKRHASH_NS::CLKRHashTable::CLKRHashTable(
    LPCSTR   pszName,               // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double   maxload,               // Upperbound on average chain length
    DWORD    initsize,              // Initial size of hash table.
    DWORD    num_subtbls,           // #subordinate hash tables
    bool            fMultiKeys      // Allow multiple identical keys?
    )
{}

LKRHASH_NS::CLKRHashTable::~CLKRHashTable()
{}



/************************************************************
 * Dump LKRhash tables
 ************************************************************/
const char*
LKRC2String(
    LK_RETCODE lkrc)
{
    const char* psz = NULL;

    switch (lkrc)
    {
    case LK_UNUSABLE:
        psz = "LK_UNUSABLE";
        break;
    case LK_ALLOC_FAIL:
        psz = "LK_ALLOC_FAIL";
        break;
    case LK_BAD_ITERATOR:
        psz = "LK_BAD_ITERATOR";
        break;
    case LK_BAD_RECORD:
        psz = "LK_BAD_RECORD";
        break;
    case LK_BAD_PARAMETERS:
        psz = "LK_BAD_PARAMETERS";
        break;
    case LK_NOT_INITIALIZED:
        psz = "LK_NOT_INITIALIZED";
        break;
    case LK_SUCCESS:
        psz = "LK_SUCCESS";
        break;
    case LK_KEY_EXISTS:
        psz = "LK_KEY_EXISTS";
        break;
    case LK_NO_SUCH_KEY:
        psz = "LK_NO_SUCH_KEY";
        break;
    case LK_NO_MORE_ELEMENTS:
        psz = "LK_NO_MORE_ELEMENTS";
        break;
    default:
        psz = "Unknown LK_RETCODE";
        break;
    }

    return psz;
}


enum {
    NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
    BUCKET_BYTE_SIZE = CNodeClump::BUCKET_BYTE_SIZE,
    HASH_INVALID_SIGNATURE =
        LKRHASH_NS::CLKRLinearHashTable::HASH_INVALID_SIGNATURE,
    LKLH_SIGNATURE =      LKRHASH_NS::CLKRLinearHashTable::SIGNATURE,
    LKLH_SIGNATURE_FREE = LKRHASH_NS::CLKRLinearHashTable::SIGNATURE_FREE,
    LKHT_SIGNATURE =      LKRHASH_NS::CLKRHashTable::SIGNATURE,
    LKHT_SIGNATURE_FREE = LKRHASH_NS::CLKRHashTable::SIGNATURE_FREE,
};


BOOL
EnumerateBucketChain(
    LKR_CUST_EXTN*    plce,
    IN LOCK_LOCKTYPE  ltBucketLockType,
    IN INT            iBkt,
    IN CBucket*       pbkt,
    IN INT            nVerbose)
{
    PSTR        cmdName = CMDNAME;
    BYTE        abBkt[BUCKET_BYTE_SIZE];
    DEFINE_CPP_VAR(CNodeClump, nc);
    CNodeClump* pnc = GET_CPP_VAR_PTR(CNodeClump, nc);
    CNodeClump* pncCurr;
    DWORD       cNodes = 0, cnc = 0;
    BOOL        fLockPrinted = FALSE;

    ReadMemory(pbkt, abBkt, sizeof(abBkt), NULL);

    for (pncCurr = (CNodeClump*) ((PBYTE) pbkt + LockSize(ltBucketLockType));
         pncCurr != NULL;
         pncCurr = pnc->m_pncNext)
    {
        DWORD i, c;

        ReadMemory(pncCurr, &nc, sizeof(nc), NULL);

        for (i = c = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                c++;
        }

        if (c == NODES_PER_CLUMP)
        {
            if (nVerbose >= 3)
                dprintf("  0-%d: -- empty\n", NODES_PER_CLUMP);
        }
        else
        {
            if (cnc++ == 0)
                PrintLock(ltBucketLockType, &pbkt->m_Lock, nVerbose);
            
            dprintf("Bucket %4d, %d:\n", iBkt, cnc);
            for (i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                {
                    if (nVerbose >= 3)
                        dprintf("  %d: --\n", i);
                    else
                        break;
                }
                else if (plce != NULL)
                {
                    if (!(*plce->m_pfn_Record_Dump)(pnc->m_pvNode[i],
                                                    pnc->m_dwKeySigs[i],
                                                    nVerbose))
                        return FALSE;
                }
            }
        }

        if (CheckControlC())
        {
            dprintf("\n^C\n");
            return FALSE;
        }

        const DWORD MAX_NODES = 20;
        if (++cNodes > MAX_NODES)
        {
            dprintf(DBGEXT ".%s: Bucket chain contains more than %d nodes! "
                    "Corrupted?\n", cmdName, MAX_NODES);
            return TRUE;
        }
    }

    return TRUE;
}



BOOL
EnumerateLKRLinearHashTable(
    LKR_CUST_EXTN*       plce,
    IN CLinearHashTable* plht,
    IN INT               nVerbose)
{
    PSTR cmdName = CMDNAME;
    CLinearHashTable lht(NULL, NULL, NULL, NULL, NULL);
    INT i;
    BOOL fRet = FALSE;
    LOCK_LOCKTYPE ltTableLockType  = LOCK_SPINLOCK;
    LOCK_LOCKTYPE ltBucketLockType = LOCK_SPINLOCK;
    CDirEntry* paDirSegs = NULL;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(plht, &lht, sizeof(lht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)plht);

        goto cleanup;
    }

    dprintf(
        "\n" DBGEXT ".%s: @ %p:\n"
        "    CLKRLinearHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    State = %d (%s)\n",
        cmdName,
        plht,
        lht.m_dwSignature,
        DECODE_SIGNATURE(lht.m_dwSignature),
        lht.m_dwSignature == LKLH_SIGNATURE
            ? "OK" : (lht.m_dwSignature == LKLH_SIGNATURE_FREE
                      ? "FREED" : "INVALID"),
        lht.m_szName,
        lht.m_lkrcState, LKRC2String(lht.m_lkrcState));

    if (nVerbose == 0)
        goto done;

    ltTableLockType  = (LOCK_LOCKTYPE) lht.m_nTableLockType;
    ltBucketLockType = (LOCK_LOCKTYPE) lht.m_nBucketLockType;
    dprintf(
        "    TableLock = %s, BucketLock = %s, Parent CLKRHashTable = %p\n",
        LockName(ltTableLockType),
        LockName(ltBucketLockType),
        lht.m_phtParent);

    dprintf(
        "    Size = %d, SegBits = %d, SegSize = %d, SegMask = %x\n",
        lht.m_lkts, lht.m_dwSegBits, lht.m_dwSegSize, lht.m_dwSegMask);
    dprintf(
        "    MaxLoad = %3.1f, paDirSegs = %p, cDirSegs = %d\n",
        lht.m_MaxLoad, lht.m_paDirSegs, lht.m_cDirSegs);
    dprintf(
        "    cRecords = %d, cActiveBuckets = %d, BucketSpins = %hd\n",
        lht.m_cRecords, lht.m_cActiveBuckets, lht.m_wBucketLockSpins);
    dprintf(
        "    nLevel = %d, dwBktAddrMask0 = %x, iExpansionIdx = %d\n",
        lht.m_nLevel, lht.m_dwBktAddrMask0, lht.m_iExpansionIdx);

    PrintLock(ltTableLockType, &plht->m_Lock, nVerbose);

    if (plce != NULL  &&  !(*plce->m_pfn_LKLH_Dump)(plht, nVerbose))
        goto done;
    
    if (nVerbose == 1)
        goto done;
    
    paDirSegs = (CDirEntry*) calloc(lht.m_cDirSegs, sizeof(CDirEntry));

    if (paDirSegs == NULL)
    {
        dprintf("Couldn't allocate %d bytes for directory segment\n",
                lht.m_cDirSegs * sizeof(CDirEntry));
        return fRet;
    }
    
    if (!ReadMemory(lht.m_paDirSegs, paDirSegs,
                    sizeof(CDirEntry) * lht.m_cDirSegs, NULL))
        goto cleanup;

    for (i = 0;  i < (INT) (lht.m_cDirSegs * lht.m_dwSegSize);  i++)
    {
        const DWORD iSeg = i >> lht.m_dwSegBits;
        CLargeSegment* pseg =
            static_cast<CLargeSegment*>(paDirSegs[iSeg].m_pseg);

        if ((i & lht.m_dwSegMask) == 0)
            dprintf("Segment %d: %p\n", iSeg, pseg);

        if (pseg == NULL)
            continue;

        if (nVerbose >= 2)
        {
            CBucket* pbkt = pseg->m_bktSlots + (i & lht.m_dwSegMask);
            
            if (!EnumerateBucketChain(plce, ltBucketLockType,
                                      i, pbkt, nVerbose))
                goto cleanup;
        }

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;

  cleanup:
    memset(&lht, 0, sizeof(lht));
    free(paDirSegs);
    return fRet;
}



BOOL
EnumerateLKRhashTable(
    LKR_CUST_EXTN*    plce,
    IN CHashTable*    pht,
    IN INT            nVerbose)
{
    CHashTable ht(NULL, NULL, NULL, NULL, NULL);
    PSTR cmdName = CMDNAME;
    CLinearHashTable** palhtDir = NULL;
    UINT i;
    BOOL fRet = FALSE;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(pht, &ht, sizeof(ht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)pht);

        goto cleanup;
    }

    dprintf(
        DBGEXT ".%s: @ %p:\n"
        "    CLKRHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    %d subtables, State = %d (%s)\n",
        cmdName,
        pht,
        ht.m_dwSignature,
        DECODE_SIGNATURE(ht.m_dwSignature),
        ht.m_dwSignature == LKHT_SIGNATURE
            ? "OK"
            : ht.m_dwSignature == LKHT_SIGNATURE_FREE
              ? "FREED"
              : "INVALID",
        ht.m_szName,
        ht.m_cSubTables,
        ht.m_lkrcState, LKRC2String(ht.m_lkrcState)
        );

    if (plce != NULL  &&  !(*plce->m_pfn_LKHT_Dump)(pht, nVerbose))
        goto done;
    
    if (nVerbose == 0)
        goto done;

    palhtDir = (CLinearHashTable**) calloc(ht.m_cSubTables,
                                           sizeof(CLinearHashTable*));
    if (!palhtDir)
        goto cleanup;
    
    if (!ReadMemory(ht.m_palhtDir, palhtDir,
                    ht.m_cSubTables * sizeof(CLinearHashTable*), NULL))
        goto cleanup;

    for (i = 0;  i < ht.m_cSubTables;  ++i)
    {
        dprintf("\n%d : ", i);
        if (!EnumerateLKRLinearHashTable(plce, palhtDir[i], nVerbose))
            break;

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;
    
  cleanup:
    free(palhtDir);

    return fRet;
}



VOID
PrintLKRLinearHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CLinearHashTable*) psdDebugger)->m_dwSignature;

    if (dwSig != LKLH_SIGNATURE)
    {
        dprintf( "CLKRLinearHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee, dwSig, DECODE_SIGNATURE(dwSig),
                 LKLH_SIGNATURE, DECODE_SIGNATURE(LKLH_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) psdDebuggee,
                                    chVerbosity);
}



VOID
PrintLKRHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CHashTable*) psdDebugger)->m_dwSignature;
    if (dwSig != LKHT_SIGNATURE)
    {
        dprintf( "CLKRHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee,
                 dwSig, DECODE_SIGNATURE(dwSig),
                 LKHT_SIGNATURE, DECODE_SIGNATURE(LKHT_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRhashTable(plce, (CHashTable*) psdDebuggee,
                              chVerbosity);
}



VOID
DumpLKRsList(
    IN INT              nVerbose)
{
    CLockedDoubleList* plstHashTables = (CLockedDoubleList*) GetExpression(
                        LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                      "CLKRHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("%s!" STR_LKRHASH_NS
                              "CLKRHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CHashTable),
                    FIELD_OFFSET( CHashTable, m_leGlobalList));


    plstHashTables = (CLockedDoubleList*) GetExpression(
                      LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                    "CLKRLinearHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("!" STR_LKRHASH_NS
                              "CLKRLinearHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRLinearHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRLinearHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CLinearHashTable),
                    FIELD_OFFSET( CLinearHashTable, m_leGlobalList));
    return;
} // DumpLKRsList()





DECLARE_API( lkrhash )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an LKRhash table.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

    ULONG_PTR lkrAddress = 0;
    INT nVerbose = 0;
    PSTR cmdName = CMDNAME;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( cmdName );
            return;
        }

        if ( *lpArgumentString == 'l' ) {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
        }

        if ( *lpArgumentString == 'v' )
        {
            lpArgumentString++;
            nVerbose = 99;
        }

        if ( *lpArgumentString == 'g' )
        {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
            DumpLKRsList(nVerbose);
            return;
        }

    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    lkrAddress = (ULONG_PTR) GetExpression( lpArgumentString );

    if (lkrAddress == 0) {

        dprintf(
            DBGEXT ".%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    DWORD dwSig;
    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, (VOID*) lkrAddress, dwSig);

    if (plce == NULL)
        goto cleanup;
    
    if (dwSig == LKHT_SIGNATURE || dwSig == LKHT_SIGNATURE_FREE)
    { 
        EnumerateLKRhashTable(plce,
                              (CHashTable*) lkrAddress,
                              nVerbose);
    }
    else if (dwSig == LKLH_SIGNATURE || dwSig == LKLH_SIGNATURE_FREE)
    { 
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) lkrAddress,
                                    nVerbose);
    }
    else
    {
        dprintf(DBGEXT ".%s: %p does not contain a valid LKRhash table\n",
                cmdName, (PVOID)lkrAddress);
    }
    
cleanup:
    return;
} // DECLARE_API( lkrhash )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\dbglocks.cxx ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    dbglocks.cxx

Abstract:

    Locks support

Author:

    George V. Reilly (GeorgeRe)  01-Mar-1999

Revision History:

--*/

#include "precomp.hxx"

#ifdef LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME ("lkrdbg")
# ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
LONG CSmallSpinLock::sm_cTotalLocks   = 0;
# endif

#ifdef TEST_LOCKS
LONG CSpinLock1::sm_cTotalLocks        = 0;
LONG CSpinLock2::sm_cTotalLocks       = 0;
#endif // TEST_LOCKS

LONG CSpinLock::sm_cTotalLocks       = 0;
LONG CReaderWriterLock::sm_cTotalLocks  = 0;
LONG CReaderWriterLock2::sm_cTotalLocks = 0;
LONG CReaderWriterLock3::sm_cTotalLocks = 0;
#else // !LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME 
#endif // !LOCK_INSTRUMENTATION

const char*
LockName(
    LOCK_LOCKTYPE lt)
{
    const char* pszName = NULL;

    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        pszName = "CSmallSpinLock";
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        pszName = "CSpinLock1";
        break;
    case LOCK_SPINLOCK2:
        pszName = "CSpinLock2";
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        pszName = "CSpinLock";
        break;
    case LOCK_FAKELOCK:
        pszName = "CFakeLock";
        break;
    case LOCK_CRITSEC:
        pszName = "CCritSec";
        break;
    case LOCK_READERWRITERLOCK:
        pszName = "CReaderWriterLock";
        break;
    case LOCK_READERWRITERLOCK2:
        pszName = "CReaderWriterLock2";
        break;
    case LOCK_READERWRITERLOCK3:
        pszName = "CReaderWriterLock3";
        break;
    default:
        pszName = "UnknownLockType";
        break;
    }

    return pszName;
};

int
LockSize(
    LOCK_LOCKTYPE lt)
{
    int cb = 0;

    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        cb = sizeof(CSmallSpinLock);
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        cb = sizeof(CSpinLock1);
        break;
    case LOCK_SPINLOCK2:
        cb = sizeof(CSpinLock2);
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        cb = sizeof(CSpinLock);
        break;
    case LOCK_FAKELOCK:
        cb = sizeof(CFakeLock);
        break;
    case LOCK_CRITSEC:
        cb = sizeof(CCritSec);
        break;
    case LOCK_READERWRITERLOCK:
        cb = sizeof(CReaderWriterLock);
        break;
    case LOCK_READERWRITERLOCK2:
        cb = sizeof(CReaderWriterLock2);
        break;
    case LOCK_READERWRITERLOCK3:
        cb = sizeof(CReaderWriterLock3);
        break;
    default:
        cb = 0;
        break;
    }

    return cb;
};



BOOL
Print_SmallSpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    CSmallSpinLock sl LOCK_DEFAULT_NAME;
#else // !LOCK_SMALL_SPIN_INSTRUMENTATION
    CSmallSpinLock sl;
#endif // !LOCK_SMALL_SPIN_INSTRUMENTATION

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSmallSpinLock (%p): Thread = %x\n",
            pvLock, sl.m_lTid);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



#ifdef TEST_LOCKS

BOOL
Print_SpinLock1(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock1 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock1 (%p): ssl = %x, Thread = %hd, Owners = %d, RW = %d\n",
            pvLock, sl.m_ssl.m_lLock, sl.m_nThreadId,
            (int) sl.m_cOwners, (int) sl.m_nRWState);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_SpinLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock2 (%p): Thread = %hd, Count = %hd\n",
            pvLock, sl.m_data.m_nThreadId, sl.m_data.m_cOwners);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}

#endif // TEST_LOCKS


BOOL
Print_SpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock (%p): Thread = %d, Count = %d\n",
            pvLock,
            (sl.m_lTid & CSpinLock::THREAD_MASK) >> CSpinLock::THREAD_SHIFT,
            (sl.m_lTid & CSpinLock::OWNER_MASK) >> CSpinLock::OWNER_SHIFT);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_FakeLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_CritSec(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_ReaderWriterLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock (%p): State = %x, Waiters = %d\n",
            pvLock, sl.m_nState, sl.m_cWaiting);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock2 (%p): State = %x, Waiters = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock2::SL_STATE_MASK)
                >> CReaderWriterLock2::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock2::SL_WAITING_MASK)
                >> CReaderWriterLock2::SL_WAITING_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock3(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock3 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock3 (%p): State = %x, Waiters = %d, "
            "Thrd = %x, Cnt = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock3::SL_STATE_MASK)
                >> CReaderWriterLock3::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock3::SL_WAITING_MASK)
                >> CReaderWriterLock3::SL_WAITING_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_THREAD_MASK)
                >> CReaderWriterLock3::SL_THREAD_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_OWNER_MASK)
                >> CReaderWriterLock3::SL_OWNER_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
PrintLock(
    LOCK_LOCKTYPE lt,
    IN PVOID      pvLock,
    IN INT        nVerbose)
{
    BOOL f = FALSE;
    switch (lt)
    {
    case LOCK_SMALLSPINLOCK:
        f = Print_SmallSpinLock(pvLock, nVerbose);
        break;
#ifdef TEST_LOCKS
    case LOCK_SPINLOCK1:
        f = Print_SpinLock1(pvLock, nVerbose);
        break;
    case LOCK_SPINLOCK2:
        f = Print_SpinLock2(pvLock, nVerbose);
        break;
#endif // TEST_LOCKS
    case LOCK_SPINLOCK:
        f = Print_SpinLock(pvLock, nVerbose);
        break;
    case LOCK_FAKELOCK:
        f = Print_FakeLock(pvLock, nVerbose);
        break;
    case LOCK_CRITSEC:
        f = Print_CritSec(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK:
        f = Print_ReaderWriterLock(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK2:
        f = Print_ReaderWriterLock2(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK3:
        f = Print_ReaderWriterLock3(pvLock, nVerbose);
        break;
    default:
        f = FALSE;
        break;
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\dbgthunk.cxx ===
/*++


   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       dbgthunk.cxx

   Abstract:
       This module defines all thunks for inlined functions, so that the
       debugger extension DLL can be peacefully linked.

   Author:

       Murali R. Krishnan    ( MuraliK )     24-Aug-1997

   Environment:
       Debugging Mode - NTSD Debugger Extension DLL

   Project:

       IIS Debugger Extensions DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"

# undef DBG_ASSERT

# define minSize(a, b)  (((a) < (b)) ? (a) : (b))


DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *   Debugger Utility Functions
 ************************************************************/

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;


/************************************************************
 *    Utility Functions
************************************************************/

VOID
dstring( CHAR * pszName, PVOID pvString, DWORD cbLen)
/*++
  Description:
    This function reads the data from the debuggee process at
    address [pvString] for specified length [cbLen] and echoes
    the string back on the debugger window.

  Arguments:
    pszName - pointer to string containing the name of the string read
    pvString - pointer to VOID specifying the location of the string
               in the debugee process
    cbLen   - count of bytes to be read at [pvString]

  Returns:
     None
--*/
{
    CHAR rgchString[10240];
    DWORD cLength = minSize( cbLen, sizeof(rgchString) -1);

    //
    // Read the data block from the debuggee process into local buffer
    //
    moveBlock( rgchString, pvString, cLength);

    rgchString[cLength] = '\0'; // terminate the string buffer
    dprintf( "%s = %s\n", pszName, rgchString);

    return;
} // dstring()



VOID
PrintLargeInteger( CHAR * pszName, LARGE_INTEGER * pli)
{
    CHAR  szLargeInt[100];

    RtlLargeIntegerToChar( pli,  // large integer location
                           10,   // base for conversion
                           sizeof(szLargeInt),
                           szLargeInt );
    dprintf( " %30s = %s\n", pszName, szLargeInt);
    return;

} // PrintLargeInteger()

VOID
Print2Dwords( CHAR * pszN1, DWORD d1,
              CHAR * pszN2, DWORD d2
              )
{
    dprintf("    %25s =%8d  %25s =%8d\n",
             pszN1, d1,
             pszN2, d2
             );
    return;
} // Print2Dwords()



BOOL
EnumLinkedList(
    IN LIST_ENTRY  *       pListHead,
    IN PFN_LIST_ENUMERATOR pfnListEnumerator,
    IN CHAR                chVerbosity,
    IN DWORD               cbSizeOfStructure,
    IN DWORD               cbListEntryOffset
    )
/*++
  Description:
    This function iterates over the NT's standard LIST_ENTRY structure
    (doubly linked circular list with header) and makes callbacks for
    objects found on the list.

  Arguments:
    pListHead  - pointer to List head in the debugee process
    pfnListEnumerator - pointer to callback function for the object on the list
    chVerbosity - character indicating the verbosity level desired
    cbSizeOfStructure - count of bytes of object's size
    cbListEntryOffset - count of bytes of offset of the List entry structure
                           inside the containing object

  Returns:
     TRUE on successful enumeration
     FALSE on failure
--*/
{
# define MAX_STRUCTURE_SIZE        (10240)
    CHAR           rgch[MAX_STRUCTURE_SIZE];
    PVOID          pvDebuggee = NULL;
    PVOID          pvDebugger = (PVOID ) rgch;

    LIST_ENTRY     leListHead;
    LIST_ENTRY *   pListEntry;

    CHAR           Symbol[256];
    DWORD          cItems = 0;

    if ( NULL == pListHead) {
        dprintf( "Invalid List given \n");
        return (FALSE);
    }

    if ( MAX_STRUCTURE_SIZE < cbSizeOfStructure) {
        dprintf( "Given size for structure %d exceeds default max %d bytes\n",
                 cbSizeOfStructure, MAX_STRUCTURE_SIZE);
        return (FALSE);
    }

    // make a local copy of the list head for navigation purposes
    MoveWithRet( leListHead, pListHead, FALSE);

    for ( pListEntry  = leListHead.Flink;
          pListEntry != pListHead;
          )
    {
        if ( CheckControlC() )
        {
            return (FALSE);
        }

        pvDebuggee = (PVOID ) ((PCHAR ) pListEntry - cbListEntryOffset);

        // make a local copy of the debuggee structure
        MoveBlockWithRet( rgch, pvDebuggee, cbSizeOfStructure, FALSE);

        cItems++;

        if( pfnListEnumerator ) {
            (*pfnListEnumerator)( pvDebuggee, pvDebugger, chVerbosity, cItems);
            dprintf( "\n");
        }

        MoveWithRet( pListEntry, &pListEntry->Flink, FALSE );
    } // for all linked list entries

    dprintf( "%d entries traversed\n", cItems );

    return (TRUE);
} // EnumLinkedList()



/*++
  Description:
    COM objects registered as LocalServer result in running in a separate
    process. The base process communicates with these COM objects using RPC.
    It is often required to find the process id of destination process.


    The function cracks the process id of the target process given the first
    parameter to the function
       ole32!CRpcChannelBuffer__SendReceive()

  Argument:
  arg1 - pointer to string containing the parameter that is the hex-value
          of the RPC structure's location (which is the first param of
          function ole32!CRpcChannelBuffer__SendReceive())

 Standard NTSD parameters:
    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

  Returns:
    None

--*/
DECLARE_API( rpcoop )
{
#if _WIN64
    dprintf("rpcoop: Not implemented for 64bit");
#else
    DWORD *   pRpcParam1;
    DWORD    dwContent;

    INIT_API();
    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "rpcoop" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "rpcoop" );
            return;
        }

    } // while

    //
    //  Treat the argument as the param1 of the RPC function
    //

    pRpcParam1 = (DWORD * ) GetExpression( lpArgumentString );

    if ( !pRpcParam1 )
    {
        dprintf( "dtext.rpcoop: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    //
    // get the contents of the memory at seventh DWORD to pRpcParam1
    // ie. get [pRpcParam1 + 0x6]
    //  - this is valid based on NT 4.0 SP3 code base :(
    //
    move( dwContent, pRpcParam1 + 0x6 );

    //
    // dwContent now contains the address of another structure
    //   that carries the remote process Id
    // get the contents of the memory at seventh DWORD to dwContent
    // ie. get [dwContent + 9]
    //  - this is valid based on NT 4.0 SP3 code base :(
    //
    DWORD  dwProcessId;

    move( dwProcessId, ((LPDWORD ) dwContent) + 9);

    //
    // dump the process id to debugger screen
    //
    dprintf("\tRPC process ID = %d (0x%x)\n", dwProcessId, dwProcessId);
#endif
    return;
} // DECLARE_API( rpcoop )

DECLARE_API( llc )

/*++

Routine Description:

    This function is called as an NTSD extension to count the LIST_ENTRYs
    on a linked list.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    PLIST_ENTRY remoteListHead;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "llc" );
        return;
    }

    //
    // Get the list head.
    //

    remoteListHead = (PLIST_ENTRY)GetExpression( lpArgumentString );

    if( remoteListHead == NULL ) {
        dprintf( "!llc: cannot evaluate %s\n", lpArgumentString );
        return;
    }

    //
    // Let the enumerator do the dirty work.
    //

    EnumLinkedList(
        remoteListHead,
        NULL,
        0,
        sizeof(LIST_ENTRY),
        0
        );

}   // DECLARE_API( llc )


/************************************************************
 *  FAKE Functions
 *
 *  Fake the definitions of certain functions that belong only
 *   in the local compilation of w3svc & infocomm dlls
 *
 ************************************************************/

extern "C" {

    //
    // NTSD Extensions & CRTDLL likes to have the main() function
    // Let us throw this in as well, while we are in the business
    // of faking several other functions :)
    //

void _cdecl main( void )
{
    ;
}

}

__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
{ return (0); }




/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\dumpoff.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dumpoff.cxx

Abstract:

    Structure dumper

Author:

    Bilal Alam      (balam)     Oct-17-1998 Initial Revision

--*/

#include "precomp.hxx"
#include "oemdbi.h"
#include "cvinfo.h"
#include "imagehlp.h"

#define INVALID_LENGTH              ((DWORD)-1)

#define MAX_MEMBERNAME_LENGTH       256
#define MAX_TYPENAME_LENGTH         256

typedef DWORD (*PFN_READ_MEMORY) (
    VOID * address, 
    DWORD cbBytes, 
    VOID *pBuffer 
);

typedef DWORD (*PFN_PRINTF) (
    CHAR * pszBuffer,
    DWORD cbBytes
);

typedef struct _STRUCTURE_MEMBER {
    CHAR                    achMemberName[ MAX_MEMBERNAME_LENGTH + 1 ];
    DWORD                   cbOffset;
    DWORD                   cbMaxSize;
} STRUCTURE_MEMBER, *PSTRUCTURE_MEMBER;

typedef struct _STRUCTURE_TEMPLATE {
    CHAR                    achName[ MAX_TYPENAME_LENGTH + 1 ];
    PSTRUCTURE_MEMBER       pMembers;
    DWORD                   cMembers;
    DWORD                   cUseful;
    DWORD                   cbTotalSize;
    DWORD                   Type;
} STRUCTURE_TEMPLATE, *PSTRUCTURE_TEMPLATE;

DWORD
GetOffset(
    BYTE *              pBuffer,
    DWORD *             pcbOffset
);

DWORD
ReadFieldList(
    TPI *               pTypeInterface,
    STRUCTURE_TEMPLATE* pStructure,
    lfFieldList *       pFieldList, 
    DWORD               cbLen,
    DWORD               dwFlags
);

DWORD
ReadBClass(
    TPI *               pTypeInterface,
    lfBClass *          pBClass, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadMember(
    lfMember*           pMember, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadNestType(
    lfNestType*         pNestType, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadOneMethod(
    lfOneMethod*        pOneMethod, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadMethod(
    lfMethod*           pMethod, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadVTable(
    lfVFuncTab*         pVTable, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadStaticMember(
    lfSTMember*         pStaticMember, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
InitializeStructureTemplate(
    PSTRUCTURE_TEMPLATE pTemplate
);

DWORD
TerminateStructureTemplate(
    PSTRUCTURE_TEMPLATE pTemplate
);

VOID
DumpoffUsage(
    VOID
);

DWORD
OutputTemplate(
    STRUCTURE_TEMPLATE *    pTemplate,
    CHAR *                  pszMemberName,
    DWORD                   dwFlags,
    PVOID                   pvAddress,
    PFN_READ_MEMORY         pfnReadMemory,
    PFN_PRINTF              pfnPrintf 
);

DWORD
BuildMemberList(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN TPI *                pTypeInterface,
    IN TI                   tiType,
    IN BOOL                 fTypeSizeOnly
);

DWORD
BuildMemberListForTypeName(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN PDB *                pPDB,
    IN LPSTR                pszTypeName
);

DWORD
FindMembersOfTypeSize(
    IN PDB *                pPDB,
    IN DWORD                cbSize,
    IN PFN_PRINTF           pfnPrintf
);

DWORD
OutputTemplate(
    STRUCTURE_TEMPLATE *    pTemplate,
    CHAR *                  pszMemberName,
    DWORD                   dwFlags,
    PVOID                   pvAddress,
    PFN_READ_MEMORY         pfnReadMemory,
    PFN_PRINTF              pfnPrintf 
)
/*++

Routine Description:

    Output a structure template.
    
    If pvAddress is NULL, then this function will output a general template
    of the structure, listing each member along with its offset from the 
    start of the structure.
    
    If pvAddress is non-NULL, then this function will output the structure
    with the memory at pvAddress cast as this type.  
    
    If pszMemberName is NULL, then the above two statements apply to all 
    members of the structure.  If pszMember is not NULL, then the statements
    apply only the member whose name is pszMember.
    
Arguments:

    pTemplate - Template to dump
    pszMemberName - Optional member name filter
    dwFlags - Flags describing Output() details.  Currently not supported
    pvAddress - Optional address of memory to cast as type
    pfnReadMemory - Provides read memory functionality
    pfnPrintf - Provides printf functionality

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD                   cCounter;
    BOOL                    fDidSomething = FALSE;
    PBYTE                   pBuffer = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    CHAR                    achFormat[ 256 ];
    DWORD                   cbRunningLength;
    BOOL                    fLastBitField = FALSE;
    DWORD                   cBitField = 0;
    DWORD                   dwTotalMask;
    DWORD                   cbSize;
    INT                     i;
    
    pBuffer = (PBYTE) LocalAlloc( LPTR, pTemplate->cbTotalSize );
    if ( pBuffer == NULL )
    {
        dwError = GetLastError();
        goto Finished;
    }

    // 
    // If address is specified, then read the amount required for this 
    // structure.  Otherwise, we are simply dumping the template and thus
    // output the size of the type 
    //
    
    if ( pvAddress )
    {
        dwError = pfnReadMemory( pvAddress, pTemplate->cbTotalSize, pBuffer );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Finished;
        }
    }
    else
    {
        _snprintf( achFormat,
                   sizeof( achFormat ),
                   "sizeof( %s %s ) = 0x%X bytes (%d bytes)\n",
                   pTemplate->Type == LF_CLASS ? "class" : "struct",
                   pTemplate->achName,
                   pTemplate->cbTotalSize,
                   pTemplate->cbTotalSize );
        pfnPrintf( achFormat, -1 );
    }
    
    //
    // Iterate through consequential members of type
    //
   
    for( cCounter = 0;
         cCounter < pTemplate->cUseful;
         cCounter++ )
    {
    
        //
        // Do filtering on member name if specified
        //
    
        if ( pszMemberName )
        {
            if ( fDidSomething )
            {
                break;
            }
            
            if ( strcmp( pTemplate->pMembers[ cCounter ].achMemberName,
                         pszMemberName ) )
            {
                continue;
            }
        }
        
        //
        // Dump member name
        //
        
        cbRunningLength = pfnPrintf( pTemplate->pMembers[ cCounter ].achMemberName,
                                     -1 );
        
        //
        // Formatting junk
        //
        
        for ( i = cbRunningLength;
              i < 25;
              i++ )
        {
            cbRunningLength += pfnPrintf( " ", -1 );
        }
        
        cbRunningLength += pfnPrintf( " = ", -1 );
        
        achFormat[ 0 ] = '\0';
        cbSize = pTemplate->pMembers[ cCounter ].cbMaxSize;
       
        if ( !pvAddress )
        {
            //
            // Just dumping template.  Output the offset from the start of 
            // the type
            //
        
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "+%8X",
                       pTemplate->pMembers[ cCounter ].cbOffset );
        }
        else if ( !cbSize ||
             ( ( cbSize == sizeof( DWORD ) ) && fLastBitField ) ) 
        {
            //
            // If the maxsize is 0, then this must be a bitfield
            // If the maxsize is 4, and the last item was a bit field, then
            // this must be the last bit of the bit field.
            //
            // BUGBUG:  Need to make this work for bit fields larger than 32
            //
            
            if ( !fLastBitField )
            {
                fLastBitField = TRUE;
            }
            cBitField++;
            
            dwTotalMask = (DWORD) *(DWORD*) ((PBYTE)pBuffer+
                             pTemplate->pMembers[ cCounter ].cbOffset);
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%s",
                       (dwTotalMask & (1 << ( cBitField - 1 ))) ? "TRUE" : "FALSE" );
            
            if ( cbSize == sizeof( DWORD ) )
            {
                fLastBitField = FALSE;
                cBitField = 0;
            }
        }
        else if ( cbSize != sizeof( DWORD ) )
        {
            //
            // If this structure is not a DWORD in size, then assume we don't 
            // know how to dump it affectly.  In this case, we will simply
            // dump out the address at which the member data starts
            //
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%08p..",
                       (PBYTE) pvAddress +
                         pTemplate->pMembers[ cCounter ].cbOffset );
        }
        else
        {
            //
            // This is a DWORD sized member.  We can dump out the value
            // effectively -> so we do it
            //
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%08X",
                       (DWORD) *(DWORD*) ((PBYTE)pBuffer+ 
                         pTemplate->pMembers[ cCounter ].cbOffset ) );
        }
        
        cbRunningLength += pfnPrintf( achFormat, -1 );
        
        //
        // Two column display.  Given 80 columns, seems like the only 
        // reasonable setting (maybe 1 column is useful?)
        //
        
        if ( pszMemberName ||
             ( cCounter % 2 ) )
        {
            pfnPrintf( "\n", -1 );
        }
        else
        {
            for ( i = cbRunningLength;
                  i < 40;
                  i++ )
            {
                pfnPrintf( " ", -1 );
            }
        }
        
        //
        // Keep tabs on whether we actually dumped something 
        //
        
        fDidSomething = TRUE;
    }
    
    if ( !fDidSomething )
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }
    
    pfnPrintf( "\n", -1 );

Finished:
    if ( pBuffer != NULL )
    {
        LocalFree( pBuffer );
    }
    return dwError;
}

DWORD
BuildMemberListForTypeName(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN PDB *                pPDB,
    IN LPSTR                pszTypeName
)
/*++

Routine Description:

    Build the structure template for a given type
    
Arguments:

    pTemplate - Template to populate (must have been previously inited)
    pPDB - PDB structure opened using MSDBI!PDBOpen
    pszTypeName - Name of type

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    TPI *                   pTypeInterface = NULL;
    TI                      RootTI;
    DWORD                   dwError = ERROR_SUCCESS;
    PB                      pb;
    
    if ( !pTemplate || !pPDB || !pszTypeName )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    //
    // Get the type interface
    //
    
    if ( !PDBOpenTpi( pPDB,
                      pdbRead,
                      &pTypeInterface ) )
    {
        dwError = GetLastError();
        goto Finished;
    }

    //
    // Does this PDB have the necessary type information?
    //

    if ( TypesQueryTiMinEx( pTypeInterface ) ==
         TypesQueryTiMacEx( pTypeInterface ) )
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }
    
    //
    // Lookup with specified type
    //
    
    if ( !TypesQueryTiForUDTEx( pTypeInterface,
                                pszTypeName,
                                TRUE,
                                &RootTI) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    strncpy( pTemplate->achName,
             pszTypeName,
             sizeof( pTemplate->achName ) - 1 );
    
    dwError = BuildMemberList( pTemplate,
                               pTypeInterface,
                               RootTI,
                               FALSE );

Finished:

    if ( pTypeInterface != NULL )
    {
        TypesClose( pTypeInterface );
    }
    return dwError;
}

DWORD
FindMembersOfTypeSize(
    IN PDB *                pPDB,
    IN DWORD                cbSize,
    IN PFN_PRINTF           pfnPrintf
)
/*++

Routine Description:

    Find members of a certain size.  Output these types
    
Arguments:

    pPDB - PDB structure opened using MSDBI!PDBOpen
    cbSize - Size in question
    pfnPrintf - Output routine

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    STRUCTURE_TEMPLATE      Template;
    TPI *                   pTypeInterface = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    TI                      tiMin;
    TI                      tiMax;
    TI                      tiCursor;
    CHAR                    achLast[ MAX_TYPENAME_LENGTH ];
    CHAR                    achBuffer[ 256 ];

    if ( !pPDB || !pfnPrintf || !cbSize )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    //
    // Get the type interface
    //
    
    if ( !PDBOpenTpi( pPDB,
                      pdbRead,
                      &pTypeInterface ) )
    {
        dwError = GetLastError();
        goto Finished;
    }

    //
    // Get min/max type indices
    //

    tiMin = TypesQueryTiMinEx( pTypeInterface );
    tiMax = TypesQueryTiMacEx( pTypeInterface );

    if ( tiMin == tiMax )
    {
        //
        // Probably no type info available in PDB
        //

        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }

    //
    // Cursor thru
    //

    achLast[ 0 ] = '\0';

    for ( tiCursor = tiMin;
          tiCursor < tiMax;
          tiCursor++ )
    {
        dwError = BuildMemberList( &Template,
                                   pTypeInterface,
                                   tiCursor,
                                   TRUE );
        if ( dwError != ERROR_SUCCESS )
        {
            if ( dwError == ERROR_NOT_SUPPORTED )
            {
                //
                // Not a struct/class. Ignore
                //

                dwError = ERROR_SUCCESS;
                continue;
            }
            else
            {
                break;
            }
        }

        if ( Template.cbTotalSize == cbSize &&
             strcmp( Template.achName, achLast ) )
        {
            pfnPrintf( Template.Type == LF_CLASS ? "class " : "struct ", -1 );
            pfnPrintf( Template.achName, -1 );
            pfnPrintf( "\n", -1 );

            strncpy( achLast,
                     Template.achName,
                     sizeof( achLast ) );
        }
        
    }
    
Finished:

    if ( pTypeInterface != NULL )
    {
        TypesClose( pTypeInterface );
    }
    return dwError;
}

DWORD
BuildMemberList(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN TPI *                pTypeInterface,
    IN TI                   tiType,
    IN BOOL                 fTypeSizeOnly
)
/*++

Routine Description:

    Build a template describing the given type.  This template contains
    an array of members representing the member of the type.
    
Arguments:

    pTemplate - Template to populate (must have been previously inited)
    pTypeInterface - Type interface
    tiType - Type ID to retrieve
    fStructSizeOnly - TRUE if we only need type size (and not the members)

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    TYPTYPE *               pType = NULL;
    lfStructure *           pStructure;
    lfFieldList *           pFieldList;
    PB                      pb;
    DWORD                   dwError = ERROR_SUCCESS;
    DWORD                   cbTotalSize = 0;
    DWORD                   cbStructSize = 0;
    DWORD                   cUseful;
    DWORD                   cbNameOffset;
    TI                      RootTI;

    if ( !pTypeInterface || !pTemplate )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    RootTI = tiType;
    
    //
    // Parse root record of the type, verifying that it is of type 
    // STRUCTURE or CLASS
    //
    
    if ( !TypesQueryPbCVRecordForTiEx( pTypeInterface,
                                       RootTI,
                                       &pb ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    pType = (TYPTYPE*) pb;

    if ( ( pType->leaf != LF_CLASS ) && 
         ( pType->leaf != LF_STRUCTURE ) )
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }
    pTemplate->Type = pType->leaf;
    
    pStructure = (lfStructure*) &(pType->leaf);

    cbNameOffset = GetOffset( pStructure->data, &cbStructSize );

    //
    // If we only need the overall structure size, then we can exit out now
    //

    if ( fTypeSizeOnly )
    {
        pTemplate->cbTotalSize = cbStructSize;

        memset( pTemplate->achName,
                0,
                sizeof( pTemplate->achName ) );

        strncpy( pTemplate->achName,
                 (LPSTR) pStructure->data + cbNameOffset + 1,
                 min( (DWORD) *(CHAR*)(pStructure->data + cbNameOffset),
                      sizeof( pTemplate->achName ) ) );

        goto Finished;
    }
    
    //
    // In allocating # of members for the structure, get upper bound by 
    // taking structure member count.
    //
    // BUGBUG:  Dynamically grow the list to avoid gross overestimation.
    //
    
    if ( pTemplate->cMembers < pStructure->count )
    {
        pTemplate->pMembers = (PSTRUCTURE_MEMBER) LocalAlloc( LPTR,
                                          sizeof( STRUCTURE_MEMBER ) *
                                            pStructure->count );
        if ( pTemplate->pMembers == NULL )
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto Finished;
        }

        pTemplate->cMembers = pStructure->count;
    }
    
    if ( !TypesQueryPbCVRecordForTi( pTypeInterface,
                                     pStructure->field,
                                     &pb ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    pType = (TYPTYPE*)pb;
    pFieldList = (lfFieldList*) &(pType->leaf);

    //
    // Read the list of the fields in the type
    //
    
    dwError = ReadFieldList( pTypeInterface,
                             pTemplate,
                             pFieldList,
                             pType->len,
                             0 );

    cUseful = pTemplate->cUseful;

    if ( cUseful && ( dwError == ERROR_SUCCESS ) )
    {
        pTemplate->pMembers[ cUseful - 1 ].cbMaxSize =
            cbStructSize - pTemplate->pMembers[ cUseful - 1 ].cbOffset;

        pTemplate->cbTotalSize = cbStructSize;
    }                                

Finished:

    return dwError;    
}

DWORD
ReadFieldList(
    IN TPI *                        pTypeInterface,
    IN STRUCTURE_TEMPLATE *         pTemplate,
    IN lfFieldList *                pFieldList,
    IN DWORD                        cbLen,
    IN DWORD                        dwFlags
)
/*++

Routine Description:

    Read the elements of the field list which represents the class/struct
    
Arguments:

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD               cbBytes = 0;
    PBYTE               pBuffer;
    DWORD               cbReturnSize = 0;
    BOOL                fExit = FALSE;
    CHAR                achMemberBuffer[ 256 ];
    DWORD               cbMemberBuffer;
    DWORD               dwError = ERROR_SUCCESS;
    DWORD               cFields = 0;
    DWORD               cbLastOffset = 0;

    while ( cbBytes < cbLen )
    {
        //
        // Account for padding the field list blob
        //
        
        for ( ; ; )
        {
            pBuffer = (PBYTE) pFieldList->data + cbBytes;
            if ( *(BYTE*)pBuffer < LF_PAD0 )
            {
                break;
            }
            cbBytes++;
        }
        
        //
        // After each padding block (if any), the first SHORT will contain
        // the field type of the next field in the struct/class.  Handle
        // each type accordingly.  If the handle function (Read*) returns 
        // a cbReturnSize of -1 then this type will not contribute to the
        // offsets in the struct/class.  For example, member functions.  
        //
        
        achMemberBuffer[ 0 ] = '\0';
        cbReturnSize = 0;
        cbMemberBuffer = sizeof( achMemberBuffer );
        
        switch ( *(USHORT*) pBuffer ) 
        {
        case LF_BCLASS:
            dwError = ReadBClass( pTypeInterface,
                                  (lfBClass*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
    
        case LF_MEMBER:
            dwError = ReadMember( (lfMember*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
            
        case LF_NESTTYPE:
            dwError = ReadNestType( (lfNestType*) pBuffer,
                                    &cbReturnSize,
                                    &cbBytes,
                                    achMemberBuffer,
                                    cbMemberBuffer );
            break;     
        
        case LF_ONEMETHOD:
            dwError = ReadOneMethod( (lfOneMethod*) pBuffer,
                                     &cbReturnSize,
                                     &cbBytes,
                                     achMemberBuffer,
                                     cbMemberBuffer );
            break;

        case LF_METHOD:
            dwError = ReadMethod( (lfMethod*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
       
        case LF_STMEMBER:
            dwError = ReadStaticMember( (lfSTMember*) pBuffer,
                                        &cbReturnSize,
                                        &cbBytes,
                                        achMemberBuffer,
                                        cbMemberBuffer );
            break;

        case LF_VFUNCTAB:
            dwError = ReadVTable( (lfVFuncTab*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
            
        default:
            fExit = TRUE;
            break;
        }
        
        if ( fExit )
        {
            break;
        }
        
        if ( dwError != ERROR_SUCCESS ||
             cbReturnSize == INVALID_LENGTH )
        {
            continue;
        }
        
        //
        // We got a useful member of the struct/class.  Add it to the 
        // template.
        //
        
        pTemplate->cUseful++;

        strncpy( pTemplate->pMembers[ cFields ].achMemberName,
                 achMemberBuffer,
                 sizeof( pTemplate->pMembers[ cFields ].achMemberName ) - 1 );

        pTemplate->pMembers[ cFields ].cbOffset = cbReturnSize;
        
        //
        // Calculate the maximum size of the previous member by taking the 
        // difference between the start offset of the member and the start 
        // offset of the previous member.  Note that this is not necessarily
        // the exact size because of potential alignment padding.  It is only
        // an upper bound on the size of the previous member.
        //
        
        if ( cFields )
        {
            pTemplate->pMembers[ cFields - 1 ].cbMaxSize =
                                            cbReturnSize - cbLastOffset;
        }
        
        cbLastOffset = cbReturnSize;
        
        cFields++;
    }
    
    return dwError;
}

DWORD
ReadBClass(
    IN TPI *                    pTypeInterface,
    IN lfBClass*                pBClass,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    OUT CHAR *                  pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of base class field
    
Arguments:

    pTypeInterface - MSDBI type interface
    pBClass - Points to a base class descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    PB                      pb;
    DWORD                   Offset;
    TYPTYPE*                pType;
    lfStructure *           pStructure;
    DWORD                   cbUnused;
    
    Offset = GetOffset( pBClass->offset, pcbReturnSize );
    *pcbOffset += sizeof( lfBClass ) + Offset;
    
    //
    // We have to lookup the name of the base class explicitly by using the 
    // index type in the base class descriptor
    //

    if ( !TypesQueryPbCVRecordForTiEx( pTypeInterface,
                                       pBClass->index,
                                       &pb ) )
    {
        return ERROR_FILE_NOT_FOUND;
    }
    
    //
    // Process/munge/extract
    // 
    
    pType = (TYPTYPE*)pb;
    pStructure = (lfStructure*) &(pType->leaf );

    Offset = GetOffset( pStructure->data, &cbUnused );
    
    memset( pszBuffer, 0, cbBuffer );
    memcpy( pszBuffer,
            (CHAR*) pStructure->data + Offset + 1,
            min( (DWORD) *(CHAR*) ( pStructure->data + Offset ), cbBuffer ) );
            
    return ERROR_SUCCESS;
}

DWORD
ReadMember(
    IN lfMember *               pMember,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a member
    
Arguments:

    pMember - Points to a member descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD Offset = GetOffset( pMember->offset, pcbReturnSize );

    memset( pszBuffer, 0, cbBuffer );
    memcpy( pszBuffer,
            (CHAR*) pMember->offset + Offset + 1,
            min( (DWORD) *(CHAR*) ( pMember->offset + Offset ), cbBuffer ) );
            
    *pcbOffset += sizeof( lfMember ) + Offset +  pMember->offset[Offset] + 1;

    return ERROR_SUCCESS;
}

DWORD
ReadOneMethod(
    IN lfOneMethod *            pOneMethod,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a non-overloaded member function.  
    We process this only to up the offset within the field list for 
    traversal purposes.  Member methods themselves have no affect on 
    the offsets/size of the data structure 
    
Arguments:

    pOneMethod - Method type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    CHAR *              pszSource = NULL;
    
    pszSource = (CHAR*) pOneMethod + sizeof( lfOneMethod );
    *pcbOffset += sizeof( lfOneMethod );
    if ( ( pOneMethod->attr.mprop == CV_MTintro ) ||
         ( pOneMethod->attr.mprop == CV_MTpureintro ) )
    {
        *pcbOffset += sizeof( LONG );
        pszSource += sizeof( LONG );
    }
    *pcbOffset += *(CHAR*)pszSource + 1;
    *pcbReturnSize = INVALID_LENGTH;

    return ERROR_SUCCESS;
}

DWORD
ReadMethod(
    IN lfMethod *               pMethod,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a member function.  We process this only to 
    up the offset within the field list for traversal purposes.  Member
    methods themselves have no affect on the offsets/size of the data 
    structure 
    
Arguments:

    pMethod - Method type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    *pcbOffset += sizeof( lfMethod ) + pMethod->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}

DWORD
ReadVTable(
    IN lfVFuncTab *             pVTable,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the vtable of the structure.
    
Arguments:

    pVTable - Vtable type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    *pcbOffset += sizeof( lfVFuncTab );
    
    strncpy( pszBuffer,
             "'vftable'",
             cbBuffer - 1 );

    //
    // Assume at the beginning of the data structure.  
    // 

    *pcbReturnSize = 0;
    
    return ERROR_SUCCESS;
}


DWORD
ReadStaticMember(
    IN lfSTMember *             pStaticMember,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
{
    *pcbOffset += sizeof( lfSTMember ) + pStaticMember->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}


DWORD
ReadNestType(
    IN lfNestType *             pNestType,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
{
    *pcbOffset += sizeof( lfNestType ) + pNestType->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}

DWORD
GetOffset(
    BYTE *              pBuffer,
    DWORD *             pcbOffset
)
/*++

Routine Description:

    Read the offset for the type record.  Then advance the cursor.
    
Arguments:

    pBuffer - Points to current position in field list buffer
    pcbOffset - Filled with offset of field member
    
Return Value:

    Amount to advance cursor to next field member

--*/
{
    USHORT leaf = *(USHORT*)pBuffer;
    
    if ( leaf < LF_NUMERIC )
    {
        *pcbOffset = leaf;
        return sizeof( leaf );
    }
    else
    {
        switch( leaf )
        {
        case LF_CHAR:
            *pcbOffset = *((char*)pBuffer);
            return sizeof(leaf) + sizeof(char);
        case LF_SHORT:
            *pcbOffset = *(short*)pBuffer;
            return sizeof(leaf) + sizeof(short);
        case LF_USHORT:
            *pcbOffset = *(USHORT*)pBuffer;
            return sizeof(leaf) + sizeof(USHORT);
        case LF_LONG:
            *pcbOffset = *(long*)pBuffer;
            return sizeof(leaf) + sizeof(long);
        case LF_ULONG:
            *pcbOffset = *(ULONG*)pBuffer;
            return sizeof(leaf) + sizeof(ULONG);
        }
    }
    return 0;
}

DWORD
InitializeStructureTemplate(
    IN PSTRUCTURE_TEMPLATE      pTemplate
)
/*++

Routine Description:

    Initialize structure template
    
Arguments:

    pTemplate - Template buffer to be initialized
    
Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( pTemplate == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pTemplate->pMembers       = NULL;
    pTemplate->cMembers       = 0;
    pTemplate->achName[ 0 ]   = '\0';
    pTemplate->cUseful        = 0;
    pTemplate->cbTotalSize    = 0;
    pTemplate->Type           = 0xFFFFFFFF;

    return ERROR_SUCCESS;
}

DWORD
TerminateStructureTemplate(
    IN PSTRUCTURE_TEMPLATE      pTemplate
)
/*++

Routine Description:

    Terminate structure template
    
Arguments:

    pTemplate - Template buffer to be terminated
    
Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( pTemplate == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pTemplate->pMembers )
    {
        LocalFree( pTemplate->pMembers );
        pTemplate->pMembers = NULL;
        pTemplate->cMembers = 0;
    }

    return ERROR_SUCCESS;
}

DWORD
OutputStructure(
    IN PDB *                    pDebug,
    IN CHAR *                   pszStructureType,
    IN CHAR *                   pszMemberName,
    IN DWORD                    dwFlags,
    IN VOID *                   pvAddress,
    IN PFN_READ_MEMORY          pfnReadMemory,
    IN PFN_PRINTF               pfnPrintf
)
/*++

Routine Description:

    Top level call to output a structure
    
Arguments:

    pDebug - PDB handle
    pszStructureType - Name of structure/class to dump
    pszMemberName - (optional) Name of particular member of structure to dump
    dwFlags - (not supported) 
    pvAddress - (optional) Address of start of structure
    pfnReadMemory - (optional) Function to read memory.  Not needed if 
                    pvAddress==NULL
    pfnPrintf - Output function

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    STRUCTURE_TEMPLATE          Template;
    DWORD                       dwError;
    
    if ( !pDebug || 
         !pszStructureType || 
         !pfnReadMemory || 
         !pfnPrintf )
    {
        return ERROR_INVALID_PARAMETER;    
    }

    dwError = InitializeStructureTemplate( &Template );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = BuildMemberListForTypeName( &Template,
                                          pDebug,
                                          pszStructureType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = OutputTemplate( &Template,
                              pszMemberName,
                              dwFlags,
                              pvAddress,
                              pfnReadMemory,
                              pfnPrintf );

    //
    // CODEWORK:  Cache the templates
    //

    TerminateStructureTemplate( &Template );

    return dwError;
}

DWORD
DoPrintf(
   CHAR *                   pszBuffer,
   DWORD                    cbBytes
)
/*++

Routine Description:

    Print out buffer
    
Arguments:

    pszBuffer - buffer to print
    cbBytes - Bytes to print

Return Value:

    Number of bytes printed

--*/
{
    dprintf( "%s", pszBuffer );
    return strlen( pszBuffer );
} 

DWORD
DoReadMemory(
    VOID *                  pvAddress,
    DWORD                   cbBytes,
    VOID *                  pBuffer 
)
/*++

Routine Description:

    Read debuggee memory into buffer
    
Arguments:

    pvAddress - Address to read
    cbBytes - # of bytes to read
    pBuffer - Buffer to be filled

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( ReadMemory( pvAddress, pBuffer, cbBytes, NULL ) )
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return GetLastError();
    }
}

VOID
DumpoffUsage(
    VOID
)
/*++

Routine Description:

    !dumpoff usage message
    
Arguments:

    None

Return Value:

    None

--*/
{
    dprintf(
        "Usage:  !dumpoff <pdb_file>!<type_name>[.<member_name>] [expression]\n"
        "        !dumpoff -s [<pdb_search_path>]\n"
        "\n"
        "pdb_file          Un-qualified name of PDB file (eg. KERNEL32, NTDLL)\n"
        "type_name         Name of type (struct/class) to dump, OR \n"
        "                  ==<cbHexSize> to dump struct/classes of size cbHexSize\n"
        "member_name       (optional) Name of member in type_name to dump\n"
        "expression        (optional) Address of memory to dump as type_name\n"
        "                  if not present, offset(s) are dumped\n"
        "pdb_search_path   Set the search path for PDBs\n"
        "\n"
        "Examples:  !dumpoff ntdll!_RTL_CRITICAL_SECTION 14d4d0\n"
        "           !dumpoff w3svc!HTTP_REQUEST._dwSignature w3svc!g_GlobalObj\n"
        "           !dumpoff ntdll!_RTL_CRITICAL_SECTION\n"
        "           !dumpoff w3svc!==840\n"
        "           !dumpoff -s \\\\mydrive\\pdbs;c:\\local\\pdbs\n"
    );
}

#if defined( _X86_ )
CHAR g_achPDBSearchPath[ 1024 ] = "\\\\x86fre\\symbols.pri\\retail\\dll";
#else
CHAR g_achPDBSearchPath[ 1024 ] = "\\\\alphafre\\symbols.pri\\retail\\dll";
#endif

DECLARE_API( dumpoff )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a structure
    based on debug info in PDB

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    CHAR *              pszPdb = NULL;
    CHAR *              pszType = NULL;
    CHAR *              pszAddress = NULL;
    CHAR *              pszMember = NULL;
    CHAR *              pszCursor = NULL;
    CHAR *              pszNext = NULL;
    CHAR                achArg1[ 256 ];
    CHAR                achArg2[ 256 ];
    CHAR                achBuffer[ 256 ] = "";
    CHAR                achFileName[ MAX_PATH + 1 ];
    CHAR                achFullPath[ MAX_PATH + 1 ];
    CHAR                achSymPath[ MAX_PATH + 1 ];
    BOOL                fRet;
    EC                  ec;
    PDB *               pDebug = NULL;
    DWORD               dwError;
    CHAR *              pszError = NULL;
    DWORD               cArguments;
    DWORD               cbSize;
    BOOL                fRetry = TRUE;

    INIT_API();

    //
    // get the debugger symbol path
    //

    fRet = SymGetSearchPath( hCurrentProcess,
                             achSymPath,
                             sizeof( achSymPath ) );
    if (!fRet )
    {
        //
        // If we couldn't get the default sym path, just use the SYSTEMROOT
        //

        dwError = GetEnvironmentVariableA( "SYSTEMROOT",
                                           achSymPath,
                                           sizeof( achSymPath ) );

        if ( dwError == 0 )
        {
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Unable to determine symbol path.  Error = %d\n",
                       GetLastError() );
            goto Finished;
        }
    }

    //
    // Parse out the argument. This is a fragile approach, but we
    // can live with that.
    // <pdbfile>!<type>[.member] [address]
    //

    cArguments = sscanf( (CHAR*) lpArgumentString, 
                         "%256s%256s", 
                         achArg1, 
                         achArg2 );
    
    if ( cArguments == EOF || cArguments == 0 )
    {
        DumpoffUsage();
        goto Finished;
    }

    //
    // Handle the !dumpoff -s [sympath] case
    //

    if ( ( achArg1[ 0 ] == '-' || achArg1[ 0 ] == '/' ) &&
         ( achArg1[ 1 ] == 's' || achArg1[ 1 ] == 'S' ) )
    {
        if ( cArguments == 2 )
        {
            strncpy( g_achPDBSearchPath,
                     achArg2,
                     sizeof( g_achPDBSearchPath ) );
        }

        dprintf( "PDB search path set to\n%s%s%s\n",
                 g_achPDBSearchPath,
                 *g_achPDBSearchPath ? "\n" : "",
                 achSymPath );
                 
        goto Finished;
    }

    //
    // Parse the regular !dumpoff command
    //
    
    pszPdb = achArg1;

    pszCursor = strchr( achArg1, '!' );
    if ( pszCursor == NULL )
    {
        DumpoffUsage();
        goto Finished;
    }
    *pszCursor = '\0';

    pszType = pszCursor + 1;
    
    pszCursor = strchr( pszType, '.' );
    if ( pszCursor != NULL )
    {
        *pszCursor = '\0';
        pszMember = pszCursor + 1;
    } 
    
    if ( cArguments > 1 )
    {
        pszAddress = achArg2;
    }

    //
    // done parsing, now get the PDB 
    //
    
    strncpy( achFileName,
             pszPdb,
             sizeof( achFileName ) - 1 );
    strncat( achFileName,
            ".pdb",
            sizeof( achFileName ) - 1 );

    //
    // Look for the PDB file.  First in the PDB search path, then sympath
    //

    pszCursor = g_achPDBSearchPath;

Retry:
    while ( pszCursor )
    {
        pszNext = strchr( pszCursor, ';' );
        if ( pszNext != NULL )
        {
            *pszNext = '\0';
        }
        
        fRet = SearchTreeForFile( pszCursor,
                                  achFileName,
                                  achFullPath );
        if ( fRet )
        {
            break;
        }
        
        if ( pszNext )
        {
            pszCursor = pszNext + 1;
        }
        else
        {
            pszCursor = NULL;
        }
    }

    if ( !pszCursor && fRetry )
    {
        fRetry = FALSE;
        
        // now try the debugger sympath

        pszCursor = achSymPath;
        goto Retry;
    }
    
    if ( !pszCursor )
    {
        _snprintf( achBuffer,
                   sizeof( achBuffer ),
                   "Couldn't find PDB file %s\n",
                   achFileName );
        goto Finished;
    }
    
    //
    // Open the PDB file
    //
    
    if ( !PDBOpen( achFullPath,
                   pdbRead,
                   0,
                   &ec,
                   achBuffer,
                   &pDebug ) )
    {
        _snprintf( achBuffer,
                   sizeof( achBuffer ),
                   "Error opening PDB file.  Error = %d\n",
                   ec );
        goto Finished;
    }

    if ( pszType[ 0 ] == '=' && pszType[ 1 ] == '=' )
    {
        //
        // Find all types of size after ==
        //

        cbSize = strtoul( pszType + 2,
                          NULL,
                          16 );

        dwError = FindMembersOfTypeSize( pDebug,
                                         cbSize,
                                         DoPrintf );
    }
    else
    {
        dwError = OutputStructure( pDebug,
                                   pszType,
                                   pszMember,
                                   0,
                                   pszAddress ? (VOID*) GetExpression( pszAddress ) : NULL, 
                                   DoReadMemory,
                                   DoPrintf );
    }

    if ( dwError != ERROR_SUCCESS )
    {
        switch ( dwError )
        {
        case ERROR_FILE_NOT_FOUND:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Could not find type '%s' in PDB file '%s'\n",
                       pszType,
                       achFullPath );
            break;
        case ERROR_NOT_SUPPORTED:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "PDB file '%s' does not contain necessary type info\n",
                       achFullPath );
            break;
        default:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Error dumping structure.  Error = %d\n", 
                       dwError );
        }

        goto Finished;
    }

Finished:

    if ( achBuffer[ 0 ] )
    {
        dprintf( "%s", achBuffer );
    }

    if ( pDebug )
    {
        PDBClose( pDebug );
    }
  
} // DECLARE_API( dumpoff )


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\enummod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    enummod.cxx

Abstract:

    This module implements a remote module enumerator.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "precomp.hxx"


BOOLEAN
EnumModules(
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all loaded modules in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each module.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    PROCESS_BASIC_INFORMATION basicInfo;
    NTSTATUS status;
    PPEB peb;
    PPEB_LDR_DATA ldr;
    PLIST_ENTRY ldrHead, ldrNext;
    PLDR_DATA_TABLE_ENTRY ldrEntry;
    LDR_DATA_TABLE_ENTRY ldrEntryData;
    WCHAR tmpName[MAX_PATH];
    MODULE_INFO moduleInfo;

    //
    // Get the process info.
    //

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessBasicInformation,
                 &basicInfo,
                 sizeof(basicInfo),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        return FALSE;
    }

    peb = basicInfo.PebBaseAddress;

    if( peb == NULL ) {
        return FALSE;
    }

    //
    // ldr = peb->Ldr
    //

    if( !ReadMemory(
            (ULONG_PTR)&peb->Ldr,
            &ldr,
            sizeof(ldr),
            NULL
            ) ) {
        return FALSE;
    }

    ldrHead = &ldr->InMemoryOrderModuleList;

    //
    // ldrNext = ldrHead->Flink;
    //

    if( !ReadMemory(
            (ULONG_PTR)&ldrHead->Flink,
            &ldrNext,
            sizeof(ldrNext),
            NULL
            ) ) {
        return FALSE;
    }

    while( ldrNext != ldrHead ) {

        if( CheckControlC() ) {
            break;
        }

        //
        // Read the LDR_DATA_TABLE_ENTRY structure and the module name.
        //

        ldrEntry = CONTAINING_RECORD(
                       ldrNext,
                       LDR_DATA_TABLE_ENTRY,
                       InMemoryOrderLinks
                       );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntry,
                &ldrEntryData,
                sizeof(ldrEntryData),
                NULL
                ) ) {
            return FALSE;
        }

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.BaseDllName.Buffer,
                tmpName,
                ldrEntryData.BaseDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.BaseName,
            "%ws",
            tmpName
            );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.FullDllName.Buffer,
                tmpName,
                ldrEntryData.FullDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.FullName,
            "%ws",
            tmpName
            );

        moduleInfo.DllBase = (ULONG_PTR)ldrEntryData.DllBase;
        moduleInfo.EntryPoint = (ULONG_PTR)ldrEntryData.EntryPoint;
        moduleInfo.SizeOfImage = (ULONG)ldrEntryData.SizeOfImage;

        //
        // Invoke the callback.
        //

        if( !(EnumProc)(
                Param,
                &moduleInfo
                ) ) {
            break;
        }

        ldrNext = ldrEntryData.InMemoryOrderLinks.Flink;

    }

    return TRUE;

}   // EnumModules
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\enumpageheap.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    enumpageheap.cxx

Abstract:

    This module implements a page-heap enumerator.

Author:

    Anil Ruia (AnilR)      2-Mar-2001

Revision History:

--*/

#include "precomp.hxx"
#define DPH_HEAP_SIGNATURE       0xFFEEDDCC

BOOLEAN
EnumProcessPageHeaps(IN PFN_ENUMPAGEHEAPS EnumProc,
                     IN PVOID             Param)
/*++

Routine Description:

    Enumerates all pageheaps in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each heap.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/
{
    if (!GetExpression("ntdll!RtlpDphHeapListHead"))
    {
        dprintf("Cannot find ntdll!RtlpDphHeapListHead.  Pageheap tally will be unavailable\n");
        dprintf("Please fix ntdll symbols\n");
        return TRUE;
    }

    BOOLEAN result = TRUE;

    DPH_HEAP_ROOT  LocalHeapRoot;
    PDPH_HEAP_ROOT pRemoteHeapRoot;

    pRemoteHeapRoot = (DPH_HEAP_ROOT *)GetExpression("poi(ntdll!RtlpDphHeapListHead)");
    while (pRemoteHeapRoot != NULL)
    {
        if (CheckControlC())
        {
            break;
        }

        if (!ReadMemory(pRemoteHeapRoot,
                        &LocalHeapRoot,
                        sizeof(LocalHeapRoot),
                        NULL))
        {
            dprintf("Unable to read pageheap at %p\n",
                    pRemoteHeapRoot);

            result = FALSE;
            break;
        }

        if(LocalHeapRoot.Signature != DPH_HEAP_SIGNATURE)
        {
            dprintf("Pageheap @ %p has invalid signature %08lx\n",
                    pRemoteHeapRoot,
                    LocalHeapRoot.Signature);

            result = FALSE;
            break;
        }

        if (!EnumProc(Param,
                      &LocalHeapRoot,
                      pRemoteHeapRoot))
        {
            dprintf("Error enumerating pageheap at %p\n",
                    pRemoteHeapRoot);

            result = FALSE;
            break;
        }

        pRemoteHeapRoot = LocalHeapRoot.pNextHeapRoot;
    }

    return result;
}

BOOLEAN
EnumPageHeapBlocks(IN PDPH_HEAP_BLOCK        pRemoteBlock,
                   IN PFN_ENUMPAGEHEAPBLOCKS EnumProc,
                   IN PVOID                  Param)
{
    BOOLEAN        result = TRUE;
    DPH_HEAP_BLOCK LocalBlock;

    while (pRemoteBlock != NULL)
    {
        if (CheckControlC())
        {
            break;
        }

        if (!ReadMemory(pRemoteBlock,
                        &LocalBlock,
                        sizeof(LocalBlock),
                        NULL))
        {
            dprintf("Unable to read pageheap block at %p\n",
                    pRemoteBlock);

            result = FALSE;
            break;
        }

        if(!EnumProc(Param,
                     &LocalBlock,
                     pRemoteBlock))
        {
            result = FALSE;
            break;
        }

        pRemoteBlock = LocalBlock.pNextAlloc;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\enumheap.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    enumheap.cxx

Abstract:

    This module implements a heap enumerator.

Author:

    Keith Moore (keithmo) 31-Oct-1997

Revision History:

--*/

#include "precomp.hxx"


BOOLEAN
EnumProcessHeaps(
    IN PFN_ENUMHEAPS EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heaps in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each heap.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    PROCESS_BASIC_INFORMATION basicInfo;
    NTSTATUS status;
    PVOID * heapList;
    ULONG numHeaps;
    ULONG i;
    PEB peb;
    HEAP heap;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    heapList = NULL;

    //
    // Get the process info.
    //

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessBasicInformation,
                 &basicInfo,
                 sizeof(basicInfo),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    if( !ReadMemory(
            (ULONG_PTR)basicInfo.PebBaseAddress,
            &peb,
            sizeof(peb),
            NULL
            ) ) {
        goto cleanup;
    }

    //
    // Allocate an array for the heap pointers, then read them from
    // the debugee.
    //

    numHeaps = peb.NumberOfHeaps;

    heapList = (PVOID *)malloc( numHeaps * sizeof(PVOID) );

    if( heapList == NULL ) {
        goto cleanup;
    }

    if( !ReadMemory(
            (ULONG_PTR)peb.ProcessHeaps,
            heapList,
            numHeaps * sizeof(PVOID),
            NULL
            ) ) {
        goto cleanup;
    }

    //
    // Now that we have the heap list, we can scan it and invoke the
    // enum proc.
    //

    for( i = 0 ; i < numHeaps ; i++ ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        if( !ReadMemory(
                (ULONG_PTR)heapList[i],
                &heap,
                sizeof(heap),
                NULL
                ) ) {
            goto cleanup;
        }

        if( heap.Signature != HEAP_SIGNATURE ) {
            dprintf(
                "Heap @ %p has invalid signature %08lx\n",
                heapList[i],
                heap.Signature
                );
            goto cleanup;
        }

        if( !EnumProc(
                Param,
                &heap,
                (PHEAP)heapList[i],
                i
                ) ) {
            break;
        }

    }

    //
    // Success!
    //

    result = TRUE;

cleanup:

    if( heapList != NULL ) {
        free( heapList );
    }

    return result;

}   // EnumProcessHeaps


BOOLEAN
EnumHeapSegments(
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN PFN_ENUMHEAPSEGMENTS EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heap segments within a heap.

Arguments:

    LocalHeap - Pointer to a local copy of the HEAP to enumerate.

    RemoteHeap - The actual address of the heap in the debugee.

    EnumProc - An enumeration proc that will be invoked for each heap
        segment.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    ULONG i;
    HEAP_SEGMENT heapSegment;

    //
    // Scan the segments.
    //

    for( i = 0 ; i < HEAP_MAXIMUM_SEGMENTS ; i++ ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        if( LocalHeap->Segments[i] != NULL ) {

            //
            // Read the segment, invoke the enumeration proc.
            //

            if( !ReadMemory(
                    (ULONG_PTR)LocalHeap->Segments[i],
                    &heapSegment,
                    sizeof(heapSegment),
                    NULL
                    ) ) {
                goto cleanup;
            }

            if( heapSegment.Signature != HEAP_SEGMENT_SIGNATURE ) {
                dprintf(
                    "HeapSegment @ %p has invalid signature %08lx\n",
                    LocalHeap->Segments[i],
                    heapSegment.Signature
                    );
                goto cleanup;
            }

            if( !EnumProc(
                    Param,
                    &heapSegment,
                    LocalHeap->Segments[i],
                    i
                    ) ) {
                break;
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapSegments


BOOLEAN
EnumHeapSegmentEntries(
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN PFN_ENUMHEAPSEGMENTENTRIES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all heap entries in a heap segment.

Arguments:

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT to
        enumerate.

    RemoteHeapSegment - The actual address of hte heap segment in the
        debugee.

    EnumProc - An enumeration proc that will be invoked for each heap
        segment.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result = FALSE;
    PHEAP_ENTRY lastHeapEntry;
    PHEAP_ENTRY remoteHeapEntry;
    HEAP_ENTRY localHeapEntry;
    PHEAP_UNCOMMMTTED_RANGE remoteUCR;
    HEAP_UNCOMMMTTED_RANGE localUCR;

    //
    // Snag the beginning & ending limits of this segment.
    //

    remoteHeapEntry = LocalHeapSegment->FirstEntry;
    lastHeapEntry = LocalHeapSegment->LastValidEntry;

    //
    // If this segment has one or more uncommitted ranges, then
    // read the first one.
    //

    remoteUCR = LocalHeapSegment->UnCommittedRanges;

    if( remoteUCR != NULL ) {
        if( !ReadMemory(
                (ULONG_PTR)remoteUCR,
                &localUCR,
                sizeof(localUCR),
                NULL
                ) ) {
            goto cleanup;
        }
    }

    //
    // Scan the entries.
    //

    while(  remoteHeapEntry < lastHeapEntry ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        //
        // Read the heap entry, invoke the enumeration proc.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteHeapEntry,
                &localHeapEntry,
                sizeof(localHeapEntry),
                NULL
                ) ) {
           goto cleanup;
        }

        if( !EnumProc(
                Param,
                &localHeapEntry,
                remoteHeapEntry
                ) ) {
            break;
        }

        //
        // Advance to the next entry.
        //

        remoteHeapEntry = (PHEAP_ENTRY)( (PUCHAR)remoteHeapEntry +
            ( localHeapEntry.Size << HEAP_GRANULARITY_SHIFT ) );

        //
        // If this is the last entry in this run, then we'll need
        // some special handling to skip over the uncommitted ranges
        // (if any).
        //

        if( localHeapEntry.Flags & HEAP_ENTRY_LAST_ENTRY ) {

            if( remoteUCR == NULL ) {
                break;
            }

            //
            // Skip the uncommitted range, then read the next uncommitted
            // range descriptor if available.
            //

            remoteHeapEntry = (PHEAP_ENTRY)( (PUCHAR)remoteHeapEntry +
                localUCR.Size );

            remoteUCR = localUCR.Next;

            if( remoteUCR != NULL ) {
                if( !ReadMemory(
                        (ULONG_PTR)remoteUCR,
                        &localUCR,
                        sizeof(localUCR),
                        NULL
                        ) ) {
                   goto cleanup;
                }
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapSegmentEntries


BOOLEAN
EnumHeapFreeLists(
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN PFN_ENUMHEAPFREELISTS EnumProc,
    IN PVOID Param
    )
{

    BOOLEAN result = FALSE;
    ULONG i;
    PLIST_ENTRY nextEntry;
    PHEAP_FREE_ENTRY remoteFreeHeapEntry;
    HEAP_FREE_ENTRY localFreeHeapEntry;

    //
    // Scan the free lists.
    //

    for( i = 0 ; i < HEAP_MAXIMUM_FREELISTS ; i++ ) {

        nextEntry = LocalHeap->FreeLists[i].Flink;

        while( nextEntry != &RemoteHeap->FreeLists[i] ) {

            if( CheckControlC() ) {
                goto cleanup;
            }

            remoteFreeHeapEntry = CONTAINING_RECORD(
                                      nextEntry,
                                      HEAP_FREE_ENTRY,
                                      FreeList
                                      );

            //
            // Read the heap entry, invoke the enumerator.
            //

            if( !ReadMemory(
                    (ULONG_PTR)remoteFreeHeapEntry,
                    &localFreeHeapEntry,
                    sizeof(localFreeHeapEntry),
                    NULL
                    ) ) {
                goto cleanup;
            }

            if( !EnumProc(
                    Param,
                    &localFreeHeapEntry,
                    remoteFreeHeapEntry
                    ) ) {
                break;
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapFreeLists
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\filter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filter.cxx

Abstract:

    Dump out ISAPI filter info

Author:

    Bilal Alam (balam)          Feb-25-2000

Revision History:

--*/

#include "precomp.hxx"

HRESULT
ReadSTRU(
    STRU *          pString,
    WCHAR *         pszBuffer,
    DWORD *         pcchBuffer
)
{
    DWORD           cbNeeded = pString->QueryCCH() + 1;
    
    if ( cbNeeded > *pcchBuffer )
    {
        *pcchBuffer = cbNeeded;
        return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }
    
    MoveBlockWithRet( (*(pszBuffer)), 
                      pString->m_Buff.m_pb,
                      pString->m_Buff.m_cb,
                      HRESULT_FROM_WIN32( ERROR_INVALID_ADDRESS ) );

    return NO_ERROR;
}

VOID
DumpFilterNotifications(
    DWORD               dwNotifications
)
{
    if ( dwNotifications & SF_NOTIFY_READ_RAW_DATA )
    {
        dprintf( "SF_NOTIFY_READ_RAW_DATA\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_PREPROC_HEADERS )
    {
        dprintf( "SF_NOTIFY_PREPROC_HEADERS\n" );
    }

    if ( dwNotifications & SF_NOTIFY_AUTHENTICATION )
    {
        dprintf( "SF_NOTIFY_AUTHENTICATION\n" );
    }

    if ( dwNotifications & SF_NOTIFY_URL_MAP )
    {
        dprintf( "SF_NOTIFY_URL_MAP\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_ACCESS_DENIED )
    {
        dprintf( "SF_NOTIFY_ACCESS_DENIED\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_SEND_RESPONSE )
    {
        dprintf( "SF_NOTIFY_SEND_RESPONSE\n" );
    }

    if ( dwNotifications & SF_NOTIFY_SEND_RAW_DATA )
    {
        dprintf( "SF_NOTIFY_SEND_RAW_DATA\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_LOG )
    {
        dprintf( "SF_NOTIFY_LOG\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_END_OF_REQUEST )
    {
        dprintf( "SF_NOTIFY_END_OF_REQUEST\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_END_OF_NET_SESSION )
    {
        dprintf( "SF_NOTIFY_END_OF_NET_SESSION\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_AUTH_COMPLETE )
    {
        dprintf( "SF_NOTIFY_AUTH_COMPLETE\n" );
    }
    
    if ( dwNotifications & SF_NOTIFY_EXTENSION_TRIGGER )
    {
        dprintf( "SF_NOTIFY_EXTENSION_TRIGGER\n" );
    }
}

VOID
DumpFilterDll(
    ULONG_PTR           pFilterDllAddress,
    HTTP_FILTER_DLL *   pFilterDll
)
{
    STRU *              pStrName;
    WCHAR               achBuffer[ 256 ] = L"";
    DWORD               cchBuffer = 256;
    DEFINE_CPP_VAR(     HTTP_FILTER_DLL, FilterDll );
   
    if ( pFilterDll == NULL )
    {
        move( FilterDll, pFilterDllAddress );
        pFilterDll = GET_CPP_VAR_PTR( HTTP_FILTER_DLL, FilterDll );
    }
    
    //
    // Top line stuff
    //
    
    dprintf( "HTTP_FILTER_DLL %p :  cRefs = %d, Secure = %s, Non-Secure = %s\n", 
             (VOID*) pFilterDllAddress,
             pFilterDll->_cRef,
             ( pFilterDll->_dwFlags & SF_NOTIFY_SECURE_PORT ) ? "YES" : "NO",
             ( pFilterDll->_dwFlags & SF_NOTIFY_NONSECURE_PORT ) ? "YES" : "NO" );

    //
    // Print the ISAPI filter path
    //

    pStrName = (STRU*) &(pFilterDll->_strName); 

    ReadSTRU( pStrName,
              achBuffer,
              &cchBuffer );

    dprintf( "Filter Path = \"%ws\"\n", achBuffer );

    //
    // Dump out a nice list of configured notifications
    //
    
    dprintf( "\n" );
    DumpFilterNotifications( pFilterDll->_dwFlags );
}

VOID
DumpFilterDllThunk(
    PVOID               FilterAddress,
    PVOID               pFilter,
    CHAR                chVerbosity,
    DWORD               iThunk
)
{
    DumpFilterDll(
        (ULONG_PTR) FilterAddress,
        (HTTP_FILTER_DLL*) pFilter
        );
    
    dprintf( "-----------------------------------------------------\n" );
}

VOID
DumpFilterGlobals(
    VOID
)
{
    ULONG_PTR           filterListAddress;
    
    //
    // Dump out how many filters are loaded and then dump each HTTP_FILTER_DLL
    //

    filterListAddress = GetExpression("&w3core!HTTP_FILTER_DLL__sm_FilterHead");
    if (!filterListAddress) 
    {
        dprintf("couldn't evaluate w3core!HTTP_FILTER_DLL__sm_FilterHead\n");
        return;
    }

    EnumLinkedList(
        (LIST_ENTRY *) filterListAddress,
        DumpFilterDllThunk,
        0,
        sizeof(HTTP_FILTER_DLL),
        FIELD_OFFSET(HTTP_FILTER_DLL, _ListEntry)
        );
            
    
}


DECLARE_API( filter )
/*++

Routine Description:

    This function is called as an NTSD extension to reset a reference
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    CHAR                chCommand = 0;
    
    INIT_API();
   
    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) 
    {
        lpArgumentString++;
    }
    
    //
    // -g Globals
    // -x W3_FILTER_CONTEXT
    // -c W3_CONNECTION_CONTEXT
    // -d HTTP_FILTER_DLL
    // -l FILTER_LIST
    //
    
    if ( *lpArgumentString != '-' )
    {
        return;
    }
    chCommand = *(++lpArgumentString);
    lpArgumentString++;
     
    //
    // Skip more blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) 
    {
        lpArgumentString++;
    }
    
    switch( chCommand )
    {
    case 'g':
        DumpFilterGlobals();
        break;
    
    case 'x':
//        DumpFilterContext( GetExpression( lpArgumentString ) );
        break;
    
    case 'c':
//        DumpFilterContext( GetExpression( lpArgumentString ) );
        break;
        
    case 'd':
        DumpFilterDll( GetExpression( lpArgumentString ),
                       NULL );
        break;
    case 'l':
//        DumpFilterList( GetExpression( lpArgumentString ) );
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\exec.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    exec.cxx

Abstract:

    This module contains an NTSD debugger extension for executing
    external commands.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"


/************************************************************
 * Execute
 ************************************************************/


DECLARE_API( exec )

/*++

Routine Description:

    This function is called as an NTSD extension to ...

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    BOOL result;
    STARTUPINFOA startInfo;
    PROCESS_INFORMATION processInfo;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    //
    // Use "cmd.exe" by default.
    //

    if( *lpArgumentString == '\0' ) {
        lpArgumentString = "cmd";
    }

    //
    // Set the prompt environment variable so the user will have clue.
    //

    SetEnvironmentVariableA(
        "PROMPT",
        "!dtext.exec - $p$g"
        );

    //
    // Launch it.
    //

    ZeroMemory(
        &startInfo,
        sizeof(startInfo)
        );

    ZeroMemory(
        &processInfo,
        sizeof(processInfo)
        );

    startInfo.cb = sizeof(startInfo);

    result = CreateProcessA(
                 NULL,                          // lpszImageName
                 lpArgumentString,              // lpszCommandLine
                 NULL,                          // lpsaProcess
                 NULL,                          // lpsaThread
                 TRUE,                          // fInheritHandles
                 0,                             // fdwCreate
                 NULL,                          // lpvEnvironment
                 NULL,                          // lpszCurDir
                 &startInfo,                    // lpsiStartInfo
                 &processInfo                   // lppiProcessInfo
                 );

    if( result ) {

        //
        // Wait for the child process to terminate, then cleanup.
        //

        WaitForSingleObject( processInfo.hProcess, INFINITE );
        CloseHandle( processInfo.hProcess );
        CloseHandle( processInfo.hThread );

    } else {

        //
        // Could not launch the process.
        //

        dprintf(
            "cannot launch \"%s\", error %lu\n",
            lpArgumentString,
            GetLastError()
            );

    }

}   // DECLARE_API( exec )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\findmod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    findmod.cxx

Abstract:

    Locates module in the debugee containing a specific address.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"

typedef struct _ENUM_CONTEXT {
    ULONG_PTR ModuleAddress;
    PMODULE_INFO ModuleInfo;
    BOOLEAN Successful;
} ENUM_CONTEXT, *PENUM_CONTEXT;


BOOLEAN
CALLBACK
FmpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;

    context = (PENUM_CONTEXT)Param;

    if( context->ModuleAddress >= ModuleInfo->DllBase &&
        context->ModuleAddress < ( ModuleInfo->DllBase + ModuleInfo->SizeOfImage ) ) {

        CopyMemory(
            context->ModuleInfo,
            ModuleInfo,
            sizeof(*ModuleInfo)
            );

        context->Successful = TRUE;

    }

    return !context->Successful;

}   // FmpEnumProc


BOOLEAN
FindModuleByAddress(
    IN ULONG_PTR ModuleAddress,
    OUT PMODULE_INFO ModuleInfo
    )

/*++

Routine Description:

    Finds a module in the debugee that contains the specified address.

Arguments:

    ModuleAddress - The module address to search for.

    ModuleInfo - If successful, receives information describing the
        module found.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result;
    ENUM_CONTEXT context;

    context.ModuleAddress = ModuleAddress;
    context.ModuleInfo = ModuleInfo;
    context.Successful = FALSE;

    result = EnumModules(
                 FmpEnumProc,
                 (PVOID)&context
                 );

    if( result )  {
        result = context.Successful;
    }

    return result;

}   // FindModuleByAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\global.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.cxx

Abstract:

    This module dumps global worker process objects.
    NTSD debugger extension.

Author:

    Michael Courage (mcourage) 07-20-99

Revision History:

--*/

#include "precomp.hxx"

char * g_achShutdownReason[] = {
    "SHUTDOWN_REASON_ADMIN",
    "SHUTDOWN_REASON_ADMIN_GONE",
    "SHUTDOWN_REASON_IDLE_TIMEOUT",
    "SHUTDOWN_REASON_MAX_REQ_SERVED",
    "SHUTDOWN_REASON_FATAL_ERROR"
};

#define SHUTDOWN_TO_STRING( reason )                            \
    ((((reason) >= SHUTDOWN_REASON_ADMIN)                       \
    && ((reason) <= SHUTDOWN_REASON_FATAL_ERROR)) ?             \
    g_achShutdownReason[ (reason) ] : "<Invalid>")


DECLARE_API( global )
{
    ULONG_PTR ctxtPtrAddress;
    ULONG_PTR ctxtPtr;
    DEFINE_CPP_VAR( WP_CONTEXT, ctxt );
    WP_CONTEXT * pctxt = GET_CPP_VAR_PTR( WP_CONTEXT, ctxt );

    DEFINE_CPP_VAR( WP_CONFIG, config );
    WP_CONFIG * pconfig = GET_CPP_VAR_PTR( WP_CONFIG, config );

    DEFINE_CPP_VAR( WP_IDLE_TIMER, timer );
    WP_IDLE_TIMER * ptimer = GET_CPP_VAR_PTR( WP_IDLE_TIMER, timer );

    INIT_API();

    ctxtPtrAddress = GetExpression("&iiswp!g_pwpContext");

    if (ctxtPtrAddress) {
        move( ctxtPtr, ctxtPtrAddress );
        move( ctxt, ctxtPtr );

        dprintf(
            "WP_CONTEXT: %p\n"
            "    m_pConfigInfo = %p\n"
            "    m_ulAppPool.m_hAppPool = %p\n"
            "    m_nreqpool             @ %p\n"
            "        m_lRequestList     @ %p\n"
            "        m_csRequestList    @ %p\n"
            "        m_nRequests        = %d\n"
            "        m_nIdleRequests    = %d\n"
            "        m_dwSignature      = %08x\n"
            "        m_fShutdown        = %d\n"
            "        m_fAddingItems     = %d\n"
            "    m_hDoneEvent           = %p\n"
            "    m_fShutdown            = %d\n"
            "    m_ShutdownReason       = %s\n"
            "    m_pIdleTimer           = %p\n"
            "    m_WpIpm                @ %p\n"
            "        m_pWpContext       = %p\n"
            "        m_pMessageGlobal   = %p\n"
            "        m_pPipe            = %p\n"
            "        m_hConnectEvent    = %p\n"
            "        m_hTerminateEvent  = %p\n",
            ctxtPtr,
            pctxt->m_pConfigInfo,
            pctxt->m_ulAppPool.m_hAppPool,
            ctxtPtr + FIELD_OFFSET( WP_CONTEXT, m_nreqpool ),
            ctxtPtr
                + FIELD_OFFSET( WP_CONTEXT, m_nreqpool )
                + FIELD_OFFSET( UL_NATIVE_REQUEST_POOL, m_lRequestList ),
            ctxtPtr
                + FIELD_OFFSET( WP_CONTEXT, m_nreqpool )
                + FIELD_OFFSET( UL_NATIVE_REQUEST_POOL, m_csRequestList ),
            pctxt->m_nreqpool.m_nRequests,
            pctxt->m_nreqpool.m_nIdleRequests,
            pctxt->m_nreqpool.m_dwSignature,
            pctxt->m_nreqpool.m_fShutdown,
            pctxt->m_nreqpool.m_fAddingItems,
            pctxt->m_hDoneEvent,
            pctxt->m_fShutdown,
            SHUTDOWN_TO_STRING( pctxt->m_ShutdownReason ),
            pctxt->m_pIdleTimer,
            ctxtPtr + FIELD_OFFSET( WP_CONTEXT, m_WpIpm ),
            pctxt->m_WpIpm.m_pWpContext,
            pctxt->m_WpIpm.m_pMessageGlobal,
            pctxt->m_WpIpm.m_pPipe,
            pctxt->m_WpIpm.m_hConnectEvent,
            pctxt->m_WpIpm.m_hTerminateEvent
            );

        move( config, pctxt->m_pConfigInfo );
        dprintf(
            "WP_CONFIG: %p\n"
            "    m_pwszAppPoolName      = %p\n"
            "    m_pwszProgram          = %S\n"
            "    m_fSetupControlChannel = %d\n"
            "    m_fLogErrorsToEventLog = %d\n"
            "    m_fRegisterWithWAS     = %d\n"
            "    m_RestartCount         = %ld\n"
            "    m_NamedPipeId          = %ld\n"
            "    m_IdleTime             = %ld\n"
            "    m_mszURLList           @ %p ( MULTISZ )\n"
            "    m_ulcc                 @ %p\n"
            "        m_hControlChannel  = %p\n"
            "        m_ConfigGroupId    = %I64u\n"
            "        m_hAppPool         = %p\n\n",
            pctxt->m_pConfigInfo,
            pconfig->m_pwszAppPoolName,
            pconfig->m_pwszProgram,
            pconfig->m_fSetupControlChannel,
            pconfig->m_fLogErrorsToEventLog,
            pconfig->m_fRegisterWithWAS,
            pconfig->m_RestartCount,
            pconfig->m_NamedPipeId,
            pconfig->m_IdleTime,
            (ULONG_PTR) pctxt->m_pConfigInfo
                + FIELD_OFFSET( WP_CONFIG, m_mszURLList ),
            (ULONG_PTR) pctxt->m_pConfigInfo
                + FIELD_OFFSET( WP_CONFIG, m_ulcc ),
            pconfig->m_ulcc.m_hControlChannel,
            pconfig->m_ulcc.m_ConfigGroupId,
            pconfig->m_ulcc.m_hAppPool
            );

        move( timer, pctxt->m_pIdleTimer );
        dprintf(
            "WP_IDLE_TIMER: %p\n"
            "    m_BusySignal               = %ld\n"
            "    m_CurrentIdleTick          = %ld\n"
            "    m_IdleTime                 = %ld\n"
            "    m_hIdleTimeExpiredTimer    = %p\n"
            "    m_pContext                 = %p\n\n",
            ptimer->m_BusySignal,
            ptimer->m_CurrentIdleTick,
            ptimer->m_IdleTime,
            ptimer->m_hIdleTimeExpiredTimer,
            ptimer->m_pContext
            );

    } else {
        dprintf(
            "global: cannot evaluate iiswp!g_pwpContext\n"
            );
    }
} // DECLARE_API( nreq )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\heappagi.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappagi.h

Abstract:

    The following definitions are internal to the debug heap manager,
    but are placed in this include file so that debugger extensions
    can reference the same structure definitions.  The following
    definitions are not intended to be referenced externally except
    by debugger extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

//
// Stack trace size. 
//
                                
#define DPH_MAX_STACK_LENGTH   16

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// DPH_HEAP_BLOCK
//

typedef struct _DPH_HEAP_BLOCK DPH_HEAP_BLOCK, *PDPH_HEAP_BLOCK;

struct _DPH_HEAP_BLOCK {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_BLOCK pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    SIZE_T  nVirtualBlockSize;

    SIZE_T  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    SIZE_T  nUserRequestedSize;
    SIZE_T  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

    PRTL_TRACE_BLOCK StackTrace;
};


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_BLOCK  pVirtualStorageListHead;
    PDPH_HEAP_BLOCK  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    SIZE_T                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_BLOCK  pBusyAllocationListHead;
    PDPH_HEAP_BLOCK  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    SIZE_T                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_BLOCK  pFreeAllocationListHead;
    PDPH_HEAP_BLOCK  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    SIZE_T                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_BLOCK  pAvailableAllocationListHead;
    PDPH_HEAP_BLOCK  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    SIZE_T                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_BLOCK  pUnusedNodeListHead;
    PDPH_HEAP_BLOCK  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    SIZE_T                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_BLOCK  pNodePoolListHead;
    PDPH_HEAP_BLOCK  pNodePoolListTail;
    ULONG                 nNodePools;
    SIZE_T                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    PDPH_HEAP_ROOT        pNextHeapRoot;
    PDPH_HEAP_ROOT        pPrevHeapRoot;

    ULONG                 nUnProtectionReferenceCount;
    ULONG                 InsideAllocateNode;           // only for debugging

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;

    //
    // Heap creation stack trace.
    //

    PRTL_TRACE_BLOCK      CreateStackTrace;

    //
    // Thread ID of the first thread inside the heap.
    //

    HANDLE FirstThread;
};


//
// DPH_BLOCK_INFORMATION
//
// This structure is stored in every page heap allocated block.
// This information is not saved if the catch backward overruns
// flag is set.
//

#define DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED   0xABCDAAAA
#define DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED     0xDCBAAAAA
#define DPH_NORMAL_BLOCK_START_STAMP_FREE        (0xABCDAAAA - 1)
#define DPH_NORMAL_BLOCK_END_STAMP_FREE          (0xDCBAAAAA - 1)

#define DPH_PAGE_BLOCK_START_STAMP_ALLOCATED     0xABCDBBBB
#define DPH_PAGE_BLOCK_END_STAMP_ALLOCATED       0xDCBABBBB
#define DPH_PAGE_BLOCK_START_STAMP_FREE          (0xABCDBBBB - 1)
#define DPH_PAGE_BLOCK_END_STAMP_FREE            (0xDCBABBBB - 1)

#define DPH_NORMAL_BLOCK_SUFFIX 	0xA0
#define DPH_PAGE_BLOCK_PREFIX 	    0xB0
#define DPH_PAGE_BLOCK_INFIX 	    0xC0
#define DPH_PAGE_BLOCK_SUFFIX 	    0xD0
#define DPH_NORMAL_BLOCK_INFIX 	    0xE0
#define DPH_FREE_BLOCK_INFIX 	    0xF0

typedef struct _DPH_BLOCK_INFORMATION {

    ULONG StartStamp;

    PVOID Heap;
    SIZE_T RequestedSize;
    SIZE_T ActualSize;

    union {
        LIST_ENTRY FreeQueue;
        USHORT TraceIndex;
    };

    PVOID StackTrace;
    
    ULONG EndStamp;

    //
    // (SilviuC): This structure needs to be 8-byte aligned.
    // If it is not, applications expecting aligned blocks will get
    // unaligned ones because this structure will prefix their
    // allocations. Internet Explorer is one such application
    // that stops working in these conditions.
    //

} DPH_BLOCK_INFORMATION, * PDPH_BLOCK_INFORMATION;

//
// Error reasons used in debug messages
//

#define DPH_SUCCESS                           0x0000
#define DPH_ERROR_CORRUPTED_START_STAMP       0x0001
#define DPH_ERROR_CORRUPTED_END_STAMP         0x0002
#define DPH_ERROR_CORRUPTED_HEAP_POINTER      0x0004
#define DPH_ERROR_CORRUPTED_PREFIX_PATTERN    0x0008
#define DPH_ERROR_CORRUPTED_SUFFIX_PATTERN    0x0010
#define DPH_ERROR_RAISED_EXCEPTION            0x0020
#define DPH_ERROR_NO_NORMAL_HEAP              0x0040
#define DPH_ERROR_CORRUPTED_INFIX_PATTERN     0x0080
#define DPH_ERROR_DOUBLE_FREE                 0x0100


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

#if !defined(_WIN64)
    union {
        struct {

            //
            //  This field gives the size of the current block in allocation
            //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
            //  equals the size in bytes).
            //
            //  Except if this is part of a virtual alloc block then this
            //  value is the difference between the commit size in the virtual
            //  alloc entry and the what the user asked for.
            //

            USHORT Size;

            //
            // This field gives the size of the previous block in allocation
            // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
            // equals the size of the previous block in bytes).
            //

            USHORT PreviousSize;
        };

        volatile PVOID SubSegment;
    };

#else
    
    USHORT Size;
    USHORT PreviousSize;

#endif

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    volatile UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    volatile PVOID SubSegment;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
//  This block describes extra information that might be at the end of a
//  busy block.
//  Note: The heap code is assuming that:
//      sizeof( HEAP_ENTRY_EXTRA ) == sizeof( HEAP_ENTRY )
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    SIZE_T AlignRound;
    SIZE_T AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;

    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //
    
    PVOID FrontEndHeap;
    
    USHORT FrontHeapLockCount;
    UCHAR FrontEndHeapType;
    UCHAR LastSegmentIndex;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\heapfind.cxx ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    heapfind.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    bits of heap information.

Author:

    Keith Moore (keithmo) 01-Nov-1997
    Anil Ruia   (anilr)   02-Mar-2001

Revision History:

--*/

#include "precomp.hxx"

typedef struct _ENUM_CONTEXT {

    ULONG  SizeToDump;
    ULONG  DumpCount;
    ULONG  DumpNDWords;
    ULONG  DWordInBlockToSearchFor;
    PUCHAR BlockToSearchFor;
    BOOLEAN ContinueEnum;

} ENUM_CONTEXT, *PENUM_CONTEXT;

# define minSize(a, b)  (((a) < (b)) ? (a) : (b))


/************************************************************
 * Dump Heap Info
 ************************************************************/

void TestAndDumpEntry(
    PENUM_CONTEXT   context,
    PUCHAR          entryStart,
    ULONG           entryLength,
    VOID            *RemoteHeapEntry,
    ULONG           Flags)
{
    BOOLEAN dumpBlock = FALSE;

    //
    // Decide how to handle this request.
    //

    if( context->BlockToSearchFor != NULL ) {

        //
        // The user is looking for the heap block that contains a
        // specific address. If the current block is a match, then
        // dump it and terminate the enumeration.
        //

        if( context->BlockToSearchFor >= entryStart &&
            context->BlockToSearchFor < ( entryStart + entryLength ) ) {

            dumpBlock = TRUE;
            context->ContinueEnum = FALSE;

        }

    } else {

        //
        // The user is looking for blocks of a specific size. If the
        // size matches, or the user is looking for "big" blocks and
        // the current block is >= 64K, then dump it.
        //

        if( context->SizeToDump == entryLength ||
            ( context->SizeToDump == 0xFFFFFFFF && entryLength >= 65536 ) ) {

            // if looking for a particular DWORD in the memory, then enter
            // some loops below to get chunks of memory and search for the value

            if (context->DWordInBlockToSearchFor != 0) {

                DWORD dwBuff[1024];
                DWORD totalRead = 0;

                // the outer loop will handle the chunked reads of the data

                for (DWORD i=0; (totalRead < entryLength) && (dumpBlock == FALSE); i++) {

                    // determine how much to get this time.

                    DWORD cbToRead = minSize(sizeof(dwBuff), entryLength-totalRead);

                    // get the memory

                    moveBlock( dwBuff, entryStart+totalRead, cbToRead);

                    // record how much we've read so far

                    totalRead += cbToRead;

                    // for simplicity, declare a counter to hold the number of
                    // DWORDs to search.  Note that dropping the remainder in
                    // this case is desired.

                    DWORD dwToSearch = cbToRead/4;

                    // the inner loop will search the read memory for the desired
                    // block

                    for (DWORD j=0; (j < dwToSearch) && (dumpBlock == FALSE); j++) {

                        if (dwBuff[j] == context->DWordInBlockToSearchFor) {
                            dumpBlock = TRUE;
                            break;
                        }
                    }
                }
            }
            else {

                dumpBlock = TRUE;
            }

        }

    }

    if( dumpBlock ) {
        context->DumpCount++;
        dprintf(
            "HeapEntry @ %p [%p], flags = %02x, length = %lx\n",
            RemoteHeapEntry,
            entryStart,
            Flags,
            entryLength
            );

        // check to see if we need to dump the memory of the entry

        if (context->DumpNDWords) {

            // declare a buffer and determine how much to read.  Read no more than
            // the lesser of 1024, the entry's length or the user's request.

            DWORD dwString[1024];
            DWORD cLength = minSize( context->DumpNDWords*sizeof(DWORD), sizeof(dwString));
            if (cLength > entryLength)
                cLength = entryLength;

            //
            // Read the data block from the debuggee process into local buffer
            //
            moveBlock( dwString, entryStart, cLength);

            // adjust the length down to a count of DWORDs

            cLength /= 4;

            // print out the dword count request.  Make it look like 'dc' output

            for (DWORD i=0, j=0; i < cLength; i++, j = ((j + 1) & 3)) {

                // if the first dword on a line, print out the memory address
                // for the line

                if (j == 0)
                    dprintf(" %p  ", entryStart+(i*4));

                // print out the DWORD itself

                dprintf("%08x ", dwString[i]);

                // if at the end of the line, print out the ASCII chars

                if (j == 3) {
                    dprintf("  ");

                    // treat the dword array as an array of bytes and print
                    // out their ASCII values if printable

                    BYTE *pBytes = (BYTE *)&dwString[i-3];
                    for (DWORD k=0; k < 16; k++) {
                        if (isprint((UCHAR)pBytes[k])) {
                            dprintf("%c", pBytes[k]);
                        }
                        else {
                            dprintf(".");
                        }
                    }
                    dprintf("\n");
                }
            }

            // done printing out the requested dwords.  Handle the case
            // where there weren't an even multiple of 4 entries

            if (cLength & 3) {

                // first determine how many we were short

                DWORD numRem = cLength & 3;

                // pad out the display to get to the ASCII portion

                for (DWORD k=4-numRem; k > 0; k--)
                    dprintf("         ");

                dprintf("  ");

                // print out the ASCII values for the dwords that
                // were printed

                BYTE *pBytes = (BYTE *)&dwString[i-numRem];
                for (DWORD k=0; k < (numRem*4); k++) {
                    if (isprint((UCHAR)pBytes[k])) {
                        dprintf("%c", pBytes[k]);
                    }
                    else {
                        dprintf(".");
                    }
                }
                dprintf("\n");
            }
            dprintf("\n");
        }
    }
    
    return;
}

BOOLEAN
CALLBACK
HfpEnumHeapSegmentEntriesProc(
    IN PVOID Param,
    IN PHEAP_ENTRY LocalHeapEntry,
    IN PHEAP_ENTRY RemoteHeapEntry
    )

/*++

Routine Description:

    Callback invoked for each heap entry within a heap segment.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapEntry - Pointer to a local copy of the HEAP_ENTRY structure.

    RemoteHeapEntry - The remote address of the HEAP_ENTRY structure
        in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PUCHAR entryStart;
    ULONG entryLength;

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // allow user to break out of lengthy enumeration
    //
    
    if( CheckControlC() ) {
        context->ContinueEnum = FALSE;
        return TRUE;
    }

    //
    // Ignore free blocks.
    //

    if( !( LocalHeapEntry->Flags & HEAP_ENTRY_BUSY ) ) {
        return TRUE;
    }

    //
    // Calculate the start & length of the heap block.
    //

    entryStart = (PUCHAR)RemoteHeapEntry + sizeof(HEAP_ENTRY);

    entryLength = ( (ULONG)LocalHeapEntry->Size << HEAP_GRANULARITY_SHIFT ) -
        (ULONG)LocalHeapEntry->UnusedBytes;

    TestAndDumpEntry(context, 
                     entryStart, 
                     entryLength, 
                     RemoteHeapEntry, 
                     (ULONG)LocalHeapEntry->Flags);

    return context->ContinueEnum;

}   // HfpEnumHeapSegmentEntriesProc


BOOLEAN
CALLBACK
HfpEnumHeapSegmentsProc(
    IN PVOID Param,
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN ULONG HeapSegmentIndex
    )

/*++

Routine Description:

    Callback invoked for each heap segment within a heap.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT
        structure.

    RemoteHeapSegment - The remote address of the HEAP_SEGMENT
        structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // Enumerate the entries for the specified segment.
    //

    if( !EnumHeapSegmentEntries(
            LocalHeapSegment,
            RemoteHeapSegment,
            HfpEnumHeapSegmentEntriesProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving heap segment entries\n" );
        return FALSE;
    }

    return context->ContinueEnum;

}   // HfpEnumHeapSegmentsProc


BOOLEAN
CALLBACK
HfpEnumHeapsProc(
    IN PVOID Param,
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN ULONG HeapIndex
    )

/*++

Routine Description:

    Callback invoked for each heap within a process.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeap - Pointer to a local copy of the HEAP structure.

    RemoteHeap - The remote address of the HEAP structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // Enumerate the segments for the specified heap.
    //

    if( !EnumHeapSegments(
            LocalHeap,
            RemoteHeap,
            HfpEnumHeapSegmentsProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving heap segments\n" );
        return FALSE;
    }

    return context->ContinueEnum;

}   // HfpEnumHeapsProc



BOOLEAN
CALLBACK
HfpEnumPageHeapBlockProc(
    IN PVOID Param,
    IN PDPH_HEAP_BLOCK pLocalBlock,
    IN PVOID pRemoteBlock
    )
{
    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    PUCHAR entryStart;
    ULONG entryLength;
    BOOLEAN dumpBlock = FALSE;

    entryStart = pLocalBlock->pUserAllocation;
    entryLength = pLocalBlock->nUserRequestedSize;

    TestAndDumpEntry(context, 
                     entryStart, 
                     entryLength, 
                     pRemoteBlock, 
                     (ULONG)pLocalBlock->UserFlags);

    return context->ContinueEnum;
}



BOOLEAN
CALLBACK
HfpEnumPageHeapProc(
    IN PVOID Param,
    IN PDPH_HEAP_ROOT pLocalHeap,
    IN PVOID pRemoteHeap
    )
{
    if (!EnumPageHeapBlocks(pLocalHeap->pBusyAllocationListHead,
                            HfpEnumPageHeapBlockProc,
                            Param))
    {
        dprintf("Error enumerating busy blocks for heap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    return TRUE;
}


DECLARE_API( heapfind )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    heap information.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;
    int          bOptionFound = FALSE;

    INIT_API();

    //
    // Setup.
    //

    RtlZeroMemory(
        &context,
        sizeof(context)
        );

    context.ContinueEnum = TRUE;


    //
    // Interpret the command-line switch.
    //

    while (*lpArgumentString) {

        // skip any whitespace to get to the next argument

        while(isspace(*lpArgumentString))
            lpArgumentString++;

        // break if we hit the NULL terminator

        if (*lpArgumentString == '\0')
            break;

        // should be pointing to a '-' char

        if (*lpArgumentString != '-') {
            PrintUsage("heapfind");
            return;
        }

        // Advance to option letter

        lpArgumentString++;

        // save the option letter

        char cOption = *lpArgumentString;

        // advance past the option letter

        lpArgumentString++;

        // note that at least one option was found

        bOptionFound = TRUE;

        // skip past leading white space in the argument

        while(isspace(*lpArgumentString))
            lpArgumentString++;

        // if we didn't find anything after the option, error

        if (*lpArgumentString == '\0') {
            PrintUsage("heapfind");
            return;
        }

        switch( cOption ) {
            case 'a' :
            case 'A' :
                sscanf(lpArgumentString, "%p", &context.BlockToSearchFor);
                break;

            case 's' :
            case 'S' :
                context.SizeToDump = (ULONG)strtoul( lpArgumentString, NULL, 16 );
                break;

            case 'd' :
            case 'D' :
                context.DumpNDWords = (ULONG)strtoul( lpArgumentString, NULL, 10 );
                break;

            case 'f' :
            case 'F' :
                context.DWordInBlockToSearchFor = (ULONG)strtoul( lpArgumentString, NULL, 16 );
                break;

            default :
                PrintUsage( "heapfind" );
                return;
        }

        // move past the current argument

        while ((*lpArgumentString != ' ') 
               && (*lpArgumentString != '\t') 
               && (*lpArgumentString != '\0')) {
            lpArgumentString++;
        }
    }

    if (bOptionFound == FALSE) {
        PrintUsage("heapfind");
        return;
    }

    // if the 'a' option was found, it should be the only
    // argument on the command line.  The rest don't make
    // sense.

    if ((context.BlockToSearchFor != NULL)
        && ((context.SizeToDump != 0)
            || (context.DumpNDWords != 0)
            || (context.DWordInBlockToSearchFor !=0))) {
        PrintUsage("heapfind");
        return;
    }

    //
    // Enumerate the heaps, which will enumerate the segments, which
    // will enumerate the entries, which will search for the specified
    // address or specified size.
    //

    if( !EnumProcessHeaps(
            HfpEnumHeapsProc,
            (PVOID)&context
            ) ) {
        dprintf( "error retrieving process heaps\n" );
        return;
    }

    if (!EnumProcessPageHeaps(HfpEnumPageHeapProc,
                              &context))
    {
        dprintf( "error retrieving page heaps\n" );
        return;
    }

    if (context.DumpCount > 0)
    {
        dprintf( "Total count: %08lx\n", context.DumpCount);
    }

}   // DECLARE_API( heapfind )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allocation call was generated from on of the
//     target dlls.
//
// PAGE_HEAP_USE_FAULT_INJECTION
//
//     Fault inject heap allocation calls based on a simple 
//     probabilistic model (see FaultProbability and FaultTimeOut).
//
// PAGE_HEAP_PROTECT_META_DATA
//
//     Keep page heap metadata read only if we are not executing inside
//     the page heap code.
//
// PAGE_CHECK_NO_SERIALIZE_ACCESS
//
//     Additional checks for multi-threaded access for no_serialize
//     heaps. This flag can trigger false positives in MPheap. It needs
//     to be used only on processes that do not use MPheap-like heaps.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// If not zero controls the probability with which
// allocations will be failed on purpose by page heap
// manager. Timeout represents the initial period during
// process initialization when faults are not allowed.
//

extern ULONG RtlpDphFaultProbability;
extern ULONG RtlpDphFaultTimeOut;

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

//
// Functions needed to turn on/off fault injection.
// They are needed in the loader so that allocations
// succeed while in LdrLoadDll code path.
//

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\heapstat.cxx ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    heapstat.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    heap statistics.

Author:

    Keith Moore (keithmo) 01-Nov-1997
    Anil Ruia   (anilr)   03-Mar-2001

Revision History:

--*/

#include "precomp.hxx"


#define MAX_SIZE    65536

// Large busy block (size exceeds MAX_SIZE)
#define MAX_LBBSIZE 1024


typedef struct _ENUM_CONTEXT {

    ULONG FreeJumbo;
    ULONG BusyJumbo;
    ULONG FreeJumboBytes;
    ULONG BusyJumboBytes;
    ULONG BusyOverhead;
    ULONG FreeOverhead;
    ULONG FreeCounters[MAX_SIZE];
    ULONG BusyCounters[MAX_SIZE];
    ULONG LargeBusyBlock[MAX_LBBSIZE];

} ENUM_CONTEXT, *PENUM_CONTEXT;

#define BYTES_TO_K(cb) ( ( (cb) + 512 ) / 1024 )


/************************************************************
 * Dump Heap Info
 ************************************************************/


BOOLEAN
CALLBACK
HspEnumHeapSegmentEntriesProc(
    IN PVOID Param,
    IN PHEAP_ENTRY LocalHeapEntry,
    IN PHEAP_ENTRY RemoteHeapEntry
    )

/*++

Routine Description:

    Callback invoked for each heap entry within a heap segment.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapEntry - Pointer to a local copy of the HEAP_ENTRY structure.

    RemoteHeapEntry - The remote address of the HEAP_ENTRY structure
        in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    ULONG entryLength;
    ULONG allocLength;

    //
    // Calculate the total length of this entry, including the heap
    // header and any "slop" at the end of the block.
    //

    entryLength = (ULONG)LocalHeapEntry->Size << HEAP_GRANULARITY_SHIFT;

    //
    // From that, compute the number of bytes in use. This is the size
    // of the allocation request as received from the application.
    //

    allocLength = entryLength - (ULONG)LocalHeapEntry->UnusedBytes;

    //
    // Adjust the appropriate accumulators.
    //

    if( LocalHeapEntry->Flags & HEAP_ENTRY_BUSY ) {

        context->BusyOverhead += entryLength;

        if( allocLength < MAX_SIZE ) {
            context->BusyCounters[allocLength] += 1;
        } else {
            context->BusyJumbo += 1;
            context->BusyJumboBytes += allocLength;

            if (context->LargeBusyBlock[MAX_LBBSIZE-1] == 0) {
                BOOL fFound = FALSE;
                UINT  i = 0;
                for (; context->LargeBusyBlock[i] != 0 && i < MAX_LBBSIZE; i++) {
                    if (allocLength == context->LargeBusyBlock[i]) {
                        fFound = TRUE;  
                        break;
                    }
                }
                if (!fFound && i < MAX_LBBSIZE-1) {
                   context->LargeBusyBlock[i] = allocLength; 
                }
            }
        }

    } else {

        context->FreeOverhead += entryLength;

        if( allocLength < MAX_SIZE ) {
            context->FreeCounters[allocLength] += 1;
        } else {
            context->FreeJumbo += 1;
            context->FreeJumboBytes += allocLength;
        }

    }

    return TRUE;

}   // HspEnumHeapSegmentEntriesProc


BOOLEAN
CALLBACK
HspEnumHeapSegmentsProc(
    IN PVOID Param,
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN ULONG HeapSegmentIndex
    )

/*++

Routine Description:

    Callback invoked for each heap segment within a heap.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT
        structure.

    RemoteHeapSegment - The remote address of the HEAP_SEGMENT
        structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    //
    // Enumerate the entries for the specified segment.
    //

    if( !EnumHeapSegmentEntries(
            LocalHeapSegment,
            RemoteHeapSegment,
            HspEnumHeapSegmentEntriesProc,
            Param
            ) ) {
        dprintf( "error retrieving heap segment entries\n" );
        return FALSE;
    }

    return TRUE;

}   // HspEnumHeapSegmentsProc


BOOLEAN
CALLBACK
HspEnumHeapsProc(
    IN PVOID Param,
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN ULONG HeapIndex
    )

/*++

Routine Description:

    Callback invoked for each heap within a process.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeap - Pointer to a local copy of the HEAP structure.

    RemoteHeap - The remote address of the HEAP structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    //
    // Enumerate the segments for the specified heap.
    //

    if( !EnumHeapSegments(
            LocalHeap,
            RemoteHeap,
            HspEnumHeapSegmentsProc,
            Param
            ) ) {
        dprintf( "error retrieving heap segments\n" );
        return FALSE;
    }

    return TRUE;

}   // HspEnumHeapsProc



BOOLEAN
CALLBACK
HspEnumPageHeapFreeBlockProc(
    IN PVOID Param,
    IN PDPH_HEAP_BLOCK LocalBlock,
    IN PVOID RemoteBlock
    )
{
    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    DWORD nSize = LocalBlock->nUserRequestedSize;

    context->FreeOverhead += nSize;

    if(nSize < MAX_SIZE)
    {
        context->FreeCounters[nSize] += 1;
    }
    else
    {
        context->FreeJumbo += 1;
        context->FreeJumboBytes += nSize;
    }

    return TRUE;
}



BOOLEAN
CALLBACK
HspEnumPageHeapBusyBlockProc(
    IN PVOID Param,
    IN PDPH_HEAP_BLOCK pLocalBlock,
    IN PVOID pRemoteBlock
    )
{
    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    DWORD nSize = pLocalBlock->nUserRequestedSize;

    context->BusyOverhead += nSize;

    if (nSize < MAX_SIZE)
    {
        context->BusyCounters[nSize] += 1;
    }
    else
    {
        context->BusyJumbo += 1;
        context->BusyJumboBytes += nSize;

        if (context->LargeBusyBlock[MAX_LBBSIZE-1] == 0)
        {
            BOOL fFound = FALSE;
            UINT  i = 0;
            for (; context->LargeBusyBlock[i] != 0 && i < MAX_LBBSIZE; i++)
            {
                if (nSize == context->LargeBusyBlock[i])
                {
                    fFound = TRUE;
                    break;
                }
            }

            if (!fFound && i < MAX_LBBSIZE-1)
            {
               context->LargeBusyBlock[i] = nSize;
            }
        }
    }

    return TRUE;
}



BOOLEAN
CALLBACK
HspEnumPageHeapProc(
    IN PVOID Param,
    IN PDPH_HEAP_ROOT pLocalHeap,
    IN PVOID          pRemoteHeap
    )
{
    if (!EnumPageHeapBlocks(pLocalHeap->pBusyAllocationListHead,
                            HspEnumPageHeapBusyBlockProc,
                            Param))
    {
        dprintf("Error enumerating busy blocks for pageheap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    if (!EnumPageHeapBlocks(pLocalHeap->pFreeAllocationListHead,
                            HspEnumPageHeapFreeBlockProc,
                            Param))
    {
        dprintf("Error enumerating free blocks for pageheap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    if (!EnumPageHeapBlocks(pLocalHeap->pAvailableAllocationListHead,
                            HspEnumPageHeapFreeBlockProc,
                            Param))
    {
        dprintf("Error enumerating available blocks for pageheap %p\n",
                pRemoteHeap);
        return FALSE;
    }

    return TRUE;
}



DECLARE_API( heapstat )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    heap statistics.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    PENUM_CONTEXT context;
    ULONG i;
    ULONG busyBytes;
    ULONG totalBusy;
    ULONG totalFree;
    ULONG totalBusyBytes;
    ULONG lowerNoiseBound;

    INIT_API();

    //
    // Setup.
    //

    context = (PENUM_CONTEXT)malloc( sizeof(*context) );

    if( context == NULL ) {
        dprintf( "out of memory\n" );
        return;
    }

    RtlZeroMemory(
        context,
        sizeof(*context)
        );

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        lowerNoiseBound = 1;
    } else {
        lowerNoiseBound = strtoul( lpArgumentString, NULL, 16 );
    }

    //
    // Enumerate the heaps, which will enumerate the segments, which
    // will enumerate the entries, which will accumulate the statistics.
    //

    if( !EnumProcessHeaps(
            HspEnumHeapsProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving process heaps\n" );
        free( context );
        return;
    }

    //
    // Now enumerate the page-heaps
    //

    if (!EnumProcessPageHeaps(HspEnumPageHeapProc,
                              context))
    {
        dprintf( "error retrieving pageheaps\n" );
        free( context );
        return;
    }

    //
    // Dump 'em.
    //

    dprintf(
        "  Size :  NumBusy :  NumFree : BusyBytes\n"
        );

    totalBusy = 0;
    totalFree = 0;
    totalBusyBytes = 0;

    for( i = 0 ; i < MAX_SIZE ; i++ ) {

        busyBytes = i * context->BusyCounters[i];

        if( context->BusyCounters[i] >= lowerNoiseBound ||
            context->FreeCounters[i] >= lowerNoiseBound ) {

            dprintf(
                " %5lx : %8lx : %8lx :  %8lx (%10ldK)\n",
                i,
                context->BusyCounters[i],
                context->FreeCounters[i],
                busyBytes,
                BYTES_TO_K( busyBytes )
                );

        }

        totalBusy += context->BusyCounters[i];
        totalBusyBytes += busyBytes;
        totalFree += context->FreeCounters[i];

    }

    if( context->BusyJumbo >= lowerNoiseBound ||
        context->FreeJumbo >= lowerNoiseBound ) {

        dprintf(
            ">%5lx : %8lx : %8lx :  %8lx (%10ldK)\n",
            MAX_SIZE,
            context->BusyJumbo,
            context->FreeJumbo,
            context->BusyJumboBytes,
            BYTES_TO_K( context->BusyJumboBytes )
            );

        totalBusy += context->BusyJumbo;
        totalFree += context->FreeJumbo;
        totalBusyBytes += context->BusyJumboBytes;

    }

    if (context->LargeBusyBlock[0] != 0) {
        for (i = 0; i < MAX_LBBSIZE && context->LargeBusyBlock[i] != 0; i++) {
            dprintf("%8lx : \n", context->LargeBusyBlock[i]);
        }
    }

    dprintf(
        " Total : %8lx : %8lx :  %8lx (%10ldK)\n"
        "\n"
        " Total Heap Impact from Busy Blocks = %8lx (%10ldK)\n"
        " Total Heap Impact from Free Blocks = %8lx (%10ldK)\n",
        totalBusy,
        totalFree,
        totalBusyBytes,
        BYTES_TO_K( totalBusyBytes ),
        context->BusyOverhead,
        BYTES_TO_K( context->BusyOverhead ),
        context->FreeOverhead,
        BYTES_TO_K( context->FreeOverhead )
        );

    free( context );

}   // DECLARE_API( heapstat )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\lkr-ulw3.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

BOOL
WINAPI
HEADER_HASH_LKHT_Dump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    dprintf("HEADER_HASH\n"
            "\tsm_pRequestHash=%p, sm_rgHeaders=%p\n",
            GetExpression("&HEADER_HASH__sm_pRequestHash"),
            GetExpression("&HEADER_HASH__sm_rgHeaders"));
    return TRUE;
}



BOOL
WINAPI
HEADER_RECORD_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide CWord ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(HEADER_RECORD, hdrec);
    HEADER_RECORD* phdrec = GET_CPP_VAR_PTR(HEADER_RECORD, hdrec); 

    // Copy the HEADER_RECORD from the debuggee's memory
    ReadMemory(pvRecord, &hdrec, sizeof(HEADER_RECORD), NULL);

    // Read the associated string from the debuggee's memory
    WCHAR wsz[64];
    ReadMemory(phdrec->_pszName, wsz, sizeof(wsz), NULL);
    wsz[64-1] = L'\0';

    dprintf("    HEADER_RECORD=%p: HeaderIndex=%lu, Name=\"%S\"\n",
            pvRecord, phdrec->_ulHeaderIndex, wsz);

    return TRUE;
}



BOOL
WINAPI
W3_SITE_LIST_LKHT_Dump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    dprintf("W3_SITE_LIST, %d\n", nVerbose);
    return TRUE;
}



BOOL
WINAPI
W3_SITE_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide W3_SITE ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(W3_SITE, w3site);
    W3_SITE* pw3site = GET_CPP_VAR_PTR(W3_SITE, w3site); 

    // Copy the W3_SITE from the debuggee's memory
    ReadMemory(pvRecord, &w3site, sizeof(W3_SITE), NULL);

    WCHAR wszSiteMBPath[MAX_PATH] = L"";
    DWORD cwcSiteMBPath =   ARRAYSIZE(wszSiteMBPath);
    STRU* pstruSiteMBPath = &pw3site->m_SiteMBPath;
    ReadSTRU(pstruSiteMBPath, wszSiteMBPath, &cwcSiteMBPath);

    WCHAR wszSiteMBRoot[MAX_PATH] = L"";
    DWORD cwcSiteMBRoot =   ARRAYSIZE(wszSiteMBRoot);
    STRU* pstruSiteMBRoot = &pw3site->m_SiteMBRoot;
    ReadSTRU(pstruSiteMBRoot, wszSiteMBRoot, &cwcSiteMBRoot);

    // TODO: dump some of these fields more deeply---perhaps keyed off nVerbose
    dprintf("    W3_SITE=%p (HashSig=%08x): Signature=%08x, "
                "cRefs=%d, SiteId=%d\n",
            pvRecord, dwSignature, pw3site->m_Signature,
                pw3site->m_cRefs, pw3site->m_SiteId);
    dprintf("\tSiteMBPath=\"%S\", SiteMBRoot=\"%S\",\n",
            wszSiteMBPath, wszSiteMBRoot);
    dprintf("\tpInstanceFilterList=%p, "
                "Logging=%p\n",
                pw3site->m_pInstanceFilterList,
                pw3site->m_pLogging);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\help.cxx ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    help.cxx

Abstract:

    This module contains the help text for all commands supported by this
    NTSD debugger extension.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"

//
// The following structure defines the text displayed in response
// to the "!help" command. This text may also be displayed if invalid
// arguments are passed to a command.
//

typedef struct _HELP_MAP {

    //
    // This is the name of the command.
    //

    PSTR Command;

    //
    // This is a "one-liner" displayed when the user executes "!help".
    //

    PSTR OneLiner;

    //
    // This is the full help text displayed when the user executes
    // "!help <cmd>".
    //

    PSTR FullHelp;

} HELP_MAP, *PHELP_MAP;

HELP_MAP HelpMaps[] =
    {
        {
            "help",
            "Dump this list or help for specific command",
            "help [<cmd>] - Dump help for command\n"
            "  If no <cmd> is given, a list of all available commands is displayed\n"
        },

        {
            "ds",
            "Dump stack with symbols",
            "!ds [-v] <addr>  - Dump symbols on stack\n"
            "      -v == print valid symbols only\n"
            "      default addr == current stack pointer\n"
        },

        {
            "ref",
            "Dump reference trace log",
            "!ref <addr> [<context>...] - Dump reference trace log at <addr>\n"
        },

        {
            "rref",
            "Dump reference trace log in reverse order",
            "!rref <addr> [<context>...] - Same as ref, except dumps backwards\n"
        },

        {
            "resetref",
            "Reset reference trace log",
            "!resetref <addr> - Reset reference trace log at <addr>\n"
        },


        {
            "rpcoop",
            "Find process/thread ID buried in RPC parameters",
            "!rpcoop <addr> - given RPC param finds the process id for OOP\n"
            "  Verbosity Levels [v]\n"
            "      0 - Print one line summary\n"
            "      1 - Print level 1 information\n"
            "      2 - Print level 2 information\n"
        },

        {
            "mod",
            "Dump module info",
            "!mod [<addr>] - Dump module info\n"
            "  If <addr> is specified, only module containing <addr> is dumped\n"
        },

        {
            "ver",
            "Dump module version resources",
            "!ver [<module>] - Dump version resource for specified module\n"
            "  <module> may be either a module base address or name\n"
            "  If no <module> is specified, then all modules are dumped\n"
        },

        {
            "heapfind",
            "Find heap block by size or address",
            "!heapfind -a<addr> - Find heap block containing <addr>\n"
            "!heapfind [-f<x>] [-d<n>] -s<size> - Find all heap blocks of length <size>\n"
            "  -d<n> - Print first <n> DWORDs of heap block; where n is decimal\n"
            "  -f<x> - Only print heap blocks that contain <x> DWORD; where x is hexadecimal\n"
        },

        {
            "heapstat",
            "Dump heap statistics",
            "!heapstat <min> - Dump heap statistics\n"
            "  If <min> is present, then only those heap blocks with countes >= <min>\n"
            "  are displayed. Note that *all* heap blocks are included in the totals,\n"
            "  even if those blocks had counts too small to display.\n"
            "  If <min> is not present, all heap blocks are displayed\n"
        },

        {
            "acache",
            "Dump allocation cache structures",
            "!acache <addr>  - Dump Allocation Cache Handler at <addr>\n"
            "!acache -g      - Dump Allocation Cache global information\n"
            "!acache -l[0|1] - Dump Allocation Cache list at verbosity [v]\n"
        },

        {
            "gem",
            "Get current error mode",
            "!gem - Get current error mode\n"
        },

        {
            "exec",
            "Execute external command",
            "!exec [<cmd>] - Execute external command\n"
            "  Default <cmd> is CMD.EXE\n"
        },

        {
            "llc",
            "Counts items on a standard linked-list",
            "!llc <list_head> - Counts the LIST_ENTRYs present on the specified list head\n"
        },

        {
            "dumpoff",
            "Dump structure/class information based on debug info in PDB",
            "!dumpoff <PDB_file>!<Type_name>[.Member_name] [expression]\n"
            "  PDB_file - Non-qualified name of PDB file without extension (say, w3svc,infocomm)\n"
            "  Type_name - Name of type (say, HTTP_FILTER)\n"
            "  Member_name - Optional member of Type_name (say, _strURL)\n"
            "  Expression - Base address of type in question\n\n"
            "  Omitting expression prints offset information from structure\n"
            "  Example: !dtext.dumpoff W3SVC!HTTP_REQUEST 1fdde0\n"
        },

        {
            "vmstat",
            "Dump virtual memory statistics",
            "!vmstat - Dump virtual memory statistics"
        },

        {
            "vmmap",
            "Dump virtual memory map",
            "!vmmap - Dump virtual memory map"
        },

        {
            "nreq",
            "Dump specific (or all) UL_NATIVE_REQUEST",
            "!nreq [-<verbosity>] <addr> - Dump request at addr with optional verbosity\n"
            "!nreq [-<verbosity>] *      - Dump all UL_NATIVE_REQUESTs\n"
        },

        {
            "filter",
            "Dump ISAPI filter information",
            "!filter -g                  - Dump global filter information\n"
            "!filter -d <FILTER_DLL>     - Dump specified HTTP_FILTER_DLL"
            "!filter -l <FILTER_LIST>    - Dump specified FILTER_LIST\n"
            "!filter -x <FILTER_CONTEXT> - Dump specified FILTER_CONTEXT\n"
            "!filter -c <CONNECTION_CTXT>- Dump specified FILTER_CONNECTION_CONTEXT\n"
        },
        
#if 0
        {
            "global",
            "Dump global worker process structures",
            "!global - Dump global data"
        },
#endif

        {
            "lkrhash",
            "Dump LKRhash table structures",
            "!lkrhash [options] <addr>    - Dump LKRhash table at <addr>\n"
             "     -l[0-2] == verbosity level\n"
             "     -v      == very verbose\n"
             "     -g[0-2] == dump global list of LKRhashes at verbosity level\n"
        },

    };

#define NUM_HELP_MAPS ( sizeof(HelpMaps) / sizeof(HelpMaps[0]) )


PSTR
FindHelpForCommand(
    IN PSTR CommandName
    )
{

    PHELP_MAP helpMap;
    ULONG i;

    for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
        if( _stricmp( helpMap->Command, CommandName ) == 0 ) {
            return helpMap->FullHelp;
        }
    }

    return NULL;

}   // FindHelpForCommand

VOID
PrintUsage(
    IN PSTR CommandName
    )
{

    PSTR cmdHelp;
    PHELP_MAP helpMap;
    ULONG i;
    ULONG maxLength;
    ULONG length;

    dprintf( "Duct Tape debugging extension for Duct Tape Version 1.0\n" );

    if( CommandName == NULL ) {

        //
        // We'll display the one-liners for each command. Start by
        // scanning the commands to find the longest length. This makes the
        // output much prettier without having to manually tweak the
        // columns.
        //

        maxLength = 0;

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            length = (ULONG)strlen( helpMap->Command );
            if( length > maxLength ) {
                maxLength = length;
            }
        }

        //
        // Now actually display the one-liners.
        //

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            dprintf(
                "!%-*s - %s\n",
                maxLength,
                helpMap->Command,
                helpMap->OneLiner
                );
        }

    } else {

        //
        // Find a specific command and display the full help.
        //

        cmdHelp = FindHelpForCommand( CommandName );

        if( cmdHelp == NULL ) {
            dprintf( "unrecognized command %s\n", CommandName );
        } else {
            dprintf( "%s", cmdHelp );
        }

    }

} // PrintUsage()


DECLARE_API( help )
{

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( !strcmp( lpArgumentString, "?" ) ) {
        lpArgumentString = "help";
    }

    if( *lpArgumentString == '\0' ) {
        lpArgumentString = NULL;
    }

    PrintUsage( lpArgumentString );

} // DECLARE_API( help )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\lkrcust.h ===
#ifndef LKR_CUST_DECLARE_TABLE

#include "lkrhash.h"

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
 using namespace LKRhash;
 typedef LKRhash::CLKRLinearHashTable CLinearHashTable;
 typedef LKRhash::CLKRHashTable       CHashTable;
#else
 #define LKRHASH_NS
 typedef CLKRLinearHashTable CLinearHashTable;
 typedef CLKRHashTable       CHashTable;
#endif // !__LKRHASH_NO_NAMESPACE__

enum {
    NAME_SIZE           = LKRHASH_NS::CLKRHashTable::NAME_SIZE,
};

typedef
BOOL
(CALLBACK * PFN_LKHT_DUMP)(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose);

typedef
BOOL
(CALLBACK * PFN_LKLH_DUMP)(
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose);

typedef
BOOL
(CALLBACK * PFN_RECORD_DUMP)(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose);

struct LKR_CUST_EXTN {
    LPCSTR          m_pszTableName;
    int             m_cchTableName;
    PFN_LKHT_DUMP   m_pfn_LKHT_Dump;
    PFN_LKLH_DUMP   m_pfn_LKLH_Dump;
    PFN_RECORD_DUMP m_pfn_Record_Dump;
};

LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig);


# define BEGIN_LKR_EXTN_TABLE()

# define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKHT_Dump(                          \
    IN CLKRHashTable*   pht,            \
    IN INT              nVerbose);      \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKLH_Dump(                          \
    IN CLKRLinearHashTable* plht,       \
    IN INT                  nVerbose);  \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_Record_Dump(                        \
    IN const void* pvRecord,            \
    IN DWORD       dwSignature,         \
    IN INT         nVerbose);           \

# define END_LKR_EXTN_TABLE()


#else // LKR_CUST_DECLARE_TABLE


#undef BEGIN_LKR_EXTN_TABLE
#undef LKR_EXTN_DECLARE
#undef END_LKR_EXTN_TABLE


 #define BEGIN_LKR_EXTN_TABLE() \
    LKR_CUST_EXTN g_alce[] = {

 #define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
        { #_TableStr, sizeof(#_TableStr)-1, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump }, 

 #define END_LKR_EXTN_TABLE()   \
        { 0, 0, 0, 0},          \
        };


#endif // LKR_CUST_DECLARE_TABLE



// Important: do NOT put quotes around class name; i.e, first parameter
// should look like MimeMap, not "MimeMap".

BEGIN_LKR_EXTN_TABLE()
  LKR_EXTN_DECLARE(?,
                   Dummy_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   Dummy_Record_Dump)
  LKR_EXTN_DECLARE(HEADER_HASH,
                   HEADER_HASH_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   HEADER_RECORD_Dump)
  LKR_EXTN_DECLARE(W3_SITE_LIST,
                   W3_SITE_LIST_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   W3_SITE_Dump)
END_LKR_EXTN_TABLE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\mod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    mod.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping module
    information.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "precomp.hxx"

typedef struct _ENUM_CONTEXT {
    BOOLEAN FirstTime;
} ENUM_CONTEXT, *PENUM_CONTEXT;


/************************************************************
 * Dump Module Info
 ************************************************************/


BOOLEAN
CALLBACK
ModpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;

    context = (PENUM_CONTEXT)Param;

    if( context->FirstTime ) {
        context->FirstTime = FALSE;
        dprintf( "Start    End      Entry    Path\n" );
    }

    dprintf(
        "%08lx %08lx %08lx %s\n",
        ModuleInfo->DllBase,
        ModuleInfo->DllBase + ModuleInfo->SizeOfImage,
        ModuleInfo->EntryPoint,
        ModuleInfo->FullName
        );

    return TRUE;

}   // ModpEnumProc


DECLARE_API( mod )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    module information.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;
    MODULE_INFO modInfo;
    ULONG address;
    PSTR endPointer;

    INIT_API();

    context.FirstTime = TRUE;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        //
        // No argument passed, dump all modules.
        //

        if( !EnumModules(
                ModpEnumProc,
                (PVOID)&context
                ) ) {
            dprintf( "error retrieving module list\n" );
        }

    } else {

        //
        // Try to find the module containing the specified address.
        //

        address = strtoul( lpArgumentString, &endPointer, 16 );

        if( *endPointer != ' ' && *endPointer != '\t' && *endPointer != '\0' ) {
            PrintUsage( "mod" );
            return;
        }

        if( FindModuleByAddress( address, &modInfo ) ) {
            ModpEnumProc( (PVOID)&context, &modInfo );
        } else {
            dprintf( "Cannot find %08lx\n", address );
        }

    }

}   // DECLARE_API( mod )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\oemdbi.h ===
// Debug Information API
// VC++5.0 Read-Only OEM Edition
// Copyright (C) 1993-1997, Microsoft Corp.  All Rights Reserved.

#ifndef __OEMDBI_INCLUDED__
#define __OEMDBI_INCLUDED__

typedef int             BOOL;
typedef unsigned        UINT;
typedef unsigned char   BYTE;
typedef unsigned long   ULONG;
typedef unsigned short  USHORT;
typedef unsigned long   DWORD;
typedef short           SHORT;
typedef long            LONG;
typedef char *          SZ;

typedef unsigned long   CV_typ_t;
typedef CV_typ_t        TI;     // PDB name for type index
typedef ULONG           INTV;   // interface version number
typedef ULONG           IMPV;   // implementation version number
typedef ULONG           SIG;    // unique (across PDB instances) signature
typedef ULONG           AGE;    // no. of times this instance has been updated
typedef BYTE*           PB;     // pointer to some bytes
typedef LONG            CB;     // count of bytes
typedef char*           SZ;     // zero terminated string
typedef char*           PCH;    // char ptr
typedef USHORT          IFILE;  // file index
typedef USHORT          IMOD;   // module index
typedef USHORT          ISECT;  // section index
typedef USHORT          LINE;   // line number
typedef LONG            OFF;    // offset
typedef BYTE            ITSM;   // type server map index

enum {
    PDBIntv50a  = 19970116,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntv     = PDBIntv50a,
};

enum {
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,    // max. length of error message
};

typedef CV_typ_t TI;        // type index
struct PDB;                 // program database
struct DBI;                 // debug information within the PDB
struct Mod;                 // a module within the DBI
struct TPI;                 // type info within the DBI
struct GSI;
struct Enum;                // generic enumerator
struct EnumContrib;         // enumerate contributions
struct Dbg;                 // misc debug data (FPO, OMAP, etc)

typedef struct PDB PDB;
typedef struct DBI DBI;
typedef struct Mod Mod;
typedef struct TPI TPI;
typedef struct GSI GSI;
typedef struct Enum Enum;
typedef struct EnumContrib EnumContrib;
typedef struct Dbg Dbg;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_MAX
};

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL

#define PDBAPI PDB_IMPORT_EXPORT

#define IN                  /* in parameter, parameters are IN by default */
#define OUT                 /* out parameter */

struct _tagSEARCHDEBUGINFO;
typedef BOOL (__stdcall * pfnFindDebugInfoFile) ( struct _tagSEARCHDEBUGINFO* );
typedef BOOL (__stdcall * PFNVALIDATEDEBUGINFOFILE) (const char* szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancillary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    SZ      szMod;                      // exe/dll
    SZ      szLib;                      // lib if appropriate
    SZ      szObj;                      // object file
    SZ *    rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char    szValidatedFile[PDB_MAX_PATH]; // output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
};

typedef enum DBGTYPE DBGTYPE;

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

PDBAPI( BOOL )
PDBOpenValidate(
    SZ szPDB,
    SZ szExeDir,
    SZ szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI( BOOL )
PDBOpen(
    SZ szPDB,
    SZ szMode,
    SIG sigInitial,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI( BOOL )
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface()
{
    return PDBExportValidateInterface(PDBIntv);
}

PDBAPI( EC )    PDBQueryLastError(PDB* ppdb, OUT char szError[cbErrMax]);
PDBAPI( INTV )  PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI( IMPV )  PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI( SZ )    PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI( SIG )   PDBQuerySignature(PDB* ppdb);
PDBAPI( AGE )   PDBQueryAge(PDB* ppdb);
PDBAPI( BOOL )  PDBOpenDBI(PDB* ppdb, SZ szMode, SZ szTarget, OUT DBI** ppdbi);
PDBAPI( BOOL )  PDBOpenTpi(PDB* ppdb, SZ szMode, OUT TPI** pptpi);
PDBAPI( BOOL )  PDBClose(PDB* ppdb);
PDBAPI( BOOL )  PDBOpenDBIEx(PDB* ppdb, const char* szTarget, const char* szMode, OUT DBI** ppdbi, pfnFindDebugInfoFile srchfcn);

PDBAPI( BOOL )  DBIOpenMod(DBI* pdbi, SZ szModule, SZ szFile, OUT Mod** ppmod);
PDBAPI( BOOL )  DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI( BOOL )  DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI( BOOL )  DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI( BOOL )  DBIQueryModFromAddr(DBI* pdbi, ISECT isect, OFF off, OUT Mod** ppmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb);
PDBAPI( BOOL )  DBIQuerySecMap(DBI* pdbi, OUT PB pb, CB* pcb);
PDBAPI( BOOL )  DBIQueryFileInfo(DBI* pdbi, OUT PB pb, CB* pcb);
PDBAPI( BOOL )  DBIClose(DBI* pdbi);
PDBAPI( BOOL )  DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI( BOOL )  DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI( BOOL )  DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI( BOOL )  DBIQueryLazyTypes(DBI* pdbi);
PDBAPI( BOOL )  DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI( BOOL )  DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI( BOOL )  DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);

PDBAPI( BOOL )  ModQueryCBName(Mod* pmod, OUT CB* pcb);
PDBAPI( BOOL )  ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT CB* pcb);
PDBAPI( BOOL )  ModQuerySymbols(Mod* pmod, PB pbSym, CB* pcb);
PDBAPI( BOOL )  ModQueryLines(Mod* pmod, PB pbLines, CB* pcb);
PDBAPI( BOOL )  ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI( BOOL )  ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI( BOOL )  ModQuerySecContrib(Mod* pmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI( BOOL )  ModQueryImod(Mod* pmod, OUT IMOD* pimod);
PDBAPI( BOOL )  ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI( BOOL )  ModClose(Mod* pmod);
PDBAPI( BOOL )  ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI( BOOL )  ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI( BOOL )  ModQueryTpi(Mod* pmod, OUT TPI** pptpi);

PDBAPI( void )  EnumContribRelease(EnumContrib* penum);
PDBAPI( void )  EnumContribReset(EnumContrib* penum);
PDBAPI( BOOL )  EnumContribNext(EnumContrib* penum);
PDBAPI( void )  EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);

PDBAPI( BOOL )  DbgClose(Dbg *pdbg);
PDBAPI( long )  DbgQuerySize(Dbg *pdbg);
PDBAPI( void )  DbgReset(Dbg *pdbg);
PDBAPI( BOOL )  DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI( BOOL )  DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI( BOOL )  DbgFind(Dbg *pdbg, IN OUT void *pelt);

// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)    TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT PB pb, IN OUT CB* pcb);
PDBAPI(BOOL)    TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT PB* ppb);
PDBAPI(TI)      TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)      TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(CB)      TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)    TypesClose(TPI* ptpi);
PDBAPI(BOOL)    TypesQueryTiForUDTEx(TPI* ptpi, char* sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)    TypesSupportQueryTiForUDT(TPI*);

// Map all old ones to new ones for new compilands.
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx

PDBAPI( PB )    GSINextSym (GSI* pgsi, PB pbSym);
PDBAPI( PB )    GSIHashSym (GSI* pgsi, SZ szName, PB pbSym);
PDBAPI( PB )    GSINearestSym (GSI* pgsi, ISECT isect, OFF off,OUT OFF* pdisp);//currently only supported for publics
PDBAPI( BOOL )  GSIClose(GSI* pgsi);

#if __cplusplus
};
#endif

#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((IMOD)(-1))

#define pdbRead                 "r"
#define pdbGetRecordsOnly       "c"         /* open PDB for type record access */

#endif // __OEMDBI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\lkrcust.cpp ===
#include "precomp.hxx"
#include "lkrcust.h"


LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig)
{
    extern LKR_CUST_EXTN g_alce[];

    struct LKRheader {
        DWORD m_dwSignature;
        CHAR  m_szName[NAME_SIZE];
    };

    LKRheader lkrh;
    rdwSig = 0;
    
    if (!ReadMemory(lkrAddress, &lkrh, sizeof(lkrh), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID) lkrAddress);

        return NULL;
    }

    rdwSig = lkrh.m_dwSignature;

    lkrh.m_szName[NAME_SIZE-1] = '\0';
    const INT cch = strlen(lkrh.m_szName);
    
    for (LKR_CUST_EXTN* plce = g_alce + 1;  // skip Dummys
         plce->m_pszTableName != NULL;
         ++plce)
    {
        if (strncmp(plce->m_pszTableName, lkrh.m_szName,
                    min(cch, plce->m_cchTableName)) == 0)
        {
            return plce;
        }
    }

    return &g_alce[0];  // Dummy methods
}



BOOL
WINAPI
Dummy_LKHT_Dump(
    IN LKRHASH_NS::CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_LKLH_Dump(
    IN LKRHASH_NS::CLKRLinearHashTable* plht,
    IN INT                  nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_Record_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    dprintf("Record=%p (HashSig=%08x)\n", pvRecord, dwSignature);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\ntstuff.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ntstuff.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    NT-specific properties.

Author:

    Keith Moore (keithmo) 08-Nov-1997

Revision History:

--*/

#include "precomp.hxx"



/************************************************************
 * Dump Current Error Mode
 ************************************************************/

DECLARE_API( gem )

/*++

Routine Description:

    This function is called as an NTSD extension to display the
    current error mode of the debugee.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    UINT errorMode;

    INIT_API();

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessDefaultHardErrorMode,
                 (PVOID)&errorMode,
                 sizeof(errorMode),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        dprintf( "Cannot query error mode, error %08lx\n", status );
        return;
    }

    if( errorMode & 1 ) {
        errorMode &= ~SEM_FAILCRITICALERRORS;
    } else {
        errorMode |= SEM_FAILCRITICALERRORS;
    }

    dprintf(
        "Current error mode = %08lx\n",
        errorMode
        );

    if( errorMode & SEM_FAILCRITICALERRORS ) {
        dprintf( "    SEM_FAILCRITICALERRORS\n" );
    }

    if( errorMode & SEM_NOGPFAULTERRORBOX ) {
        dprintf( "    SEM_NOGPFAULTERRORBOX\n" );
    }

    if( errorMode & SEM_NOALIGNMENTFAULTEXCEPT ) {
        dprintf( "    SEM_NOALIGNMENTFAULTEXCEPT\n" );
    }

    if( errorMode & SEM_NOOPENFILEERRORBOX ) {
        dprintf( "    SEM_NOOPENFILEERRORBOX\n" );
    }

}   // DECLARE_API( gem )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\nreq.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nreq.cxx

Abstract:

    This module dumps UL_NATIVE_REQUEST objects.
    NTSD debugger extension.

Author:

    Michael Courage (mcourage) 07-19-99

Revision History:

--*/

#include "precomp.hxx"

extern 
VOID
DumpReferenceLog(
    IN PSTR lpArgumentString,
    IN BOOLEAN fReverse
    );

char * g_achRequestState[] = {
    "NREQ_STATE_START",
    "NREQ_STATE_READ",
    "NREQ_STATE_PROCESS",
    "NREQ_STATE_ERROR",
    "NREQ_STATE_CLIENT_CERT"
    };

char * g_achVerbs[] = {
    "Unparsed",
    "Unknown",
    "Invalid",
    "OPTIONS",
    "GET",
    "HEAD",
    "POST",
    "PUT",
    "DELETE",
    "TRACE",
    "CONNECT",
    "TRACK",
    "MOVE",
    "COPY",
    "PROPFIND",
    "PROPPATCH",
    "MKCOL",
    "LOCK",
    "UNLOCK",
    "SEARCH",
};

char * g_achKnownHeaders[ HttpHeaderRequestMaximum ] = {
    "Cache-Control",        // 0
    "Connection",
    "Date",
    "Keep-Alive",
    "Pragma",
    "Trailer",              // 5
    "Transfer-Encoding",
    "Upgrade",
    "Via",
    "Warning",
    "Allow",                // 10
    "Content-Length",
    "Content-Type",
    "Content-Encoding",
    "Content-Language",
    "Content-Location",     // 15
    "Content-MD5",
    "Content-Range",
    "Expires",
    "LastModified",
    "Accept",               // 20
    "Accept-CharSet",
    "Accept-Encoding",
    "Accept-Language",
    "Authorization",
    "Cookie",               // 25
    "Expect",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",    // 30
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Max-Forwards",
    "Proxy-Authorization",  // 35
    "Referer",
    "Range",
    "Transfer-Encoding",
    "Translate",
    "User-Agent"            // 40
};

VOID
DumpString(
    WCHAR *         pszDebugeeAddress,
    DWORD           cbBuffer
)
{
    PVOID pBuffer = LocalAlloc( LPTR, cbBuffer + sizeof(WCHAR) );
    if ( pBuffer != NULL )
    {
        moveBlock( (*((CHAR*)pBuffer)), pszDebugeeAddress, cbBuffer );
        dprintf(
            "%ws",
            (LPWSTR) pBuffer
            );
        
        LocalFree( pBuffer);
    }
}

VOID
DumpString(
    CHAR *          pszDebugeeAddress,
    DWORD           cbBuffer
)
{
    PVOID pBuffer = LocalAlloc( LPTR, cbBuffer + sizeof(CHAR) );
    if ( pBuffer != NULL )
    {
        moveBlock( (*((CHAR*)pBuffer)), pszDebugeeAddress, cbBuffer );
        dprintf(
            "%s",
            (LPSTR) pBuffer
            );
        
        LocalFree( pBuffer);
    }
}

VOID
DumpRequestVerb(
    HTTP_REQUEST*    pUlReq
)
{
    if ( pUlReq->Verb == HttpVerbUnknown )
    {
        DumpString( pUlReq->pUnknownVerb,
                    pUlReq->UnknownVerbLength );
    }
    else
    {
        dprintf( g_achVerbs[ pUlReq->Verb ] );
    }
}

VOID
DumpRequestRawUrl(
    HTTP_REQUEST *   pUlReq
)
{
    DumpString( pUlReq->pRawUrl,
                pUlReq->RawUrlLength );
}

VOID
DumpRequestVersion(
    HTTP_REQUEST *   pUlReq
)
{
    dprintf( "HTTP/%d.%d", pUlReq->Version.MajorVersion, pUlReq->Version.MinorVersion );
}

VOID
DumpRequestHeaders(
    HTTP_REQUEST *   pUlReq
)
{
    DWORD               cCounter;

    //
    // First dump out known headers
    //
    
    for ( cCounter = 0; 
          cCounter < HttpHeaderRequestMaximum;
          cCounter++ )
    {
        if ( pUlReq->Headers.pKnownHeaders[ cCounter ].pRawValue != NULL )
        {
            dprintf( 
                "%s: ",
                g_achKnownHeaders[ cCounter ]
                );
            
            DumpString( pUlReq->Headers.pKnownHeaders[ cCounter ].pRawValue,
                        pUlReq->Headers.pKnownHeaders[ cCounter ].RawValueLength );
            
            dprintf( "\n" );
        }
    }
          
    //
    // Dump out unknown headers
    //
    
    HTTP_UNKNOWN_HEADER *pUnknown = NULL;
    
    pUnknown = (HTTP_UNKNOWN_HEADER *)
                        LocalAlloc( LPTR,
                                    sizeof( HTTP_UNKNOWN_HEADER ) * 
                                    pUlReq->Headers.UnknownHeaderCount );    
    if ( pUnknown == NULL )
    {
        return;
    }
    
    moveBlock( (*(pUnknown)), 
               pUlReq->Headers.pUnknownHeaders,
               sizeof( HTTP_UNKNOWN_HEADER ) * pUlReq->Headers.UnknownHeaderCount );
    
    for ( cCounter = 0;
          cCounter < pUlReq->Headers.UnknownHeaderCount;
          cCounter++ )
    {
        DumpString( pUnknown[ cCounter ].pName,
                    pUnknown[ cCounter ].NameLength );
                    
        dprintf( ": " );
        
        DumpString( pUnknown[ cCounter ].pRawValue,
                    pUnknown[ cCounter ].RawValueLength );
        
        dprintf( "\n" );
    }
    
    if ( pUnknown != NULL )
    {
        LocalFree( pUnknown );
    }
}

VOID
DumpNativeRequest(
    ULONG_PTR           nreqAddress,
    UL_NATIVE_REQUEST * pRequest,
    CHAR                chVerbosity
)
{
    char *              pszRequestState;
    char *              pbBuffer = NULL;
    HTTP_REQUEST *      pUlReq;
    CHAR                achRefCommand[ 256 ];
    
    if ( pRequest->_ExecState < NREQ_STATE_START ||
         pRequest->_ExecState > NREQ_STATE_CLIENT_CERT )
    {
        pszRequestState = "<Invalid>";
    }
    else
    {
        pszRequestState = g_achRequestState[ pRequest->_ExecState ];
    }
    
    //
    // Dump the bare minimum
    //
    
    dprintf(
        "%p : %s state = %s, refs = %d, pvContext = %p\n",
        nreqAddress,
        pRequest->_dwSignature == UL_NATIVE_REQUEST_SIGNATURE ? "" : " (INVALID!)",
        pszRequestState,
        pRequest->_cRefs,
        pRequest->_pvContext 
        );

    //
    // Next verbosity is still pretty trivial
    //

    if ( chVerbosity >= '1' )
    {
        dprintf(
            "\t_cbAsyncIOData       = %d\n"
            "\t_dwAsyncIOError      = %d\n"
            "\t_overlapped.Internal = %08x\n"
            "\t(UL_HTTP_REQUEST*)   = %p\n",
            pRequest->_cbAsyncIOData,
            pRequest->_dwAsyncIOError,
            pRequest->_Overlapped.Internal,
            pRequest->_pbBuffer
            );
    }
    
    //
    // Dump out some more useful stuff.  Now we will actually go to the
    // UL_HTTP_REQUEST structure
    // 
    // But do so only if the state is NREQ_STATE_PROCESS (i.e. we've read
    // the request
    //
    
    if ( pRequest->_ExecState != NREQ_STATE_PROCESS &&
         pRequest->_ExecState != NREQ_STATE_CLIENT_CERT )
    {
        return;
    }

    pbBuffer = (CHAR*) LocalAlloc( LPTR, pRequest->_cbBuffer );
    if ( pbBuffer == NULL )
    {
        return;
    }
    moveBlock( (*(pbBuffer)), 
               pRequest->_pbBuffer, 
               pRequest->_cbBuffer );
    pUlReq = (HTTP_REQUEST*) pbBuffer;

    //
    // Dump out the entire "stream"ized request
    //

    if ( chVerbosity >= '2' )
    {
        dprintf( 
            "\tConnectionId = %I64x\n"
            "\tRequestId    = %I64x\n"
            "-------------\n",
            pUlReq->ConnectionId,
            pUlReq->RequestId
            );

        //
        // Dump the request line
        //
            
        DumpRequestVerb( pUlReq );
        dprintf( " " );
        DumpRequestRawUrl( pUlReq );
        dprintf( " " );
        DumpRequestVersion( pUlReq );
        dprintf( "\n" );

        //
        // Dump the headers
        //
            
        DumpRequestHeaders( pUlReq );
        
        dprintf( 
            "-------------\n\n"
            );
    }

    if ( chVerbosity >= '3' )
    {    
        //
        // Dump out the reference log (if any)
        //

        sprintf( achRefCommand,
                 "poi(w3dt!UL_NATIVE_REQUEST__sm_pTraceLog) %p",
                 nreqAddress );
    
        DumpReferenceLog( achRefCommand, FALSE );   
    }
    
    //
    // Cleanup 
    //
    
    if ( pbBuffer != NULL )
    {
        LocalFree( pbBuffer );
    }
}

VOID
DumpNativeRequestThunk(
    PVOID nreqAddress,
    PVOID pnreq,
    CHAR  chVerbosity,
    DWORD iThunk
    )
{
    DumpNativeRequest(
        (ULONG_PTR) nreqAddress,
        (UL_NATIVE_REQUEST *) pnreq,
        chVerbosity
        );
}


VOID
DumpAllNativeRequests(
    CHAR chVerbosity
    )
{
    ULONG_PTR       reqlistAddress;

    reqlistAddress = GetExpression("&w3dt!UL_NATIVE_REQUEST__sm_RequestListHead");
    if (!reqlistAddress) 
    {
        dprintf("couldn't evaluate w3dt!UL_NATIVE_REQUEST__sm_RequestListHead\n");
        return;
    }

    EnumLinkedList(
        (LIST_ENTRY *) reqlistAddress,
        DumpNativeRequestThunk,
        chVerbosity,
        sizeof(UL_NATIVE_REQUEST),
        FIELD_OFFSET(UL_NATIVE_REQUEST, _ListEntry)
        );
}


DECLARE_API( nreq )
/*++

Routine Description:

    This function is called as an NTSD extension to reset a reference
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    ULONG_PTR               nreqAddress;
    CHAR                    chVerbosity = 0;
    DEFINE_CPP_VAR( UL_NATIVE_REQUEST, nreq );

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) 
    {
        lpArgumentString++;
    }
    
    //
    // Parse out verbosity if any
    //    
    
    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;
        chVerbosity = *lpArgumentString;
        
        if ( *lpArgumentString != '\0' )
        {
            lpArgumentString++;
        } 
    }
    
    //
    // Skip spaces again
    //
    
    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) 
    {
        lpArgumentString++;
    }
    
    //
    // * means list
    //
    
    if ( *lpArgumentString == '\0' ||
         *lpArgumentString == '*' ) 
    {
        //
        // Default verbosity on a list is minimal
        //
        
        if ( chVerbosity == 0 )
        {
            chVerbosity = '0';
        }
        
        DumpAllNativeRequests( chVerbosity );
    }
    else
    {
        nreqAddress = GetExpression( lpArgumentString );

        if (nreqAddress) {

            move( nreq, nreqAddress );

            //
            // Default verbosity on a single dump is high
            //
            
            if ( chVerbosity == 0 )
            {
                chVerbosity = '2';
            }

            DumpNativeRequest(
                nreqAddress,
                GET_CPP_VAR_PTR(UL_NATIVE_REQUEST, nreq),
                chVerbosity
                );

        } else {
            dprintf(
                "nreq: cannot evaluate \"%s\"\n",
                lpArgumentString
                );
        }
    }
} // DECLARE_API( nreq )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtflags\makefile.inc ===
$(O)\dtflags.res: dtflags.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\template.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    template.cxx

Abstract:

    This is just a template for creating new NTSD extension commands.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"


// Don't forget to add 'template' to dtext.def

DECLARE_API( template )

/*++

Routine Description:

    This function is called as an NTSD extension to ...

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        //
        // ???
        //

    } else {

        //
        // ???
        //

    }

}   // DECLARE_API( template )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\ref.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ref.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    Internet Information Server.

Author:

    Keith Moore (keithmo) 27-Aug-1997

Revision History:

--*/

#include "precomp.hxx"

//
// The maximum number of contexts that may be passed to the "ref"
// extension command on the command line.
//

#define MAX_REF_CONTEXT 64


/************************************************************
 * Dump Reference Traces
 ************************************************************/


BOOL
IsContextInList(
    IN PVOID Context,
    IN PVOID * ContextList,
    IN LONG NumContextsInList
    )

/*++

Routine Description:

    Scans the given context list looking for the specified context value.

Arguments:

    Context - The context value to look for.

    ContextList - The context list to scan.

    NumContextsInList - The number of contexts in the context list.

Return Value:

    BOOL - TRUE if the context value is in the list, FALSE if not.

--*/

{
    while( NumContextsInList > 0 ) {
        if( *ContextList == Context ) {
            return TRUE;
        }

        ContextList++;
        NumContextsInList--;
    }

    return FALSE;
}


VOID
DumpReferenceLog(
    IN PSTR lpArgumentString,
    IN BOOLEAN fReverse
    )

/*++

Routine Description:

    Dumps the specified reference log either forwards (fReverse == FALSE)
    or backwards (fReverse == TRUE).

Arguments:

    lpArgumentString - An expression specifying the reference log to
        dump.

    fReverse - The dump direction.

Return Value:

    None.

--*/

{
    ULONG_PTR refLogAddress = 0;
    ULONG_PTR entryAddress;
    LONG numEntries;
    TRACE_LOG logHeader;
    REF_TRACE_LOG_ENTRY logEntry;
    LONG i;
    ULONG_PTR offset;
    PCHAR format;
    PVOID specificContexts[MAX_REF_CONTEXT];
    LONG numSpecificContexts = 0;
    LONG index;
    LONG direction;
    PSTR cmdName;
    UCHAR symbol[MAX_SYMBOL_LEN];

    direction = fReverse ? -1 : 1;
    cmdName = fReverse ? "rref" : "ref";

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    refLogAddress = (ULONG_PTR)GetExpression( lpArgumentString );

    if( refLogAddress == 0 ) {

        dprintf(
            "dtext.%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    //
    // If we have context values, use them.
    //

    while( *lpArgumentString != '\0' && numSpecificContexts < MAX_REF_CONTEXT ) {

        specificContexts[numSpecificContexts++] =
            (PVOID)GetExpression( lpArgumentString );

        while( *lpArgumentString != ' ' &&
               *lpArgumentString != '\t' &&
               *lpArgumentString != '\0' ) {
            lpArgumentString++;
        }

        while( *lpArgumentString == ' ' ||
               *lpArgumentString == '\t' ) {
            lpArgumentString++;
        }

    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.%s: cannot read memory @ %p\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    dprintf(
        "dtext.%s: log @ %p:\n"
        "    Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        cmdName,
        (PVOID)refLogAddress,
        logHeader.Signature,
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.LogBuffer
        );

    if( logHeader.LogBuffer > ( (PUCHAR)refLogAddress + sizeof(logHeader) ) ) {
        dprintf(
            "    Extra Data @ %p\n",
            (PVOID)( refLogAddress + sizeof(logHeader) )
            );
    }

    if( logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X ) {

        dprintf(
            "dtext.%s: log @ %p has invalid signature %08lx:\n",
            cmdName,
            (PVOID)refLogAddress,
            logHeader.Signature
            );

        return;

    }

    if( logHeader.EntrySize != sizeof(logEntry) ) {

        dprintf(
            "dtext.%s: log @ %p is not a ref count log\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    if( logHeader.NextEntry == -1 ) {

        dprintf(
            "dtext.%s: empty log @ %p\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    //
    // Calculate the starting address and number of entries.
    //

    if( fReverse ) {
        if( logHeader.NextEntry < logHeader.LogSize ) {
            numEntries = logHeader.NextEntry + 1;
            index = logHeader.NextEntry;
        } else {
            numEntries = logHeader.LogSize;
            index = logHeader.NextEntry % logHeader.LogSize;
        }
    } else {
        if( logHeader.NextEntry < logHeader.LogSize ) {
            numEntries = logHeader.NextEntry + 1;
            index = 0;
        } else {
            numEntries = logHeader.LogSize;
            index = ( logHeader.NextEntry + 1 ) % logHeader.LogSize;
        }
    }

    entryAddress = (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( index * sizeof(logEntry) );

    if( entryAddress >=
        ( (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( numEntries * sizeof(logEntry) ) ) ) {

        dprintf(
            "dtext.%s: log @ %p has invalid data\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    //
    // Dump the log.
    //

    for( ;
         numEntries > 0 ;
         index += direction,
         numEntries--,
         entryAddress += ( direction * sizeof(logEntry) ) ) {

        if( CheckControlC() ) {
            break;
        }

        if( index >= logHeader.LogSize ) {
            index = 0;
            entryAddress = (ULONG_PTR)logHeader.LogBuffer;
        } else if( index < 0 ) {
            index = logHeader.LogSize - 1;
            entryAddress = (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( index * sizeof(logEntry) );
        }

        if( !ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ) ) {

            dprintf(
                "dtext.%s: cannot read memory @ %p\n",
                cmdName,
                (ULONG_PTR)entryAddress
                );

            return;

        }

        if( ( numSpecificContexts == 0 ) ||
            IsContextInList(
                logEntry.Context,
                specificContexts,
                numSpecificContexts
                ) ) {

            dprintf(
                "\nThread = %08p, Context = %08p, NewRefCount = %-10ld : %ld\n",
                logEntry.Thread,
                logEntry.Context,
                logEntry.NewRefCount,
                index
                );

            if (    logEntry.Context1 != REF_TRACE_EMPTY_CONTEXT
                 || logEntry.Context2 != REF_TRACE_EMPTY_CONTEXT
                 || logEntry.Context3 != REF_TRACE_EMPTY_CONTEXT
                 ) {

                //
                //  if the caller passed extended context values,
                //  write them to the log
                //
                //  NOTE we use REF_TRACE_EMPTY_CONTEXT in all extended
                //  contexts as the signal that a caller does not use
                //  extended context - avoids spew for callers who don't care.
                //

                dprintf(
                    "Context1 = %08p, Context2 = %08p, Context3 = %08p\n",
                    logEntry.Context1,
                    logEntry.Context2,
                    logEntry.Context3
                    );
            }

            for( i = 0 ; i < REF_TRACE_LOG_STACK_DEPTH ; i++ ) {

                if( logEntry.Stack[i] == NULL ) {
                    break;
                }

                GetSymbol(
                    (ULONG_PTR)logEntry.Stack[i],
                    symbol,
                    &offset
                    );

                if( symbol[0] == '\0' ) {
                    format = "    %08p\n";
                } else
                if( offset == 0 ) {
                    format = "    %08p : %s\n";
                } else {
                    format = "    %08p : %s+0x%p\n";
                }

                dprintf(
                    format,
                    logEntry.Stack[i],
                    symbol,
                    offset
                    );

            }

        }

    }

} // DumpReferenceLog


DECLARE_API( ref )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a reference trace log.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();
    DumpReferenceLog( lpArgumentString, FALSE );

} // DECLARE_API( ref )


DECLARE_API( rref )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a reference trace log backwards.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();
    DumpReferenceLog( lpArgumentString, TRUE );

} // DECLARE_API( rref )


DECLARE_API( resetref )

/*++

Routine Description:

    This function is called as an NTSD extension to reset a reference
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR refLogAddress = 0;
    TRACE_LOG logHeader;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "resetref" );
        return;
    }

    refLogAddress = GetExpression( lpArgumentString );

    if( refLogAddress == 0 ) {

        dprintf(
            "dtext.resetref: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            (ULONG_PTR)refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.resetref: cannot read memory @ %p\n",
            refLogAddress
            );

        return;

    }

    dprintf(
        "dtext.resetref: log @ %p:\n"
        "    Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %08lx\n",
        (PVOID) refLogAddress,
        logHeader.Signature,
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.LogBuffer
        );

    if( logHeader.LogBuffer > ( (PUCHAR)refLogAddress + sizeof(logHeader) ) ) {
        dprintf(
            "    Extra Data @ %08p\n",
            (PVOID) (refLogAddress + sizeof(logHeader))
            );
    }

    if( logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X ) {

        dprintf(
            "dtext.resetref: log @ %p has invalid signature %08lx:\n",
            (PVOID) refLogAddress,
            logHeader.Signature
            );

        return;

    }

    if( logHeader.EntrySize != sizeof(REF_TRACE_LOG_ENTRY) ) {

        dprintf(
            "dtext.resetref: log @ %p is not a ref count log\n",
            (PVOID) refLogAddress
            );

        return;

    }

    //
    // Reset it.
    //

    logHeader.NextEntry = -1;

    if( !WriteMemory(
            refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.resetref: cannot write memory @ %p\n",
            (PVOID) refLogAddress
            );

        return;

    }

    dprintf(
        "dtext.resetref: log @ %p reset\n",
        (PVOID) refLogAddress
        );

} // DECLARE_API( resetref )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\ver.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ver.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping module
    version resources.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "precomp.hxx"

PSTR VersionLabels[] =
     {
         "CompanyName",
         "FileDescription",
         "FileVersion",
         "InternalName",
         "LegalCopyright",
         "OriginalFilename",
         "ProductName",
         "ProductVersion"
     };
#define NUM_LABELS ( sizeof(VersionLabels) / sizeof(VersionLabels[0]) )

typedef struct _ENUM_CONTEXT {
    PSTR ModuleName;
    INT NameLength;
} ENUM_CONTEXT, *PENUM_CONTEXT;


/************************************************************
 * Dump File Version Info
 ************************************************************/

PIMAGE_RESOURCE_DIRECTORY
FindResourceDir(
    IN PIMAGE_RESOURCE_DIRECTORY BaseResourceDir,
    IN PIMAGE_RESOURCE_DIRECTORY TargetResourceDir,
    IN USHORT ResourceId
    )

/*++

Routine Description:

    Finds the specified resource directory.

Arguments:

    BaseResourceDir - The (remote) address of the *start* of the resource
        section.

    TargetResourceDir - The (remote) address of the resource directory
        to search.

    ResourceId - The resource ID we're looking for.

Return Value:

    PIMAGE_RESOURCE_DIRECTORY - Pointer to the resource directory
        corresponding to ResourceId if successful, NULL otherwise.

--*/

{

    IMAGE_RESOURCE_DIRECTORY localDir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY localEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY remoteEntry;
    USHORT i;

    //
    // Read the target resource directory.
    //

    if( !ReadMemory(
            (ULONG_PTR)TargetResourceDir,
            &localDir,
            sizeof(localDir),
            NULL
            ) ) {
        return NULL;
    }

    //
    // Scan it.
    //

    remoteEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( TargetResourceDir + 1 );

    for( i = localDir.NumberOfNamedEntries + localDir.NumberOfIdEntries ;
         i > 0 ;
         i--, remoteEntry++ ) {

        //
        // Read the directory entry.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteEntry,
                &localEntry,
                sizeof(localEntry),
                NULL
                ) ) {
            return NULL;
        }

        //
        // If the entry is a directory and the IDs match, then return it.
        //

        if( localEntry.DataIsDirectory == 0 ) {
            continue;
        }

        if( localEntry.NameIsString == 0 &&
            localEntry.Id == ResourceId ) {

            return (PIMAGE_RESOURCE_DIRECTORY)
                       ( (ULONG_PTR)BaseResourceDir + localEntry.OffsetToDirectory );

        }

    }

    return NULL;

}   // FindResourceDir

PIMAGE_RESOURCE_DATA_ENTRY
FindResourceData(
    IN PIMAGE_RESOURCE_DIRECTORY BaseResourceDir,
    IN PIMAGE_RESOURCE_DIRECTORY TargetResourceDir,
    IN USHORT ResourceId
    )

/*++

Routine Description:

    Finds the specified resource data item.

Arguments:

    BaseResourceDir - The (remote) address of the *start* of the resource
        section.

    TargetResourceDir - The (remote) address of the resource directory
        to search.

    ResourceId - The resource ID we're looking for. This may be zero
        to return any resource.

Return Value:

    PIMAGE_RESOURCE_DATA_ENTRY - Pointer to the resource data entry
        corresponding to ResourceId if successful, NULL otherwise.

--*/

{

    IMAGE_RESOURCE_DIRECTORY localDir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY localEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY remoteEntry;
    USHORT i;

    //
    // Read the target resource directory.
    //

    if( !ReadMemory(
            (ULONG_PTR)TargetResourceDir,
            &localDir,
            sizeof(localDir),
            NULL
            ) ) {
        return NULL;
    }

    //
    // Scan it.
    //

    remoteEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( TargetResourceDir + 1 );

    for( i = localDir.NumberOfNamedEntries + localDir.NumberOfIdEntries ;
         i > 0 ;
         i--, remoteEntry++ ) {

        //
        // Read the directory entry.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteEntry,
                &localEntry,
                sizeof(localEntry),
                NULL
                ) ) {
            return NULL;
        }

        //
        // If the entry is not a directory and the IDs match (or the
        // requested ID is zero, meaning any ID) then return it.
        //

        if( localEntry.DataIsDirectory != 0 ) {
            continue;
        }

        if( localEntry.NameIsString == 0 &&
            ( localEntry.Id == ResourceId ||
              ResourceId == 0 ) ) {

            return (PIMAGE_RESOURCE_DATA_ENTRY)
                       ( (ULONG_PTR)BaseResourceDir + localEntry.OffsetToDirectory );

        }

    }

    return NULL;

}   // FindResourceData


BOOL
DumpVersionResource(
    IN PVOID VersionResource
    )

/*++

Routine Description:

    Dumps a version resource block.

Arguments:

    VersionResource - The version resource to dump.

Return Value:

    BOOL - TRUE if successful, FALSE if the version resource block
        was corrupt or unreadable.

--*/

{

    ULONG charSet;
    LPVOID version;
    UINT versionLength;
    INT i;
    VS_FIXEDFILEINFO * fixedFileInfo;
    CHAR label[MAX_PATH];

    //
    // Get the language/character-set pair.
    //

    if( !VerQueryValueA(
            VersionResource,
            "\\VarFileInfo\\Translation",
            &version,
            &versionLength
            ) ) {
        return FALSE;
    }

    charSet = *(LPDWORD)version;
    charSet = (DWORD)MAKELONG( HIWORD(charSet), LOWORD(charSet) );

    //
    // Get the root block so we can determine if this is a free or
    // checked build.
    //

    if( !VerQueryValueA(
             VersionResource,
             "\\",
             &version,
             &versionLength
             ) ) {
        return FALSE;
    }

    fixedFileInfo = (VS_FIXEDFILEINFO *)version;

    dprintf(
        "%-19s = 0x%08lx (%s)\n",
        "dwFileFlags",
        fixedFileInfo->dwFileFlags,
        ( ( fixedFileInfo->dwFileFlags & VS_FF_DEBUG ) != 0 )
            ? "CHECKED"
            : "FREE"
        );

    //
    // Dump the various version strings.
    //

    for( i = 0 ; i < NUM_LABELS ; i++ ) {

        wsprintfA(
            label,
            "\\StringFileInfo\\%08lX\\%s",
            charSet,
            VersionLabels[i]
            );

        if( VerQueryValueA(
                VersionResource,
                label,
                &version,
                &versionLength
                ) ) {
            dprintf(
                "%-19s = %s\n",
                VersionLabels[i],
                version
                );
        }

    }

    dprintf( "\n" );

    return TRUE;

}   // DumpVersionResource


VOID
FindAndDumpVersionResourceByAddress(
    IN ULONG_PTR ModuleAddress,
    IN PSTR ModuleName
    )

/*++

Routine Description:

    Locates and dumps the version resource for the module based at
    the specified address.

Arguments:

    ModuleAddress - The base address of the module to dump.

    ModuleName - The module name, for display purposes.

Return Value:

    None.

--*/

{

    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS ntHeaders;
    PIMAGE_OPTIONAL_HEADER optionalHeader;
    PIMAGE_DATA_DIRECTORY dataDir;
    PIMAGE_RESOURCE_DIRECTORY baseResourceDir;
    PIMAGE_RESOURCE_DIRECTORY tmpResourceDir;
    PIMAGE_RESOURCE_DATA_ENTRY dataEntry;
    IMAGE_RESOURCE_DATA_ENTRY localDataEntry;
    PVOID versionResource;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    versionResource = NULL;

    //
    // Read & validate the image headers.
    //

    if( !ReadMemory(
            ModuleAddress,
            &dosHeader,
            sizeof(dosHeader),
            NULL
            ) ) {

        dprintf(
            "dtext.ver: cannot read DOS header @ 0x%p\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( dosHeader.e_magic != IMAGE_DOS_SIGNATURE ) {

        dprintf(
            "dtext.ver: module @ 0x%p has invalid DOS header\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( !ReadMemory(
            ModuleAddress + dosHeader.e_lfanew,
            &ntHeaders,
            sizeof(ntHeaders),
            NULL
            ) ) {

        dprintf(
            "dtext.ver: cannot read NT headers @ 0x%p\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( ntHeaders.Signature != IMAGE_NT_SIGNATURE ) {

        dprintf(
            "dtext.ver: module @ 0x%p has invalid NT headers\n",
            ModuleAddress
            );

        goto cleanup;

    }

    optionalHeader = &ntHeaders.OptionalHeader;

    if( optionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC ) {

        dprintf(
            "dtext.ver: module @ 0x%p has invalid optional header\n",
            ModuleAddress
            );

        goto cleanup;

    }

    //
    // Locate the resource.
    //

    dataDir = &optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];

    if( dataDir->VirtualAddress == 0 ||
        dataDir->Size == 0 ) {

        dprintf(
            "dtext.ver: module @ 0x%p has no resource information\n",
            ModuleAddress
            );

        goto cleanup;

    }

    baseResourceDir = (PIMAGE_RESOURCE_DIRECTORY)
                          ( ModuleAddress + dataDir->VirtualAddress );

    //
    // Now go and find the resource in the image. Since resources are
    // stored heirarchally, we're basically for the resource path:
    //
    //     VS_FILE_INFO\VS_VERSION_INFO\LanguageId
    //
    // For the language ID, we'll first try 0x409 (English) and if
    // that fails, we'll take any language.
    //

    dataEntry = NULL;

    tmpResourceDir = FindResourceDir(
                         baseResourceDir,
                         baseResourceDir,
                         (USHORT)VS_FILE_INFO
                         );

    if( tmpResourceDir != NULL ) {

        tmpResourceDir = FindResourceDir(
                             baseResourceDir,
                             tmpResourceDir,
                             (USHORT)VS_VERSION_INFO
                             );

        if( tmpResourceDir != NULL ) {

            dataEntry = FindResourceData(
                            baseResourceDir,
                            tmpResourceDir,
                            0x409
                            );

            if( dataEntry == NULL ) {

                dataEntry = FindResourceData(
                                baseResourceDir,
                                tmpResourceDir,
                                0
                                );

            }

        }

    }

    if( dataEntry == NULL ) {

        dprintf(
            "dtext.ver: cannot find version resource\n"
            );

        goto cleanup;

    }

    //
    // Actually read the dir entry.
    //

    if( !ReadMemory(
            (ULONG_PTR)dataEntry,
            &localDataEntry,
            sizeof(localDataEntry),
            NULL
            ) ) {

        dprintf(
            "dtext.ver: error reading resource\n"
            );

        goto cleanup;

    }

    //
    // Now we can allocate & read the resource.
    //

    versionResource = malloc( localDataEntry.Size );

    if( versionResource == NULL ) {

        dprintf(
            "dtext.ver: not enough memory\n"
            );

        goto cleanup;

    }

    if( !ReadMemory(
            ModuleAddress + localDataEntry.OffsetToData,
            versionResource,
            localDataEntry.Size,
            NULL
            ) ) {

        dprintf(
            "dtext.ver: error reading resource\n"
            );

        goto cleanup;

    }

    //
    // Dump it.
    //

    dprintf(
        "Module @ 0x%p = %s\n",
        ModuleAddress,
        ModuleName
        );

    if( !DumpVersionResource( versionResource ) ) {

        dprintf(
            "Cannot interpret version resource\n"
            );

        goto cleanup;

    }

cleanup:

    if( versionResource != NULL ) {
        free( versionResource );
    }

}   // FindAndDumpVersionResourceByAddress


BOOLEAN
CALLBACK
VerpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;
    INT baseNameLength;

    context = (PENUM_CONTEXT)Param;
    baseNameLength = strlen( ModuleInfo->BaseName );

    //
    // If the user wants all modules, or if the specified module matches
    // the "tail" of the module name, dump it.
    //

    if( context->ModuleName == NULL ||
        ( baseNameLength >= context->NameLength &&
          !_stricmp(
              context->ModuleName,
              ModuleInfo->BaseName + baseNameLength - context->NameLength
              ) ) ) {

        FindAndDumpVersionResourceByAddress(
            ModuleInfo->DllBase,
            ModuleInfo->BaseName
            );

    }

    return TRUE;

}   // VerpEnumProc


VOID
FindAndDumpVersionResourceByName(
    IN PSTR ModuleName
    )

/*++

Routine Description:

    Locates and dumps the version resource for the specified module.

Arguments:

    ModuleName - The name of the module to dump. If this is NULL then
        all modules are dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;

    context.ModuleName = ModuleName;

    if( ModuleName == NULL ) {
        context.NameLength = 0;
    } else {
        context.NameLength = strlen( ModuleName );
    }

    if( !EnumModules(
            VerpEnumProc,
            (PVOID)&context
            ) ) {
        dprintf( "error retrieving module list\n" );
    }

}   // FindAndDumpVersionResourceByName


DECLARE_API( ver )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    module version info.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG module;
    PSTR endPointer;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        //
        // No argument passed, dump all modules.
        //

        FindAndDumpVersionResourceByName( NULL );

    } else {

        module = strtoul( lpArgumentString, &endPointer, 16 );

        if( *endPointer != ' ' && *endPointer != '\t' && *endPointer != '\0' ) {

            //
            // Assume the argument is actually a module name, not
            // a base address.
            //

            FindAndDumpVersionResourceByName( lpArgumentString );

        } else {

            FindAndDumpVersionResourceByAddress( module, NULL );

        }

    }

}   // DECLARE_API( ver )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtext\vm.cxx ===
/*++

Copyright (c) 1999-1999  Microsoft Corporation

Module Name:

    vm.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    virtual memory statistics.

Author:

    Keith Moore (keithmo) 15-Jan-1999

Revision History:

--*/

#include "precomp.hxx"


//
// Private constants.
//

#define SMALL_REGION        (64 * 1024)
#define MEDIUM_REGION       (1 * 1024 * 1024)

#define IS_SMALL(c)         ((c) <= SMALL_REGION)
#define IS_MEDIUM(c)        (((c) > SMALL_REGION) && ((c) <= MEDIUM_REGION))
#define IS_LARGE(c)         ((c) > MEDIUM_REGION)

#define PRINTF_FORMAT       "%-7s %*s %*s %*s %*s\n"

#define CCH_ULONG_COMMAS    sizeof("4,294,967,296")


//
// Private types.
//

typedef struct _INDIVIDUAL_STAT
{
    SIZE_T MinimumSize;
    SIZE_T MaximumSize;
    SIZE_T TotalSize;
    SIZE_T BlockCount;

} INDIVIDUAL_STAT, *PINDIVIDUAL_STAT;

typedef struct _VM_STATS
{
    INDIVIDUAL_STAT Summary;
    INDIVIDUAL_STAT Small;
    INDIVIDUAL_STAT Medium;
    INDIVIDUAL_STAT Large;

} VM_STATS, *PVM_STATS;

typedef struct PROTECT_MASK
{
    DWORD Bit;
    PSTR Name;

} PROTECT_MASK, *PPROTECT_MASK;


//
// Private globals.
//

PROTECT_MASK ProtectMasks[] =
    {
        {
            PAGE_NOACCESS,
            "NA"
        },

        {
            PAGE_NOCACHE,
            "NC"
        },

        {
            PAGE_GUARD,
            "G"
        },

        {
            PAGE_READONLY,
            "Rd"
        },

        {
            PAGE_READWRITE,
            "RdWr"
        },

        {
            PAGE_WRITECOPY,
            "WrCp"
        },

        {
            PAGE_EXECUTE,
            "Ex"
        },

        {
            PAGE_EXECUTE_READ,
            "ExRd"
        },

        {
            PAGE_EXECUTE_READWRITE,
            "ExRdWr"
        },

        {
            PAGE_EXECUTE_WRITECOPY,
            "ExWrCp"
        }
    };

#define NUM_PROTECT_MASKS (sizeof(ProtectMasks) / sizeof(ProtectMasks[0]))


//
// Private functions.
//

PSTR
ULongLongToString(
    IN ULONGLONG Value,
    OUT PSTR Buffer
    )
{

    PSTR p1;
    PSTR p2;
    CHAR ch;
    INT digit;
    INT count;
    BOOL needComma;
    INT length;

    //
    // Handling zero specially makes everything else a bit easier.
    //

    if( Value == 0 ) {
        Buffer[0] = '0';
        Buffer[1] = '\0';
        return Buffer;
    }

    //
    // Pull the least signifigant digits off the value and store them
    // into the buffer. Note that this will store the digits in the
    // reverse order.
    //

    p1 = p2 = Buffer;
    count = 3;
    needComma = FALSE;

    while( Value != 0 ) {

        if( needComma ) {
            *p1++ = ',';
            needComma = FALSE;
        }

        digit = (INT)( Value % 10 );
        Value = Value / 10;

        *p1++ = '0' + digit;

        count--;
        if( count == 0 ) {
            count = 3;
            needComma = TRUE;
        }

    }

    length = DIFF(p1 - Buffer);

    //
    // Reverse the digits in the buffer.
    //

    *p1-- = '\0';

    while( p1 > p2 ) {

        ch = *p1;
        *p1 = *p2;
        *p2 = ch;

        p2++;
        p1--;

    }

    return Buffer;

}   // ULongLongToString

VOID
InitVmStats(
    OUT PVM_STATS Stats
    )
{
    ZeroMemory( Stats, sizeof(*Stats) );
    Stats->Summary.MinimumSize = (SIZE_T)-1L;
    Stats->Small.MinimumSize = (SIZE_T)-1L;
    Stats->Medium.MinimumSize = (SIZE_T)-1L;
    Stats->Large.MinimumSize = (SIZE_T)-1L;

}   // InitVmStats

VOID
UpdateIndividualStat(
    IN OUT PINDIVIDUAL_STAT Stat,
    IN SIZE_T BlockSize
    )
{
    Stat->BlockCount++;
    Stat->TotalSize += BlockSize;

    if( BlockSize > Stat->MaximumSize ) {
        Stat->MaximumSize = BlockSize;
    }

    if( BlockSize < Stat->MinimumSize ) {
        Stat->MinimumSize = BlockSize;
    }

}   // UpdateIndividualStat

VOID
UpdateVmStats(
    IN OUT PVM_STATS Stats,
    IN SIZE_T BlockSize
    )
{
    UpdateIndividualStat( &Stats->Summary, BlockSize );

    if( IS_SMALL(BlockSize) ) {
        UpdateIndividualStat( &Stats->Small, BlockSize );
    }

    if( IS_MEDIUM(BlockSize) ) {
        UpdateIndividualStat( &Stats->Medium, BlockSize );
    }

    if( IS_LARGE(BlockSize) ) {
        UpdateIndividualStat( &Stats->Large, BlockSize );
    }

}   // UpdateVmStats

VOID
PrintVmStatsHeader(
    VOID
    )
{
    dprintf(
        PRINTF_FORMAT,
        "TYPE",
        CCH_ULONG_COMMAS,
        "MINIMUM",
        CCH_ULONG_COMMAS,
        "MAXIMUM",
        CCH_ULONG_COMMAS,
        "AVERAGE",
        CCH_ULONG_COMMAS,
        "BLK COUNT"
        );

    printf(
        PRINTF_FORMAT,
        "~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~~~"
        );

}   // PrintVmStatsHeader

VOID
PrintIndividualStat(
    IN PSTR Name,
    IN PINDIVIDUAL_STAT Stat
    )
{
    SIZE_T average;
    SIZE_T minsize;
    CHAR minStr[CCH_ULONG_COMMAS];
    CHAR maxStr[CCH_ULONG_COMMAS];
    CHAR avgStr[CCH_ULONG_COMMAS];
    CHAR countStr[CCH_ULONG_COMMAS];

    if( Stat->BlockCount == 0 ) {
        average = 0;
        minsize = 0;
    } else {
        average = Stat->TotalSize / Stat->BlockCount;
        minsize = Stat->MinimumSize;
    }

    dprintf(
        PRINTF_FORMAT,
        Name,
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)minsize,
            minStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)Stat->MaximumSize,
            maxStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)average,
            avgStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)Stat->BlockCount,
            countStr
            )
        );

}   // PrintIndividualStat

VOID
PrintVmStats(
    IN PSTR Name,
    IN PVM_STATS Stats
    )
{
    dprintf( "%s:\n", Name );

    PrintIndividualStat( "Small", &Stats->Small );
    PrintIndividualStat( "Medium", &Stats->Medium );
    PrintIndividualStat( "Large", &Stats->Large );
    PrintIndividualStat( "Summary", &Stats->Summary );

    dprintf( "\n" );

}   // PrintVmStats

PSTR
VmProtectToString(
    IN DWORD Protect,
    OUT PSTR Buffer
    )
{
    INT i;
    PPROTECT_MASK mask;

    Buffer[0] = '\0';

    for( i = 0, mask = &ProtectMasks[0] ;
        (i < NUM_PROTECT_MASKS) && (Protect != 0) ;
        i++, mask++ ) {
        if( mask->Bit & Protect ) {
            Protect &= ~mask->Bit;
            if( Buffer[0] != '\0' ) {
                strcat( Buffer, "|" );
            }
            strcat( Buffer, mask->Name );
        }
    }

    if( Protect != 0 ) {
        if( Buffer[0] != '\0' ) {
            strcat( Buffer, "|" );
        }
        sprintf( Buffer + strlen(Buffer), "%08lx", Protect );
    }

    return Buffer;

}   // VmProtectToString

PSTR
VmStateToString(
    IN DWORD State,
    OUT PSTR Buffer
    )
{
    PSTR result;
    CHAR invalidStr[sizeof("12345678")];

    switch( State )
    {
    case MEM_COMMIT:
        result = "Commit";
        break;

    case MEM_RESERVE:
        result = "Reserve";
        break;

    case MEM_FREE:
        result = "Free";
        break;

    default:
        sprintf( invalidStr, "%08lx", State );
        result = invalidStr;
        break;
    }

    strcpy( Buffer, result );
    return Buffer;

}   // VmStateToString

PSTR
VmTypeToString(
    IN DWORD Type,
    OUT PSTR Buffer
    )
{
    PSTR result;
    CHAR invalidStr[sizeof("12345678")];

    switch( Type )
    {
    case MEM_PRIVATE:
        result = "Private";
        break;

    case MEM_MAPPED:
        result = "Mapped";
        break;

    case MEM_IMAGE:
        result = "Image";
        break;

    case 0:
        result = "";
        break;

    default:
        sprintf( invalidStr, "%08lx", Type );
        result = invalidStr;
        break;
    }

    strcpy( Buffer, result );
    return Buffer;

}   // VmTypeToString


/************************************************************
 * Dump Virtual Memory Info
 ************************************************************/


DECLARE_API( vmstat )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    virtual memory statistics.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    ULONG_PTR address;
    MEMORY_BASIC_INFORMATION memInfo;
    VM_STATS freeStats;
    VM_STATS reserveStats;
    VM_STATS commitStats;
    VM_STATS privateStats;
    VM_STATS mappedStats;
    VM_STATS imageStats;

    INIT_API();

    //
    // Setup.
    //

    InitVmStats( &freeStats );
    InitVmStats( &reserveStats );
    InitVmStats( &commitStats );
    InitVmStats( &privateStats );
    InitVmStats( &mappedStats );
    InitVmStats( &imageStats );

    address = 0;

    //
    // Scan the virtual address space.
    //

    for( ; ; ) {
        status = NtQueryVirtualMemory(
                     hCurrentProcess,
                     (PVOID)address,
                     MemoryBasicInformation,
                     &memInfo,
                     sizeof(memInfo),
                     NULL
                     );

        if( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Interpret the memory state.
        //

        switch( memInfo.State ) {
        case MEM_FREE:
            UpdateVmStats( &freeStats, memInfo.RegionSize );
            break;

        case MEM_RESERVE:
            UpdateVmStats( &reserveStats, memInfo.RegionSize );
            break;

        case MEM_COMMIT:
            UpdateVmStats( &commitStats, memInfo.RegionSize );
            break;
        }

        //
        // Interpret the memory type.
        //

        switch( memInfo.Type ) {
        case MEM_PRIVATE:
            UpdateVmStats( &privateStats, memInfo.RegionSize );
            break;

        case MEM_MAPPED:
            UpdateVmStats( &mappedStats, memInfo.RegionSize );
            break;

        case MEM_IMAGE:
            UpdateVmStats( &imageStats, memInfo.RegionSize );
            break;
        }

        //
        // Advance to the next block.
        //

        address += memInfo.RegionSize;
    }

    //
    // Dump it.
    //

    PrintVmStatsHeader();
    PrintVmStats( "Free", &freeStats );
    PrintVmStats( "Reserve", &reserveStats );
    PrintVmStats( "Commit", &commitStats );
    PrintVmStats( "Private", &privateStats );
    PrintVmStats( "Mapped", &mappedStats );
    PrintVmStats( "Image", &imageStats );

}   // DECLARE_API( vmstat )


DECLARE_API( vmmap )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the debugee's virtual memory address space.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    ULONG_PTR address;
    MEMORY_BASIC_INFORMATION memInfo;
    CHAR protectStr[32];
    CHAR aprotectStr[32];
    CHAR stateStr[16];
    CHAR typeStr[16];

    INIT_API();

    //
    // Setup.
    //

    address = 0;

    dprintf(
        "%-*s %-*s %-*s  %-13s %-13s %-8s %-8s\n",
        sizeof(PVOID) * 2,
        "Start",
        sizeof(PVOID) * 2,
        "Stop",
        sizeof(PVOID) * 2,
        "Length",
        "AllocProtect",
        "Protect",
        "State",
        "Type"
        );

    //
    // Scan the virtual address space.
    //

    for( ; ; ) {
        status = NtQueryVirtualMemory(
                     hCurrentProcess,
                     (PVOID)address,
                     MemoryBasicInformation,
                     &memInfo,
                     sizeof(memInfo),
                     NULL
                     );

        if( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Dump the current entry.
        //

        dprintf(
            "%p-%p %p  %-13s %-13s %-8s %-8s\n",
            memInfo.BaseAddress,
            (ULONG_PTR)memInfo.BaseAddress + memInfo.RegionSize - 1,
            memInfo.RegionSize,
            VmProtectToString( memInfo.AllocationProtect, aprotectStr ),
            VmProtectToString( memInfo.Protect, protectStr ),
            VmStateToString( memInfo.State, stateStr ),
            VmTypeToString( memInfo.Type, typeStr )
            );

        //
        // Advance to the next block.
        //

        address += memInfo.RegionSize;
    }

}   // DECLARE_API( vmmap )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\atl.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

#include <precomp.hxx>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

//
// don't need this. it keeps the compiler happy
//
CComModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtflags\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file for the dtflags.exe app.

Author:

    Michael Courage (mcourage)      21-Aug-1999

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>




#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtflags\dtflags.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dtflags.c

Abstract:

    A debug flag twiddling program

Author:

    Michael Courage (mcourage)      21-Aug-1999

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

// this funny business gets me the DEBUG_* flags on free builds
#if !DBG
#undef DBG
#define DBG 1
#define DBG_FLIP
#endif

// have to undef _DBGUTIL_H_ or we'll only get one set of flags.
// also undef DEFAULT_OUTPUT_FLAGS so it doesn't get defined 
// each time.

#include "..\ipm\dbgutil.h"

#undef _DBGUTIL_H_
#undef DEFAULT_OUTPUT_FLAGS
#include "..\..\iiswp\dbgutil.h"

#undef _DBGUTIL_H_
#undef DEFAULT_OUTPUT_FLAGS
#include "..\..\inc\wasdbgut.h"

#ifdef DBG_FLIP
#undef DBG_FLIP
#undef DBG
#define DBG 0
#endif

//
// Registry keys
//
#define REGISTRY_WAS_PARAM \
            L"System\\CurrentControlSet\\Services\\iisw3adm\\Parameters"

#define REGISTRY_DEBUG_FLAGS L"DebugFlags"

#define REGISTRY_WP_PARAM   REGISTRY_WAS_PARAM L"\\WP"

#define REGISTRY_IPM_PARAM  REGISTRY_WAS_PARAM L"\\IPM"

#define REGISTRY_XSP_PARAM \
            L"Software\\Microsoft\\XSP\\Debug"

//
// Our command table.
//

typedef
INT
(WINAPI * PFN_COMMAND)(
    IN INT   argc,
    IN PWSTR argv[],
    IN HKEY  key,
    IN PVOID pTable
    );

typedef struct _COMMAND_ENTRY
{
    PWSTR pCommandName;
    PWSTR pUsageHelp;
    PWSTR pRegistryName;
    PVOID pTable;
    PFN_COMMAND pCommandHandler;
} COMMAND_ENTRY, *PCOMMAND_ENTRY;


//
// Standard debug flag stuff
//

typedef struct _FLAG_ENTRY {
    PWSTR pName;
    PWSTR pDisplayFormat;
    LONG  Value;
} FLAG_ENTRY, *PFLAG_ENTRY;

#define MAKE_FLAG( name, display )                                          \
    {                                                                       \
        (PWSTR)L#name,                                                      \
        (display),                                                          \
        DEBUG_ ## name                                                      \
    }

#define DEBUG_END 0x0

//
// Reserved debug flags
//

FLAG_ENTRY FlagTable[] =
{
    MAKE_FLAG(API_ENTRY, L"entry points to APIs"),
    MAKE_FLAG(API_EXIT, L"exit points for APIs"),
    MAKE_FLAG(INIT_CLEAN, L"process or dll init"),
    MAKE_FLAG(ERROR, L"errors"),

    MAKE_FLAG(END, L"end of table")
};



//
// WAS specifig debug flags
//

FLAG_ENTRY FlagTableWas[] = 
{
    MAKE_FLAG(WEB_ADMIN_SERVICE, L"basically all of was"),

    MAKE_FLAG(END, L"end of table")
};



//
// IPM specific debug flags
//

FLAG_ENTRY FlagTableIpm[] =
{
    MAKE_FLAG(IPM, L"everything except refcounting"),
    MAKE_FLAG(REFERENCE, L"refcounting for most IPM classes"),

    MAKE_FLAG(END, L"end of table")
};


//
// Worker process specific debug flags
//

FLAG_ENTRY FlagTableWp[] =
{
    MAKE_FLAG(NREQ, L"UL_NATIVE_REQUEST state machine, etc."),
    MAKE_FLAG(WPIPM, L"worker specific IPM (wpipm & ipm_io_c)"),
    MAKE_FLAG(TRACE, L"junk from all over"),

    MAKE_FLAG(END, L"end of table")
};



//
// common functions
//

VOID
Usage(
    VOID
    );

DWORD
ReadFlagsFromRegistry(
    IN  PWSTR   pKeyName,
    OUT PULONG  pFlags
    );


PCOMMAND_ENTRY
FindCommandByName(
    IN PWSTR pCommand
    );

ULONG
FindFlagByName(
    IN PWSTR pFlagName,
    IN PFLAG_ENTRY pTable
    );


VOID
DumpFlags(
    IN PWSTR       pCommandName,
    
    PFLAG_ENTRY pFlagTable    
    );

//
// commands
//

INT
DoIisDebugFlags(
    IN INT argc,
    IN PWSTR argv[],
    IN HKEY key, 
    IN PVOID pTable
    );

INT
DoXspDebugFlags(
    IN INT argc,
    IN PWSTR argv[],
    IN HKEY key,
    IN PVOID pTable
    );

#define IIS_USAGE \
            L" [hexflags] [flagname1 flagname2 ...]"


COMMAND_ENTRY CommandTable[] =
    {
        {
            L"was",
            L"dtflags was" IIS_USAGE,
            REGISTRY_WAS_PARAM,
            FlagTableWas,
            &DoIisDebugFlags
        },

        {
            L"wp",
            L"dtflags wp" IIS_USAGE,
            REGISTRY_WP_PARAM,
            FlagTableWp,
            &DoIisDebugFlags
        },

        {
            L"ipm",
            L"dtflags ipm" IIS_USAGE,
            REGISTRY_IPM_PARAM,
            FlagTableIpm,
            &DoIisDebugFlags
        },

        {
            L"xsp",
            L"dtflags xsp [flagname flagvalue]",
            REGISTRY_XSP_PARAM,
            NULL,
            &DoXspDebugFlags
        }
    };

#define NUM_COMMAND_ENTRIES (sizeof(CommandTable) / sizeof(CommandTable[0]))


VOID
DumpIisFlags(
    IN DWORD flags,
    IN PFLAG_ENTRY pTable
    )
{
    PFLAG_ENTRY pEntry;

    pEntry = pTable;
    while (pEntry->Value) {
        wprintf(
            L"%-20s",
            pEntry->pName
            );

        if (flags & pEntry->Value) {
            wprintf(L"[on]    ");
        } else {
            wprintf(L"        ");
        }
        wprintf(L"%s\n", pEntry->pDisplayFormat);

        pEntry++;
    }
    wprintf(L"\n");
}


INT
DoIisDebugFlags(
    IN INT   argc,
    IN PWSTR argv[],
    IN HKEY  key,
    IN PVOID pTable
    )
{
    DWORD flags;
    DWORD err;
    DWORD length;
    LONG i;

    //
    // set new flags
    //
    flags = 0;

    if (argc > 1) {
        for (i = 1; i < argc; i++) {
            flags |= FindFlagByName(argv[i], FlagTable);
            flags |= FindFlagByName(argv[i], pTable);
        }

        err = RegSetValueEx(
                    key,
                    REGISTRY_DEBUG_FLAGS,
                    0,
                    REG_DWORD,
                    (LPBYTE)&flags,
                    sizeof(flags)
                    );
    
        if (err != NO_ERROR) {
            wprintf(L"Error %d writing flags to registry\n", err);
        }
    }

    //
    // Read flags from registry
    //
    flags = 0;
    err = RegQueryValueEx(
                key,                    // key
                REGISTRY_DEBUG_FLAGS,   // name
                NULL,                   // reserved
                NULL,                   // type
                (LPBYTE) &flags,        // value
                &length                 // value length
                );

    if (err != NO_ERROR) {
        wprintf(L"Error %d reading debug flags from registry\n", err);
    }

    //
    // Dump them out
    //
    wprintf(L"%s: %s = 0x%x\n\n", argv[0], REGISTRY_DEBUG_FLAGS, flags);
    DumpIisFlags(flags, FlagTable);
    DumpIisFlags(flags, pTable);
    
    
    return err;
}


PWSTR
XspFlagToString(
    DWORD flag
    )
{
    switch(flag) {
    case 0:
        return L"Disabled";
        break;

    case 1:
        return L"Print";
        break;

    case 2:
        return L"Print and Break";
        break;

    default:
        return L"INVALID";
        break;
    }
}

INT
DumpXspDebugFlags(
    IN HKEY  key
    )
{
    DWORD err;
    DWORD i;
    WCHAR name[MAX_PATH];
    DWORD nameLen;
    DWORD value;
    DWORD valueLen;

    i = 0;
    err = NO_ERROR;

    while (err == NO_ERROR) {
        nameLen = sizeof(name);
        valueLen = sizeof(value);

        err = RegEnumValue(
                    key,            // key
                    i,              // index
                    name,           // name of entry
                    &nameLen,       // length of name buffer
                    NULL,           // reserved
                    NULL,           // type
                    (LPBYTE)&value, // value buffer
                    &valueLen       // length of value buffer
                    );

        if (err == NO_ERROR) {
            wprintf(
                L"%-20s %d - %s\n",
                name,
                value,
                XspFlagToString(value)
                );
        }

        i++;
    }

    if (err != ERROR_NO_MORE_ITEMS) {
        wprintf(L"Error %d enumerating XSP flags\n", err);
    }

    return err;
}

INT
DoXspDebugFlags(
    IN INT argc,
    IN PWSTR argv[],
    IN HKEY  key,
    IN PVOID pTable
    )
{
    DWORD err;

    //
    // set a flag if specified
    //
    if (argc == 3) {
        LONG value;

        value = wcstol(argv[2], NULL, 0);
        if ((value >= 0) || (value <= 2)) {
            err = RegSetValueEx(
                        key,
                        argv[1],
                        0,
                        REG_DWORD,
                        (LPBYTE) &value,
                        sizeof(value)
                        );

            if (err != NO_ERROR) {
                wprintf(L"Error %d writing to registry\n");
            }
        } else {
            wprintf(L"Valid range is 0 to 2\n");
        }
        
    } else if (argc != 1) {
        wprintf(L"You must specify exactly one name value pair\n");
    }

    //
    // dump flags
    //

    err = DumpXspDebugFlags(key);

    return err;
}



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    PCOMMAND_ENTRY pEntry;
    INT result;
    HKEY key;
    ULONG err;
    WCHAR emptyString = 0;

    //
    // Find the command handler.
    //

    if (argc == 1)
    {
        pEntry = NULL;
    }
    else
    {
        pEntry = FindCommandByName( argv[1] );
    }

    if (pEntry == NULL)
    {
        Usage();
        result = 1;
        goto cleanup;
    }

    //
    // Try open the relevant registry key
    //
    err = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,     // key
                pEntry->pRegistryName,  // subkey
                0,                      // reserved
                &emptyString,           // class
                0,                      // options
                KEY_ALL_ACCESS,         // access
                NULL,                   // security attrib
                &key,                   // result key
                NULL                    // disposition info
                );

    if (err != NO_ERROR)
    {
        wprintf(
            L"dtflags: cannot open registry, error %ld\n",
            err
            );
        result = 1;
        goto cleanup;
    }

    //
    // Call the handler.
    //

    argc--;
    argv++;

    result = (pEntry->pCommandHandler)(
                 argc,
                 argv,
                 key,
                 pEntry->pTable
                 );

    RegCloseKey( key );

cleanup:

    return result;

}   // main


PCOMMAND_ENTRY
FindCommandByName(
    IN PWSTR pCommand
    )
{
    PCOMMAND_ENTRY pEntry;
    INT i;

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
     {
        if (_wcsicmp( pCommand, pEntry->pCommandName ) == 0)
        {
            return pEntry;
        }
    }

    return NULL;

}   // FindCommandByName





ULONG
FindFlagByName(
    IN PWSTR pFlagName,
    IN PFLAG_ENTRY pTable
    )
{
    INT len;
    ULONG flags;
    PFLAG_ENTRY pEntry;

    len = wcslen(pFlagName);
    if ((len > 2) && (wcsncmp(pFlagName, L"0x", 2) == 0)) {
        // numeric flag
        flags = wcstol(pFlagName, NULL, 16);
    } else {
        // named flag
        flags = 0;

        pEntry = pTable;
        while (pEntry->Value) {
            if (_wcsicmp(pFlagName, pEntry->pName) == 0) {
                flags = pEntry->Value;
                break;
            }

            pEntry++;
        }
    }
        
    return flags;
}


VOID
Usage(
    VOID
    )
{
    PCOMMAND_ENTRY pEntry;
    INT i;
    INT maxLength;
    INT len;

    //
    // Scan the command table, searching for the longest command name.
    // (This makes the output much prettier...)
    //

    maxLength = 0;

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        len = wcslen( pEntry->pCommandName );

        if (len > maxLength)
        {
            maxLength = len;
        }
    }

    //
    // Now display the usage information.
    //

    wprintf(
        L"use: dtflags action [options]\n"
        L"\n"
        L"valid actions are:\n"
        L"\n"
        );

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        wprintf(
            L"    %-*s - %s\n",
            maxLength,
            pEntry->pCommandName,
            pEntry->pUsageHelp
            );
    }

}   // Usage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\guids.cxx ===
#include "precomp.hxx"

#include <logobj.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\logtest.cxx ===
#include "precomp.hxx"
#include <stdio.h>

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

HRESULT
BigTest(
    _Log * pLog
    )
{
    HRESULT hr;
    VARIANT testcase,testtype;

    testcase.vt = VT_I4;
    testcase.lVal  = 0;

    testtype.vt = VT_I4;
    testtype.lVal  = 0;

    hr = pLog->StartTest(CComBSTR(L"BigTest"), testcase, testtype);
    if (SUCCEEDED(hr)) {
        hr = pLog->Comment(CComBSTR(L"Big comment"));
        if (FAILED(hr)) goto endtest;

        hr = pLog->Pass(CComBSTR(L"Big pass"));
        if (FAILED(hr)) goto endtest;

        hr = pLog->Fail(CComBSTR(L"Big failure"));
        if (FAILED(hr)) goto endtest;

endtest:
        pLog->EndTest();
    }

    return hr;
}



HRESULT
DoTests(
    _Log *pLog
    )
{
    HRESULT hr;
    VARIANT testcase,testtype;

    testcase.vt = VT_I4;
    testcase.lVal  = 0;

    testtype.vt = VT_I4;
    testtype.lVal  = 0;

    hr = pLog->StartTest(CComBSTR(L"LogTest 1"), testcase, testtype);
    if (SUCCEEDED(hr)) {
        hr = pLog->Pass(CComBSTR(L"test 1 passed"));
        pLog->EndTest();

        hr = BigTest(pLog);
    }

    return hr;
}


HRESULT
DoLogStuff(
    _Log * pLog
    )
{
    HRESULT hr;

    hr = pLog->Init(CComBSTR(L"logtest.txt"), TRUE);
    if (SUCCEEDED(hr)) {
        hr = pLog->StartRun(CComBSTR(L"C++ logtest run"));

        if (SUCCEEDED(hr)) {
            hr = DoTests(pLog);

            pLog->EndRun();
        }

    }

    return hr;
}

extern "C" INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    HRESULT      hr;
    _Connector * pConnector = NULL;
    _Log       * pLog       = NULL;

    printf("logobj test\n");

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr)) {
        printf("initialized COM\n");

        hr = CoCreateInstance(
                    CLSID_Connector,
                    NULL,
                    CLSCTX_SERVER,
                    IID__Connector,
                    (PVOID *) &pConnector
                    );

        if (SUCCEEDED(hr)) {
            printf("Created Connector object\n");

            hr = pConnector->get_LogObj(&pLog);
            if (SUCCEEDED(hr)) {
                printf("got Log object\n");

                hr = DoLogStuff(pLog);
                if (FAILED(hr)) {
                    printf("Failed to DoLogStuff! %x\n", hr);
                }

                pLog->Release();
            } else {
                printf("Failed to get_LogObj %x\n", hr);
            }

            pConnector->Release();
        } else {
            printf("Failed to CoCreate connector %x\n", hr);
        }

        CoUninitialize();
    }

    return (0);
} // wmain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\dllmain.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Michael Courage      (MCourage)      08-Feb-1999

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

//
//  Configuration parameters registry key.
//
// BUGBUG: This seems like the wrong place, but where
// do we put common (to iiswp and was) stuff?
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszDtunitRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\DTUNIT";


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("dtunit");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszDtunitRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "DTUNIT::DllMain::DLL_PROCESS_ATTACH\n"));
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "DTUNIT::DllMain::DLL_PROCESS_DETACH\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\makefile.inc ===
$(O)\logtest.res: logtest.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\template\makefile.inc ===
$(O)\dtuTemplate.res: dtuTemplate.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\dtunit.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dtunit.cxx

Abstract:

    Implementation of unit test classes
    
Author:

    Michael Courage (MCourage)      19-Feb-1999
    
Revision History:

--*/


# include "precomp.hxx"
# include <dtunit.hxx>

#include <stringau.hxx>
#include <stdio.h>

TEST_CASE::TEST_CASE(
    VOID
    )
{
}
    
TEST_CASE::~TEST_CASE(
    VOID
    )
{
}

HRESULT
TEST_CASE::Run(
    TEST_RESULT * pTestResult
    )
{
    HRESULT hr = S_OK;

    m_pResult = pTestResult;

    pTestResult->StartTest(GetTestName());

    hr = Initialize();
    
    if (UT_SUCCEEDED(hr)) {
        hr = RunTest();
    }

    UT_CHECK_HR( Terminate() );

    pTestResult->EndTest();

    return hr;
}


HRESULT
TEST_CASE::AssertImplementation(
    IN BOOL   fCondition,
    IN CHAR * pszExpression,
    IN DWORD  dwLine,
    IN CHAR * pszFile
    )
{
    HRESULT        hr = S_OK;

    if (!fCondition) {
        TEST_FAILURE * pFailure;
        DWORD          cchFile;
        DWORD          cchExpression;
        STRAU          strFile(pszFile);
        STRAU          strExpression(pszExpression);
    
        pFailure = new TEST_FAILURE;
        if (pFailure) {
            hr = pFailure->SetFailure(
                        GetTestName(),
                        strFile.QueryStr(),
                        dwLine,
                        strExpression.QueryStr()
                        );

            if (SUCCEEDED(hr)) {
                hr = m_pResult->AddFailure(pFailure);
            }
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return hr;
}


BOOL
TEST_CASE::ErrorImplementation(
    IN HRESULT hrError,
    IN DWORD   dwLine,
    IN CHAR *  pszFile
    )
{
    HRESULT hr = S_OK;

    if (FAILED(hrError)) {
        TEST_ERROR * pError;
        DWORD        cchFile;
        STRAU        strFile(pszFile);
    
        pError = new TEST_ERROR;
        if (pError) {
            hr = pError->SetError(
                        GetTestName(),
                        strFile.QueryStr(),
                        dwLine,
                        hrError
                        );

            if (SUCCEEDED(hr)) {
                hr = m_pResult->AddError(pError);
            }
        }
    }

    return SUCCEEDED(hrError);
}


TEST_RESULT::TEST_RESULT(
    VOID
    )
{
}


TEST_RESULT::~TEST_RESULT(
    VOID
    )
{
}



TEST_EXCEPTION::TEST_EXCEPTION(
    VOID
    )
{
    m_dwLineNumber   = 0;
    m_achFileName[0] = L'\0';
    m_achTestName[0] = L'\0';
}

TEST_EXCEPTION::~TEST_EXCEPTION(
    VOID
    )
{
}


HRESULT
TEST_EXCEPTION::SetException(
    IN LPCWSTR pszTestName,
    IN LPCWSTR pszFileName,
    IN DWORD   dwLineNumber
    )
{
    wcscpy(m_achFileName, pszFileName);
    wcscpy(m_achTestName, pszTestName);
    m_dwLineNumber = dwLineNumber;

    return S_OK;
}


TEST_FAILURE::TEST_FAILURE(
    VOID
    )
{
    m_achExceptionString[0] = L'\0';
}

TEST_FAILURE::~TEST_FAILURE(
    VOID
    )
{
    m_achExceptionString[0] = L'\0';
}

HRESULT
TEST_FAILURE::SetFailure(
    IN LPCWSTR pszTestName,
    IN LPCWSTR pszFileName,
    IN DWORD   dwLineNumber,
    IN LPCWSTR pszExpression
    )
{
    HRESULT hr               = S_OK;
    PCWSTR  pszShortFileName = wcsrchr(pszFileName, L'\\');

    if (!pszShortFileName) {
        pszShortFileName = pszFileName;
    }

    hr = SetException(
                pszTestName,
                pszFileName,
                dwLineNumber
                );

    if (SUCCEEDED(hr)) {
        wsprintf(
            m_achExceptionString,
            L"FAILURE: %s UT_ASSERT(%s) [%d : %s]",
            pszTestName,
            pszExpression,
            dwLineNumber,
            pszShortFileName
            );
        
    }

    return hr;
}


TEST_ERROR::TEST_ERROR(
    VOID
    )
{
    m_achExceptionString[0] = L'\0';
}

TEST_ERROR::~TEST_ERROR(
    VOID
    )
{
    m_achExceptionString[0] = L'\0';
}

HRESULT
TEST_ERROR::SetError(
    IN LPCWSTR pszTestName,
    IN LPCWSTR pszFileName,
    IN DWORD   dwLineNumber,
    IN HRESULT hrError
    )
{
    HRESULT hr               = S_OK;
    PCWSTR  pszShortFileName = wcsrchr(pszFileName, L'\\');

    if (!pszShortFileName) {
        pszShortFileName = pszFileName;
    }

    hr = SetException(
                pszTestName,
                pszFileName,
                dwLineNumber
                );
    m_hr = hrError;

    if (SUCCEEDED(hr)) {
        wsprintf(
            m_achExceptionString,
            L"ERROR: %s HRESULT(%x) [%d : %s]",
            pszTestName,
            hrError,
            dwLineNumber,
            pszShortFileName
            );
        
    }

    return hr;
}




UNIT_TEST::UNIT_TEST(
    VOID
    )
{
    m_pResult = NULL;
}

UNIT_TEST::~UNIT_TEST(
    VOID
    )
{
    delete m_pResult;
}


HRESULT
UNIT_TEST::Initialize(
    IN INT   argc,
    IN PWSTR argv[]
    )
{
    HRESULT hr           = S_OK;
    BOOL    fStandAlone;
    PWSTR   pszRunName   = argv[0];
    PWSTR   pszLogFile;

    //
    // allocate appropriate test result object
    //
    if (argc == 1) {
        //
        // no arguments means send errors to standard out
        //
        fStandAlone = TRUE;
        pszLogFile  = NULL;
    
        m_pResult = new TEST_RESULT_STDOUT;

        if (!m_pResult) {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else if (argc == 2) {
        //
        // send errors to log object
        //

        if (_wcsicmp(L"bvt", argv[1]) == 0) {
            //
            // we're part of a larger bvt
            //
            fStandAlone = FALSE;
            pszLogFile  = NULL;
        } else {
            //
            // running standalone
            //
            fStandAlone = TRUE;
            pszLogFile  = argv[1];
        }

        m_pResult = new TEST_RESULT_LOGOBJ;
        if (!m_pResult) {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // start the run
    //
    if (SUCCEEDED(hr)) {
        hr = m_pResult->StartRun(fStandAlone, pszRunName, pszLogFile);

        if (FAILED(hr)) {
            delete m_pResult;
            m_pResult = NULL;
        }
    }

    //
    // init the test suite member
    //
    if (SUCCEEDED(hr)) {
        hr = m_TestSuite.Initialize();

        if (FAILED(hr)) {
            delete m_pResult;
            m_pResult = NULL;
        }
    }

    return hr;
}


VOID
UNIT_TEST::Terminate(
    VOID
    )
{
    if (m_pResult) {
        m_pResult->EndRun();
        m_TestSuite.Terminate();
    }
}


HRESULT
UNIT_TEST::AddTest(
    TEST * pTest
    )
{
    return m_TestSuite.AddTest(pTest);
}

HRESULT
UNIT_TEST::Run(
    VOID
    )
{
    return m_TestSuite.Run(m_pResult);
}



HRESULT
TEST_RESULT_LOGOBJ::StartRun(
    IN BOOL fStandAlone,
    IN PCWSTR pszRunName,
    IN PCWSTR pszLogName
    )
{
    HRESULT hr;

    m_fStandAlone = fStandAlone;

    hr = GetLogObject();

    if (SUCCEEDED(hr)) {
        if (m_fStandAlone) {
            hr = InitLogObject(pszRunName, pszLogName);
        }
    }

    return hr;
}


HRESULT
TEST_RESULT_LOGOBJ::EndRun(
    VOID
    )
{
    HRESULT hr = S_OK;

    if (m_fStandAlone) {
        hr = m_pLogObj->EndRun();
    }

    m_pLogObj->Release();
    m_pLogObj = NULL;

    return hr;
}


VOID
TEST_RESULT_LOGOBJ::StartTest(
    PCWSTR pTestName
    )
{
    VARIANT testcase, testtype;

    testcase.vt = VT_I4;
    testcase.lVal  = 0;

    testtype.vt = VT_I4;
    testtype.lVal  = 0;

    m_pLogObj->StartTest(CComBSTR(pTestName), testcase, testtype);
}
   

VOID
TEST_RESULT_LOGOBJ::EndTest(
    VOID
    )
{
    m_pLogObj->EndTest();
}


HRESULT
TEST_RESULT_LOGOBJ::AddError(
    IN TEST_ERROR * pError
    )
{
    return m_pLogObj->Fail(CComBSTR(pError->GetExceptionAsString()));
}
    

HRESULT
TEST_RESULT_LOGOBJ::AddFailure(
    IN TEST_FAILURE * pFailure
    )
{
    return m_pLogObj->Fail(CComBSTR(pFailure->GetExceptionAsString()));
}


HRESULT
TEST_RESULT_LOGOBJ::GetLogObject(
    VOID
    )
{
    HRESULT      hr;
    _Connector * pConnector;

    hr = CoCreateInstance(
                CLSID_Connector,
                NULL,
                CLSCTX_SERVER,
                IID__Connector,
                (PVOID *) &pConnector
                );      

    if (SUCCEEDED(hr)) {
        hr = pConnector->get_LogObj(&m_pLogObj);
        if (FAILED(hr)) {
            m_pLogObj = NULL;
        }

        pConnector->Release();
    }

    return hr;
}

HRESULT
TEST_RESULT_LOGOBJ::InitLogObject(
    IN PCWSTR pszRunName,
    IN PCWSTR pszLogName
    )
{
    HRESULT hr;

    hr = m_pLogObj->Init(CComBSTR(pszLogName), TRUE);
    if (SUCCEEDED(hr)) {
        hr = m_pLogObj->StartRun(CComBSTR(pszRunName));
    }

    if (FAILED(hr)) {
        m_pLogObj->Release();
        m_pLogObj = NULL;
    }

    return hr;
}


//
// dtunit.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\ipm\dbgutil.h ===
/*++

Copyright (c) 1994-1999 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

#define DEBUG_IPM                   0x00010000
#define DEBUG_REFERENCE             0x00020000

// end_user_modifiable


// begin_user_modifiable

//
// Local debugging definitions
//

//
// traceing
//
#if DBG

#define IpmTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define IpmTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\ipm\dllmain.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Michael Courage      (MCourage)      08-Feb-1999

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

//
//  Configuration parameters registry key.
//
// BUGBUG: This seems like the wrong place, but where
// do we put common (to iiswp and was) stuff?
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIpmRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IPM";


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("ipm");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIpmRegLocation, DEBUG_ERROR );

        IpmTrace(INIT_CLEAN, (
                    DBG_CONTEXT,
                    "IPM::DllMain::DLL_PROCESS_ATTACH, g_dwDebugFlags = %08x\n",
                    g_dwDebugFlags
                    ));
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IpmTrace(INIT_CLEAN, (
                        DBG_CONTEXT,
                        "IPM::DllMain::DLL_PROCESS_DETACH\n"
                        ));

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\dtunit\template\dtutemplate.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     dtuTemplate.cxx

   Abstract:
     Main module for the unit test
 
   Author:

       Michael Courage  (MCourage)  29-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"

# include <stdio.h>
# include "dtuTemplate.hxx"

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();


//
// modify this function to create and add your tests
//
HRESULT
AddTests(
    IN UNIT_TEST * pUnit
    )
{
    HRESULT  hr;

    hr = pUnit->AddTest(new FOO_TEST);
    if (FAILED(hr)) goto exit;
        
    hr = pUnit->AddTest(new BAR_TEST);
    if (FAILED(hr)) goto exit;

exit:
    return hr;
}


//
// this is a nice place to define your test methods
//


//
// leave this function alone. thanks
//
extern "C" INT
__cdecl
wmain(
    INT   argc,
    PWSTR argv[]
    )
{
    HRESULT   hr;
    UNIT_TEST test;
    BOOL      fUseLogObj;
    PWSTR     pszLogFile;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr)) {
        hr = test.Initialize(argc, argv);
        if (SUCCEEDED(hr)) {
    
            hr = AddTests(&test);
            if (SUCCEEDED(hr)) {
                hr = test.Run();
            }
    
            test.Terminate();
        }

        CoUninitialize();
    }
    
    if (FAILED(hr)) {
        wprintf(L"Warning: test program failed with error %x\n", hr);
    }

    return (0);
} // wmain()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\ipm\dtumessage.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     strtest.cxx

   Abstract:
     Main module for the string test
 
   Author:

       Murali R. Krishnan    ( MuraliK )     23-Sept-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include "dtuMessage.hxx"

# include <stdio.h>

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();


//
// modify this function to create and add your tests
//
HRESULT
AddTests(
    IN UNIT_TEST * pUnit
    )
{
    HRESULT  hr;

    hr = pUnit->AddTest(new IPM_MESSAGE_TEST);
    if (FAILED(hr)) goto exit;

    hr = pUnit->AddTest(new IPM_PIPE_FACTORY_TEST);
    if (FAILED(hr)) goto exit;

    hr = pUnit->AddTest(new IPM_PIPE_TEST);
    if (FAILED(hr)) goto exit;

exit:
    return hr;
}


HRESULT
IPM_PIPE_FACTORY_TEST::Initialize(
    VOID
    )
{
    HRESULT hr = S_OK;

    m_pFactory = new IPM_PIPE_FACTORY(&m_IoFactory);
    if (m_pFactory) {
        hr = m_pFactory->Initialize();
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hr;
}


HRESULT
IPM_PIPE_FACTORY_TEST::Terminate(
    VOID
    )
{
    HRESULT hr = S_OK;

    hr = m_pFactory->Terminate();
    // factory deletes itself
    
    return hr;
}



HRESULT
IPM_PIPE_FACTORY_TEST::RunTest(
    VOID
    )
{
    HRESULT            hr;
    IPM_MESSAGE_PIPE * pPipe = NULL;

    hr = m_pFactory->CreatePipe(
                this,
                &pPipe
                );

    if (UT_SUCCEEDED(hr)) {
        UT_ASSERT(pPipe != NULL);

        // closing pipe should result in its destruction
        hr = pPipe->Disconnect(S_OK);
        UT_CHECK_HR( hr );
    }

    return hr;
}


HRESULT
IPM_MESSAGE_TEST::RunTest(
    VOID
    )
{
    IPM_MESSAGE          msgSet;
    IPM_MESSAGE          msgParseFull;
    IPM_MESSAGE          msgParseHalf;
    IPM_MESSAGE_HEADER * pHeader;
    PBYTE                pbMsgBuffer;
    DWORD                cbMsgBuffer;

    //
    // set up a canned message
    //
    UT_CHECK_HR( msgSet.SetMessage(
                        IPM_TEST_OPCODE,
                        IPM_TEST_DATALEN,
                        (PBYTE) IPM_TEST_DATA
                        ) );

    UT_ASSERT( msgSet.Equals(&msgSet) );
    UT_ASSERT( msgSet.GetOpcode() == IPM_TEST_OPCODE );
    UT_ASSERT( msgSet.GetDataLen() == IPM_TEST_DATALEN );
    UT_ASSERT( 
        memcmp(msgSet.GetData(), IPM_TEST_DATA, IPM_TEST_DATALEN) == 0
        );

    //
    // Make the MESSAGE parse itself out of a buffer
    //
    pbMsgBuffer = msgParseFull.GetNextBufferPtr();
    cbMsgBuffer = msgParseFull.GetNextBufferSize();

    UT_ASSERT( pbMsgBuffer != NULL );
    UT_ASSERT( cbMsgBuffer >= sizeof(IPM_MESSAGE_HEADER) );

    pHeader = (IPM_MESSAGE_HEADER *) pbMsgBuffer;
    pHeader->dwOpcode = IPM_TEST_OPCODE;
    pHeader->cbData   = 0;

    if (UT_SUCCEEDED(
            msgParseFull.ParseFullMessage(sizeof(IPM_MESSAGE_HEADER))
            ) )
    {
        UT_ASSERT( msgParseFull.GetOpcode() == IPM_TEST_OPCODE );
        UT_ASSERT( msgParseFull.GetDataLen() == 0 );
        UT_ASSERT( msgParseFull.GetData() == NULL );
    }

    //
    // parse a bigger message
    //
    pbMsgBuffer = msgParseHalf.GetNextBufferPtr();
    cbMsgBuffer = msgParseHalf.GetNextBufferSize();

    UT_ASSERT( pbMsgBuffer != NULL );
    UT_ASSERT( cbMsgBuffer >= sizeof(IPM_MESSAGE_HEADER) );

    pHeader = (IPM_MESSAGE_HEADER *) pbMsgBuffer;
    pHeader->dwOpcode = IPM_TEST_OPCODE;
    pHeader->cbData   = IPM_TEST_DATALEN;

    if (UT_SUCCEEDED(
            msgParseHalf.ParseHalfMessage(sizeof(IPM_MESSAGE_HEADER))
            ) )
    {
        // see if buffer made more space
        UT_ASSERT( msgParseHalf.GetNextBufferSize() >= IPM_TEST_DATALEN );

        // copy in the rest
        memcpy(
            msgParseHalf.GetNextBufferPtr(),
            IPM_TEST_DATA,
            IPM_TEST_DATALEN
            );

        if (UT_SUCCEEDED(
                msgParseHalf.ParseFullMessage(IPM_TEST_DATALEN)
                ))
        {
            UT_ASSERT( msgParseHalf.Equals(&msgSet) );
        }
    }
    
    return S_OK;
}


HRESULT
IPM_PIPE_TEST::Initialize(
    VOID
    )
{
    HRESULT hr = S_OK;

    //
    // create a test message to send
    //
    hr = m_msgTestMessage.SetMessage(
                IPM_TEST_OPCODE,
                IPM_TEST_DATALEN,
                (PBYTE) IPM_TEST_DATA
                );

    //
    // and another
    //
    if (UT_SUCCEEDED(hr)) {
        hr = m_msgPing.SetMessage(
                    IPM_OP_PING,    // ping opcode
                    0,              // no data
                    NULL            // really, no data
                    );
    }
    
    //
    // init message pipe factory
    //
    m_pPipeFactory = new IPM_PIPE_FACTORY(&m_IoFactory);
    if (m_pPipeFactory) {
        if (UT_SUCCEEDED(hr)) {
            hr = m_pPipeFactory->Initialize();
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // create a message pipe
    //
    if (UT_SUCCEEDED(hr)) {
        hr = m_pPipeFactory->CreatePipe(this, &m_pPipe);
        if (UT_SUCCEEDED(hr)) {
            m_pPipe->SetPipeIoHandler(this);
        }
    }

    //
    // init read state
    //
    m_fReadOutstanding = FALSE;
    m_pReadIoContext   = NULL;
    m_pvReadContext    = NULL;
    m_pReadBuff        = NULL;
    m_cbReadBuff       = 0;

    //
    // connect the message pipe
    //
    if (UT_SUCCEEDED(hr)) {
        m_fConnected = FALSE;
        hr = m_pPipe->Connect();

        UT_CHECK_HR(hr);
        UT_ASSERT( m_fConnected );
        UT_ASSERT( m_fReadOutstanding );
    }

    return hr;
}

HRESULT
IPM_PIPE_TEST::Terminate(
    VOID
    )
{
    HRESULT hr;

    UT_CHECK_HR( m_pPipe->Disconnect(S_OK) );
    hr = m_pPipeFactory->Terminate();
    // factory should delete itself

    return hr;
}


HRESULT
IPM_PIPE_TEST::RunTest(
    VOID
    )
{
    HRESULT hr;

    hr = WriteTest();

    if (UT_SUCCEEDED(hr)) {
        hr = ReadTest();
    }

    return hr;
}


HRESULT
IPM_PIPE_TEST::PipeConnected(
    VOID
    )
{
    UT_ASSERT( !m_fConnected );
    m_fConnected = TRUE;

    return S_OK;
}


HRESULT
IPM_PIPE_TEST::WriteTest(
    VOID
    )
{
    HRESULT hr;

    //
    // remember what we're sending
    //
    m_pmsgExpected = &m_msgTestMessage;

    //
    // call WriteMessage. The pipe should call this class
    // back on its Write method. Write will check what it
    // gets against m_pmsgExpected.
    //
    hr = m_pPipe->WriteMessage(
        m_msgTestMessage.GetOpcode(),
        m_msgTestMessage.GetDataLen(),
        m_msgTestMessage.GetData()
        );
        

    return hr;
}

HRESULT
IPM_PIPE_TEST::Write(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN const BYTE * pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT            hr;
    IPM_MESSAGE_PIPE * pPipe;
    IPM_MESSAGE *      pMessage;

    // downcast incoming pointers
    pPipe    = (IPM_MESSAGE_PIPE *) pContext;
    pMessage = (IPM_MESSAGE *) pv;

    UT_ASSERT( pContext == m_pPipe );
    UT_ASSERT( pMessage->GetDataLen() == cbBuff - sizeof(IPM_MESSAGE_HEADER) );
    UT_ASSERT( pMessage->GetData() == pBuff + sizeof(IPM_MESSAGE_HEADER) );

    UT_ASSERT( pMessage->Equals(m_pmsgExpected) );

    return S_OK;
}


HRESULT
IPM_PIPE_TEST::ReadTest(
    VOID
    )
{
    HRESULT hr;

    UT_ASSERT( m_fReadOutstanding );
    UT_ASSERT( m_cbReadBuff >= sizeof(IPM_MESSAGE_HEADER) );

    //
    // fill in the message buffer
    //
    IPM_MESSAGE_HEADER * pHeader = (IPM_MESSAGE_HEADER *) m_pReadBuff;
    pHeader->dwOpcode = m_msgPing.GetOpcode();
    pHeader->cbData   = m_msgPing.GetDataLen();
    // note:there's no data in a ping message

    //
    // remember what message we're expecting to receive at
    // the listener end.
    //
    m_pmsgExpected = &m_msgPing;

    //
    // complete the outstanding read operation
    //   

    m_fReadOutstanding = FALSE;
    
    hr = m_pReadIoContext->NotifyReadCompletion(
                m_pvReadContext,
                sizeof(IPM_MESSAGE_HEADER),
                S_OK
                );
    

    UT_ASSERT( m_fReadOutstanding );
    
    return hr;
}



HRESULT
IPM_PIPE_TEST::Read(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN BYTE *       pBuff,
    IN DWORD        cbBuff
    )
{
    UT_ASSERT( !m_fReadOutstanding );
    UT_ASSERT( (IPM_MESSAGE_PIPE *) pContext == m_pPipe );

    m_fReadOutstanding = TRUE;

    m_pReadIoContext   = pContext;
    m_pvReadContext    = pv;
    m_pReadBuff        = pBuff;
    m_cbReadBuff       = cbBuff;

    return S_OK;
}


HRESULT
IPM_PIPE_TEST::AcceptMessage(
    IN const MESSAGE * pPipeMessage
    )
{
    IPM_MESSAGE * pMessage = (IPM_MESSAGE *) pPipeMessage;

    UT_ASSERT( m_pmsgExpected->Equals(pMessage) );

    return S_OK;
}


extern "C" INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    HRESULT   hr;
    UNIT_TEST test;
    BOOL      fUseLogObj;
    PWSTR     pszLogFile;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr)) {
        hr = test.Initialize(argc, argv);
        if (SUCCEEDED(hr)) {

            hr = AddTests(&test);
            if (SUCCEEDED(hr)) {
                hr = test.Run();
            }

            test.Terminate();
        }

        CoUninitialize();
    }

    if (FAILED(hr)) {
        wprintf(L"Warning: test program failed with error %x\n", hr);
    }

    return (0);
} // wmain()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\ipm\makefile.inc ===
$(O)\dtuMessage.res: dtuMessage.rc

$(O)\dtuState.res: dtuState.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\ipm\message.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     message.cxx

   Abstract:
     Message layer implementation

   Author:

       Michael Courage      (MCourage)      08-Feb-1999

   Project:

       Internet Server DLL

--*/



#include "precomp.hxx"

#include "message.hxx"
#include "shutdown.hxx"

//
// globals
//
REFMGR_TRACE g_MessagePipeTrace;


/***************************************************************************++

Routine Description:

    Constructor for IPM_MESSAGE.
    
Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
IPM_MESSAGE::IPM_MESSAGE(
    VOID
    )
{
    m_dwSignature = IPM_MESSAGE_SIGNATURE;
    m_fMessageSet = FALSE;
    m_cbReceived  = 0;
    m_pHeader     = NULL;
    m_pData       = NULL;
}


/***************************************************************************++

Routine Description:

    Destructor for IPM_MESSAGE.
    
Arguments:

    None.

Return Value:

    None.

--***************************************************************************/
IPM_MESSAGE::~IPM_MESSAGE(
    VOID
    )
{
    DBG_ASSERT( m_dwSignature == IPM_MESSAGE_SIGNATURE );
    m_dwSignature = IPM_MESSAGE_SIGNATURE_FREED;
}


/***************************************************************************++

Routine Description:

    A simple accessor.
    
Arguments:

    None.

Return Value:

    Opcode of this message.

--***************************************************************************/
DWORD
IPM_MESSAGE::GetOpcode(
    VOID
    ) const
{
    DBG_ASSERT( m_fMessageSet );
    DBG_ASSERT( m_pHeader );

    if (m_fMessageSet) {
        return m_pHeader->dwOpcode;
    } else {
        //
        // this is very bad, but we should do something
        //
        return -1;
    }
}


/***************************************************************************++

Routine Description:

    A simple accessor.
    
Arguments:

    None.

Return Value:

    Data in this message. May be NULL if there is no data.

--***************************************************************************/
const BYTE *
IPM_MESSAGE::GetData(
    VOID
    ) const
{
    DBG_ASSERT( m_fMessageSet );
    DBG_ASSERT( m_pHeader );

    return m_pData;
}


/***************************************************************************++

Routine Description:

    A simple accessor.
    
Arguments:

    None.

Return Value:

    Byte count of data in the message.

--***************************************************************************/
DWORD
IPM_MESSAGE::GetDataLen(
    VOID
    ) const
{
    DBG_ASSERT( m_fMessageSet );
    DBG_ASSERT( m_pHeader );

    if (m_fMessageSet) {
        return m_pHeader->cbData;
    } else {
        //
        // really bad, but have to do something
        //
        return 0;
    }
}


/***************************************************************************++

Routine Description:

    Sets the message that goes in this object.
    
Arguments:

    dwOpcode  - Opcode of the message
    cbDataLen - Length in bytes of the data
    pData     - pointer to the data. NULL iff cbDataLen is zero.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE::SetMessage(
    IN DWORD        dwOpcode,
    IN DWORD        cbDataLen,
    IN const BYTE * pData      OPTIONAL
    )
{
    HRESULT hr = S_OK;

    //
    // verify arguments
    //
    if ((cbDataLen && !pData) ||
            (!cbDataLen && pData)) {

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // make sure the buffer is big enough
    //
    if (SUCCEEDED(hr)) {
        DWORD cbBuffNeeded;
        
        cbBuffNeeded = cbDataLen + sizeof(IPM_MESSAGE_HEADER);

        if (m_Buff.QuerySize() < cbBuffNeeded) {
            //
            // try to make room
            //
            if (!m_Buff.Resize(cbBuffNeeded)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    //
    // construct the message
    //
    if (SUCCEEDED(hr)) {
        m_pHeader = (IPM_MESSAGE_HEADER *) m_Buff.QueryPtr();
        m_pHeader->dwOpcode = dwOpcode;
        m_pHeader->cbData   = cbDataLen;

        if (cbDataLen) {
            m_pData = (PBYTE) (m_pHeader + 1);
            memcpy(m_pData, pData, cbDataLen);
        }

        m_cbReceived  = sizeof(IPM_MESSAGE_HEADER) + cbDataLen;
        m_fMessageSet = TRUE;
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Returns a pointer to the current location in the message buffer.
    
Arguments:

    None.

Return Value:

    Pointer to location of buffer

--***************************************************************************/
PBYTE
IPM_MESSAGE::GetNextBufferPtr(
    VOID
    )
{
    return ((PBYTE) m_Buff.QueryPtr()) + m_cbReceived;
}


/***************************************************************************++

Routine Description:

    Returns the amount of space remaining in our buffer.
    
Arguments:

    None.

Return Value:

    DWORD space remaining in buffer

--***************************************************************************/
DWORD
IPM_MESSAGE::GetNextBufferSize(
    VOID
    )
{
    return m_Buff.QuerySize() - m_cbReceived;
}



/***************************************************************************++

Routine Description:

    Sets the message that goes in this object.

    The buffer contains a message received from a pipe. We parse it
    out here.
    
Arguments:

    cbTransferred - size of the I/O completion that filled the buffer.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE::ParseFullMessage(
    IN DWORD cbTransferred
    )
{
    DBG_ASSERT( cbTransferred <= m_Buff.QuerySize() );
    DBG_ASSERT( m_Buff.QuerySize() >= sizeof(IPM_MESSAGE_HEADER) );

    IPM_MESSAGE_HEADER * pHeader;
    PBYTE                pData;
    DWORD                cbTotalSize;
    HRESULT              hr = S_OK;

    pHeader = (IPM_MESSAGE_HEADER *) m_Buff.QueryPtr();
    if (pHeader->cbData) {
        pData = (PBYTE) (pHeader + 1);
    } else {
        pData = NULL;
    }

    cbTotalSize = sizeof(IPM_MESSAGE_HEADER) + pHeader->cbData;
    if (cbTotalSize == (cbTransferred + m_cbReceived)) {
        m_pHeader     = pHeader;
        m_pData       = pData;
        m_cbReceived  = cbTotalSize;
        m_fMessageSet = TRUE;
    } else {
        //
        // sizes don't add up. That's a bad thing.
        //
        // CODEWORK: What's a good error code for this?
        //
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
        
    return hr;   
}


/***************************************************************************++

Routine Description:

    Sets the message that goes in this object.

    The buffer contains a message received from a pipe. We parse it
    out here.

    This method gets called when only part of a message has been
    received (due to lack of buffer space). It figures out how much
    space is needed, allocates the required buffer, and returns
    the size of the next read in an out parameter.
    
Arguments:

    cbTransferred - size of the I/O completion that filled the buffer.
    pcbRequired   - receives the number of bytes remaining in the message
                        only gets set on successful buffer allocation
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE::ParseHalfMessage(
    IN  DWORD   cbTransferred
    )
{
    DBG_ASSERT( cbTransferred <= m_Buff.QuerySize() );
    DBG_ASSERT( m_Buff.QuerySize() >= sizeof(IPM_MESSAGE_HEADER) );

    IPM_MESSAGE_HEADER * pHeader;
    PBYTE                pData;
    DWORD                cbTotalSize;
    HRESULT              hr = S_OK;

    //
    // figure out how big the required buffer is
    //
    pHeader = (IPM_MESSAGE_HEADER *) m_Buff.QueryPtr();
    if (pHeader->cbData) {
        pData = (PBYTE) (pHeader + 1);
    } else {
        pData = NULL;
    }

    cbTotalSize = sizeof(IPM_MESSAGE_HEADER) + pHeader->cbData;

    DBG_ASSERT( cbTotalSize > cbTransferred );

    //
    // remember where we are in the buffer.
    //
    m_cbReceived = cbTransferred;

    //
    // resize so we'll have enough space next time
    //
    if (!m_Buff.Resize(cbTotalSize)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
        
    return hr;   
}


/***************************************************************************++

Routine Description:

    Checks to see if this message is the same as another message.
    
Arguments:

    pMessage - the message to compare
    
Return Value:

    BOOL - true if the messages are identical

--***************************************************************************/
BOOL
IPM_MESSAGE::Equals(
    const IPM_MESSAGE * pMessage
    )
{
    if ((pMessage->GetOpcode() == GetOpcode()) &&
            (pMessage->GetDataLen() == GetDataLen()) &&
            (memcmp(pMessage->GetData(), GetData(), GetDataLen()) == 0))
    {
        return TRUE;
    } else {
        return FALSE;
    }
}


/***************************************************************************++

Routine Description:

    Constructor for IPM_MESSAGE_PIPE
    
Arguments:

    pListener - pointer to object that receives IPM_MESSAGEs.

Return Value:

    None.

--***************************************************************************/
IPM_MESSAGE_PIPE::IPM_MESSAGE_PIPE(
    IN IPM_PIPE_FACTORY * pFactory,
    IN MESSAGE_LISTENER * pListener
    )
{
    m_dwSignature = IPM_MESSAGE_PIPE_SIGNATURE;
    m_pFactory    = pFactory;
    m_pIoHandler  = NULL;
    m_dwId        = 0;
    m_dwRemotePid = 0;
    m_pListener   = pListener;
}

/***************************************************************************++

Routine Description:

    Destructor for IPM_MESSAGE_PIPE
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
IPM_MESSAGE_PIPE::~IPM_MESSAGE_PIPE(
    VOID
    )
{
    DBG_ASSERT( m_dwSignature == IPM_MESSAGE_PIPE_SIGNATURE );
    m_dwSignature = IPM_MESSAGE_PIPE_SIGNATURE_FREED;
}


/***************************************************************************++

Routine Description:

    Sends a message down the pipe.
    
Arguments:

    dwOpcode  - opcode of the message
    cbDataLen - length of pData buffer
    pData     - message data. may be NULL iff cbDataLen is zero
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::WriteMessage(
        IN DWORD        dwOpcode,
        IN DWORD        cbDataLen,
        IN const BYTE * pData      OPTIONAL
    )
{
    HRESULT       hr;
    IPM_MESSAGE * pMessage;

    if (StartIo()) {
        //
        // trace
        //
        IpmTrace( IPM, (
            DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::WriteMessage(%d, %d, %p)\n"
            "    (%p)->m_pIoHandler == %p\n",
            dwOpcode,
            cbDataLen,
            pData,
            this,
            m_pIoHandler
            ));

        DBG_ASSERT( m_pIoHandler );

        //
        // make the message
        //
        pMessage = new IPM_MESSAGE;
        
        if (pMessage) {
            hr = pMessage->SetMessage(dwOpcode, cbDataLen, pData);

            if (SUCCEEDED(hr)) {
                //
                // send it
                //
                hr = m_pIoHandler->Write(
                            this,
                            pMessage,
                            pMessage->GetBufferPtr(),
                            pMessage->GetBufferSize()
                            );

            }
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // since we won't get a completion we must
        // say the i/o is over now
        //
        if (FAILED(hr)) {
            HandleErrorCompletion(pMessage, hr);
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_PIPE_NOT_CONNECTED);
    }

    return hr;
}




/***************************************************************************++

Routine Description:

    If hr indicates success, the contents of the buffer will be parsed.

    Calls the message pipe to notify it that the message completion
    has happened.
    
Arguments:

    cbTransferred - the number of bytes reported in the completion
    hr            - completion success code
    
Return Value:

    HRESULT
    
--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::NotifyReadCompletion(
    IN PVOID   pv,
    IN DWORD   cbTransferred,
    IN HRESULT hr
    )
{
    HRESULT       hrRetval = S_OK;
    IPM_MESSAGE * pMessage;

    DBG_ASSERT( pv );
    pMessage = (IPM_MESSAGE *) pv;

    if (SUCCEEDED(hr)) {
        //
        // parse message buffer
        //
        hrRetval = pMessage->ParseFullMessage(cbTransferred);

        if (SUCCEEDED(hrRetval)) {
            hrRetval = HandleReadCompletion(pMessage);
        } else {
            //
            // got something bogus. error out
            //
            HandleErrorCompletion(pMessage, hr);
        }
        
    } else if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // need to do another read to get entire message
        //
        DWORD cbRemaining;
        
        hrRetval = pMessage->ParseHalfMessage(cbTransferred);

        if (SUCCEEDED(hrRetval)) {
            hrRetval = HandleHalfReadCompletion(pMessage);
        } else {
            //
            // got something bogus. error out
            //
            HandleErrorCompletion(pMessage, hr);
        }
        
    } else {
        //
        // error
        //
        hrRetval = HandleErrorCompletion(pMessage, hr);
    }
        
    return hrRetval;
}


/***************************************************************************++

Routine Description:

    Calls the message pipe to notify it that the message completion
    has happened.
    
Arguments:

    cbTransferred - the number of bytes reported in the completion
    hr            - completion success code

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::NotifyWriteCompletion(
    IN PVOID   pv,
    IN DWORD   cbTransferred,
    IN HRESULT hr
    )
{
    HRESULT       hrRetval;
    IPM_MESSAGE * pMessage;

    DBG_ASSERT( pv );
    pMessage = (IPM_MESSAGE *) pv;

    if (SUCCEEDED(hr)) {
        hrRetval = HandleWriteCompletion(pMessage);
    } else {
        hrRetval = HandleErrorCompletion(pMessage, hr);
    }

    return hrRetval;
}


/***************************************************************************++

Routine Description:

    Forwards received message to the message listener.
    
Arguments:

    pMessage - the message
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::HandleReadCompletion(
    IN IPM_MESSAGE * pMessage
    )
{
    HRESULT hr = S_OK;
    
    //
    // Start the next read if appropriate
    //
    hr = ReadMessage();

    //
    // send the received message up to the listener.
    //
    if (StartCallback()) {
        hr = m_pListener->AcceptMessage(pMessage);
        EndCallback();
    }

    //
    // now that we've fully handled the i/o, tell the state manager
    //
    EndIo();

    //
    // always delete the message when we're done with it
    //
    delete pMessage;

    return hr;
}


/***************************************************************************++

Routine Description:

    Initiates a new read to get the rest of a partially
    received message.
    
Arguments:

    pMessage - the message
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::HandleHalfReadCompletion(
    IN IPM_MESSAGE * pMessage
    )
{
    HRESULT hr = S_OK;

    //
    // Start another read to get the rest of the message
    //
    hr = FinishReadMessage(pMessage);
    
    //
    // now that we've handled the i/o, tell the state manager
    //
    EndIo();

    return hr;
}


/***************************************************************************++

Routine Description:

    Deletes the unneeded message object.
    
Arguments:

    pMessage - the message
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::HandleWriteCompletion(
    IN IPM_MESSAGE * pMessage
    )
{
    EndIo();
    delete pMessage;
    return S_OK;
}


/***************************************************************************++

Routine Description:

    Deletes the unneeded message object. Changes the state of the
    pipe, and notifies the listener of the error.
    
Arguments:

    pMessage - the message
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::HandleErrorCompletion(
    IN IPM_MESSAGE * pMessage,
    IN HRESULT       hr
    )
{
    m_hrDisconnect = hr;

    //
    // since there was an error, tell the state manager we want
    // to shut down.
    //
    m_RefMgr.Shutdown();
    EndIo();

    delete pMessage;

    return S_OK;
}


/***************************************************************************++

Routine Description:

    Initializes the pipe.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::Initialize(
    VOID
    )
{
    HRESULT hr;

    hr = m_RefMgr.Initialize(this, &g_MessagePipeTrace);

    if (SUCCEEDED(hr)) {
        DBG_REQUIRE( AddListenerReference() );
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Notifies the listener that the pipe is ready for business.
    
    Also initiates the first read on the pipe.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::Connect(
    VOID
    )
{
    HRESULT hrRetval;

    hrRetval = m_pListener->PipeConnected();

    if (SUCCEEDED(hrRetval)) {
        //
        // start initial read
        //
        hrRetval = ReadMessage();
    }

    return hrRetval;
}

/***************************************************************************++

Routine Description:

    Disconnects from the MESSAGE_LISTENER if possible.

Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::Disconnect(
    HRESULT hr
    )
{
    m_hrDisconnect = hr;

    m_RefMgr.Shutdown();
    RemoveListenerReference();

    return S_OK;
}

/***************************************************************************++

Routine Description:

    Creates a new message object and reads it from the
    pipe.

Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::ReadMessage(
    VOID
    )
{
    HRESULT       hr = S_OK;
    IPM_MESSAGE * pMessage;

    if (StartIo()) {
        //
        // trace
        //
        IpmTrace( IPM, (
            DBG_CONTEXT,
            "IPM_MESSAGE_PIPE::ReadMessage()\n"
            "    (%p)->m_pIoHandler == %p\n",
            this,
            m_pIoHandler
            ));

        DBG_ASSERT( m_pIoHandler );

        //
        // make the message
        //
        pMessage = new IPM_MESSAGE;
        if (pMessage) {
            //
            // do the read
            //
            hr = m_pIoHandler->Read(
                        this,
                        pMessage,
                        pMessage->GetNextBufferPtr(),
                        pMessage->GetNextBufferSize()
                        );

        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (FAILED(hr)) {
            //
            // couldn't do our read. better bail out
            //
            HandleErrorCompletion(pMessage, hr);
        }
    }
    
    return hr;
}


/***************************************************************************++

Routine Description:

    Reads the remainder of a half read message.

Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_MESSAGE_PIPE::FinishReadMessage(
    IN IPM_MESSAGE * pMessage
    )
{
    HRESULT       hr = S_OK;

    if (StartIo()) {
        //
        // do the read
        //
        hr = m_pIoHandler->Read(
                    this,
                    pMessage,
                    pMessage->GetNextBufferPtr(),
                    pMessage->GetNextBufferSize()
                    );

        if (FAILED(hr)) {
            HandleErrorCompletion(pMessage, hr);
        }
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    When all callbacks are done, we notify the listener that
    the pipe is shutting down.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_MESSAGE_PIPE::InitialCleanup(
    VOID
    )
{
    //
    // tell the listener that the pipe has been disconnected
    //
    m_pListener->PipeDisconnected(m_hrDisconnect);
}


/***************************************************************************++

Routine Description:

    When all references are gone, we clean up the object.

Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_MESSAGE_PIPE::FinalCleanup(
    VOID
    )
{
    HRESULT hr;
    
    //
    // time to delete this object
    //
    hr = m_pFactory->DestroyPipe(this);
}


//
// handy state change methods
//
BOOL
IPM_MESSAGE_PIPE::StartIo()
{ return m_RefMgr.Reference(); }

VOID
IPM_MESSAGE_PIPE::EndIo()
{ m_RefMgr.Dereference(); }

BOOL
IPM_MESSAGE_PIPE::StartCallback()
{ return m_RefMgr.StartReference(); }

VOID
IPM_MESSAGE_PIPE::EndCallback()
{ m_RefMgr.FinishReference(); m_RefMgr.Dereference(); }

BOOL
IPM_MESSAGE_PIPE::AddListenerReference()
{ return m_RefMgr.Reference(); }

VOID
IPM_MESSAGE_PIPE::RemoveListenerReference()
{ m_RefMgr.Dereference(); }


/***************************************************************************++

Routine Description:

    Constructor for IPM_PIPE_FACTORY.
    
Arguments:

    pIoFactory - pointer to an object that constructs PIPE_IO_HANDLERs.
    
Return Value:

    None.

--***************************************************************************/
IPM_PIPE_FACTORY::IPM_PIPE_FACTORY(
    IN IO_FACTORY * pIoFactory
    )
{
    m_dwSignature = IPM_PIPE_FACTORY_SIGNATURE;
    m_pIoFactory  = pIoFactory;

    m_pIoFactory->Reference();

    g_MessagePipeTrace.Initialize();
}


/***************************************************************************++

Routine Description:

    Destructor for IPM_PIPE_FACTORY.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
IPM_PIPE_FACTORY::~IPM_PIPE_FACTORY(
    VOID
    )
{

    DBG_ASSERT( m_dwSignature == IPM_PIPE_FACTORY_SIGNATURE );

    g_MessagePipeTrace.Terminate();
    m_pIoFactory->Dereference();
    m_dwSignature = IPM_PIPE_FACTORY_SIGNATURE_FREED;
}


/***************************************************************************++

Routine Description:

    Initializes IPM_PIPE_FACTORY.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
HRESULT
IPM_PIPE_FACTORY::Initialize(
    VOID
    )
{
    IpmTrace(INIT_CLEAN, (
        DBG_CONTEXT,
        "\n    IPM_PIPE_FACTORY::Initialize (%x)\n",
        this
        ));
            
    return m_RefMgr.Initialize(this, &g_MessagePipeTrace);
}


/***************************************************************************++

Routine Description:

    Terminates IPM_PIPE_FACTORY. After this call when the
    pipe count reaches zero the factory will delete itself.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_FACTORY::Terminate(
    VOID
    )
{
    m_RefMgr.Shutdown();

    return S_OK;
}



/***************************************************************************++

Routine Description:

    Creates a message pipe attached to the given listener.
    
Arguments:

    pMessageListener - the listener to be connected to the pipe
    ppMessagePipe    - receives pointer to create pipe.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_FACTORY::CreatePipe(
    IN  MESSAGE_LISTENER *  pMessageListener,
    OUT IPM_MESSAGE_PIPE ** ppMessagePipe
    )
{
    HRESULT hr = S_OK;

    //
    // make sure its ok to make a pipe
    //
    if (CreatingMessagePipe()) {
        IPM_MESSAGE_PIPE * pPipe;

        pPipe = new IPM_MESSAGE_PIPE(this, pMessageListener);
        if (pPipe) {
            hr = pPipe->Initialize();

            if (SUCCEEDED(hr)) {
                *ppMessagePipe = pPipe;
            } else {
                delete pPipe;
            }
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        FinishCreatingMessagePipe();
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    if (SUCCEEDED(hr)) {
        IpmTrace(IPM, (
            DBG_CONTEXT,
            "IPM_PIPE_FACTORY::CreatePipe(listener = %p) created %p\n",
            pMessageListener,
            *ppMessagePipe
            ));
    } else {
        IpmTrace(IPM, (
            DBG_CONTEXT,
            "IPM_PIPE_FACTORY::CreatePipe(listener = %p) failed %x\n",
            pMessageListener,
            hr
            ));
    }        
    
    return hr;
}


/***************************************************************************++

Routine Description:

    Destroys a message pipe.

    If this was the last pipe and we're in shutdown, we'll
    delete the object.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_FACTORY::DestroyPipe(
    IN IPM_MESSAGE_PIPE * pMessagePipe
    )
{
    HRESULT hr = S_OK;

    DBG_ASSERT( !pMessagePipe->GetPipeIoHandler() );

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "IPM_PIPE_FACTORY::DestroyPipe(%p)\n",
        pMessagePipe
        ));

    delete pMessagePipe;

    DestroyedMessagePipe();

    return hr;
}


/***************************************************************************++

Routine Description:

    Constructor for MESSAGE_GLOBAL.
    
Arguments:

    pIoFactory - pointer to an object that constructs PIPE_IO_HANDLERs.
    
Return Value:

    None.

--***************************************************************************/
MESSAGE_GLOBAL::MESSAGE_GLOBAL(
    IN IO_FACTORY * pIoFactory
    )
{
    m_pConnector   = NULL;
    m_pPipeFactory = NULL;
    m_pIoFactory   = pIoFactory;
}


/***************************************************************************++

Routine Description:

    Destructor for MESSAGE_GLOBAL.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
MESSAGE_GLOBAL::~MESSAGE_GLOBAL(
    VOID
    )
{
}


/***************************************************************************++

Routine Description:

    Initializes MESSAGE_GLOBAL.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
HRESULT
MESSAGE_GLOBAL::InitializeMessageGlobal(
    VOID
    )
{
    HRESULT hr = S_OK;

    m_pPipeFactory = new IPM_PIPE_FACTORY(m_pIoFactory);
    m_pConnector = new IPM_PIPE_CONNECTOR(m_pIoFactory);
    
    if (!m_pPipeFactory || !m_pConnector) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (SUCCEEDED(hr)) {
        hr = m_pPipeFactory->Initialize();
        
        if (SUCCEEDED(hr)) {
            hr = m_pConnector->Initialize();

            if (FAILED(hr)) {
                m_pPipeFactory->Terminate();
            }
        }
    }

    if (FAILED(hr)) {
        delete m_pPipeFactory;
        delete m_pConnector;

        m_pPipeFactory = NULL;
        m_pConnector   = NULL;
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Terminates MESSAGE_GLOBAL. 
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGE_GLOBAL::TerminateMessageGlobal(
    VOID
    )
{
    HRESULT hr;
    HRESULT hrFactory;
    HRESULT hrConnector;

    hrFactory   = m_pPipeFactory->Terminate();
    hrConnector = m_pConnector->Terminate();

    if (SUCCEEDED(hrFactory)) {
        hr = hrConnector;
    } else {
        hr = hrFactory;
    }

    // connector deletes itself
    // factory deletes itself

    return hr;
}


/***************************************************************************++

Routine Description:

    Creates a message pipe attached to the given listener.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGE_GLOBAL::CreateMessagePipe(
    IN  MESSAGE_LISTENER *  pMessageListener,
    OUT MESSAGE_PIPE **     ppMessagePipe
    )
{
    HRESULT            hr;
    IPM_MESSAGE_PIPE * pPipe;

    hr = m_pPipeFactory->CreatePipe(
                pMessageListener,
                &pPipe
                );

    if (SUCCEEDED(hr)) {
        *ppMessagePipe = pPipe;
    }
    
    return hr;
}


/***************************************************************************++

Routine Description:

    Connects a message pipe.
    
Arguments:

    strPipeName  - name of the pipe
    pMessagePipe - the pipe to be connected
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGE_GLOBAL::ConnectMessagePipe(
    IN const STRU&    strPipeName,
    IN DWORD          dwId,
    IN MESSAGE_PIPE * pMessagePipe
    )
{
    HRESULT hr;

    hr = m_pConnector->ConnectMessagePipe(
                strPipeName,
                dwId,
                (IPM_MESSAGE_PIPE *) pMessagePipe
                );

    return hr;
}


/***************************************************************************++

Routine Description:

    Accepts a connection to another pipe that calls connect
    with the same id number.
    
Arguments:

    strPipeName  - name of the pipe
    pMessagePipe - the pipe to be connected
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGE_GLOBAL::AcceptMessagePipeConnection(
    IN const STRU&    strPipeName,
    IN DWORD          dwId,
    IN MESSAGE_PIPE * pMessagePipe
    )
{
    HRESULT hr;

    hr = m_pConnector->AcceptMessagePipeConnection(
                strPipeName,
                dwId,
                (IPM_MESSAGE_PIPE *) pMessagePipe
                );

    return hr;
}


/***************************************************************************++

Routine Description:

    Disconnects a pipe
    
Arguments:

    pMessagePipe - the pipe to be disconnected
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
MESSAGE_GLOBAL::DisconnectMessagePipe(
    IN MESSAGE_PIPE * pMessagePipe
    )
{
    HRESULT hr;

    hr = m_pConnector->DisconnectMessagePipe(
                (IPM_MESSAGE_PIPE *) pMessagePipe
                );

    return hr;
}


/***************************************************************************++

Routine Description:

    A stupid hack to work around the limitations of ReadFile and
    ReadFileEx. ReadFileEx can't deal with completion ports, and
    ReadFile does the error handling wrong.
    
Arguments:

    hFile       - the file handle
    pBuffer     - buffer that gets the bytes
    cbBuffer    - size of the buffer
    pOverlapped - overlapped i/o thingy
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IpmReadFile(
    HANDLE       hFile,
    PVOID        pBuffer,
    DWORD        cbBuffer,
    LPOVERLAPPED pOverlapped
    )
{
    NTSTATUS Status;

    pOverlapped->Internal = (DWORD)STATUS_PENDING;

    Status = NtReadFile(
                hFile,                                      // File handle
                NULL,                                       // Event
                NULL,                                       // ApcRoutine
                pOverlapped,                                // ApcContext
                (PIO_STATUS_BLOCK)&pOverlapped->Internal,   // io status
                pBuffer,                                    // output buffer
                cbBuffer,                                   // bytes 2 read
                NULL,                                       // file offset
                NULL                                        // key
                );

    if ( NT_ERROR(Status) ) {
        return HRESULT_FROM_NT( Status );
    }
    else {
        return S_OK;
    }
}


/***************************************************************************++

Routine Description:

    A stupid hack to work around the limitations of WriteFile and
    WriteFileEx. WriteFileEx can't deal with completion ports, and
    WriteFile does the error handling wrong.
    
Arguments:

    hFile       - the file handle
    pBuffer     - buffer that has the bytes
    cbBuffer    - # of bytes in the buffer
    pOverlapped - overlapped i/o thingy
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IpmWriteFile(
    HANDLE       hFile,
    PVOID        pBuffer,
    DWORD        cbBuffer,
    LPOVERLAPPED pOverlapped
    )
{
    NTSTATUS Status;

    pOverlapped->Internal = (DWORD)STATUS_PENDING;
        
    Status = NtWriteFile(
                hFile,                                      // File handle
                NULL,                                       // Event
                NULL,                                       // ApcRoutine
                pOverlapped,                                // ApcContext
                (PIO_STATUS_BLOCK)&pOverlapped->Internal,   // io status
                pBuffer,                                    // output buffer
                cbBuffer,                                   // bytes 2 write
                NULL,                                       // file offset
                NULL                                        // key
                );

    if ( NT_ERROR(Status) ) {
        return HRESULT_FROM_NT( Status );
    }
    else {
        return S_OK;
    }
}



//
// end message.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\ipm\dtustate.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dtuState.cxx

   Abstract:
     Main module for the STATE_MANAGER test
 
   Author:

       Murali R. Krishnan    ( MuraliK )     23-Sept-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include "dtuState.hxx"

# include <stdio.h>

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

//
// modify this function to create and add your tests
//
HRESULT
AddTests(
    IN UNIT_TEST * pUnit
    )
{
    HRESULT  hr;

    hr = pUnit->AddTest(new REFMGR_TEST);
    if (FAILED(hr)) goto exit;

    hr = pUnit->AddTest(new REFMGR3_TEST);
    if (FAILED(hr)) goto exit;

exit:
    return hr;
}

//
// this is a nice place to define your test methods
//

HRESULT
REFMGR_TEST::RunTest(
    VOID
    )
{
    HRESULT       hr = S_OK;

    //
    // no references
    //
    m_fDeleted = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );
        m_RefManager.Shutdown();
        UT_ASSERT( m_fDeleted );
    }

    //
    // do some references
    //
    m_fDeleted = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );

        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );

        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );

        m_RefManager.Shutdown();
        UT_ASSERT( m_fDeleted );
    }

    //
    // the whole deal
    //
    m_fDeleted = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );

        m_RefManager.Shutdown();
        UT_ASSERT( !m_fDeleted );

        UT_ASSERT( !m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        
        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );

        m_RefManager.Dereference();
        UT_ASSERT( m_fDeleted );
    }

    
    return hr;
}


HRESULT
REFMGR3_TEST::RunTest(
    VOID
    )
{
    HRESULT       hr = S_OK;

    //
    // no references
    //
    m_fDeleted = FALSE;
    m_fInitial = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );
        
        m_RefManager.Shutdown();
        UT_ASSERT( m_fDeleted );
        UT_ASSERT( m_fInitial );
    }

    //
    // do some references
    //
    m_fDeleted = FALSE;
    m_fInitial = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        m_RefManager.Shutdown();
        UT_ASSERT( m_fDeleted );
        UT_ASSERT( m_fInitial );
    }

    //
    // almost the whole deal
    //
    m_fDeleted = FALSE;
    m_fInitial = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        m_RefManager.Shutdown();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( m_fInitial );

        UT_ASSERT( !m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        
        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );

        m_RefManager.Dereference();
        UT_ASSERT( m_fDeleted );
    }

    //
    // a half reference
    //
    m_fDeleted = FALSE;
    m_fInitial = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );
        
        UT_ASSERT( m_RefManager.StartReference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );
        
        m_RefManager.Shutdown();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        m_RefManager.FinishReference();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( m_fInitial );

        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );
        
        m_RefManager.Dereference();
        UT_ASSERT( m_fDeleted );
    }

    //
    // a half reference, i/o completions before FinishReference
    //
    m_fDeleted = FALSE;
    m_fInitial = FALSE;
    if (UT_SUCCEEDED( m_RefManager.Initialize(this) )) {
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        UT_ASSERT( m_RefManager.Reference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );
        
        UT_ASSERT( m_RefManager.StartReference() );
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );
        
        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );
        
        m_RefManager.Dereference();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );
        
        m_RefManager.Shutdown();
        UT_ASSERT( !m_fDeleted );
        UT_ASSERT( !m_fInitial );

        m_RefManager.FinishReference();
        UT_ASSERT( m_fDeleted );
        UT_ASSERT( m_fInitial );

    }

    
    return hr;
}

extern "C" INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    HRESULT   hr;
    UNIT_TEST test;
    BOOL      fUseLogObj;
    PWSTR     pszLogFile;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr)) {
        hr = test.Initialize(argc, argv);
        if (SUCCEEDED(hr)) {

            hr = AddTests(&test);
            if (SUCCEEDED(hr)) {
                hr = test.Run();
            }

            test.Terminate();
        }

        CoUninitialize();
    }

    if (FAILED(hr)) {
        wprintf(L"Warning: test program failed with error %x\n", hr);
    }

    return (0);
} // wmain()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\ipm\pipeconn.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     pipeconn.cxx

   Abstract:
     IPM_PIPE_CONNECTOR implementation

   Author:

       Michael Courage      (MCourage)      10-Mar-1999

   Project:

       Internet Server DLL

--*/



#include "precomp.hxx"

#include "message.hxx"
#include "shutdown.hxx"
#include "secfcns.h"


REFMGR_TRACE g_PipeConnTrace;


/***************************************************************************++

Routine Description:

    Constructor for IPM_PIPE_CONNECTOR.
    
Arguments:

    pIoFactory - pointer to an object that constructs PIPE_IO_HANDLERs.
    
Return Value:

    None.

--***************************************************************************/
IPM_PIPE_CONNECTOR::IPM_PIPE_CONNECTOR(
    IN IO_FACTORY * pIoFactory
    )
{
    m_dwSignature = IPM_PIPE_CONNECTOR_SIGNATURE;

    m_pIoFactory  = pIoFactory;
    m_pIoFactory->Reference();

    InitializeListHead(&m_lhCreatedNamedPipes);
    InitializeListHead(&m_lhConnectedNamedPipes);
    InitializeListHead(&m_lhConnectedMessagePipes);

    m_cCreatedNamedPipes = 0;
    m_cConnectedNamedPipes = 0;
    m_cConnectedMessagePipes = 0;

    g_PipeConnTrace.Initialize();
}


/***************************************************************************++

Routine Description:

    Destructor for IPM_PIPE_CONNECTOR.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
IPM_PIPE_CONNECTOR::~IPM_PIPE_CONNECTOR(
    VOID
    )
{
    DBG_ASSERT( m_dwSignature == IPM_PIPE_CONNECTOR_SIGNATURE );
    DBG_ASSERT( IsListEmpty(&m_lhCreatedNamedPipes) );
    DBG_ASSERT( IsListEmpty(&m_lhConnectedNamedPipes) );
    DBG_ASSERT( IsListEmpty(&m_lhConnectedMessagePipes) );

    m_pIoFactory->Dereference();
    m_ListLock.Terminate();
    g_PipeConnTrace.Terminate();

    m_dwSignature = IPM_PIPE_CONNECTOR_SIGNATURE_FREED;
}


/***************************************************************************++

Routine Description:

    Initializes the IPM_PIPE_CONNECTOR.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::Initialize(
    VOID
    )
{
    HRESULT hr = S_OK;

    hr = m_ListLock.Initialize();
    if (SUCCEEDED(hr)) {
        hr = m_RefMgr.Initialize(this, &g_PipeConnTrace);

        if (SUCCEEDED(hr)) {
            hr = m_ConnectTable.Initialize();
        }
    }

    IpmTrace(INIT_CLEAN, (
        DBG_CONTEXT,
        "\n    IPM_CONNECTOR::Initialize (%x) hr = %x\n",
        this,
        hr
        ));

    return hr;
}


/***************************************************************************++

Routine Description:

    Begins shutdown of IPM_PIPE_CONNECTOR.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::Terminate(
    VOID
    )
{
    DbgPrintThis();
    
    m_RefMgr.Shutdown();

    return S_OK;
}


/***************************************************************************++

Routine Description:

    Connects a message pipe.
    
Arguments:

    strPipeName  - name of the pipe
    pMessagePipe - the pipe to be connected
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::ConnectMessagePipe(
    IN const STRU&        strPipeName,
    IN DWORD              dwId,
    IN IPM_MESSAGE_PIPE * pMessagePipe
    )
{
    HRESULT           hr = S_OK;
    PIPE_IO_HANDLER * pIoHandler;

    hr = AddNewSender(strPipeName, dwId);

    if (SUCCEEDED(hr)) {
        hr = AddUnboundMessagePipe(pMessagePipe, dwId);    
    }
    
    return hr;
}


/***************************************************************************++

Routine Description:

    Accepts a connection to another pipe that calls connect
    with the same id number.
    
Arguments:

    strPipeName  - name of the pipe
    dwId         - id of the pipe
    pMessagePipe - the pipe to be connected
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::AcceptMessagePipeConnection(
    IN const STRU&        strPipeName,
    IN DWORD              dwId,
    IN IPM_MESSAGE_PIPE * pMessagePipe
    )
{
    HRESULT                hr = S_OK;
    HANDLE                 hPipe;
    IPM_NAMED_PIPE_ENTRY * pNamedPipeEntry;
    PIPE_IO_HANDLER *      pIoHandler;

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\n    IPM_PIPE_CONNECTOR::AcceptMessagePipeConnection(id = %d, pipe = %p)\n",
        dwId,
        pMessagePipe
        ));

    //
    // add a new listener
    //
    m_ListLock.Lock();

    hr = AddNewListener(strPipeName, dwId);

    //
    // add the unbound message pipe
    //
    if (SUCCEEDED(hr)) {
        hr = AddUnboundMessagePipe(pMessagePipe, dwId);    
    } else {
        DPERROR((
            DBG_CONTEXT,
            hr,
            "IPM_PIPE_CONNECTOR::AddNewListener failed"
            ));
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Disconnects a pipe
    
Arguments:

    pMessagePipe - the pipe to be disconnected
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::DisconnectMessagePipe(
    IN IPM_MESSAGE_PIPE * pMessagePipe,
    IN HRESULT            hrDisconnect
    )
{
    HRESULT hr;
    BOOL    fBound;
    PIPE_IO_HANDLER * pIoHandler;

    // assume it's bound for now
    fBound = TRUE; 

    m_ListLock.Lock();

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\n    IPM_PIPE_CONNECTOR::DisconnectMessagePipe(%x, %x) %x %x\n",
        pMessagePipe,
        hrDisconnect,
        pMessagePipe->GetPipeIoHandler(),
        pMessagePipe->GetId()
        ));

    pIoHandler = pMessagePipe->GetPipeIoHandler();

    if (pIoHandler) {
        //
        // Disconnect a connected message pipe
        //
    
        RemoveListConnectedMessagePipe(pMessagePipe);
        pMessagePipe->SetPipeIoHandler(NULL);

        hr = pMessagePipe->Disconnect(hrDisconnect);
        DBG_ASSERT( SUCCEEDED(hr) );

        hr = pIoHandler->Disconnect();
        m_pIoFactory->ClosePipeIoHandler(pIoHandler);

    } else if (pMessagePipe->GetId()) {
        //
        // Cancel the binding for a bound message pipe
        //

        IPM_MESSAGE_PIPE * pPipeCancelled;
        PIPE_IO_HANDLER *  pIoHandler;
        
        hr = m_ConnectTable.CancelBinding(
                    pMessagePipe->GetId(),
                    &pPipeCancelled,
                    &pIoHandler
                    );

        if (SUCCEEDED(hr)) {
            DBG_ASSERT( pPipeCancelled == pMessagePipe );
            DBG_ASSERT( pIoHandler == NULL );
            
            hr = pMessagePipe->Disconnect(hrDisconnect);

            DBG_ASSERT(SUCCEEDED(hr));
        }
    } else {
        //
        // just get rid of the unconnected, unbound pipe
        //
        fBound = FALSE;
        hr = pMessagePipe->Disconnect(hrDisconnect);

        DBG_ASSERT(SUCCEEDED(hr));
    }

    m_ListLock.Unlock();

    if (fBound) {
        RemovedMessagePipe();
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Handles the async completion of a pipe and initiates the 
    first read needed to bind it to a message pipe.
    
Arguments:

    cbTransferred - the bytes transferred in the completion
    hr            - error code from completion
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::NotifyConnectCompletion(
    IN PVOID   pv,
    IN DWORD   cbTransferred,
    IN HRESULT hr
    )
{
    HRESULT                hrRetval = S_OK;
    IPM_NAMED_PIPE_ENTRY * pEntry   = (IPM_NAMED_PIPE_ENTRY *) pv;

    DBG_ASSERT( pEntry->dwSignature == IPM_NAMED_PIPE_ENTRY_SIGNATURE );
    //
    // outstanding I/O completed
    //
    EndIo();

    //
    // remove from list
    //
    RemoveListCreatedNamedPipe(pEntry);

    if (SUCCEEDED(hr)) {
        //
        // pipe connected successfully
        //
        AddListConnectedNamedPipe(pEntry);
        
        //
        // initiate read operation
        //
        if (StartAddIo()) {
            hrRetval = pEntry->pIoHandler->Read(
                            this,                   // IO_CONTEXT
                            pEntry,                 // context param
                            (PBYTE) pEntry->adwId,  // read buffer
                            sizeof(pEntry->adwId)    // buffer len
                            );

            if (FAILED(hrRetval)) {
                //
                // complete the i/o
                //
                NotifyReadCompletion(pEntry, 0, hr);
            }

            FinishAddIo();
        } else {
            hrRetval = HRESULT_FROM_WIN32(ERROR_BUSY);
        }

    } else {
        //
        // get rid of entry since it's no longer needed
        //
        m_pIoFactory->ClosePipeIoHandler(pEntry->pIoHandler);
        delete pEntry;

        RemovedNamedPipe();
    }

    return hrRetval;
}


/***************************************************************************++

Routine Description:

    Handles the async completion of an attempt to ReadFile on
    the named pipe.
    
Arguments:

    pv            - pointer to IPM_NAMED_PIPE_ENTRY
    cbTransferred - the bytes transferred in the completion
    hr            - error code from completion
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::NotifyReadCompletion(
    IN PVOID   pv,
    IN DWORD   cbTransferred,
    IN HRESULT hr
    )
{
    return HandleBindingCompletion(pv, cbTransferred, hr);
}


/***************************************************************************++

Routine Description:

    Handles the async completion of an attempt to WriteFile on
    a message pipe (this is the id handshake send from the client).
    
Arguments:

    pv            - pointer to IPM_MESSAGE_PIPE
    cbTransferred - the bytes transferred in the completion
    hr            - error code from completion
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::NotifyWriteCompletion(
    IN PVOID   pv,
    IN DWORD   cbTransferred,
    IN HRESULT hr
    )
{
    IPM_NAMED_PIPE_ENTRY * pNamedPipeEntry;
    DWORD                  dwId;
    HRESULT                hrRetval;
    HRESULT                hrCancel;
    IPM_MESSAGE_PIPE *     pMessagePipe;
    PIPE_IO_HANDLER *      pIoHandler;

    pNamedPipeEntry = (IPM_NAMED_PIPE_ENTRY *) pv;
    DBG_ASSERT( pNamedPipeEntry->dwSignature == IPM_NAMED_PIPE_ENTRY_SIGNATURE );

    dwId = pNamedPipeEntry->adwId[0];
    
    hrRetval = HandleBindingCompletion(pv, cbTransferred, hr);

    if (FAILED(hr) || FAILED(hrRetval)) {
        //
        // cancel the message pipe
        //
        hrCancel = m_ConnectTable.CancelBinding(
                        dwId,
                        &pMessagePipe,
                        &pIoHandler
                        );

    IpmTrace(IPM, (
            DBG_CONTEXT,
            "\n    IPM_PIPE_CONNECTOR::NotifyWriteCompletion Cancel %x %x\n",
            pMessagePipe,
            pIoHandler
            ));

        if (SUCCEEDED(hrCancel)) {
            DBG_ASSERT( pMessagePipe );
            DBG_ASSERT( !pIoHandler );

            if (FAILED(hr)) {
                pMessagePipe->Disconnect(hr);
            } else {
                pMessagePipe->Disconnect(hrRetval);
            }
        }
    }

    return hrRetval;
}


/***************************************************************************++

Routine Description:

    Cancels all outstanding operations.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::InitialCleanup(
    VOID
    )
{
    HRESULT hr;
    HRESULT hrMessagePipes;

    //
    // clean up lists here
    //
    hr             = DisconnectNamedPipes();
    hrMessagePipes = DisconnectMessagePipes();

    if (SUCCEEDED(hr)) {
        hr = hrMessagePipes;
    }

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\n    IPM_CONNECTOR::InitialCleanup (%x) hr = %x\n",
        this,
        hr
        ));

    DbgPrintThis();
}


/***************************************************************************++

Routine Description:

    Deletes the object.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::FinalCleanup(
    VOID
    )
{
    m_ListLock.Terminate();
    m_ConnectTable.Terminate();

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\n    IPM_CONNECTOR::FinalCleanup (%x)\n",
        this
        ));
    
    DbgPrintThis();

    delete this;
}


/***************************************************************************++

Routine Description:

    Creates a PIPE_IO_HANDLER and an I/O context to be used
    for the handshake i/o.
    
Arguments:

    dwId             - the id number of the worker process
    hPipe            - handle to named pipe
    ppNamedPipeEntry - receives i/o context
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::PrepareNamedPipeContext(
    IN  DWORD                   dwId,
    IN  HANDLE                  hPipe,
    OUT IPM_NAMED_PIPE_ENTRY ** ppNamedPipeEntry
    )
{
    HRESULT                hr              = S_OK;
    PIPE_IO_HANDLER *      pIoHandler      = NULL;
    IPM_NAMED_PIPE_ENTRY * pNamedPipeEntry = NULL;
    
    pNamedPipeEntry = new IPM_NAMED_PIPE_ENTRY;

    if (pNamedPipeEntry) {
        pNamedPipeEntry->adwId[0]    = dwId;
        pNamedPipeEntry->adwId[1]    = GetCurrentProcessId();
        pNamedPipeEntry->pIoHandler  = NULL;

        hr = m_pIoFactory->CreatePipeIoHandler(
                    hPipe,
                    &pIoHandler
                    );

        if (SUCCEEDED(hr)) {
            pNamedPipeEntry->pIoHandler = pIoHandler;
            *ppNamedPipeEntry           = pNamedPipeEntry;

            IpmTrace(IPM, (
                DBG_CONTEXT,
                "\n    IPM_PIPE_CONNECTOR::PrepareNamedPipeContext %x (%d %d %x)\n",
                pNamedPipeEntry,
                pNamedPipeEntry->adwId[0],
                pNamedPipeEntry->adwId[1],
                pNamedPipeEntry->pIoHandler
                ));
        } else {
            delete pNamedPipeEntry;
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hr;
}

/***************************************************************************++

Routine Description:

    Handles the async completion of an attempt to bind
    the named pipe.
    
Arguments:

    pv            - pointer to IPM_NAMED_PIPE_ENTRY
    cbTransferred - the bytes transferred in the completion
    hr            - error code from completion
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::HandleBindingCompletion(
    IN PVOID   pv,
    IN DWORD   cbTransferred,
    IN HRESULT hr
    )
{
    IPM_NAMED_PIPE_ENTRY * pNamedPipeEntry;
    IPM_MESSAGE_PIPE *     pMessagePipe;
    HRESULT                hrRetval = hr;

    pNamedPipeEntry = (IPM_NAMED_PIPE_ENTRY *) pv;
    DBG_ASSERT( pNamedPipeEntry->dwSignature == IPM_NAMED_PIPE_ENTRY_SIGNATURE );

    //
    // i/o is completed
    //
    EndIo();

    //
    // remove entry from list
    //
    RemoveListConnectedNamedPipe(pNamedPipeEntry);
    
    if (SUCCEEDED(hr)) {
        //
        // successful i/o, try to bind
        //
        hrRetval = m_ConnectTable.BindIoHandler(
                        pNamedPipeEntry->adwId[0],
                        pNamedPipeEntry->pIoHandler,
                        &pMessagePipe
                        );

        if (SUCCEEDED(hrRetval) && pMessagePipe) {
            //
            // remember the remote pid
            //
            pMessagePipe->SetRemotePid(pNamedPipeEntry->adwId[1]);
            
            //
            // add to list of connected pipes
            //
            AddListConnectedMessagePipe(
                pMessagePipe,
                pNamedPipeEntry->pIoHandler
                );

            //
            // do connection notification
            //
            IpmTrace(IPM, (
                DBG_CONTEXT,
                "\n    IPM_PIPE_CONNECTOR::HandleBindingCompletion connecting pipe %x\n",
                pMessagePipe
                ));
            
            hrRetval = pMessagePipe->Connect();
        }
    } else {
        //
        // get rid of the pipe on failed i/o
        //
        m_pIoFactory->ClosePipeIoHandler(pNamedPipeEntry->pIoHandler);
    }

    //
    // get rid of list element in any case
    //
    delete pNamedPipeEntry;

    RemovedNamedPipe();

    return hrRetval;
}



/***************************************************************************++

Routine Description:

    Creates a new named pipe and starts it listening for 
    a connection.
    
Arguments:

    strPipeName  - name of the pipe
    dwId         - id of the pipe
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::AddNewListener(
    IN const STRU&        strPipeName,
    IN DWORD              dwId
    )
{
    HRESULT                hr = S_OK;
    DWORD                  dwErr = ERROR_SUCCESS;
    HANDLE                 hPipe;
    IPM_NAMED_PIPE_ENTRY * pNamedPipeEntry = NULL;

    CSecurityDispenser     SecDisp;
    PSECURITY_ATTRIBUTES   pSa = NULL;

    // We are not responsible for freeing any memory retrieved from this
    // Dispenser class.
    dwErr = SecDisp.GetSecurityAttributesForAllWorkerProcesses(&pSa);
    if ( dwErr != ERROR_SUCCESS )
    {
        return HRESULT_FROM_WIN32( dwErr );
    }
 
    //
    // make sure its ok to start
    //
    if (AddingNamedPipe()) {
        //
        // create a named pipe
        //
        hPipe = CreateNamedPipe(
            strPipeName.QueryStr(),
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
            PIPE_UNLIMITED_INSTANCES,
            4096,
            4096,
            0,
            pSa
            );

        if (hPipe == INVALID_HANDLE_VALUE) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        //
        // get ready for connect i/o
        //
        if (SUCCEEDED(hr)) {
            hr = PrepareNamedPipeContext(dwId, hPipe, &pNamedPipeEntry);

            if (SUCCEEDED(hr)) {
                DBG_ASSERT( pNamedPipeEntry );
                AddListCreatedNamedPipe(pNamedPipeEntry);
            } else {
                CloseHandle(hPipe);
            }
        }

        //
        // do the connect i/o
        //
        if (SUCCEEDED(hr)) {

            if (StartAddIo()) {
                //
                // try to connect named pipe
                //
                hr = pNamedPipeEntry->pIoHandler->Connect(
                            this,
                            pNamedPipeEntry
                            );

                if (FAILED(hr)) {
                    //
                    // failed i/o is complete
                    //
                    NotifyConnectCompletion(pNamedPipeEntry, 0, hr);
                }

                FinishAddIo();
            } else {
                //
                // shutting down, can't start i/o operation
                //
                hr = HRESULT_FROM_WIN32(ERROR_BUSY);
            }
        }

        FinishAddingNamedPipe();
    } else {
        //
        // shutting down, can't add a new named pipe
        //
        hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        goto exit;
    }

exit:
    return hr;
}


/***************************************************************************++

Routine Description:

    Creates a new named pipe, connects it with CreateFile, and
    sends its ID to the listener.
    
Arguments:

    strPipeName  - name of the pipe
    dwId         - id of the pipe
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::AddNewSender(
    IN const STRU&        strPipeName,
    IN DWORD              dwId
    )
{
    HRESULT                hr              = S_OK;
    IPM_NAMED_PIPE_ENTRY * pNamedPipeEntry = NULL;
    DWORD                  dwReadModeFlag  = PIPE_READMODE_MESSAGE;
    HANDLE                 hPipe;
 
    //
    // make sure its ok to start
    //
    if (AddingNamedPipe()) {
        //
        // create and connect the pipe
        //
        hPipe = CreateFile(
                    strPipeName.QueryStr(),
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_OVERLAPPED,
                    NULL
                    );

        if (hPipe == INVALID_HANDLE_VALUE) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        //
        // set readmode to message
        //
        if (SUCCEEDED(hr)) {
            if (!SetNamedPipeHandleState(hPipe, &dwReadModeFlag, NULL, NULL)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hPipe);
            }
        }

        //
        // get ready for binding write i/o
        //
        if (SUCCEEDED(hr)) {
            hr = PrepareNamedPipeContext(dwId, hPipe, &pNamedPipeEntry);

            if (SUCCEEDED(hr)) {
                DBG_ASSERT( pNamedPipeEntry );
            } else {
                CloseHandle(hPipe);
            }
        }

        //
        // do binding write i/o
        //
        if (SUCCEEDED(hr)) {
            AddListConnectedNamedPipe(pNamedPipeEntry);
            
            //
            // initiate write operation
            //
            if (StartAddIo()) {
                hr = pNamedPipeEntry->pIoHandler->Write(
                            this,                   // IO_CONTEXT
                            pNamedPipeEntry,        // context param
                            (PBYTE) pNamedPipeEntry->adwId,  // write buffer
                            sizeof(pNamedPipeEntry->adwId)    // buffer len
                            );

                if (FAILED(hr)) {
                    //
                    // complete the i/o
                    //
                    NotifyWriteCompletion(pNamedPipeEntry, 0, hr);
                }

                FinishAddIo();
            } else {
                hr = HRESULT_FROM_WIN32(ERROR_BUSY);
            }
        }

        FinishAddingNamedPipe();
    } else {
        //
        // shutting down, can't add a new named pipe
        //
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }
    
    return hr;
}


/***************************************************************************++

Routine Description:

    Adds a message pipe to the connect table, and try to bind it
    
Arguments:

    strPipeName  - name of the pipe
    dwId         - id of the pipe
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_PIPE_CONNECTOR::AddUnboundMessagePipe(
    IN IPM_MESSAGE_PIPE * pMessagePipe,
    IN DWORD              dwId
    )
{
    HRESULT           hr         = S_OK;
    PIPE_IO_HANDLER * pIoHandler = NULL;

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\nIPM_PIPE_CONNECTOR::AddUnboundMessagePipe(pipe = %p, id = %d)\n",
        pMessagePipe,
        dwId
        ));
 
    if (AddingMessagePipe()) {
        //
        // try to bind the message pipe to a named pipe
        //
        pMessagePipe->SetId(dwId);
        
        hr = m_ConnectTable.BindMessagePipe(
                    dwId,
                    pMessagePipe,
                    &pIoHandler
                    );

        if (SUCCEEDED(hr)) {
            if (pIoHandler) {
                AddListConnectedMessagePipe(pMessagePipe, pIoHandler);

                //
                // do connection notification
                //
                hr = pMessagePipe->Connect();
            }
        } else {
            //
            // if it's not in the table we don't track it
            //
            RemovedMessagePipe();

            DPERROR((
                DBG_CONTEXT,
                hr,
                "IPM_CONNECT_TABLE::BindMessagePipe failed"
                ));
            
        }

        FinishAddingMessagePipe();
    } else {
        //
        // shutting down, can't add a pipe
        //
        hr = HRESULT_FROM_WIN32(ERROR_BUSY);
    }
    
    return hr;
}



/***************************************************************************++

Routine Description:

    Adds a created named pipe to the list
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::AddListCreatedNamedPipe(
    IPM_NAMED_PIPE_ENTRY * pEntry
    )
{
    m_ListLock.Lock();

    InsertHeadList(
        &m_lhCreatedNamedPipes,
        &pEntry->ListEntry
        );

    m_cCreatedNamedPipes++;

    DBG_ASSERT( m_cCreatedNamedPipes > 0 );

    m_ListLock.Unlock();
}

    
    
/***************************************************************************++

Routine Description:

    Removes a created named pipe from the list
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::RemoveListCreatedNamedPipe(
    IPM_NAMED_PIPE_ENTRY * pEntry
    )
{
    m_ListLock.Lock();

    RemoveEntryList(
        &pEntry->ListEntry
        );

    m_cCreatedNamedPipes--;

    DBG_ASSERT( m_cCreatedNamedPipes >= 0 );

    m_ListLock.Unlock();
}

    
    
/***************************************************************************++

Routine Description:

    Removes the first created named pipe from the list
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
IPM_NAMED_PIPE_ENTRY *
IPM_PIPE_CONNECTOR::PopListCreatedNamedPipe(
    VOID
    )
{
    IPM_NAMED_PIPE_ENTRY * pEntry;
    LIST_ENTRY *           ple;

    m_ListLock.Lock();

    if (!IsListEmpty(&m_lhCreatedNamedPipes)) {
        ple = RemoveHeadList(
                    &m_lhCreatedNamedPipes
                    );
                    
        pEntry = CONTAINING_RECORD(ple, IPM_NAMED_PIPE_ENTRY, ListEntry);

        m_cCreatedNamedPipes--;

        DBG_ASSERT( m_cCreatedNamedPipes >= 0 );
    } else {
        DBG_ASSERT( m_cCreatedNamedPipes == 0 );
        pEntry = NULL;
    }

    m_ListLock.Unlock();

    return pEntry;
}
   

/***************************************************************************++

Routine Description:

    Adds a connected named pipe to the list
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::AddListConnectedNamedPipe(
    IPM_NAMED_PIPE_ENTRY * pEntry
    )
{
    m_ListLock.Lock();

    InsertHeadList(
        &m_lhConnectedNamedPipes,
        &pEntry->ListEntry
        );

    m_cConnectedNamedPipes++;

    DBG_ASSERT( m_cConnectedNamedPipes > 0 );

    m_ListLock.Unlock();
}
    
/***************************************************************************++

Routine Description:

    Removes a connected named pipe from the list
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::RemoveListConnectedNamedPipe(
    IPM_NAMED_PIPE_ENTRY * pEntry
    )
{
    m_ListLock.Lock();

    RemoveEntryList(
        &pEntry->ListEntry
        );

    m_cConnectedNamedPipes--;

    DBG_ASSERT( m_cConnectedNamedPipes >= 0 );

    m_ListLock.Unlock();
}
   
/***************************************************************************++

Routine Description:

    Removes the first connected named pipe from the list
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
IPM_NAMED_PIPE_ENTRY *
IPM_PIPE_CONNECTOR::PopListConnectedNamedPipe(
    VOID
    )
{
    IPM_NAMED_PIPE_ENTRY * pEntry;
    LIST_ENTRY *           ple;

    m_ListLock.Lock();

    if (!IsListEmpty(&m_lhConnectedNamedPipes)) {
        ple = RemoveHeadList(
                    &m_lhConnectedNamedPipes
                    );
                    
        pEntry = CONTAINING_RECORD(ple, IPM_NAMED_PIPE_ENTRY, ListEntry);

        m_cConnectedNamedPipes--;

        DBG_ASSERT( m_cConnectedNamedPipes >= 0 );
    } else {
        DBG_ASSERT( m_cConnectedNamedPipes == 0 );
        pEntry = NULL;
    }

    m_ListLock.Unlock();

    return pEntry;
}

/***************************************************************************++

Routine Description:

    Adds a connected message pipe to the list.
    Also binds the io handler to the pipe.
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::AddListConnectedMessagePipe(
    IPM_MESSAGE_PIPE * pPipe,
    PIPE_IO_HANDLER *  pIoHandler
    )
{
    m_ListLock.Lock();

    pPipe->SetPipeIoHandler(pIoHandler);

    InsertHeadList(
        &m_lhConnectedMessagePipes,
        pPipe->GetConnectListEntry()
        );

    m_cConnectedMessagePipes++;

    DBG_ASSERT( m_cConnectedMessagePipes > 0 );

    m_ListLock.Unlock();
}
    
/***************************************************************************++

Routine Description:

    Removes a connected message pipe from the list
    
Arguments:

    None.
    
Return Value:

    None.

--***************************************************************************/
VOID
IPM_PIPE_CONNECTOR::RemoveListConnectedMessagePipe(
    IPM_MESSAGE_PIPE * pPipe
    )
{
    m_ListLock.Lock();

    RemoveEntryList(
        pPipe->GetConnectListEntry()
        );

    m_cConnectedMessagePipes--;

    DBG_ASSERT( m_cConnectedMessagePipes >= 0 );

    m_ListLock.Unlock();
}


HRESULT
IPM_PIPE_CONNECTOR::DisconnectNamedPipes(
    VOID
    )
{
    HRESULT                hr = S_OK;
    HRESULT                hrClose;
    LIST_ENTRY *           ple;
    IPM_NAMED_PIPE_ENTRY * pEntry;

    ple = m_lhCreatedNamedPipes.Flink;

    while (ple != &m_lhCreatedNamedPipes) {
        pEntry = (IPM_NAMED_PIPE_ENTRY *) ple;

        hrClose = pEntry->pIoHandler->Disconnect();

        if (FAILED(hrClose)) {
            hr = hrClose;
        }

        ple = ple->Flink;
    }


    ple = m_lhConnectedNamedPipes.Flink;
    
    while (ple != &m_lhConnectedNamedPipes) {
        pEntry = (IPM_NAMED_PIPE_ENTRY *) ple;

        hrClose = pEntry->pIoHandler->Disconnect();

        if (FAILED(hrClose)) {
            hr = hrClose;
        }

        ple = ple->Flink;        
    };
    
    return hr;
}

HRESULT
IPM_PIPE_CONNECTOR::DisconnectMessagePipes(
    VOID
    )
{
    return S_OK;
}

VOID
IPM_PIPE_CONNECTOR::DbgPrintThis(
    VOID
    ) const
{
    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\n    IPM_PIPE_CONNECTOR (%x)\n"
        "      m_cCreatedNamedPipes     = %d\n"
        "      m_cConnectedNamedPipes   = %d\n"
        "      m_cConnectedMessagePipes = %d\n"
        "      GetConnectsOutstanding() = %d\n",
        this,
        m_cCreatedNamedPipes,
        m_cConnectedNamedPipes,
        m_cConnectedMessagePipes,
        m_ConnectTable.GetConnectsOutstanding()
        ));
        
}


/***************************************************************************++

Routine Description:

    Initializes the IPM_CONNECT_TABLE.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_CONNECT_TABLE::Initialize(
    VOID
    )
{
    m_cConnectsOutstanding = 0;
    return m_Lock.Initialize();
}


/***************************************************************************++

Routine Description:

    Terminates the IPM_CONNECT_TABLE.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_CONNECT_TABLE::Terminate(
    VOID
    )
{
    m_Lock.Terminate();

    return S_OK;
}


/***************************************************************************++

Routine Description:

    Looks up dwId in the hash table. If there is an associated
    PIPE_IO_HANDLER in the table at that location, this method
    returns it in the out parameter, and removes the entry from
    the table.

    If there is no PIPE_IO_HANDLER, this method makes a new entry
    containing the MESSAGE_PIPE. The out parameter gets set to NULL.
    
Arguments:

    dwId         - A unique ID for the pair of pipe objects
    pMessagePipe - Message pipe to be bound
    ppIoHandler  - OUT parameter that receives i/o handler
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_CONNECT_TABLE::BindMessagePipe(
    IN  DWORD              dwId,
    IN  IPM_MESSAGE_PIPE * pMessagePipe,
    OUT PIPE_IO_HANDLER ** ppIoHandler
    )
{
    HRESULT             hr = S_OK;
    IPM_CONNECT_ENTRY * pEntry;
    PIPE_IO_HANDLER *   pIoHandler;

    m_Lock.Lock();

    hr = FindEntry(dwId, &pEntry);

    if (SUCCEEDED(hr)) {
        if (pEntry) {
            //
            // found it
            //
            if (pEntry->pIoHandler && !pEntry->pMessagePipe) {
                // everything looks good
                pIoHandler = pEntry->pIoHandler;
                
                hr = RemoveEntry(pEntry);

                if (SUCCEEDED(hr)) {
                    IpmTrace(IPM, (
                        DBG_CONTEXT,
                        "\n    IPM_CONNECT_TABLE::BindMessagePipe: Success(%d %x %x)\n",
                        dwId,
                        pMessagePipe,
                        pIoHandler
                        ));
                        
                    *ppIoHandler = pIoHandler;
                }
            } else {
                // someone is trying to connect one pipe twice!
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

                IpmTrace(IPM, (
                    DBG_CONTEXT,
                    "\n    IPM_CONNECT_TABLE::BindMessagePipe: Entry = (%d %x %x)\n",
                    dwId,
                    pEntry->pMessagePipe,
                    pEntry->pIoHandler
                    ));
                
            }

        } else {
            //
            // couldn't find it
            //
            hr = AddEntry(dwId, pMessagePipe, NULL);
            *ppIoHandler = NULL;
        }
    }

    m_Lock.Unlock();

    return hr;
}




/***************************************************************************++

Routine Description:

    Looks up dwId in the hash table. If there is an associated
    MESSAGE_PIPE in the table at that location, this method
    returns it in the out parameter, and removes the entry from
    the table.

    If there is no MESSAGE_PIPE, this method makes a new entry
    containing the PIPE_IO_HANDLER. The OUT parameter gets set
    to NULL.
    
Arguments:

    dwId          - A unique ID for the pair of pipe objects
    pIoHandler    - i/o handler to be bound
    ppMessagePipe - OUT parameter that receives the message pipe
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_CONNECT_TABLE::BindIoHandler(
    IN  DWORD               dwId,
    IN  PIPE_IO_HANDLER *   pIoHandler,
    OUT IPM_MESSAGE_PIPE ** ppMessagePipe
    )
{
    HRESULT             hr = S_OK;
    IPM_CONNECT_ENTRY * pEntry;
    IPM_MESSAGE_PIPE *  pMessagePipe;

    m_Lock.Lock();

    hr = FindEntry(dwId, &pEntry);

    if (SUCCEEDED(hr)) {
        if (pEntry) {
            //
            // found it
            //
            if (!pEntry->pIoHandler && pEntry->pMessagePipe) {
                // everything looks good
                pMessagePipe = pEntry->pMessagePipe;
                
                hr = RemoveEntry(pEntry);

                if (SUCCEEDED(hr)) {
                    IpmTrace(IPM, (
                        DBG_CONTEXT,
                        "\n    IPM_CONNECT_TABLE::BindIoHandler: Success(%d %x %x)\n",
                        dwId,
                        pMessagePipe,
                        pIoHandler
                        ));
                        
                    *ppMessagePipe = pMessagePipe;
                }
            } else {
                // someone is trying to connect one pipe twice!
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            }

        } else {
            //
            // couldn't find it
            //
            hr = AddEntry(dwId, NULL, pIoHandler);
            *ppMessagePipe = NULL;
        }
    }

    m_Lock.Unlock();

    return hr;
}


HRESULT
IPM_CONNECT_TABLE::CancelBinding(
    IN  DWORD               dwId,
    OUT IPM_MESSAGE_PIPE ** ppMessagePipe,
    OUT PIPE_IO_HANDLER **  ppIoHandler
    )
{
    HRESULT             hr = S_OK;
    IPM_CONNECT_ENTRY * pEntry;
    IPM_MESSAGE_PIPE *  pMessagePipe;
    PIPE_IO_HANDLER *   pIoHandler;

    m_Lock.Lock();

    hr = FindEntry(dwId, &pEntry);

    if (SUCCEEDED(hr)) {
        if (pEntry) {
            //
            // found it
            //
            if (pEntry->pIoHandler) {
                DBG_ASSERT( !pEntry->pMessagePipe );
                pMessagePipe = NULL;
                pIoHandler   = pEntry->pIoHandler;
            } else {
                DBG_ASSERT( pEntry->pMessagePipe );
                pMessagePipe = pEntry->pMessagePipe;
                pIoHandler   = NULL;
            }
            
            hr = RemoveEntry(pEntry);

            if (SUCCEEDED(hr)) {
                *ppMessagePipe = pMessagePipe;
                *ppIoHandler   = pIoHandler;                
            }
        }
    }

    m_Lock.Unlock();

    return hr;
}


/***************************************************************************++

Routine Description:

    Creates a new IPM_CONNECT_ENTRY and adds it to the
    hash table.

    Only one of the pointers should be set.
    
Arguments:

    dwId         - A unique ID for the pair of pipe objects
    pIoHandler   - i/o handler to be bound
    pMessagePipe - message pipe to be bound
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IPM_CONNECT_TABLE::AddEntry(
    IN DWORD              dwId,
    IN IPM_MESSAGE_PIPE * pMessagePipe,
    IN PIPE_IO_HANDLER *  pIoHandler
    )
{
    HRESULT             hr = S_OK;
    LK_RETCODE          lkrc;
    IPM_CONNECT_ENTRY * pEntry;

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\n    IPM_CONNECT_TABLE::AddEntry(id = %d, pipe = %x, %x)\n",
        dwId,
        pMessagePipe,
        pIoHandler
        ));


    DBG_ASSERT(
        (pMessagePipe && !pIoHandler) ||
        (!pMessagePipe && pIoHandler)
        );

    pEntry = new IPM_CONNECT_ENTRY;
    if (pEntry) {
        pEntry->dwId         = dwId;
        pEntry->pMessagePipe = pMessagePipe;
        pEntry->pIoHandler   = pIoHandler;

        lkrc = m_ConnectHash.InsertRecord(pEntry);
        hr   = HRESULT_FROM_LK_RETCODE(lkrc);        
    
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hr;
}

HRESULT
IPM_CONNECT_TABLE::RemoveEntry(
    IN IPM_CONNECT_ENTRY * pEntry
    )
{
    HRESULT    hr = S_OK;
    LK_RETCODE lkrc;

    IpmTrace(IPM, (
        DBG_CONTEXT,
        "\n    IPM_CONNECT_TABLE::RemoveEntry %x (id = %d, pipe = %x, %x)\n",
        pEntry,
        pEntry->dwId,
        pEntry->pMessagePipe,
        pEntry->pIoHandler
        ));

    lkrc = m_ConnectHash.DeleteRecord(pEntry);
    hr   = HRESULT_FROM_LK_RETCODE(lkrc);        

    if (SUCCEEDED(hr)) {
        delete pEntry;
    }

    return hr;
}

HRESULT
IPM_CONNECT_TABLE::FindEntry(
    IN  DWORD                dwId,
    OUT IPM_CONNECT_ENTRY ** ppEntry
    )
{
    HRESULT    hr = S_OK;
    LK_RETCODE lkrc;

    lkrc = m_ConnectHash.FindKey(dwId, ppEntry);
    if (LK_SUCCESS == lkrc) {
        //
        // found it
        //

    } else if (LK_NO_SUCH_KEY == lkrc) {
        //
        // couldn't find it
        //
        *ppEntry = NULL;

    } else {
        // unexpected retcode
        hr = HRESULT_FROM_LK_RETCODE(lkrc);
    }

    if (lkrc == LK_SUCCESS) {
        IpmTrace(IPM, (
            DBG_CONTEXT,
            "\n    IPM_CONNECT_TABLE::FindEntry %x (id = %d, pipe = %x, %x)\n",
            (*ppEntry),
            (*ppEntry)->dwId,
            (*ppEntry)->pMessagePipe,
            (*ppEntry)->pIoHandler
            ));
    }    

    return hr;
}


//
// end pipeconn.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\acache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       acache.cxx

   Abstract:
       This module implements the Allocation cache handler and associated
        objects.

   Author:

       Murali R. Krishnan    ( MuraliK )     12-Sept-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/

// TODO:
// * (Debug only) Add guard blocks before and after each allocation to detect
//   under- and overruns.
// * (Debug only) Change the order of the freelist to FIFO (instead of
//   LIFO) to help catch cases of a block being free'd while something
//   else still points to it and then getting reused.

/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#include <acache.hxx>
#include <sched.hxx>
#include <irtlmisc.h>

// BUGBUG - TaylorW
// The use of the private heap was causing an AV during w3wp shutdown
// for now I am turning this off until I have time to do some more
// investigation.
//
// #define PRIVATE_HEAP

//
// # of CPUs in machine (for allocation threshold scaling)
//
DWORD g_cCPU = 1;

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ACACHE_CONFIG_PARAMS_REG_KEY[] = ACACHE_REG_PARAMS_REG_KEY;

/************************************************************
 *    Inlined Documentation on Alloc-Cache
 *
 * Allocation Cache:
 *    This module is to cache the commonly allocated objects
 *    to serve following goals
 *      1) we can have maximum reuse of blocks
 *      2) avoid traffic to the process heap manager
 *      3) gather statistics for understanding of usage
 *
 * Details on Allocation Cache:
 *   There is one ALLOC_CACHE_HANDLER (shortly ACH) object per
 *   object that we decide to cache. The ACH is initialized by
 *   the configuration supplied during its construction. ACH serves
 *   as the main object for allocation/free of the objects it is created
 *   to cache. ACH gathers statistics of various operations and provides
 *   hooks to export the gathered statistics. There is a periodic cleanup
 *   scavenger that frees up long unused blocks thus reducing the working
 *   set of the system.
 *
 *   All ACH objects created are chained and maintained in the global
 *   list of allocation cache handler objects. This global list is used
 *   for enumeration, debugging, and statistics dumps
 *
 * Allocation cache Configuration:
 *
 *   Each ACH object is created with the ALLOC_CACHE_CONFIGURATION that
 *   specifies the (concurrency factor, threshold, size) desired.
 *   The concurrency factor ensures that we support the specified level
 *   of concurrency in allocations. The threshold specifies the number
 *   of objects that we will maintain (max) in the free-list. When the
 *   threshold is exceeded the freed objects are pushed to the process
 *   pool until the currently active objects fall below the threshold.
 *   In addition, each ACH object also retains a read-only name for the
 *   object allocated - for friendly tracking purposes.
 *
 *   There is also a global configuration parameter that specifies the
 *   Lookaside cleanup interval.
 *
 * Allocation and Free:
 *   Allocation allocates one free object from the free-list if any exist.
 *   Otherwise the allocation will result in fetching a new object from
 *   the process heap manager.
 *   A free adds the freed object to the free-list if the # free objects
 *   is less than the threshold specified. Otherwise the object is freed
 *   to the process heap manager.
 *   Statistics are gathered during both allocation and free operations.
 *
 * Statistics:
 *   Statistics are gathered during the alloc/free operations throughout
 *   the life-time of the ACH. These statistics are reported via the
 *   DumpStatsToHtml() exported function. The statistics can also be
 *   gathered by the NTSD helper function.
 *
 * Scheduled List cleanup:
 *   There is a scheduled work item for the lookaside cleanup interval.
 *   The callback function walks through the list of ACH items on global
 *   list and takes snapshot of the # allocation calls. On a subsequent
 *   walk-through, if the # allocation calls remains the same (which will
 *   be the case if there is no allocation activity), then, the entire
 *   list of alloced objects is pruned. This pruning reduces the working
 *   set of the process.
 ************************************************************/

/************************************************************
 *    Static Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

CRITICAL_SECTION ALLOC_CACHE_HANDLER::sm_csItems;
LIST_ENTRY       ALLOC_CACHE_HANDLER::sm_lItemsHead;
DWORD            ALLOC_CACHE_HANDLER::sm_dwScheduleCookie = 0;
LONG             ALLOC_CACHE_HANDLER::sm_nFillPattern = 0xACA50000 ;


// This class is used to implement the free list.  We cast the free'd
// memory block to a CFreeList*.  The signature is used to guard against
// double deletion.  We also fill memory with a pattern.

class CFreeList
{
public:
    SINGLE_LIST_ENTRY Next;
    DWORD             dwSig;

    enum {
        FREESIG = (('A') | ('C' << 8) | ('a' << 16) | (('$' << 24) | 0x80)),
    };
};


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Initialize(VOID)
{
    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    // initialize the class statics
    InitializeListHead( &sm_lItemsHead);
    INITIALIZE_CRITICAL_SECTION( &sm_csItems);
    
    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Initialize()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Cleanup(VOID)
{
    DBG_ASSERT( sm_dwScheduleCookie == 0);

    DBG_ASSERT( IsListEmpty(&sm_lItemsHead));
    DeleteCriticalSection( &sm_csItems);

    return ( TRUE);

} // ALLOC_CACHE_HANDLER::Cleanup()


/* class static */
VOID
ALLOC_CACHE_HANDLER::InsertNewItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    InsertTailList( &sm_lItemsHead, &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::InsertNewItem()



/* class static */
VOID
ALLOC_CACHE_HANDLER::RemoveItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    RemoveEntryList( &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::RemoveItem()



/* class static */
BOOL
ALLOC_CACHE_HANDLER::DumpStatsToHtml(
   OUT CHAR * pchBuffer,
   IN OUT LPDWORD lpcchBuffer )
/*++
  Description:
    This function dumps the stats on all allocation cached objects
     to HTML format for diagnostics

  Arguments:
    pchBuffer - pointer to buffer that will contain the html results
    lpcchBuffer - pointer to DWORD containing the size of buffer on entry
               On return this contains the # of bytes written out to buffer

  Return:
    TRUE for success and FALSE for failure
    Look at GetLastError() for the error code.
--*/
{
    LIST_ENTRY  * pEntry;
    DWORD  iCount, cch;
    DWORD  cbTotalMem = 0;
    BOOL   fRet = TRUE;

    if ( (lpcchBuffer == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    EnterCriticalSection( &sm_csItems);

    if ( 300 < *lpcchBuffer ) {

        // Print the header blob
        cch = wsprintfA( pchBuffer,
                         "\r\nAllocCacheTable Data <br>\r\n"
                         "<TABLE BORDER> <TR> "
                         "<TH> Item Name </TH> "
                         "<TH> Config(concurr, threshold, size) </TH> "
                         "<TH> # Total Items </TH> "
                         "<TH> # Alloc Calls </TH> "
                         "<TH> # Free Calls </TH> "
                         "<TH> # Free Entries </TH> "
                         "<TH> # Total Size (bytes) </TH> "
                         "<TH> Fill Pattern </TH> "
                         "<TH> Heap </TH> "
                         " </TR>\r\n"
                         );
    } else {
        cch = 300;
    }

    for ( pEntry = sm_lItemsHead.Flink, iCount = 0;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink, iCount++
          ) {

        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        cbTotalMem += pach->m_acConfig.cbSize * pach->m_nTotal;

        if ( (cch + 160 + strlen( pach->m_pszName)) < *lpcchBuffer) {
            cch += wsprintfA( pchBuffer + cch,
                              " <TR> <TD> [%d] %s </TD>"
                              " <TD> (%d, %d, %d) </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> %4d </TD>"
                              " <TD> 0x%08lX </TD>"
                              " <TD> %p </TD>"
                              " </TR>\r\n"
                              ,
                              iCount, pach->m_pszName,
                              pach->m_acConfig.nConcurrency,
                              pach->m_acConfig.nThreshold,
                              pach->m_acConfig.cbSize,
                              pach->m_nTotal,
                              pach->m_nAllocCalls,
                              pach->m_nFreeCalls,
                              pach->m_nFreeEntries,
                              pach->m_acConfig.cbSize * pach->m_nTotal,
                              pach->m_nFillPattern,
                              pach->m_hHeap
                              );
        } else {
            cch += 160 + strlen( pach->m_pszName);
        }
    } // for

    LeaveCriticalSection( &sm_csItems);

    //
    // dump the final summary
    //
    if ( (cch + 100 ) < *lpcchBuffer) {
        cch += wsprintfA( pchBuffer + cch,
                          " <b>"
                          " <TR> </TR>"
                          " <TR> <TD> Total </TD> <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> </TD>"
                          " <TD> %4d </TD>"
                          " </TR>"
                          "</b>\r\n"
                          " </TABLE>\r\n\r\n"
                          ,
                          cbTotalMem
                          );
    } else {
        cch += 100;
    }

    if ( *lpcchBuffer < cch ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fRet = FALSE;
    }

    *lpcchBuffer = cch;

    return (fRet);
} // ALLOC_CACHE_HANDLER::DumpStatsToHtml()

extern "C"
BOOL AllocCacheDumpStatsToHtml( OUT CHAR * pch,
                                IN OUT LPDWORD lpcchBuff)
{
    return ( ALLOC_CACHE_HANDLER::DumpStatsToHtml( pch, lpcchBuff));
}

/* class static */
BOOL
ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval( VOID )
{
    DWORD               dwError;
    DWORD               dwVal = 0;
    HKEY                hkey;

    dwError = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                             g_PSZ_ACACHE_CONFIG_PARAMS_REG_KEY,
                             0,
                             KEY_READ,
                             &hkey);

    if ( dwError == NO_ERROR ) {

        //
        // get the lookaside list cleanup period
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL,
                                   ACACHE_REG_DEFAULT_CLEANUP_INTERVAL );

        DBG_REQUIRE( !RegCloseKey( hkey ) );
    }

    if ( dwVal != 0 )
    {
        sm_dwScheduleCookie =
            ScheduleWorkItem( ALLOC_CACHE_HANDLER::CleanupAllLookasides,
                              NULL,
                              dwVal * 1000,
                              TRUE );

        if ( sm_dwScheduleCookie == 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
} // ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval( VOID )
{
    BOOL fReturn = TRUE;
    if ( sm_dwScheduleCookie )
    {
        fReturn = RemoveWorkItem( sm_dwScheduleCookie );
        if (fReturn) {
            sm_dwScheduleCookie = 0;
        }
    }

    return ( fReturn);
} // ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval()



/* class static */
VOID
WINAPI
ALLOC_CACHE_HANDLER::CleanupAllLookasides(
    IN PVOID            /* pvContext */
)
{
    LIST_ENTRY *        pEntry;

    EnterCriticalSection( &sm_csItems);

    for ( pEntry = sm_lItemsHead.Flink;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink )
    {
        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        IF_DEBUG( ALLOC_CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                         "Cleaning lookaside list for '%s' handler\n",
                         pach->m_pszName ));
        }

        pach->CleanupLookaside( FALSE );
    }

    LeaveCriticalSection( &sm_csItems);
} // ALLOC_CACHE_HANDLER::CleanupAllLookasides()




/************************************************************
 *    Member Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig,
    IN BOOL fEnableCleanupAsserts /* = TRUE */
    )
    : m_fValid ( FALSE),
      m_nTotal       (0),
      m_nAllocCalls  (0),
      m_nFreeCalls   (0),
      m_nFreeEntries (0),
      m_pszName      (pszName),
      m_nLastAllocCount(0),
      m_hHeap        (NULL),
      m_fCleanupAssertsEnabled(fEnableCleanupAsserts)
{
    DBG_ASSERT( NULL != pacConfig );
    m_acConfig = *pacConfig;

    if ( pacConfig->nThreshold == INFINITE) {
        // this will be compared against a signed value. So be careful.
        m_acConfig.nThreshold = 0x7FFFFFFF;
    } else {
        // scale by the number of processors on MP machines
        m_acConfig.nThreshold *= g_cCPU;
    }

    // make sure the block is big enough to hold a CFreeList
    m_acConfig.cbSize = max(m_acConfig.cbSize, sizeof(CFreeList));
    // round up the block size to a multiple of the size of a LONG (for
    // the fill pattern in Free()).
    m_acConfig.cbSize = 
        (m_acConfig.cbSize + sizeof(LONG) - 1) & ~(sizeof(LONG) - 1);

    INITIALIZE_CRITICAL_SECTION( & m_csLock);

    m_lHead.Next = NULL;
    m_nFillPattern = InterlockedIncrement(&sm_nFillPattern);

    //
    // Create private heap
    //

#ifdef PRIVATE_HEAP
    if (TsIsNtServer())
        m_hHeap = HeapCreate( 0, 0, 0 );
    else
        m_hHeap = IisHeap();

    if( m_hHeap == NULL )
    {
        return;
    }
#endif

    ALLOC_CACHE_HANDLER::InsertNewItem( this);
    m_fValid = TRUE;
    return;
} // ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER()



ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{
    if ( m_fValid) {

        CleanupLookaside( TRUE );

        DeleteCriticalSection( & m_csLock);
        ALLOC_CACHE_HANDLER::RemoveItem( this);
        
#ifdef PRIVATE_HEAP
        if ( m_hHeap )
        {
            if (TsIsNtServer())
                DBG_REQUIRE( HeapDestroy( m_hHeap ) );
            m_hHeap = NULL;
        }
#endif
    }

    if (m_fCleanupAssertsEnabled) {
        DBG_ASSERT( 0 == m_nTotal );
        DBG_ASSERT( m_lHead.Next == NULL);
    }

    return;
} // ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER()



VOID
ALLOC_CACHE_HANDLER::CleanupLookaside(
    IN BOOL             fForceCleanup
)
/*++
  Description:
    This function cleans up the lookaside list by removing excess storage space
    used by the objects allocated by this instance. This function is
    used by the periodic scavenging operation as well as for final cleanup.

  Arguments:
    fForceCleanup - forces a cleanup operation always.

  Returns:
     None
--*/
{
    if ( !fForceCleanup )
    {
        //
        // We are called for the regular scavenging operation
        // Take a snapshot of the # allocation calls so that
        //  we may cleanup space when services are idle.
        //

        IF_DEBUG( ALLOC_CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                         "AllocCalls = %ld, LastAllocCount = %ld\n",
                         m_nAllocCalls,
                         m_nLastAllocCount ));
        }

        if ( m_nAllocCalls != m_nLastAllocCount )
        {
            InterlockedExchange( &m_nLastAllocCount,
                                 m_nAllocCalls );
            return;
        }
    }

    SINGLE_LIST_ENTRY listHeadCopy;

    //
    // make a copy of the first element in the list inside the lock
    // Free the entire chain outside the locked section.
    // Otherwise on a busy system the threads will be waiting for
    //  this thread to complete
    //

    Lock();
    listHeadCopy.Next = m_lHead.Next;

    //
    // we are about to cleanup all entries -> so set state back properly.
    //
    m_lHead.Next      = NULL;
    m_nFreeEntries    = 0; // no more free-entries available
    Unlock();

    //
    // free up all the entries in the list
    //

    PSINGLE_LIST_ENTRY pl;
    pl = PopEntryList( &listHeadCopy);
    while ( pl != NULL) {

        InterlockedDecrement( &m_nTotal);
#ifdef PRIVATE_HEAP
        HeapFree( m_hHeap, 0, pl );
#else
        ::LocalFree(pl);
#endif
        pl = PopEntryList( &listHeadCopy);
    } // for

    DBG_ASSERT( listHeadCopy.Next == NULL);

    return;
} // ALLOC_CACHE_HANDLER::CleanupLookaside()



LPVOID
ALLOC_CACHE_HANDLER::Alloc( VOID )
{
    LPVOID pv = NULL;

    if ( m_nFreeEntries > 0) {

        //
        // There are free entries available - allocate from the free pool
        //

        // Only acquire the lock if there's potentially something to grab
        Lock();

        // Check again if the free entry is available.
        if ( m_nFreeEntries > 0) {
            pv = (LPVOID) PopEntryList( & m_lHead);  // get the real object
            m_nFreeEntries--;
        }

        Unlock();

        if ( NULL != pv ) {
            CFreeList* pfl = (CFreeList*) pv;
            // If the signature is wrong then somebody's been scribbling
            // on memory that they've freed
            DBG_ASSERT(pfl->dwSig == CFreeList::FREESIG);
            pfl->dwSig = 0; // clear; just in case caller never overwrites
        }
    }

    if ( NULL == pv) {

        //
        // No free entry. Need to alloc a new object.
        //
        
#ifdef PRIVATE_HEAP
        DBG_ASSERT( m_hHeap != NULL );

        pv = (LPVOID) HeapAlloc( m_hHeap,
                                 HEAP_ZERO_MEMORY,
                                 m_acConfig.cbSize );
#else
        pv = (LPVOID) LocalAlloc( LPTR, m_acConfig.cbSize );
#endif
        if ( NULL != pv) {
            // update counters
            InterlockedIncrement( &m_nTotal);
        }
    }

    if ( NULL != pv ) {
        InterlockedIncrement( &m_nAllocCalls);
    }

    return ( pv);
} // ALLOC_CACHE_HANDLER::Alloc()



BOOL
ALLOC_CACHE_HANDLER::Free( LPVOID pv)
{
    // Assume that this is allocated using the Alloc() function
    DBG_ASSERT( NULL != pv);

    // use a signature to check against double deletions
    CFreeList* pfl = (CFreeList*) pv;
    DBG_ASSERT(pfl->dwSig != CFreeList::FREESIG);

#ifdef _DEBUG
    // Fill the memory with an improbable pattern that is unique
    // to this allocator (for identification in the debugger)
    RtlFillMemoryUlong(pv, m_acConfig.cbSize, m_nFillPattern);
#else  // !_DEBUG
    // Start filling the space beyond the portion overlaid by the initial
    // CFreeList.  Fill at most 6 DWORDS.
    LONG* pl = (LONG*) (pfl+1);

    for (LONG cb = (LONG)min(6 * sizeof(LONG),m_acConfig.cbSize) - sizeof(CFreeList);
         cb > 0;
         cb -= sizeof(LONG))
    {
        *pl++ = m_nFillPattern;
    }
#endif // !_DEBUG

    // Now, set the signature
    pfl->dwSig = CFreeList::FREESIG;

    // store the items in the alloc cache.

    if ( m_nFreeEntries >= m_acConfig.nThreshold) {

        //
        // threshold for free entries is exceeded. free the object to
        //  process pool
        //
        
#ifdef PRIVATE_HEAP
        HeapFree( m_hHeap, 0, pv );
#else
        ::LocalFree(pv);
#endif

        InterlockedDecrement( &m_nTotal);
    } else {

        //
        // Store the given pointer in the single linear list
        //

        Lock();
        PushEntryList( &m_lHead,  &pfl->Next);
        m_nFreeEntries++;
        Unlock();
    }

    InterlockedIncrement( &m_nFreeCalls);

    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Free()




VOID
ALLOC_CACHE_HANDLER::Print( VOID)
{
    CHAR  rgchBuffer[8192];
    DWORD cchBuffer = sizeof(rgchBuffer);

    DBG_REQUIRE( IpPrint( rgchBuffer, &cchBuffer));

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));

    return;
} // ALLOC_CACHE_HANDLER::Print()



BOOL
ALLOC_CACHE_HANDLER::IpPrint( OUT CHAR * pchBuffer, IN OUT LPDWORD pcchSize)
{
    DWORD cchUsed;

    cchUsed = wsprintfA( pchBuffer,
                         "[%d]ALLOC_CACHE_HANDLER[%08p]. Config: "
                         " ObjSize = %d. Concurrency=%d. Thres=%d.\n"
                         " TotalObjs = %d. Calls: Alloc(%d), Free(%d)."
                         " FreeEntries = %d. FillPattern = 0x%08lX.\n"
                         ,
                         GetCurrentThreadId(),
                         this,
                         m_acConfig.cbSize,
                         m_acConfig.nConcurrency,
                         m_acConfig.nThreshold,
                         m_nTotal, m_nAllocCalls, m_nFreeCalls,
                         m_nFreeEntries, m_nFillPattern
                         );
    Lock();

    // NYI: Print the list of individual pointers
    Unlock();

    DBG_ASSERT( *pcchSize > cchUsed);
    *pcchSize = cchUsed;

    return (TRUE);
} // ALLOC_CACHE_HANDLER::IpPrint()



VOID
ALLOC_CACHE_HANDLER::QueryStats( IN ALLOC_CACHE_STATISTICS * pacStats )
{
    DBG_ASSERT( pacStats != NULL );

    pacStats->acConfig      = m_acConfig;
    pacStats->nTotal        = m_nTotal;
    pacStats->nAllocCalls   = m_nAllocCalls;
    pacStats->nFreeCalls    = m_nFreeCalls;
    pacStats->nFreeEntries  = m_nFreeEntries;

    return;
} // ALLOC_CACHE_HANDLER::QueryStats()


//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\alloc.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    Alloc.h

Abstract:
    Custom heap allocator

   Author:
       George V. Reilly      (GeorgeRe)     Oct-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/11/1999 - Initial

--*/

#ifndef __ALLOC_H__
#define __ALLOC_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif // !__IRTLMISC_H__

extern HANDLE g_hHeap;

BOOL
WINAPI
IisHeapInitialize();

VOID
WINAPI
IisHeapTerminate();


#endif // __ALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\adminmonitor.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    adminmonitor.cxx

        This code is used to monitor the IISAdmin service and let
        dependent services know when it crashes and how to handle
        that crash.

        When the dependent service launches a thread with the StartIISAdminMonitor
        on it, it will start monitoring the iis admin process.  If the process
        crashes it will decide on the action to take and will notify the 
        service through call back functions to take the particular action.

        The service must also call the StopIISAdminMonitor when it is exiting
        so the thread that the StartIISAdminMonitor can be released.
*/

#include "precomp.hxx"
#include "adminmonitor.h"

#define MS_WAIT_FOR_IISRESET_TO_SHUT_SERVICE_DOWN 60000
#define MS_MAX_WAIT_FOR_INETINFO_TO_RESTART 120000
#define MS_INCREMENT_WAIT_TO_CHECK_FOR_INETINFO_TO_RESTART 5000



HANDLE g_IISAdminMonitorShutdownEvent;
HANDLE g_hIISAdminMonitorThread;
DWORD  g_dwIISAdminThreadId;

enum IISRESET_ACTION
{
    NoReset = 0,
    FullReset,
    InetinfoResetOnly
};

DWORD WINAPI
StartMonitoring(
    LPVOID pCallbackFcnsAsLPVoid
    );

HRESULT
MonitorProcess(
    IN SC_HANDLE  hService,
    IN PFN_IISAdminNotify pCallbackFcn,
    IN OUT BOOL* pfRehook
    );

HRESULT
GetProcessHandleForInetinfo(
    IN  SC_HANDLE  hService,
    OUT HANDLE*    phInetinfoProcess 
    );


/***************************************************************************++

Routine Description:

    This routine handles all the monitoring of the IISAdmin process and 
    the decision making logic to decide what to do when the process has
    problems.  It will used the callback functions provided to let the
    service know what it needs to do in case of a IISAdmin crash.

Arguments:

    Routine to call when we want to tell the service to do something or to 
    know about something because inetinfo had a problem.


    NOTE:  This routine should not lead to shutting down the monitor.
           Since it is launched on the monitor thread and the shutdown
           routine for the monitor will wait for the monitor thread to 
           complete, it will cause a deadlock.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
StartIISAdminMonitor(
    PFN_IISAdminNotify pfnNotifyIISAdminCrash
    )
{
    HRESULT hr = S_OK;
    DWORD threadid = 0;

    //
    // Create the shutdown event so we can signal when we need 
    // this thread to exit.  If we have all ready created this event
    // it means we are trying to monitor multiple times in one process
    // this is not allowed.
    //

    DBG_ASSERT ( g_IISAdminMonitorShutdownEvent == NULL );
    if ( g_IISAdminMonitorShutdownEvent != NULL )
    {
        hr = E_UNEXPECTED;

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Start monitoring called when we were all ready "
                                "monitoring, setting hr to equal %08x\n",
                                hr));

        goto exit;
    }

    // 
    // need to create the shutdown event.
    // since it is not named, don't worry about
    // openning an allready existing event.
    //
    // note that it is not manually reset, because if it has been
    // called, even if we weren't listening at that momement we still
    // want to know it was triggered the next time we start listening.
    //
    g_IISAdminMonitorShutdownEvent = CreateEvent( 
                                       NULL,  // default security descriptor
                                       TRUE,  // manual-reset (must ResetEvent)
                                       FALSE, // initial state = not signalled
                                       NULL );// not a named event

    if ( g_IISAdminMonitorShutdownEvent == NULL )
    {
        // there has been a problem creating the event
        // need to return the error

        hr = HRESULT_FROM_WIN32(GetLastError());

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Can not create shutdown event for monitoring "
                                "the inetinfo process, hr = %08x\n",
                                hr));

        goto exit;
    }

    //
    // Now that we have the shutdown event we can 
    // go ahead and spin up the process.
    //

    g_hIISAdminMonitorThread = CreateThread( NULL,  // default security descriptor
                                             0,  // stack size ( process default )
                                             StartMonitoring, // function to call
                                             (LPVOID) pfnNotifyIISAdminCrash,  // callback function
                                             0,     // thread can run immediately
                                             &g_dwIISAdminThreadId );


    if ( g_hIISAdminMonitorThread == NULL )
    {
        hr = HRESULT_FROM_WIN32 ( GetLastError() );
        goto exit;
    }

exit:

    if ( FAILED ( hr ) )
    {
        if ( g_IISAdminMonitorShutdownEvent ) 
        {
            CloseHandle ( g_IISAdminMonitorShutdownEvent );
            g_IISAdminMonitorShutdownEvent = NULL;
        }
    }

    return hr;
}

/***************************************************************************++

Routine Description:

  Routine shutsdown the monitoring thread, so that the service
  can exit.  It will block waiting for the thread to complete.

  If the shutdown event does not exist, it will not do anything.

Arguments:

   None

Return Value:

    VOID.

--***************************************************************************/
VOID
StopIISAdminMonitor(
    )
{
    //
    // issue, we need to use a critical section or something to prevent
    // this handle from being changed while we are in this code.
    //
    if ( g_IISAdminMonitorShutdownEvent )
    {
        SetEvent ( g_IISAdminMonitorShutdownEvent );
    }

    if ( g_hIISAdminMonitorThread ) 
    {
        //
        // make sure we are not on the thread that we are trying to stop
        // if we are we will deadlock.
        //
        DBG_ASSERT ( GetCurrentThreadId() != g_dwIISAdminThreadId );

        DWORD dwWaitResult = WaitForSingleObject ( g_hIISAdminMonitorThread, INFINITE );

        if ( dwWaitResult != WAIT_OBJECT_0 )
        {
            DBG_ASSERT ( dwWaitResult == WAIT_OBJECT_0 );
            DBGPRINTF((DBG_CONTEXT, 
                       "Failed to wait for iis admin thread to shutdown. hr = %08x\n", 
                       HRESULT_FROM_WIN32(GetLastError()) ));
        }

        IF_DEBUG ( INET_MONITOR )
        {
            DBGPRINTF((DBG_CONTEXT, "Inetinfo monitor thread has completed\n" ));
        }

        CloseHandle( g_hIISAdminMonitorThread );
        g_hIISAdminMonitorThread = NULL;
    }

    // now that the thread has exited we no longer need the shutdown event
    // so go ahead and close it down.
    if ( g_IISAdminMonitorShutdownEvent ) 
    {
        CloseHandle ( g_IISAdminMonitorShutdownEvent );
        g_IISAdminMonitorShutdownEvent = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Routine figures out if iisreset is even enabled on the machine.

Arguments:

    None.

Return Value:

    BOOL  - True, IISReset is enabled
            False, IISReset is not enabled.

Note:  Routine has been copied from the iisreset code.
If the value is set to 1, or non-existant then IISReset is enabled.
If the value is set to anything other than 1 then IISReset is disabled.
I am keeping it like this for backward compatibility, even though it seems
more correct to have 0 be disabled and everything else be enabled.

--***************************************************************************/
BOOL
IsIISResetEnabled(
    )
{
    BOOL    fSt = FALSE;
    HKEY    hKey;
    DWORD   dwValue;
    DWORD   dwType;
    DWORD   dwSize;


    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                       TEXT("SOFTWARE\\Microsoft\\INetStp"), 
                       0, 
                       KEY_READ, 
                       &hKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey, 
                              TEXT("EnableRestart"),
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            fSt = ( dwValue == 1 );
        }
        else
        {
            fSt = TRUE;
        }

        RegCloseKey( hKey );
    }

    return fSt;
}

/***************************************************************************++

Routine Description:

    Routine determines the timer values needed to recover from a crash.

Arguments:

    DWORD* pmsWaitForServiceShutdown,
    DWORD* pmsWaitForInetinfoToRestart,
    DWORD* pmsCheckIntervalForInetinfoToRestart

Return Value:

    None.


--***************************************************************************/
VOID
GetRegistryControlsForInetinfoCrash(
    DWORD* pmsWaitForServiceShutdown,
    DWORD* pmsWaitForInetinfoToRestart,
    DWORD* pmsCheckIntervalForInetinfoToRestart
    )
{
    HKEY    hKey;
    DWORD   dwValue;
    DWORD   dwType;
    DWORD   dwSize;

    DBG_ASSERT ( pmsWaitForServiceShutdown != NULL );
    DBG_ASSERT ( pmsWaitForInetinfoToRestart != NULL );
    DBG_ASSERT ( pmsCheckIntervalForInetinfoToRestart != NULL );

    // set the values to the defaults.
    *pmsWaitForServiceShutdown = MS_WAIT_FOR_IISRESET_TO_SHUT_SERVICE_DOWN;
    *pmsWaitForInetinfoToRestart = MS_MAX_WAIT_FOR_INETINFO_TO_RESTART;
    *pmsCheckIntervalForInetinfoToRestart = MS_INCREMENT_WAIT_TO_CHECK_FOR_INETINFO_TO_RESTART;

    // now check if there are registry overrides in place.
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                       REGISTRY_KEY_IISADMIN_PARAMETERS_W, 
                       0, 
                       KEY_READ, 
                       &hKey ) == ERROR_SUCCESS )
    {
        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey, 
                              REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_SHUTDOWN_AFTER_INETINFO_CRASH_W,
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( ( dwType == REG_DWORD ) && ( dwValue != 0 ))
            {
                *pmsWaitForServiceShutdown = dwValue;
            }
        }

        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey, 
                              REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_RESTART_AFTER_INETINFO_CRASH_W ,
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( ( dwType == REG_DWORD ) && ( dwValue != 0 ))
            {
                *pmsWaitForInetinfoToRestart = dwValue;
            }
        }

        dwSize = sizeof( dwValue );
        if ( RegQueryValueEx( hKey, 
                              REGISTRY_VALUE_IISADMIN_MS_CHECK_INTERVAL_FOR_INETINFO_TO_RESTART_W,
                              0, 
                              &dwType, 
                              (LPBYTE)&dwValue, 
                              &dwSize ) == ERROR_SUCCESS )
        {
            if ( ( dwType == REG_DWORD ) && ( dwValue != 0 ))
            {
                *pmsCheckIntervalForInetinfoToRestart = dwValue;
            }
        }

        RegCloseKey( hKey );
    }
}


/***************************************************************************++

Routine Description:

    Routine looks through the SCM information and determines the expected
    behavior of IISReset.

Arguments:

    IN  SC_HANDLE hIISAdminService 
    OUT IISRESET_ACTION* pExpectedResetAction


Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
DetermineIISResetState(
    IN  SC_HANDLE hIISAdminService,
    OUT IISRESET_ACTION* pExpectedResetAction
    )
{
    HRESULT hr = S_OK;


    // In normal configuration, QueryServiceConfig2 is returning that we need
    //  atleast 136 bytes to retreive this data.  I suspect that the extra bytes 
    // ( SERVICE_FAILURE_ACTIONS is only 20 bytes ) are for the extra memory
    // that the actions point to at the end.  Note that the below code will 
    // adjust if this guess is not correct.

    BUFFER FailureDataBuffer(150);
    SERVICE_FAILURE_ACTIONS* pFailureActions = NULL;
    DWORD dwBytesNeeded = 0;
    BOOL fRunFileConfigured = FALSE;

    IISRESET_ACTION ResetAction = NoReset;

    DBG_ASSERT ( hIISAdminService != NULL );
    DBG_ASSERT ( pExpectedResetAction != NULL );

    // Check if IISReset is enabled in the registry, if it is not then
    // don't bother with the scm.
    // Issue which is beter to check first?  Can do it either way.
    //
    if ( IsIISResetEnabled() == FALSE )
    {
        ResetAction = NoReset;
        goto exit;
    }

    // Need to find out if IISReset is set on the IISAdmin Service
    // and need to also figure out if it has a command line argument for
    // partial reset.

    if ( ! QueryServiceConfig2( hIISAdminService,
                                SERVICE_CONFIG_FAILURE_ACTIONS,
                                (LPBYTE) FailureDataBuffer.QueryPtr(),
                                FailureDataBuffer.QuerySize(),
                                &dwBytesNeeded ) )
    {
        DWORD dwErr = GetLastError();

        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            // try again with the larger size before failing
             
            if ( !FailureDataBuffer.Resize( dwBytesNeeded ) )
            {
                hr = HRESULT_FROM_WIN32 ( GetLastError() );

                // error case, always spew
                DBGPRINTF((DBG_CONTEXT, "Failed to resize the buffer to the appropriate size, "
                                        "hr = %08x attempted size = %d\n",
                                        hr,
                                        dwBytesNeeded));

                goto exit;
            }

            if ( ! QueryServiceConfig2( hIISAdminService,
                                        SERVICE_CONFIG_FAILURE_ACTIONS,
                                        (LPBYTE) FailureDataBuffer.QueryPtr(),
                                        FailureDataBuffer.QuerySize(),
                                        &dwBytesNeeded ) )

            {
                hr = HRESULT_FROM_WIN32 ( GetLastError () );

                // error case, always spew
                DBGPRINTF((DBG_CONTEXT, "( 1 ) Failed to query the IISAdmin service config, "
                                        "hr = %08x bytes needed = %d\n",
                                        hr,
                                        dwBytesNeeded));

                goto exit;
            }
        }
        else  // not a resizing issue.
        {
            hr = HRESULT_FROM_WIN32( dwErr );

            // error case, always spew
            DBGPRINTF((DBG_CONTEXT, "( 2 ) Failed to query the IISAdmin service config, "
                                    "hr = %08x bytes needed = %d\n",
                                    hr,
                                    dwBytesNeeded));
            goto exit;
        }

    }

    pFailureActions = reinterpret_cast<SERVICE_FAILURE_ACTIONS*>( FailureDataBuffer.QueryPtr() );

    // check that atleast one of the actions are set to run a file, 
    // if they are then check the command line argument.
    for ( DWORD i = 0; i < pFailureActions->cActions; i++ )
    {
        if ( pFailureActions->lpsaActions[i].Type == SC_ACTION_RUN_COMMAND )
        {
            fRunFileConfigured = TRUE;
            break;
        }
    }

    // If we didn't find any actions configured to run then we 
    // need to search no farther.  Reset is not setup.
    if ( !fRunFileConfigured )
    {
        ResetAction = NoReset;
        goto exit;
    }

    // Now that we know that we are planning on running an action
    // we need to check the command line argument
    if ( pFailureActions->lpCommand == NULL )
    {
        // This is the default value, but just in case it changes
        // we are setting it here too.
        ResetAction = NoReset;
        goto exit;
    }

    IF_DEBUG ( INET_MONITOR )
    {
        DBGPRINTF((DBG_CONTEXT, "IISAdmin pFailureActions = %S \n ",
                                pFailureActions->lpCommand));
    }

    // first convert the FailureActions command line to lower case.
    // this does an inplace conversion.  the return value is the
    // same as the string passed in so no need to check it.
    _wcslwr( pFailureActions->lpCommand );

    if ( wcsstr( pFailureActions->lpCommand, L"iisreset" ) == NULL )
    {
        // we know that we don't have iisreset set on iisadmin
        ResetAction = NoReset;
        goto exit;
    }

    if ( wcsstr( pFailureActions->lpCommand, L"/start" ) == NULL )
    {
        // at this point we know that iisreset is on, but the endure
        // flag is not set.  so we want to just wait to be recycled.

        ResetAction = FullReset;
        goto exit;
    }
    else
    {
        // if we did find the flag then we can assume that we are
        // going to attempt to stay up during the recycle.
        ResetAction = InetinfoResetOnly;
        goto exit;
    }


exit:

    // If we aren't going to fail the routine
    // we should set the out parameter.
    if ( SUCCEEDED ( hr ) )
    {
        *pExpectedResetAction = ResetAction;
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    This routine handles all the monitoring of the IISAdmin process and 
    the decision making logic to decide what to do when the process has
    problems.  It will used the callback functions provided to let the
    service know what it needs to do in case of a IISAdmin crash.

Arguments:

    LPVOID pCallbackFcnAsLPVoid -- pointer to the callback function.

Return Value:

    HRESULT.

--***************************************************************************/
DWORD WINAPI
StartMonitoring(
    LPVOID pCallbackFcnAsLPVoid
    )
{
    HRESULT hr = S_OK;

    // cast the callback function to a usable type
    // issue - should this be some sort of reinterpret cast?
    PFN_IISAdminNotify pCallbackFcn = (PFN_IISAdminNotify) pCallbackFcnAsLPVoid;

    //
    // Need to find the inetinfo process id 
    // 
    SC_HANDLE hSCM = OpenSCManager( NULL,  // local machine
                                    NULL,  // services active database
                                    GENERIC_READ );
    if ( hSCM == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Failed to open the SCMManager, "
                                "hr = %08x\n",
                                hr));

        goto exit;
    }

    SC_HANDLE hService = OpenService( hSCM,
                                      L"IISADMIN",
                                      GENERIC_READ );

    if ( hService == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Failed to open the IISADMIN service, "
                                "hr = %08x\n",
                                hr));

        goto exit;
    }

    BOOL fRehook = FALSE;
    do
    {
        hr = MonitorProcess ( hService, pCallbackFcn, &fRehook );

    } while ( fRehook );

    if ( FAILED ( hr ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Failed monitoring of the process, "
                                "hr = %08x\n",
                                hr));

        goto exit;
    }


exit:

    if ( hService )
    {
        CloseServiceHandle ( hService );
        hService = NULL;
    }

    if ( hSCM )
    {
        CloseServiceHandle ( hSCM );
        hSCM = NULL;
    }

    return hr;
}

/***************************************************************************++

Routine Description:

  Routine figures out the process that contains iisadmin and returns
  a handle to it.

Arguments:

    IN SC_HANDLE  hService,
    OUT HANDLE* phInetinfoProcess 


Return Value:

    HRESULT

--***************************************************************************/
HRESULT
GetProcessHandleForInetinfo(
    IN  SC_HANDLE  hService,
    OUT HANDLE*    phInetinfoProcess 
    )
{
    HRESULT hr = S_OK;
    DWORD NumTries = 0;
    BOOL fContinue = TRUE;
    SERVICE_STATUS_PROCESS  statusProcess;
    DWORD dwBytesNeeded = 0;
    HANDLE hInetinfoProcess = NULL;

    DBG_ASSERT ( phInetinfoProcess != NULL );
    *phInetinfoProcess = NULL;

    //
    // Get the current service status for the IISAdmin Service.
    //
    if ( !QueryServiceStatusEx( hService, 
                                SC_STATUS_PROCESS_INFO,
                                (LPBYTE) &statusProcess,
                                sizeof ( statusProcess ),
                                &dwBytesNeeded ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Failed querying the iisadmin service for it's process info, "
                                "hr = %08x, BytesNeeded = %d\n",
                                hr,
                                dwBytesNeeded));

        goto exit;
    }

    //
    // do this in a loop incase the process id is change on us.
    //
    do
    {
        //
        // grab the process id that we are holding so
        // that we can make sure the process id doesn't change
        // while we are openning the process.
        //

        DWORD dwProcessId = statusProcess.dwProcessId;
        //
        // Use the process id to grab the inetinfo process.
        //
        hInetinfoProcess = OpenProcess( SYNCHRONIZE,
                                        FALSE,
                                        dwProcessId );

        if ( hInetinfoProcess == NULL ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            // error case, always spew
            DBGPRINTF((DBG_CONTEXT, "Could not open the inetinfo process, "
                                    "hr = %08x\n",
                                    hr));

            goto exit;
        }

        // Need to check that we got the correct process ( could of changed,
        // since we last got the process id )

        //
        // Get the current service status for the IISAdmin Service.
        //
        if ( !QueryServiceStatusEx( hService, 
                                    SC_STATUS_PROCESS_INFO,
                                    (LPBYTE) &statusProcess,
                                    sizeof ( statusProcess ),
                                    &dwBytesNeeded ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            // error case, always spew
            DBGPRINTF((DBG_CONTEXT, "Failed querying the iisadmin service for it's process info, "
                                    "hr = %08x, BytesNeeded = %d\n",
                                    hr,
                                    dwBytesNeeded));

            goto exit;
        }

        if ( dwProcessId == statusProcess.dwProcessId )
        {
            // we have the correct handle.
            fContinue = FALSE;
        }
        else
        {
            // 5 is a completely random number, but if we have not gotten it right by the 
            // 5th time, something is more than a little wrong.  Fail the hookup.
            if ( NumTries > 5 ) 
            {
                // error case, always spew
                DBGPRINTF((DBG_CONTEXT, "Process id for the process we got and the current "
                                        "inetinfo process don't match, failing the hookup \n "));

                hr = E_UNEXPECTED;

                fContinue = FALSE;
            }
            else
            {
                // error case, always spew ( we should never really have to try more than once )
                DBGPRINTF((DBG_CONTEXT, "Process id for the process we got and the current "
                                        "inetinfo process don't match, trying again \n "));

                // need to release the process handle.
                DBG_ASSERT ( hInetinfoProcess != NULL );
                CloseHandle ( hInetinfoProcess );
                hInetinfoProcess = NULL;

                NumTries++;
            }
        } 


    } while ( fContinue );

exit:

    if ( SUCCEEDED ( hr ) ) 
    {
        *phInetinfoProcess = hInetinfoProcess;
    }
    else
    {
        if ( hInetinfoProcess != NULL )
        {
            CloseHandle ( hInetinfoProcess );
            hInetinfoProcess = NULL;
        }
    }

    return hr;

}

/***************************************************************************++

Routine Description:

    Routine is used to monitor the inetinfo process and initiate appropriate
    actions when there is a problem.  All code in this routine can be repeatedly
    called, for instance if we think we have recovered from a problem this function
    will automatically be called to start us monitoring again.

Arguments:

    IN SC_HANDLE  hService,
    IN PFN_IISAdminNotify pCallbackFcn,
    IN OUT BOOL* pfRehook


Return Value:

    HRESULT. 

--***************************************************************************/
HRESULT
MonitorProcess(
    IN SC_HANDLE  hService,
    IN PFN_IISAdminNotify pCallbackFcn,
    IN OUT BOOL* pfRehook
    )
{

    HRESULT hr = S_OK;
    HANDLE hInetinfoProcess = NULL;

    DBG_ASSERT ( hService != NULL );
    DBG_ASSERT ( pfRehook != NULL );

    BOOL fRehook = *pfRehook;
    *pfRehook = FALSE;

    DBG_ASSERT ( pCallbackFcn != NULL );

    //
    // Get the current process handle for inetinfo.
    //
    hr = GetProcessHandleForInetinfo ( hService,
                                       &hInetinfoProcess );
    if ( FAILED ( hr ) ) 
    {

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Failed to get inetinfo process handle "
                                "hr = %08x\n",
                                hr));

        goto exit;
    }


    // 
    // Now that we have the process and we are about to wait on it, go 
    // ahead and first tell the service that it can rehook, if we need to.
    //
    if ( fRehook )
    {
        //
        // Note:  This path can not end up calling the StopIISAdminMonitor or 
        //        we will hit a dead lock.  While we could stop the StopIISAdminMonitor
        //        from waiting for the thread to exit, we would give up the 
        //        ability during the shutdown to know that we are free of this thread.
        //
        hr = pCallbackFcn(RehookAfterInetinfoCrash);
        if ( FAILED ( hr ) ) 
        {
            // error case, always spew
            DBGPRINTF((DBG_CONTEXT, "Rehook callback failed, "
                                    "hr = %08x\n",
                                    hr));

            goto exit;
        }

    }

    // 
    // Setup the wait handles array
    // and wait on either inetinfo to have a problem
    // or for us to be told to stop monitoring the process
    //

    HANDLE WaitHandles[2];

    WaitHandles[0] = g_IISAdminMonitorShutdownEvent;
    WaitHandles[1] = hInetinfoProcess;

    DWORD dwWaitResult = WaitForMultipleObjects( 2, 
                                           WaitHandles,
                                           FALSE,  // return if any handles signal
                                           INFINITE );


    IF_DEBUG ( INET_MONITOR )
    {
        DBGPRINTF((DBG_CONTEXT, "WaitResult = %d \n", dwWaitResult ));
    }

    if ( dwWaitResult == WAIT_FAILED )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "WaitForMultipleObjects failed, "
                                "hr = %08x\n",
                                 hr));

        goto exit;
    }

    //
    // Need to determine if we are just shutting down or if we have
    // an event we need to process.
    //
    if ( dwWaitResult == WAIT_OBJECT_0 )
    {
        DBG_ASSERT ( hr == S_OK );
        // we are just trying to shutdown.
        goto exit;
    }


    // Assume inetinfo has signalled.
    DBG_ASSERT ( dwWaitResult == WAIT_OBJECT_0 + 1 );

    //
    // Note:  The this routine may not call the
    //        StopIISAdminMonitor routine or we will
    //        deadlock.  ( There is an assert to protect
    //        in checked builds )
    //
    hr = pCallbackFcn(NotifyAfterInetinfoCrash);
    if ( FAILED ( hr ) ) 
    {
        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Notify callback failed, "
                                "hr = %08x\n",
                                hr));

        goto exit;
    }

    //
    // we need to get the configuration information for the 
    // handling the crash correctly.  this is read everytime
    // from the registry, but if inetinfo is crashing, performance
    // is not the most important consideration.
    //
    // Note that this routine returns VOID.
    //
    DWORD msWaitForServiceShutdown;
    DWORD msWaitForInetinfoToRestart;
    DWORD msCheckIntervalForInetinfoToRestart;

    GetRegistryControlsForInetinfoCrash( &msWaitForServiceShutdown,
                                         &msWaitForInetinfoToRestart,
                                         &msCheckIntervalForInetinfoToRestart );
    //
    // Now go ahead and figure out what specific action
    // we need to take.
    //
    IISRESET_ACTION ExpectedResetAction;

    // Need to figure out what the correct behavior should be.
    hr = DetermineIISResetState(hService, &ExpectedResetAction);
    if ( FAILED ( hr ) )
    {
        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Determining IISResetAction failed, "
                                "hr = %08x\n",
                                hr));

        goto exit;
    }

    IF_DEBUG ( INET_MONITOR )
    {
        DBGPRINTF((DBG_CONTEXT, "Reset action is %d \n",
                                (DWORD) ExpectedResetAction));
    }

    switch ( ExpectedResetAction )
    {
        case ( NoReset ):

            // don't need to do anything, the default path is to 
            // call shutdown on our way out.

        break;

        case ( FullReset ):

            if ( WaitForSingleObject( g_IISAdminMonitorShutdownEvent, 
                                      msWaitForServiceShutdown ) 
                 == WAIT_OBJECT_0 )
            {
                // just let the system shutdown, don't need to 
                // stop and call shutdown first.
                goto exit;
            }
                
        break;

        case ( InetinfoResetOnly ):

            SERVICE_STATUS_PROCESS  statusProcess;
            DWORD dwBytesNeeded;

            for ( DWORD i = 0; 
                  i < msWaitForInetinfoToRestart; 
                  i = i + msCheckIntervalForInetinfoToRestart )
            {
                // rest a while
                Sleep( msCheckIntervalForInetinfoToRestart );

                if ( !QueryServiceStatusEx( hService, 
                                            SC_STATUS_PROCESS_INFO,
                                            (LPBYTE) &statusProcess,
                                            sizeof ( statusProcess ),
                                            &dwBytesNeeded ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );

                    // error case, always spew
                    DBGPRINTF((DBG_CONTEXT, "Failed querying the iisadmin service for it's process info, "
                                            "hr = %08x, BytesNeeded = %d\n",
                                            hr,
                                            dwBytesNeeded));

                    goto exit;
                }
                
                // see if the service is back up and running
                if ( statusProcess.dwCurrentState == SERVICE_RUNNING ) 
                {
                    //
                    // signal to call the rehook function once we are
                    // monitoring again.
                    //

                    *pfRehook = TRUE;
                    goto exit;
                }
                
            }

        break;

        default:
            DBG_ASSERT ( 0 );
    }

    DBG_ASSERT ( *pfRehook == FALSE );

    // At this point we know that we need to tell the service to shutdown
    // so we will before we exit.
    //
    // Note:  The this routine may not call the
    //        StopIISAdminMonitor routine or we will
    //        deadlock.  ( There is an assert to protect
    //        in checked builds )
    //
    hr = pCallbackFcn( ShutdownAfterInetinfoCrash );
    if ( FAILED ( hr ) ) 
    {
        // error case, always spew
        DBGPRINTF((DBG_CONTEXT, "Shutdown callback failed, "
                                "hr = %08x\n",
                                hr));

        goto exit;
    }

exit:

    if ( hInetinfoProcess != NULL )
    {
        CloseHandle ( hInetinfoProcess );
        hInetinfoProcess = NULL;
    }

    return hr;

}  // MonitorProcess
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\alloc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    Alloc.cpp

Abstract:
    Custom heap allocator

   Author:
       George V. Reilly      (GeorgeRe)     Oct-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/11/1999 - Initial

--*/

#include "precomp.hxx"
#include "alloc.h"
#include <irtldbg.h>


// Private heap for IIS

HANDLE g_hHeap = NULL;

BOOL
WINAPI
IisHeapInitialize()
{
    g_hHeap = ::HeapCreate(0, 0, 0);
    return (g_hHeap != NULL);
}

VOID
WINAPI
IisHeapTerminate()
{
    if (g_hHeap)
    {
        IRTLVERIFY(::HeapDestroy(g_hHeap));
        g_hHeap = NULL;
    }
}

// Private IIS heap
HANDLE
WINAPI 
IisHeap()
{
    IRTLASSERT(g_hHeap != NULL);
    return g_hHeap;
}

// Allocate dwBytes
LPVOID
WINAPI
IisMalloc(
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapAlloc( g_hHeap, 0, dwBytes );
}

// Allocate dwBytes. Memory is zeroed
LPVOID
WINAPI
IisCalloc(
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapAlloc( g_hHeap, HEAP_ZERO_MEMORY, dwBytes );
}

// Reallocate lpMem to dwBytes
LPVOID
WINAPI
IisReAlloc(
    IN LPVOID lpMem,
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapReAlloc( g_hHeap, 0, lpMem, dwBytes);
}

// Free lpMem
BOOL
WINAPI
IisFree(
    IN LPVOID lpMem)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapFree( g_hHeap, 0, lpMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\dbgutil.h ===
/*++

   Copyright    (c)   1994-1998    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

    
// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_ALLOC_CACHE          0x01000000
# define DEBUG_SCHED                0x02000000
# define DEBUG_RESOURCE             0x04000000
# define DEBUG_INET_MONITOR         0x08000000

// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "sched.hxx"
#include "lkrhash.h"
#include "alloc.h"
#include "_locks.h"
#include "tokenacl.hxx"
#include "datetime.hxx"

/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();
                                                                               //
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\W3SVC"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisUtilRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IisUtil";

//
// Stuff to handle components which must initialized/terminated outside
// the loader lock
//

INT                     g_cRefs;
CRITICAL_SECTION        g_csInit;
extern CRITICAL_SECTION   g_SchedulerCritSec;


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {       
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("iisutil");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisUtilRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "IisUtil::DllMain::DLL_PROCESS_ATTACH\n"));
        }

        Locks_Initialize();
        
        INITIALIZE_CRITICAL_SECTION(&g_csInit);

        InitializeCriticalSectionAndSpinCount(&g_SchedulerCritSec, 
                                                 0x80000000 );        
        
        InitializeSecondsTimer();

        DBG_REQUIRE( IisHeapInitialize() );

        DBG_REQUIRE( ALLOC_CACHE_HANDLER::Initialize() );

        fReturn = LKRHashTableInit();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
//      if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "IisUtil::DllMain::DLL_PROCESS_DETACH\n"));
            }

            LKRHashTableUninit();
    
            ALLOC_CACHE_HANDLER::Cleanup();
        
            IisHeapTerminate();

            TerminateSecondsTimer();

            DeleteCriticalSection(&g_SchedulerCritSec);

            DeleteCriticalSection(&g_csInit);
       
            Locks_Cleanup();

            DELETE_DEBUG_PRINT_OBJECT();
        }

    }

    return fReturn;
} // DllMain()

BOOL
WINAPI 
InitializeIISUtil(
    VOID
)
{
    BOOL fReturn = TRUE;  // ok
    HRESULT hr = NO_ERROR;

    EnterCriticalSection(&g_csInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "InitializeIISUtil, %d %s\n",
                   g_cRefs, (g_cRefs == 0 ? "initializing" : "")));

    if (g_cRefs++ == 0)
    {
        if (SchedulerInitialize())
        {
            DBG_REQUIRE(ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval());
        
            IF_DEBUG(INIT_CLEAN)
                DBGPRINTF((DBG_CONTEXT, "Scheduler Initialized\n"));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT, "Initializing Scheduler Failed\n"));
            fReturn = FALSE;
        }
    }

    hr = InitializeTokenAcl();

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        fReturn = FALSE;
    }

    InitializeDateTime();

    LeaveCriticalSection(&g_csInit);

    return fReturn;
}



/////////////////////////////////////////////////////////////////////////////
// Additional termination needed

VOID
WINAPI 
TerminateIISUtil(
    VOID
)
{
    EnterCriticalSection(&g_csInit);

    IF_DEBUG(INIT_CLEAN)
        DBGPRINTF((DBG_CONTEXT, "TerminateIISUtil, %d %s\n",
                   g_cRefs, (g_cRefs == 1 ? "Uninitializing" : "")));

    if (--g_cRefs == 0)
    {
        DBG_REQUIRE(ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval());
    
        SchedulerTerminate();
    }

    TerminateDateTime();

    UninitializeTokenAcl();

    LeaveCriticalSection(&g_csInit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\chunkbuffer.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     headerbuffer.cxx

   Abstract:
     Maintains a list of response/request headers and takes care of all the
     buffering goo.  The goo here is keeping useful information in a buffer
     which can be realloced (and thus re-based) under us.
 
   Author:
     Bilal Alam (balam)             18-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "chunkbuffer.hxx"

HRESULT
CHUNK_BUFFER::AllocateSpace(
    DWORD               cbSize,
    CHAR * *            ppvBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    cbSize - Size needed
    ppvBuffer - Set to point to buffer on success
    
Return Value:

    HRESULT

--*/
{
    
    HRESULT         hr = NO_ERROR;
    BYTE *          pDest;
   
    if ( ppvBuffer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    //
    // Resize the buffer if needed
    //
    
    if ( _pBufferCurrent->_cbSize < cbSize + _pBufferCurrent->_cbOffset )
    {
        hr = AddNewBlock( cbSize );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Copy the actual string
    //

    pDest = ((BYTE*) (_pBufferCurrent->_pchBuffer)) + _pBufferCurrent->_cbOffset;

    _pBufferCurrent->_cbOffset += cbSize;

    *ppvBuffer = (CHAR *)pDest;
    
    return NO_ERROR;
    
}

HRESULT
CHUNK_BUFFER::AllocateSpace(
    DWORD               cbSize,
    WCHAR * *           ppvBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    cbSize - Size needed
    ppvBuffer - Set to point to buffer on success
    
Return Value:

    HRESULT

--*/
{
    //
    // Advance the current offset by 1 if it is not aligned to WCHAR
    //
    if (_pBufferCurrent->_cbOffset % sizeof(WCHAR))
    {
        _pBufferCurrent->_cbOffset++;
    }
   
    return AllocateSpace(cbSize, (CHAR **)ppvBuffer);
}

HRESULT
CHUNK_BUFFER::AllocateSpace(
    CHAR *              pszHeaderValue,
    DWORD               cchHeaderValue,
    CHAR * *            ppszBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    pszHeaderValue - String to duplicate into buffer
    cchHeaderValue - Character count of string
    ppszBuffer - Set to point to space allocated for string
    
Return Value:

    HRESULT

--*/
{
    DWORD           cbRequired;
    DWORD           cbNewBlock;
    BUFFER_LINK *   pBufferLink;
    HRESULT         hr = NO_ERROR;
    BYTE *          pDest;
   
    if ( pszHeaderValue == NULL ||
         ppszBuffer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Resize the buffer if needed
    //
    
    cbRequired = ( cchHeaderValue + 1 );
    if ( _pBufferCurrent->_cbSize < cbRequired + _pBufferCurrent->_cbOffset )
    {
        hr = AddNewBlock( cbRequired );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Copy the actual string
    //

    pDest = ((BYTE*) (_pBufferCurrent->_pchBuffer)) + _pBufferCurrent->_cbOffset;

    memcpy( pDest,
            pszHeaderValue,
            cbRequired );

    _pBufferCurrent->_cbOffset += cbRequired;

    *ppszBuffer = (CHAR *) pDest;
    
    return NO_ERROR;
}

HRESULT
CHUNK_BUFFER::AllocateSpace(
    LPWSTR              pszHeaderValue,
    DWORD               cchHeaderValue,
    LPWSTR *            ppszBuffer
)
/*++

Routine Description:

    Allocate some space in internal buffer and return pointer

Arguments:

    pszHeaderValue - String to duplicate into buffer
    cchHeaderValue - Character count of string
    ppszBuffer - Set to point to space allocated for string
    
Return Value:

    HRESULT

--*/
{
    DWORD           cbRequired;
    DWORD           cbNewBlock;
    BUFFER_LINK *   pBufferLink;
    HRESULT         hr = NO_ERROR;
    BYTE *          pDest;
   
    if ( pszHeaderValue == NULL ||
         ppszBuffer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Advance the current offset by 1 if it is not aligned to WCHAR
    //
    if (_pBufferCurrent->_cbOffset % sizeof(WCHAR))
    {
        _pBufferCurrent->_cbOffset++;
    }
   
    //
    // Resize the buffer if needed
    //
    
    cbRequired = ( cchHeaderValue + 1 ) * sizeof( WCHAR );
    if ( _pBufferCurrent->_cbSize < cbRequired + _pBufferCurrent->_cbOffset )
    {
        cbNewBlock = max( cbRequired + sizeof(BUFFER_LINK), BUFFER_MIN_SIZE ); 

        pBufferLink = (BUFFER_LINK*) LocalAlloc( LPTR,
                                                 cbNewBlock );
        if ( pBufferLink == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        pBufferLink->_cbSize = cbNewBlock - sizeof( BUFFER_LINK );
        pBufferLink->_pNext = NULL;
        pBufferLink->_cbOffset = 0;
        
        //
        // Link up the buffer
        //
        
        _pBufferCurrent->_pNext = pBufferLink;
        _pBufferCurrent = pBufferLink;
    }
    
    //
    // Copy the actual string
    //

    pDest = ((BYTE*) (_pBufferCurrent->_pchBuffer)) + _pBufferCurrent->_cbOffset;

    memcpy( pDest,
            pszHeaderValue,
            cbRequired );

    _pBufferCurrent->_cbOffset += cbRequired;

    *ppszBuffer = (LPWSTR) pDest;
    
    return NO_ERROR;
}

HRESULT 
CHUNK_BUFFER::AddNewBlock( 
    DWORD cbSize 
    )
/*++

Routine Description:

    If there is currently not enough space in internal buffer
    get new block off the heap (of minimum cbSize) 

Arguments:

    cbSize - number of bytes requested by caller of AllocateSpace
    
Return Value:

    HRESULT

--*/    
{
    DWORD           cbNewBlock;
    BUFFER_LINK *   pBufferLink;
    
    cbNewBlock = max( cbSize + sizeof(BUFFER_LINK), BUFFER_MIN_SIZE ); 

    pBufferLink = (BUFFER_LINK*) LocalAlloc( LPTR,
                                             cbNewBlock );
    if ( pBufferLink == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    pBufferLink->_cbSize = cbNewBlock - sizeof( BUFFER_LINK );
    pBufferLink->_pNext = NULL;
    pBufferLink->_cbOffset = 0;

    _dwHeapAllocCount++;
    
    //
    // Link up the buffer
    //
    
    _pBufferCurrent->_pNext = pBufferLink;
    _pBufferCurrent = pBufferLink;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\datetime.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      datetime.cxx

   Abstract:

      This module exports common functions for date and time fields,
      Expanding into strings and manipulation.

   Author:

           Murali R. Krishnan    ( MuraliK )    3-Jan-1995

--*/

#include "precomp.hxx"

#include <stdlib.h>


# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#include <datetime.hxx>


class dllexp CDateTime
{
public:
    FILETIME_UINT64 m_ftu;
    SYSTEMTIME      m_st;
    
    CDateTime()
    { /* do nothing */ }

    CDateTime(const SYSTEMTIME& rst)
    { SetTime(rst); }
      
    CDateTime(const FILETIME& rft)
    { SetTime(rft); }

    CDateTime(const FILETIME& rft, const SYSTEMTIME& rst)
    { m_ftu.ft = rft; m_st = rst; }
    
    BOOL
    GetCurrentTime()
    {
        GetSystemTimeAsFileTime(&m_ftu.ft);
        return FileTimeToSystemTime(&m_ftu.ft, &m_st);
    }

    BOOL
    SetTime(const SYSTEMTIME& rst)
    { m_st = rst; return SystemTimeToFileTime(&m_st, &m_ftu.ft); }

    BOOL
    SetTime(const FILETIME& rft)
    { m_ftu.ft = rft; return FileTimeToSystemTime(&m_ftu.ft, &m_st); }
};



static const CHAR  g_rgchTwoDigits[100][2] =
{
    { '0', '0' }, { '0', '1' }, { '0', '2' }, { '0', '3' }, { '0', '4' },
    { '0', '5' }, { '0', '6' }, { '0', '7' }, { '0', '8' }, { '0', '9' },

    { '1', '0' }, { '1', '1' }, { '1', '2' }, { '1', '3' }, { '1', '4' },
    { '1', '5' }, { '1', '6' }, { '1', '7' }, { '1', '8' }, { '1', '9' },

    { '2', '0' }, { '2', '1' }, { '2', '2' }, { '2', '3' }, { '2', '4' },
    { '2', '5' }, { '2', '6' }, { '2', '7' }, { '2', '8' }, { '2', '9' },

    { '3', '0' }, { '3', '1' }, { '3', '2' }, { '3', '3' }, { '3', '4' },
    { '3', '5' }, { '3', '6' }, { '3', '7' }, { '3', '8' }, { '3', '9' },

    { '4', '0' }, { '4', '1' }, { '4', '2' }, { '4', '3' }, { '4', '4' },
    { '4', '5' }, { '4', '6' }, { '4', '7' }, { '4', '8' }, { '4', '9' },

    { '5', '0' }, { '5', '1' }, { '5', '2' }, { '5', '3' }, { '5', '4' },
    { '5', '5' }, { '5', '6' }, { '5', '7' }, { '5', '8' }, { '5', '9' },

    { '6', '0' }, { '6', '1' }, { '6', '2' }, { '6', '3' }, { '6', '4' },
    { '6', '5' }, { '6', '6' }, { '6', '7' }, { '6', '8' }, { '6', '9' },

    { '7', '0' }, { '7', '1' }, { '7', '2' }, { '7', '3' }, { '7', '4' },
    { '7', '5' }, { '7', '6' }, { '7', '7' }, { '7', '8' }, { '7', '9' },

    { '8', '0' }, { '8', '1' }, { '8', '2' }, { '8', '3' }, { '8', '4' },
    { '8', '5' }, { '8', '6' }, { '8', '7' }, { '8', '8' }, { '8', '9' },

    { '9', '0' }, { '9', '1' }, { '9', '2' }, { '9', '3' }, { '9', '4' },
    { '9', '5' }, { '9', '6' }, { '9', '7' }, { '9', '8' }, { '9', '9' },
};


//
//  Constants
//

#define APPEND_STR(a,b)  \
    {CopyMemory(a,b,sizeof(b));  a += sizeof(b)-sizeof(CHAR);}

#define APPEND_PSZ( pszTail, psz )          \
    { DWORD cb = strlen( psz );             \
      CopyMemory( (pszTail), (psz), cb + 1 );\
      (pszTail) += cb;                      \
    }

//
// Makes a two-digit zero padded number (i.e., "23", or "05")
//

inline
VOID
AppendTwoDigits(
    CHAR*& rpszTail,
    DWORD Num
    )
{
    if ( Num < 100 )
    {
        rpszTail[0] = g_rgchTwoDigits[Num][0];
        rpszTail[1] = g_rgchTwoDigits[Num][1];
        rpszTail[2] = '\0';
        rpszTail += 2;
    }
    else
    {
        DBG_ASSERT(!"Num >= 100");
    }
}


//
// Years conversion
//


#define MAX_CACHED_YEARS 32
static DWORD g_nMinYear = 0, g_nMaxYear = 0;
static char  g_aszYears[MAX_CACHED_YEARS][4+1];

typedef CDataCache<CDateTime> CCacheTime;
static CCacheTime             g_ctCurrentTime;

void
InitializeDateTime()
{
    SYSTEMTIME    st;
    GetSystemTime(&st);

    g_nMinYear = st.wYear - MAX_CACHED_YEARS / 2;
    g_nMaxYear = g_nMinYear + MAX_CACHED_YEARS - 1;

    DBG_ASSERT(1000 <= g_nMinYear  &&  g_nMaxYear <= 9999);

    for (DWORD i = g_nMinYear;  i <= g_nMaxYear;  i++)
    {
        _itoa( i, g_aszYears[i - g_nMinYear], 10 );
    }

    CDateTime dt(st);
    g_ctCurrentTime.Write(dt);
}


void
TerminateDateTime()
{
    // nothing to be done, at least for now
}


inline
VOID
AppendYear(
    CHAR* &rpszTail,
    DWORD dwYear
    )
{
    DBG_ASSERT(g_nMinYear >= 1000);
    DWORD i = dwYear - g_nMinYear;
    
    if (i < MAX_CACHED_YEARS)
    {
        DBG_ASSERT(g_nMinYear <= dwYear  &&  dwYear <= g_nMaxYear);
        const char* pszYear = g_aszYears[i];
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail++ = *pszYear++;
        *rpszTail = '\0';
    }
    else
    {
        CHAR  __ach[32];
        DBG_ASSERT( dwYear >= 1000 && dwYear <= 9999 );
        _itoa( dwYear, __ach, 10 );

        CopyMemory( rpszTail, __ach, 4+1 );
        rpszTail += 4;
    }
}


// Since ::GetSystemTime is relatively expensive (310 instructions) and
// ::GetSystemTimeAsFileTime is pretty cheap (20 instructions), we cache
// the SYSTEMTIME representation of the current time with an accuracy of
// 1.0 seconds.

BOOL
IISGetCurrentTime(
    OUT FILETIME*   pft,
    OUT SYSTEMTIME* pst)
{
    BOOL fUpdatedCachedTime = FALSE;
    CDateTime dt;
    
    while (! g_ctCurrentTime.Read(dt))
    {
        // empty loop
    }
    
    FILETIME_UINT64 ftu;
    GetSystemTimeAsFileTime(&ftu.ft);
    
    if (ftu.u64 - dt.m_ftu.u64 >= FILETIME_1_SECOND)
    {
#undef WT_INSTRUCTION_COUNTS
        
#ifndef WT_INSTRUCTION_COUNTS
        fUpdatedCachedTime = TRUE;
        dt.SetTime(ftu.ft);
        g_ctCurrentTime.Write(dt);
#endif
    }
    
    if (pft != NULL)
        *pft = dt.m_ftu.ft;
    if (pst != NULL)
        *pst = dt.m_st;

    return fUpdatedCachedTime;
}



/************************************************************
 *   Data
 ************************************************************/
static const CHAR* s_rgchDays[] =  {
    "Sun", "Mon", "Tue", "Wed",
    "Thu", "Fri", "Sat"
};

static const CHAR* s_rgchMonths[] = {
    "Jan", "Feb", "Mar", "Apr",
    "May", "Jun", "Jul", "Aug",
    "Sep", "Oct", "Nov", "Dec"
};

LPCSTR
DayOfWeek3CharNames(DWORD dwDayOfWeek)
{
    return s_rgchDays[dwDayOfWeek];
}

LPCSTR
Month3CharNames(DWORD dwMonth)
{
    return s_rgchMonths[dwMonth];
}

// Custom hash table for make_month() for mapping "Apr" to 4
static const CHAR MonthIndexTable[64] = {
   -1,'A',  2, 12, -1, -1, -1,  8, // A to G
   -1, -1, -1, -1,  7, -1,'N', -1, // F to O
    9, -1,'R', -1, 10, -1, 11, -1, // P to W
   -1,  5, -1, -1, -1, -1, -1, -1, // X to Z
   -1,'A',  2, 12, -1, -1, -1,  8, // a to g
   -1, -1, -1, -1,  7, -1,'N', -1, // f to o
    9, -1,'R', -1, 10, -1, 11, -1, // p to w
   -1,  5, -1, -1, -1, -1, -1, -1  // x to z
};


static const BYTE TensDigit[10] = { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 };


/************************************************************
 *    Functions
 ************************************************************/

WORD
iis_2atoi(
    PCHAR s
    )
/*++

    Converts a 2 character string to integer

    Arguments:
        s   String to convert

    Returns:
        numeric equivalent, 0 on failure.
--*/
{

    DWORD tens = s[0] - '0';
    DWORD ones = s[1] - '0';

    if ( (tens <= 9) && (ones <= 9) ) {
        return((WORD)(TensDigit[tens] + ones));
    }
    return(0);
}

#if 1
WORD
make_month(
    PCHAR s
    )
{
    UCHAR monthIndex;
    UCHAR c;
    LPCSTR monthString;

    //
    // use the third character as the index
    //

    c = (s[2] - 0x40) & 0x3F;

    monthIndex = MonthIndexTable[c];

    if ( monthIndex < 13 ) {
        goto verify;
    }

    //
    // ok, we need to look at the second character
    //

    if ( monthIndex == 'N' ) {

        //
        // we got an N which we need to resolve further
        //

        //
        // if s[1] is 'u' then Jun, if 'a' then Jan
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 1;
        } else {
            monthIndex = 6;
        }

    } else if ( monthIndex == 'R' ) {

        //
        // if s[1] is 'a' then March, if 'p' then April
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 3;
        } else {
            monthIndex = 4;
        }
    } else {
        goto error_exit;
    }

verify:

    monthString = s_rgchMonths[monthIndex-1];

    if ( (s[0] == monthString[0]) &&
         (s[1] == monthString[1]) &&
         (s[2] == monthString[2]) ) {

        return(monthIndex);

    } else if ( (toupper(s[0]) == monthString[0]) &&
                (tolower(s[1]) == monthString[1]) &&
                (tolower(s[2]) == monthString[2]) ) {

        return monthIndex;
    }

error_exit:
    return(0);

} // make_month
#else
int
make_month(
    CHAR * s
    )
{
    int i;

    for (i=0; i<12; i++)
        if (!_strnicmp(s_rgchMonths[i], s, 3))
            return i + 1;
    return 0;
}
#endif

BOOL
SystemTimeToGMT(
    IN  const SYSTEMTIME & st,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    DBG_ASSERT( pszBuff != NULL);

    if ( cbBuff < GMT_STRING_SIZE )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    APPEND_PSZ( pszBuff, s_rgchDays[st.wDayOfWeek] );   // 0-based
    *pszBuff++ = ',';
    *pszBuff++ = ' ';
    AppendTwoDigits( pszBuff, st.wDay );
    *pszBuff++ = ' ';
    APPEND_PSZ( pszBuff, s_rgchMonths[st.wMonth - 1] ); // 1-based
    *pszBuff++ = ' ';
    AppendYear( pszBuff, st.wYear );
    *pszBuff++ = ' ';
    AppendTwoDigits( pszBuff, st.wHour );
    *pszBuff++ = ':';
    AppendTwoDigits( pszBuff, st.wMinute );
    *pszBuff++ = ':';
    AppendTwoDigits( pszBuff, st.wSecond );
    *pszBuff++ = ' ';
    *pszBuff++ = 'G';
    *pszBuff++ = 'M';
    *pszBuff++ = 'T';
    *pszBuff   = '\0';

    return ( TRUE);

} // SystemTimeToGMT()


BOOL
NtLargeIntegerTimeToLocalSystemTime(
    IN const LARGE_INTEGER * pliTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in Local Time zone.

  Arguments:
    pliTime        pointer to large integer containing the time in NT format.
    pst            pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            27-Apr-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG.
--*/
{
    FILETIME  ftLocal;

    if ( pliTime == NULL || pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    //  Convert the given large integer to local file time and
    //  then convert that to SYSTEMTIME.
    //   structure, containing the time details.
    //  I dont like this cast ( assumes too much about time structures)
    //   but again suitable methods are not available.
    //
    return (FileTimeToLocalFileTime((FILETIME *) pliTime,
                                     &ftLocal) &&
            FileTimeToSystemTime(&ftLocal, pst)
            );

} // NtLargeIntegerTimeToLocalSystemTime()


BOOL
SystemTimeToGMTEx(
    IN  const SYSTEMTIME & st,
    OUT CHAR *      pszBuff,
    IN  DWORD       cbBuff,
    IN  DWORD       csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;
    FILETIME    ft;

    DBG_ASSERT( pszBuff != NULL);

    //
    //  If an offset is specified, calculate that now
    //

    if (!SystemTimeToFileTime( &st, &ft )) {
        return(FALSE);
    }

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) FILETIME_1_SECOND;

    ft.dwHighDateTime = liTime.HighPart;
    ft.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
} // SystemTimeToGMTEx


BOOL
FileTimeToGMT(
    IN  const FILETIME   & ft,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      ft         File time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.
--*/
{
    SYSTEMTIME st;

    if (FileTimeToSystemTime(&ft, &st))
        return SystemTimeToGMT(st, pszBuff, cbBuff);
    else
        return FALSE;
}


BOOL
FileTimeToGMTEx(
    IN  const FILETIME   & ft,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff,
    IN  DWORD              csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      ft         File time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;

    DBG_ASSERT( pszBuff != NULL);

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) FILETIME_1_SECOND;

    FILETIME ft2 = ft;
    ft2.dwHighDateTime = liTime.HighPart;
    ft2.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft2, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
}

BOOL
NtLargeIntegerTimeToSystemTime(
    IN const LARGE_INTEGER & liTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in GMT

  Arguments:
    liTime             large integer containing the time in NT format.
    pst                pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            3-Jan-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG. Will that make a difference ? God knows.
       Or substitute whatever you want for God...
--*/
{
    FILETIME ft;

    if ( pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // convert li to filetime
    //

    ft.dwLowDateTime = liTime.LowPart;
    ft.dwHighDateTime = liTime.HighPart;

    //
    // convert to system time
    //

    if (!FileTimeToSystemTime(&ft,pst)) {
        return(FALSE);
    }

    return ( TRUE);

} // NtLargeIntegerTimeToSystemTime()

BOOL
NtSystemTimeToLargeInteger(
    IN  const SYSTEMTIME * pst,
    OUT LARGE_INTEGER *    pli
    )
{

    FILETIME ft;

    //
    // Convert to file time
    //

    if ( !SystemTimeToFileTime( pst, &ft ) ) {
        return(FALSE);
    }

    //
    // Convert file time to large integer
    //

    pli->LowPart = ft.dwLowDateTime;
    pli->HighPart = ft.dwHighDateTime;

    return(TRUE);
}

BOOL
StringTimeToFileTime(
    IN  const CHAR * pszTime,
    OUT LARGE_INTEGER * pliTime
    )
/*++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format

  Arguments:
    pszTime             String representation of time field
    pliTime             large integer containing the time in NT format.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library

--*/
{

    CHAR * s;
    SYSTEMTIME    st;

    if (pszTime == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    st.wMilliseconds = 0;

    if ((s = strchr(pszTime, ','))) {

        DWORD len;

        //
        // Thursday, 10-Jun-93 01:29:59 GMT
        // or: Thu, 10 Jan 1993 01:29:59 GMT */
        //

        s++;

        while (*s && *s==' ') s++;
        len = strlen(s);

        if (len < 18) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( *(s+2) == '-' ) {        /* First format */

            st.wDay = (WORD) atoi(s);
            st.wMonth = (WORD) make_month(s+3);
            st.wYear = (WORD) atoi(s+7);
            st.wHour = (WORD) atoi(s+10);
            st.wMinute = (WORD) atoi(s+13);
            st.wSecond = (WORD) atoi(s+16);

        } else {                /* Second format */

            if (len < 20) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }

            st.wDay = iis_2atoi(s);
            st.wMonth = make_month(s+3);
            st.wYear = iis_2atoi(s+7) * 100  +  iis_2atoi(s+9);
            st.wHour = iis_2atoi(s+12);
            st.wMinute = iis_2atoi(s+15);
            st.wSecond = iis_2atoi(s+18);

        }
    } else {    /* Try the other format:  Wed Jun  9 01:29:59 1993 GMT */

        s = (CHAR *) pszTime;
        while (*s && *s==' ') s++;

        if ((int)strlen(s) < 24) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        st.wDay = (WORD) atoi(s+8);
        st.wMonth = (WORD) make_month(s+4);
        st.wYear = (WORD) atoi(s+20);
        st.wHour = (WORD) atoi(s+11);
        st.wMinute = (WORD) atoi(s+14);
        st.wSecond = (WORD) atoi(s+17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if ( st.wYear < 1000 ) {
        if ( st.wYear < 50 ) {
            st.wYear += 2000;
        } else {
            st.wYear += 1900;
        }
    }

    if ( !NtSystemTimeToLargeInteger( &st,pliTime )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    return(TRUE);
}


/************************************************************
 *  Cached Date Time Formats
 *
 *  Formatting Date and Time for
 *    HTTP headers & Logging Requests
 *    is a costly operation.
 *  Using default NT Formatting operations with wsprintf()
 *    consumes about 6000 instructions/transaction
 *
 *  Following code addresses this issue by
 *   1) Caching formatted date/time pair for all purposes
 *   2) Caching is done at the granularity of seconds/minute
 *      If there is a match till seconds, we return entire
 *        formatted information.
 *      If there is a match till the minutes, then the seconds
 *        portion is over-written using a seconds-lookup-table.
 *
 *   Murali R. Krishnan (MuraliK)   23-Feb-1996
 ************************************************************/

//
// The delimiter string is :  <logDelimiterChar><blank>
// The delimiter char should be same as the one used for LOG_RECORD
//   in the file: ilogcls.cxx
//
const CHAR G_PSZ_LOG_DELIMITER[3] = ", ";



#ifdef ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  InterlockedIncrement( &m_nAccesses)
# define CdtCountMisses()    InterlockedIncrement( &m_nMisses)

# else  // ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  /* do nothing */
# define CdtCountMisses()    /* do nothing */

# endif // ENABLE_AUX_COUNTERS






VOID
DATETIME_FORMAT_ENTRY::CopyFormattedData(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime) const
{
    //
    // copy the formatted date/time information
    //
    
    CopyMemory(pchDateTime,
               m_rgchDateTime,
               m_cbDateTime
               );
    
    if ( m_stDateTime.wSecond != pst->wSecond) {
        
        //
        // seconds do not match. update seconds portion alone
        //
        
        LPSTR pch = pchDateTime + m_cchOffsetSeconds;
        
        *pch       = g_rgchTwoDigits[pst->wSecond][0];
        *(pch + 1) = g_rgchTwoDigits[pst->wSecond][1];
    }
    
    return;
}



BOOL
CDFTCache::CopyFormattedData(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime) const
{
    // See <readmost.hxx> for an explanation of this routine
    const LONG nSequence = _ReadSequence();
    
    // Is the data being updated on another thread?
    if (nSequence != UPDATING)
    { 
        // The weird const_cast syntax is necessitated by the volatile
        // attribute on m_tData (DATETIME_FORMAT_ENTRY).
        LPCSTR pchDate = FormattedBuffer();
        DWORD cbDateTime = DateTimeChars();
        
        // Copy the string
        CopyMemory(pchDateTime, pchDate, cbDateTime);
        
        if (Seconds() != pst->wSecond) {
            
            //
            // seconds do not match. update seconds portion alone
            //
            
            LPSTR pch = pchDateTime + OffsetSeconds();
            
            *pch       = g_rgchTwoDigits[pst->wSecond][0];
            *(pch + 1) = g_rgchTwoDigits[pst->wSecond][1];
        }

        // If the sequence number is unchanged, the read was valid.
        const LONG nSequence2 = _ReadSequence();

        return (nSequence == nSequence2);
    }

    return FALSE;
}



VOID
ASCLOG_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    CHAR rgchTime[25];
    CHAR * pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );


    //
    // Format date for Logging (dftLog)

    //  Format is:
    //      <Date><DelimiterString><Time><DelimiterString>
    //
    // We need to generate the date format again, only if it changes
    //

    pchDateTime = pdft->m_rgchDateTime;
    if ( !SameDate( &pdft->m_stDateTime, pst) ) {

        ::GetDateFormatA(LOCALE_SYSTEM_DEFAULT,
                                     LOCALE_NOUSEROVERRIDE,
                                     pst, NULL,
                                     pchDateTime,
                                     15);

        strcat( pchDateTime, G_PSZ_LOG_DELIMITER);

        //
        // cache the date length for future use.
        //

        pdft->m_cchDateLen = strlen( pchDateTime);

    }

    cchLen = pdft->m_cchDateLen;

    //
    // format the time portion
    //

    ::GetTimeFormatA( LOCALE_SYSTEM_DEFAULT,
                                 (LOCALE_NOUSEROVERRIDE |
                                  TIME_FORCE24HOURFORMAT|
                                  TIME_NOTIMEMARKER),
                                 pst, NULL,
                                 rgchTime, 15);

    DBG_ASSERT(strlen(rgchTime) + strlen( G_PSZ_LOG_DELIMITER) <
               sizeof(rgchTime));
    strcat( rgchTime, G_PSZ_LOG_DELIMITER);

    //
    // append time to date generated
    //

    DBG_ASSERT( cchLen > 0); // range is fine
    strcpy(pchDateTime + cchLen, rgchTime);

    DBG_ASSERT( strlen( pchDateTime) < sizeof( pdft->m_rgchDateTime));

    //
    // Calculate the offset for seconds based on time format.
    // the time is usually formatted as hh:mm:ss if wHour >= 10  Offset =6
    //       and is formatted as         h:mm:ss if wHour < 10   Offset =5
    //

    pdft->m_cchOffsetSeconds = ( cchLen + 5 + ((pst->wHour < 10) ? 0 : 1));

    //
    // !!! for the german locale, it's always hh:mm:ss
    //

    if ( pdft->m_rgchDateTime[pdft->m_cchOffsetSeconds] == ':' ) {
        pdft->m_cchOffsetSeconds++;
    }

    pdft->m_cbDateTime = strlen( pdft->m_rgchDateTime) + 1;
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // ASCLOG_DATETIME_CACHE::GenerateDateTimeString


VOID
EXTLOG_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

    Used for W3C Extended Logging format.
     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    PCHAR pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );

    //
    //  Format is:
    //      Date    YYYY-MM-DD
    //      Time    HH:MM:SS
    //

    pchDateTime = pdft->m_rgchDateTime;
    if ( !SameDate( &pdft->m_stDateTime, pst) ) {

        AppendYear( pchDateTime, pst->wYear );
        *pchDateTime++ = '-';
        AppendTwoDigits( pchDateTime, pst->wMonth );
        *pchDateTime++ = '-';
        AppendTwoDigits( pchDateTime, pst->wDay );

        //
        // cache the date length for future use.
        //

        pchDateTime++;
        pdft->m_cchDateLen = strlen( pdft->m_rgchDateTime );
        DBG_ASSERT( pdft->m_cchDateLen == 10 );

    } else {

        DBG_ASSERT( pdft->m_cchDateLen == 10 );
        pchDateTime += (pdft->m_cchDateLen+1);
    }

    cchLen = pdft->m_cchDateLen;

    //
    // format the time portion
    //

    AppendTwoDigits( pchDateTime, pst->wHour );
    *pchDateTime++ = ':';
    AppendTwoDigits( pchDateTime, pst->wMinute );
    *pchDateTime++ = ':';
    AppendTwoDigits( pchDateTime, pst->wSecond );
    pchDateTime++;

    //
    // Calculate the offset for seconds based on time format.
    // YYYY-MM-DD HH:MM:SS
    //

    pdft->m_cchOffsetSeconds = cchLen + 7;
    pdft->m_cbDateTime = DIFF(pchDateTime - (PCHAR)pdft->m_rgchDateTime);
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // EXTLOG_DATETIME_CACHE::GenerateDateTimeString



VOID
W3_DATETIME_CACHE::GenerateDateTimeString(
    IN PDFT_ENTRY pdft,
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    CHAR  rgchTime[25];
    PCHAR pchDateTime;
    DWORD cchLen;

    DBG_ASSERT( pdft != NULL  &&  pst != NULL );

    //
    // Format date for Logging (dftGmt)
    //  Format is:
    //   Date: <date-time> GMT\r\n
    //

    pchDateTime = pdft->m_rgchDateTime;

    static const char szDate[] = "Date: ";
    static const char szCRLF[] = "\r\n";

    CopyMemory( pchDateTime, szDate, sizeof(szDate) - 1 );
    pchDateTime += sizeof(szDate) - 1;

    if ( !::SystemTimeToGMT( *pst,
                       pchDateTime,
                       sizeof(pdft->m_rgchDateTime)
                         - sizeof( szDate) - sizeof(szCRLF) + 1 ) )
    {
        pdft->m_rgchDateTime[0] = '\0';
    } else {

        pchDateTime += strlen( pchDateTime );

        pdft->m_cchOffsetSeconds =
                DIFF(pchDateTime - pdft->m_rgchDateTime)
                - 2         // minus 2 digits for seconds
                - 4;        // minus " GMT"

        pdft->m_cchDateLen = pdft->m_cchOffsetSeconds 
                - 7;        // minus " hh:mm:"

        CopyMemory( pchDateTime, szCRLF, sizeof(szCRLF) );
    }

    pdft->m_cbDateTime = ( strlen( pdft->m_rgchDateTime ) + 1);
    DBG_ASSERT(pdft->m_cbDateTime <= MAX_FORMATTED_DATETIME_LEN);

    //
    // store the valid time now
    //

    pdft->m_stDateTime = *pst;

    return;

} // W3_DATETIME_CACHE::GenerateDateTimeString




CACHED_DATETIME_FORMATS::CACHED_DATETIME_FORMATS( VOID )
    :
#if ENABLE_AUX_COUNTERS
    m_nMisses       ( 0),
    m_nAccesses     ( 0),
#endif // ENABLE_AUX_COUNTERS
    m_idftCurrent   ( 0)
{
    DATETIME_FORMAT_ENTRY dft;
    ZeroMemory( &dft, sizeof(dft));
    for (int i = 0;  i < CACHE_SIZE;  i++)
    {
        m_rgDateTimes[i].Write(dft);
    }
}



DWORD
CACHED_DATETIME_FORMATS::GetFormattedDateTime(
    IN const SYSTEMTIME * pst,
    OUT CHAR * pchDateTime
    )
/*++
  This function obtains formatted string for date specified in *pst.

  It uses a cache to do lookup for the formatted date and time.

  If all entries fail, then it calls the Formatting functions to
    generate a new format.

  It has been experimentally determined that the cost of formatting is too
    high and hence we resort to caching and this comprehensive lookup function.

  Also this function is NOT a GENERAL PURPOSE DATE-FORMAT cacher.
   We cache with the ASSUMPTION that the date format requests will be for
   consecutive time intervals.

  Arguments:
    pst   - pointer to SYSTEMTIME
    pchDateTime - pointer to character buffer into which the formatted
                     date will be copied.

  Returns:
    Length of string (excluding the NULL terminator)

--*/
{
    DBG_ASSERT( pst != NULL && pchDateTime != NULL);

    CdtCountAccesses();
    
    CDFTCache* pdft;
    LONG i = m_idftCurrent + CACHE_SIZE; // modulo operation in loop
                                        //   => start at m_idftCurrent

    // m_rgDateTimes is a circular buffer of CDFTCaches.  The current entry
    // is pointed to by m_idftCurrent.  The second-most recent entry is at
    // (m_idftCurrent - 1) % CACHE_SIZE.  Etc.
    for (int j = CACHE_SIZE  ;  --j >= 0;  i--)
    {
        pdft = &m_rgDateTimes[i & CACHE_MASK];
        
        if (pdft->IsHit(pst)
            &&  pdft->CopyFormattedData(pst, pchDateTime))
        {
            return pdft->DateTimeChars() - 1;
        }
    }
    
    // Not found in cache?  Then generate the time string and add it
    DATETIME_FORMAT_ENTRY dft;
    dft.m_stDateTime.wYear = 0; // invalid date

    GenerateDateTimeString(&dft, pst);
    i = InterlockedIncrement(const_cast<LONG*>(&m_idftCurrent));
    pdft = &m_rgDateTimes[i & CACHE_MASK];
    pdft->Write(dft);

    CdtCountMisses();

    //
    // The date time format is valid. Copy formatted date time.  It is 
    // assumed that the buffer has sufficient space for the formatted date
    //

    dft.CopyFormattedData(pst, pchDateTime);
    return dft.m_cbDateTime - 1;
} // CACHED_DATETIME_FORMATS::GetFormattedDateTime()



DWORD
CACHED_DATETIME_FORMATS::GetFormattedCurrentDateTime(
    OUT PCHAR pchDateTime
    )
{
    DBG_ASSERT(pchDateTime != NULL);
    SYSTEMTIME st;
    IISGetCurrentTimeAsSystemTime(&st);
    return GetFormattedDateTime(&st, pchDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991-1996           **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        MuraliK     3-July-1996 Rewrote the buffer class
*/

#include "precomp.hxx"

# include <buffer.hxx>
# include "dbgutil.h"



/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets m_cb, m_pb and m_fIsDynAlloced

    RETURNS:    TRUE if successful, FALSE for GetLastError()

    NOTES:
        Private member function.

********************************************************************/

BOOL
BUFFER::GetNewStorage( UINT cbRequested )
{
    if ( cbRequested <= m_cb) {

        return TRUE;
    }

    DBG_ASSERT( !IsDynAlloced());  // otherwise I should free up the block :(
    m_pb = (BYTE *) ::LocalAlloc( NONZEROLPTR, cbRequested );

    if ( !m_pb ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    } else {
        m_pb[0] = '\0'; // just store null
        m_cb = cbRequested;
        m_fIsDynAlloced = 1;
    }

    return (m_pb != NULL);
} // BUFFER::GetNewStorage()



/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd. m_pb, m_cb, m_fIsDynAlloced changed

    RETURNS:    TRUE if successful, FALSE for GetLastError()

********************************************************************/

BOOL
BUFFER::ReallocStorage( UINT cbNewRequested )
{
    if ( cbNewRequested <= m_cb) {

        return (TRUE);
    }

    HANDLE hNewMem = ((IsDynAlloced()) ?
                      (::LocalReAlloc( m_pb, cbNewRequested, LMEM_MOVEABLE )):
                      (::LocalAlloc( NONZEROLPTR, cbNewRequested))
                      );

    if (hNewMem == 0)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    if ( !IsDynAlloced()) {
        // First time this block is allocated. Copy over old contents.
        CopyMemory( (BYTE* ) hNewMem, m_pb, m_cb);
        m_fIsDynAlloced = 1;
    }

    m_pb = (BYTE *) hNewMem;
    m_cb = cbNewRequested;

    DBG_ASSERT( m_pb != NULL );

    return TRUE;
} // BUFFER::ReallocStorage()



/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

********************************************************************/

VOID BUFFER::VerifyState() const
{
    //
    //  1. If Dynamically Allocated ==>
    //       m_pb points to something other than m_rgb &
    //       m_cb > INLINED_BUFFER_LEN
    //  2. If not Dynamicall Allocated ==>
    //       (a)  it can be using user-supplied buffer & any sized
    //       (b)  it can be using inlined buffer & m_cb == INLINED_BUFFER_LEN
    //

    DBG_ASSERT(( IsDynAlloced() && (m_pb != m_rgb) &&
                 (m_cb > INLINED_BUFFER_LEN)) ||
               ( !IsDynAlloced() &&
                 ( m_pb != m_rgb || m_cb == INLINED_BUFFER_LEN)
                 )
               );

} // BUFFER::VerifyState()



/*******************************************************************

    NAME:       BUFFER::FreeMemory

    SYNOPSIS:   Frees the heap memory associated with this buffer object

********************************************************************/

VOID
BUFFER::FreeMemory(
    VOID
    )
{
    if ( IsDynAlloced()) {
        ::LocalFree( (HANDLE)m_pb );
        m_pb = m_rgb;
        m_cb = INLINED_BUFFER_LEN;
        m_fIsDynAlloced = 0;
    }

    m_rgb[0] = '\0';  // reset the contents
}



BOOL
BUFFER_CHAIN::AppendBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Adds a new buffer chain item to the end of the buffer chain

Arguments:

    pBCI - Chain item to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DBG_ASSERT( pBCI );
    DBG_ASSERT( pBCI->_ListEntry.Flink == NULL );

    InsertTailList( &_ListHead,
                    &pBCI->_ListEntry );

    return TRUE;
}



DWORD
BUFFER_CHAIN::DeleteChain(
    VOID
    )
/*++

Routine Description:

    Deletes all of the buffers in this chain

Return Value:

    Total number of allocated bytes freed by this call

--*/
{
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbFreed = 0;

    while ( !IsListEmpty( &_ListHead ))
    {
        pBCI = CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );

        DBG_ASSERT( pBCI->_ListEntry.Flink != NULL );

        RemoveEntryList( &pBCI->_ListEntry );

        cbFreed += pBCI->QuerySize();

        delete pBCI;
    }

    return cbFreed;
}



BUFFER_CHAIN_ITEM *
BUFFER_CHAIN::NextBuffer(
    BUFFER_CHAIN_ITEM * pBCI
    )
/*++

Routine Description:

    Returns the next buffer in the chain.  Start the enumeration by
    passing pBCI as NULL.  Continue it by passing the return value

Arguments:

    pBCI - Previous item in enumeration

Return Value:

    Pointer to next item in chain, NULL when done

--*/
{
    if ( pBCI != NULL )
    {
        if ( pBCI->_ListEntry.Flink != &_ListHead )
        {
            return CONTAINING_RECORD( pBCI->_ListEntry.Flink,
                                      BUFFER_CHAIN_ITEM,
                                      _ListEntry );
        }
        else
        {
            return NULL;
        }
    }

    if ( !IsListEmpty( &_ListHead ))
    {
        return CONTAINING_RECORD( _ListHead.Flink,
                                  BUFFER_CHAIN_ITEM,
                                  _ListEntry );
    }

    return NULL;
}



DWORD
BUFFER_CHAIN::CalcTotalSize(
    BOOL fUsed
    ) const
/*++

Routine Description:

    Returns the total amount of memory allocated by this buffer chain
    excluding the size of the structures themselves


Arguments:

    fUsed - If FALSE, returns total allocated by chain, if TRUE returns
        total used by chain

Return Value:

    Total bytes allocated or total bytes used

--*/
{
    LIST_ENTRY *        pEntry;
    BUFFER_CHAIN_ITEM * pBCI;
    DWORD               cbRet = 0;

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pBCI = CONTAINING_RECORD( pEntry, BUFFER_CHAIN_ITEM, _ListEntry );

        if ( fUsed == FALSE )
            cbRet += pBCI->QuerySize();
        else
            cbRet += pBCI->QueryUsed();
    }

    return cbRet;
}

/***************************** End Of File ******************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\helpfunc.cxx ===
#include "precomp.hxx"
#include <limits.h>

DWORD
ReadRegDword(
   IN HKEY     hKey,
   IN LPCTSTR  pszRegistryPath,
   IN LPCTSTR  pszValueName,
   IN DWORD    dwDefaultValue 
   )
/*++

Routine Description:

    Reads a DWORD value from the registry

Arguments:
    
    hKey - a predefined registry handle value

    pszRegistryPath - the subkey to open

    pszValueName - The name of the value.

    dwDefaultValue - The default value to use if the
        value cannot be read.


Return Value:

    DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    LONG err;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;
    DWORD dwReturnValue = dwDefaultValue;

    err = RegOpenKeyEx( hKey,
                        pszRegistryPath,
                        0,
                        KEY_READ,
                        &hKey
                        );
    if (ERROR_SUCCESS == err)
    {
        err = RegQueryValueEx( hKey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer 
                               );

        if( ( ERROR_SUCCESS == err ) && ( REG_DWORD == dwType ) ) 
        {
            dwReturnValue = dwBuffer;
        }
        RegCloseKey(hKey);
    }

    return dwReturnValue;
}

int
SAFEIsSpace(int c)
{
    // don't call if parameter is outside of 0->127 inclusive
    if (c >= 0 && c <= SCHAR_MAX)
    {
        return isspace(c);
    }
    
    DBG_ASSERT(FALSE && "SAFEIsSpace called with invalid data");
    return 0;
}

int
SAFEIsXDigit(int c)
{
    // don't call if parameter is outside of 0->127 inclusive
    if (c >= 0 && c <= SCHAR_MAX)
    {
        return isxdigit(c);
    }
    
    DBG_ASSERT(FALSE && "SAFEIsXDigit called with invalid data");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\irtldbg.cpp ===
// Implementation of debug support functions

#include "precomp.hxx"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>


IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    DBGPRINTF(( DBG_CONTEXT, "%ls\n", tszBuff ));
}



#ifdef IRTLDEBUG

# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef IRTLDBG_RUNNING_AS_SERVICE

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        // If using MFC's TRACE macro (AfxTrace), the report hook
        // (AspAssertHandler) will get called with _CRT_WARN.  Ignore.
        pszMessageTitle = "Warning";
        *pnReturn = 0;
        return FALSE;

    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;

    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000



void
IrtlDebugInit()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // If we end up in _CrtDbgReport, don't put up a message box
    // _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // IRTLDBG_RUNNING_AS_SERVICE

    
    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
IrtlDebugTerm()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000
}

#endif //IRTLDEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\isplat.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       isplat.h

   Abstract:

        Exports platform data types for Internet Services.

   Author:

       Johnson Apacible     (johnsona)      29-Feb-1996

   Project:

       Internet Server DLLs

   Revision History:

--*/

 // Just to ensure the the old platform type does not cause problems
# define _ISPLAT_H_ 

# ifndef _ISPLAT_H_
# define _ISPLAT_H_

# if !defined( dllexp)
#define dllexp __declspec( dllexport )
# endif // dllexp

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// Used to get the platform type
//

dllexp
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// external macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)

//
// infocomm internal
//

extern
PLATFORM_TYPE    TsPlatformType;

#define TsIsNtServer( )         InetIsNtServer(TsPlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(TsPlatformType)
#define TsIsWindows95()         InetIsWindows95(TsPlatformType)

# ifdef __cplusplus
}; // extern "C"
# endif // __cplusplus


# endif // _ISPLAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\eventlog.cxx ===
/*++

   Copyright    (c)    1996-1997        Microsoft Corporation

   Module Name:
        eventlog.cxx

   Abstract:

        This module defines the generic class for logging events.


   Author:

        Murali R. Krishnan    (MuraliK)    28-Sept-1994

--*/

#include "precomp.hxx"

//
//  Include Headers
//

# include <dbgutil.h>
# include <eventlog.hxx>


EVENT_LOG::EVENT_LOG(
    IN LPCWSTR lpszSource
    )
/*++

   Description
     Constructor function for given event log object.
     Initializes event logging services.

   Arguments:

      lpszSource:    Source string for the Event.

   Note:

     This is intended to be executed once only.
     This is not to be used for creating multiple event
      log handles for same given source name.
     But can be used for creating EVENT_LOG objects for
      different source names.

--*/
:
    m_ErrorCode         (NO_ERROR)
{


    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Initializing Event Log for %S[%p]\n",
                    lpszSource, this ));
    }

    //
    //  Register as an event source.
    //

    m_hEventSource = RegisterEventSourceW( NULL, lpszSource);

    if ( m_hEventSource != NULL ) {

        //
        //  Success!
        //

        IF_DEBUG( ERROR) {
            DBGPRINTF( ( DBG_CONTEXT,
                         " Event Log for %S initialized (hEventSource=%p)\n",
                         lpszSource,
                         m_hEventSource));
        }
    } else {

        //
        // An Error in initializing the event log.
        //

        m_ErrorCode = GetLastError();
        DBGPRINTF( ( DBG_CONTEXT,
                     "Could not register event source (%S) ( Error %lu)\n",
                     lpszSource,
                     m_ErrorCode));
    }

    return;

} // EVENT_LOG::EVENT_LOG()



EVENT_LOG::~EVENT_LOG(
    VOID
    )
/*++

    Description:
        Destructor function for given EVENT_LOG object.
        Terminates event logging functions and closes
         event log handle

--*/
{

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "Terminating events logging[%p]\n",
                        this));
    }


    //
    // If there is a valid Events handle, deregister it
    //

    if ( m_hEventSource != NULL) {

        BOOL fSuccess;

        fSuccess = DeregisterEventSource( m_hEventSource);

        if ( !fSuccess) {

            //
            // An Error in DeRegistering
            //

            m_ErrorCode = GetLastError();

            IF_DEBUG( INIT_CLEAN) {

                DBGPRINTF( ( DBG_CONTEXT,
                             "Termination of EventLog[%p] failed."
                             " error %lu\n",
                             this,
                             m_ErrorCode));
            }
        }

        //
        //  Reset the handle's value. Just as a precaution
        //
        m_hEventSource = NULL;
    }


    IF_DEBUG( API_EXIT) {
        DBGPRINTF( ( DBG_CONTEXT, "Terminated events log[%p]\n",this));
    }

} /* EVENT_LOG::~EVENT_LOG() */



VOID
EVENT_LOG::LogEvent(
        IN DWORD  idMessage,
        IN WORD   nSubStrings,
        IN const WCHAR * rgpszSubStrings[],
        IN DWORD  errCode)
/*++

     Description:
        Log an event to the event logger

     Arguments:

       idMessage           Identifies the event message

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       rgpszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{

    WORD wType;                // Type of Event to be logged

    //
    //  Find type of message for the event log
    //

    IF_DEBUG( API_ENTRY)  {

        DWORD i;

        DBGPRINTF( ( DBG_CONTEXT,
                    "reporting event %08lX, Error Code = %lu\n",
                    idMessage,
                    errCode ));

        for( i = 0 ; i < nSubStrings ; i++ ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "    substring[%lu] = %S\n",
                       i,
                       rgpszSubStrings[i] ));
        }
    }

    if ( NT_INFORMATION( idMessage)) {

        wType = EVENTLOG_INFORMATION_TYPE;

    } else {

        if ( NT_WARNING( idMessage)) {

            wType = EVENTLOG_WARNING_TYPE;

        } else {

            wType = EVENTLOG_ERROR_TYPE;

            DBG_ASSERT(NT_ERROR( idMessage));
        }
    }

    //
    //  Log the event
    //

    EVENT_LOG::LogEventPrivate( idMessage,
                              wType,
                              nSubStrings,
                              rgpszSubStrings,
                              errCode);


    return;

} /* EVENT_LOG::LogEvent() */


//
//  Private functions.
//

VOID
EVENT_LOG::LogEventPrivate(
    IN DWORD   idMessage,
    IN WORD    wEventType,
    IN WORD    nSubStrings,
    IN const WCHAR  * apszSubStrings[],
    IN DWORD   errCode
    )
/*++

     Description:
        Log an event to the event logger.
        ( Private version, includes EventType)

     Arguments:

       idMessage           Identifies the event message

       wEventType          Specifies the severety of the event
                            (error, warning, or informational).

       nSubStrings         Number of substrings to include in
                            this message. (Maybe 0)

       apszSubStrings     array of substrings included in the message
                            (Maybe NULL if nSubStrings == 0)

       errCode             An error code from Win32 or WinSock or NT_STATUS.
                            If this is not Zero, it is considered as
                            "raw" data to be included in message

   Returns:

     None

--*/
{
    VOID  * pRawData  = NULL;
    DWORD   cbRawData = 0;
    BOOL    fReport;
    DWORD   dwErr;

    if ( m_hEventSource == NULL ) {

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Attempt to log with no event source\n"));
        }
        return;
    }

    ASSERT( (nSubStrings == 0) || (apszSubStrings != NULL));

    if( errCode != 0 ) {
        pRawData  = &errCode;
        cbRawData = sizeof(errCode);
    }

    m_ErrorCode  = NO_ERROR;
    dwErr = GetLastError();


    fReport = ReportEventW(
                       m_hEventSource,                   // hEventSource
                       wEventType,                       // fwEventType
                       0,                                // fwCategory
                       idMessage,                        // IDEvent
                       NULL,                             // pUserSid,
                       nSubStrings,                      // cStrings
                       cbRawData,                        // cbData
                       (LPCWSTR *) apszSubStrings,       // plpszStrings
                       pRawData );                       // lpvData

    if ( !fReport ) {

        IF_DEBUG( ERROR) {

            m_ErrorCode = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                        "Cannot report event for %p, error %lu\n",
                        this,
                        m_ErrorCode));
        }
    }
    else {
        SetLastError( dwErr );
    }

}  // EVENT_LOG::LogEventPrivate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\makefile.inc ===
$(O)\mbtest.res: mbtest.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff (moved to locks.cxx)
--*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <locks.h>


typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }

    //
    // see if this is win95
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetVersionEx failed with %d\n",
                    GetLastError() ));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibraryA("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtWindows95;
    }

    g_PlatformType = pt;
    return(pt);

} // IISGetPlatformType



// Thunking wrapper for ::SetCriticalSectionSpinCount that will work on
// systems that don't have this API in kernel32

DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount)
{
    return CCritSec::SetSpinCount(lpCriticalSection, dwSpinCount);
}


// Thunking wrapper for ::InitializeCriticalSectionAndSpinCount that will
// work on systems that don't have this API in kernel32.  Sets the spin count
// to the IIS default, IIS_DEFAULT_CS_SPIN_COUNT, which is defined in
// <pudebug.h>

VOID
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection)
{
    InitializeCriticalSection(lpCriticalSection);
    CCritSec::SetSpinCount(lpCriticalSection, IIS_DEFAULT_CS_SPIN_COUNT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\lkrhash.cpp ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__


#ifdef LKRHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CLKRhashAllocator* LKRHASH_NS::CLASS::sm_palloc = NULL;            \

# define DECLARE_ALLOCATOR_LHTSUBCLASS(CLASS)            \
  CLKRhashAllocator* LKRHASH_NS::CLKRLinearHashTable::CLASS::sm_palloc = NULL; \


  // DECLARE_ALLOCATOR(CLKRLinearHashTable);
  // DECLARE_ALLOCATOR(CLKRHashTable);
  DECLARE_ALLOCATOR(CNodeClump);
  DECLARE_ALLOCATOR(CSmallSegment);
  DECLARE_ALLOCATOR(CMediumSegment);
  DECLARE_ALLOCATOR(CLargeSegment);

#endif // LKRHASH_ALLOCATOR_NEW


static bool s_fInitialized = false;


// -------------------------------------------------------------------------
// Initialize per-class allocators
// -------------------------------------------------------------------------

bool
LKRHashTableInit()
{
    bool f = true;

    IRTLTRACE0("LKRHashTableInit\n");

#define INIT_ALLOCATOR(CLASS, N)                                \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLASS, N, f);                         \

#define INIT_ALLOCATOR_LHTSUBCLASS(CLASS, N)                    \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLKRLinearHashTable::CLASS, N, f);     \


    // INIT_ALLOCATOR(CLKRLinearHashTable,        20);
    // INIT_ALLOCATOR(CLKRHashTable,               4);
    INIT_ALLOCATOR(CNodeClump,    200);
    INIT_ALLOCATOR(CSmallSegment,   5);
    INIT_ALLOCATOR(CMediumSegment,  5);
    INIT_ALLOCATOR(CLargeSegment,   5);

    s_fInitialized = f;

    return f;
} // LKRHashTableInit



// -------------------------------------------------------------------------
// Destroy per-class allocators
// -------------------------------------------------------------------------

void
LKRHashTableUninit()
{
#define UNINIT_ALLOCATOR(CLASS)                        \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLASS);                    \

#define UNINIT_ALLOCATOR_LHTSUBCLASS(CLASS)            \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLKRLinearHashTable::CLASS);\

    // UNINIT_ALLOCATOR(CLKRLinearHashTable);
    // UNINIT_ALLOCATOR(CLKRHashTable);
    UNINIT_ALLOCATOR(CNodeClump);
    UNINIT_ALLOCATOR(CSmallSegment);
    UNINIT_ALLOCATOR(CMediumSegment);
    UNINIT_ALLOCATOR(CLargeSegment);

    s_fInitialized = false;

#ifdef IRTLDEBUG
    CLKRLinearHashTable::sm_llGlobalList.Lock();
    if (! CLKRLinearHashTable::sm_llGlobalList.IsEmpty())
    {
        IRTLTRACE0("CLKRLinearHashTable::sm_llGlobalList is not Empty\n");
        for (CListEntry* ple = CLKRLinearHashTable::sm_llGlobalList.First();
             ple != CLKRLinearHashTable::sm_llGlobalList.HeadNode();
             ple = ple->Flink)
        {
            CLKRLinearHashTable* plht
                = CONTAINING_RECORD(ple, CLKRLinearHashTable, m_leGlobalList);
            IRTLTRACE2("CLKRLinearHashTable %p, \"%hs\" not deleted\n",
                       plht, plht->m_szName);
        }
        IRTLASSERT(! "CLKRLinearHashTable::sm_llGlobalList is not Empty");
    }
    CLKRLinearHashTable::sm_llGlobalList.Unlock();
    
    CLKRHashTable::sm_llGlobalList.Lock();
    if (! CLKRHashTable::sm_llGlobalList.IsEmpty())
    {
        IRTLTRACE0("CLKRHashTable::sm_llGlobalList is not Empty\n");
        for (CListEntry* ple = CLKRHashTable::sm_llGlobalList.First();
             ple != CLKRHashTable::sm_llGlobalList.HeadNode();
             ple = ple->Flink)
        {
            CLKRHashTable* pht
                = CONTAINING_RECORD(ple, CLKRHashTable, m_leGlobalList);
            IRTLTRACE2("CLKRHashTable %p, \"%hs\" not deleted\n",
                       pht, pht->m_szName);
        }
        IRTLASSERT(! "CLKRHashTable::sm_llGlobalList is not Empty");
    }
    CLKRHashTable::sm_llGlobalList.Unlock();
#endif // IRTLDEBUG
    
    IRTLTRACE0("LKRHashTableUninit done\n");
} // LKRHashTableUninit



// See if countdown loops are faster than countup loops for traversing
// a CNodeClump
#ifdef LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = NODES_PER_CLUMP;  --x >= 0;  )
#else // !LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = 0;  x < NODES_PER_CLUMP;  ++x)
#endif // !LKR_COUNTDOWN


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets    = 0;

LONG CLKRLinearHashTable::sm_cTables              = 0;
#endif // LOCK_INSTRUMENTATION


#ifndef LKR_NO_GLOBAL_LIST
CLockedDoubleList CLKRLinearHashTable::sm_llGlobalList;
CLockedDoubleList CLKRHashTable::sm_llGlobalList;
#endif // LKR_NO_GLOBAL_LIST



// CLKRLinearHashTable --------------------------------------------------------
// Public Constructor for class CLKRLinearHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD         /*num_subtbls*/,  // for compatiblity with CLKRHashTable
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL),    // directly created, no owning table
      m_fMultiKeys(fMultiKeys)
{
    STATIC_ASSERT(1 <= LK_DFLT_MAXLOAD  && LK_DFLT_MAXLOAD <= NODES_PER_CLUMP);
    STATIC_ASSERT(0 <= NODE_BEGIN  &&  NODE_BEGIN < NODES_PER_CLUMP);
    STATIC_ASSERT(!(0 <= NODE_END  &&  NODE_END < NODES_PER_CLUMP));

    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// CLKRLinearHashTable --------------------------------------------------------
// Private Constructor for class CLKRLinearHashTable, used by CLKRHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(phtParent),
      m_fMultiKeys(fMultiKeys)
{
    IRTLASSERT(m_phtParent != NULL);
    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// _Initialize -------------------------------------------------------------
// Do all the real work of constructing a CLKRLinearHashTable
// -------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Initialize(
    PFnExtractKey   pfnExtractKey,
    PFnCalcKeyHash  pfnCalcKeyHash,
    PFnEqualKeys    pfnEqualKeys,
    PFnAddRefRecord pfnAddRefRecord,
    LPCSTR          pszName,
    double          maxload,
    DWORD           initsize)
{
    m_dwSignature =     SIGNATURE;
    m_dwBktAddrMask0 =  0;
    m_dwBktAddrMask1 =  0;
    m_iExpansionIdx =   0;
    m_paDirSegs =       NULL;
    m_lkts =            LK_MEDIUM_TABLESIZE;
    m_dwSegBits =       0;
    m_dwSegSize =       0;
    m_dwSegMask =       0;
    m_lkrcState =       LK_UNUSABLE;
    m_MaxLoad =         LK_DFLT_MAXLOAD;
    m_nLevel =          0;
    m_cDirSegs =        0;
    m_cRecords =        0;
    m_cActiveBuckets =  0;
    m_wBucketLockSpins= LOCK_USE_DEFAULT_SPINS;
    m_pfnExtractKey =   pfnExtractKey;
    m_pfnCalcKeyHash =  pfnCalcKeyHash;
    m_pfnEqualKeys =    pfnEqualKeys;
    m_pfnAddRefRecord = pfnAddRefRecord;

    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(m_pfnExtractKey != NULL
               && m_pfnCalcKeyHash != NULL
               && m_pfnEqualKeys != NULL
               && m_pfnAddRefRecord != NULL);

    IRTLASSERT(s_fInitialized);

    if (!s_fInitialized)
        return (m_lkrcState = LK_NOT_INITIALIZED);

    if (m_pfnExtractKey == NULL
            || m_pfnCalcKeyHash == NULL
            || m_pfnEqualKeys == NULL
            || m_pfnAddRefRecord == NULL)
        return (m_lkrcState = LK_BAD_PARAMETERS);

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad = (maxload <= 1.0)  ?  LK_DFLT_MAXLOAD  :  maxload;
    m_MaxLoad = min(m_MaxLoad, 10 * NODES_PER_CLUMP);

    // Choose the size of the segments according to the desired "size" of
    // the table, small, medium, or large.
    LK_TABLESIZE lkts;

    if (initsize == LK_SMALL_TABLESIZE)
    {
        lkts = LK_SMALL_TABLESIZE;
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        lkts = LK_MEDIUM_TABLESIZE;
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        lkts = LK_LARGE_TABLESIZE;
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::INITSIZE  <= initsize <=  MAX_DIRSIZE * Large::INITSIZE
        initsize = min(max(initsize, CSmallSegment::INITSIZE),
                       (MAX_DIRSIZE >> CLargeSegment::SEGBITS)
                            * CLargeSegment::INITSIZE);

        // Guess a table size
        if (initsize <= 8 * CSmallSegment::INITSIZE)
            lkts = LK_SMALL_TABLESIZE;
        else if (initsize >= CLargeSegment::INITSIZE)
            lkts = LK_LARGE_TABLESIZE;
        else
            lkts = LK_MEDIUM_TABLESIZE;
    }

    return _SetSegVars(lkts, initsize);
} // CLKRLinearHashTable::_Initialize



// CLKRHashTable ----------------------------------------------------------
// Constructor for class CLKRHashTable.
// ---------------------------------------------------------------------

CLKRHashTable::CLKRHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Bound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD           num_subtbls,    // Number of subordinate hash tables.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_palhtDir(NULL),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_BAD_PARAMETERS)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    _InsertThisIntoGlobalList();

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL
               && pfnAddRefRecord != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL
            || pfnAddRefRecord == NULL)
        return;

    if (!s_fInitialized)
    {
        m_lkrcState = LK_NOT_INITIALIZED;
        return;
    }

    LK_TABLESIZE lkts = NumSubTables(initsize, num_subtbls);

#ifdef IRTLDEBUG
    int cBuckets = initsize;
    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = CLargeSegment::INITSIZE;

    IRTLTRACE(TEXT("CLKRHashTable: %s, %d subtables, initsize = %d, ")
              TEXT("total #buckets = %d\n"),
              ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
               (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
              num_subtbls, initsize, cBuckets * num_subtbls);
#endif // IRTLDEBUG

    m_lkrcState = LK_ALLOC_FAIL;
    m_palhtDir  = _AllocateSubTableArray(num_subtbls);

    if (m_palhtDir == NULL)
        return;
    else
    {
        m_cSubTables = num_subtbls;
        for (DWORD i = 0;  i < m_cSubTables;  i++)
            m_palhtDir[i] = NULL;
    }

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i] = _AllocateSubTable(pszName, pfnExtractKey,
                                          pfnCalcKeyHash, pfnEqualKeys,
                                          pfnAddRefRecord, maxload,
                                          initsize, this, fMultiKeys);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                _FreeSubTable(m_palhtDir[j]);
            _FreeSubTableArray(m_palhtDir);
            m_cSubTables = 0;
            m_palhtDir   = NULL;

            return;
        }
    }

    m_nSubTableMask = m_cSubTables - 1;
    // power of 2?
    if ((m_nSubTableMask & m_cSubTables) != 0)
        m_nSubTableMask = -1;

    m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail
} // CLKRHashTable::CLKRHashTable



// ~CLKRLinearHashTable ------------------------------------------------------
// Destructor for class CLKRLinearHashTable
//-------------------------------------------------------------------------

CLKRLinearHashTable::~CLKRLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the table
    WriteLock();
    _Clear(false);
    WriteUnlock();

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRLinearHashTable::~CLKRLinearHashTable



// ~CLKRHashTable ------------------------------------------------------------
// Destructor for class CLKRHashTable
//-------------------------------------------------------------------------
CLKRHashTable::~CLKRHashTable()
{
    // delete in reverse order, just like delete[].
    for (DWORD i = m_cSubTables;  i-- > 0;  )
        _FreeSubTable(m_palhtDir[i]);

    _FreeSubTableArray(m_palhtDir);

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRHashTable::~CLKRHashTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRLinearHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts = LK_MEDIUM_TABLESIZE;

    return lkts;
} // CLKRLinearHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        int nCPUs = NumProcessors();
        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = max(1, nCPUs);
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * nCPUs;
            break;
        }
    }

    rnum_subtbls = min(MAX_SUBTABLES, rnum_subtbls);

    return lkts;
} // CLKRHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindBucket
// Synopsis: Find a bucket, given its signature. The bucket is locked
//           before returning. Assumes table is already locked, to avoid
//           race conditions.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CBucket*
CLKRLinearHashTable::_FindBucket(
    DWORD dwSignature,
    bool  fLockForWrite) const
{
    IRTLASSERT(IsValid());
    IRTLASSERT(m_dwBktAddrMask0 > 0);
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT(2 < m_dwSegBits  &&  m_dwSegBits < 20
               &&  m_dwSegSize == (1U << m_dwSegBits)
               &&  m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(IsReadLocked()  ||  IsWriteLocked());
    
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    
    CBucket* const pbkt = _Bucket(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (fLockForWrite)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();
    
    return pbkt;
} // CLKRLinearHashTable::_FindBucket



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsNodeCompact
// Synopsis: validates that a node is correctly compacted
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsNodeCompact(
    CBucket* const pbkt) const
{
    CNodeClump* pncCurr;
    CNodeClump* pncPrev;
    bool fEmpty  = pbkt->m_ncFirst.InvalidSignature(NODE_BEGIN);
    int  cErrors = fEmpty ? !pbkt->m_ncFirst.IsLastClump() : 0;

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (fEmpty)
            {
                cErrors += (!pncCurr->InvalidSignature(i));
                cErrors += (!pncCurr->IsEmptyNode(i));
            }
            else if (pncCurr->InvalidSignature(i))
            {
                fEmpty = true;
                cErrors += (!pncCurr->IsEmptyNode(i));
                cErrors += (!pncCurr->IsLastClump());
            }
            else // still in non-empty portion
            {
                cErrors += (pncCurr->InvalidSignature(i));
                cErrors += (pncCurr->IsEmptyNode(i));
            }
        }
    }

    return cErrors;
} // CLKRLinearHashTable::_IsNodeCompact



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTable
// Synopsis:
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CLKRHashTable::SubTable*
CLKRHashTable::_SubTable(
    DWORD dwSignature) const
{
    IRTLASSERT(m_lkrcState == LK_SUCCESS
               &&  m_palhtDir != NULL  &&  m_cSubTables > 0);
    
    const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
    DWORD       index = dwSignature;
    
    index = (((index * PRIME + 12345) >> 16)
             | ((index * 69069 + 1) & 0xffff0000));
    
    if (m_nSubTableMask >= 0)
        index &= m_nSubTableMask;
    else
        index %= m_cSubTables;

    return m_palhtDir[index];
} // CLKRHashTable::_SubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTableIndex
// Synopsis:
//------------------------------------------------------------------------

int
CLKRHashTable::_SubTableIndex(
    CLKRHashTable::SubTable* pst) const
{
    int index = -1;
    
    for (int i = 0;  i < m_cSubTables;  ++i)
    {
        if (pst == m_palhtDir[i])
        {
            index = i;
            break;
        }
    }

    IRTLASSERT(index >= 0);

    return index;
} // CLKRHashTable::_SubTableIndex



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash table. If this causes the
//           average chain length to exceed the upper bound, the table is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the table, unless
//               fOverwrite==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash table not in usable state
//           LK_BAD_RECORD, if record is bad.
//
// TODO: honor m_fMultiKeys and allow multiple identical keys.
// This will require keeping all identical signatures contiguously
// within a bucket chain, and keeping all identical keys contigously
// within that set of contigous signatures. With a good hash function,
// there should not be identical signatures without also having
// identical keys. Also, need to modify _DeleteNode. This modification
// is needed for EqualRange and for hash_multiset and hash_multimap
// to work.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to table
    DWORD       dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult
#endif // LKR_STL_ITERATORS
    )
{
    IRTLASSERT(IsUsable()
               &&  pvRecord != NULL
               &&  dwSignature != HASH_INVALID_SIGNATURE);

    // find the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
#endif // LKR_STL_ITERATORS
    
    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE lkrc = LK_SUCCESS;
    CNodeClump* pncFree = NULL;
    int         iFreePos = NODE_BEGIN - NODE_STEP;
    CNodeClump* pncPrev;
    CNodeClump* pncCurr;
    bool        fUpdate = false;
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    // walk down the entire bucket chain, looking for matching hash
    // signatures and keys
    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());

                pncFree  = pncCurr;
                iFreePos = i;
                goto insert;
            }

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  (pvRecord == pncCurr->m_pvNode[i]  ||
                    _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i]))))
            {
                if (fOverwrite)
                {
                    // If we allow overwrites, this is the slot to do it to
                    fUpdate  = true;
                    pncFree  = pncCurr;
                    iFreePos = i;
                    goto insert;
                }
                else
                {
                    // overwrites forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }
        }
    }

  insert:
    if (pncFree != NULL)
    {
        pncCurr = pncFree;
        IRTLASSERT(0 <= iFreePos  &&  iFreePos < NODES_PER_CLUMP);
    }
    else
    {
        // No free slots.  Attach the new node to the end of the chain
        IRTLASSERT(iFreePos == NODE_BEGIN - NODE_STEP);
        pncCurr = _AllocateNodeClump();

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncPrev != NULL  &&  pncPrev->IsLastClump());
        pncPrev->m_pncNext = pncCurr;
        iFreePos = NODE_BEGIN;
    }

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, +1);

    if (fUpdate)
    {
        // We're overwriting an existing record.  Adjust the old record's
        // refcount downwards.  (Doing ++new, --old in this order ensures
        // that the refcount won't briefly go to zero if new and old are
        // the same record.)
        IRTLASSERT(!pncCurr->IsEmptyAndInvalid(iFreePos));
        _AddRefRecord(pncCurr->m_pvNode[iFreePos], -1);
    }
    else
    {
        IRTLASSERT(pncCurr->IsEmptyAndInvalid(iFreePos));
        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));
    }

    pncCurr->m_dwKeySigs[iFreePos] = dwSignature;
    pncCurr->m_pvNode[iFreePos]    = pvRecord;

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
#ifdef LKR_STL_ITERATORS
        // Don't call _Expand() if we're putting the result into an
        // iterator, as _Expand() tends to invalidate any other
        // iterators that might be in use.
        if (piterResult != NULL)
        {
            piterResult->m_plht =         this;
            piterResult->m_pnc =          pncCurr;
            piterResult->m_dwBucketAddr = dwBktAddr;
            piterResult->m_iNode =        (short) iFreePos;

            // Add an extra reference on the record, as the one added by
            // _InsertRecord will be lost when the iterator's destructor
            // fires or its assignment operator is used
            piterResult->_AddRef(+1);
        }
        else
#endif // LKR_STL_ITERATORS
        {
            // If the average load factor has grown too high, we grow the
            // table one bucket at a time.
            while (m_cRecords > m_MaxLoad * m_cActiveBuckets)
            {
                // If _Expand returns an error code (viz. LK_ALLOC_FAIL), it
                // just means that there isn't enough spare memory to expand
                // the table by one bucket. This is likely to cause problems
                // elsewhere soon, but this hashtable has not been corrupted.
                // If the call to _AllocateNodeClump above failed, then we do
                // have a real error that must be propagated back to the caller
                // because we were unable to insert the element at all.
                if (_Expand() != LK_SUCCESS)
                    break;  // expansion failed
            }
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_InsertRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::InsertRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InsertRecord(
    const void* pvRecord,
    bool fOverwrite /*=false*/)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk = pst->_InsertRecord(pvRecord, hash_val, fOverwrite);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::InsertRecord



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           table (if it exists).
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    DWORD           dwSignature
    )
{
    IRTLASSERT(IsUsable());

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[i])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[i]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteKey(
    const DWORD_PTR pnKey)
{
    if (!IsUsable())
        return m_lkrcState;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(pnKey);
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteKey(pnKey, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteKey



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash table (if it
//           exists).  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If _DeleteKey were called for
//           a record that doesn't exist in the table, it could delete some
//           completely unrelated record that happened to have the same key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the table.
//           LK_UNUSABLE, if hash table not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    DWORD       dwSignature
    )
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);

                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteRecord(
    const void* pvRecord)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteRecord(pvRecord, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//
// TODO: Is the rpncPrev parameter really necessary?
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_DeleteNode(
    CBucket*     pbkt,      // bucket chain containing node
    CNodeClump*& rpnc,      // actual node
    CNodeClump*& rpncPrev,  // predecessor of actual node, or NULL
    int&         riNode)    // index within node
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);
    IRTLASSERT(0 <= riNode  &&  riNode < NODES_PER_CLUMP);
    IRTLASSERT(!rpnc->IsEmptyAndInvalid(riNode));

#ifdef IRTLDEBUG
    // Check that the node clump really does belong to the bucket
    CNodeClump* pnc1 = &pbkt->m_ncFirst;

    while (pnc1 != NULL  &&  pnc1 != rpnc)
         pnc1 = pnc1->m_pncNext;

    IRTLASSERT(pnc1 == rpnc);
#endif // IRTLDEBUG

    // Release the reference to the record
    _AddRefRecord(rpnc->m_pvNode[riNode], -1);

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // TODO: honor m_fMultiKeys

    // Compact the nodeclump by moving the very last node back to the
    // newly freed slot
    CNodeClump* pnc2   = rpnc;
    int         iNode2 = riNode;

    // Find the last nodeclump in the chain
    while (!pnc2->IsLastClump())
    {
         pnc2 = pnc2->m_pncNext;
         iNode2 = NODE_BEGIN;
    }

    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP);
    IRTLASSERT(!pnc2->IsEmptyAndInvalid(iNode2));

    // Find the first empty slot in the nodeclump
    while (iNode2 != NODE_END  &&  !pnc2->IsEmptySlot(iNode2))
    {
        iNode2 += NODE_STEP;
    }

    // Back up to last non-empty slot
    iNode2 -= NODE_STEP;
    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP
               &&  !pnc2->IsEmptyAndInvalid(iNode2));
    IRTLASSERT(iNode2+NODE_STEP == NODE_END
               ||  pnc2->IsEmptyAndInvalid(iNode2+NODE_STEP));

#ifdef IRTLDEBUG
    // Check that all the remaining nodes are empty
    IRTLASSERT(pnc2->IsLastClump());
    for (int iNode3 = iNode2 + NODE_STEP;
         iNode3 != NODE_END;
         iNode3 += NODE_STEP)
    {
        IRTLASSERT(pnc2->IsEmptyAndInvalid(iNode3));
    }
#endif // IRTLDEBUG

    // Move the last node's data back to the current node
    rpnc->m_pvNode[riNode]    = pnc2->m_pvNode[iNode2];
    rpnc->m_dwKeySigs[riNode] = pnc2->m_dwKeySigs[iNode2];

    // Blank the old last node.
    // Correct even if (rpnc, riNode) == (pnc2, iNode2).
    pnc2->m_pvNode[iNode2]    = NULL;
    pnc2->m_dwKeySigs[iNode2] = HASH_INVALID_SIGNATURE;

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Back up riNode by one, so that the next iteration of the loop
    // calling _DeleteNode will end up pointing to the same spot.
    if (riNode != NODE_BEGIN)
    {
        riNode -= NODE_STEP;
    }
    else
    {
        // rewind rpnc and rpncPrev to previous node
        if (rpnc == &pbkt->m_ncFirst)
        {
            riNode = NODE_BEGIN - NODE_STEP;
        }
        else
        {
            riNode = NODE_END;
            rpnc = rpncPrev;
            if (rpnc == &pbkt->m_ncFirst)
            {
                rpncPrev = NULL;
            }
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

    // Is the last node clump now completely empty?  Delete, if possible
    if (iNode2 == NODE_BEGIN  &&  pnc2 != &pbkt->m_ncFirst)
    {
        // Find preceding nodeclump
        CNodeClump* pnc3 = &pbkt->m_ncFirst;
        while (pnc3->m_pncNext != pnc2)
        {
            pnc3 = pnc3->m_pncNext;
            IRTLASSERT(pnc3 != NULL);
        }

        pnc3->m_pncNext = NULL;
#ifdef IRTLDEBUG
        pnc2->m_pncNext = NULL; // or dtor will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pnc2);
    }

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));

    return true;
} // CLKRLinearHashTable::_DeleteNode



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKey(
    const DWORD_PTR  pnKey,  // Key value of the record, depends on key type
    DWORD        dwSignature,// hash signature
    const void** ppvRecord   // resultant record
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult
#endif // LKR_STL_ITERATORS
    ) const
{
    IRTLASSERT(IsUsable()  &&  ppvRecord != NULL);

    *ppvRecord = NULL;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;
    int iNode;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
#endif // LKR_STL_ITERATORS
    
    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        FOR_EACH_NODE(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(iNode));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[iNode])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[iNode]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                    *ppvRecord = pncCurr->m_pvNode[iNode];
                    lkrc = LK_SUCCESS;

                    // bump the reference count before handing the record
                    // back to the user.  The user should decrement the
                    // reference count when finished with this record.
                    _AddRefRecord(*ppvRecord, +1);
                    goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();

#ifdef LKR_STL_ITERATORS
    if (piterResult != NULL  &&  lkrc == LK_SUCCESS)
    {
        piterResult->m_plht =         const_cast<CLKRLinearHashTable*>(this);
        piterResult->m_pnc =          pncCurr;
        piterResult->m_dwBucketAddr = dwBktAddr;
        piterResult->m_iNode =        (short) iNode;
    }
#endif // LKR_STL_ITERATORS

    return lkrc;
} // CLKRLinearHashTable::_FindKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindKey(
    const DWORD_PTR pnKey,
    const void**    ppvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindKey(pnKey, hash_val, ppvRecord);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindKey



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the table
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the table
//           LK_UNUSABLE, if hash table not in usable state
// Note:     The record is *not* AddRef'd.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the table
    DWORD       dwSignature  // hash signature
    ) const
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                lkrc = LK_SUCCESS;

                goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // CLKRLinearHashTable::_FindRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindRecord(
    const void* pvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindRecord(pvRecord, hash_val);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindRecord



#ifdef LKR_APPLY_IF

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    LK_PREDICATE lkp = LKP_PERFORM;
    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    DWORD dw = _Apply(pfnAction, pvState, lkl, lkp);
    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRLinearHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_Apply(pfnAction, pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();
    return dw;
} // CLKRLinearHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                          pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();
    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (IsValid())
        dw = _DeleteIf(pfnPredicate, pvState, lkp);
    WriteUnlock();

    return dw;
} // CLKRLinearHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    WriteUnlock();

    return dw;
} // CLKRHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    return _ApplyIf(_PredTrue, pfnAction, pvState, lkl, rlkp);
} // CLKRLinearHashTable::_Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !IsWriteLocked()  :  !IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (lkl == LKL_WRITELOCK)
                            pbkt->WriteUnlock();
                        else
                            pbkt->ReadUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            pbkt->ReadUnlock();
                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(! "Unknown LK_ACTION in ApplyIf");
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in ApplyIf");
                        break;
                    }
                }
            }
        }

      unlock:
        if (lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_DeleteIf(
    PFnRecordPred  pfnPredicate,
    void*          pvState,
    LK_PREDICATE& rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        pbkt->WriteUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            pbkt->WriteUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in DeleteIf");
                        break;
                    }
                }
            }
        }

      unlock:
        pbkt->WriteUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_DeleteIf

#endif // LKR_APPLY_IF



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKRLinearHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (!IsValid())
    {
        _ReadOrWriteUnlock(fReadLocked);
        return LK_UNUSABLE;
    }

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       retcode = 0;

    // Check every bucket
    for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
    {
        CBucket* const pbkt = _Bucket(i);

        IRTLASSERT(pbkt != NULL);
        retcode += !(pbkt != NULL);

        pbkt->ReadLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        // Walk the bucket chain
        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int j;

            FOR_EACH_NODE(j)
            {
                if (pncCurr->IsEmptySlot(j))
                {
                    IRTLASSERT(pncCurr->IsLastClump());
                    retcode += !(pncCurr->IsLastClump());

                    for (int k = j;  k != NODE_END;  k += NODE_STEP)
                    {
                        IRTLASSERT(pncCurr->IsEmptyNode(k));
                        retcode += !pncCurr->IsEmptyNode(k);
                        IRTLASSERT(pncCurr->InvalidSignature(k));
                        retcode += !pncCurr->InvalidSignature(k);
                    }
                    break;
                }

                if (!pncCurr->IsEmptySlot(j))
                {
                    ++cRecords;

                    const DWORD_PTR pnKey = _ExtractKey(pncCurr->m_pvNode[j]);

                    DWORD dwSignature = _CalcKeyHash(pnKey);
                    IRTLASSERT(dwSignature != HASH_INVALID_SIGNATURE);
                    retcode += !(dwSignature != HASH_INVALID_SIGNATURE);
                    IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[j]);
                    retcode += !(dwSignature == pncCurr->m_dwKeySigs[j]);

                    DWORD address = _BucketAddress(dwSignature);
                    IRTLASSERT(address == i);
                    retcode += !(address == i);

                    if (address != i || dwSignature != pncCurr->m_dwKeySigs[j])
                        cMisplaced++;
                }
                else // pncCurr->IsEmptySlot(j)
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(j));
                    retcode += !pncCurr->IsEmptyAndInvalid(j);
                }
            }
            if (pncPrev != NULL)
            {
                IRTLASSERT(pncPrev->m_pncNext == pncCurr);
                retcode += !(pncPrev->m_pncNext == pncCurr);
            }
        }
        pbkt->ReadUnlock();
    }

    if (cRecords != m_cRecords)
        ++retcode;

    IRTLASSERT(cRecords == m_cRecords);
    retcode += !(cRecords == m_cRecords);

    if (cMisplaced > 0)
        retcode = cMisplaced;

    IRTLASSERT(cMisplaced == 0);
    retcode += !(cMisplaced == 0);

    _ReadOrWriteUnlock(fReadLocked);

    return retcode;
} // CLKRLinearHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKRHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    int retcode = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        retcode += m_palhtDir[i]->CheckTable();

    return retcode;
} // CLKRHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    if (!IsUsable())
        return;

    IRTLASSERT(IsWriteLocked());

#ifdef IRTLDEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // IRTLDEBUG

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             )
        {
            int i;

            FOR_EACH_NODE(i)
            {

                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(pncCurr->IsLastClump());
                    break;
                }
                else
                {
                    _AddRefRecord(pncCurr->m_pvNode[i], -1);
                    pncCurr->m_pvNode[i]    = NULL;
                    pncCurr->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                    m_cRecords--;

#ifdef IRTLDEBUG
                    ++cDeleted;
#endif // IRTLDEBUG
                }
            } // for (i ...

            pncPrev = pncCurr;
            pncCurr = pncCurr->m_pncNext;
            pncPrev->m_pncNext = NULL;

            if (pncPrev != &pbkt->m_ncFirst)
                _FreeNodeClump(pncPrev);
        } // for (pncCurr ...

        pbkt->WriteUnlock();
    } // for (iBkt ...

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all segments
    for (DWORD iSeg = 0;  iSeg < m_cActiveBuckets;  iSeg += m_dwSegSize)
    {
        _FreeSegment(_Segment(iSeg));
        _Segment(iSeg) = NULL;
    }

    _FreeSegmentDirectory();
    m_nLevel = m_cActiveBuckets = m_iExpansionIdx = 0;
    m_dwBktAddrMask0 = 1;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    // set directory of segments to minimum size
    if (fShrinkDirectory)
    {
        DWORD cInitialBuckets = 0;

        if (LK_SMALL_TABLESIZE == m_lkts)
            cInitialBuckets = CSmallSegment::INITSIZE;
        else if (LK_MEDIUM_TABLESIZE == m_lkts)
            cInitialBuckets = CMediumSegment::INITSIZE;
        else if (LK_LARGE_TABLESIZE == m_lkts)
            cInitialBuckets = CLargeSegment::INITSIZE;
        else
            IRTLASSERT(! "Unknown LK_TABLESIZE");

        _SetSegVars(m_lkts, cInitialBuckets);
    }
} // CLKRLinearHashTable::_Clear



//------------------------------------------------------------------------
// Function: CLKRHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRHashTable::Clear()
{
    WriteLock();
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->_Clear(true);
    WriteUnlock();
} // CLKRHashTable::Clear



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRLinearHashTable::GetStatistics() const
{
    CLKRHashTableStats stats;

    if (!IsUsable())
        return stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                              / (1 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = NODES_PER_CLUMP;
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
        {
            int acc = 0;

            for (CNodeClump* pncCurr = &_Bucket(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                int j;

                FOR_EACH_NODE(j)
                {
                    if (!pncCurr->IsEmptySlot(j))
                    {
                        acc++;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _Bucket(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           ++;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                empty++;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx) /(1 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                    low_sl  = static_cast<double>(low_count)
                        / (2.0 * m_iExpansionIdx);
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                    high_sl = static_cast<double>(high_count)
                        / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // CLKRLinearHashTable::GetStatistics



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRHashTable::GetStatistics() const
{
    CLKRHashTableStats hts;

    if (!IsUsable())
        return hts;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        CLKRHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // CLKRHashTable::GetStatistics



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts,
    DWORD        cInitialBuckets)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
      {
        m_lkts      = LK_SMALL_TABLESIZE;
        m_dwSegBits = CSmallSegment::SEGBITS;
        m_dwSegSize = CSmallSegment::SEGSIZE;
        m_dwSegMask = CSmallSegment::SEGMASK;
        STATIC_ASSERT(CSmallSegment::SEGSIZE == (1U<<CSmallSegment::SEGBITS));
        STATIC_ASSERT(CSmallSegment::SEGMASK == (CSmallSegment::SEGSIZE-1));
        break;
      }
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
      {
        m_lkts      = LK_MEDIUM_TABLESIZE;
        m_dwSegBits = CMediumSegment::SEGBITS;
        m_dwSegSize = CMediumSegment::SEGSIZE;
        m_dwSegMask = CMediumSegment::SEGMASK;
        STATIC_ASSERT(CMediumSegment::SEGSIZE ==(1U<<CMediumSegment::SEGBITS));
        STATIC_ASSERT(CMediumSegment::SEGMASK == (CMediumSegment::SEGSIZE-1));
        break;
      }
        
    case LK_LARGE_TABLESIZE:
      {
        m_lkts      = LK_LARGE_TABLESIZE;
        m_dwSegBits = CLargeSegment::SEGBITS;
        m_dwSegSize = CLargeSegment::SEGSIZE;
        m_dwSegMask = CLargeSegment::SEGMASK;
        STATIC_ASSERT(CLargeSegment::SEGSIZE == (1U<<CLargeSegment::SEGBITS));
        STATIC_ASSERT(CLargeSegment::SEGMASK == (CLargeSegment::SEGSIZE-1));
        break;
      }
    }

    m_dwBktAddrMask0 = m_dwSegMask;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    m_nLevel         = m_dwSegBits;
    m_cActiveBuckets = cInitialBuckets;

    IRTLASSERT(m_cActiveBuckets > 0);

    IRTLASSERT(m_nLevel == m_dwSegBits);
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));

    IRTLASSERT(m_dwSegBits > 0);
    IRTLASSERT(m_dwSegSize == (1U << m_dwSegBits));
    IRTLASSERT(m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(m_dwBktAddrMask0 == m_dwSegMask);

    // adjust m_dwBktAddrMask0 (== m_dwSegMask) to make it large
    // enough to distribute the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
    }

    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask0;

    // create and clear directory of segments
    DWORD cDirSegs = MIN_DIRSIZE;
    while (cDirSegs < (m_cActiveBuckets >> m_dwSegBits))
        cDirSegs <<= 1;

    cDirSegs = min(cDirSegs, MAX_DIRSIZE);
    IRTLASSERT((cDirSegs << m_dwSegBits) >= m_cActiveBuckets);

    m_lkrcState = LK_ALLOC_FAIL;
    m_paDirSegs = _AllocateSegmentDirectory(cDirSegs);

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = cDirSegs;
        IRTLASSERT(m_cDirSegs >= MIN_DIRSIZE
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = (m_cActiveBuckets + m_dwSegSize - 1) >> m_dwSegBits;
        IRTLASSERT(dwMaxSegs <= m_cDirSegs);

        IRTLTRACE(TEXT("InitSegDir: m_lkts = %d, m_cActiveBuckets = %lu, ")
                  TEXT("m_dwSegSize = %lu, bits = %lu\n")
                  TEXT("m_cDirSegs = %lu, dwMaxSegs = %lu, ")
                  TEXT("segment total size = %lu bytes\n"),
                  m_lkts, m_cActiveBuckets,
                  m_dwSegSize, m_dwSegBits,
                  m_cDirSegs, dwMaxSegs,
                  m_dwSegSize * sizeof(CBucket));

        m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail

        for (DWORD i = 0;  i < dwMaxSegs;  i++)
        {
            CSegment* pSeg = _AllocateSegment();
            if (pSeg != NULL)
                m_paDirSegs[i].m_pseg = pSeg;
            else
            {
                // problem: deallocate everything
                m_lkrcState = LK_ALLOC_FAIL;
                for (DWORD j = i;  j-- > 0;  )
                {
                    _FreeSegment(m_paDirSegs[j].m_pseg);
                    m_paDirSegs[j].m_pseg = NULL;
                }
                _FreeSegmentDirectory();
                break;
            }
        }
    }

    if (m_lkrcState != LK_SUCCESS)
    {
        m_paDirSegs = NULL;
        m_cDirSegs  = m_cActiveBuckets = m_iExpansionIdx = 0;

        // Propagate error back up to parent (if it exists). This ensures
        // that all of the parent's public methods will start failing.
        if (m_phtParent != NULL)
            m_phtParent->m_lkrcState = m_lkrcState;
    }

    return m_lkrcState;
} // CLKRLinearHashTable::_SetSegVars




#include <stdlib.h>

LONG g_cAllocDirEntry = 0;
LONG g_cAllocNodeClump = 0;
LONG g_cAllocSmallSegment = 0;
LONG g_cAllocMediumSegment = 0;
LONG g_cAllocLargeSegment = 0;

extern "C"
__declspec(dllexport)
bool
GetAllocCounters()
{
return true;
}

// #define LKR_RANDOM_MEMORY_FAILURES 1000  // 1..RAND_MAX (32767)

// Memory allocation wrappers to allow us to simulate allocation
// failures during testing

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

CDirEntry* const
CLKRLinearHashTable::_AllocateSegmentDirectory(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocDirEntry);

    CDirEntry* const paDirSegs = new CDirEntry [n];

#ifdef IRTLDEBUG
    for (size_t i = 0;  i < n;  ++i)
        IRTLASSERT(paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    return paDirSegs;
} // CLKRLinearHashTable::_AllocateSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegmentDirectory()
{
#ifdef IRTLDEBUG
    for (size_t i = 0;  i < m_cDirSegs;  ++i)
        IRTLASSERT(m_paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    delete [] m_paDirSegs;
    m_paDirSegs = NULL;
    m_cDirSegs = 0;
    return true;
} // CLKRLinearHashTable::_FreeSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateNodeClump
// Synopsis: 
//------------------------------------------------------------------------

CNodeClump* const
CLKRLinearHashTable::_AllocateNodeClump()
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocNodeClump);
    return new CNodeClump;
} // CLKRLinearHashTable::_AllocateNodeClump



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeNodeClump
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeNodeClump(
    CNodeClump* pnc)
{
    delete pnc;
    return true;
} // CLKRLinearHashTable::_FreeNodeClump



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegment
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

CSegment* const
CLKRLinearHashTable::_AllocateSegment(
    ) const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CSmallSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CMediumSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CLargeSegment, m_bktSlots2));

    CSegment* pseg = NULL;

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CSmallSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocSmallSegment);
        pseg = new CSmallSegment;
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CMediumSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocMediumSegment);
        pseg = new CMediumSegment;
        break;
        
    case LK_LARGE_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLargeSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocLargeSegment);
        pseg = new CLargeSegment;
        break;
    }

    IRTLASSERT(pseg != NULL);

    if (pseg != NULL  &&  BucketLock::PerLockSpin() == LOCK_INDIVIDUAL_SPIN)
    {
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }

    return pseg;
} // CLKRLinearHashTable::_AllocateSegment



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegment(
    CSegment* pseg) const
{
    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        delete static_cast<CSmallSegment*>(pseg);
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        delete static_cast<CMediumSegment*>(pseg);
        break;
        
    case LK_LARGE_TABLESIZE:
        delete static_cast<CLargeSegment*>(pseg);
        break;
    }

    return true;
} // CLKRLinearHashTable::_FreeSegment



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable** const
CLKRHashTable::_AllocateSubTableArray(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    return new SubTable* [n];
} // CLKRHashTable::_AllocateSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTableArray(
    CLKRHashTable::SubTable** palht)
{
    delete [] palht;
    return true;
} // CLKRHashTable::_FreeSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTable
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable* const
CLKRHashTable::_AllocateSubTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    return new SubTable(pszName, pfnExtractKey, pfnCalcKeyHash,
                        pfnEqualKeys,  pfnAddRefRecord,
                        maxload, initsize, phtParent, fMultiKeys);
} // CLKRHashTable::_AllocateSubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTable
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTable(
    CLKRHashTable::SubTable* plht)
{
    delete plht;
    return true;
} // CLKRHashTable::_FreeSubTable




//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Expand
// Synopsis: Expands the table by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed due to lack of memory.
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Expand()
{
    if (m_cActiveBuckets >= MAX_DIRSIZE * m_dwSegSize - 1)
        return LK_ALLOC_FAIL;  // table is not allowed to grow any more

    WriteLock();

    // double segment directory size if necessary
    if (m_cActiveBuckets >= m_cDirSegs * m_dwSegSize)
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);
        DWORD cDirSegsNew = (m_cDirSegs == 0) ? MIN_DIRSIZE : m_cDirSegs << 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  j++)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j].m_pseg = NULL;
            }

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
        else
        {
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
    }

    // locate the new bucket, creating a new segment if necessary
    ++m_cActiveBuckets;

    DWORD     dwOldBkt = m_iExpansionIdx;
    DWORD     dwNewBkt = (1 << m_nLevel) | dwOldBkt;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    IRTLASSERT(_Segment(dwOldBkt) != NULL);
    CSegment* psegNew  = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _AllocateSegment();
        if (psegNew == NULL)
        {
            --m_cActiveBuckets;
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
        _Segment(dwNewBkt) = psegNew;
    }

    // prepare to relocate records to the new bucket
    CBucket* pbktOld = _Bucket(dwOldBkt);
    CBucket* pbktNew = _Bucket(dwNewBkt);

    // get locks on the two buckets involved
    pbktOld->WriteLock();
    pbktNew->WriteLock();

    // Now work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _SplitRecordSet, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.

    CNodeClump* pncFreeList = NULL;
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // If the old bucket has more than one CNodeClump, there's a chance that
    // we'll need extra CNodeClumps in the new bucket too.  If it doesn't,
    // we definitely won't. One CNodeClump is enough to prime the freelist.
    if (!pbktOld->m_ncFirst.IsLastClump())
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            --m_cActiveBuckets;
        }
    }

    // adjust expansion pointer, level, and mask
    if (lkrc == LK_SUCCESS)
    {
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            // m_dwBktAddrMask0 = 00011..111
            IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
            IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
        }
    }

    DWORD iExpansionIdx = m_iExpansionIdx;  // save to avoid race conditions
    DWORD dwBktAddrMask = m_dwBktAddrMask0; // ditto

    // Release the table lock before doing the actual relocation
    WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        lkrc = _SplitRecordSet(&pbktOld->m_ncFirst, &pbktNew->m_ncFirst,
                               iExpansionIdx, dwBktAddrMask,
                               dwNewBkt, pncFreeList);
    }

    pbktNew->WriteUnlock();
    pbktOld->WriteUnlock();

    return lkrc;
} // CLKRLinearHashTable::_Expand



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SplitRecordSet
// Synopsis: Split records between the old and new buckets.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SplitRecordSet(
    CNodeClump* pncOldTarget,
    CNodeClump* pncNewTarget,
    DWORD       iExpansionIdx,
    DWORD       dwBktAddrMask,
    DWORD       dwNewBkt,
    CNodeClump* pncFreeList     // list of free nodes available for reuse
    )
{
    CNodeClump  ncFirst = *pncOldTarget;    // save head of old target chain
    CNodeClump* pncOldList = &ncFirst;
    CNodeClump* pncTmp;
    int         iOldSlot = NODE_BEGIN;
    int         iNewSlot = NODE_BEGIN;

    // clear target buckets
    pncOldTarget->Clear();
    pncNewTarget->Clear();

    // scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            // node already empty?
            if (pncOldList->IsEmptySlot(i))
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
                continue;
            }

            // calculate bucket address of this node
            DWORD dwBkt = _H0(pncOldList->m_dwKeySigs[i], dwBktAddrMask);
            if (dwBkt < iExpansionIdx)
                dwBkt = _H1(pncOldList->m_dwKeySigs[i], dwBktAddrMask);

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // node in new bucket chain full?
                if (iNewSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];
                iNewSlot += NODE_STEP;
            }

            // no, record stays in its current bucket chain
            else
            {
                // node in old bucket chain full?
                if (iOldSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    iOldSlot = NODE_BEGIN;
                }

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[i];
                iOldSlot += NODE_STEP;
            }

            // clear old slot
            pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            pncOldList->m_pvNode[i]    = NULL;
        }

        // keep walking down the original bucket chain
        pncTmp     = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

#ifdef IRTLDEBUG
    ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_SplitRecordSet



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Contract
// Synopsis: Contract the table by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Contract()
{
    WriteLock();

    // update the state variables (expansion ptr, level and mask)
    if (m_iExpansionIdx > 0)
        --m_iExpansionIdx;
    else
    {
        --m_nLevel;
        m_iExpansionIdx = (1 << m_nLevel) - 1;
        IRTLASSERT(m_nLevel > 0  &&  m_iExpansionIdx > 0);
        m_dwBktAddrMask0 >>= 1;
        IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
        m_dwBktAddrMask1 >>= 1;
        IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
        IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    }

    // The last bucket is the one that will be emptied
    CBucket* pbktLast = _Bucket(m_cActiveBuckets - 1);
    pbktLast->WriteLock();

    // Decrement after calculating pbktLast, or _Bucket() will assert.
    --m_cActiveBuckets;

    // Where the nodes from pbktLast will end up
    CBucket* pbktNew = _Bucket(m_iExpansionIdx);
    pbktNew->WriteLock();

    // Now we work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _MergeRecordSets, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.
    
    CNodeClump* pnc;
    int         c = 0;

    // First, count the number of items in the old bucket
    for (pnc = &pbktLast->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pnc->IsEmptySlot(i))
            {
                IRTLASSERT(!pnc->IsEmptyAndInvalid(i));
                c++;
            }
        }
    }

    // Then, subtract off the number of empty slots in the new bucket
    for (pnc = &pbktNew->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pnc->IsEmptySlot(i))
            {
                IRTLASSERT(pnc->IsEmptyAndInvalid(i));
                c--;
            }
        }
    }

    CNodeClump* pncFreeList = NULL;  // list of nodes available for reuse
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // Do we need to allocate CNodeClumps to accommodate the surplus items?
    if (c > 0)
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
            lkrc = LK_ALLOC_FAIL;
        else if (c > NODES_PER_CLUMP)
        {
            // In the worst case, we need a 2-element freelist for
            // _MergeRecordSets. Two CNodeClumps always suffice since the
            // freelist will be augmented by the CNodeClumps from the old
            // bucket as they are processed.
            pnc = _AllocateNodeClump();
            if (pnc == NULL)
            {
                _FreeNodeClump(pncFreeList);
                lkrc = LK_ALLOC_FAIL;
            }
            else
                pncFreeList->m_pncNext = pnc;
        }
    }

    // Abort if we couldn't allocate enough CNodeClumps
    if (lkrc != LK_SUCCESS)
    {
        // undo the changes to the state variables
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx  = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
        }
        ++m_cActiveBuckets;

        // Unlock the buckets and the table
        pbktLast->WriteUnlock();
        pbktNew->WriteUnlock();
        WriteUnlock();

        return lkrc;
    }

    // Copy the chain of records from pbktLast
    CNodeClump ncOldFirst = pbktLast->m_ncFirst;

    // destroy pbktLast
    pbktLast->m_ncFirst.Clear();
    pbktLast->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef IRTLDEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
        {
            CBucket* pbkt = &_Segment(m_cActiveBuckets)->Slot(i);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->m_ncFirst.IsLastClump());

            int j;

            FOR_EACH_NODE(j)
            {
                IRTLASSERT(pbkt->m_ncFirst.IsEmptyAndInvalid(j));
            }
        }
#endif // IRTLDEBUG
        _FreeSegment(_Segment(m_cActiveBuckets));
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= (m_cDirSegs * m_dwSegSize) >> 1
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        // Memory allocation failure here does not require us to abort; it
        // just means that the directory of segments is larger than we'd like.
        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < cDirSegsNew;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the table lock before doing the reorg
    WriteUnlock();

    lkrc = _MergeRecordSets(pbktNew, &ncOldFirst, pncFreeList);

    pbktNew->WriteUnlock();

#ifdef IRTLDEBUG
    ncOldFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return lkrc;
} // CLKRLinearHashTable::_Contract



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_MergeRecordSets
// Synopsis: Merge two record sets.  Copy the contents of pncOldList
//           into pbktNewTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_MergeRecordSets(
    CBucket*    pbktNewTarget,
    CNodeClump* pncOldList,
    CNodeClump* pncFreeList
    )
{
    IRTLASSERT(pbktNewTarget != NULL  &&  pncOldList != NULL);

    CNodeClump*   pncTmp = NULL;
    CNodeClump* const pncOldFirst = pncOldList;
    CNodeClump*   pncNewTarget = &pbktNewTarget->m_ncFirst;
    int           iNewSlot;

    // find the first nodeclump in the new target bucket with an empty slot
    while (!pncNewTarget->IsLastClump())
    {
        FOR_EACH_NODE(iNewSlot)
        {
            if (pncNewTarget->IsEmptySlot(iNewSlot))
                break;
        }

        if (iNewSlot == NODE_END)
            pncNewTarget = pncNewTarget->m_pncNext;
        else
            break;
    }

    IRTLASSERT(pncNewTarget != NULL);

    // find the first empty slot in pncNewTarget;
    // if none, iNewSlot == NODE_END
    FOR_EACH_NODE(iNewSlot)
    {
        if (pncNewTarget->IsEmptySlot(iNewSlot))
        {
            break;
        }
    }
    
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pncOldList->IsEmptySlot(i))
            {
                // any empty slots left in pncNewTarget?
                if (iNewSlot == NODE_END)
                {
                    // no, so walk down pncNewTarget until we find another
                    // empty slot
                    while (!pncNewTarget->IsLastClump())
                    {
                        pncNewTarget = pncNewTarget->m_pncNext;

                        FOR_EACH_NODE(iNewSlot)
                        {
                            if (pncNewTarget->IsEmptySlot(iNewSlot))
                                goto found_slot;
                        }
                    }

                    // Oops, reached the last nodeclump in pncNewTarget
                    // and it's full.  Get a new nodeclump off the free
                    // list, which is big enough to handle all needs.
                    IRTLASSERT(pncNewTarget != NULL);
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

              found_slot:
                // We have an empty slot in pncNewTarget
                IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < NODES_PER_CLUMP
                       &&  pncNewTarget != NULL
                       &&  pncNewTarget->IsEmptyAndInvalid(iNewSlot));

                // Let's copy the node from pncOldList
                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];

                // Clear old slot
                pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                pncOldList->m_pvNode[i]    = NULL;

                // find the next free slot in pncNewTarget
                while ((iNewSlot += NODE_STEP) != NODE_END)
                {
                    if (pncNewTarget->IsEmptySlot(iNewSlot))
                    {
                        break;
                    }
                }
            }
            else // iNewSlot != NODE_END
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
            }
        }

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // Append to the free list.  Don't put the first node of
        // pncOldList on the free list, as it's a stack variable.
        if (pncTmp != pncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

    return LK_SUCCESS;
} // CLKRLinearHashTable::_MergeRecordSets



#ifdef LKR_DEPRECATED_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);
    if (piter->m_lkl == LKL_WRITELOCK)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = NODE_BEGIN - NODE_STEP;

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
} // CLKRLinearHashTable::_InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
} // CLKRHashTable::InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode != NODE_BEGIN - NODE_STEP)
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, -1);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((piter->m_iNode += NODE_STEP) != NODE_END)
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
                if (pvRecord != NULL)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, +1);
                    return LK_SUCCESS;
                }
                else // pvRecord == NULL
                {
#ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(piter->m_pnc->IsLastClump());
                    for (int i = piter->m_iNode;
                         i != NODE_END;
                         i += NODE_STEP)
                    {
                        IRTLASSERT(piter->m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = NODE_BEGIN - NODE_STEP;
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _Bucket(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = NODE_BEGIN - NODE_STEP;
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
} // CLKRLinearHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    // Table is already locked
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
} // CLKRHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the table?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, -1);
        }
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
} // CLKRLinearHashTable::_CloseIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    LK_RETCODE lkrc = LK_SUCCESS;

    if (!IsValid())
        lkrc = LK_UNUSABLE;
    else
    {
        // Are we abandoning the iterator before we've reached the end?
        // If so, close the subtable iterator.
        if (piter->m_plht != NULL)
        {
            IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
            CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
            piter->m_plht->_CloseIterator(pBaseIter);
        }
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return lkrc;
} // CLKRHashTable::CloseIterator

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRLinearHashTable::Iterator
CLKRLinearHashTable::Begin()
{
    Iterator iter(this, &_Bucket(0)->m_ncFirst, 0, NODE_BEGIN - NODE_STEP);

    LKR_ITER_TRACE(_TEXT("  LKLH:Begin(it=%p, plht=%p)\n"), &iter, this);
    
    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRLinearHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable_Iterator::Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRLinearHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_plht != NULL);
    IRTLASSERT(m_dwBucketAddr < m_plht->m_cActiveBuckets);
    IRTLASSERT(m_pnc != NULL);
    IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == m_iNode));

    // Release the reference acquired in the previous call to _Increment
    if (fDecrementOldValue)
        _AddRef(-1);

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((m_iNode += NODE_STEP) != NODE_END)
            {
                const void* pvRecord = m_pnc->m_pvNode[m_iNode];

                if (pvRecord != NULL)
                {
                    IRTLASSERT(!m_pnc->InvalidSignature(m_iNode));

                    // Add a new reference
                    _AddRef(+1);

                    LKR_ITER_TRACE(_TEXT("  LKLH:++(this=%p, plht=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_plht, m_pnc,
                                   m_dwBucketAddr, m_iNode, pvRecord);

                    return true;
                }
                else // pvRecord == NULL
                {
#if 0 //// #ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(m_pnc->IsLastClump());

                    for (int i = m_iNode;  i != NODE_END;  i += NODE_STEP)
                    {
                        IRTLASSERT(m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            m_iNode = NODE_BEGIN - NODE_STEP;
            m_pnc = m_pnc->m_pncNext;

        } while (m_pnc != NULL);

        // Try the next bucket, if there is one
        if (++m_dwBucketAddr < m_plht->m_cActiveBuckets)
        {
            CBucket* pbkt = m_plht->_Bucket(m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            m_pnc = &pbkt->m_ncFirst;
        }

    } while (m_dwBucketAddr < m_plht->m_cActiveBuckets);

    // We have fallen off the end of the hashtable. Set iterator equal
    // to end(), the empty iterator.
    LKR_ITER_TRACE(_TEXT("  LKLH:End(this=%p, plht=%p)\n"), this, m_plht);

    m_plht = NULL;
    m_pnc = NULL;
    m_dwBucketAddr = 0;
    m_iNode = 0;

    //// IRTLASSERT(this->operator==(Iterator())); // == end()

    return false;
} // CLKRLinearHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Insert
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    bool fSuccess = (_InsertRecord(pvRecord,
                                  _CalcKeyHash(_ExtractKey(pvRecord)),
                                  fOverwrite,
                                  &riterResult)
                     == LK_SUCCESS);

    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fSuccess
               ?  _IsValidIterator(riterResult)
               :  riterResult == End());

    return fSuccess;
} // CLKRLinearHashTable::Insert()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_Erase(
    Iterator& riter,
    DWORD     dwSignature)
{
    CNodeClump* pncCurr, *pncPrev;
    CBucket* const pbkt = riter.m_plht->_Bucket(riter.m_dwBucketAddr);

    LKR_ITER_TRACE(_TEXT("  LKLH:_Erase:pre(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);

    pbkt->WriteLock();

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        if (pncCurr == riter.m_pnc)
            break;
    }
    IRTLASSERT(pncCurr != NULL);

    // Release the iterator's reference on the record
    const void* pvRecord = riter.m_pnc->m_pvNode[riter.m_iNode];
    IRTLASSERT(pvRecord != NULL);
    _AddRefRecord(pvRecord, -1);

    // _DeleteNode will leave iterator members pointing to the
    // preceding record
    int iNode = riter.m_iNode;
    IRTLVERIFY(_DeleteNode(pbkt, riter.m_pnc, pncPrev, iNode));

    if (iNode == NODE_END)
        LKR_ITER_TRACE(_TEXT("\t_Erase(BKT=%p, PNC=%p, PREV=%p, INODE=%d)\n"),
                       pbkt, riter.m_pnc, pncPrev, iNode);
                  
    riter.m_iNode = (iNode == NODE_END)  ? NODE_END-NODE_STEP  : (short) iNode;

    pbkt->WriteUnlock();

    // Don't contract the table. Likely to invalidate the iterator,
    // if iterator is being used in a loop

    return true;
} // CLKRLinearHashTable::_Erase()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:pre(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    bool fSuccess = _Erase(riter, dwSignature);
    bool fIncrement = false;
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL,
                   (fSuccess ? "true" : "false"));
    
    // _Erase left riter pointing to the preceding record.
    // Move to next record.
    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter == End());
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post++(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n  LKLH:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT("  LKLH:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    bool        fFound   = (_FindKey(pnKey, hash_val, &pvRecord, &riterResult)
                            == LK_SUCCESS);

    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());
    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);

    return fFound;
} // CLKRLinearHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT("  LKLH:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound ?  _IsValidIterator(riterFirst) :  riterFirst == End());

    IRTLASSERT(riterLast.m_iNode  != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRLinearHashTable::EqualRange



//------------------------------------------------------------------------
// Function: CLKRHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRHashTable::Iterator
CLKRHashTable::Begin()
{
    Iterator iter(this, -1);

    LKR_ITER_TRACE(_TEXT(" LKHT:Begin(it=%p, pht=%p)\n"), &iter, this);

    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_ist != -1);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRHashTable_Iterator::_Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_pht != NULL);
    IRTLASSERT(-1 <= m_ist
               &&  m_ist < static_cast<int>(m_pht->m_cSubTables));

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (m_subiter.m_plht == NULL)
        {
            while (++m_ist < static_cast<int>(m_pht->m_cSubTables))
            {
                LKR_ITER_TRACE(_TEXT(" LKHT:++IST=%d\n"), m_ist);
                m_subiter = m_pht->m_palhtDir[m_ist]->Begin();

                if (m_subiter.m_plht != NULL)
                {
                    LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                                   _TEXT("LHT=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_pht, m_ist,
                                   m_subiter.m_plht, m_subiter.m_pnc,
                                   m_subiter.m_dwBucketAddr, m_subiter.m_iNode,
                                   m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]
                                  );
                    return true;
                }
            }
            
            // There are no more subtables left.
            LKR_ITER_TRACE(_TEXT(" LKHT:End(this=%p, pht=%p)\n"), this, m_pht);

            m_pht = NULL;
            m_ist = 0;

            //// IRTLASSERT(this->operator==(Iterator())); // == end()
            
            return false;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        m_subiter._Increment(fDecrementOldValue);

        if (m_subiter.m_plht != NULL)
        {
            LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                           _TEXT("LHT=%p, NC=%p, BA=%u, IN=%d, Rec=%p)\n"),
                           this, m_pht, m_ist,
                           m_subiter.m_plht, m_subiter.m_pnc,
                           m_subiter.m_dwBucketAddr, m_subiter.m_iNode, 
                           m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]);
            return true;
        }
    }
} // CLKRHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRHashTable::Insert
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);

    bool f = (pst->_InsertRecord(pvRecord, hash_val, fOverwrite,
                                 &riterResult.m_subiter)
              == LK_SUCCESS);

    if (f)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(f  ?  _IsValidIterator(riterResult)  :  riterResult == End());

    return f;
} // CLKRHashTable::Insert



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD     dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    SubTable* const pst   = _SubTable(dwSignature);

    IRTLASSERT(pst == riter.m_subiter.m_plht);

    if (pst != riter.m_subiter.m_plht)
        return false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:pre(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    // _Erase left riter pointing to the preceding record. Move to
    // next record.
    bool fSuccess = pst->_Erase(riter.m_subiter, dwSignature);
    bool fIncrement = false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   ((riter.m_subiter.m_pnc && riter.m_subiter.m_iNode >= 0)
                        ? riter.Record() : NULL),
                   (fSuccess ? "true" : "false"));

    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_ist != -1);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter  == End());

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post++(iter=%p, pht=%p, ist=%d, ")
                   _TEXT("plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n LKHT:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    bool        fFound   = (pst->_FindKey(pnKey, hash_val, &pvRecord,
                                          &riterResult.m_subiter)
                            == LK_SUCCESS);
    if (fFound)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());

    return fFound;
} // CLKRHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_ist != -1);
    IRTLASSERT(fFound ? _IsValidIterator(riterFirst) : riterFirst == End());

    IRTLASSERT(riterLast.m_ist != -1);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRHashTable::EqualRange


#endif // LKR_STL_ITERATORS



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKRHashTable::WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->WriteLock();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::WriteLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKRHashTable::ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ReadLock();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ReadLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::WriteUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
        m_palhtDir[i]->WriteUnlock();
        IRTLASSERT(m_palhtDir[i]->IsWriteUnlocked());
    }
} // CLKRHashTable::WriteUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
        m_palhtDir[i]->ReadUnlock();
        IRTLASSERT(m_palhtDir[i]->IsReadUnlocked());
    }
} // CLKRHashTable::ReadUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteLocked
// Synopsis: Are all subtables write-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsWriteLocked();
    }
    return fLocked;
} // CLKRHashTable::IsWriteLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadLocked
// Synopsis: Are all subtables read-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsReadLocked();
    }
    return fLocked;
} // CLKRHashTable::IsReadLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteUnlocked
// Synopsis: Are all subtables write-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsWriteUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsWriteUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadUnlocked
// Synopsis: Are all subtables read-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsReadUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsReadUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertSharedToExclusive
// Synopsis: Convert the read lock to a write lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertSharedToExclusive() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertSharedToExclusive();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::ConvertSharedToExclusive



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertExclusiveToShared
// Synopsis: Convert the write lock to a read lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertExclusiveToShared() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertExclusiveToShared();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ConvertExclusiveToShared



//------------------------------------------------------------------------
// Function: CLKRHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        cSize += m_palhtDir[i]->Size();

    return cSize;
} // CLKRHashTable::Size



//------------------------------------------------------------------------
// Function: CLKRHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
} // CLKRHashTable::MaxSize



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  i++)
        f = f && m_palhtDir[i]->IsValid();

    if (!f)
        m_lkrcState = LK_UNUSABLE;

    return f;
} // CLKRHashTable::IsValid



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

    if (BucketLock::PerLockSpin() != LOCK_INDIVIDUAL_SPIN)
        return;
    
    for (DWORD i = 0;  i < m_cDirSegs;  i++)
    {
        CSegment* pseg = m_paDirSegs[i].m_pseg;

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_dwSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
} // CLKRLinearHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetBucketLockSpinCount() const
{
    return m_wBucketLockSpins;
} // CLKRLinearHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
} // CLKRHashTable::SetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetTableLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
} // CLKRHashTable::GetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
} // CLKRHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetBucketLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
} // CLKRHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::MultiKeys
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::MultiKeys() const
{
    return ((m_cSubTables == 0)
            ?  false
            :  m_palhtDir[0]->MultiKeys());
} // CLKRHashTable::MultiKeys



#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\mb.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mb.cxx

Abstract:

    This module implements the MB class using the DCOM interface.

    The old MB class (IIS4.0) was used internally within the IIS codebase to 
    access the metabase objects locally inprocess. This allowed  access to
    the metabase using the inprocess ANSI/COM interface.
  
    In the current incarnation, MB class attempts to support the following:
    o  Support UNICODE only interface to items
    o  Use only the DCOM interface of the Metabase (IMSAdminBase interface)
    o  Expose similar functionality like the MB class.

    Return Values:
      Almost all MB class members return BOOL values. 
      TRUE indicates success in the operation and FALSE indicates a failure.
      The class is expected to be used in-process for code that is mostly
        reliant on the Win32 style error reporting, it sets the error code in
        the thread and exposes them via GetLastError() interface.
Author:

    Murali Krishnan (MuraliK)        03-Nov-1998

Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"

#include <iadmw.h>
#include <mb.hxx>
#include "dbgutil.h"

//
//  Default timeout
//

#define MB_TIMEOUT           (30 * 1000)

//
//  Default timeout for SaveData
//

#define MB_SAVE_TIMEOUT      (10 * 1000)        // milliseconds


/************************************************************
 *     Member Functions of MB
 ************************************************************/

MB::MB( IMSAdminBase * pAdminBase )
    : m_pAdminBase( pAdminBase ),
      m_hMBPath ( NULL)
{
    DBG_ASSERT( m_pAdminBase != NULL);

    //
    // Add ref the admin base object so that we can keep this object around.
    // 
    m_pAdminBase->AddRef();
}

MB::~MB( VOID )
{
    //
    // Close the metabase handle if we have it open
    // 
    if ( NULL != m_hMBPath) {
        //
        // Close can sometimes fail with error RPC_E_DISCONNECTED.
        // Do not Assert
        //
        Close();
    }

    //
    // Release the AdminBase object here 
    //
    if ( NULL != m_pAdminBase) {
        m_pAdminBase->Release();
        m_pAdminBase = NULL;
    }
} // MB::~MB()




/*********************************************************************++

Routine Description:

    Opens the metabase and saves the metabase handle in the current object.
    Note: If there is already an opened handle, this method will fail.

Arguments:

    hOpenRoot - Relative root or METADATA_MASTER_ROOT_HANDLE
    pwszPath  - Path to open
    dwFlags   - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())
    The handle opened is stored inside the MB object.

--*********************************************************************/
BOOL 
MB::Open( METADATA_HANDLE hOpenRoot,
          LPCWSTR    pwszPath,
          DWORD      dwFlags )
{
    HRESULT hr;

    if ( m_hMBPath != NULL) {
        SetLastError( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));
        return (FALSE);
    }

    hr = m_pAdminBase->OpenKey( hOpenRoot,
                                pwszPath,
                                dwFlags,
                                MB_TIMEOUT,
                                &m_hMBPath );
    
    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ) );
    return FALSE;
} // MB::Open()



/*********************************************************************++
  Routine Descrition:
    This function closes the metabase handle that we have open in 
    this MB object

  Arguments:
    None

  Returns:
    TRUE on success
    FALSE if there are any errors. Use GetLastError() to retrieve the error
      on failure.
--*********************************************************************/

BOOL MB::Close( VOID )
{
    if ( m_hMBPath )
    {
        HRESULT hr;

        hr = m_pAdminBase->CloseKey( m_hMBPath );

        if (FAILED(hr)) {
            SetLastError( HRESULTTOWIN32( hr));
            return (FALSE);
        }

        m_hMBPath = NULL;
    }

    return TRUE;
} // MB::Close()



/*********************************************************************++
  Routine Descrition:
    This function saves all the changes that we have made using current
    metabase object.

  Arguments:
    None

  Returns:
    TRUE on success
    FALSE if there are any errors. Use GetLastError() to retrieve the error
      on failure.
--*********************************************************************/
BOOL MB::Save( VOID )
{
    HRESULT hr;
    METADATA_HANDLE mdhRoot;

    if ( NULL != m_pAdminBase) { 
        hr = m_pAdminBase->SaveData();

        if ( FAILED( hr)) {
            SetLastError( HRESULTTOWIN32( hr));
            return (FALSE);
        }
    }
        
    return (TRUE);
} // MB::Save()




/*********************************************************************++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath    - Path to get the data on
    dwFlags    - Inerhitance flags
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to data
    pcbData    - Size of pvData, receives size of object
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetAll( IN LPCWSTR     pszPath,
            DWORD          dwFlags,
            DWORD          dwUserType,
            BUFFER *       pBuff,
            DWORD *        pcRecords,
            DWORD *        pdwDataSetNumber )
{
    DWORD   RequiredSize;
    HRESULT hr;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    do {

        hr = m_pAdminBase->
            GetAllData( m_hMBPath,
                        pszPath,
                        dwFlags,
                        dwUserType,
                        ALL_METADATA,
                        pcRecords,
                        pdwDataSetNumber,
                        pBuff->QuerySize(),
                        (PBYTE)pBuff->QueryPtr(),
                        &RequiredSize
                        );
        
        // See if we got it, and if we failed because of lack of buffer space
        // try again.
        
        if ( SUCCEEDED(hr) ) {
                return TRUE;
        }
        
        //
        // Some sort of error, most likely not enough buffer space. Keep
        // trying until we get a non-fatal error.
        //
        
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32 &&
            HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
            
            // Not enough buffer space. RequiredSize contains the amount
            // the metabase thinks we need.
            
            if ( !pBuff->Resize(RequiredSize) ) {
                
                // Not enough memory to resize.
                return FALSE;
            }
        } else {
          
            //
            // Some other failure: return the failure to caller
            //

            SetLastError(HRESULTTOWIN32(hr));
            break;
        }
    } while (FAILED(hr));

    return FALSE;
} // MB::GetAll()



/*********************************************************************++
  Routine Description:
    This function retrieves the data set number from the metabase
     for the given path.

  Arguments:
    pszPath - pointer to string containing the path for metabase item
    pdwDataSetNumber - pointer to DWORD that will contain the dataset
               number on return.

  Returns:
    TRUE on success. FALSE for failure
--*********************************************************************/
BOOL
MB::GetDataSetNumber(IN LPCWSTR pszPath,
                     OUT DWORD * pdwDataSetNumber)
{
    DWORD   RequiredSize;
    HRESULT hr;

    DBG_ASSERT ( m_pAdminBase != NULL);

    //
    //  NULL metabase handle is permitted here
    //

    hr = m_pAdminBase->GetDataSetNumber( m_hMBPath, pszPath, pdwDataSetNumber);
    if (FAILED (hr)) {
        SetLastError( HRESULTTOWIN32( hr));
        return (FALSE);
    }

    return (TRUE);
} // MB::GetDataSetNumber()



/*********************************************************************++
  Routine Description:
    Enumerates and obtain the name of the object at given index position
     within the given path in the tree.

  Arguments:
    pszPath - pointer to string containing the path for metabase item
    pszName - pointer to a buffer that will contain the name of the item
              at index position [dwIndex]. The buffer should at least be
              ADMINDATA_MAX_NAME_LEN+1 character in length
    dwIndex - index for the item to be enumerated.

  Returns:
    TRUE on success. FALSE for failure.
    ERROR_NO_MORE_ITEMS when the end of the list is reached.

  A typical use is to enumerate for all items starting at index 0 and 
   enumerating till the return value is FALSE with error = ERROR_NO_MORE_ITEMS
--*********************************************************************/
BOOL
MB::EnumObjects( IN LPCWSTR  pszPath,
                 OUT LPWSTR  pszName,
                 IN DWORD    dwIndex )
{
    HRESULT hr = m_pAdminBase->EnumKeys( m_hMBPath,
                                           pszPath,
                                           pszName,
                                           dwIndex );

    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ));
    return FALSE;
} // MB::EnumObjects()


BOOL
MB::AddObject( IN LPCWSTR pszPath)
{
    HRESULT hr;
    
    hr = m_pAdminBase->AddKey( m_hMBPath, pszPath);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);

} // MB::AddObject()


BOOL
MB::DeleteObject( IN LPCWSTR pszPath)
{
    HRESULT hr;
    
    hr = m_pAdminBase->DeleteKey( m_hMBPath, pszPath);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // MB::DeleteObject()


BOOL
MB::DeleteData(
   IN LPCWSTR  pszPath,
   IN DWORD    dwPropID,
   IN DWORD    dwUserType,
   IN DWORD    dwDataType )
{
    HRESULT hr = m_pAdminBase->DeleteData( m_hMBPath,
                                           pszPath,
                                           dwPropID,
                                           dwDataType
                                           );
    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ));
    return(FALSE);
} // MB::DeleteData()


BOOL
MB::GetSystemChangeNumber( OUT DWORD * pdwChangeNumber)
{
    HRESULT hr = m_pAdminBase->GetSystemChangeNumber( pdwChangeNumber);
    
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} 


/*********************************************************************++

Routine Description:

    Sets a metadata property on an opened metabase path.

Arguments:

    pszPath    - Path to set data on
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to data buffer containing the data.
    cbData     - Size of data
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::SetData( IN LPCWSTR pszPath,
             IN DWORD   dwPropID,
             IN DWORD   dwUserType,
             IN DWORD   dwDataType,
             IN VOID *  pvData,
             IN DWORD   cbData,
             IN DWORD   dwFlags )
{
    HRESULT hr;
    METADATA_RECORD mdr;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    mdr.dwMDIdentifier = dwPropID;
    mdr.dwMDAttributes = dwFlags;
    mdr.dwMDUserType   = dwUserType;
    mdr.dwMDDataType   = dwDataType;
    mdr.dwMDDataLen    = cbData;
    mdr.pbMDData       = (BYTE * ) pvData;

    hr = m_pAdminBase->SetData(m_hMBPath, pszPath, &mdr);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);

} // MB::SetData()




/*********************************************************************++

Routine Description:

    Obtains the metadata requested in the call. 
    It uses the current opened metabase path for getting the data.

Arguments:

    pszPath    - Path to get data on
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to buffer in which the data will be obtained
    pcbData    - Size of data
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetData( IN LPCWSTR pszPath,
             IN DWORD   dwPropID,
             IN DWORD   dwUserType,
             IN DWORD   dwDataType,
             OUT VOID * pvData,
             IN OUT DWORD *  pcbData,
             IN DWORD   dwFlags)
{
    HRESULT hr;
    METADATA_RECORD mdr;
    DWORD           dwRequiredDataLen;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    mdr.dwMDIdentifier = dwPropID;
    mdr.dwMDAttributes = dwFlags;
    mdr.dwMDUserType   = dwUserType;
    mdr.dwMDDataType   = dwDataType;
    mdr.dwMDDataLen    = *pcbData;
    mdr.pbMDData       = (BYTE * ) pvData;

    hr = m_pAdminBase->GetData(m_hMBPath, pszPath, &mdr, &dwRequiredDataLen);

    if (SUCCEEDED(hr)) {
        *pcbData = mdr.dwMDDataLen;
        return ( TRUE);
    } 

    *pcbData = dwRequiredDataLen;

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // MB::GetData()



/*********************************************************************++

Routine Description:

    Obtains the paths beneath the given path in the metadata tree.
    It uses the current opened metabase path for getting the data.

Arguments:

    pszPath - Path to get data on
    dwPropID - Metabase property ID
    dwDataType - Type of data being set (dword, string etc)
    pBuff    - pointer to BUFFER object that will contain the resulting data

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetDataPaths(IN LPCWSTR   pszPath,
                 IN DWORD     dwPropID,
                 IN DWORD     dwDataType,
                 IN BUFFER *  pBuff )
{
    HRESULT hr;
    METADATA_RECORD mdr;
    DWORD           cchRequiredDataLen;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    do { 

        hr = m_pAdminBase->GetDataPaths( m_hMBPath, 
                                         pszPath,
                                         dwPropID,
                                         dwDataType,
                                         pBuff->QuerySize() / sizeof(WCHAR),
                                         (LPWSTR ) pBuff->QueryPtr(),
                                         &cchRequiredDataLen
                                         );
        
        if ( SUCCEEDED( hr)) {
            
            return (TRUE);
        }

        // Some sort of error, most likely not enough buffer space. Keep
        // trying until we get a non-fatal error.
        
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32 &&
            HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) 
        {
            
            // Not enough buffer space. 
            // cchRequiredDataLen contains the # of wide chars that metabase
            //    thinks we need.
            
            if ( !pBuff->Resize( (cchRequiredDataLen + 1) * sizeof(WCHAR)) )
            {
                
                // Not enough memory to resize.
                return FALSE;
            }
        } else {

            // unknown failure. return failure
            break;
        }

    } while (FAILED(hr));

    DBG_ASSERT( FAILED(hr));

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // MB::GetDataPaths()


/*********************************************************************++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.
    The retrieved string is stored in the STR object supplied.

Arguments:

    pszPath    - Path to get data on
    dwPropID   - property id to retrieve
    dwUserType - User type for this property
    pstrValue  - string that receives the value
    dwFlags    - Metabase flags
    pszDefault - Default value to use if the string isn't found, NULL
        for no default value (i.e., will return an error).

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetStr( IN LPCWSTR  pszPath,
            IN DWORD    dwPropID,
            IN DWORD    dwUserType,
            OUT STRU * pstrValue,
            IN DWORD    dwFlags,
            IN LPCWSTR  pszDefault )

{
    HRESULT hr = S_OK;
    DWORD cbSize = pstrValue->QueryBuffer()->QuerySize();

    do {

        if ( GetData( pszPath,
                       dwPropID,
                       dwUserType,
                       STRING_METADATA,
                       pstrValue->QueryBuffer()->QueryPtr(),
                       &cbSize,
                       dwFlags )
             ) {

            //
            // we got the data - bail out
            //
            pstrValue->SyncWithBuffer();
            return (TRUE);
            
        } else {
            
            if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND ) {
                
                // 
                // No item found. Use the default.
                //
                if ( pszDefault != NULL ) {
                    
                    hr =  pstrValue->Copy( (const LPWSTR ) pszDefault );

                    if ( FAILED( hr ) )
                    {
                        SetLastError( WIN32_FROM_HRESULT( hr ) );
                        return (FALSE);
                    }

                    return (TRUE);
                }

                return FALSE;
            } else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                if (TRUE == pstrValue->QueryBuffer()->Resize( cbSize ) )
                {
                    // 
                    // reallocation of buffer for holding the string is sufficient
                    // Now try again.
                    // 
                    continue;
                }
                else
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
            } else {
                SetLastError( WIN32_FROM_HRESULT( hr ) );
                return (FALSE);
            }
        }
    } while (TRUE);  // loop till you get out with error or success.

    return FALSE;
} // MB::GetStr()



/*********************************************************************++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath    - Path to get data on
    dwPropID   - property id to retrieve
    dwUserType - User type for this property
    pMultiszValue - multi-string that receives the value
    dwFlags    - Metabase flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
MB::GetMultisz(
    IN LPCWSTR    pszPath,
    IN DWORD      dwPropID,
    IN DWORD      dwUserType,
    OUT MULTISZ * pMultiszValue,
    IN DWORD      dwFlags
    )

{
    DWORD cbSize = pMultiszValue->QuerySize();

    do {
        
        if ( GetData( pszPath,
                       dwPropID,
                       dwUserType,
                       MULTISZ_METADATA,
                       pMultiszValue->QueryStr(),
                       &cbSize,
                       dwFlags ))
        {
            //
            // we got the data - bail out
            //
            
            goto Succeeded;
        } else {

            if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND ) 
            {
                return FALSE;
            }
            else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                      pMultiszValue->Resize( cbSize ) )
            {
                continue;
            }

            return FALSE;
        }
    } while ( TRUE);

Succeeded:

    //
    //  Value was read directly into the buffer so update the member
    //  variables
    //

    pMultiszValue->RecalcLen();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\memorylog.cxx ===
#include "precomp.hxx"
#include "memorylog.hxx"

CMemoryLog::CMemoryLog(DWORD dwMaxByteSize) :
  m_fValid(FALSE)
{
    BOOL fRet;
    
    fRet = m_buf.Resize(dwMaxByteSize);
    if (fRet)
    {
        m_fValid = TRUE;
    }

    m_pBufferBegin = (CHAR*) m_buf.QueryPtr();
    m_pLastMessageEnd = (CHAR*) m_buf.QueryPtr();
    m_pBufferEnd = ((CHAR*) m_buf.QueryPtr()) + m_buf.QuerySize();

    // preallocate the semaphore and set a spin count of 0xffff
    InitializeCriticalSectionAndSpinCount(&m_cs, 0x8000ffff);
}

CMemoryLog::~CMemoryLog()
{
    m_pBufferBegin = NULL;
    m_pLastMessageEnd = NULL;
    m_pBufferEnd = NULL;
    m_fValid = FALSE;

    DeleteCriticalSection(&m_cs);
}

//
// Appends to end of the circular memory log.  
// 
DWORD
CMemoryLog::Append(LPCSTR pszOutput,
                   DWORD cchLen
                  )
{
    // make sure we allocated the buffer
    if (FALSE == m_fValid)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // make sure the string length will fit inside the buffer
    if (cchLen + 1 > m_buf.QuerySize())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CHAR * pWhereToWriteMessage = NULL;

    // need to synchronize access to m_pLastMessageEnd
    EnterCriticalSection(&m_cs);

    // check if the new message will fit into the remaining space in the buffer
    // previous end (+1) + new length + 1 for NULL
    if (m_pLastMessageEnd + cchLen + 1 < m_pBufferEnd)
    {
        // it will fit in remaining space
        pWhereToWriteMessage = m_pLastMessageEnd;
    }
    else
    {
        // start over at the beginning
        pWhereToWriteMessage = (CHAR*)m_buf.QueryPtr();

        // don't leave extra old goo sitting around in the buffer
        ZeroMemory(m_pLastMessageEnd, m_pBufferEnd - m_pLastMessageEnd);
    }
    
    // set end of message to pWhere + length + 1 for NULL
    m_pLastMessageEnd = pWhereToWriteMessage + cchLen + 1;

    LeaveCriticalSection(&m_cs);

    // the following memcpy is outside of the criticalsection - 
    // this introduces a race between leaving the criticalsection and 
    // looping back through the buffer before we finish writing.
    // how likely is this?  Not very.
    //
    // In addition - moving the memcpy inside of the critsec makes the time spent
    // quite a bit larger than some simple load/stores that are currently there.
    // 
    // Plus this is a debugging aid - life isn't fair.

    // actually do the copy
    memcpy(pWhereToWriteMessage, pszOutput, cchLen);

    // write out a NULL to indicate end of message
    *(pWhereToWriteMessage + cchLen) = NULL;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\mb_notify.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    mb_notify.cxx

Abstract:

    Type definitions for handling metabase change notifications.

Author:

    Taylor Weiss (TaylorW)       26-Jan-1999

Revision History:

--*/

#include <precomp.hxx>
#include <initguid.h>

//
// Contruction and Destruction
//

MB_BASE_NOTIFICATION_SINK::MB_BASE_NOTIFICATION_SINK()
    : m_Refs(1),
      m_SinkCookie(0),
      m_fStartedListening(FALSE)
{
    InitializeCriticalSection(&m_csListener);
    m_fInitCsListener = TRUE;

}

MB_BASE_NOTIFICATION_SINK::~MB_BASE_NOTIFICATION_SINK()
{
    // The owner of this object needs to start and stop
    DBG_ASSERT( m_SinkCookie == 0 );

    m_fInitCsListener = FALSE;
    DeleteCriticalSection(&m_csListener);
    

}

//
// IUnknown
//

STDMETHODIMP_(ULONG)
MB_BASE_NOTIFICATION_SINK::AddRef()
{
    ULONG CurrentRefs = InterlockedIncrement( &m_Refs );

    return CurrentRefs;
}

STDMETHODIMP_(ULONG)
MB_BASE_NOTIFICATION_SINK::Release()
{
    ULONG CurrentRefs = InterlockedDecrement( &m_Refs );

    if( CurrentRefs == 0 )
    {
        delete this;
    }
    return CurrentRefs;
}

STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::QueryInterface(REFIID iid, void ** ppvObject)
{
    
    *ppvObject = NULL;

    if( iid == IID_IUnknown ||
        iid == IID_IMSAdminBaseSink )
    {
        *ppvObject = (IMSAdminBaseSink *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    DBG_ASSERT( *ppvObject );
    ((IUnknown *)*ppvObject)->AddRef();

    return S_OK;
}

STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::SynchronizedShutdownNotify()
{
    return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
}


//
// IMSAdminBaseSink
//
// Dummy implemenation
//


STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::ShutdownNotify()
{
    HRESULT hr = E_FAIL;
    DBG_ASSERT( m_fInitCsListener == TRUE );

    EnterCriticalSection( &m_csListener );
    if ( m_fStartedListening )
    {
        hr = SynchronizedShutdownNotify();
    }
    LeaveCriticalSection( &m_csListener );
    
    return hr;
}

STDMETHODIMP
MB_BASE_NOTIFICATION_SINK::SinkNotify(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
    )
{

    HRESULT hr = E_FAIL;
    DBG_ASSERT( m_fInitCsListener == TRUE );

    EnterCriticalSection( &m_csListener );
    if ( m_fStartedListening )
    {
        hr = SynchronizedSinkNotify( dwMDNumElements,
                          pcoChangeList );
    }
    LeaveCriticalSection( &m_csListener );
    
    return hr;
}

// Public interface

HRESULT
MB_BASE_NOTIFICATION_SINK::StartListening( IUnknown * pUnkAdminBase )
/*++
Routine Description:

    Set up the metabase sink. 
    
    StartListening and stop listening use m_SinkCookie and do no
    synchronization. Caller must synchronize.

Arguments:
    
    pUnkAdminBase - Base object pointer
    
Return Value:

--*/
{
    DBG_ASSERT( m_SinkCookie == 0 );

    DBG_ASSERT( m_fInitCsListener == TRUE );

    IConnectionPointContainer * pContainer = NULL;
    IConnectionPoint *          pConnectionPoint = NULL;
    
    HRESULT hr = 
    pUnkAdminBase->QueryInterface( IID_IConnectionPointContainer,
                                   (void **)&pContainer );

    if( SUCCEEDED(hr) )
    {
        hr = pContainer->FindConnectionPoint( IID_IMSAdminBaseSink,
                                              &pConnectionPoint );
        
        if( SUCCEEDED(hr) )
        {
            hr = pConnectionPoint->Advise( (IMSAdminBaseSink *)this,
                                           &m_SinkCookie );

            if( FAILED(hr) )
            {
                CoDisconnectObject( this, 0 );
            }

            pConnectionPoint->Release();
        }
                
        pContainer->Release();
    }

    if ( SUCCEEDED(hr) )
    {
        EnterCriticalSection( &m_csListener );

        m_fStartedListening = TRUE;
    
        LeaveCriticalSection( &m_csListener );
    }
    return hr;
}

HRESULT
MB_BASE_NOTIFICATION_SINK::StopListening( IUnknown * pUnkAdminBase )
/*++
Routine Description:

    Set up the metabase sink.

Arguments:
    
    pUnkAdminBase - Base object pointer
    
Return Value:

--*/
{
    HRESULT hr = S_FALSE;

    DBG_ASSERT( m_fInitCsListener == TRUE );

    if( m_SinkCookie != 0 )
    {
        IConnectionPointContainer * pContainer = NULL;
        IConnectionPoint *          pConnectionPoint = NULL;
    
        hr = pUnkAdminBase->QueryInterface( IID_IConnectionPointContainer,
                                            (void **)&pContainer );

        if( SUCCEEDED(hr) )
        {
            hr = pContainer->FindConnectionPoint( IID_IMSAdminBaseSink,
                                                  &pConnectionPoint );
        
            if( SUCCEEDED(hr) )
            {
                hr = pConnectionPoint->Unadvise( m_SinkCookie );

                pConnectionPoint->Release();
            }
                
            pContainer->Release();
        }

        // If we fail on any of the above calls we aren't listening 
        // any more

        m_SinkCookie = 0;
    }

    CoDisconnectObject( this, 0 );
    
    EnterCriticalSection( &m_csListener );

    m_fStartedListening = FALSE;
    
    LeaveCriticalSection( &m_csListener );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\locks.cpp ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <locks.h>
#include "_locks.h"


//------------------------------------------------------------------------
// Not all Win32 platforms support all the functions we want. Set up dummy
// thunks and use GetProcAddress to find their addresses at runtime.

typedef
BOOL
(WINAPI * PFN_SWITCH_TO_THREAD)(
    VOID
    );

static BOOL WINAPI
FakeSwitchToThread(
    VOID)
{
    return FALSE;
}

PFN_SWITCH_TO_THREAD  g_pfnSwitchToThread = NULL;


typedef
BOOL
(WINAPI * PFN_TRY_ENTER_CRITICAL_SECTION)(
    IN OUT LPCRITICAL_SECTION lpCriticalSection
    );

static BOOL WINAPI
FakeTryEnterCriticalSection(
    LPCRITICAL_SECTION /*lpCriticalSection*/)
{
    return FALSE;
}

PFN_TRY_ENTER_CRITICAL_SECTION g_pfnTryEnterCritSec = NULL;


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;

DWORD g_cProcessors = 0;


class CSimpleLock
{
  public:
    CSimpleLock()
        : m_l(0)
    {}

    void Enter()
    {
        while (Lock_AtomicExchange(const_cast<LONG*>(&m_l), 1) != 0)
            Sleep(0);
    }

    void Leave()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_l), 0);
    }

    volatile LONG m_l;
};


BOOL g_fLocksInitialized = FALSE;
CSimpleLock g_lckInit;

BOOL
Locks_Initialize()
{
    if (!g_fLocksInitialized)
    {
        g_lckInit.Enter();
    
        if (!g_fLocksInitialized)
        {
            // load kernel32 and get NT-specific entry points
            HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

            if (hKernel32 != NULL)
            {
                g_pfnSwitchToThread = (PFN_SWITCH_TO_THREAD)
                    GetProcAddress(hKernel32, "SwitchToThread");
                
                g_pfnTryEnterCritSec = (PFN_TRY_ENTER_CRITICAL_SECTION)
                    GetProcAddress(hKernel32, "TryEnterCriticalSection");
                
                g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT)
                    GetProcAddress(hKernel32, "SetCriticalSectionSpinCount");
            }
            
            if (g_pfnSwitchToThread == NULL)
                g_pfnSwitchToThread = FakeSwitchToThread;
            
            if (g_pfnTryEnterCritSec == NULL)
                g_pfnTryEnterCritSec = FakeTryEnterCriticalSection;
            
            if (g_pfnSetCSSpinCount == NULL)
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
            
            g_cProcessors = NumProcessors();

            Lock_AtomicExchange((LONG*) &g_fLocksInitialized, TRUE);
        }
        
        g_lckInit.Leave();
    }

    return TRUE;
}


BOOL
Locks_Cleanup()
{
    return TRUE;
}



#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__


#define LOCK_DEFAULT_SPIN_DATA(CLASS)                       \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    strcpy(ls.m_szName, m_szName);                              \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION
# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()
#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

double
RandomBackoffFactor()
{
    static const double s_aFactors[] = {
        1.020, 0.965,  0.890, 1.065,
        1.025, 1.115,  0.940, 0.995,
        1.050, 1.080,  0.915, 0.980,
        1.010,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
    DWORD nRand = ::GetCurrentThreadId();

    return s_aFactors[nRand % nFactors];
}


//------------------------------------------------------------------------
// Function: SwitchOrSleep
// Synopsis: If possible, yields the thread with SwitchToThread. If that
//           doesn't work, calls Sleep.
//------------------------------------------------------------------------

void
SwitchOrSleep(
    DWORD dwSleepMSec)
{
#ifdef LOCKS_SWITCH_TO_THREAD
    if (!g_pfnSwitchToThread())
#endif
        Sleep(dwSleepMSec);
}
    



// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION

LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION


//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_PROLOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
    
    DWORD dwSleepTime = 0;
    LONG  cBaseSpins  = sm_wDefaultSpinCount;
    LONG  cBaseSpins2 = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == _CurrentThreadId())
    {
        IRTLASSERT(
           !"CSmallSpinLock: Illegally attempted to acquire lock recursively");
        DebugBreak();
    }

    while (!_TryLock())
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = (int) (cBaseSpins2 * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion.  Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run.  If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock.  NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable.  If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU.  We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~100,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);

            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

    }

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_EPILOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
}



// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime   = 0;
    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = sm_wDefaultSpinCount;

    cBaseSpins = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    while (!fAcquiredLock)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  sm_wDefaultSpinCount != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
            
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);
            
            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

        // Is the lock unowned?
        if (_TryLock())
            fAcquiredLock = true; // got the lock
    }

    IRTLASSERT((m_lTid & OWNER_MASK) > 0
               &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);

bool
CCritSec::TryWriteLock()
{
    IRTLASSERT(g_pfnTryEnterCritSec != NULL);
    return g_pfnTryEnterCritSec(&m_cs) ? true : false;
}

//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    IRTLASSERT(g_pfnSetCSSpinCount != NULL);
    return g_pfnSetCSSpinCount(pcs, dwSpinCount);
}


// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);



// CRtlResource static member variables

LOCK_DEFAULT_SPIN_DATA(CRtlResource);
LOCK_STATISTICS_DATA(CRtlResource);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CRtlResource);


// CShareLock static member variables

LOCK_DEFAULT_SPIN_DATA(CShareLock);
LOCK_STATISTICS_DATA(CShareLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CShareLock);



// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();
            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);


void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);


void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(SPIN_WRITE);
}


void
CReaderWriterLock3::_LockSpin(
    SPIN_TYPE st)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock;

            if (st == SPIN_WRITE)
                fLock = _TryWriteLock(0);
            else if (st == SPIN_READ)
                fLock = _TryReadLock();
            else
            {
                IRTLASSERT(st == SPIN_READ_RECURSIVE);
                fLock = _TryReadLockRecursive();
            }

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT((st == SPIN_WRITE)  ?  IsWriteLocked()  :  IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\multisz.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    multisz.cxx

    This module contains a light weight multi-string class


    FILE HISTORY:
        KeithMo     20-Jan-1997 Created from string.cxx

*/

#include "precomp.hxx"


# include <dbgutil.h>
# include <multisz.hxx>
//# include <auxctrs.h>

# include <tchar.h>

//
//  Private Definitions
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128


DWORD
MULTISZ::CalcLength( const WCHAR * str,
                     LPDWORD pcStrings )
{
    DWORD count = 0;
    DWORD total = 1;
    DWORD len;

    while( *str ) {
        len = ::wcslen( str ) + 1;
        total += len;
        str += len;
        count++;
    }

    if( pcStrings != NULL ) {
        *pcStrings = count;
    }

    return total;

}   // MULTISZ::CalcLength


BOOL
MULTISZ::FindString( const WCHAR * str )
{

    WCHAR * multisz;

    //
    // Sanity check.
    //

    DBG_ASSERT( QueryStr() != NULL );
    DBG_ASSERT( str != NULL );
    DBG_ASSERT( *str != '\0' );

    //
    // Scan it.
    //

    multisz = QueryStr();

    while( *multisz != '\0' ) {

        if( !::wcscmp( multisz, str ) ) {

            return TRUE;

        }

        multisz += ::wcslen( multisz ) + 1;

    }

    return FALSE;

}   // MULTISZ::FindString


VOID
MULTISZ::AuxInit( const WCHAR * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        DWORD cStrings;
        int cbCopy = CalcLength( pInit, &cStrings ) * sizeof(WCHAR);
        fRet = Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = (cbCopy)/sizeof(WCHAR);
            m_cStrings = cStrings;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        Reset();

    }

} // MULTISZ::AuxInit()


/*******************************************************************

    NAME:       MULTISZ::AuxAppend

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZ::AuxAppend( const WCHAR * pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 4 );

    if( cbThis == 4 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis -= sizeof(WCHAR);

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    //AcIncrement( CacMultiszAppend);
    if ( QuerySize() < cbThis + cbStr + sizeof(WCHAR))
    {
        if ( !Resize( cbThis + cbStr + sizeof(WCHAR)  
             + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);

    *(WCHAR *)((BYTE *)QueryPtr() + cbThis + cbStr) = L'\0';

    m_cchLen = CalcLength( (const WCHAR *)QueryPtr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppend()


#if 0

BOOL
MULTISZ::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
        is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
        to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the UNICODE version of string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in *lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         11-30-94
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    if ( *lpcch == 0) {

      //
      //  Inquiring the size of buffer alone
      //
      *lpcch = QueryCCH() + 1;    // add one character for terminating null
    } else {

        //
        // Copy after conversion from ANSI to Unicode
        //
        int  iRet;
        iRet = MultiByteToWideChar( CP_ACP,   MB_PRECOMPOSED,
                                    QueryStrA(),  QueryCCH() + 1,
                                    lpszBuffer, (int )*lpcch);

        if ( iRet == 0 || iRet != (int ) *lpcch) {

            //
            // Error in conversion.
            //
            fReturn = FALSE;
        }
    }

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
#endif

BOOL
MULTISZ::CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    register DWORD cch = QueryCCH();

    if ( *lpcch >= cch) {

        DBG_ASSERT( lpszBuffer);
        memcpy( lpszBuffer, QueryStr(), cch * sizeof(WCHAR));
    } else {
        DBG_ASSERT( *lpcch < cch);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // MULTISZ::CopyToBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\mbtest.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     mbtest.cxx

   Abstract:
     Test program for the MB class

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#undef DEFINE_GUID
#define INITGUID
#include <ole2.h>
#include <iadmw.h>
#include <mb.hxx>

#include <iostream.h>
#include <iiscnfg.h>

#include <stdio.h>
#include <string.hxx>

#include "dbgutil.h"

//
// namespace std only works with iostream; but I cannot find a way
// to link if I were to use the <iostream> as is.
// I need to fiddle with CPlusPlus compiler flags - for later use
// using namespace std;

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

/************************************************************
 *    Functions
 ************************************************************/


void CreateAndTestMB( IMSAdminBase * pAdminBase);


extern "C" INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    HRESULT hr;
    IMSAdminBase * pAdminBase = NULL;

    CREATE_DEBUG_PRINT_OBJECT( "mbtest");

    //
    // Initialize COM
    //
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED);
    if (FAILED( hr)) {
        cout << "Failed to initialize COM. Error = "
             << ios::hex << hr << endl;
        exit(1);
    }

    //
    // Create the Admin Base object
    //

    hr = CoCreateInstance(
                          GETAdminBaseCLSID( TRUE),   // refCLSID
                          NULL,                       // punkOuter
                          CLSCTX_SERVER,              // dwClsCtx
                          IID_IMSAdminBase,           // Admin Base object
                          reinterpret_cast<LPVOID *> (&pAdminBase)
                          );
    if (FAILED(hr)) {
        cout << "Failed to create Admin Base object. Error = "
             << ios::hex << hr << endl;
        exit (1);
    }

    CreateAndTestMB(pAdminBase);

    // release of pAdminBase is done here
    pAdminBase->Release();

    CoUninitialize();

    DELETE_DEBUG_PRINT_OBJECT();
    return (0);
} // wmain()


void ReportStatus( IN LPCSTR pszItem, IN BOOL fRet)
{
    cout << pszItem << " returns => " << fRet << endl;
    if (!fRet) {
        cout << "\t Error= " << GetLastError() << endl;
        cout << "\t Error= " << hex << GetLastError() << endl;
    }
}


void RunEnumerationTest( IN MB * pmb, LPCWSTR psz, int level)
{
    BOOL fRet;
    static CHAR  rgszBlanks[] =
        "                                                       "
        "                                                       "
        ;

    // set the blanking interval for our use.
    if ( level >= sizeof(rgszBlanks)) { level = sizeof(rgszBlanks); }

    WCHAR wchNext[200];
    DWORD len = lstrlen( psz);
    lstrcpy( wchNext, psz);
    if ( len > 1) {
        wchNext[len++] = L'/';
        wchNext[len] = L'\0';
    }


    WCHAR rgszName[ADMINDATA_MAX_NAME_LEN];
    for ( DWORD i = 0; i < 10; i++ ) {
        fRet = pmb->EnumObjects( psz, rgszName, i);
        if (!fRet) {
            break;
        } else {
            rgszBlanks[level] = '\0';
            printf( "%s[%p] => %S\n", rgszBlanks, psz, i, rgszName);
            rgszBlanks[level] = ' '; // reset the blanks

            //
            // recurse to printout other elements
            //
            lstrcpy( wchNext + len, rgszName);
            RunEnumerationTest( pmb, wchNext, level+1);
        }
    } // for
} // RunEnumerationTest()




/*++
  Routine Description:
   This function creates the MB class object, calls test methods and runs
    the various method calls on the MB object
    to ensure that this is working well.

  Arguments:
    pAdminBase - pointer to Admin Base object

  Returns:
    None
--*/
void CreateAndTestMB(IMSAdminBase * pAdminBase)
{
    MB  mb1( pAdminBase);
    BOOL fRet;

    cout << "In CreateAndTestMB() "
         << (reinterpret_cast<LPVOID> (pAdminBase))
         << endl;

    fRet = mb1.Open( L"/w3svc");
    ReportStatus( "Open(/w3svc)", fRet);

    fRet = mb1.Save();
    ReportStatus( "Save()", fRet);

    DWORD dsNumber = 0;
    fRet = mb1.GetDataSetNumber( L"/w3svc", &dsNumber);
    ReportStatus( "GetDataSetNumber(/w3svc)", fRet);

    if (fRet) {
        cout << "\t Data Set Number is " << dsNumber << endl;
    }

    fRet = mb1.GetDataSetNumber( NULL, &dsNumber);
    ReportStatus( "GetDataSetNumber(NULL)", fRet);

    if (fRet) {
        cout << "\t Data Set Number (NULL) is " << dsNumber << endl;
    }

    //
    // Test Enumeration of the objects
    //
    //    RunEnumerationTest( &mb1, L"/", 0);
    //    cout << "Enumeration at root completed" << endl;


    fRet = mb1.Close();
    ReportStatus( "Close()", fRet);


    fRet = mb1.Open( L"/lm");
    ReportStatus( "Open(/lm/w3svc)", fRet);

    //
    // Test the Get operations
    //

    STRU stru;
    fRet = mb1.GetStr( L"/w3svc",
                       MD_ASP_SCRIPTERRORMESSAGE,
                       ASP_MD_UT_APP,
                       &stru,
                       METADATA_INHERIT,
                       L"Value Not Found"
                       );
    ReportStatus( "GetStr( /w3svc/AspScriptErrorMessage)", fRet);
    if (fRet) {
        printf( "\tGetStr( AspScriptErrorMessage) =>%S\n", stru.QueryStr());
    }

    fRet = mb1.Close();
    ReportStatus( "Close()", fRet);

    cout << "Exiting CreateAndTestMB() " << endl;
    return;
} // CreateAndTestMB()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\multisza.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    multisz.cxx

    This module contains a light weight multi-string class


    FILE HISTORY:
        KeithMo     20-Jan-1997 Created from string.cxx

*/

#include "precomp.hxx"


# include <dbgutil.h>
# include <multisza.hxx>

//
//  Private Definitions
//

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128

// static
DWORD
MULTISZA::CalcLength(const CHAR * str,
                     LPDWORD pcStrings)
{
    DWORD count = 0;
    DWORD total = 1;
    DWORD len;

    while( *str ) {
        len = strlen( str ) + 1;
        total += len;
        str += len;
        count++;
    }

    if( pcStrings != NULL ) {
        *pcStrings = count;
    }

    return total;

}   // MULTISZA::CalcLength


BOOL
MULTISZA::FindString( const CHAR * str )
{

    CHAR * multisz;

    //
    // Sanity check.
    //

    DBG_ASSERT( QueryStr() != NULL );
    DBG_ASSERT( str != NULL );
    DBG_ASSERT( *str != '\0' );

    //
    // Scan it.
    //

    multisz = QueryStr();

    while( *multisz != '\0' ) {

        if( !strcmp( multisz, str ) ) {

            return TRUE;

        }

        multisz += strlen( multisz ) + 1;

    }

    return FALSE;

}   // MULTISZA::FindString


VOID
MULTISZA::AuxInit( const BYTE * pInit )
{
    BOOL fRet;

    if ( pInit )
    {
        DWORD cStrings;
        int cbCopy = CalcLength( (const CHAR *)pInit, &cStrings );
        fRet = Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( QueryPtr(), pInit, cbCopy );
            m_cchLen = cbCopy;
            m_cStrings = cStrings;
        } else {
            BUFFER::SetValid( FALSE);
        }

    } else {

        Reset();

    }

} // MULTISZA::AuxInit()


/*******************************************************************

    NAME:       MULTISZ::AuxAppend

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZA::AuxAppend(const BYTE * pStr,
                         UINT cbStr,
                         BOOL fAddSlop)
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 2 );

    if( cbThis == 2 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis -= sizeof(CHAR);

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbStr + sizeof(CHAR))
    {
        if ( !Resize( cbThis + cbStr + sizeof(CHAR)  
             + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pStr,
            cbStr);

    *((CHAR *)QueryPtr() + cbThis + cbStr) = '\0';

    m_cchLen = CalcLength( (const CHAR *)QueryPtr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppend()


/*******************************************************************

    NAME:       MULTISZA::AuxAppendW

    SYNOPSIS:   Appends the string onto the multisz.

    ENTRY:      Object to append
********************************************************************/

BOOL MULTISZA::AuxAppendW(LPCWSTR pStr,
                          UINT cbStr,
                          BOOL fAddSlop)
{
    DBG_ASSERT( pStr != NULL );

    UINT cbThis = QueryCB();

    DBG_ASSERT( cbThis >= 2 );

    if( cbThis == 2 ) {

        //
        // It's empty, so start at the beginning.
        //

        cbThis = 0;

    } else {

        //
        // It's not empty, so back up over the final terminating NULL.
        //

        cbThis -= sizeof(CHAR);

    }

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbStr + sizeof(CHAR))
    {
        if ( !Resize( cbThis + cbStr + sizeof(CHAR)  
             + (fAddSlop ? STR_SLOP : 0 )) )
            return FALSE;
    }

    // copy the exact string and tack on the double terminator
    for (DWORD i=0; i < cbStr; i++)
    {
        QueryStr()[cbThis + i] = (CHAR)pStr[i];
    }

    QueryStr()[cbThis + cbStr] = '\0';

    m_cchLen = CalcLength(QueryStr(), &m_cStrings );
    return TRUE;

} // MULTISZ::AuxAppendW()


BOOL
MULTISZA::CopyToBuffer(CHAR * lpszBuffer, LPDWORD lpcch) const
/*++
    Description:
        Copies the string into the WCHAR buffer passed in if the buffer
          is sufficient to hold the translated string.
        If the buffer is small, the function returns small and sets *lpcch
          to contain the required number of characters.

    Arguments:
        lpszBuffer      pointer to WCHAR buffer which on return contains
                        the string on success.
        lpcch           pointer to DWORD containing the length of the buffer.
                        If *lpcch == 0 then the function returns TRUE with
                        the count of characters required stored in lpcch.
                        Also in this case lpszBuffer is not affected.
    Returns:
        TRUE on success.
        FALSE on failure.  Use GetLastError() for further details.

    History:
        MuraliK         20-Nov-1996
--*/
{
   BOOL fReturn = TRUE;

    if ( lpcch == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    DWORD cch = QueryCCH() + 1;

    if ( *lpcch >= cch) {

        DBG_ASSERT( lpszBuffer);
        CopyMemory( lpszBuffer, QueryStr(), cch);
    } else {
        DBG_ASSERT( *lpcch < cch);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fReturn = FALSE;
    }

    *lpcch = cch;

    return ( fReturn);
} // MULTISZA::CopyToBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\pudebug.cxx ===
/*++

    Copyright (c) 1994-1998  Microsoft Corporation

    Module  Name :
        pudebug.cxx

    Abstract:

        This module defines functions required for
         Debugging and logging messages for a dynamic program.

    Author:
         Murali R. Krishnan ( MuraliK )    10-Sept-1994

    Revisions:
         MuraliK  13-Nov-1998  Ported over the IIS-DuctTape project
--*/


/************************************************************
 * Include Headers
 ************************************************************/
# include "precomp.hxx"

# include <stdio.h>
# include <stdlib.h>
# include <stdarg.h>
# include <string.h>

# include "pudebug.h"
# include "memorylog.hxx"

/*************************************************************
 * Global Variables and Default Values
 *************************************************************/

# define MAX_PRINTF_OUTPUT  ( 10240)

# define DEFAULT_DEBUG_FLAGS_VALUE  ( 0)
# define DEBUG_FLAGS_REGISTRY_LOCATION_A   "DebugFlags"
# define DEBUG_BREAK_ENABLED_REGKEYNAME_A  "BreakOnAssert"


/*************************************************************
 *   Functions
 *************************************************************/

/********************************************************************++

Routine Description:
   This function creates a new DEBUG_PRINTS object for the required
     program.

Arguments:
      pszPrintLabel     pointer to null-terminated string containing
                         the label for program's debugging output
      dwOutputFlags     DWORD containing the output flags to be used.

Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*********************************************************************/
LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
    IN const char *         pszPrintLabel,
    IN DWORD                dwOutputFlags)
{

   LPDEBUG_PRINTS   pDebugPrints;

   pDebugPrints = (LPDEBUG_PRINTS ) GlobalAlloc( GPTR, sizeof( DEBUG_PRINTS));

   if ( pDebugPrints != NULL) {

        if ( strlen( pszPrintLabel) < MAX_LABEL_LENGTH) {

            strcpy( pDebugPrints->m_rgchLabel, pszPrintLabel);
        } else {
            strncpy( pDebugPrints->m_rgchLabel,
                     pszPrintLabel, MAX_LABEL_LENGTH - 1);
            pDebugPrints->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
                // terminate string
        }

        memset( pDebugPrints->m_rgchLogFilePath, 0, MAX_PATH);
        memset( pDebugPrints->m_rgchLogFileName, 0, MAX_PATH);

        pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;

        pDebugPrints->m_dwOutputFlags = dwOutputFlags;
        pDebugPrints->m_StdErrHandle  = GetStdHandle( STD_ERROR_HANDLE);
        pDebugPrints->m_fInitialized = TRUE;
        pDebugPrints->m_fBreakOnAssert= TRUE;
        pDebugPrints->m_pMemoryLog = NULL;
    }


   return ( pDebugPrints);
} // PuCreateDebugPrintsObject()




/********************************************************************++

Routine Description:
    This function cleans up the pDebugPrints object and
      frees the allocated memory.

    Arguments:
       pDebugPrints     poitner to the DEBUG_PRINTS object.

    Returns:
        NULL  on  success.
        pDebugPrints() if the deallocation failed.

--*********************************************************************/
LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    if ( pDebugPrints != NULL) {

        PuCloseDbgMemoryLog(pDebugPrints);
        DWORD dwError = PuCloseDbgPrintFile( pDebugPrints);

        if ( dwError != NO_ERROR) {

            SetLastError( dwError);
        } else {

            // returns NULL on success
            pDebugPrints =
                (LPDEBUG_PRINTS ) GlobalFree( pDebugPrints);
        }
    }

    return ( pDebugPrints);

} // PuDeleteDebugPrintsObject()




VOID
PuSetDbgOutputFlags(
    IN OUT LPDEBUG_PRINTS   pDebugPrints,
    IN DWORD                dwFlags)
{

    if ( pDebugPrints == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
    } else {

        pDebugPrints->m_dwOutputFlags = dwFlags;
    }

    return;
} // PuSetDbgOutputFlags()



DWORD
PuGetDbgOutputFlags(
    IN const LPDEBUG_PRINTS      pDebugPrints)
{
    return ( pDebugPrints != NULL) ? pDebugPrints->m_dwOutputFlags : 0;

} // PuGetDbgOutputFlags()


static DWORD
PuOpenDbgFileLocal(
   IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    if ( pDebugPrints == NULL)
        return ERROR_INVALID_PARAMETER;

    if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Silently return as a file handle exists.
        //
        return ( NO_ERROR);
    }

    pDebugPrints->m_LogFileHandle =
                      CreateFileA( pDebugPrints->m_rgchLogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

    if ( pDebugPrints->m_LogFileHandle == INVALID_HANDLE_VALUE) {

        CHAR  pchBuffer[1024];
        DWORD dwError = GetLastError();

        wsprintfA( pchBuffer,
                  " Critical Error: Unable to Open File %s. Error = %d\n",
                  pDebugPrints->m_rgchLogFileName, dwError);
        OutputDebugStringA( pchBuffer);

        return ( dwError);
    }

    return ( NO_ERROR);
} // PuOpenDbgFileLocal()





DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFileName,
   IN const char *            pszPathForFile)
/********************************************************************++

  Opens a Debugging log file. This function can be called to set path
  and name of the debugging file.

  Arguments:
     pszFileName           pointer to null-terminated string containing
                            the name of the file.

     pszPathForFile        pointer to null-terminated string containing the
                            path for the given file.
                           If NULL, then the old place where dbg files were
                           stored is used or if none,
                           default windows directory will be used.

   Returns:
       Win32 error codes. NO_ERROR on success.

--*********************************************************************/

{
    if ( pszFileName == NULL || pDebugPrints == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    //
    //  Setup the Path information. if necessary.
    //

    if ( pszPathForFile != NULL) {

        // Path is being changed.

        if ( strlen( pszPathForFile) < MAX_PATH) {

            strcpy( pDebugPrints->m_rgchLogFilePath, pszPathForFile);
        } else {

            return ( ERROR_INVALID_PARAMETER);
        }
    } else {

        if ( pDebugPrints->m_rgchLogFilePath[0] == '\0' &&  // no old path
            !GetWindowsDirectoryA( pDebugPrints->m_rgchLogFilePath, MAX_PATH)) {

            //
            //  Unable to get the windows default directory. Use current dir
            //

            strcpy( pDebugPrints->m_rgchLogFilePath, ".");
        }
    }

    //
    // Should need be, we need to create this directory for storing file
    //


    //
    // Form the complete Log File name and open the file.
    //
    if ( (strlen( pszFileName) + strlen( pDebugPrints->m_rgchLogFilePath))
         >= MAX_PATH) {

        return ( ERROR_NOT_ENOUGH_MEMORY);
    }

    //  form the complete path
    strcpy( pDebugPrints->m_rgchLogFileName, pDebugPrints->m_rgchLogFilePath);

    if ( pDebugPrints->m_rgchLogFileName[ strlen(pDebugPrints->m_rgchLogFileName) - 1]
        != '\\') {
        // Append a \ if necessary
        strcat( pDebugPrints->m_rgchLogFileName, "\\");
    };
    strcat( pDebugPrints->m_rgchLogFileName, pszFileName);

    return  PuOpenDbgFileLocal( pDebugPrints);

} // PuOpenDbgPrintFile()




DWORD
PuReOpenDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
/********************************************************************++

  This function closes any open log file and reopens a new copy.
  If necessary. It makes a backup copy of the file.

--*********************************************************************/

{
    if ( pDebugPrints == NULL) {
        return ( ERROR_INVALID_PARAMETER);
    }

    PuCloseDbgPrintFile( pDebugPrints);      // close any existing file.

    if ( pDebugPrints->m_dwOutputFlags & DbgOutputBackup) {

        // MakeBkupCopy();

        OutputDebugStringA( " Error: MakeBkupCopy() Not Yet Implemented\n");
    }

    return PuOpenDbgFileLocal( pDebugPrints);

} // PuReOpenDbgPrintFile()




DWORD
PuCloseDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
{
    DWORD dwError = NO_ERROR;

    if ( pDebugPrints == NULL ) {
        dwError = ERROR_INVALID_PARAMETER;
    } else {

        if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

            FlushFileBuffers( pDebugPrints->m_LogFileHandle);

            if ( !CloseHandle( pDebugPrints->m_LogFileHandle)) {

                CHAR pchBuffer[1024];

                dwError = GetLastError();

                wsprintfA( pchBuffer,
                          "CloseDbgPrintFile() : CloseHandle( %d) failed."
                          " Error = %d\n",
                          pDebugPrints->m_LogFileHandle,
                          dwError);
                OutputDebugStringA( pchBuffer);
            }

            pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return ( dwError);
} // DEBUG_PRINTS::CloseDbgPrintFile()

DWORD
PuOpenDbgMemoryLog(IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    DWORD dwError;
    CMemoryLog * pLog = NULL;

    if (NULL == pDebugPrints)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (NULL != pDebugPrints->m_pMemoryLog)
    {
        dwError = ERROR_SUCCESS;
        goto done;
    }

    pLog = new CMemoryLog(1024 * 512);  // max size of 512 K
    if (NULL == pLog)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    // save away the pointer
    pDebugPrints->m_pMemoryLog = pLog;

    // make sure output gets to the log
    pDebugPrints->m_dwOutputFlags |= DbgOutputMemory;

    dwError = NO_ERROR;
done:
    return dwError;
}

DWORD
PuCloseDbgMemoryLog(IN OUT LPDEBUG_PRINTS pDebugPrints)
{
    DWORD dwError;

    if (NULL == pDebugPrints)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto done;
    }
    if (NULL != pDebugPrints->m_pMemoryLog)
    {
        CMemoryLog * pLog = (CMemoryLog*) (pDebugPrints->m_pMemoryLog);
        delete pLog;
        pDebugPrints->m_pMemoryLog = NULL;
    }

    dwError = NO_ERROR;
done:
    return dwError;
}

VOID
PupOutputMessage( 
   IN LPDEBUG_PRINTS  pDebugPrints,
   IN LPCSTR          pszOutput,
   IN DWORD           cchLen
   )
{
  if ( pDebugPrints != NULL)
  {
      if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {
          
          DWORD nBytesWritten;
          
          ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                             pszOutput,
                             cchLen,
                             &nBytesWritten,
                             NULL);
      }
      
      if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
           pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {
          
          DWORD nBytesWritten;
          
          //
          // Truncation of log files. Not yet implemented.
          
          ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                             pszOutput,
                             cchLen,
                             &nBytesWritten,
                             NULL);
          
      }

      if ( (pDebugPrints->m_dwOutputFlags & DbgOutputMemory) &&
           (NULL != pDebugPrints->m_pMemoryLog) )
      {
            CMemoryLog* pLog = (CMemoryLog*) (pDebugPrints->m_pMemoryLog);
            pLog->Append(pszOutput, cchLen);
      }
           
  }


  if ( pDebugPrints == NULL ||
       pDebugPrints->m_dwOutputFlags & DbgOutputKdb)
  {
      OutputDebugStringA( pszOutput);
  }

  return;
}

void
FormatMsgToBuffer( OUT LPSTR    pszOutput, 
                   OUT LPDWORD  pcchOutput,
                   IN LPDEBUG_PRINTS pDebugPrints, 
                   IN LPCSTR    pszFilePath, 
                   IN DWORD     nLineNum, 
                   IN LPCSTR    pszFormat,
                   IN va_list * pargsList)
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   int cchPrologue = 0;

   *pcchOutput = 0;

   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      // if skipping \\ yields nothing use whole path.
      pszFileName = pszFilePath;  
   }

   // Format the message header
   
   cchPrologue = wsprintfA( pszOutput, "%s (%lu)[ %12s : %05d]",
                           pDebugPrints ? pDebugPrints->m_rgchLabel : "??",
                           GetCurrentThreadId(),
                           pszFileName, nLineNum);
   
   // Format the incoming message using vsnprintf() so that the overflows are
   //  captured
   
  
   *pcchOutput = _vsnprintf( pszOutput + cchPrologue,
                             MAX_PRINTF_OUTPUT - cchPrologue - 1,
                             pszFormat, *pargsList);
   
  //
  // The string length is long, we get back -1.
  //   so we get the string length for partial data.
  //

   if ( *pcchOutput == -1 ) {
       
       //
       // terminate the string properly,
       //   since _vsnprintf() does not terminate properly on failure.
       //
       *pcchOutput = MAX_PRINTF_OUTPUT;
       pszOutput[ *pcchOutput] = '\0';
  } else {
      *pcchOutput += cchPrologue;
  }

  return;
} // FormatMsgToBuffer()


/********************************************************************++
Routine Description:
   Main function that examines the incoming message and prints out a header
    and the message.

Arguments:
  pDebugPrints - pointer to the debug print object 
  pszFilePaht  - pointer to the file from where this function is called
  nLineNum     - Line number within the file
  pszFormat    - formatting string to use.

Returns:
  None
--*********************************************************************/

VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFilePath,
   IN int                     nLineNum,
   IN const char *            pszFormat,
   ...)
{
   char pszOutput[ MAX_PRINTF_OUTPUT + 2];
   DWORD  cchOutput;
   va_list argsList;
   DWORD dwErr;

   // get a local copy of the error code so that it is not lost
  dwErr = GetLastError();

  va_start( argsList, pszFormat);
  FormatMsgToBuffer( pszOutput, 
                     &cchOutput,
                     pDebugPrints, 
                     pszFilePath, 
                     nLineNum, 
                     pszFormat,
                     &argsList);
  
  va_end( argsList);
  
  //
  // Send the outputs to respective files.
  //
  PupOutputMessage( pDebugPrints, pszOutput, cchOutput);


  SetLastError( dwErr );

  return;

} // PuDbgPrint()



/********************************************************************++
Routine Description:
   This function behaves like PuDbgPrint() but also prints out formatted
   Error message indicating what failed.

Arguments:
  pDebugPrints - pointer to the debug print object 
  pszFilePaht  - pointer to the file from where this function is called
  nLineNum     - Line number within the file
  dwError      - Error code for which the formatted error message should
                  be printed
  pszFormat    - formatting string to use.

Returns:
  None
--*********************************************************************/
VOID
PuDbgPrintError(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN DWORD                dwError,
   IN const char *         pszFormat,
   ...) // argsList
{
   char pszOutput[ MAX_PRINTF_OUTPUT + 2];
   DWORD  cchOutput;
   va_list argsList;
   DWORD dwErr;

   // get a local copy of the error code so that it is not lost
  dwErr = GetLastError();

  va_start( argsList, pszFormat);
  FormatMsgToBuffer( pszOutput, 
                     &cchOutput,
                     pDebugPrints, 
                     pszFilePath, 
                     nLineNum, 
                     pszFormat,
                     &argsList);
  
  va_end( argsList);

  LPSTR lpErrorBuffer = NULL;
  DWORD nRet;
  nRet = 
      FormatMessageA((FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                      FORMAT_MESSAGE_FROM_SYSTEM),
                     NULL,     // lpSource
                     dwError,
                     LANG_NEUTRAL,
                     (LPSTR ) &lpErrorBuffer, // pointer to store buffer allocated
                     0,    // size of buffer
                     NULL  // lpArguments
                     );

  //
  // obtain the formatted error message for error code
  // 
                 
  if ((nRet == 0 ) || (cchOutput + nRet) < MAX_PRINTF_OUTPUT) {
      
      //
      // Append the formatted error code here
      // 
      
      if ( lpErrorBuffer != NULL) {
          cchOutput += wsprintfA( pszOutput + cchOutput,
                                 "\tError(%x): %s\n",
                                 dwError, 
                                 lpErrorBuffer);
      }
      
      //
      // Send the outputs to respective files.
      //
      PupOutputMessage( pDebugPrints, pszOutput, cchOutput);
  } else {

      //
      // Sorry the buffer space is not sufficient. 
      // do separate send operations
      //

      // first print out the regular message
      PupOutputMessage( pDebugPrints, pszOutput, cchOutput);
      
      // next print the error value text => race conditions can cause trouble
      // this is a low likely event, so we will ignore the error case here.
      PupOutputMessage( pDebugPrints, lpErrorBuffer, nRet);
  }

  // free the buffer if any was allocated  
  if ( lpErrorBuffer != NULL) {
      LocalFree (lpErrorBuffer);
  }

  SetLastError( dwErr );

  return;
} // PuDbgPrintError()



VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   DWORD dwErr;
   DWORD cbDump;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;
   }

   dwErr = GetLastError();

   // No message header for this dump
   cbDump = strlen( pszDump);

   //
   // Send the outputs to respective files.
   //

   if ( pDebugPrints != NULL)
   {
       if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {
           
           DWORD nBytesWritten;
           
           ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                              pszDump,
                              cbDump,
                              &nBytesWritten,
                              NULL);
       }
       
       if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
            pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {
           
           DWORD nBytesWritten;
           
           //
           // Truncation of log files. Not yet implemented.
           
           ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                              pszDump,
                              cbDump,
                              &nBytesWritten,
                              NULL);
           
       }

       if ( (pDebugPrints->m_dwOutputFlags & DbgOutputMemory) &&
            (NULL != pDebugPrints->m_pMemoryLog) )
       {
           CMemoryLog * pLog = (CMemoryLog*)(pDebugPrints->m_pMemoryLog);
           pLog->Append(pszDump, cbDump);
       }
   }

   if ( pDebugPrints == NULL
       ||  pDebugPrints->m_dwOutputFlags & DbgOutputKdb)
   {
       OutputDebugStringA( pszDump);
   }

   SetLastError( dwErr );

  return;
} // PuDbgDump()

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszExpression,
    IN const char *               pszMessage)
/********************************************************************++
    This function calls assertion failure and records assertion failure
     in log file.

--*********************************************************************/

{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " Assertion (%s) Failed: %s\n"
                " use !cxr %p to dump context\n",
                pszExpression,
                pszMessage,
                &context);

    DebugBreak();

    return;
} // PuDbgAssertFailed()

#pragma optimize( "", on )      // restore frame pointer omission (FPO)



VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    )
/********************************************************************++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*********************************************************************/

{
    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " TickCount = %u\n",
                GetTickCount()
                );

    return;
} // PrintOutCurrentTime()




DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault)
/********************************************************************++
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key.
  If there is any error the default value is returned.
--*********************************************************************/

{
    DWORD err;
    DWORD dwDebug = dwDefault;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               DEBUG_FLAGS_REGISTRY_LOCATION_A,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDebug = dwBuffer;
        }
    }

    return dwDebug;
} // PuLoadDebugFlagsFromReg()




DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault)
/********************************************************************++
Description:
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key location in registry.
  If there is any error the default value is returned.

Arguments:
  pszRegKey - pointer to registry key location from where to read the key from
  dwDefault - default values in case the read from registry fails

Returns:
   Newly read value on success
   If there is any error the dwDefault is returned.
--*********************************************************************/

{
    HKEY        hkey = NULL;

    DWORD dwVal = dwDefault;

    DWORD dwError = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                  pszRegKey,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hkey);
    if ( dwError == NO_ERROR) {
        dwVal = PuLoadDebugFlagsFromReg( hkey, dwDefault);
        RegCloseKey( hkey);
        hkey = NULL;
    }

    return ( dwVal);
} // PuLoadDebugFlagsFromRegStr()





DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg)
/********************************************************************++
  Saves the debug flags in registry. On failure returns the error code for
   the operation that failed.

--*********************************************************************/
{
    DWORD err;

    if( hkey == NULL ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(hkey,
                             DEBUG_FLAGS_REGISTRY_LOCATION_A,
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwDbg,
                             sizeof(dwDbg) );
    }

    return (err);
} // PuSaveDebugFlagsInReg()


VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    )
{
    //
    // This space intentionally left blank.
    //

}   // PuDbgCaptureContext


/****************************** End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\refcount.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    RefCount.cxx

Abstract:

    This module implements the reference counting class implementing
   	the methods required when REFERENCE_TRACKING is enabled. 

   	It uses the reference tracking code to log the references to an in-memory
   	buffer, that can be dumped out later on.

Author:

    Murali Krishnan (MuraliK)        03-Nov-1998

Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include "reftrace.h"
# include "tracelog.h"

/************************************************************
 *     Member Functions of MB
 ************************************************************/

# ifdef REFERENCE_TRACKING 

REF_COUNT::REF_COUNT( IN LONG lInitialRef)
	: m_nRefs( lInitialRef),
	  m_pRefTraceLog( NULL)
{
}

REF_COUNT::~REF_COUNT( void)
{
	if (m_pRefTraceLog != NULL) 
	{
		DestroyRefTraceLog( (PTRACE_LOG ) m_pRefTraceLog);
		m_pRefTraceLog = NULL;
	}
	
	DBG_ASSERT( m_nRefs == 0);
}

void
REF_COUNT::Initialize(IN nTraces)
{
    //
    // Create a ref trace log if one is not already existent.   
    //
    if ( m_pRefTraceLog == NULL)
    {
        m_pRefTraceLog = CreateRefTraceLog( nTraces, 0);
    }

    return;
}

void 
REF_COUNT::TrackReference(
    IN PVOID pvContext1,
    IN PVOID pvContext2,
    IN PVOID pvContext3
    IN PVOID pvContext4
    )
{

    //
    // Write the output to Log file for now
    //
    
    if ( m_pRefTraceLog != NULL)
    {
        WriteRefTraceLogEx(
            m_pRefTraceLog,
            m_nRefs,
            pvContext1,
            pvContext2,
            pvContext3,
            pvContext4
            );
    }

    return;
}

# endif // REFERENCE_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\reftrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>
#include <pudebug.h>
#include <reftrace.h>
#include <stktrace.h>


PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    return CreateTraceLog(
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/
{

    DestroyTraceLog( Log );

}   // DestroyRefTraceLog


//
// N.B. For IISCaptureStackBackTrace() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// WriteRefTraceLog[Ex]() with the __cdecl modifier and disable the frame
// pointer omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

LONG
__cdecl
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    )
/*++

Routine Description:

    Writes a new entry to the specified ref count trace log. The entry
    written contains the updated reference count and a stack backtrace
    leading up to the current caller.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context - An uninterpreted context to associate with the log entry.

Return Value:

    Index of entry in log.

--*/
{

    return WriteRefTraceLogEx(
        Log,
        NewRefCount,
        Context,
        REF_TRACE_EMPTY_CONTEXT, // suppress use of optional extra contexts
        REF_TRACE_EMPTY_CONTEXT,
        REF_TRACE_EMPTY_CONTEXT
        );

}   // WriteRefTraceLog




LONG
__cdecl
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1, // optional extra context
    IN PVOID Context2, // optional extra context
    IN PVOID Context3  // optional extra context
    )
/*++

Routine Description:

    Writes a new "extended" entry to the specified ref count trace log.
    The entry written contains the updated reference count, stack backtrace
    leading up to the current caller and extra context information.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context  - An uninterpreted context to associate with the log entry.
    Context1 - An uninterpreted context to associate with the log entry.
    Context2 - An uninterpreted context to associate with the log entry.
    Context3 - An uninterpreted context to associate with the log entry.

    NOTE Context1/2/3 are "optional" in that the caller may suppress
    debug display of these values by passing REF_TRACE_EMPTY_CONTEXT
    for each of them.

Return Value:

    Index of entry in log.

--*/
{

    REF_TRACE_LOG_ENTRY entry;
    ULONG hash;
    DWORD cStackFramesSkipped;

    //
    // Initialize the entry.
    //

    RtlZeroMemory(
        &entry,
        sizeof(entry)
        );

    //
    //  Set log entry members.
    //

    entry.NewRefCount = NewRefCount;
    entry.Context = Context;
    entry.Thread = GetCurrentThreadId();
    entry.Context1 = Context1;
    entry.Context2 = Context2;
    entry.Context3 = Context3;

    //
    // Capture the stack backtrace. Normally, we skip two stack frames:
    // one for this routine, and one for IISCaptureStackBackTrace() itself.
    // For non-Ex callers who come in via WriteRefTraceLog,
    // we skip three stack frames.
    //

    if (    entry.Context1 == REF_TRACE_EMPTY_CONTEXT
         && entry.Context2 == REF_TRACE_EMPTY_CONTEXT
         && entry.Context3 == REF_TRACE_EMPTY_CONTEXT
         ) {

         cStackFramesSkipped = 2;

    } else {

         cStackFramesSkipped = 1;

    }

    IISCaptureStackBackTrace(
        cStackFramesSkipped,
        REF_TRACE_LOG_STACK_DEPTH,
        entry.Stack,
        &hash
        );

    //
    // Write it to the log.
    //

    return WriteTraceLog(
        Log,
        &entry
        );

}   // WriteRefTraceLogEx

#pragma optimize( "", on )      // restore frame pointer omission (FPO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\resource.cxx ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Mark Lucovsky       (markl)     04-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode.  They make use of Nt system
    services.

Revision History:

--*/

#include "precomp.hxx"

#include "dbgutil.h"
# define DLL_IMPLEMENTATION
# include "irtlmisc.h"
#include <tsres.hxx>

//
//  The semaphore wait time before retrying the wait
//

#define INET_RES_TIMEOUT            (2 * 60 * 1000)

# define InetResPrint( s)  \
{ CHAR buff[256];  \
  wsprintfA s ; \
  OutputDebugStringA( buff);  \
}

#if DBG
LONG g_InetResourcesCreated = 0;
LONG g_InetResourcesDeleted = 0;
#endif



BOOL
InetInitializeResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{

    PLATFORM_TYPE platformType;

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction.
    //

    INITIALIZE_CRITICAL_SECTION( &Resource->CriticalSection );

    //
    // The critical section's DebugInfo field is only valid under NT.
    // If we're running under NT, then set the critical section type
    // to mark this as a resource. This is useful when debugging resource
    // leaks.
    //

    platformType = IISGetPlatformType();

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {
        Resource->CriticalSection.DebugInfo->Type = RTL_RESOURCE_TYPE;
    }

    Resource->DebugInfo = NULL;

    //
    //  Initialize flags so there is a default value.
    //  (Some apps may set RTL_RESOURCE_FLAGS_LONG_TERM to affect timeouts.)
    //

    Resource->Flags = 0;

    //
    //  Initialize the shared and exclusive waiting counters and semaphore.
    //  The counters indicate how many are waiting for access to the resource
    //  and the semaphores are used to wait on the resource.  Note that
    //  the semaphores can also indicate the number waiting for a resource
    //  however there is a race condition in the alogrithm on the acquire
    //  side if count if not updated before the critical section is exited.
    //

    Resource->SharedSemaphore = IIS_CREATE_SEMAPHORE(
                                    "RTL_RESOURCE::SharedSemaphore",
                                    Resource,
                                    0,
                                    MAXLONG
                                    );

    if ( !Resource->SharedSemaphore ) {
        return FALSE;
    }

    Resource->NumberOfWaitingShared = 0;

    Resource->ExclusiveSemaphore = IIS_CREATE_SEMAPHORE(
                                       "RTL_RESOURCE::ExclusiveSemaphore",
                                       Resource,
                                       0,
                                       MAXLONG
                                       );

    if ( !Resource->ExclusiveSemaphore ){
        CloseHandle( Resource->SharedSemaphore );

        return FALSE;
    }

    Resource->NumberOfWaitingExclusive = 0;

    //
    //  Initialize the current state of the resource
    //

    Resource->NumberOfActive = 0;

    Resource->ExclusiveOwnerThread = NULL;

#if DBG
    InterlockedIncrement( &g_InetResourcesCreated );
#endif

    return TRUE;
}


BOOL
InetAcquireResourceShared(
    IN PRTL_RESOURCE Resource,
    IN BOOL          Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    DWORD          ret;
    ULONG          TimeoutCount = 0;
    DWORD          TimeoutTime  = INET_RES_TIMEOUT;
    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If it is not currently acquired for exclusive use then we can acquire
    //  the resource for shared access.  Note that this can potentially
    //  starve an exclusive waiter however, this is necessary given the
    //  ability to recursively acquire the resource shared.  Otherwise we
    //  might/will reach a deadlock situation where a thread tries to acquire
    //  the resource recusively shared but is blocked by an exclusive waiter.
    //
    //  The test to reanable not starving an exclusive waiter is:
    //
    //      if ((Resource->NumberOfWaitingExclusive == 0) &&
    //          (Resource->NumberOfActive >= 0)) {
    //

    if (Resource->NumberOfActive >= 0) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section
        //

        Resource->NumberOfActive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise check to see if this thread is the one currently holding
    //  exclusive access to the resource.  And if it is then we change
    //  this shared request to an exclusive recusive request and grant
    //  access to the resource.
    //

    } else if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

        //
        //  The resource is ours (recusively) so indicate that we have it
        //  and exit the critial section
        //

        Resource->NumberOfActive -= 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise we'll have to wait for access.
    //

    } else {

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting shared,
        //  release the lock, and wait on the shared semaphore
        //

        Resource->NumberOfWaitingShared += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->SharedSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceShared] Sem timeout\n",
                          Resource));

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }

            InetResPrint((buff,
                          "%08x::[InetAcquireResourceShared] Re-Waiting\n",
                          Resource));

            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceShared] "
                          "WaitForSingleObject Failed\n",
                          Resource));

        }
    }

    //
    //  Now the resource is ours, for shared access
    //

    return TRUE;

}


BOOL
InetAcquireResourceExclusive(
    IN PRTL_RESOURCE Resource,
    IN BOOL Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOL - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    ULONG TimeoutCount = 0;
    DWORD TimeoutTime  = INET_RES_TIMEOUT;
    DWORD ret;

    //
    //  Loop until the resource is ours or exit if we cannot wait.
    //

    while (TRUE) {

        //
        //  Enter the critical section
        //

        EnterCriticalSection(&Resource->CriticalSection);

        //
        //  If there are no shared users and it is not currently acquired for
        //  exclusive use then we can acquire the resource for exclusive
        //  access.  We also can acquire it if the resource indicates exclusive
        //  access but there isn't currently an owner.
        //

        if ((Resource->NumberOfActive == 0)

                ||

            ((Resource->NumberOfActive == -1) &&
             (Resource->ExclusiveOwnerThread == NULL))) {

            //
            //  The resource is ours, so indicate that we have it and
            //  exit the critical section
            //

            Resource->NumberOfActive = -1;

            Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Otherwise check to see if we already have exclusive access to the
        //  resource and can simply recusively acquire it again.
        //

        if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

            //
            //  The resource is ours (recusively) so indicate that we have it
            //  and exit the critial section
            //

            Resource->NumberOfActive -= 1;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting exclusive,
        //  release the lock, and wait on the exclusive semaphore
        //

        Resource->NumberOfWaitingExclusive += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceExclusive] "
                          "Sem Timeout\n",
                          Resource));

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceExclusive] "
                          "Re-Waiting\n",
                          Resource));
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            InetResPrint((buff,
                          "%08x::[InetAcquireResourceExclusive] "
                          "WaitForSingleObject Failed\n",
                          Resource));
        }
    }

    return TRUE;
}


BOOL
InetReleaseResource(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  Test if the resource is acquired for shared or exclusive access
    //

    if (Resource->NumberOfActive > 0) {

        //
        //  Releasing shared access to the resource, so decrement
        //  the number of shared users
        //

        Resource->NumberOfActive -= 1;

        //
        //  If the resource is now available and there is a waiting
        //  exclusive user then give the resource to the waiting thread
        //

        if ((Resource->NumberOfActive == 0) &&
            (Resource->NumberOfWaitingExclusive > 0)) {

            //
            //  Set the resource state to exclusive (but not owned),
            //  decrement the number of waiting exclusive, and release
            //  one exclusive waiter
            //

            Resource->NumberOfActive = -1;
            Resource->ExclusiveOwnerThread = NULL;

            Resource->NumberOfWaitingExclusive -= 1;

            if ( !ReleaseSemaphore(
                         Resource->ExclusiveSemaphore,
                         1,
                         &PreviousCount
                         )) {
                return FALSE;
            }
        }

    } else if (Resource->NumberOfActive < 0) {

        //
        //  Releasing exclusive access to the resource, so increment the
        //  number of active by one.  And continue testing only
        //  if the resource is now available.
        //

        Resource->NumberOfActive += 1;

        if (Resource->NumberOfActive == 0) {

            //
            //  The resource is now available.  Remove ourselves as the
            //  owner thread
            //

            Resource->ExclusiveOwnerThread = NULL;

            //
            //  If there is another waiting exclusive then give the resource
            //  to it.
            //

            if (Resource->NumberOfWaitingExclusive > 0) {

                //
                //  Set the resource to exclusive, and its owner undefined.
                //  Decrement the number of waiting exclusive and release one
                //  exclusive waiter
                //

                Resource->NumberOfActive = -1;
                Resource->NumberOfWaitingExclusive -= 1;

                if ( !ReleaseSemaphore(
                             Resource->ExclusiveSemaphore,
                             1,
                             &PreviousCount
                             )) {
                    return FALSE;
                }

            //
            //  Check to see if there are waiting shared, who should now get
            //  the resource
            //

            } else if (Resource->NumberOfWaitingShared > 0) {

                //
                //  Set the new state to indicate that all of the shared
                //  requesters have access and there are no more waiting
                //  shared requesters, and then release all of the shared
                //  requsters
                //

                Resource->NumberOfActive = Resource->NumberOfWaitingShared;

                Resource->NumberOfWaitingShared = 0;

                if ( !ReleaseSemaphore(
                             Resource->SharedSemaphore,
                             Resource->NumberOfActive,
                             &PreviousCount
                             )) {
                    return FALSE;
                }
            }
        }

#if DBG
    } else {

        //
        //  The resource isn't current acquired, there is nothing to release
        //  so tell the user the mistake
        //


        InetResPrint((buff,
                      "%08x::[InetReleaseResource] "
                      "Resource released too many times!\n",
                      Resource));
        DebugBreak();
#endif
    }

    //
    //  Exit the critical section, and return to the caller
    //

    LeaveCriticalSection(&Resource->CriticalSection);

    return TRUE;
}


BOOL
InetConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for shared access into
    one acquired for exclusive access.  Upon return from the procedure
    the resource is acquired for exclusive access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for shared access

Return Value:

    None

--*/

{
    DWORD ret;
    DWORD TimeoutTime  = INET_RES_TIMEOUT;
    ULONG TimeoutCount = 0;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == 1) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section, and return
        //

        Resource->NumberOfActive = -1;

        Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is currently acquired exclusive and it's us then
    //  we already have exclusive access
    //

    if ((Resource->NumberOfActive < 0) &&
        (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread)) {

        //
        //  We already have exclusive access to the resource so we'll just
        //  exit the critical section and return
        //

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;
    }

    //
    //  If the resource is acquired by more than one shared then we need
    //  to wait to get exclusive access to the resource
    //

    if (Resource->NumberOfActive > 1) {

        //
        //  To wait we will decrement the fact that we have the resource for
        //  shared, and then loop waiting on the exclusive lock, and then
        //  testing to see if we can get exclusive access to the resource
        //

        Resource->NumberOfActive -= 1;

        while (TRUE) {

            //
            //  Increment the number of waiting exclusive, exit and critical
            //  section and wait on the exclusive semaphore
            //

            Resource->NumberOfWaitingExclusive += 1;

            LeaveCriticalSection(&Resource->CriticalSection);
rewait:
        if ( Resource->Flags & RTL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = INFINITE;
        }
        ret = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );

        if ( ret == WAIT_TIMEOUT ) {
            InetResPrint((buff,
                          "%08x::[InetConvertSharedToExclusive] Sem timeout\n",
                          Resource));

            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
#if DBG
                DebugBreak();
#endif
                }
            InetResPrint((buff,
                          "%08x::[InetConvertSharedToExclusive] Re-Waiting\n",
                          Resource));
            goto rewait;
        } else if ( ret != WAIT_OBJECT_0 ) {
            InetResPrint((buff,
                          "%08x::[InetConvertSharedToExclusive] "
                          "WaitForSingleObject Failed\n",
                          Resource));

            return FALSE;
        }

            //
            //  Enter the critical section
            //

            EnterCriticalSection(&Resource->CriticalSection);

            //
            //  If there are no shared users and it is not currently acquired
            //  for exclusive use then we can acquire the resource for
            //  exclusive access.  We can also acquire it if the resource
            //  indicates exclusive access but there isn't currently an owner
            //

            if ((Resource->NumberOfActive == 0)

                    ||

                ((Resource->NumberOfActive == -1) &&
                 (Resource->ExclusiveOwnerThread == NULL))) {

                //
                //  The resource is ours, so indicate that we have it and
                //  exit the critical section and return.
                //

                Resource->NumberOfActive = -1;

                Resource->ExclusiveOwnerThread = NtCurrentTeb()->ClientId.UniqueThread;

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }

            //
            //  Otherwise check to see if we already have exclusive access to
            //  the resource and can simply recusively acquire it again.
            //

            if (Resource->ExclusiveOwnerThread == NtCurrentTeb()->ClientId.UniqueThread) {

                //
                //  The resource is ours (recusively) so indicate that we have
                //  it and exit the critical section and return.
                //

                Resource->NumberOfActive -= 1;

                LeaveCriticalSection(&Resource->CriticalSection);

                return TRUE;
            }
        }

    }

    //
    //  The resource is not currently acquired for shared so this is a
    //  spurious call
    //

#if DBG
    InetResPrint((buff,
                  "%08x::[InetConvertSharedToExclusive] "
                  "Failed error - SHARED_RESOURCE_CONV_ERROR\n",
                  Resource));
    DebugBreak();
#endif

    return FALSE;
}


BOOL
InetConvertExclusiveToShared(
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for exclusive access into
    one acquired for shared access.  Upon return from the procedure
    the resource is acquired for shared access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for exclusive access

Return Value:

    None

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == -1) {

        Resource->ExclusiveOwnerThread = NULL;

        //
        //  Check to see if there are waiting shared, who should now get the
        //  resource along with us
        //

        if (Resource->NumberOfWaitingShared > 0) {

            //
            //  Set the new state to indicate that all of the shared requesters
            //  have access including us, and there are no more waiting shared
            //  requesters, and then release all of the shared requsters
            //

            Resource->NumberOfActive = Resource->NumberOfWaitingShared + 1;

            Resource->NumberOfWaitingShared = 0;

            if ( !ReleaseSemaphore(
                         Resource->SharedSemaphore,
                         Resource->NumberOfActive - 1,
                         &PreviousCount
                         )) {
                return FALSE;
            }
        } else {

            //
            //  There is no one waiting for shared access so it's only ours
            //

            Resource->NumberOfActive = 1;

        }

        LeaveCriticalSection(&Resource->CriticalSection);

        return TRUE;

    }

    //
    //  The resource is not currently acquired for exclusive, or we've
    //  recursively acquired it, so this must be a spurious call
    //

#if DBG
    InetResPrint((buff,
                  "%08x::[InetConvertExclusiveToShared] "
                  "Failed error - SHARED_RESOURCE_CONV_ERROR\n",
                  Resource));
    DebugBreak();
#endif

    return FALSE;
}


VOID
InetDeleteResource (
    IN PRTL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    DeleteCriticalSection( &Resource->CriticalSection );
    CloseHandle(Resource->SharedSemaphore);
    CloseHandle(Resource->ExclusiveSemaphore);
    ZeroMemory( Resource, sizeof( *Resource ) );

#if DBG
    InterlockedIncrement( &g_InetResourcesDeleted );
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\stktrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    Implements IISCaptureStackBackTrace().

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>
#include <pudebug.h>
#include <stktrace.h>

USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Implementation of IISCaptureStackBackTrace() for all platforms.

Arguments:

    See RtlCaptureStackBackTrace() below.

Return Value:

    USHORT - Always 0.

--*/
{
    return RtlCaptureStackBackTrace(FramesToSkip,
                                    FramesToCapture,
                                    BackTrace,
                                    BackTraceHash);

}   // IISCaptureStackBackTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\sched.cxx ===
/*++
TODO: fix !inetdbg.sched

   Copyright    (c)    1995-2001     Microsoft Corporation

   Module Name:

       sched.cxx

   Abstract:

        This module contains a simple timer interface for scheduling future
        work items


   Author:

        John Ludeman    (johnl)     17-Jul-1995

   Project:

        Internet Servers Common Server DLL

   Revisions:
        Murali R. Krishnan  (MuraliK)     16-Sept-1996
          Added scheduler items cache
        George V. Reilly      (GeorgeRe)        May-1999
          Removed the global variables; turned into refcounted objects, so
          that code will survive stops and restarts when work items take a
          long time to complete
        Jeffrey Wall        (jeffwall)    April 2001
          Switched API to use NT public CreateTimerQueue, 
          CreateTimerQueueTimer and DeleteTimerQueueEx
--*/

//
//  Include Headers
//

#include "precomp.hxx"

#include "sched.hxx"


// Initialize class static members
LONG              SCHEDULER::sm_nID = 0;
LONG              TIMER::sm_lLastCookie = 0;

//
//  Global data items
//
SCHEDULER*         g_pScheduler = NULL;
CRITICAL_SECTION   g_SchedulerCritSec;

ULONG              cSchedInits = 0;
ULONG              cSchedUninits = 0;


/************************************************************
 *  Public functions of Scheduler
 ************************************************************/


BOOL
SchedulerInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "SchedulerInitialize: inits=%d, uninits=%d\n",
                        cSchedInits, cSchedUninits));
    }

    ++cSchedInits;

    unsigned idThread;
    LONG     i, numThreads;

    SCHEDULER* const psd = SCHEDULER::CreateScheduler();
    if (psd == NULL)
    {
        return FALSE;
    }
    DBG_ASSERT(psd->CheckSignature());

    EnterCriticalSection(&g_SchedulerCritSec);

    // Update the global pointer to the scheduler
    SCHEDULER* const psd2 =
        (SCHEDULER*) InterlockedExchangePointer((VOID**)&g_pScheduler, psd);

    TIMER::ResetCookie();

    LeaveCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(psd2 == NULL);

    return TRUE;
} // SchedulerInitialize()

VOID
SchedulerTerminate(
    VOID
    )
/*++

Routine Description:

    Terminates and cleans up the scheduling package.  Any items left on the
    list are *not* called during cleanup.

    Blocks until all callbacks are completed and removed.

--*/
{
    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "SchedulerTerminate: inits=%d, uninits=%d\n",
                                  cSchedInits, cSchedUninits));
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    // Grab the global pointer, then set it to NULL
    SCHEDULER* const psd =
        (SCHEDULER*) InterlockedExchangePointer((VOID**)&g_pScheduler, NULL);

    ++cSchedUninits;

    if (psd)
    {
        // blocks until all callbacks have finished
        psd->Terminate();
    }

    LeaveCriticalSection(&g_SchedulerCritSec);

    return;
}

DWORD
WINAPI 
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    BOOL               fPeriodic /* = FALSE */
    )
/*++

Routine Description:

    Adds a timed work item to the work list

Arguments:

    pfnCallback - Function to call
    pContext - Context to pass to the callback
    msecTime - number of milliseconds to wait before calling timeout
    fPeriodic - whether or not timer reactivates every msecTime periods
    fCoInitializeCallback - whether or not callback function should be coinitialized

Return Value:

    zero on failure, non-zero on success.  The return value can be used to
    remove the scheduled work item.

--*/
{
    BOOL               fCoInitializeCallback = TRUE;

    if (!g_pScheduler)
    {
        return ERROR_NOT_READY;
    }

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "ScheduleWorkItem: callback=%p context=%p time=%d periodic=%d Com=%d\n",
                        pfnCallback,
                        pContext,
                        msecTime,
                        fPeriodic,
                        fCoInitializeCallback));
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return ERROR_NOT_READY;
    }

    DWORD dwRet;
    dwRet = TIMER::Create(g_pScheduler,
                           pfnCallback,
                           pContext,
                           msecTime,
                           fPeriodic,
                           fCoInitializeCallback);
    LeaveCriticalSection(&g_SchedulerCritSec);

    return dwRet;
}

// function prototype for decision routine
typedef BOOL (WINAPI *P_DECISION_ROUTINE )(PLIST_ENTRY, PVOID);

BOOL
WalkList(PLIST_ENTRY pListHead,
         P_DECISION_ROUTINE pfnDecision,
         PVOID pContext)
/*++

Routine Description:

    Walks list pointed to by pListHead calling pfnDecision with pContext until
    1) list is done being walked OR
    2) pfnDecision returns TRUE

Arguments:
    pListHead - list head
    pfnDecision - pointer to decision function
    pContext - pointer to context

Return Value:

    TRUE if any call to pfnDecision returns TRUE
    FALSE if NO call to pfnDecision returns TRUE

--*/
{
    BOOL fRet = FALSE;

    PLIST_ENTRY pEntry = pListHead->Flink;

    while(pEntry != pListHead)
    {
        fRet = pfnDecision(pEntry, pContext);
        if (fRet)
        {
            break;
        }

        pEntry = pEntry->Flink;
    }
    return fRet;
}

struct FindTimerData
/*++
Struct Description:

    one pointer for cookie and found timer

--*/
{
    DWORD dwCookie;
    TIMER * pTimer;
};

BOOL
WINAPI
FindTimerEntry(PLIST_ENTRY pEntry,
               PVOID pvftd)
/*++

Routine Description:
    Determines if current pEntry is the timer being searched for

Arguments:
    pEntry - pointer to TIMER under consideration
    pvftd - void pointer to FindTimerData

Return Value:

    TRUE if TIMER matches, false otherwise

--*/
{
    TIMER * pTimer = TIMER::TimerFromListEntry(pEntry);
    FindTimerData * pftd = reinterpret_cast<FindTimerData*>(pvftd);

    if (pTimer->GetCookie() == pftd->dwCookie)
    {
        pftd->pTimer = pTimer;
        // don't continue enumeration
        return TRUE;
    }

    // continue enumeration
    return FALSE;
}

TIMER *
FindTimerNoLock(DWORD dwCookie)
/*++

Routine Description:
    Finds timer associated with cookie by walking timer list
    DOES NOT LOCK LIST

Arguments:
    dwCookie - cookie being looked for

Return Value:
    NULL if associated TIMER not found, otherwise TIMER *

--*/
{
    FindTimerData ftd;
    ftd.dwCookie = dwCookie;
    ftd.pTimer = NULL;

    WalkList(g_pScheduler->GetListHead(), FindTimerEntry, reinterpret_cast<PVOID>(&ftd));    

    return ftd.pTimer;
}

TIMER *
FindTimer(DWORD dwCookie)
/*++

Routine Description:

    Finds a TIMER associated with a given cookie
    LOCKS LIST

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    NULL if not found, otherwise TIMER * with cookie equal to dwCookie

--*/
{
    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return NULL;
    }

    TIMER * pTimer = FindTimerNoLock(dwCookie);

    LeaveCriticalSection(&g_SchedulerCritSec);

    return pTimer;
}

BOOL
WINAPI 
RemoveWorkItem(
    DWORD  dwCookie
    )
/*++

Routine Description:

    Removes a scheduled work item

    If NOT called from callback associated with cookie, function blocks waiting for all callbacks to finish.
    otherwise, queues deletion of TIMER, but no more callbacks will occur.

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    TRUE if the item was found, FALSE if the item was not found.

--*/
{
    TIMER * pTimer = NULL;

    if (!g_pScheduler)
    {
        return ERROR_NOT_READY;
    }

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "RemoveWorkItem: cookie=%d\n",
                        dwCookie));
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return FALSE;
    }

    pTimer = FindTimerNoLock(dwCookie);
    if (pTimer)
    {
        // remove this timer from the running list
        pTimer->RemoveFromList();
    }

    LeaveCriticalSection(&g_SchedulerCritSec);

    if (pTimer)
    {
        pTimer->Terminate();
    }
    else
    {
        SetLastError(ERROR_NOT_FOUND);
    }

    return pTimer ? TRUE : FALSE;
} // RemoveWorkItem()


DWORD
WINAPI 
ScheduleAdjustTime(
    DWORD dwCookie,
    DWORD msecNewTime
    )
/*++

Routine Description:

    Reschedules a given work item

    If NOT called from callback associated with cookie, function blocks waiting 
    for all callbacks to finish on previous TIMER.

    if called from callback associated with cookie, 
    queues deletion of previous TIMER, and some callbacks MAY still occur

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem
    msecNewTime - new time period

Return Value:
    
    Win32 error code: NO_ERROR => success.

    if item not found, returns ERROR_NOT_FOUND
    if item found but couldn't be rescheduled returns ERROR_OUT_OF_MEMORY

--*/
{
    DWORD dwRet = ERROR_NOT_FOUND;
    TIMER * pTimer = NULL;

    IF_DEBUG(SCHED)
    {
        DBGPRINTF(( DBG_CONTEXT, "ScheduleAdjustTime: cookie=%d time=%d\n",
                        dwCookie,
                        msecNewTime));
    }

    if (!g_pScheduler)
    {
        return ERROR_NOT_READY;
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    DBG_ASSERT(g_pScheduler && g_pScheduler->CheckSignature());

    if (!g_pScheduler)
    {
        LeaveCriticalSection(&g_SchedulerCritSec);
        return ERROR_NOT_READY;
    }

    pTimer = FindTimerNoLock(dwCookie);
    if (pTimer)
    {
        //
        // create the new timer and have it be on the list when we leave critsec
        // AND guarantee that the old timer won't ever call the callback function
        //
        pTimer->RemoveFromList();

        dwRet = pTimer->CopyTimer(msecNewTime);
    }
    
    LeaveCriticalSection(&g_SchedulerCritSec);

    if (pTimer)
    {
        pTimer->Terminate();
    }
    else
    {
        return ERROR_NOT_FOUND;
    }

    return dwRet;
} // ScheduleAdjustTime()


//
// Implementation of SCHEDULER
//

//static 
SCHEDULER*
SCHEDULER::CreateScheduler()
/*++

Routine Description:
    Creates the SCHEDULER object

Arguments:
    void

Return Value:
    NULL if scheduler couldn't be created, otherwise SCHEDULER*

--*/
{
    SCHEDULER* pScheduler = new SCHEDULER();
    if (NULL == pScheduler)
    {
        goto error;
    }

    pScheduler->m_hDeletionEvent = 
        CreateEvent(NULL,   // security descriptor
                    TRUE,   // manual reset
                    FALSE,  // initial state
                    NULL);  // name
    if (NULL == pScheduler->m_hDeletionEvent)
    {
        goto error;
    }

    pScheduler->m_hQueue = CreateTimerQueue();
    if (NULL == pScheduler->m_hQueue)
    {
        goto error;
    }

    return pScheduler;
error:
    delete pScheduler;
    return NULL;
}

SCHEDULER::SCHEDULER() :
    m_dwSignature(SIGNATURE_SCHEDULER),
    m_nID(InterlockedIncrement(&sm_nID)),
    m_hQueue(NULL),
    m_hDeletionEvent(NULL),
    m_cRef(0)
/*++

Routine Description:

    Constructor
Arguments:

    void

Return Value:
    
    void
--*/
{
    InitializeListHead(&m_listTimerHead);
}

void
SCHEDULER::Terminate()
/*++

Routine Description:

    Tears down and deletes a SCHEDULER

    Terminates all TIMERs still active
    Blocks waiting until all TIMER objects have released their reference on SCHEDULER
    Blocks waiting until all CALLBACK functions have returned by calling DeleteTimerQueue with blocking
    

Arguments:

    void

Return Value:

    void

--*/
{
    DBG_ASSERT(CheckSignature());

    BOOL fRet;

    //
    //  Delete all of the items that were scheduled, note we do *not*
    //  call any scheduled items in the list (there shouldn't be any)
    //

    DBG_ASSERT(IsListEmpty(&m_listTimerHead));

    while ( !IsListEmpty(&m_listTimerHead) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[SCHEDULER::Terminate] Warning - Items in schedule list "
                    "at termination\n" ));
        
        PLIST_ENTRY pEntry = m_listTimerHead.Flink;
        TIMER * pTimer = TIMER::TimerFromListEntry(pEntry);
        pTimer->Terminate();
    }

    LeaveCriticalSection(&g_SchedulerCritSec);

    while(0 != m_cRef)
    {
        // wait for all of the TIMER object to release their references
        Sleep(1000);
    }

    EnterCriticalSection(&g_SchedulerCritSec);

    // All the timers are gone now
    fRet = DeleteTimerQueueEx(m_hQueue,
                              INVALID_HANDLE_VALUE);
    DBG_ASSERT(FALSE != fRet);
    m_hQueue = NULL;

    DBG_ASSERT(0 == m_cRef);

    // can't touch this
    delete this;

    return;
} // SCHEDULER::Terminate()


SCHEDULER::~SCHEDULER()
/*++

Routine Description:
    destructor

Arguments:
    void

Return Value:
    void

--*/
{
    DBG_ASSERT(CheckSignature());
    DBG_ASSERT(IsListEmpty(&m_listTimerHead));
    DBG_ASSERT(NULL == m_hQueue);

    if (m_hDeletionEvent)
    {
        CloseHandle(m_hDeletionEvent);
        m_hDeletionEvent = NULL;
    }

    m_dwSignature = SIGNATURE_SCHEDULER_FREE;
}


//static 
DWORD
TIMER::Create(SCHEDULER        *pScheduler,
               PFN_SCHED_CALLBACK pfnCallback,
               PVOID              pContext,
               DWORD              msecTime,
               BOOL               fPeriodic,
               BOOL               fCoInitializeCallback,
               DWORD              dwCookie /* = 0 */
               )
/*++

Routine Description:
    Creates a TIMER object and adds the object to the active TIMER list

Arguments:
    pScheduler - owning scheduler
    pfnCallback - callback function
    pContext - context for callback
    msecTime - timeout
    fPeriodic - callback multiple times?
    fCoInitializeCallback - Should callback be CoInited?
    dwCookie - optional - preset cookie to give new object

Return Value:
    Cookie for new TIMER object, zero if not created.

--*/
{
    BOOL fRet;

    TIMER * pTimer = NULL;
    // allocate storage for the new timer
    pTimer = new TIMER(pScheduler);
    if (NULL == pTimer)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto done;
    }

    pTimer->m_hDeletionEvent = 
        CreateEvent(NULL,   // security descriptor
                    TRUE,   // manual reset
                    FALSE,  // initial state
                    NULL);  // name
    if (NULL == pTimer->m_hDeletionEvent)
    {
        delete pTimer;
        pTimer = NULL;
        goto done;
    }

    pTimer->m_pfnCallback = pfnCallback;
    pTimer->m_pContext = pContext;
    pTimer->m_fPeriodic = fPeriodic;
    pTimer->m_fCoInitializeCallback = fCoInitializeCallback;

    if (dwCookie)
    {
        // reuse a previously handed out cookie
        pTimer->m_dwCookie = dwCookie;
    }
    else
    {
        pTimer->m_dwCookie = InterlockedIncrement(&sm_lLastCookie);
        //
        // BUGBUG: handle cookie wrap-around
        //
    }

    InsertHeadList(pScheduler->GetListHead(), &pTimer->m_listEntry);

    fRet = pTimer->CreateTimer(msecTime);
    if (FALSE == fRet)
    {
        pTimer->RemoveFromList();
        delete pTimer;
        pTimer = NULL;
        goto done;
    }

done:
    return pTimer ? pTimer->GetCookie() : 0;
}

BOOL
TIMER::CreateTimer(DWORD msecTime)
/*++

Routine Description:
    Creates a TimerQueueTimer associated with the TIMER object

Arguments:
    msecTime - timeout for timer

Return Value:
    FALSE if timer couldn't be created, otherwise TRUE

--*/
{
    BOOL fRet = FALSE;

    DWORD dwPeriod = 0;
    ULONG ulFlags = 0;

    if (m_fPeriodic)
    {
        // timer period is set
        dwPeriod = msecTime;        
    }
    else
    {
        // if we aren't periodic, we only execute once
        ulFlags |= WT_EXECUTEONLYONCE;
    }

    // callback function could take long time to complete
    ulFlags |= WT_EXECUTELONGFUNCTION;

    fRet = CreateTimerQueueTimer(&m_hTimer,                 // pointer to HANDLE for new timer
                                 m_pScheduler->GetQueue(),  // TimerQueue
                                 TimerCallback,             // Callback function
                                 (PVOID)(DWORD_PTR)(m_dwCookie), // callback parameter
                                 msecTime,                  // first due time
                                 dwPeriod,                  // repition period
                                 ulFlags);                  // creation flags
    if (FALSE == fRet)
    {
        goto done;
    }

done:
    return fRet;
} // CreateTimer()

TIMER::TIMER(SCHEDULER * pScheduler) :
    m_dwSignature(SIGNATURE_TIMER),
    m_pScheduler(pScheduler),
    m_hDeletionEvent(NULL),
    m_hRegisterWaitHandle(NULL),
    m_lCallbackThreadId(0)
/*++

Routine Description:
    Constructor

Arguments:
    pScheduler - associated scheduler

Return Value:
    void

--*/
{
    DBG_ASSERT(NULL != pScheduler);
    m_pScheduler->ReferenceScheduler();
}

TIMER::~TIMER()
/*++

Routine Description:
    TIMER destructor

Arguments:
    void

Return Value:
    void

--*/
{
    DBG_ASSERT(CheckSignature());
    m_dwSignature = SIGNATURE_TIMER_FREE;

    DBG_ASSERT(NULL == m_hRegisterWaitHandle);
    DBG_ASSERT(NULL == m_hTimer);

    if (m_hDeletionEvent)
    {
        CloseHandle(m_hDeletionEvent);
        m_hDeletionEvent = NULL;
    }

    m_pScheduler->DereferenceScheduler();
}

void
TIMER::Terminate()
/*++

Routine Description:
    Begins (and sometimes finished) TIMER destruction.

    If current callback thread is NOT the same thread calling TIMER::Terminate
    Do a blocking call to DeleteTimerQueueTimer, then delete the current object

    If current callback thread IS the same thread calling TIMER::Terminate
    Register a wait for the callback to complete, and make a non blocking call
    to DeleteTimerQueueTimer and wait for the RegisterWait to fire and delete the 
    current object

Arguments:
    void

Return Value:
    void

--*/
{
    DBG_ASSERT(CheckSignature());

    BOOL fInCallback = FALSE;
    BOOL fRet;
    HANDLE hEvent = NULL;

    LONG lThreadId = GetCurrentThreadId();
    LONG lCallbackThreadId = 
        InterlockedCompareExchange(&m_lCallbackThreadId,
                                   0,
                                   lThreadId);
    if (lThreadId == lCallbackThreadId)
    {
        fInCallback = TRUE;
    }

    if (fInCallback)
    {
        // terminate is being called from callback function.  
        // Register a wait to destroy this once callback finishes
        fRet = RegisterWaitForSingleObject(&m_hRegisterWaitHandle,  // handle to fill out
                                           m_hDeletionEvent,        // event to wait for
                                           TIMER::PostTerminate,    // callback function
                                           this,                    // callback parameter
                                           INFINITE,                // timeout count
                                           WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION   // flags
                                           );
        
        DBG_ASSERT(FALSE != fRet);
    }

    if (fInCallback)
    {
        // terminate is being called from callback.  Must wait to destroy this
        hEvent = m_hDeletionEvent;
    }
    else
    {
        // terminate is being called from another thread.  Destroy this ASAP
        hEvent = INVALID_HANDLE_VALUE;
    }

    // signal the timer queue to remove this timer
    // at any point after this call the current TIMER can be deleted
    fRet = DeleteTimerQueueTimer(m_pScheduler->GetQueue(),  // queue to use
                                 m_hTimer,                  // timer to delete
                                 hEvent                     // event to signal
                                 );

    DBG_ASSERT((FALSE != fRet) ||
               (GetLastError() == ERROR_IO_PENDING));
    
    m_hTimer = NULL;

    if (!fInCallback)
    {
        // the DeleteTimerQueueTimer call was blocking - delete this object now!
        delete this;
    }
    
    return;
}

DWORD
TIMER::CopyTimer(DWORD msecTime)
/*++

Routine Description:
    Create a copy of the current object and add the copy to the running timer list

Arguments:
    msecTime - timeout period for new TIMER

Return Value:
    ERROR_SUCCESS on success, ERROR_NOT_ENOUGH_MEMORY on failure

--*/
{
    DBG_ASSERT(CheckSignature());

    DWORD dwRet;

    // create a new TIMER with the same cookie as this object
    dwRet = TIMER::Create(m_pScheduler,
                          m_pfnCallback,
                          m_pContext,
                          msecTime,
                          m_fPeriodic,
                          m_fCoInitializeCallback,
                          m_dwCookie);
    if (0 == dwRet)
    {
        // failed allocation on new timer
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    DBG_ASSERT(m_dwCookie == dwRet);

    return ERROR_SUCCESS;
}

//static
VOID
TIMER::TimerCallback(PVOID lpParameter,
                      BOOLEAN TimerOrWaitFired)
/*++

Routine Description:
    TimerCallback function

    Find TIMER associated with this callback
    if no other callbacks are occurring with this timer,
    CoInitialize if required, then
    callback to interesting function
    CoUninitialize if required then 
    if this was a one shot timer, delete it.
    otherwise see if timer is still valid and if so, reset
    the current thread

Arguments:
    lpParameter - cookie for timer currently firing
    TimerOrWaitFired - not used

Return Value:
    void

--*/
{
    DWORD dwCookie = (DWORD)(DWORD_PTR)(lpParameter);

    TIMER * pTimer = FindTimer(dwCookie);
    if (NULL == pTimer)
    {
        return;
    }

    DBG_ASSERT(pTimer->CheckSignature());

    BOOL fCoInitializeCallback = pTimer->m_fCoInitializeCallback;
    BOOL fPeriodic = pTimer->m_fPeriodic;
    
    LONG lThreadId = GetCurrentThreadId();
    LONG lPrevThreadId = 0;

    lPrevThreadId = InterlockedCompareExchange(
                        &pTimer->m_lCallbackThreadId,
                        lThreadId,
                        0);
    if (0 != lPrevThreadId)
    {
        // another TIMER callback is currently occurring
        // on this timer.  don't callback twice.
        return;
    }

    if (fCoInitializeCallback)
    {
        CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }

    pTimer->m_pfnCallback(pTimer->m_pContext);

    // don't touch pTimer after the call out.  
    // RemoveWorkItem could have been called, and the pointer could be gone
    pTimer = NULL;

    if (fCoInitializeCallback)
    {
        CoUninitialize();
    }

    if (!fPeriodic)
    {
        RemoveWorkItem(dwCookie);
    }
    else
    {
        // timer may or may not still exist
        pTimer = FindTimer(dwCookie);
        if (pTimer)
        {
            InterlockedExchange(&pTimer->m_lCallbackThreadId,
                                0);
        }
    }

    return;
}

//static
void
TIMER::PostTerminate(PVOID lpParameter,
                      BOOLEAN TimerOrWaitFired)
/*++

Routine Description:
    If TIMER::Terminate had to wait to delete the current TIMER,
    this function is called when the TIMER can be deleted.

Arguments:
    lpParameter - pointer to TIMER to delete
    TimerOrWaitFired - unused

Return Value:
    void

--*/
{
    BOOL fRet;
    TIMER * pThis = reinterpret_cast<TIMER*>(lpParameter);

    DBG_ASSERT(pThis->CheckSignature());
    DBG_ASSERT(0 == pThis->m_lCallbackThreadId);

    // because this was a one time RegisterWait this is safe
    fRet = UnregisterWaitEx(pThis->m_hRegisterWaitHandle,
                            NULL);  
    DBG_ASSERT((FALSE != fRet) ||
               (GetLastError() == ERROR_IO_PENDING));
    pThis->m_hRegisterWaitHandle = NULL;

    delete pThis;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\secfcns.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    secfns.cxx

        Declarations for some functions that support working with
        security SID, ACLS, TOKENS, and other pieces.
*/

#include "precomp.hxx"
#include <secfcns.h>
#include <Aclapi.h>

/***************************************************************************++

Routine Description:

    Figures out how much memory is needed and allocates the memory
    then requests the well known sid to be copied into the memory.  If
    all goes well then the SID is returned, if anything fails the 
    SID is not returned.  

Arguments:

    WELL_KNOWN_SID_TYPE SidType = Enum value for the SID being requested.
    PSID* ppSid = Ptr to the pSid that is returned.

Return Value:

    DWORD - Win32 Status Code.

--***************************************************************************/
DWORD 
AllocateAndCreateWellKnownSid( 
    WELL_KNOWN_SID_TYPE SidType,
    PSID* ppSid
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( ppSid != NULL && *ppSid == NULL );

    PSID  pSid = NULL;
    DWORD cbSid = 0;

    //
    // Get the size of memory needed for the sid.
    //
    if ( CreateWellKnownSid(SidType, NULL, NULL, &cbSid ) )
    {
        // If CreateWellKnownSid passed then there is a problem
        // because we passed in NULL for the pointer to the sid.

        dwErr = ERROR_NOT_SUPPORTED;

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating a sid worked with no memory allocated for it. ( This is not good )\n"
            ));

        DBG_ASSERT ( FALSE );
        goto exit;
    }

    //
    // Get the error code and make sure it is
    // not enough space allocated.
    //
    dwErr = GetLastError();
    if ( dwErr != ERROR_INSUFFICIENT_BUFFER ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Getting the SID length failed, can't create the sid (Type = %d)\n",
            SidType
            ));

        goto exit;
    }

    //
    // If we get here then the error code was expected, so
    // lose it now.
    //
    dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( cbSid > 0 );

    // 
    // At this point we know the size of the sid to allocate.
    //
    pSid = (PSID) GlobalAlloc(GMEM_FIXED, cbSid);

    // 
    // Ok now we can get the SID
    //
    if ( !CreateWellKnownSid (SidType, NULL, pSid, &cbSid) )
    {
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating SID failed ( SidType = %d )\n",
            SidType
            ));

        goto exit;
    }

    DBG_ASSERT ( dwErr == ERROR_SUCCESS );

exit:

    //
    // If we are returning a failure here, we don't
    // want to actually set the ppSid value.  It may
    // not get freed.
    //
    if ( dwErr != ERROR_SUCCESS && pSid != NULL)
    {
        GlobalFree( pSid );
        pSid = NULL;
    }
    else
    {
        //
        // Otherwise we should return the value
        // to the caller.  The caller must 
        // use FreeWellKnownSid to free this value.
        //
        *ppSid = pSid;
    }
        
    return dwErr;
}

/***************************************************************************++

Routine Description:

    Frees memory that was allocated by the 
    AllocateAndCreateWellKnownSid function.

Arguments:

    PSID* ppSid = Ptr to the pointer to be freed and set to NULL.

Return Value:

    VOID.

--***************************************************************************/
VOID 
FreeWellKnownSid( 
    PSID* ppSid
    )
{
    DBG_ASSERT ( ppSid );
    if ( *ppSid != NULL )
    {
        GlobalFree ( *ppSid );
        *ppSid = NULL;
    }
}

/***************************************************************************++

Routine Description:

    Routine will create an acl for a well known sid and return it.
    It allocates all the memory so you don't have to.  But you do have to
    call FreeWellKnownAcl to free the memory.

    It also returns the size of memory allocated.

   
Arguments:

    WELL_KNOWN_SID_TYPE SidType = Enum value for the SID being requested.
    PACL* ppAcl = Ptr to the pAcl that is returned.

Return Value:

    DWORD - Win32 Status Code.

--***************************************************************************/
DWORD 
AllocateAndCreateWellKnownAcl( 
    WELL_KNOWN_SID_TYPE SidType,
    BOOL  fAccessAllowedAcl,
    PACL* ppAcl,
    DWORD* pcbAcl
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    PSID  pSid = NULL;
    DWORD dwSizeOfAcl = sizeof( ACL );
    PACL pAcl = NULL;

    DBG_ASSERT ( ppAcl != NULL && *ppAcl == NULL );
    DBG_ASSERT ( pcbAcl != NULL );

    *pcbAcl = 0;

    //
    // Create the sid
    //
    dwErr = AllocateAndCreateWellKnownSid ( SidType, &pSid );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating SID failed ( SidType = %d )\n",
            SidType
            ));

        goto exit;
    }

    //
    // Figure out the side of the ACL to create.
    //

    // It all ready has the size of the ACl from above.

    // add in the size of the ace.
    if ( fAccessAllowedAcl ) 
    {
        ACCESS_ALLOWED_ACE a;
        dwSizeOfAcl = dwSizeOfAcl + sizeof ( a ) - sizeof ( a.SidStart );
    }
    else
    {
        ACCESS_DENIED_ACE d;
        dwSizeOfAcl = dwSizeOfAcl + sizeof ( d ) - sizeof ( d.SidStart );
    }

    // don't forget the size of the sid as well.
    dwSizeOfAcl += GetLengthSid (pSid);


    // Now create enough space for all.
    pAcl = reinterpret_cast< PACL > ( GlobalAlloc(GMEM_FIXED, dwSizeOfAcl) ); 
    if ( pAcl == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failure allocating space for the acl\n"
            ));

        goto exit;

    }
        
    // Now initalize the ACL.
    if ( !InitializeAcl ( pAcl, dwSizeOfAcl, ACL_REVISION ) )
    {
        dwErr = GetLastError();

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failure initializing the acl\n"
            ));

        goto exit;

    }

    // Now add an acl of the appropriate type.
    if ( fAccessAllowedAcl )
    {
        if ( !AddAccessAllowedAce( pAcl, ACL_REVISION, 
                                   GENERIC_ALL, pSid ) )
        {
            dwErr = GetLastError();

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Failure adding the access allowed ace to the acl\n"
                ));

            goto exit;
        }
    }
    else
    {
        if ( !AddAccessDeniedAce( pAcl, ACL_REVISION, 
                                   GENERIC_ALL, pSid ) )
        {
            dwErr = GetLastError();

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Failure adding the access denied ace to the acl\n"
                ));

            goto exit;
        }
    }


    // if we make it here then we have succeeded in creating the 
    // acl, and we will be returning it out.

    *ppAcl = pAcl;
    *pcbAcl = dwSizeOfAcl;


exit:

    //
    // No matter what, we need to free the original sid that
    // was created for us.
    //
    FreeWellKnownSid( &pSid );

    //
    // If we are not returning the acl out
    // then we need to free any memory we created.
    //
    if ( *ppAcl == NULL )
    {
        FreeWellKnownAcl ( &pAcl );
    }
        
    return dwErr;
}

/***************************************************************************++

Routine Description:

    Frees memory that was allocated by the 
    AllocateAndCreateWellKnownAcl function.

Arguments:

    PACL* ppAcl = Ptr to the pointer to be freed and set to NULL.

Return Value:

    VOID.

--***************************************************************************/
VOID 
FreeWellKnownAcl( 
    PACL* ppAcl
    )
{
    DBG_ASSERT ( ppAcl );
    if ( *ppAcl != NULL )
    {
        GlobalFree ( *ppAcl );
        *ppAcl = NULL;
    }
}

/***************************************************************************++

Routine Description:

    Set EXPLICIT_ACCESS settings for wellknown sid.

Arguments:

    

Return Value:




--***************************************************************************/
VOID 
SetExplicitAccessSettings( EXPLICIT_ACCESS* pea,
                           DWORD            dwAccessPermissions,
                           ACCESS_MODE      AccessMode,
                           PSID             pSID
    )
{
    pea->grfInheritance= NO_INHERITANCE;
    pea->Trustee.TrusteeForm = TRUSTEE_IS_SID;
    pea->Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;

    pea->grfAccessMode = AccessMode;
    pea->grfAccessPermissions = dwAccessPermissions;
    pea->Trustee.ptstrName  = (LPTSTR) pSID;
}

/***************************************************************************++

Routine Description:

    Constructor for CSecurityDispenser class

Arguments:

    

Return Value:


--***************************************************************************/
CSecurityDispenser::CSecurityDispenser() :
    m_pLocalSystemSID ( NULL ),
    m_pLocalServiceSID ( NULL ),
    m_pNetworkServiceSID ( NULL ),
    m_WpgSIDIsSet ( FALSE ),
    m_pACLForAllWorkerProcesses ( NULL ),
    m_pSDForAllWorkerProcesses ( NULL ),
    m_pSAForAllWorkerProcesses ( NULL )
{
}

/***************************************************************************++

Routine Description:

    Destructor for CSecurityDispenser class

Arguments:

    

Return Value:


--***************************************************************************/
CSecurityDispenser::~CSecurityDispenser() 
{
    //
    // FreeWellKnownSid will only free if it is not null
    // and will set to null once it is done.
    //

    FreeWellKnownSid ( &m_pLocalSystemSID );
    FreeWellKnownSid ( &m_pLocalServiceSID );
    FreeWellKnownSid ( &m_pNetworkServiceSID );

    // 
    // The buffer class will clean up m_pWPG_SID.
    //


    if ( m_pACLForAllWorkerProcesses )
    {
        LocalFree ( m_pACLForAllWorkerProcesses );
        m_pACLForAllWorkerProcesses = NULL;
    }

    if ( m_pSDForAllWorkerProcesses )
    {
        delete m_pSDForAllWorkerProcesses;
        m_pSDForAllWorkerProcesses = NULL;
    }

    if ( m_pSAForAllWorkerProcesses )
    {
        delete m_pSAForAllWorkerProcesses;
        m_pSAForAllWorkerProcesses = NULL;
    }

}


/***************************************************************************++

Routine Description:

    Gets security id's for the well known accounts that IIS deals with.

Arguments:

    

Return Value:

    DWORD - NtSuccess code, ( used here so functions that don't expose HRESULTS
                              can still use this function )


--***************************************************************************/
DWORD 
CSecurityDispenser::GetSID(
    WELL_KNOWN_SID_TYPE sidId, 
    PSID* ppSid
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( ( ppSid != NULL ) && ( ( *ppSid ) == NULL ) );

    switch ( sidId )
    {
        case ( WinLocalSystemSid):

            // if we have the local system sid return it.
            if ( m_pLocalSystemSID != NULL )
            {
                *ppSid = m_pLocalSystemSID;

                goto exit;

            }
            

        break;

        case ( WinLocalServiceSid ):

            // if we have the LocalService system sid return it.
            if ( m_pLocalServiceSID != NULL )
            {
                *ppSid = m_pLocalServiceSID;

                goto exit;
            }

        break;

        case ( WinNetworkServiceSid ):
            
            // if we have the NetworkService system sid return it.
            if ( m_pNetworkServiceSID != NULL )
            {
                *ppSid = m_pNetworkServiceSID;

                goto exit;
            }

        break;

        default:

            DBG_ASSERT ( FALSE ) ;
            dwErr = ERROR_INVALID_PARAMETER;
            goto exit;

    }

    // if we get here then we haven't created the sid yet, so we
    // need to do that now.

    dwErr = AllocateAndCreateWellKnownSid( sidId, ppSid );
    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Failed to create the sid we were looking for\n",
            sidId
            ));

        goto exit;
    }

    //
    // Now hold on to the security id so we won't have
    // to worry about creating it again later.
    //
    switch ( sidId )
    {
        case ( WinLocalSystemSid ):

            m_pLocalSystemSID = *ppSid;

        break;

        case ( WinLocalServiceSid ):

            m_pLocalServiceSID = *ppSid;

        break;

        case ( WinNetworkServiceSid ):

            m_pNetworkServiceSID = *ppSid;
            
        break;

        default:

            DBG_ASSERT ( FALSE ) ;
            goto exit;

    }

exit:

    return dwErr;

}

/***************************************************************************++

Routine Description:

    Gets the IIS_WPG side ( creates it if it has to ).

Arguments:

    

Return Value:

    DWORD - NtSuccess code, ( used here so functions that don't expose HRESULTS
                              can still use this function )


--***************************************************************************/
DWORD 
CSecurityDispenser::GetIisWpgSID(
    PSID* ppSid
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbSid = m_WpgSID.QuerySize();
    BUFFER buffDomainName;
    DWORD cchDomainName = buffDomainName.QuerySize() / sizeof(WCHAR);
    SID_NAME_USE peUse;

    DBG_ASSERT ( ( ppSid != NULL ) && ( ( *ppSid ) == NULL ) );

    if ( m_WpgSIDIsSet )
    {
        *ppSid = m_WpgSID.QueryPtr();

        return ERROR_SUCCESS;
    }

    //
    // obtain the logon sid of the IIS_WPG group
    //
    while(!LookupAccountName(NULL,
                             L"IIS_WPG",
                             m_WpgSID.QueryPtr(),
                             &cbSid,
                             (LPWSTR)buffDomainName.QueryPtr(),
                             &cchDomainName,
                             &peUse))
    {
        dwErr = GetLastError();

        if ( dwErr != ERROR_INSUFFICIENT_BUFFER )
        {

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not look up the IIS_WPG group sid.\n"
                ));

            goto Exit;
        }

        // forget about the insufficient buffer size.
        dwErr = ERROR_SUCCESS;

        if (!m_WpgSID.Resize(cbSid) ||
            !buffDomainName.Resize(cchDomainName * sizeof(WCHAR)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Failed to allocate appropriate space for the WPG sid\n"
                ));

            goto Exit;
        }
    }

    m_WpgSIDIsSet = TRUE;

    // save the value back to the user.
    *ppSid = m_WpgSID.QueryPtr();

Exit:

    return dwErr;
}

/***************************************************************************++

Routine Description:

    Returns a security attribute that can be used to grant all access
    to the identities that may be used for worker processes.

Arguments:

    PSECURITY_ATTRIBUTES* ppSa - Ptr to the security attribute being returned.

Return Value:

    DWORD - NtSuccess code, ( used here so functions that don't expose HRESULTS
                              can still use this function )


--***************************************************************************/
DWORD 
CSecurityDispenser::GetSecurityAttributesForAllWorkerProcesses(
    PSECURITY_ATTRIBUTES* ppSa
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    // The well known sids that should have full access.
    WELL_KNOWN_SID_TYPE    WellKnownSidsToAdd[] = { WinLocalSystemSid,
                                                    WinLocalServiceSid,
                                                    WinNetworkServiceSid };

    // Number of wellknown sids with full access.
    DWORD                  NumWellKnownSidsToAdd = sizeof(WellKnownSidsToAdd) / sizeof (WELL_KNOWN_SID_TYPE);

    // Number of total sids.
    DWORD                  NumberOfSidsTotal = NumWellKnownSidsToAdd + 1;   // 1 is for the WPG group

    // local variables to hold values until we know we succeeded.
    PEXPLICIT_ACCESS       pEa = NULL;
    PACL                   pAcls = NULL;
    PSECURITY_DESCRIPTOR   pSd = NULL;
    PSECURITY_ATTRIBUTES   pSa = NULL;

    // Make sure we can return a result.
    DBG_ASSERT ( ( ppSa != NULL ) && ( (*ppSa) == NULL ) );

    // If we all ready have the result then return it.
    // Otherwise we assume we don't have any of the others set 
    // and we need to set them all.
    if ( m_pSAForAllWorkerProcesses != NULL )
    {
        *ppSa = m_pSAForAllWorkerProcesses;
        return ERROR_SUCCESS;
    }

    DBG_ASSERT ( m_pSDForAllWorkerProcesses == NULL && 
                 m_pACLForAllWorkerProcesses == NULL );

    // Don't worry about this guys memory, he will always point
    // to memory owned by this object and should never have to clean
    // it up himself.
    PSID pSidToAdd = NULL;

    pEa = new EXPLICIT_ACCESS[NumberOfSidsTotal];
    if ( pEa == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pEa, sizeof(EXPLICIT_ACCESS) * NumberOfSidsTotal);

    // Add the well known sids first.
    for ( DWORD i = 0; i < NumWellKnownSidsToAdd; i++ )
    {

        pSidToAdd = NULL;

        dwErr = GetSID( WellKnownSidsToAdd[i], &pSidToAdd );
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        DBG_ASSERT ( pSidToAdd != NULL );

        SetExplicitAccessSettings( &(pEa[i]),
                                   GENERIC_ALL,
                                   GRANT_ACCESS,
                                   pSidToAdd );
    }

    // now add the WPG sid.
    pSidToAdd = NULL;

    dwErr = GetIisWpgSID( &pSidToAdd );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    // can use the number of well known sids since this will
    // always follow that list.
    SetExplicitAccessSettings( &(pEa[NumWellKnownSidsToAdd]),
                               GENERIC_ALL,
                               GRANT_ACCESS,
                               pSidToAdd );

    // override the well known group setting.
    pEa[NumWellKnownSidsToAdd].Trustee.TrusteeType = TRUSTEE_IS_GROUP;


    // At this point we know we have m_pEaForAllWorkerProcesses.
    // Now lets get the ACL for it up.

    // Create a new ACL that contains the new ACEs.
    // You don't need the ACEs after this point ( I hope ).
    //
    dwErr = SetEntriesInAcl(NumberOfSidsTotal, pEa, NULL, &pAcls);
    if ( dwErr != ERROR_SUCCESS ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    pSd = new SECURITY_DESCRIPTOR;
    if ( pSd == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pSd, sizeof(SECURITY_DESCRIPTOR));

    if (!InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    } 

    if (!SetSecurityDescriptorDacl(pSd, 
            TRUE,     // fDaclPresent flag   
            pAcls, 
            FALSE))   // not a default DACL 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    }                                

    pSa = new SECURITY_ATTRIBUTES;
    if ( pSa == NULL )
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pSa, sizeof(SECURITY_ATTRIBUTES));

    pSa->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSa->lpSecurityDescriptor = pSd;
    pSa->bInheritHandle = FALSE;

exit:

    // Don't need to hold this memory, so always go ahead and free it.
    if ( pEa )
    {
        delete [] pEa;
        pEa = NULL;
    }

    if ( dwErr == ERROR_SUCCESS )
    {
        // Note these will get cleaned up when this
        // dispenser shutsdown.
        m_pACLForAllWorkerProcesses = pAcls;
        m_pSDForAllWorkerProcesses = pSd;
        m_pSAForAllWorkerProcesses = pSa;

        // Setup the return value.
        *ppSa = pSa;
    }
    else
    {
        if ( pAcls )
        {
            LocalFree ( pAcls );
            pAcls = NULL;
        }

        if ( pSd )
        {
            delete pSd;
            pSd = NULL;
        }

        if ( pSa )
        {
            delete pSa;
            pSa = NULL;
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\stktrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This module contains public declarations and definitions for capturing
    stack back traces.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\sharelok.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//   The include files for supporting classes.
//
//   The include files for supporting classes consists of
//   classes refered to or used in this class.  The structure
//   of each source module is as follows:
//      1. Include files.
//      2. Constants local to the class.
//      3. Data structures local to the class.
//      4. Data initializations.
//      5. Static functions.
//      6. Class functions.
//   Sections that are not required are omitted.
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <Sharelok.h>


//////////////////////////////////////////////////////////////////////
//
//   Class constructor.
//
//   Create a new lock and initialize it.  This call is not
//   thread safe and should only be made in a single thread
//   environment.
//
//////////////////////////////////////////////////////////////////////

CSharelock::CSharelock( SBIT32 lNewMaxSpins, SBIT32 lNewMaxUsers )
{
	//
	//   Set the initial state.
	//
	m_lExclusive = 0;
	m_lTotalUsers = 0;
    m_lWaiting = 0;

	//
	//   Check the configurable values.
	//
	if ( lNewMaxSpins > 0 )
	{ 
		m_lMaxSpins = lNewMaxSpins; 
	}
	else
	{
		throw (TEXT("Maximum spins invalid in constructor for CSharelock")); 
	}

	if ( (lNewMaxUsers > 0) && (lNewMaxUsers <= m_MaxShareLockUsers) )
	{
		m_lMaxUsers = lNewMaxUsers; 
	}
	else
	{
		throw (TEXT("Maximum share invalid in constructor for CSharelock")); 
	}

	//
	//   Create a semaphore to sleep on when the spin count exceeds
	//   its maximum.
	//
    if ( (m_hSemaphore = CreateSemaphore( NULL, 0, m_MaxShareLockUsers, NULL )) == NULL)
    {
		throw (TEXT("Create semaphore in constructor for CSharelock")); 
	}

#ifdef _DEBUG

	//
	//   Set the initial state of any debug variables.
	//
    m_lTotalExclusiveLocks = 0;
    m_lTotalShareLocks = 0;
    m_lTotalSleeps = 0;
    m_lTotalSpins = 0;
    m_lTotalTimeouts = 0;
    m_lTotalWaits = 0;
#endif
    }

//////////////////////////////////////////////////////////////////////
//
//   Sleep waiting for the lock.
//
//   We have decided it is time to sleep waiting for the lock
//   to become free.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::SleepWaitingForLock( SBIT32 lSleep )
{
	//
	//   We have been spinning waiting for the lock but it
	//   has not become free.  Hence, it is now time to 
	//   give up and sleep for a while.
	//
	(void) InterlockedIncrement( (LPLONG) & m_lWaiting );

	//
	//   Just before we go to sleep we do one final check
	//   to make sure that the lock is still busy and that
	//   there is someone to wake us up when it becomes free.
	//
	if ( m_lTotalUsers > 0 )
	{
#ifdef _DEBUG
		//
		//   Count the number of times we have slept on this lock.
		//
		(void) InterlockedIncrement( (LPLONG) & m_lTotalSleeps );

#endif
		//
		//   When we sleep we awoken when the lock becomes free
		//   or when we timeout.  If we timeout we simply exit
		//   after decrementing various counters.
		if (WaitForSingleObject( m_hSemaphore, lSleep ) != WAIT_OBJECT_0 )
		{ 
#ifdef _DEBUG
			//
			//   Count the number of times we have timed out 
			//   on this lock.
			//
			(void) InterlockedIncrement( (LPLONG) & m_lTotalTimeouts );

#endif
			return FALSE; 
		}
	}
	else
	{
		//
		//   Lucky - the lock was just freed so lets
		//   decrement the sleep count and exit without
		//   sleeping.
		// 
		(void) InterlockedDecrement( (LPLONG) & m_lWaiting );
	}
	
	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Update the spin limit.
//
//   Update the maximum number of spins while waiting for the lock.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::UpdateMaxSpins( SBIT32 lNewMaxSpins )
{
	if ( lNewMaxSpins > 0 )
	{ 
		m_lMaxSpins = lNewMaxSpins; 

		return TRUE;
	}
	else
	{ 
		return FALSE; 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Update the sharing limit.
//
//   Update the maximum number of users that can share the lock.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::UpdateMaxUsers( SBIT32 lNewMaxUsers )
{
	if ( (lNewMaxUsers > 0) && (lNewMaxUsers <= m_MaxShareLockUsers) )
	{
		ClaimExclusiveLock();

		m_lMaxUsers = lNewMaxUsers;
		
		ReleaseExclusiveLock();

		return TRUE;
	}
	else
	{ 
		return FALSE; 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Wait for an exclusive lock.
//
//   Wait for the spinlock to become free and then claim it.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::WaitForExclusiveLock( SBIT32 lSleep )
{
#ifdef _DEBUG
	register SBIT32 lSpins = 0;
	register SBIT32 lWaits = 0;

#endif
	while ( m_lTotalUsers != 1 )
	{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );
    
		//
		//  Find out if we are allowed to spin and sleep if
		//  necessary.
		//
		if ( (lSleep > 0) || (lSleep == INFINITE) )
		{
			register SBIT32 lCount;

			//
			//   Wait by spinning and repeatedly testing the lock.
			//   We exit when the lock becomes free or the spin limit
			//   is exceeded.
			//
			for (lCount = (NumProcessors() < 2) ? 0 : m_lMaxSpins;
                 (lCount > 0) && (m_lTotalUsers > 0);
                 lCount -- )
				;
#ifdef _DEBUG

			lSpins += (m_lMaxSpins - lCount);
			lWaits ++;
#endif

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( lCount == 0 )
			{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
				(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

				//
				//   We have decide to go to sleep.  If the sleep time
				//   is not 'INFINITE' then we must subtract the time
				//   we sleep from our maximum sleep time.  If the
				//   sleep time is 'INFINITE' then we can just skip
				//   this step.
				//
				if ( lSleep != INFINITE )
				{
					register DWORD dwStartTime = GetTickCount();

					if ( ! SleepWaitingForLock( lSleep ) )
					{ 
						return FALSE; 
					}

					lSleep -= ((GetTickCount() - dwStartTime) + 1);
					lSleep = (lSleep > 0) ? lSleep : 0;
				}
				else
				{
					if ( ! SleepWaitingForLock( lSleep ) )
					{
						return FALSE; 
					}
				}

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
				(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
			}
		}
		else
		{ 
			//
			//   We have decide that we need to exit but are still
			//   holding an exclusive lock.  so lets drop it and leave.
			//
			(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

			return FALSE; 
		} 

		//
		//   Lets test the lock again.
		//
		InterlockedIncrement( (LPLONG) & m_lTotalUsers );
	}
#ifdef _DEBUG

	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalSpins, (LONG) lSpins );
	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalWaits, (LONG) lWaits );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Wait for a shared lock.
//
//   Wait for the lock to become free and then claim it.
//
//////////////////////////////////////////////////////////////////////

BOOLEAN CSharelock::WaitForShareLock( SBIT32 lSleep )
{
#ifdef _DEBUG
	register SBIT32 lSpins = 0;
	register SBIT32 lWaits = 0;

#endif
	while ( (m_lExclusive > 0) || (m_lTotalUsers > m_lMaxUsers) )
	{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );

		if ( (lSleep > 0) || (lSleep == INFINITE) )
		{
			register SBIT32 lCount;

			//
			//   Wait by spinning and repeatedly testing the lock.
			//   We exit when the lock becomes free or the spin limit
			//   is exceeded.
			//
			for (lCount = (NumProcessors() < 2) ? 0 : m_lMaxSpins;
                 (lCount > 0) && ((m_lExclusive > 0) || (m_lTotalUsers >= m_lMaxUsers));
                 lCount -- )
				;
#ifdef _DEBUG

			lSpins += (m_lMaxSpins - lCount);
			lWaits ++;
#endif

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( lCount == 0 )
			{ 
				//
				//   We have decide to go to sleep.  If the sleep time
				//   is not 'INFINITE' then we must subtract the time
				//   we sleep from our maximum sleep time.  If the
				//   sleep time is 'INFINITE' then we can just skip
				//   this step.
				//
				if ( lSleep != INFINITE )
				{
					register DWORD dwStartTime = GetTickCount();

					if ( ! SleepWaitingForLock( lSleep ) )
					{ 
						return FALSE; 
					}

					lSleep -= ((GetTickCount() - dwStartTime) + 1);
					lSleep = (lSleep > 0) ? lSleep : 0;
				}
				else
				{
					if ( ! SleepWaitingForLock( lSleep ) )
					{
						return FALSE; 
					}
				}
			}
		}
		else
		{ 
			return FALSE; 
		}

		//
		//   Lets test the lock again.
		//
		(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );
	}
#ifdef _DEBUG


	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalSpins, (LONG) lSpins );
	(void) InterlockedExchangeAdd( (LPLONG) & m_lTotalWaits, (LONG) lWaits );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Wake all sleepers.
//
//   Wake all the sleepers who are waiting for the spinlock.
//   All sleepers are woken because this is much more efficent
//   and it is known that the lock latency is short.
//
//////////////////////////////////////////////////////////////////////

void CSharelock::WakeAllSleepers( void )
{
    register LONG lWakeup = InterlockedExchange( (LPLONG) & m_lWaiting, 0 );

    if ( lWakeup > 0 )
    {
        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( m_hSemaphore, lWakeup, NULL ) )
        { 
			throw (TEXT("Wakeup failed in ReleaseLock()")); 
		}
    }
    else
    {
        //
        //   When multiple threads pass through the critical section rapidly
        //   it is possible for the 'Waiting' count to become negative.
        //   This should be very rare but such a negative value needs to be
        //   preserved. 
        //
        InterlockedExchangeAdd( (LPLONG) & m_lWaiting, lWakeup ); 
    }
}

//////////////////////////////////////////////////////////////////////
//
//   Class destructor.
//
//   Destroy a lock.  This call is not thread safe and should
//   only be made in a single thread environment.
//
//////////////////////////////////////////////////////////////////////

CSharelock::~CSharelock( void )
{
    if ( ! CloseHandle( m_hSemaphore ) )
    { 
		throw (TEXT("Close semaphore in destructor for CSharelock")); 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\string.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class.


    FILE HISTORY:
        Johnl       15-Aug-1994 Created
        MuraliK     27-Feb-1995 Modified to be a standalone module with buffer.
        MuraliK     2-June-1995 Made into separate library
        MCourage    12-Feb-1999 Another rewrite. All unicode of course.

*/

#include "precomp.hxx"


//
// Normal includes only for this module to be active
//

# include <string.hxx>


//
//  Private Definations
//

// Change a hexadecimal digit to its numerical equivalent
#define TOHEX( ch )                                     \
    ((ch) > L'9' ?                                      \
        (ch) >= L'a' ?                                  \
            (ch) - L'a' + 10 :                          \
            (ch) - L'A' + 10                            \
        : (ch) - L'0')

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128



/***************************************************************************++

Routine Description:

    Appends to the string starting at the (byte) offset cbOffset.

Arguments:

    pStr     - A unicode string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/


HRESULT
STRU::AuxAppend(
    const BYTE * pStr,
    ULONG        cbStr,
    ULONG        cbOffset,
    BOOL         fAddSlop
    )
{
    DBG_ASSERT( pStr );
    DBG_ASSERT( cbStr % 2 == 0 );
    DBG_ASSERT( cbOffset <= QueryCB() );
    DBG_ASSERT( cbOffset % 2 == 0 );
    
    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + cbStr + sizeof(WCHAR) )
    {
        UINT uNewSize = cbOffset + cbStr;

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(WCHAR);
        }
        
        if ( !m_Buff.Resize(uNewSize) ) {
            //
            // CODEWORK: BUFFER should return HRESULTs
            //
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    //
    // copy the exact string and append a null character
    //
    memcpy(
        (BYTE *) m_Buff.QueryPtr() + cbOffset,
        pStr,
        cbStr
        );

    //
    // set the new length
    //
    m_cchLen = (cbStr + cbOffset) / sizeof(WCHAR);

    //
    // append NUL character
    //
    *(QueryStr() + m_cchLen) = L'\0';

    return S_OK;
}

/***************************************************************************++

Routine Description:

    Convert and append an ANSI string to the string starting at 
    the (byte) offset cbOffset

Arguments:

    pStr     - An ANSI string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STRU::AuxAppendA(
    const BYTE * pStr,
    ULONG        cbStr,
    ULONG        cbOffset,
    BOOL         fAddSlop
    )
{
    WCHAR *             pszBuffer;
    
    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );
    DBG_ASSERT( cbOffset % 2 == 0 );
    
    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + (cbStr * sizeof( WCHAR )) + sizeof(WCHAR) )
    {
        UINT uNewSize = cbOffset + cbStr*sizeof(WCHAR);

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(WCHAR);
        }
        
        if ( !m_Buff.Resize(uNewSize) ) {
            //
            // CODEWORK: BUFFER should return HRESULTs
            //
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    //
    // Copy/convert the ANSI string over (by making one byte into two)
    //
    pszBuffer = (WCHAR*)((BYTE*) m_Buff.QueryPtr() + cbOffset);
    for ( unsigned int i = 0; i < cbStr; i++ )
    {
        pszBuffer[ i ] = (WCHAR) pStr[ i ];
    }

    //
    // set the new length
    //
    m_cchLen = (cbStr*sizeof(WCHAR) + cbOffset) / sizeof(WCHAR);

    //
    // append NUL character
    //
    *(QueryStr() + m_cchLen) = L'\0';

    return S_OK;
}

HRESULT
STRU::CopyToBuffer( 
    WCHAR *         pszBuffer, 
    DWORD *         pcb
    ) const
{
    HRESULT         hr = S_OK;
    
    if ( pcb == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DWORD cbNeeded = (QueryCCH() + 1) * sizeof(WCHAR);
    if ( *pcb >= cbNeeded && 
         pszBuffer != NULL )
    {
        //
        // Do the copy
        //
        memcpy(pszBuffer, QueryStr(), cbNeeded);
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }
    
    *pcb = cbNeeded;
    
    return hr;
}

HRESULT STRU::Unescape()
/*++
  Unescape the string (URL or QueryString)
--*/
{
    WCHAR   *pScan;

    //
    // First convert any +'s to spaces
    //

    for (pScan = wcschr(QueryStr(), '+');
         pScan != NULL;
         pScan = wcschr(pScan + 1, L'+'))
    {
        *pScan = L' ';
    }

    //
    // Now take care of any escape characters
    //

    WCHAR   *pDest;
    WCHAR   *pNextScan;
    BOOL    fChanged = FALSE;

    pDest = pScan = wcschr(QueryStr(), L'%');

    while (pScan)
    {
        if ((pScan[1] == L'u' || pScan[1] == L'U') &&
            iswxdigit(pScan[2]) &&
            iswxdigit(pScan[3]) &&
            iswxdigit(pScan[4]) &&
            iswxdigit(pScan[5]))
        {
            *pDest = TOHEX(pScan[2]) * 4096 + TOHEX(pScan[3]) * 256
                + TOHEX(pScan[4]) * 16 + TOHEX(pScan[5]);

            pDest++;
            pScan += 6;
            fChanged = TRUE;
        }
        else if (iswxdigit(pScan[1]) && iswxdigit(pScan[2]))
        {
            *pDest = TOHEX(pScan[1]) * 16 + TOHEX(pScan[2]);

            pDest++;
            pScan += 3;
            fChanged = TRUE;
        }
        else   // Not an escaped char, just a '%'
        {
            if (fChanged)
            {
                *pDest = *pScan;
            }

            pDest++;
            pScan++;
        }

        //
        // Copy all the information between this and the next escaped char
        //
        pNextScan = wcschr(pScan, L'%');

        if (fChanged)   // pScan!=pDest, so we have to copy the char's
        {
            if (!pNextScan)   // That was the last '%' in the string
            {
                memmove(pDest,
                        pScan,
                        (QueryCCH() - DIFF(pScan - QueryStr()) + 1) *
                        sizeof(WCHAR));
            }
            else
            {  
                // There is another '%', move intermediate chars
                DWORD dwLen;
                if (dwLen = DIFF(pNextScan - pScan))
                {
                    memmove(pDest,
                            pScan,
                            dwLen * sizeof(WCHAR));
                    pDest += dwLen;
                }
            }
        }

        pScan = pNextScan;
    }

    if (fChanged)
    {
        m_cchLen = wcslen(QueryStr());  // for safety recalc the length
    }

    return S_OK;
}

WCHAR * SkipWhite( 
    WCHAR * pwch 
)
{
    while ( ISWHITEW( *pwch ) )
    {
        pwch++;
    }

    return pwch;
}

WCHAR * SkipTo( 
    WCHAR * pwch, WCHAR wch 
)
{
    while ( *pwch && *pwch != L'\n' && *pwch != wch )
        pwch++;

    return pwch;
}

VOID 
WCopyToA(
    WCHAR      * wszSrc,
    CHAR       * szDest
    )
{
   while( *szDest++ = ( CHAR )( *wszSrc++ ) )
   { ; }
}

VOID 
ACopyToW(
    CHAR       * szSrc,
    WCHAR      * wszDest
    )
{
   while( *wszDest++ = ( WCHAR )( *szSrc++ ) )
   { ; }
}

WCHAR *
FlipSlashes(
    WCHAR *             pszPath
)
/*++

Routine Description:

    Simple utility to convert forward slashes to back slashes

Arguments:

    pszPath - Path to convert
    
Return Value:

    Returns pointer to original converted string

--*/
{
    WCHAR   ch;
    WCHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != L'\0' )
    {
        if( ch == L'/' )
        {
            *pszScan = L'\\';
        }

        pszScan++;
    }

    return pszPath;
}

static CHAR * s_rgchDays[] =  {
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat" };

CHAR * s_rgchMonths[] = {
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec" };

HRESULT
MakePathCanonicalizationProof(
    IN LPWSTR               pszName,
    OUT STRU*               pstrPath
    )
/*++

Routine Description:

    This functions adds a prefix
    to the string, which is "\\?\UNC\" for a UNC path, and "\\?\" for
    other paths.  This prefix tells Windows not to parse the path.

Arguments:

    IN  pszName     - The path to be converted
    OUT pstrPath    - Output path created

Return Values:

    HRESULT

--*/
{
    HRESULT hr;

    if ( pszName[ 0 ] == L'\\' && pszName[ 1 ] == L'\\' )
    {
        pszName += 2;

        if ( FAILED( hr = pstrPath->Copy( L"\\\\?\\UNC\\" ) ) )
        {
            return hr;
        }
    }
    else
    {
        if ( FAILED( hr = pstrPath->Copy( L"\\\\?\\" ) ) )
        {
            return hr;
        }
    }

    return pstrPath->Append( pszName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\timer.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Wrap-proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Functions Exported:

    InitializeSecondsTimer()
    GetCurrentTimeInSeconds()
    GetCurrentTimeInMilliseconds()

Revision History:
    MuraliK  14-Nov-1995 Made multi thread safe.
    
--*/


#include "precomp.hxx"


//
//  Timer globals
//

CRITICAL_SECTION    g_csTimerWrap;


VOID
InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INITIALIZE_CRITICAL_SECTION( &g_csTimerWrap );

} // InitializeSecondsTimer()

VOID
TerminateSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Terminate DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteCriticalSection( &g_csTimerWrap );

} // TerminateSecondsTimer()


DWORD
GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetCurrentTime();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            dwWrapTime += (0xffffffff / 1000);
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (dwCurrentTime / 1000 + dwWrapTime);
}


__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
/*++

Routine Description:

    Get current time in milliseconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetTickCount();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            ++dwWrapTime;
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (((__int64)dwWrapTime)<<32) |  dwCurrentTime;
}


//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\tracelog.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.cxx

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>
#include <pudebug.h>
#include <tracelog.h>

#define ALLOC_MEM(cb) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)LocalFree( (HLOCAL)(ptr) )



PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )
/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    DBG_ASSERT( LogSize > 0 );
    DBG_ASSERT( EntrySize > 0 );
    DBG_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    DBG_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        RtlZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;
    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/
{
        if ( Log != NULL ) {
        DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

        Log->Signature = TRACE_LOG_SIGNATURE_X;
        FREE_MEM( Log );
    }

}   // DestroyTraceLog


LONG
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )
/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    Index of entry in log.  This is useful for correlating the output
    of !inetdbg.ref to a particular point in the output debug stream

--*/
{

    PUCHAR target;
    LONG index;

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    DBG_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = InterlockedIncrement( &Log->NextEntry ) % Log->LogSize;
    target = Log->LogBuffer + ( index * Log->EntrySize );

    RtlCopyMemory(
        target,
        Entry,
        Log->EntrySize
        );

    return index;
}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )
{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    RtlZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\tokenacl.cxx ===
/*++

   Copyright    (c)    1995-2000    Microsoft Corporation

   Module  Name :
        tokenacl.cxx

   Abstract:
        This module contains routines for manipulating token ACL's

   Author:

       Wade A. Hilmo (wadeh)        05-Dec-2000

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

--*/
#include "precomp.hxx"
#include "tokenacl.hxx"
#include "irtltoken.h"

//
// Globals
//

PSID    g_pSidWpg = NULL;           // SID for worker process group
PSID    g_pSidLocalSystem = NULL;   // SID for local system account

//
// Local functions
//

HRESULT
ExpandAcl(
    PACL paclOld,
    ULONG cbAclOld,
    PACL *ppAclNew,
    PSID psid
    );

HRESULT
AddSidToTokenAcl(
    HANDLE hToken,
    PSID pSid,
    ACCESS_MASK amDesiredAccess
    );

//
// Implementations
//

HRESULT
InitializeTokenAcl(
    VOID
    )
/*++

Routine Description:

    Initializes this module by getting the SIDs for the worker
    process group and the local system account.

Arguments:

    None
  
Return Value:

    HRESULT

--*/
{
    SID_IDENTIFIER_AUTHORITY sidWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY sidNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL                     fResult;
    HRESULT                  hr = NO_ERROR;

    //
    // BUGBUG - We are currently getting the SID for the EVERYONE
    // group instead of the worker process group.  This is temporary
    // until the functionality and implementation of the worker
    // process group is implemented and stable.
    //

    fResult = AllocateAndInitializeSid(
        &sidWorldAuthority,    // pIdentifierAuthority
        1,                     // nSubAuthorityCount
        SECURITY_WORLD_RID,    // nSubAuthority0
        0,                     // nSubAuthority1
        0,                     // nSubAuthority2
        0,                     // nSubAuthority3
        0,                     // nSubAuthority4
        0,                     // nSubAuthority5
        0,                     // nSubAuthority6
        0,                     // nSubAuthority7
        &g_pSidWpg             // pSid
        );

    if( !fResult )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto LExit;
    }

    //
    // Get the Local System SID
    //

    fResult = AllocateAndInitializeSid(
        &sidNtAuthority,           // pIdentifierAuthority
        1,                         // nSubAuthorityCount
        SECURITY_LOCAL_SYSTEM_RID, // nSubAuthority0
        0,                         // nSubAuthority1
        0,                         // nSubAuthority2
        0,                         // nSubAuthority3
        0,                         // nSubAuthority4
        0,                         // nSubAuthority5
        0,                         // nSubAuthority6
        0,                         // nSubAuthority7
        &g_pSidLocalSystem         // pSid
        );

    if ( !fResult )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto LExit;
    }

    return NO_ERROR;

LExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( g_pSidWpg )
    {
        FreeSid( g_pSidWpg );
        g_pSidWpg = NULL;
    }

    if ( g_pSidLocalSystem )
    {
        FreeSid( g_pSidLocalSystem );
        g_pSidLocalSystem = NULL;
    }

    return hr;
}

VOID
UninitializeTokenAcl(
    VOID
    )
/*++

Routine Description:

    Uninitializes this module by getting freeing the global SIDs.

Arguments:

    None
  
Return Value:

    HRESULT

--*/
{
    if ( g_pSidWpg )
    {
        FreeSid( g_pSidWpg );
        g_pSidWpg = NULL;
    }

    if ( g_pSidLocalSystem )
    {
        FreeSid( g_pSidLocalSystem );
        g_pSidLocalSystem = NULL;
    }
}

HRESULT
WINAPI
GrantWpgAccessToToken(
    HANDLE  hToken
    )
/*++

Routine Description:

    Grant the worker process group access to the specified token.  This
    is particularly necessary for tokens that get duplicated for OOP
    ISAPI calls so that they can do a GetThreadToken call in the remote
    process.

Arguments:

    hToken - The handle to which the WPG should be added
  
Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( g_pSidWpg );
        
    hr = AddSidToTokenAcl(
        hToken,
        g_pSidWpg,
        TOKEN_ALL_ACCESS
        );

    DBG_ASSERT( SUCCEEDED( hr ) );

    return(hr);
}

HRESULT
WINAPI
AddWpgToTokenDefaultDacl(
    HANDLE  hToken
    )
/*++

Routine Description:

    Adds the worker process group and local system to the default
    DACL of the specified token.  This is particularly necessary in
    the case of OOP ISAPI requests, since any objects created in
    the remote process with a default DACL will get an ACL derived
    from this token's default DACL.  It's a good thing when the OOP
    process can access the objects it creates - especially when those
    objects are threads.

    Note that we will also add the local system account to the
    default DACL.

Arguments:

    hToken - The handle to be modified
  
Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;
    DWORD       cbTokenUserBuffer = 0;
    LPVOID      pvTokenUserBuffer = NULL;
    DWORD       cbNewAcl = 0;
    PACL        pNewAcl = NULL;

    DBG_ASSERT( g_pSidWpg );
    DBG_ASSERT( g_pSidLocalSystem );

    do
    {
        BOOL    bRet;

        //
        // Get the User SID from the token
        //

        // Get buffer size
        bRet = GetTokenInformation(  hToken,
                                     TokenUser,
                                     NULL,
                                     0,
                                     &cbTokenUserBuffer
                                     );
        DBG_ASSERT( bRet == FALSE );

        pvTokenUserBuffer = LocalAlloc( LPTR, cbTokenUserBuffer );
        if( !pvTokenUserBuffer )
        {
            DBG_ASSERT( pvTokenUserBuffer );
            hr = E_OUTOFMEMORY;
            break;
        }

        // Get TokenUser
        bRet = GetTokenInformation(  hToken,
                                     TokenUser,
                                     pvTokenUserBuffer,
                                     cbTokenUserBuffer,
                                     &cbTokenUserBuffer
                                     );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        PSID pSidUser = ((TOKEN_USER *)pvTokenUserBuffer)->User.Sid;
        
        DBG_ASSERT( pSidUser );

        //
        // Allocate and init our new ACL
        //
        cbNewAcl = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSidUser) - sizeof(DWORD) +
                   sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(g_pSidLocalSystem) - sizeof(DWORD) +
                   sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(g_pSidWpg) - sizeof(DWORD);

        pNewAcl = (PACL)LocalAlloc( LPTR, cbNewAcl );
        if( !pNewAcl )
        {
            DBG_ASSERT( pNewAcl );
            hr = E_OUTOFMEMORY;
            break;
        }

        bRet = InitializeAcl( pNewAcl, cbNewAcl, ACL_REVISION );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        //
        // Add the aces
        //
        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    pSidUser
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    g_pSidLocalSystem
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    g_pSidWpg
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        // Blast the new DACL into our token
        TOKEN_DEFAULT_DACL tddNew;
        tddNew.DefaultDacl = pNewAcl;

        bRet = SetTokenInformation( hToken,
                                    TokenDefaultDacl,
                                    &tddNew,
                                    cbNewAcl
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

    }while(FALSE);

    if( pvTokenUserBuffer )
    {
        LocalFree( pvTokenUserBuffer );
    }
    if( pNewAcl )
    {
        LocalFree( pNewAcl );
    }

    DBG_ASSERT( SUCCEEDED(hr) );
    return hr;
}

HRESULT
AddSidToTokenAcl(
    HANDLE      hToken,
    PSID        pSid,
    ACCESS_MASK amDesiredAccess
)
/*++

Routine Description:

    Adds the specified SID to the specified TOKEN's ACL

Arguments:

    hToken          - The handle to be modified
    pSid            - The SID to add
    amDesiredAccess - The access mask for the SID
  
Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    DWORD err;
    PSECURITY_DESCRIPTOR psdRelative = NULL;
    SECURITY_DESCRIPTOR sdAbsolute;
    ULONG cbSdPost;
    PACL pDacl = NULL;
    PACL pDaclNew = NULL;
    ULONG cbSD;
    ULONG cbDacl;
    ULONG cbSacl;
    ULONG cbOwner;
    ULONG cbGroup;
    ACL_SIZE_INFORMATION AclSize;

    //
    // Get the SD of the token.
    // Call this twice; once to get the size, then again to get the info
    //
    GetKernelObjectSecurity(hToken,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            0,
                            &cbSD);

    psdRelative = (PSECURITY_DESCRIPTOR) new BYTE[cbSD];
    if (psdRelative == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    if (!GetKernelObjectSecurity(hToken,
                                 DACL_SECURITY_INFORMATION,
                                 psdRelative,
                                 cbSD,
                                 &cbSD))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    //
    // Allocate a new Dacl
    //
    pDacl = (PACL) new BYTE[cbSD];
    if (pDacl == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    //
    // Make an absolute SD from the relative SD we have, and get the Dacl at the same time
    //
    cbSdPost = sizeof(sdAbsolute);
    cbDacl = cbSD;
    cbSacl = 0;
    cbOwner = 0;
    cbGroup = 0;
    if (!MakeAbsoluteSD(psdRelative,
                        &sdAbsolute,
                        &cbSdPost,
                        pDacl,
                        &cbDacl,
                        NULL,
                        &cbSacl,
                        NULL,
                        &cbOwner,
                        NULL,
                        &cbGroup))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    //
    // Copy ACEs over
    //
    hr = ExpandAcl(pDacl, cbSD, &pDaclNew, pSid);
    if (FAILED(hr))
    {
        goto LExit;
    }
    
    //
    // Add ACE to allow access
    //
    if (!AddAccessAllowedAce(pDaclNew, ACL_REVISION, amDesiredAccess, pSid))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    //
    // Set the new DACL in the SD
    //
    if (!SetSecurityDescriptorDacl(&sdAbsolute, TRUE, pDaclNew, FALSE))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

    //
    // Set the new SD on the token object
    //
    if (!SetKernelObjectSecurity(hToken, DACL_SECURITY_INFORMATION, &sdAbsolute))
    {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
    }

LExit:
    delete []pDacl;
    delete pDaclNew;
    delete []psdRelative;

    return hr;
}

HRESULT
ExpandAcl(
    PACL    paclOld,
    ULONG   cbAclOld,
    PACL *  ppAclNew,
    PSID    psid
)
/*++

Routine Description:

  Expands ACL so that there is room for an additional ACE

Arguments:

    paclOld  - The old ACL to expand
    cbAclOld - The size of the old ACL
    ppAclNew - The newly expanded ACL
    pSid     - The SID to use
  
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    DWORD                   err;
    PACL                    pAclNew = NULL;
    ACL_SIZE_INFORMATION    asi;
    int                     dwAclSize;
    DWORD                   iAce;
    LPVOID                  pAce;

    DBG_ASSERT(paclOld != NULL);
    DBG_ASSERT(ppAclNew != NULL);
    
    //
    // Create a new ACL to play with
    //
    if (!GetAclInformation (paclOld, (LPVOID) &asi, (DWORD) sizeof (asi), AclSizeInformation))
    {
        goto LExit;
    }

    dwAclSize = cbAclOld + GetLengthSid(psid) + (8 * sizeof(DWORD));

    pAclNew = (PACL) new BYTE[dwAclSize];
    if (pAclNew == NULL)
    {
        return(E_OUTOFMEMORY);
    }
        
    if (!InitializeAcl(pAclNew, dwAclSize, ACL_REVISION))
    {
        goto LExit;
    }

    //
    // Copy all of the ACEs to the new ACL
    //
    for (iAce = 0; iAce < asi.AceCount; iAce++)
    {
        //
        // Get the ACE and header info
        //
        if (!GetAce(paclOld, iAce, &pAce))
        {
            goto LExit;
        }

        //
        // Add the ACE to the new list
        //
        if (!AddAce(pAclNew, ACL_REVISION, iAce, pAce, ((ACE_HEADER *)pAce)->AceSize))
        {
            goto LExit;
        }
    }

    *ppAclNew = pAclNew;
    return(NOERROR);
    
LExit:
    if (pAclNew != NULL)
    {
        delete []pAclNew;
    }
    
    DBG_ASSERT(FALSE);

    err = GetLastError();
    hr = HRESULT_FROM_WIN32(err);
    return hr;
}

BOOL 
DupTokenWithSameImpersonationLevel
( 
    HANDLE     hExistingToken,
    DWORD      dwDesiredAccess,
    TOKEN_TYPE TokenType,
    PHANDLE    phNewToken
)
/*++
Routine Description:

    Duplicate an impersionation token using the same ImpersonationLevel.
    
Arguments:

    hExistingToken - a handle to a valid impersionation token
    dwDesiredAccess - the access level to the new token (see DuplicateTokenEx)
    phNewToken - ptr to the new token handle, client must CloseHandle.

Return Value:

    Return value of DuplicateTokenEx
   
--*/
{
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD                        dwBytesReturned;

    if( !GetTokenInformation( hExistingToken,
                              TokenImpersonationLevel,
                              &ImpersonationLevel,
                              sizeof(ImpersonationLevel),
                              &dwBytesReturned
                              ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetTokenInformation - failed to get TokenImpersonationLevel "
                    "LastError=%d, using SecurityImpersonation\n",
                    GetLastError()
                    ));
        
        ImpersonationLevel = SecurityImpersonation;
    }

    return DuplicateTokenEx( hExistingToken,
                             dwDesiredAccess,
                             NULL,
                             ImpersonationLevel,
                             TokenType,
                             phNewToken
                             );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\useracl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2000                **/
/**********************************************************************/

/*
    useracl.cxx

        Declarations for some functions to add permissions to windowstations/
        desktops
*/

#include "precomp.hxx"
#include <useracl.h>

#define WINSTA_ALL (WINSTA_ACCESSCLIPBOARD|WINSTA_ACCESSGLOBALATOMS|WINSTA_CREATEDESKTOP|WINSTA_ENUMDESKTOPS|WINSTA_ENUMERATE|WINSTA_EXITWINDOWS|WINSTA_READATTRIBUTES|WINSTA_READSCREEN|WINSTA_WRITEATTRIBUTES|DELETE|READ_CONTROL| WRITE_DAC|WRITE_OWNER)

#define DESKTOP_ALL (DESKTOP_CREATEMENU|DESKTOP_CREATEWINDOW|DESKTOP_ENUMERATE|DESKTOP_HOOKCONTROL|DESKTOP_JOURNALPLAYBACK|DESKTOP_JOURNALRECORD|DESKTOP_READOBJECTS|DESKTOP_WRITEOBJECTS|DELETE|READ_CONTROL|WRITE_DAC|WRITE_OWNER)

#define GENERIC_ACCESS (GENERIC_READ | GENERIC_WRITE |GENERIC_EXECUTE | GENERIC_ALL)


BOOL AddTheAceWindowStation(HWINSTA hwinsta, PSID psid)
{

    ACCESS_ALLOWED_ACE   *pace     = NULL;
    ACL_SIZE_INFORMATION aclSizeInfo;
    BOOL                 bDaclExist;
    BOOL                 bDaclPresent;
    BOOL                 bSuccess  = FALSE; // assume function will
                                            //fail
    DWORD                dwNewAclSize;
    DWORD                dwSidSize = 0;
    DWORD                dwSdSizeNeeded;
    PACL                 pacl;
    PACL                 pNewAcl   = NULL;
    PSECURITY_DESCRIPTOR psd       = NULL;
    PSECURITY_DESCRIPTOR psdNew    = NULL;
    PVOID                pTempAce;
    SECURITY_INFORMATION si        = DACL_SECURITY_INFORMATION;
    unsigned int         i;

    __try
    {
        // 
        // obtain the dacl for the windowstation
        // 
        if (!GetUserObjectSecurity(
                    hwinsta,
                    &si,
                    psd,
                    dwSidSize,
                    &dwSdSizeNeeded
                    ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
                            GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSdSizeNeeded
                            );
                if (psd == NULL)
                {
                    __leave;
                }

                psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
                            GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSdSizeNeeded
                            );
                if (psdNew == NULL)
                {
                    __leave;
                }

                dwSidSize = dwSdSizeNeeded;

                if (!GetUserObjectSecurity(
                        hwinsta,
                        &si,
                        psd,
                        dwSidSize,
                        &dwSdSizeNeeded
                        ))
                {
                    __leave;
                }
            }
            else
            {
               __leave;
            }
        }
        else
        {
            SetLastError ( ERROR_CAN_NOT_COMPLETE );

            // This should not happen, because if it does this means
            // that we were able to get the User Object without any space.
            __leave;
        }

        // 
        // create a new dacl
        // 
        if (!InitializeSecurityDescriptor(
              psdNew,
              SECURITY_DESCRIPTOR_REVISION
              ))
        {
            __leave;
        }

        // 
        // get dacl from the security descriptor
        // 
        if (!GetSecurityDescriptorDacl(
                psd,
                &bDaclPresent,
                &pacl,
                &bDaclExist
                ))
        {
            __leave;
        }

        // 
        // initialize
        // 
        ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
        aclSizeInfo.AclBytesInUse = sizeof(ACL);

        // 
        // call only if the dacl is not NULL
        // 
        if (pacl != NULL)
        {
            // get the file ACL size info
            if (!GetAclInformation(
                    pacl,
                    (LPVOID)&aclSizeInfo,
                    sizeof(ACL_SIZE_INFORMATION),
                    AclSizeInformation
                    ))
            {
                __leave;
            }
        }

        // 
        // compute the size of the new acl
        // 
        dwNewAclSize = aclSizeInfo.AclBytesInUse + (2 *
            sizeof(ACCESS_ALLOWED_ACE)) + (2 * GetLengthSid(psid)) - (2 *
            sizeof(DWORD));

        //
        // allocate memory for the new acl
        // 
        pNewAcl = (PACL)HeapAlloc(
                    GetProcessHeap(),
                    HEAP_ZERO_MEMORY,
                    dwNewAclSize
                    );
        if (pNewAcl == NULL)
        {
            __leave;
        }

        // 
        // initialize the new dacl
        // 
        if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
        {
            __leave;
        }

        // 
        // if DACL is present, copy it to a new DACL
        // 
        if (bDaclPresent) // only copy if DACL was present
        {
            // copy the ACEs to our new ACL
            if (aclSizeInfo.AceCount)
            {
                for (i=0; i < aclSizeInfo.AceCount; i++)
                {
                    // get an ACE
                    if (!GetAce(pacl, i, &pTempAce))
                    {
                        __leave;
                    }

                    DBG_ASSERT(pTempAce != NULL);

                    // If it is the SID we are trying to add, no need to
                    // do anything more
                    if (((ACE_HEADER *)pTempAce)->AceType == ACCESS_ALLOWED_ACE_TYPE &&
                        EqualSid(&((ACCESS_ALLOWED_ACE *)pTempAce)->SidStart, psid))
                    {
                        bSuccess = TRUE;
                        __leave;
                    }

                    // add the ACE to the new ACL
                    if (!AddAce(
                            pNewAcl,
                            ACL_REVISION,
                            INFINITE,
                            pTempAce,
                            ((PACE_HEADER)pTempAce)->AceSize
                            ))
                    {
                        __leave;
                    }
                }
            }
        }

        // 
        // add the first ACE to the windowstation
        // 
        pace = (ACCESS_ALLOWED_ACE *)HeapAlloc(
                    GetProcessHeap(),
                    HEAP_ZERO_MEMORY,
                    sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid) -
                        sizeof(DWORD
                    ));
        if (pace == NULL)
        {
            __leave;
        }

        pace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
        pace->Header.AceFlags = CONTAINER_INHERIT_ACE |
                                INHERIT_ONLY_ACE      |
                                OBJECT_INHERIT_ACE;
        pace->Header.AceSize  = (USHORT)(sizeof(ACCESS_ALLOWED_ACE) +
                                         GetLengthSid(psid) - sizeof(DWORD));
        pace->Mask            = GENERIC_ACCESS;

        if (!CopySid(GetLengthSid(psid), &pace->SidStart, psid))
        {
            __leave;
        }

        if (!AddAce(
                pNewAcl,
                ACL_REVISION,
                INFINITE,
                (LPVOID)pace,
                pace->Header.AceSize
                ))
        {
            __leave;
        }

        // 
        // add the second ACE to the windowstation
        // 
        pace->Header.AceFlags = NO_PROPAGATE_INHERIT_ACE;
        pace->Mask            = WINSTA_ALL;

        if (!AddAce(
                pNewAcl,
                ACL_REVISION,
                INFINITE,
                (LPVOID)pace,
                pace->Header.AceSize
                ))
        {
            __leave;
        }

        // 
        // set new dacl for the security descriptor
        // 
        if (!SetSecurityDescriptorDacl(
                   psdNew,
                   TRUE,
                   pNewAcl,
                   FALSE
                   ))
        {
            __leave;
        }

        // 
        // set the new security descriptor for the windowstation
        // 
        if (!SetUserObjectSecurity(
                    hwinsta,
                    &si,
                    psdNew))
        {
            __leave;
        }

        // 
        // indicate success
        // 
        bSuccess = TRUE;
    }
    __finally
    {
        // 
        // free the allocated buffers
        // 
        if (pace != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)pace);
        }

        if (pNewAcl != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)pNewAcl);
        }

        if (psd != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psd);
        }

        if (psdNew != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psdNew);
        }
    }

    return bSuccess;
}

BOOL AddTheAceDesktop(HDESK hdesk, PSID psid)
{

    ACL_SIZE_INFORMATION aclSizeInfo;
    BOOL                 bDaclExist;
    BOOL                 bDaclPresent;
    BOOL                 bSuccess  = FALSE; // assume function will
                                            // fail
    DWORD                dwNewAclSize;
    DWORD                dwSidSize = 0;
    DWORD                dwSdSizeNeeded;
    PACL                 pacl;
    PACL                 pNewAcl   = NULL;
    PSECURITY_DESCRIPTOR psd       = NULL;
    PSECURITY_DESCRIPTOR psdNew    = NULL;
    PVOID                pTempAce;
    SECURITY_INFORMATION si        = DACL_SECURITY_INFORMATION;
    unsigned int         i;

    __try
    {
        // 
        // obtain the security descriptor for the desktop object
        // 
        if (!GetUserObjectSecurity(
                hdesk,
                &si,
                psd,
                dwSidSize,
                &dwSdSizeNeeded
                ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
                            GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSdSizeNeeded
                            );
                if (psd == NULL)
                {
                    __leave;
                }

                psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
                                GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                dwSdSizeNeeded
                                );
                if (psdNew == NULL)
                {
                    __leave;
                }

                dwSidSize = dwSdSizeNeeded;

                if (!GetUserObjectSecurity(
                            hdesk,
                            &si,
                            psd,
                            dwSidSize,
                            &dwSdSizeNeeded
                            ))
                {
                    __leave;
                }
            }
            else
            {
                __leave;
            }
        }
        else
        {
            SetLastError ( ERROR_CAN_NOT_COMPLETE );

            // This should not happen, because if it does this means
            // that we were able to get the User Object without any space.
            __leave;
        }

        // 
        // create a new security descriptor
        // 
        if (!InitializeSecurityDescriptor(
                    psdNew,
                    SECURITY_DESCRIPTOR_REVISION
                    ))
        {
            __leave;
        }

        // 
        // obtain the dacl from the security descriptor
        // 
        if (!GetSecurityDescriptorDacl(
                    psd,
                    &bDaclPresent,
                    &pacl,
                    &bDaclExist
                    ))
        {
            __leave;
        }

        // 
        // initialize
        // 
        ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
        aclSizeInfo.AclBytesInUse = sizeof(ACL);

        // 
        // call only if NULL dacl
        // 
        if (pacl != NULL)
        {
            // 
            // determine the size of the ACL info
            // 
            if (!GetAclInformation(
                    pacl,
                    (LPVOID)&aclSizeInfo,
                    sizeof(ACL_SIZE_INFORMATION),
                    AclSizeInformation
                    ))
            {
                __leave;
            }
        }

        // 
        // compute the size of the new acl
        // 
        dwNewAclSize = aclSizeInfo.AclBytesInUse +
                        sizeof(ACCESS_ALLOWED_ACE) +
                        GetLengthSid(psid) - sizeof(DWORD);

        // 
        // allocate buffer for the new acl
        // 
        pNewAcl = (PACL)HeapAlloc(
                        GetProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        dwNewAclSize
                        );
        if (pNewAcl == NULL)
        {
            __leave;
        }

        // 
        // initialize the new acl
        // 
        if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
        {
            __leave;
        }

        // 
        // if DACL is present, copy it to a new DACL
        // 
        if (bDaclPresent) // only copy if DACL was present
        {
            // copy the ACEs to our new ACL
            if (aclSizeInfo.AceCount)
            {
                for (i=0; i < aclSizeInfo.AceCount; i++)
                {
                     // get an ACE
                    if (!GetAce(pacl, i, &pTempAce))
                    {
                        __leave;
                    }

                    DBG_ASSERT(pTempAce != NULL);

                    // If it is the SID we are trying to add, no need to
                    // do anything more
                    if (((ACE_HEADER *)pTempAce)->AceType == ACCESS_ALLOWED_ACE_TYPE &&
                        EqualSid(&((ACCESS_ALLOWED_ACE *)pTempAce)->SidStart, psid))
                    {
                        bSuccess = TRUE;
                        __leave;
                    }

                    // add the ACE to the new ACL
                    if (!AddAce(
                            pNewAcl,
                            ACL_REVISION,
                            INFINITE,
                            pTempAce,
                            ((PACE_HEADER)pTempAce)->AceSize
                            ))
                    {
                        __leave;
                    }
                }
            }
        }

        // 
        // add ace to the dacl
        // 
        if (!AddAccessAllowedAce(
                pNewAcl,
                ACL_REVISION,
                DESKTOP_ALL,
                psid
                ))
        {
            __leave;
        }

        // 
        // set new dacl to the new security descriptor
        // 
        if (!SetSecurityDescriptorDacl(
                    psdNew,
                    TRUE,
                    pNewAcl,
                    FALSE
                    ))
        {
            __leave;
        }

        // 
        // set the new security descriptor for the desktop object
        // 
        if (!SetUserObjectSecurity(hdesk, &si, psdNew))
        {
            __leave;
        }

        // 
        // indicate success
        // 
        bSuccess = TRUE;
    }
    __finally
    {
        // 
        // free buffers
        // 
        if (pNewAcl != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)pNewAcl);
        }

        if (psd != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psd);
        }

        if (psdNew != NULL)
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)psdNew);
        }
    }

    return bSuccess;
} 


/*
BOOL ObtainSid(HANDLE hToken, PSID *ppsid)
{
    BOOL                    bSuccess = FALSE; // assume function will
                                              // fail
    DWORD                   dwIndex;
    DWORD                   dwLength = 0;
    TOKEN_INFORMATION_CLASS tic      = TokenGroups;
    PTOKEN_GROUPS           ptg      = NULL;

    __try
    {
        // 
        // determine the size of the buffer
        // 

        if (!GetTokenInformation(
                hToken,
                tic,
                (LPVOID)ptg,
                0,
                &dwLength
                ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                ptg = (PTOKEN_GROUPS)HeapAlloc(
                        GetProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        dwLength
                        );

                if (ptg == NULL)
                {
                    __leave;
                }
            }
            else
            {
                __leave;
            }
        }

        // 
        // obtain the groups the access token belongs to
        // 
        if (!GetTokenInformation(
                hToken,
                tic,
                (LPVOID)ptg,
                dwLength,
                &dwLength
                ))
        {
            __leave;
        }

        // 
        // determine which group is the logon sid
        // 
        for (dwIndex = 0; dwIndex < ptg->GroupCount; dwIndex++)
        {
            if ((ptg->Groups[dwIndex].Attributes & SE_GROUP_LOGON_ID)
                   ==  SE_GROUP_LOGON_ID)
            {
                // 
                // determine the length of the sid
                // 
                dwLength = GetLengthSid(ptg->Groups[dwIndex].Sid);

                // 
                // allocate a buffer for the logon sid
                // 
                *ppsid = (PSID)HeapAlloc(
                            GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwLength
                            );
                if (*ppsid == NULL)
                {
                    __leave;
                }

                //
                // obtain a copy of the logon sid
                // 
                if (!CopySid(dwLength, *ppsid, ptg->Groups[dwIndex].Sid))
                {
                    __leave;
                }

                //
                // break out of the loop since the logon sid has been
                // found
                // 
                break;
            }
        }

        // 
        // indicate success
        // 
        bSuccess = TRUE;
    }
    __finally
    {
        // 
        // free the buffer for the token group
        // 
        if (ptg != NULL)
        {
              HeapFree(GetProcessHeap(), 0, (LPVOID)ptg);
        }
    }

    return bSuccess;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\stringau.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997-1999           **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class for storing 
    and operating on UNICODE and ANSI strings

    FILE HISTORY:
    4/8/97      michth      created

*/

#include "precomp.hxx"
#include "stringau.hxx"
#include "dbgutil.h"



VOID
STRAU::AuxInit( LPCSTR pInit )
{
    BOOL fRet;

    if ( pInit && (*pInit != '\0') )
    {
        INT cbCopy = (::strlen( pInit ) + 1) * sizeof(CHAR);
        fRet = m_bufAnsi.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufAnsi.QueryPtr(), pInit, cbCopy );
            m_cbMultiByteLen = (cbCopy)/sizeof(CHAR) - 1;
            m_bUnicode = FALSE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // STRAU::AuxInit()


VOID
STRAU::AuxInit( LPCWSTR pInit )
{
    BOOL fRet;

    if ( pInit && (*pInit != (WCHAR)'\0'))
    {
        INT cbCopy = (::wcslen( pInit) + 1) * sizeof(WCHAR);
        fRet = m_bufUnicode.Resize( cbCopy );

        if ( fRet ) {
            CopyMemory( m_bufUnicode.QueryPtr(), pInit, cbCopy );
            m_cchUnicodeLen = (cbCopy)/sizeof(WCHAR) - 1;
            m_bUnicode = TRUE;
            m_bInSync = FALSE;
        } else {
            m_bIsValid = FALSE;
        }

    } else {
        Reset();
    }

    return;
} // STRAU::AuxInit()


/*******************************************************************

    NAME:       STRAU::AuxAppend

    SYNOPSIS:   Appends the string onto this one.

    ENTRY:      Object to append
********************************************************************/


BOOL STRAU::AuxAppend( LPCSTR pStr, UINT cbStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    BOOL bReturn = m_bIsValid;

    if (m_bIsValid) {
        if (!m_bUnicode || (m_cchUnicodeLen == 0)) {
            //
            // Just append the ANSI string
            //
            //
            //  Only resize when we have to.  When we do resize, we tack on
            //  some extra space to avoid extra reallocations.
            //
            //  Note: QuerySize returns the requested size of the string buffer,
            //        *not* the strlen of the buffer
            //

            if ( m_bufAnsi.QuerySize() < ((m_cbMultiByteLen + cbStr + 1) * sizeof(CHAR)) )
            {
                bReturn = m_bufAnsi.Resize( ((m_cbMultiByteLen + cbStr + 1) * sizeof(CHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
            }

            if (bReturn) {
                // copy the exact string and append a null character
                memcpy( (BYTE *) (((LPSTR)m_bufAnsi.QueryPtr()) + m_cbMultiByteLen),
                        pStr,
                        cbStr * sizeof(char));
                m_cbMultiByteLen += cbStr;
                *((CHAR *) m_bufAnsi.QueryPtr() + m_cbMultiByteLen) = '\0';  // append an explicit null char
                m_bUnicode = FALSE;
                m_bInSync = FALSE;
            }
            else {
                m_bIsValid = FALSE;
            }
        }
        else {
            //
            // Currently have a UNICODE string
            // Need to convert to UNICODE and copy
            // Use the ANSI buffer as temporary space
            //
            int iUnicodeLen = ConvertMultiByteToUnicode((LPSTR)pStr, &m_bufAnsi, cbStr);
            if (STR_CONVERSION_SUCCEEDED(iUnicodeLen)) {
                if ( m_bufUnicode.QuerySize() < ((m_cchUnicodeLen + iUnicodeLen + 1) * sizeof(WCHAR)) )
                {
                    bReturn = m_bufUnicode.Resize( ((m_cchUnicodeLen + iUnicodeLen + 1) * sizeof(WCHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
                }

                if (bReturn) {
                    // copy the exact string and append a null character
                    memcpy( (BYTE *) ((LPWSTR)(m_bufUnicode.QueryPtr()) + m_cchUnicodeLen),
                            m_bufAnsi.QueryPtr(),
                            (iUnicodeLen * sizeof(WCHAR)));
                    m_cchUnicodeLen += iUnicodeLen;
                    *((LPWSTR)m_bufUnicode.QueryPtr() + m_cchUnicodeLen) = (WCHAR)'\0';  // append an explicit null char
                    m_bInSync = FALSE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                m_bIsValid = FALSE;
            }
        }
    }
    return bReturn;
} // STRAU::AuxAppend()


BOOL STRAU::AuxAppend( LPCWSTR pStr, UINT cchStr, BOOL fAddSlop )
{
    DBG_ASSERT( pStr != NULL );

    BOOL bReturn = m_bIsValid;
    int iUnicodeLen;

    if (m_bIsValid) {
        if (!m_bUnicode && !m_bInSync && (m_cbMultiByteLen != 0)) {

            // Currently have an ANSI string
            // Need to convert ANSI string to UNICODE before copy
            //
            iUnicodeLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen);
            if (STR_CONVERSION_SUCCEEDED(iUnicodeLen)) {
                m_cchUnicodeLen = iUnicodeLen;
            }
            else {
                bReturn = FALSE;
                m_bIsValid = FALSE;
            }
        }
        if (bReturn) {
            //
            //  Only resize when we have to.  When we do resize, we tack on
            //  some extra space to avoid extra reallocations.
            //
            //  Note: QuerySize returns the requested size of the string buffer,
            //        *not* the strlen of the buffer
            //
            if ( m_bufUnicode.QuerySize() < ((m_cchUnicodeLen + cchStr + 1) * sizeof(WCHAR)) )
            {
                bReturn = m_bufUnicode.Resize( ((m_cchUnicodeLen + cchStr + 1) * sizeof(WCHAR)) + ((fAddSlop) ? STR_SLOP : 0) );
            }

            if (bReturn) {
                // copy the exact string and append a null character
                memcpy( (BYTE *) (((LPWSTR)m_bufUnicode.QueryPtr()) + m_cchUnicodeLen),
                        pStr,
                        (cchStr * sizeof(WCHAR)));
                m_cchUnicodeLen += cchStr;
                *((LPWSTR)m_bufUnicode.QueryPtr() + m_cchUnicodeLen) = (WCHAR)'\0';  // append an explicit null char
                m_bInSync = FALSE;
                m_bUnicode = TRUE;
            }
            else {
                m_bIsValid = FALSE;
            }
        }
    }
    return bReturn;
} // STRAU::AuxAppend()


BOOL
STRAU::SetLen( IN DWORD cchLen)
{
    BOOL bReturn = FALSE;
    if (cchLen <= QueryCCH()) {
        if (m_bUnicode || m_bInSync) {
            *((LPWSTR)m_bufUnicode.QueryPtr() + cchLen) = (WCHAR)'\0';
            m_cchUnicodeLen = cchLen;
        }
        if (!m_bUnicode || m_bInSync) {
            LPSTR pszTerminateByte = (LPSTR)m_bufAnsi.QueryPtr();
            WORD wPrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());
            if (wPrimaryLangID == LANG_JAPANESE ||
                wPrimaryLangID == LANG_CHINESE  ||
                wPrimaryLangID == LANG_KOREAN)
            {
                char *pszTop = pszTerminateByte;
                for (DWORD i = 0; i < QueryCCH(); i++) {
                    pszTerminateByte = CharNextExA(CP_ACP,
                                                   pszTerminateByte,
                                                   0);
                }
                m_cbMultiByteLen = DIFF(pszTerminateByte - pszTop);
            }
            else
            {
                pszTerminateByte += cchLen;
                m_cbMultiByteLen = cchLen;
            }
            *pszTerminateByte = '\0';
        }
        bReturn = TRUE;
    }

    return bReturn;
}


LPTSTR
STRAU::QueryStr(BOOL bUnicode)
{

    //
    // This can fail. Return a null string for either UNICODE or ANSI
    // So that clients expecting a valid pointer actually get one.
    //
    LPTSTR pszReturn = NULL;
    int iNewStrLen;

    if (m_bIsValid) {
        if ((bUnicode != m_bUnicode) && (!m_bInSync)) {
            //
            // Need to Convert First
            //
            if (bUnicode) {
                //
                // Convert current string to UNICODE
                //
                iNewStrLen = ConvertMultiByteToUnicode((LPSTR)m_bufAnsi.QueryPtr(), &m_bufUnicode, m_cbMultiByteLen);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cchUnicodeLen = iNewStrLen;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
            else {
                //
                // Convert current string to Ansi
                //
                iNewStrLen = ConvertUnicodeToMultiByte((LPWSTR)m_bufUnicode.QueryPtr(), &m_bufAnsi, m_cchUnicodeLen);
                if (STR_CONVERSION_SUCCEEDED(iNewStrLen)) {
                    m_cbMultiByteLen = iNewStrLen;
                    m_bInSync = TRUE;
                }
                else {
                    m_bIsValid = FALSE;
                }
            }
        }

        if (m_bIsValid) {
            if (bUnicode) {
                pszReturn = (LPTSTR)m_bufUnicode.QueryPtr();
            }
            else {
                pszReturn = (LPTSTR)m_bufAnsi.QueryPtr();
            }

        }
    }

    return pszReturn;
}

BOOL
STRAU::SafeCopy( LPCSTR pchInit )
{
    BOOL bReturn = TRUE;
    SaveState();
    Reset();
    if (pchInit != NULL) {
        bReturn  = AuxAppend(pchInit, ::strlen( pchInit ), FALSE );
        if (!bReturn) {
            RestoreState();
        }
    }
    return bReturn;
}


BOOL
STRAU::SafeCopy( LPCWSTR pchInit )
{
    BOOL bReturn = TRUE;
    SaveState();
    Reset();
    if (pchInit != NULL) {
        bReturn  = AuxAppend( pchInit, ::wcslen( pchInit ), FALSE );
        if (!bReturn) {
            RestoreState();
        }
    }
    return bReturn;
}




/********************************************************************++
  Functions to handle ANSI/UNICODE  conversions
--********************************************************************/
int
ConvertMultiByteToUnicode(LPCSTR pszSrcAnsiString,
                          BUFFER *pbufDstUnicodeString,
                          DWORD dwStringLen)
{
    DBG_ASSERT(pszSrcAnsiString != NULL);
    int iStrLen = -1;
    BOOL bTemp;

    bTemp = pbufDstUnicodeString->Resize((dwStringLen + 1) * sizeof(WCHAR));
    if (bTemp) {
        iStrLen = MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszSrcAnsiString,
                                      dwStringLen + 1,
                                      (LPWSTR)pbufDstUnicodeString->QueryPtr(),
                                      (int)pbufDstUnicodeString->QuerySize());
        if (iStrLen == 0) {
            DBG_ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
            iStrLen = -1;
        }
        else {
            //
            // Don't count '\0'
            //
            iStrLen--;
        }


    }
    return iStrLen;
}

int
ConvertUnicodeToCodePage(LPCWSTR pszSrcUnicodeString,
                         BUFFER *pbufDstAnsiString,
                         DWORD dwStringLen,
                         UINT uCodePage)
{
    DBG_ASSERT(NULL != pszSrcUnicodeString);
    DBG_ASSERT(NULL != pbufDstAnsiString);

    BOOL bTemp;
    int iStrLen = 0;

    iStrLen = WideCharToMultiByte(uCodePage,
                                  0,
                                  pszSrcUnicodeString,
                                  dwStringLen,
                                  (LPSTR)pbufDstAnsiString->QueryPtr(),
                                  (int)pbufDstAnsiString->QuerySize(),
                                  NULL,
                                  NULL);
    if ((iStrLen == 0) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        iStrLen = WideCharToMultiByte(uCodePage,
                                      0,
                                      pszSrcUnicodeString,
                                      dwStringLen,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);
        if (iStrLen != 0) {
            bTemp = pbufDstAnsiString->Resize(iStrLen, STR_SLOP);
            if (!bTemp) {
                iStrLen = 0;
            }
            else {
                iStrLen = WideCharToMultiByte(uCodePage,
                                              0,
                                              pszSrcUnicodeString,
                                              dwStringLen,
                                              (LPSTR)pbufDstAnsiString->QueryPtr(),
                                              (int)pbufDstAnsiString->QuerySize(),
                                              NULL,
                                              NULL);
            }

        }
    }

    if (0 != iStrLen)
    {
        // need to add terminating NULL into buffer
        pbufDstAnsiString->Resize(iStrLen + 1, STR_SLOP);
        ((CHAR*)pbufDstAnsiString->QueryPtr())[iStrLen] = '\0';
        iStrLen++;
    }

    //
    // Don't count '\0'
    // and convert 0 to -1 for errors
    //
    iStrLen--;
    return iStrLen;
}


int
ConvertUnicodeToMultiByte(LPCWSTR pszSrcUnicodeString,
                          BUFFER *pbufDstAnsiString,
                          DWORD dwStringLen)
{
    return ConvertUnicodeToCodePage(pszSrcUnicodeString,
                                    pbufDstAnsiString,
                                    dwStringLen,
                                    CP_ACP);
}

int
ConvertUnicodeToUTF8(LPCWSTR pszSrcUnicodeString,
                     BUFFER *pbufDstAnsiString,
                     DWORD dwStringLen)
{    
    return ConvertUnicodeToCodePage(pszSrcUnicodeString,
                                    pbufDstAnsiString,
                                    dwStringLen,
                                    CP_UTF8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\stringa.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    string.cxx

    This module contains a light weight string class.


    FILE HISTORY:
        Johnl       15-Aug-1994 Created
        MuraliK     27-Feb-1995 Modified to be a standalone module with buffer.
        MuraliK     2-June-1995 Made into separate library
*/

#include "precomp.hxx"


//
// Normal includes only for this module to be active
//

# include <stringa.hxx>
# include <stringau.hxx>

//
//  Private Definations
//

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
     (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

// Change a hexadecimal digit to its numerical equivalent
#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')

//
//  When appending data, this is the extra amount we request to avoid
//  reallocations
//
#define STR_SLOP        128



/***************************************************************************++

Routine Description:

    Appends to the string starting at the (byte) offset cbOffset.

Arguments:

    pStr     - An ANSI string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT STRA::AuxAppend(const BYTE * pStr,
                        ULONG        cbStr,
                        ULONG        cbOffset,
                        BOOL         fAddSlop)
{
    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );
    
    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + cbStr + sizeof(CHAR) )
    {
        UINT uNewSize = cbOffset + cbStr;

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(CHAR);
        }

        if ( !m_Buff.Resize(uNewSize) ) {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // copy the exact string and append a null character
    //
    memcpy((BYTE *)m_Buff.QueryPtr() + cbOffset,
           pStr,
           cbStr);

    //
    // set the new length
    //
    m_cchLen = cbStr + cbOffset;

    //
    // append NULL character
    //
    *(QueryStr() + m_cchLen) = '\0';

    return S_OK;
}


/***************************************************************************++

Routine Description:

    Convert and append a UNICODE string to the string starting at 
    the (byte) offset cbOffset

Arguments:

    pStr     - A UNICODE string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT STRA::AuxAppendW(const WCHAR * pStr,
                         ULONG         cchStr,
                         ULONG         cbOffset,
                         BOOL          fAddSlop)
{
    int iRet;

    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );

    if (cchStr == 0)
    {
        return S_OK;
    }

    if (cbOffset == 0)
    {
        iRet = ConvertUnicodeToMultiByte(pStr,
                                         &m_Buff,
                                         cchStr);
        if (-1 == iRet)
        {
            // could not convert
            return HRESULT_FROM_WIN32(GetLastError());
        }

        m_cchLen = iRet;
        DBG_ASSERT(strlen(QueryStr()) == m_cchLen);
        return S_OK;
    }
    else
    {
        STACK_BUFFER( buffTemp, 128);

        iRet = ConvertUnicodeToMultiByte(pStr,
                                         &buffTemp,
                                         cchStr);
        if (-1 == iRet)
        {
            // could not convert
            return HRESULT_FROM_WIN32(GetLastError());
        }

        return AuxAppend((const BYTE *)buffTemp.QueryPtr(),
                         iRet,
                         cbOffset,
                         fAddSlop);
    }
}

/***************************************************************************++

Routine Description:

    Convert and append a UNICODE string to the string starting at 
    the (byte) offset cbOffset

Arguments:

    pStr     - A UNICODE string to be appended
    cbStr    - Length, in bytes, of pStr
    cbOffset - Offset, in bytes, at which to begin the append
    fAddSlop - If we resize, should we add an extra STR_SLOP bytes.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT STRA::AuxAppendWTruncate(const WCHAR * pStr,
                                 ULONG         cchStr,
                                 ULONG         cbOffset,
                                 BOOL          fAddSlop)
{
    CHAR *pszBuffer;

    DBG_ASSERT( pStr );
    DBG_ASSERT( cbOffset <= QueryCB() );

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //
    if ( m_Buff.QuerySize() < cbOffset + cchStr + sizeof(CHAR) )
    {
        UINT uNewSize = cbOffset + cchStr;

        if (fAddSlop) {
            uNewSize += STR_SLOP;
        } else {
            uNewSize += sizeof(CHAR);
        }
        
        if ( !m_Buff.Resize(uNewSize) ) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

    }
    
    //
    // Copy/convert the UNICODE string over (by making two bytes into one)
    //
    pszBuffer = (CHAR *)((BYTE *)m_Buff.QueryPtr() + cbOffset);
    for (unsigned int i = 0; i < cchStr; i++)
    {
        pszBuffer[i] = (CHAR)pStr[i];
    }

    //
    // set the new length
    //
    m_cchLen = cchStr + cbOffset;

    //
    // append NULL character
    //
    *(QueryStr() + m_cchLen) = '\0';

    return S_OK;
}


HRESULT STRA::CopyWToUTF8Unescaped(LPCWSTR cpchStr, DWORD cch)
{
    HRESULT hr = S_OK;
    int iRet;

    if (cch == 0)
    {
        Reset();
        return S_OK;
    }

    iRet = ConvertUnicodeToUTF8(cpchStr,
                                &this->m_Buff,
                                cch);
    if (-1 == iRet)
    {
        // could not convert
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    m_cchLen = iRet;

    DBG_ASSERT(strlen(reinterpret_cast<CHAR*>(this->m_Buff.QueryPtr())) == m_cchLen);
done:
    return hr;
}

HRESULT STRA::CopyWToUTF8(LPCWSTR cpchStr, DWORD cch)
{
    HRESULT hr = S_OK;

    hr = STRA::CopyWToUTF8Unescaped(cpchStr, cch);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = STRA::Escape();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT STRA::Unescape()
/*++
  Unescape the string (URL or QueryString)
--*/
{
    CHAR   *pScan;

    //
    // First convert any +'s to spaces
    //

    for (pScan = strchr(QueryStr(), '+');
         pScan != NULL;
         pScan = strchr(pScan + 1, '+'))
    {
        *pScan = ' ';
    }

    //
    // Now take care of any escape characters
    //

    CHAR   *pDest;
    CHAR   *pNextScan;
    WCHAR   wch;
    DWORD   dwLen;
    BOOL    fChanged = FALSE;

    pDest = pScan = strchr(QueryStr(), '%');

    while (pScan)
    {
        if ((pScan[1] == 'u' || pScan[1] == 'U') &&
            SAFEIsXDigit(pScan[2]) &&
            SAFEIsXDigit(pScan[3]) &&
            SAFEIsXDigit(pScan[4]) &&
            SAFEIsXDigit(pScan[5]))
        {
            wch = TOHEX(pScan[2]) * 4096 + TOHEX(pScan[3]) * 256
                + TOHEX(pScan[4]) * 16 + TOHEX(pScan[5]);

            dwLen = WideCharToMultiByte(CP_ACP,
                                        0,
                                        &wch,
                                        1,
                                        (LPSTR) pDest,
                                        2,
                                        NULL,
                                        NULL);

            pDest += dwLen;
            pScan += 6;
            fChanged = TRUE;
        }
        else if (SAFEIsXDigit(pScan[1]) && SAFEIsXDigit(pScan[2]))
        {
            *pDest = TOHEX(pScan[1]) * 16 + TOHEX(pScan[2]);

            pDest ++;
            pScan += 3;
            fChanged = TRUE;
        }
        else   // Not an escaped char, just a '%'
        {
            if (fChanged)
            {
                *pDest = *pScan;
            }

            pDest++;
            pScan++;
        }

        //
        // Copy all the information between this and the next escaped char
        //
        pNextScan = strchr(pScan, '%');

        if (fChanged)   // pScan!=pDest, so we have to copy the char's
        {
            if (!pNextScan)   // That was the last '%' in the string
            {
                memmove(pDest,
                        pScan,
                        QueryCCH() - DIFF(pScan - QueryStr()) + 1);
            }
            else
            {  
                // There is another '%', move intermediate chars
                if (dwLen = DIFF(pNextScan - pScan))
                {
                    memmove(pDest,
                            pScan,
                            dwLen);
                    pDest += dwLen;
                }
            }
        }

        pScan = pNextScan;
    }

    if (fChanged)
    {
        m_cchLen = strlen(QueryStr());  // for safety recalc the length
    }

    return S_OK;
}

/*******************************************************************

    NAME:       STRA::Escape

    SYNOPSIS:   Replaces non-ASCII characters with their hex equivalent

    NOTES:      If no characters need to be escaped, each character is simply
                walked once and compared a few times.

                If a character must be escaped, all previous characters 
                are copied into a local temporary STRA and then all following
                characters are copied into the temporary.  At the end of the
                function the temporary STRA is copied back to this.

    HISTORY:
        Johnl   17-Aug-1994     Created
        jeffwall 1-May-2001     made somewhat efficient

********************************************************************/

HRESULT STRA::Escape( VOID )
{
    CHAR *  pch      = QueryStr();   
    int     i        = 0;
    BYTE    ch;
    HRESULT hr       = S_OK;
    BOOL    fRet;
    
    // Set to true if any % escaping occurs
    BOOL fEscapingDone = FALSE;

    // if there are any characters that need to be escaped we copy the entire string 
    // character by character into straTemp, escaping as we go, then at the end
    // copy all of straTemp over
    STRA  straTemp;

    DBG_ASSERT( pch );

    while ( ch = pch[i] )
    {
        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( ((ch <= 32) ||
              ((ch >= 128) && (ch <= 255)) ||
              (ch == '%') || 
              (ch == '?') ||
              (ch == '#')
             ) &&
             !(ch == '\n' || ch == '\r')  )
        {
            if (FALSE == fEscapingDone)
            {
                // first character in the string that needed escaping
                fEscapingDone = TRUE;

                // guess that the size needs to be larger than
                // what we used to have times two
                hr = straTemp.Resize(QueryCCH() * 2);
                if (FAILED(hr))
                {
                    return hr;
                }

                // copy all of the previous buffer into buffTemp
                hr = straTemp.Copy(this->QueryStr(), 
                                   i * sizeof(CHAR));
                if (FAILED(hr))
                {
                    return hr;
                }
            }

            // resize the temporary (if needed) with the slop of the entire buffer length
            // this fixes constant reallocation if the entire string needs to be escaped
            fRet = straTemp.m_Buff.Resize( QueryCCH() + 2 * sizeof(CHAR) + 1 * sizeof(CHAR), // current length + two hex + NULL
                                           QueryCCH());  // additional slop to allocate
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
            }

            //
            //  Create the string to append for the current character
            //
            
            CHAR chHex[3];
            chHex[0] = '%';

            //
            //  Convert the low then the high character to hex
            //

            UINT nLowDigit = (UINT)(ch % 16);
            chHex[2] = HEXDIGIT( nLowDigit );

            ch /= 16;

            UINT nHighDigit = (UINT)(ch % 16);

            chHex[1] = HEXDIGIT( nHighDigit );

            //
            // Actually append the converted character to the end of the temporary
            //
            hr = straTemp.Append(chHex, 3);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            // if no escaping done, no need to copy
            if (fEscapingDone)
            {
                // if ANY escaping done, copy current character into new buffer
                straTemp.Append(&pch[i], 1);
            }
        }

        // inspect the next character in the string
        i++;
    }

    if (fEscapingDone)
    {
        // the escaped string is now in straTemp
        hr = this->Copy(straTemp);
    }

    return hr;

} // STRA::Escape()

/*******************************************************************

    NAME:       STRA::LoadString

    SYNOPSIS:   Loads a string resource from this module's string table
                or from the system string table

    ENTRY:      dwResID - System error or module string ID
                lpszModuleName - name of the module from which to load.
                 If NULL, then load the string from system table.

********************************************************************/

HRESULT STRA::LoadString( IN DWORD   dwResID,
                          IN LPCSTR  lpszModuleName, // Optional
                          IN DWORD   dwLangID        // Optional
                        )
{
    HRESULT hr = FALSE;
    INT     cch;

    //
    //  If lpszModuleName is NULL, load the string from system's string table.
    //

    if ( lpszModuleName == NULL) {

        BYTE * pchBuff = NULL;

        //
        //  Call the appropriate function so we don't have to do the Unicode
        //  conversion
        //

        cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_IGNORE_INSERTS  |
                                FORMAT_MESSAGE_MAX_WIDTH_MASK  |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                dwResID,
                                dwLangID,
                                (LPSTR) &pchBuff,
                                1024,
                                NULL );

        if ( cch ) {

            hr = Copy( (LPCSTR) pchBuff, cch );
        }

        //
        //  Free the buffer FormatMessage allocated
        //

        if ( cch )
        {
            ::LocalFree( (VOID*) pchBuff );
        }
        
    } 
    else   
    {
        CHAR ach[STR_MAX_RES_SIZE];
        cch = ::LoadStringA( GetModuleHandleA( lpszModuleName),
                             dwResID,
                             (CHAR *) ach,
                             sizeof(ach));
        if ( cch )
        {
            hr =  Copy( (LPSTR) ach, cch );
        }
    }

    return ( hr );

} // STR::LoadString()

HRESULT STRA::LoadString( IN DWORD  dwResID,
                          IN HMODULE hModule
                         )
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( hModule != NULL );

    BOOL fReturn = FALSE;
    INT  cch;
    CHAR ach[STR_MAX_RES_SIZE];

    cch = ::LoadStringA(hModule,
                        dwResID,
                        (CHAR *) ach,
                        sizeof(ach));
    if ( cch ) {
        hr =  Copy( (LPSTR) ach, cch );
    }
    else {
      	hr =  HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return ( hr );

} // STRA::LoadString()

HRESULT
STRA::FormatString(
    IN DWORD   dwResID,
    IN LPCSTR  apszInsertParams[],
    IN LPCSTR  lpszModuleName,
    IN DWORD   cbMaxMsg
    )
{
    DWORD   cch;
    LPSTR   pchBuff;
    HRESULT hr = E_FAIL;

    cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                            FORMAT_MESSAGE_FROM_HMODULE,
                            GetModuleHandleA( lpszModuleName ),
                            dwResID,
                            0,
                            (LPSTR) &pchBuff,
                            cbMaxMsg * sizeof(WCHAR),
                            (va_list *) apszInsertParams );

    if ( cch )
    {
        hr = Copy( (LPCSTR) pchBuff, cch );

        ::LocalFree( (VOID*) pchBuff );
    }

    return hr;
}


HRESULT
STRA::CopyToBuffer(
    CHAR *         pszBuffer,
    DWORD *        pcb
    ) const
{
    HRESULT         hr = S_OK;

    if ( pcb == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DWORD cbNeeded = QueryCCH() + 1;
    if ( *pcb >= cbNeeded &&
         pszBuffer != NULL )
    {
        //
        // Do the copy
        //
        memcpy(pszBuffer, QueryStr(), cbNeeded);
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }

    *pcb = cbNeeded;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\_locks.h ===
#define LOCKS_SWITCH_TO_THREAD

extern "C" {

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\uuencode.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    uuencode.cxx

Abstract:

    General uuencode and uudecode routine implementation.

Author:

    Ming Lu     (MingLu)      1-Feb-2000

Revision History:

--*/

/************************************************************
 * Include Headers
 ************************************************************/
#include "precomp.hxx"
#include "uuencode.hxx"

/************************************************************
 * Globals
 ************************************************************/

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

/*************************************************************
 *   Function implementations
 *************************************************************/

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\win32obj.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    win32obj.c

Abstract:

    This module contains helper functions for creating debug-specific
    named Win32 objects. Functions are included for named events,
    semaphores, and mutexes.

    Object names created by these routines have the following format:

        filename.ext:line_number member:address PID:pid

    Where:

        filename.ext = The file name where the object was created.

        line_number = The line number within the file.

        member = The member/global variable name where the handle is
            stored. This name is provided by the caller, but is usually
            of the form "g_Global" for globals and "CLASS::m_Member" for
            class members.

        address = An address, used to guarantee uniqueness of the objects
            created. This is provided by the caller. For global variables,
            this is typically the address of the global. For class members,
            this is typically the address of the containing class.

        pid = The current process ID. This ensures uniqueness across all
            processes.

    Here are a couple of examples:

        main.cxx:796 g_hShutdownEvent:683a42bc PID:373

        resource.cxx:136 RTL_RESOURCE::SharedSemaphore:00250970 PID:373

Author:

    Keith Moore (keithmo)        23-Sep-1997

Revision History:

--*/

# include "precomp.hxx"


#define MAX_OBJECT_NAME 256 // chars


LONG g_PuDbgEventsCreated = 0;
LONG g_PuDbgSemaphoresCreated = 0;
LONG g_PuDbgMutexesCreated = 0;



LPSTR
PuDbgpBuildObjectName(
    IN LPSTR ObjectNameBuffer,
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address
    )

/*++

Routine Description:

    Internal routine that builds an appropriate object name based on
    the file name, line number, member name, address, and process ID.

Arguments:

    ObjectNameBuffer - Pointer to the target buffer for the name.

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

Return Value:

    LPSTR - Pointer to ObjectNameBuffer if successful, NULL otherwise.

    N.B. This routine always returns NULL when running under Win9x.

--*/

{

    PLATFORM_TYPE platformType;
    LPSTR fileNamePart;
    LPSTR result;

    //
    // We have no convenient way to dump objects w/ names from
    // Win9x, so we'll only enable this functionality under NT.
    //

    // platformType = IISGetPlatformType();

    //
    // By default IIS-Duct-tape will only run on NT platforms. So
    // do not worry about getting the platform types yet.
    // 
    platformType = PtNtServer;
    result = NULL;

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {

        //
        // Find the filename part of the incoming source file name.
        //

        fileNamePart = strrchr( FileName, '\\' );

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, '/' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, ':' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = FileName;
        } else {
            fileNamePart++;
        }

        //
        // Ensure we don't overwrite our object name buffer.
        //

        if( ( sizeof(":1234567890 :12345678 PID:1234567890") +
              strlen( fileNamePart ) +
              strlen( MemberName ) ) < MAX_OBJECT_NAME ) {

            wsprintfA(
                ObjectNameBuffer,
                "%s:%lu %s:%08lx PID:%lu",
                fileNamePart,
                LineNumber,
                MemberName,
                Address,
                GetCurrentProcessId()
                );

            result = ObjectNameBuffer;

        }

    }

    return result;

}   // PuDbgpBuildObjectName


HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    )

/*++

Routine Description:

    Creates a new event object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    ManualReset - TRUE to create a manual reset event, FALSE to create
        an automatic reset event.

    InitialState - The intitial state of the event object.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateEventA(
                    NULL,                       // lpEventAttributes
                    ManualReset,                // bManualReset
                    InitialState,               // bInitialState
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgEventsCreated );
    }

    return objHandle;

}   // PuDbgCreateEvent


HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    Creates a new semaphore object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialCount - The initial count of the semaphore.

    MaximumCount - The maximum count of the semaphore.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateSemaphoreA(
                    NULL,                       // lpSemaphoreAttributes
                    InitialCount,               // lInitialCount
                    MaximumCount,               // lMaximumCount
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgSemaphoresCreated );
    }

    return objHandle;

}   // PuDbgCreateSemaphore


HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    )

/*++

Routine Description:

    Creates a new mutex object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialOwner - TRUE if the mutex should be created "owned".

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateMutexA(
                    NULL,                       // lpMutexAttributes
                    InitialOwner,               // bInitialOwner,
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgMutexesCreated );
    }

    return objHandle;

}   // PuDbgCreateMutex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\apppool.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     AppPool.cxx

   Abstract:
     Defines the functions used to access the data channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/

/*********************************************************
 * Include Headers
 *********************************************************/

# include "precomp.hxx"
# include "AppPool.hxx"

/*********************************************************
 * Member Functions of UL_APP_POOL
 *********************************************************/

UL_APP_POOL::UL_APP_POOL()
: m_hAppPool( NULL)
{
    IF_DEBUG( INIT_CLEAN) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Created UL_APP_POOL=>%08x\n", this));
    }
}

/********************************************************************++
++********************************************************************/

UL_APP_POOL::~UL_APP_POOL()
{
    Cleanup();

    IF_DEBUG( INIT_CLEAN) 
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "Destroyed UL_APP_POOL=>%08x\n", 
                    this));
    }
}

/********************************************************************++
++********************************************************************/
/*++
  UL_APP_POOL::Initialize()

  Description:
    This function creates a new data channel for the specified namespace
    group object. The UL will then queue up the requests for the namespace
    group to this data channel.

  Arguments:
    pszNSGO  - pointer to NameSpace Group object
--*/

ULONG
UL_APP_POOL::Initialize( IN LPCWSTR pwszAppPoolName)
{
    ULONG   rc;

    if ( m_hAppPool != NULL) 
    {
        //
        // There is already an App Pool channel established
        //
        
        DBGPRINTF(( DBG_CONTEXT, "Duplicate open of data channel\n"));
        return ERROR_DUP_NAME;
    }

    rc = UlOpenAppPool( &m_hAppPool,
                        pwszAppPoolName,               
                        UL_OPTION_OVERLAPPED  // ASync handle
                      );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "Failed to open AppPool '%ws': rc = 0x%0x8\n", 
                        pwszAppPoolName, rc));
        }
    }

    return (rc);
    
} // UL_APP_POOL::Initialize()

/********************************************************************++
++********************************************************************/

/*++
  UL_APP_POOL::Cleanup()

  Description:
    Closes the data channel and rests all the data inside Data channel

  Arguments:
    None

  Returns:
    Win32 error
--*/

ULONG 
UL_APP_POOL::Cleanup(void)
{ 
    ULONG rc = NO_ERROR;

    if ( m_hAppPool != NULL) 
    {
        if (!::CloseHandle( m_hAppPool)) 
        {
            rc = GetLastError();
            
            IF_DEBUG( ERROR) 
            {
                DBGPRINTF(( DBG_CONTEXT, 
                    "Unable to cleanup Data Channel handle (%08x)\n",
                    m_hAppPool
                    ));
            }
        } 
        else 
        {
            m_hAppPool = NULL;
        }
    }
    
    return (rc);

} // UL_APP_POOL::Cleanup()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\controlchannel.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     ControlChannel.cxx

   Abstract:
     Defines the functions used to access the control channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/


# include "precomp.hxx"
# include "ControlChannel.hxx"

/********************************************************************++

  UL_CONTROL_CHANNEL::Initialize()

  Description:
     This function initializes the control channel for given address, NSGO, 
     and host name. It opens the control channel, registers a virtual host,
     and NSGO. After that it registers the URL for which notifications are 
     to be handled within the NSGO.

  Arguments:


  Returns:

++********************************************************************/

ULONG 
UL_CONTROL_CHANNEL::Initialize( 
    IN MULTISZ& mszURLList,
    IN LPCWSTR  pwszAppPoolName
    )
{
    ULONG   rc;
    LPCWSTR pwszURL;

    if ( m_hControlChannel != NULL) 
    {
        //
        // There is already a control channel
        //
        
        DBGPRINTF(( DBG_CONTEXT, "Duplicate open of control channel\n"));
        return ERROR_DUP_NAME;
    }
    
    //
    // 1. Open a control channel object from the UL driver
    //
    
    rc = UlOpenControlChannel( &m_hControlChannel, 0);

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "UlOpenControlChannel() failed. Error = %08x. Returning\n", 
                        rc
                        ));
        }

        return (rc);
    }

    //
    // 2. Create a Config Group on this control channel
    //
    
    rc = UlCreateConfigGroup( m_hControlChannel, &m_ConfigGroupId );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateConfigGroup failed. Error=%08x. Returning\n",
                       rc
                       ));
        }

        return rc;
    }

    //
    // 3. Insert all specified URLs into the config group
    //

    pwszURL = mszURLList.First();

    while (NULL != pwszURL)
    {
        rc = AddURLToConfigGroup(pwszURL);

        if (NO_ERROR != rc)
        {
            return rc;
        }

        pwszURL = mszURLList.Next(pwszURL);
    }

    //
    // 4. Activate the Control Channel and the Config Group
    //

    UL_ENABLED_STATE    ccState = UlEnabledStateActive;

    rc = UlSetControlChannelInformation( m_hControlChannel,
                                         UlControlChannelStateInformation,
                                         &ccState,
                                         sizeof(ccState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate ControlChannel. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    UL_CONFIG_GROUP_STATE   cgState;

    cgState.Flags.Present = 1;
    cgState.State         = UlEnabledStateActive;  
                                         
    rc = UlSetConfigGroupInformation( m_hControlChannel,
                                      m_ConfigGroupId,
                                      UlConfigGroupStateInformation,
                                      &cgState,
                                      sizeof(cgState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate Config Group. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    //
    // 5. Create an AppPool 
    //

    rc = UlCreateAppPool( &m_hAppPool,
                          pwszAppPoolName,
                          0,
                          UL_OPTION_OVERLAPPED
                        );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateAppPool failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;
    }
    
    //
    // 6. Associate AppPool with the config group
    //

    UL_CONFIG_GROUP_APP_POOL    AppPoolConfig;

    AppPoolConfig.Flags.Present = 1;
    AppPoolConfig.AppPoolHandle = m_hAppPool;
    
    rc = UlSetConfigGroupInformation( m_hControlChannel,
                                      m_ConfigGroupId,
                                      UlConfigGroupAppPoolInformation,
                                      &AppPoolConfig,
                                      sizeof(AppPoolConfig)
                                    );
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlSetConfigGroupInformation failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }
    }
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Initialize()

/********************************************************************++
++********************************************************************/


ULONG 
UL_CONTROL_CHANNEL::Cleanup(void)
{ 
    ULONG rc = NO_ERROR;

    if ( m_hControlChannel != NULL) 
    {
        if ( ! UL_IS_NULL_ID(&m_ConfigGroupId) )
        {
            rc = UlDeleteConfigGroup( m_hControlChannel, m_ConfigGroupId);
            UL_SET_NULL_ID(&m_ConfigGroupId);
        }

        if ( NULL != m_hAppPool )
        {
            if ( !::CloseHandle( m_hAppPool))
            {
                rc = GetLastError();
            }
        }

        m_hAppPool = NULL;
        
        if (!::CloseHandle( m_hControlChannel)) 
        {
            rc = GetLastError();
        }
        
        m_hControlChannel = NULL;
    }
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Cleanup()

/********************************************************************++
++********************************************************************/

ULONG
UL_CONTROL_CHANNEL::AddURLToConfigGroup( IN LPCWSTR  pwszURL)
{
    //
    //  Add the URL to the Config Group
    //

    ULONG rc;

    rc = UlAddUrlToConfigGroup( m_hControlChannel,
                                m_ConfigGroupId,
                                pwszURL,
                               0
                              );
    
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG (ERROR)
        {
            DBGPRINTF((DBG_CONTEXT, 
                       "UlAddUrlToConfigGroup() failed. Error=%08x\n",
                       rc));
        }
    }

    return (rc);
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\common\util\i386\stkwalk.asm ===
TITLE   "Capture Stack Back Trace"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stkwalk.asm
;
; Abstract:
;
;    This module implements the routine IISCaptureStackBackTrace.  It will
;    walker the stack back trace and capture a portion of it.
;
; Author:
;
;    Steve Wood (stevewo) 29-Jan-1992
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "IISCaptureStackBackTrace"
;++
;
; USHORT
; IISCaptureStackBackTrace(
;    IN ULONG FramesToSkip,
;    IN ULONG FramesToCapture,
;    OUT PVOID *BackTrace,
;    OUT PULONG BackTraceHash
;    )
;
; Routine Description:
;
;    This routine walks up the stack frames, capturing the return address from
;    each frame requested.
;
;
; Arguments:
;
;    OUT PVOID BackTrace (eps+0x10) - Returns the caller of the caller.
;
;
; Return Value:
;
;     Number of return addresses returned in the BackTrace buffer.
;
;
;--
RcbtFramesToSkip        EQU [ebp+08h]
RcbtFramesToCapture     EQU [ebp+0Ch]
RcbtBackTrace           EQU [ebp+010h]
RcbtBackTraceHash       EQU [ebp+014h]

cPublicProc _IISCaptureStackBackTrace ,4
;
; This is defined always for user mode code, although it can be
; unreliable if called from code compiled with FPO enabled.
; In fact, it can fault, so we have a simple exception handler which
; will return 0 if this code takes an exception.
;
        push    ebp
        mov     ebp, esp
        push    esi                     ; Save ESI
        push    edi                     ; Save EDI
        push    esp                     ; Save current esp for handler
        push    offset RcbtFault        ; Address of handler
        push    fs:PcExceptionList      ; Save current list head
        mov     fs:PcExceptionList,esp  ; Put us on list
        mov     esi,RcbtBackTraceHash   ; (ESI) -> where to accumulate hash sum
        mov     edi,RcbtBackTrace       ; (EDI) -> where to put backtrace
        mov     edx,ebp                 ; (EDX) = current frame pointer
        mov     ecx,RcbtFramesToSkip    ; (ECX) = number of frames to skip
        jecxz   RcbtSkipLoopDone        ; Done if nothing to skip
RcbtSkipLoop:
        mov     edx,[edx]               ; (EDX) = next frame pointer
        cmp     edx,fs:PcStackLimit     ; If outside stack limits,
        jbe     RcbtExit                ; ...then exit
        cmp     edx,fs:PcInitialStack
        jae     RcbtExit
        loop    RcbtSkipLoop
RcbtSkipLoopDone:
        mov     ecx,RcbtFramesToCapture ; (ECX) = number of frames to capture
        jecxz   RcbtExit                ; Bail out if nothing to capture
RcbtCaptureLoop:
        mov     eax,[edx].4             ; Get next return address
        stosd                           ; Store it in the callers buffer
        add     [esi],eax               ; Accumulate hash sum
        mov     edx,[edx]               ; (EDX) = next frame pointer
        cmp     edx,fs:PcStackLimit     ; If outside stack limits,
        jbe     RcbtExit                ; ...then exit
        cmp     edx,fs:PcInitialStack
        jae     RcbtExit
        loop    RcbtCaptureLoop         ; Otherwise get next frame
RcbtExit:
        mov     eax,edi                 ; (EAX) -> next unused dword in buffer
        sub     eax,RcbtBackTrace       ; (EAX) = number of bytes stored
        shr     eax,2                   ; (EAX) = number of dwords stored
        pop     fs:PcExceptionList      ; Restore Exception list
        pop     edi                     ; discard handler address
        pop     edi                     ; discard saved esp
        pop     edi                     ; Restore EDI
        pop     esi                     ; Restore ESI
        pop     ebp
        stdRET    _IISCaptureStackBackTrace

RcbtFault:
;
; Cheap and sleazy exception handler.  This function is a leaf, so it is
; safe to do this.
;
        mov     eax,[esp+0Ch]           ; (esp)->Context
        mov     edi,CsEdi[eax]          ; restore buffer pointer
        mov     esp,[esp+8]             ; (esp)->ExceptionList
        jmp     RcbtExit                ;

stdENDP _IISCaptureStackBackTrace

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\ctrstshr\ctrstshr.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ctrstshr.cxx

Abstract:

    This file contains array descriptions of counters
    that are needed for handling worker processes counters.

Author:

    Emily Kruglick (EmilyK)       19-Sept-2000

Revision History:

--*/


#include "iis.h"
#include "httpdef.h"
#include "wpcounters.h"

//
// Every entry here has a corrosponding entry in the equivalent
// enum and structure in IISCOUNTERS.h
//

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// 
// These are used by WAS to determine the size of the data
// that each counter has in the structure above and it's offset.
//

HTTP_PROP_DESC aIISULGlobalDescription[] =
{
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, CurrentUrisCached),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, CurrentUrisCached),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, TotalUrisCached),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, TotalUrisCached),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, UriCacheHits),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, UriCacheHits),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, UriCacheMisses),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, UriCacheMisses),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, UriCacheFlushes),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, UriCacheFlushes),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_GLOBAL_COUNTERS, TotalFlushedUris),
      FIELD_OFFSET(HTTP_GLOBAL_COUNTERS, TotalFlushedUris),
      TRUE }
};

//
// Used By WAS and the WP to figure out offset, and sizes as well
// as whether or not to zero a field.
//
HTTP_PROP_DESC aIISWPGlobalDescription[] =
{
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentFileCacheMemoryUsage),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentFileCacheMemoryUsage),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, MaxFileCacheMemoryUsage),
      FIELD_OFFSET(IISWPGlobalCounters, MaxFileCacheMemoryUsage),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentFilesCached),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentFilesCached),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFilesCached),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFilesCached),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, FileCacheHits),
      FIELD_OFFSET(IISWPGlobalCounters, FileCacheHits),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, FileCacheMisses),
      FIELD_OFFSET(IISWPGlobalCounters, FileCacheMisses),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, FileCacheFlushes),
      FIELD_OFFSET(IISWPGlobalCounters, FileCacheFlushes),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, ActiveFlushedFiles),
      FIELD_OFFSET(IISWPGlobalCounters, ActiveFlushedFiles),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFlushedFiles),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFlushedFiles),
      TRUE  },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentUrisCached),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentUrisCached),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalUrisCached),
      FIELD_OFFSET(IISWPGlobalCounters, TotalUrisCached),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, UriCacheHits),
      FIELD_OFFSET(IISWPGlobalCounters, UriCacheHits),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, UriCacheMisses),
      FIELD_OFFSET(IISWPGlobalCounters, UriCacheMisses),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, UriCacheFlushes),
      FIELD_OFFSET(IISWPGlobalCounters, UriCacheFlushes),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFlushedUris),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFlushedUris),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, CurrentBlobsCached),
      FIELD_OFFSET(IISWPGlobalCounters, CurrentBlobsCached),
      FALSE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalBlobsCached),
      FIELD_OFFSET(IISWPGlobalCounters, TotalBlobsCached),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, BlobCacheHits),
      FIELD_OFFSET(IISWPGlobalCounters, BlobCacheHits),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, BlobCacheMisses),
      FIELD_OFFSET(IISWPGlobalCounters, BlobCacheMisses),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, BlobCacheFlushes),
      FIELD_OFFSET(IISWPGlobalCounters, BlobCacheFlushes),
      TRUE },
    { RTL_FIELD_SIZE(IISWPGlobalCounters, TotalFlushedBlobs),
      FIELD_OFFSET(IISWPGlobalCounters, TotalFlushedBlobs),
      TRUE }
};

//
// Used by WAS to figure out offset information and size
// of counter field in the above structure.
//
HTTP_PROP_DESC aIISULSiteDescription[] =
{
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, BytesSent),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, BytesSent),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, BytesReceived),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, BytesReceived),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, BytesTransfered),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, BytesTransfered),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, CurrentConns),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, CurrentConns),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, MaxConnections),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, MaxConnections),
      FALSE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, ConnAttempts),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, ConnAttempts),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, GetReqs),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, GetReqs),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, HeadReqs),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, HeadReqs),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, AllReqs),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, AllReqs),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, MeasuredIoBandwidthUsage),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, MeasuredIoBandwidthUsage),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, CurrentBlockedBandwidthBytes),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, CurrentBlockedBandwidthBytes),
      TRUE },
    { RTL_FIELD_SIZE(HTTP_SITE_COUNTERS, TotalBlockedBandwidthBytes),
      FIELD_OFFSET(HTTP_SITE_COUNTERS, TotalBlockedBandwidthBytes),
      TRUE }
};

//
// Used by WAS and WP to navigate the IISWPSiteCounters structure.
//
HTTP_PROP_DESC aIISWPSiteDescription[] =
{
    { RTL_FIELD_SIZE(IISWPSiteCounters, FilesSent),
      FIELD_OFFSET(IISWPSiteCounters, FilesSent),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, FilesReceived),
      FIELD_OFFSET(IISWPSiteCounters, FilesReceived),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, FilesTransferred),
      FIELD_OFFSET(IISWPSiteCounters, FilesTransferred),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, CurrentAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentNonAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, CurrentNonAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, AnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, AnonUsers),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, NonAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, NonAnonUsers),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, MaxAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxNonAnonUsers),
      FIELD_OFFSET(IISWPSiteCounters, MaxNonAnonUsers),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, LogonAttempts),
      FIELD_OFFSET(IISWPSiteCounters, LogonAttempts),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, GetReqs),
      FIELD_OFFSET(IISWPSiteCounters, GetReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, OptionsReqs),
      FIELD_OFFSET(IISWPSiteCounters, OptionsReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, PostReqs),
      FIELD_OFFSET(IISWPSiteCounters, PostReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, HeadReqs),
      FIELD_OFFSET(IISWPSiteCounters, HeadReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, PutReqs),
      FIELD_OFFSET(IISWPSiteCounters, PutReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, DeleteReqs),
      FIELD_OFFSET(IISWPSiteCounters, DeleteReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, TraceReqs),
      FIELD_OFFSET(IISWPSiteCounters, TraceReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MoveReqs),
      FIELD_OFFSET(IISWPSiteCounters, MoveReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CopyReqs),
      FIELD_OFFSET(IISWPSiteCounters, CopyReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MkcolReqs),
      FIELD_OFFSET(IISWPSiteCounters, MkcolReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, PropfindReqs),
      FIELD_OFFSET(IISWPSiteCounters, PropfindReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, ProppatchReqs),
      FIELD_OFFSET(IISWPSiteCounters, ProppatchReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, SearchReqs),
      FIELD_OFFSET(IISWPSiteCounters, SearchReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, LockReqs),
      FIELD_OFFSET(IISWPSiteCounters, LockReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, UnlockReqs),
      FIELD_OFFSET(IISWPSiteCounters, UnlockReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, OtherReqs),
      FIELD_OFFSET(IISWPSiteCounters, OtherReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentCgiReqs),
      FIELD_OFFSET(IISWPSiteCounters, CurrentCgiReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CgiReqs),
      FIELD_OFFSET(IISWPSiteCounters, CgiReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxCgiReqs),
      FIELD_OFFSET(IISWPSiteCounters, MaxCgiReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, CurrentIsapiExtReqs),
      FIELD_OFFSET(IISWPSiteCounters, CurrentIsapiExtReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, IsapiExtReqs),
      FIELD_OFFSET(IISWPSiteCounters, IsapiExtReqs),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, MaxIsapiExtReqs),
      FIELD_OFFSET(IISWPSiteCounters, MaxIsapiExtReqs),
      FALSE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, NotFoundErrors),
      FIELD_OFFSET(IISWPSiteCounters, NotFoundErrors),
      TRUE },
    { RTL_FIELD_SIZE(IISWPSiteCounters, LockedErrors),
      FIELD_OFFSET(IISWPSiteCounters, LockedErrors),
      TRUE },

};

#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\cginative.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :

        CgiNative.cxx

   Abstract :
 
        This Module is used by the cgi handler to handle all the stuff
        that needs to be done in native code.

   Author:

        Anil Ruia        (anilr)     11-Aug-1999

   Project:

        Web Server

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#include <malloc.h>
#include <stdio.h>


/********************************************************************++
Global Entry Points for callback from XSP
++********************************************************************/

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

/********************************************************************++
++********************************************************************/

#define BUFSIZE             0x1000
#define CGI_PEEK_INTERVAL   1000        // in milliseconds 
#define CGI_TIMEOUT         30000       // in milliseconds
#define CGI_FINAL_TIMEOUT   300000      // in milliseconds
#define MAXDWORD            0xffffffff

// HTTP status codes
#define Ok 200
#define GatewayTimeout 504
#define InternalServerError 500


typedef struct _IOPipes
{
    HANDLE parentstdin;
    HANDLE parentstdout;
    HANDLE childstdin;
    HANDLE childstdout;
    HANDLE processHandle;
} IOPipes;

// Function which sets up and standard input/ouput and environment for the
// child and starts it.
dllexp
BOOL
SetupIOAndStartProc(LPTSTR cmdLine, LPTSTR workingDir, LPTSTR childEnv, IOPipes *parentpipes, HANDLE userToken)
{
    HANDLE hChildStdoutRd;
    SECURITY_ATTRIBUTES saAttr;

    // set flag so pipe handles are inherited

    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    saAttr.bInheritHandle = TRUE;
    saAttr.lpSecurityDescriptor = NULL;

    // Steps for redirecting child process's stdout
    //  1. create anonymous pipe
    //  2. create noninheritable duplicate of read handle of
    //     the pipe and close the inheritable handle

    // Step 1

    if (!CreatePipe(&hChildStdoutRd, &parentpipes->childstdout, &saAttr, 0))
    {
        DBGPRINTF((DBG_CONTEXT, "Stdout pipe creation failed\n"));
        return FALSE;
    }

    // Step 2

    if (!DuplicateHandle(GetCurrentProcess(),         // source Process Handle
                        hChildStdoutRd,              // source handle
                        GetCurrentProcess(),         // target process Handle
                        &parentpipes->parentstdout,  // target handle
                        0,                           // requested access
                        FALSE,                       // Inheritance option
                        DUPLICATE_SAME_ACCESS))      // optional actions
    {
        DBGPRINTF((DBG_CONTEXT, "Duplicate Handle Failed\n"));
        return FALSE;
    }
    CloseHandle(hChildStdoutRd);

    // Steps for redirecting child process's stdin
    //  1. create anonymous pipe
    //  2. create noninheritable duplicate of write handle of
    //     the pipe and close the inheritable handle

    HANDLE hChildStdinWr;

    // Step 1

    if (!CreatePipe(&parentpipes->childstdin, &hChildStdinWr, &saAttr, 0))
    {
        DBGPRINTF((DBG_CONTEXT, "Stdin pipe creation failed\n"));
        return FALSE;
    }

    // Step 2

    if (!DuplicateHandle(GetCurrentProcess(),        // source process handle
                        hChildStdinWr,              // source handle
                        GetCurrentProcess(),        // target process handle
                        &parentpipes->parentstdin,  // target handle
                        0,                          // requested access
                        FALSE,                      // inheritance option
                        DUPLICATE_SAME_ACCESS))     // optional action
    {
        DBGPRINTF((DBG_CONTEXT, "Duplicate Handle Failed\n"));
        return FALSE;
    }
    CloseHandle(hChildStdinWr);

    // Set up members of STARTUPINFO structure, specifying the correct input,
    // output and error handles for the child
    PROCESS_INFORMATION piProcInfo;
    STARTUPINFO siStartInfo;
    ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));
    siStartInfo.cb = sizeof(STARTUPINFO);
    siStartInfo.dwFlags = STARTF_USESTDHANDLES;
    siStartInfo.hStdInput = parentpipes->childstdin;
    siStartInfo.hStdOutput = parentpipes->childstdout;
    siStartInfo.hStdError = GetStdHandle(STD_ERROR_HANDLE);

    // Create the child process

    if(userToken == NULL)
    {
        if (!CreateProcess(NULL,               // appName
                           cmdLine,            // cmdLine
                           NULL,               // processAttr
                           NULL,               // threadAttr
                           TRUE,               // bInherit
                           CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,
                           // creationFlags
                           (LPVOID)childEnv,   // envBlock
                           workingDir,         // current directory
                           &siStartInfo,       // startupinfo
                           &piProcInfo))       // processinfo
        {
            DBGPRINTF((DBG_CONTEXT, "Cannot create child process\n"));
            return FALSE;
        }
    }
    else
    {
        HANDLE procToken;
        if (!DuplicateTokenEx(userToken,
                         MAXIMUM_ALLOWED,
                         NULL,
                         SecurityImpersonation,
                         TokenPrimary,
                         &procToken))
        {
            DBGPRINTF((DBG_CONTEXT, "Cannot duplicate token\n"));
            return FALSE;
        }
        if (!CreateProcessAsUser(procToken,          // User Token
                                 NULL,               // appName
                                 cmdLine,            // cmdLine
                                 NULL,               // processAttr
                                 NULL,               // threadAttr
                                 TRUE,               // bInherit
                                 CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,
                                 // creationFlags
                                 (LPVOID)childEnv,   // envBlock
                                 workingDir,         // current directory
                                 &siStartInfo,       // startupinfo
                                 &piProcInfo))       // processinfo
        {
            DBGPRINTF((DBG_CONTEXT, "Cannot create child process with the given token\n"));
            return FALSE;
        }
        CloseHandle(procToken);
    }
    CloseHandle(piProcInfo.hThread);
    parentpipes->processHandle = piProcInfo.hProcess;

    return TRUE;
}

// Write out the entity body.

dllexp
BOOL
WriteOutRequest(LPBYTE data, int length, HANDLE parentstdin)
{
    DWORD bytesWritten;
    BOOL retval = WriteFile(parentstdin, data, length, &bytesWritten, NULL);
    // Somehow the last part does not get flushed if the it does not end
    // with a newline.  So, if it does not, write a newline
    if(data[length - 1] != '\n')
        retval = retval && WriteFile(parentstdin, "\r\n", 2, &bytesWritten, NULL);
    return retval;
}

// Structure used to pass back the response from the CGI script to the
// managed code
struct NativeResponse
{
    LPBYTE ptr;
    int length;
};

// function which gets the response from the CGI script.  Right now, all
// of it is obtained and then passed to the managed code.  Later, we may want
// to only obtain the headers and then the rest of the data could be obtained
// later.

dllexp
int
ReadResponse(HANDLE parentstdout, HANDLE childstdout, HANDLE procHandle, NativeResponse *respData)
{
    int statusCode = Ok;
    BOOL allDone = FALSE;
    int totalTimeWaited = 0;
    respData->ptr = NULL;
    respData->length = 0;
    LPBYTE data;
    DWORD size = BUFSIZE, free = BUFSIZE;

    LPBYTE origdata = (LPBYTE)malloc(BUFSIZE);
    if (origdata == NULL)
    {
        DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
        statusCode = InternalServerError;
        TerminateProcess(procHandle, 1);
        goto Cleanup;
    }
    data = origdata;

    while (!allDone)
    {
        int timeWaited = 0;
        DWORD bytesToRead;

        // peek from pipe to see if anything to read
        PeekNamedPipe(parentstdout, NULL, 0, NULL, &bytesToRead, NULL);

        // if nothing to read, keep peeking at every CGI_PEEK_INTERVAL
        // until either we have waited for more than CGI_TIMEOUT ms for
        // reading this chunk or for more than CGI_FINAL_TIMEOUT ms
        // totally or the process terminated or we finally have something
        // on the pipe
        while ((bytesToRead == 0) && !allDone)
        {
            DWORD rc = WaitForSingleObject(procHandle, CGI_PEEK_INTERVAL);
            timeWaited += CGI_PEEK_INTERVAL;
            totalTimeWaited += CGI_PEEK_INTERVAL;
            if ((rc == WAIT_TIMEOUT) &&
                ((timeWaited >= CGI_TIMEOUT) ||
                 (totalTimeWaited >= CGI_FINAL_TIMEOUT)))
            {
                TerminateProcess(procHandle, 1);
                allDone = TRUE;
                statusCode = GatewayTimeout;
                break;
            }
            if (rc == WAIT_OBJECT_0) // process terminated
                allDone = TRUE;

            if (statusCode == Ok)
                PeekNamedPipe(parentstdout, NULL, 0, NULL, &bytesToRead, NULL);
        }

        // Now, if there are any bytes to read, read them.
        while (bytesToRead > 0)
        {
            DWORD numRead;

            if (bytesToRead > free)
                ReadFile(parentstdout, data, free, &numRead, NULL);
            else
                ReadFile(parentstdout, data, bytesToRead, &numRead, NULL);

            data += numRead;
            free -= numRead;
            bytesToRead -= numRead;

            if (free == 0) // need more buffer space
            {
                size += BUFSIZE;
                origdata = (LPBYTE)realloc(origdata, size);
                if (origdata == NULL)
                {
                    DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
                    // just give up at this point
                    allDone = TRUE;
                    size = 0;
                    statusCode = InternalServerError;
                    TerminateProcess(procHandle, 1);
                    break;
                }

                data = origdata + size - BUFSIZE;
                free = BUFSIZE;
            }
        }
    }
    respData->ptr = origdata;
    respData->length = size - free;

Cleanup:
    CloseHandle(procHandle);
    CloseHandle(childstdout);
    CloseHandle(parentstdout);
    return statusCode;
}

dllexp
void
cgiCompletionCallback(LPBYTE respData,
                      HANDLE parentstdin,
                      HANDLE childstdin)
{
    free(respData);
    CloseHandle(parentstdin);
    CloseHandle(childstdin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\datetime.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :

      DateTime.cxx

   Abstract:

      Date parsing routines thanx to JohnL (01/24/95)

--*/

#include "precomp.hxx"

# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

/************************************************************
 *   Data
 ************************************************************/
 
static const WCHAR* s_rgchDays[] =  {
    TEXT("Sun"), TEXT("Mon"), TEXT("Tue"), TEXT("Wed"),
    TEXT("Thu"), TEXT("Fri"), TEXT("Sat")
};

static const WCHAR* s_rgchMonths[] = {
    TEXT("Jan"), TEXT("Feb"), TEXT("Mar"), TEXT("Apr"),
    TEXT("May"), TEXT("Jun"), TEXT("Jul"), TEXT("Aug"),
    TEXT("Sep"), TEXT("Oct"), TEXT("Nov"), TEXT("Dec")
};

// Custom hash table for make_month() for mapping "Apr" to 4
static const CHAR MonthIndexTable[64] = {
   -1,'A',  2, 12, -1, -1, -1,  8, // A to G
   -1, -1, -1, -1,  7, -1,'N', -1, // F to O
    9, -1,'R', -1, 10, -1, 11, -1, // P to W
   -1,  5, -1, -1, -1, -1, -1, -1, // X to Z
   -1,'A',  2, 12, -1, -1, -1,  8, // a to g
   -1, -1, -1, -1,  7, -1,'N', -1, // f to o
    9, -1,'R', -1, 10, -1, 11, -1, // p to w
   -1,  5, -1, -1, -1, -1, -1, -1  // x to z
};


static const BYTE TensDigit[10] = { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 };


/************************************************************
 *    Functions
 ************************************************************/

WORD
iis_2atoi(
    PWCHAR s
    )
/*++

    Converts a 2 character string to integer

    Arguments:
        s   String to convert

    Returns:
        numeric equivalent, 0 on failure.
--*/
{

    DWORD tens = s[0] - L'0';
    DWORD ones = s[1] - L'0';

    if ( (tens <= 9) && (ones <= 9) ) {
        return((WORD)(TensDigit[tens] + ones));
    }
    return(0);
}

WORD
make_month(
    PWCHAR s
    )
{
    UCHAR monthIndex;
    UCHAR c;
    LPCTSTR monthString;

    //
    // use the third character as the index
    //

    c = ((CHAR) s[2] - 0x40) & 0x3F;

    monthIndex = MonthIndexTable[c];

    if ( monthIndex < 13 ) {
        goto verify;
    }

    //
    // ok, we need to look at the second character
    //

    if ( monthIndex == 'N' ) {

        //
        // we got an N which we need to resolve further
        //

        //
        // if s[1] is 'u' then Jun, if 'a' then Jan
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 1;
        } else {
            monthIndex = 6;
        }

    } else if ( monthIndex == 'R' ) {

        //
        // if s[1] is 'a' then March, if 'p' then April
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 3;
        } else {
            monthIndex = 4;
        }
    } else {
        goto error_exit;
    }

verify:

    monthString = s_rgchMonths[monthIndex-1];

    if ( (s[0] == monthString[0]) &&
         (s[1] == monthString[1]) &&
         (s[2] == monthString[2]) ) {

        return(monthIndex);

    } else if ( (toupper(s[0]) == monthString[0]) &&
                (tolower(s[1]) == monthString[1]) &&
                (tolower(s[2]) == monthString[2]) ) {

        return monthIndex;
    }

error_exit:
    return(0);

} // make_month

BOOL
NtSystemTimeToLargeInteger(
    IN  const SYSTEMTIME * pst,
    OUT LARGE_INTEGER *    pli
    )
{

    FILETIME ft;

    //
    // Convert to file time
    //

    if ( !SystemTimeToFileTime( pst, &ft ) ) {
        return(FALSE);
    }

    //
    // Convert file time to large integer
    //

    pli->LowPart = ft.dwLowDateTime;
    pli->HighPart = ft.dwHighDateTime;

    return(TRUE);
}

dllexp
BOOL
StringTimeToFileTime(
    IN  const WCHAR * pszTime,
    OUT __int64 * pliTime
    )
/*++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format

  Arguments:
    pszTime             String representation of time field
    pliTime             large integer containing the time in NT format.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library

--*/
{

    WCHAR *         s;
    SYSTEMTIME      st;
    LARGE_INTEGER   liTime;

    if (pszTime == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    st.wMilliseconds = 0;

    if ((s = wcschr(pszTime, ','))) {

        DWORD len;

        //
        // Thursday, 10-Jun-93 01:29:59 GMT
        // or: Thu, 10 Jan 1993 01:29:59 GMT */
        //

        s++;

        while (*s && *s==' ') s++;
        len = wcslen(s);

        if (len < 18) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( *(s+2) == '-' ) {        /* First format */

            st.wDay = (WORD) _wtoi(s);
            st.wMonth = (WORD) make_month(s+3);
            st.wYear = (WORD) _wtoi(s+7);
            st.wHour = (WORD) _wtoi(s+10);
            st.wMinute = (WORD) _wtoi(s+13);
            st.wSecond = (WORD) _wtoi(s+16);

        } else {                /* Second format */

            if (len < 20) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }

            st.wDay = iis_2atoi(s);
            st.wMonth = make_month(s+3);
            st.wYear = iis_2atoi(s+7) * 100  +  iis_2atoi(s+9);
            st.wHour = iis_2atoi(s+12);
            st.wMinute = iis_2atoi(s+15);
            st.wSecond = iis_2atoi(s+18);

        }
    } else {    /* Try the other format:  Wed Jun  9 01:29:59 1993 GMT */

        s = (WCHAR *) pszTime;
        while (*s && *s==' ') s++;

        if ((int)wcslen(s) < 24) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        st.wDay = (WORD) _wtoi(s+8);
        st.wMonth = (WORD) make_month(s+4);
        st.wYear = (WORD) _wtoi(s+20);
        st.wHour = (WORD) _wtoi(s+11);
        st.wMinute = (WORD) _wtoi(s+14);
        st.wSecond = (WORD) _wtoi(s+17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if ( st.wYear < 1000 ) {
        if ( st.wYear < 50 ) {
            st.wYear += 2000;
        } else {
            st.wYear += 1900;
        }
    }

    if ( !NtSystemTimeToLargeInteger( &st, &liTime )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    *pliTime = liTime.QuadPart;
    
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\davpropbag.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :

        DAVPropBag.cxx

   Abstract :
 
        This Module is used by DAV to retrieve properties stored within
		files on NTFS NT 5 systems.

   Author:

        Emily Kruglick     (emilyk)     08-Sept-1999

   Project:

        Web Server

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "precomp.hxx"

#include <malloc.h>
#include <stdio.h>
#include <string.h>
#include <pbagex.h>


// Function declaration for the StgOpenStoreageOnHandle
// it is supported from OLE32.dll, but is not exposed or
// documented.
typedef HRESULT (__stdcall * STGOPENSTORAGEONHANDLE)(
	IN HANDLE hStream,
	IN DWORD grfMode,
	IN void *reserved1,
	IN void *reserved2,
	IN REFIID riid,
	OUT void **ppObjectOpen );

#define DEC_CONST		extern const __declspec(selectany)

// Must match the constant values defined in managed code.
DEC_CONST int gc_iDavType_String			= 1;
DEC_CONST int gc_iDavType_String_XML_TAG	= 2;
DEC_CONST int gc_iDavType_String_XML_FULL	= 3;
DEC_CONST int gc_iDavType_Date_ISO8601		= 4;
DEC_CONST int gc_iDavType_Date_Rfc1123		= 5;
DEC_CONST int gc_iDavType_Float				= 6;
DEC_CONST int gc_iDavType_Boolean			= 7;
DEC_CONST int gc_iDavType_Int				= 8;


/********************************************************************++
 Routines borrowed from DAVFS that manage converting data for properties
++********************************************************************/
#define CchConstString(_s)  ((sizeof(_s)/sizeof(_s[0])) - 1)

DEC_CONST WCHAR gc_wszIso8601_min[]			= L"yyyy-mm-ddThh:mm:ssZ";
DEC_CONST UINT gc_cchszIso8601_min			= CchConstString(gc_wszIso8601_min);
DEC_CONST WCHAR gc_wszIso8601_scanfmt[]		= L"%04hu-%02hu-%02huT%02hu:%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_tz_scanfmt[]	= L"%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_fmt[]			= L"%04d-%02d-%02dT%02d:%02d:%02d.%03dZ";
DEC_CONST WCHAR gc_wszRfc1123_min[]			= L"www, dd mmm yyyy hh:mm:ss GMT";
DEC_CONST UINT	gc_cchRfc1123_min			= CchConstString (gc_wszRfc1123_min);
DEC_CONST WCHAR gc_wszRfc1123_fmt[] 		= L"%hs, %02d %hs %04d %02d:%02d:%02d GMT";
DEC_CONST CHAR gc_szRfc1123_fmt[]	 		= "%hs, %02d %hs %04d %02d:%02d:%02d GMT";

DEC_CONST int PROP_BAG_SIZE = 16;
DEC_CONST int HTTP_STATUS_OK = 200;


BOOL __fastcall
FGetDateIso8601FromSystime(SYSTEMTIME * psystime, LPWSTR pwszDate, ULONG cSize)
{
	//	If there is not enough space...
	//
	if (cSize <= gc_cchszIso8601_min)
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszIso8601_fmt,
						 psystime->wYear,
						 psystime->wMonth,
						 psystime->wDay,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond,
						 psystime->wMilliseconds));
}


/********************************************************************++
Global Entry Points for callback from XSP
++********************************************************************/

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

/********************************************************************++
++********************************************************************/
// Used to store linked list of property information.
struct PropNode
{
	 BSTR PropName;
     BSTR PropValue;
     int	PropType;
     int	ResultCode;
     PropNode* next;
};

const int ALL_PROPS_REQUESTED = 1;
const int PROP_NAMES_ONLY_REQUESTED = 2;

// Class is used to hold information about a URI's properties
// so we don't have to evaluate from the URI twice when we need 
// to get the count of values that we should expect back.
class DAVPropertyManager
{
public:
	DAVPropertyManager();
	~DAVPropertyManager();

	HRESULT GetCountOfProperties(BSTR uri, int flag, BSTR* RequestedProps, int ReqPropsCount, int* count);
	HRESULT GetProperties(  BSTR uri
							, int  flag
							, BSTR* RequestedProps
							, int  RequestedPropsCount
							, BSTR* names
							, BSTR* values
							, int*   types
							, int*   codes
							, int    count);

private:

	HRESULT EvaluateURI(BSTR bstrURI, int flag, BSTR* propnames, int propnamescount);
	HRESULT GetPropertyBag( LPCWSTR pwszPath, IPropertyBagEx** ppBag);
	HRESULT StoreProps( IPropertyBagEx* pBag, BSTR* RequestedProps, int RequestedPropCount, int flag);
	HRESULT AddPropToList(LPWSTR name, PROPVARIANT* var, int resultcode);
	HRESULT CopyValue (LPWSTR origVal, BSTR* pnewValue);
	HRESULT SavePropValue ( PROPVARIANT* var, BSTR* ppValue, int* ppType );

	int			_count;					// number of properties found
	LPWSTR		_uri;					// uri the properties were retrieved from
	PropNode*	_pPropertyList;			// saved property listing
	PropNode*	_pLastPropertyAdded;	// last spot in property listing

};

DAVPropertyManager::DAVPropertyManager()
{
	_count = 0;
	_uri = NULL;
	_pPropertyList = NULL;
	_pLastPropertyAdded = NULL;
}

DAVPropertyManager::~DAVPropertyManager()
{
	delete[] _uri;

	PropNode* tpi;

	while (_pPropertyList != NULL)
	{
		tpi = _pPropertyList->next;

		SysFreeString(_pPropertyList->PropName);
		SysFreeString(_pPropertyList->PropValue);
		
		// Types are set to integers so they don't need freeing!!
		// so they are never freed!!
		// delete[] _pPropertyList->PropType;
		delete _pPropertyList;
		_pPropertyList = tpi;
	}

}

HRESULT DAVPropertyManager::EvaluateURI(BSTR bstrURI, int flag, BSTR* RequestedProps, int RequestedPropsCount)
{
	HRESULT hr = S_OK;
	IPropertyBagEx* pBag = NULL;

	if (bstrURI == NULL)
		return E_INVALIDARG;

	// Save the URI for later use.  (Right now we don't have a later use, but we might someday.)
	_uri = new WCHAR[wcslen(bstrURI) + 1];
	if (_uri == NULL) 
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}
	wcscpy(_uri, bstrURI);

	hr = GetPropertyBag(bstrURI, &pBag);
	if (SUCCEEDED (hr))
	{
		hr = StoreProps(pBag, RequestedProps, RequestedPropsCount, flag);
	}

cleanup:
	if (pBag) 
		pBag->Release();

	return hr;
}

// BUGBUG:  This is an extremely simplified version just to get us running, it will need to be compared with ScGetPropertyBag 
// and have all the complexity added back in.
HRESULT DAVPropertyManager::GetPropertyBag( LPCWSTR pwszPath, IPropertyBagEx** ppBag)
{
	HRESULT hr = S_OK;
	DWORD dwResult = 0;

	HANDLE hFile = NULL;
	HINSTANCE hLib = NULL;

	hFile = CreateFileW (pwszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == NULL)
	{
		dwResult = GetLastError();
		hr = HRESULT_FROM_WIN32(dwResult);
		goto cleanup;
	}

	hLib = LoadLibrary (L"ole32.dll");
	if (hLib != NULL)
	{
		// Physical Address does not need to be freed (I believe).
		STGOPENSTORAGEONHANDLE pfnStorage = (STGOPENSTORAGEONHANDLE) GetProcAddress (hLib, "StgOpenStorageOnHandle");

		hr = (*pfnStorage) (hFile,
						STGM_READ | STGM_SHARE_DENY_WRITE,
						NULL,
						NULL,
						IID_IPropertyBagEx,
						(LPVOID *)ppBag);

		if (FAILED(hr)) goto cleanup;
	}
	else
	{
		dwResult = GetLastError();
		hr = HRESULT_FROM_WIN32(dwResult);
		goto cleanup;
	}

	if (*ppBag == NULL)
	{
		hr = E_FAIL;
		goto cleanup;
	}

cleanup:

	if (hFile) CloseHandle(hFile);
	if (hLib) FreeLibrary(hLib);

	return hr;
}

HRESULT DAVPropertyManager::StoreProps( IPropertyBagEx* pBag, BSTR* RequestedProps, int RequestedPropCount, int flag )
{
	HRESULT hr = S_OK;

	IEnumSTATPROPBAG* enumBag = NULL;
	STATPROPBAG sp[PROP_BAG_SIZE];
	ULONG cprops = 0;
	LPWSTR propnames[PROP_BAG_SIZE] = {0};
	LPWSTR* passprops = NULL;
	PROPVARIANT propvariants[PROP_BAG_SIZE];

	// Need to clear out the propvariants memory.
	ZeroMemory (&propvariants, sizeof(PROPVARIANT) * PROP_BAG_SIZE );

	ULONG i = 0;

	// Figure out if we want all properties or just selected ones and if we want the property values as well.
	bool fAllProps = ((flag == ALL_PROPS_REQUESTED) || (flag == PROP_NAMES_ONLY_REQUESTED));
	bool fPropValues = flag != PROP_NAMES_ONLY_REQUESTED;

	// Validate that either we want all properties or have been given specific properties we want to get
	ASSERT (fAllProps || (RequestedProps && RequestedPropCount > 0));
	bool fMorePropertiesExist = fAllProps;

	// If we are looking for all properties then 
	// we need an enum bag to use to get the properties
	if (fAllProps) 
	{
		hr = pBag->Enum (NULL, 0, &enumBag);
		if (FAILED(hr))
			goto cleanup;
	}

	do
	{
		if (fAllProps)
		{
			// Use the enumBag to get the properties names we need.
			hr = enumBag->Next(PROP_BAG_SIZE, sp, &cprops);
			if (FAILED(hr)) goto cleanup;

			fMorePropertiesExist = (hr == S_OK);  // hr will be S_FALSE when we have processed all the properties.

			// Need to first go through and create a list of the properties I am going to ask
			// for when I read multiple property info from the bag.
			for (i = 0 ; i < cprops ; i++)
			{
				// grab the pointer to the property name
				propnames[i] = sp[i].lpwstrName;
			}

			// set it into the variable we will use below.
			passprops = propnames;
		}
		else
		{
			// if we already had the property names set them into the correct variables.
			passprops = (LPWSTR*) RequestedProps;
			cprops = RequestedPropCount;
		}

		// Now that i have set the property names in I can ask
		// for the properties back.
		hr = pBag->ReadMultiple (cprops,
					   passprops,
					   propvariants,
					   NULL);
		if (FAILED(hr)) 
			goto cleanup;

		for (i = 0 ; i < cprops ; i++)
		{
			if (propvariants[i].vt != VT_EMPTY)
			{
				if (fPropValues)
					AddPropToList(passprops[i], &(propvariants[i]), HTTP_STATUS_OK);
				else
					AddPropToList(passprops[i], NULL, HTTP_STATUS_OK);
			}

			// If the enumBag->Next created property names then we need to clean them up.
			if (fAllProps)
			{
				CoTaskMemFree(passprops[i]);
				passprops[i] = NULL;
			}

		//	MessageBox(NULL, sp[i].lpwstrName, L"Names", MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONHAND);
		}
		
		// Free the memory for the PROPVARIANTS
		FreePropVariantArray(cprops, propvariants);


	} while (fMorePropertiesExist);

cleanup:

	if (enumBag) 
        enumBag->Release();

	if ((fAllProps) && (passprops != NULL))
	{
		for (i = 0; i<cprops; i++)
		{
			CoTaskMemFree(passprops[i]);
		}
	}
	return hr;
}

HRESULT DAVPropertyManager::AddPropToList(LPWSTR name, PROPVARIANT* var, int resultcode)
{
	HRESULT hr = S_OK;
	PropNode* tmp = new PropNode;
	if (tmp==NULL) 
	{ 
		// We won't record an error, the property will just be dropped.
		return E_OUTOFMEMORY;
	}

	if (var)
	{
		hr = SavePropValue(var, &(tmp->PropValue), &(tmp->PropType));
		if (FAILED(hr)) 
		{
			// if we had any problem with saving the property value then we 
			// will just ignore the property being returned to the user.
			delete tmp;
			return S_OK;
		}
	}
	else
	{
		tmp->PropValue = NULL;
		tmp->PropType = 0;
	}

	// Make copy of names and values, so we don't end up with someone changing our values later
	// like when another enumBag->Next is called.
	hr = CopyValue(name, &(tmp->PropName));
	if (FAILED(hr))
	{
		SysFreeString(tmp->PropValue) ;
		delete tmp;
		return hr;
	}

	tmp->ResultCode = resultcode;
	tmp->next = NULL;

	if (_pLastPropertyAdded)
	{
		_pLastPropertyAdded->next = tmp;
		_pLastPropertyAdded = tmp;
	}
	else
	{
		_pPropertyList = tmp;
		_pLastPropertyAdded = tmp;
	}

	// Make sure we record that we have another property.
	_count++;

	return hr;
}

HRESULT DAVPropertyManager::CopyValue (LPWSTR origVal, BSTR* pnewValue)
{
	ASSERT (pnewValue);

	*pnewValue = SysAllocString(origVal);
	if (*pnewValue == NULL) 
        return E_OUTOFMEMORY;

	return S_OK;

}

HRESULT DAVPropertyManager::SavePropValue ( PROPVARIANT* var, BSTR* ppValue, int* ppType )
{
	HRESULT hr = S_OK;
	ULONG cch = 0;		// Count of characters needed for new string
	WCHAR wszBuf[100];  // Buffer for converting number into a string
	VARIANT* pvarTrue = reinterpret_cast<VARIANT*>(var);  // Used for reaching numeric types.
	CHAR szBuf[100];    // Buffer for convertint asci values.
	LPWSTR tmp = NULL;

	// Validate we have the correct variables coming in.
	ASSERT (ppValue && ppType);
	ASSERT (var);

	if (ppValue==NULL || ppType ==NULL) return E_INVALIDARG;
	if (var==NULL) return E_INVALIDARG;

	// Initalize outgoing variables.
	*ppValue = NULL;
	*ppType = 0;

	switch (var->vt)
	{
		case VT_NULL:
		case VT_EMPTY:

			break;

		case VT_BSTR:

			hr = CopyValue(static_cast<LPWSTR>(var->bstrVal), ppValue);
			break;

		case VT_LPWSTR:

			hr = CopyValue(var->pwszVal, ppValue);
			break;

		case VT_LPSTR:

			if (!var->pszVal)
				break;

			cch = strlen (var->pszVal) + 1;
			tmp = new WCHAR[cch];
			if (tmp == NULL) 
				hr = E_OUTOFMEMORY;
			else
			{
				MultiByteToWideChar (CP_ACP,
									 0,
									 var->pszVal,
									 -1,
									 tmp,
									 cch);
				
				*ppValue = SysAllocString(tmp);
				delete[] tmp;
			}
			break;

		case VT_I1:

			// BUGBUG:  Do we want to new the wszBuf each time
			//          and then itow directly into it, instead of
			//          having to do the new and copy after the itow?
			*ppType = gc_iDavType_Int;
			_itow (pvarTrue->cVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI1:

			*ppType = gc_iDavType_Int;
			_ultow (var->bVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_I2:

			*ppType = gc_iDavType_Int;
			_itow (var->iVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI2:

			*ppType = gc_iDavType_Int;
			_ultow (var->uiVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_I4:

			*ppType = gc_iDavType_Int;
			_ltow (var->lVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI4:

			*ppType =  gc_iDavType_Int;
			_ultow (var->ulVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_I8:

			*ppType =  gc_iDavType_Int;
			_i64tow (var->hVal.QuadPart, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI8:

			*ppType = gc_iDavType_Int;
			_ui64tow (var->uhVal.QuadPart, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_INT:

			*ppType =  gc_iDavType_Int;
			_itow (pvarTrue->intVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UINT:

			*ppType =  gc_iDavType_Int;
			_ultow (pvarTrue->uintVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_BOOL:

			*ppType =  gc_iDavType_Boolean;
			_itow (!(VARIANT_FALSE == var->boolVal), wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_R4:
		case VT_R8:

			if (VT_R4 == var->vt)
				_gcvt (var->fltVal, 99, szBuf);
			else
				_gcvt (var->dblVal, 99 , szBuf);

			MultiByteToWideChar (CP_ACP,
								 0,
								 szBuf,
								 -1,
								 wszBuf,
								 100);

			*ppType = gc_iDavType_Float;
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_FILETIME:

			SYSTEMTIME st;

			FileTimeToSystemTime (&var->filetime, &st);
			if (!FGetDateIso8601FromSystime(&st, wszBuf, 100))
			{
				hr = E_INVALIDARG;
			} 
			else
			{
				*ppType = gc_iDavType_Date_ISO8601;
				hr = CopyValue(wszBuf, ppValue);
			}
			break;

		case VT_CY:
		case VT_DATE:
		case VT_DISPATCH:
		case VT_ERROR:
		case VT_VARIANT:
		case VT_UNKNOWN:
		case VT_DECIMAL:
		case VT_RECORD:
		case VT_BLOB:
		case VT_STREAM:
		case VT_STORAGE:
		case VT_STREAMED_OBJECT:
		case VT_STORED_OBJECT:
		case VT_BLOB_OBJECT:
		case VT_CF:
		case VT_CLSID:

		// DAVFS supported vectors of wstrs because at one point you could save them, however that was long ago
		// JoelS didn't have any problem with my decision not to support reading these back so we are not.
		// They complicate property management since they require multiple value support.
		case VT_VECTOR | VT_LPWSTR:

		default:

			hr = E_UNEXPECTED;
			break;
	}

	return hr;
}




HRESULT DAVPropertyManager::GetCountOfProperties(  BSTR uri
												 , int     flag
												 , BSTR* propnames
												 , int	   propnamescount
 												 , int* count)

{
	HRESULT hr = S_OK;

	if (_uri == NULL)
		hr = EvaluateURI(uri, flag, propnames, propnamescount);

	*count = _count;
	return hr;
}

HRESULT DAVPropertyManager::GetProperties(  BSTR uri
										  , int    flag
										  , BSTR* propnames
										  , int    propnamescount
										  , BSTR* names
										  , BSTR* values
										  , int*   types
										  , int*   codes
										  , int    count)
{
	HRESULT hr = S_OK;

	if (_uri == NULL)
		hr = EvaluateURI(uri, flag, propnames, propnamescount);

	if (SUCCEEDED(hr))
	{
		if (count != _count)
			return E_INVALIDARG;

	//	MessageBox(NULL, L"GetProperties", L"IN", MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONHAND);
		PropNode* tpi = _pPropertyList;

		int i = 0;
		while ((tpi != NULL) && (i < count))
		{
			names[i] = tpi->PropName;
			values[i] = tpi->PropValue;
			types[i] = tpi->PropType;
			codes[i] = tpi->ResultCode;
            i++;
			tpi = tpi->next;
		}
	}

	return hr;
}



// Exported functions for interacting with the DAVPropertyManager Class.
dllexp 
HRESULT DAVGetPropertyCount (BSTR uri, BSTR* propnames, int propnamescount, int flag,  int* count, int* addr)
{
	HRESULT hr = S_OK;
    DAVPropertyManager* pm = NULL;

	*count = 0;  //initalize out parameter.

	if (*addr == NULL)
	{
        pm = new DAVPropertyManager();
        *addr = (int) pm;
	}
    else
    {
        pm = (DAVPropertyManager*) *addr;
    }

	hr = pm->GetCountOfProperties(uri, flag, propnames, propnamescount, count);

	return hr;

}

dllexp 
HRESULT DAVGetProperties (  BSTR uri
						  , BSTR* propnames
						  , int propnamescount
						  , int flag
						  , BSTR* names
						  , BSTR* values
						  , int* types
						  , int* codes
						  , int count
						  , int* addr)
{
	HRESULT hr = S_OK;
    DAVPropertyManager* pm = NULL;

	if (*addr == NULL)
	{
        pm = new DAVPropertyManager();
        *addr = (int) pm;
	}
    else
    {
        pm = (DAVPropertyManager*) *addr;
    }

	hr = pm->GetProperties(uri, flag, propnames, propnamescount, names, values, types, codes, count);

	return hr;

}

dllexp 
HRESULT DAVFreePropManager (int addr)
{
	HRESULT hr = S_OK;

	if (addr != NULL)
	{
		DAVPropertyManager* pm = (DAVPropertyManager*) addr;
		delete pm;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_UL_CALLS             0x00010000

# define    DEBUG_NREQ                 0x00040000
# define    DEBUG_WPIPM                0x00080000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

#if DBG

//
// handy trace macro
//
#define WpTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define WpTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\iiswp.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     iiswp.cxx

   Abstract:
     Main module for the Worker Process of KDT
 
   Author:

       Murali R. Krishnan    ( MuraliK )     23-Sept-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
// Include worker process exit codes
#include "wpif.h"
#ifdef TEST
#include "RWP_Func.hxx"
#endif

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\WP";


class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule)
    {
#if DBG
        CREATE_DEBUG_PRINT_OBJECT( pszModule);
#else
        UNREFERENCED_PARAMETER(pszModule);
#endif
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};


WP_CONTEXT * g_pwpContext = NULL;

PTRACE_LOG g_pRequestTraceLog = NULL;

extern void IsapiNativeCleanup();


/************************************************************
 *    Functions 
 ************************************************************/

extern "C" INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    DEBUG_WRAPPER  dbgWrapper( "iiswp");
    WP_CONFIG      wpConfig;
    ULONG          rc;
    HRESULT        hr;

    //
    // We don't want the worker process to get stuck in a dialog box
    // if it goes awry.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );

    IF_DEBUG( TRACE) 
    {

        //
        // Print out our process affinity mask on debug builds.
        //


        BOOL fRet = TRUE;
        DWORD_PTR ProcessAffinityMask = 0;
        DWORD_PTR SystemAffinityMask = 0;

        fRet = GetProcessAffinityMask(
                    GetCurrentProcess(),
                    &ProcessAffinityMask,
                    &SystemAffinityMask
                    );

        DBGPRINTF(( DBG_CONTEXT, "Process affinity mask: %p\n", ProcessAffinityMask ));
        
    }

    if (argc > 0 ) 
    {

        BOOL fRet;
        fRet = wpConfig.ParseCommandLine( argc, argv);

        if (!fRet) 
        {
            return (ERROR_WORKER_PROCESS_EXIT_CODE);
        }
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    DBGPRINTF((DBG_CONTEXT, "rc %d\n", hr));
    if (FAILED(hr))
        return ERROR_WORKER_PROCESS_EXIT_CODE;

    hr = wpConfig.InitConfiguration();
    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Error (hr=%08x) initializing configuration. Exiting\n",
                   hr));
        return (ERROR_WORKER_PROCESS_EXIT_CODE);
    }

    rc = UlInitialize(0);
    
    if (NO_ERROR != rc)
    {
        DBGPRINTF(( DBG_CONTEXT, "Error (rc=%08x) in UlInitialize. Exiting\n",
                    rc ));
        return (ERROR_WORKER_PROCESS_EXIT_CODE);
    }

    if ( wpConfig.FSetupControlChannel()) 
    {

        IF_DEBUG( TRACE) 
        {
            DBGPRINTF(( DBG_CONTEXT, "Setting up Control Channel\n" ));
        }

        rc = wpConfig.SetupControlChannel();

        if (NO_ERROR != rc) 
        {
            IF_DEBUG(ERROR) 
            {
                DBGPRINTF(( DBG_CONTEXT, 
                            "Error (rc=%08x) in setting up Control Channel. Exiting\n",
                            rc
                         ));
            }

            UlTerminate();
            return (ERROR_WORKER_PROCESS_EXIT_CODE);
        }
    }

    //
    // Initialize global state
    //

    g_pRequestTraceLog = CreateRefTraceLog(1024, 0);
    
    g_pwpContext = new WP_CONTEXT;
    
    if (NULL == g_pwpContext) 
    {

        IF_DEBUG(ERROR) 
        {
           DBGPRINTF(( DBG_CONTEXT, "Memory failure in creating WP_CONTEXT object.\n"));
        }

        UlTerminate();
        return (ERROR_WORKER_PROCESS_EXIT_CODE);
    }

    //
    // Initialize the worker process context
    //

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Initalizing conext for AppPool: %ws\n", 
                    wpConfig.QueryAppPoolName()
                 ));
    }

#ifdef TEST
	//
	// Determine if we should be deterministic or random, 
	// and declare our intentions
	//
	RWP_Read_Config(RWP_CONFIG_LOCATION);
#endif

#ifdef TEST
	//
	// On demand, just short circuit the startup loop (by sending a shutdown event)
	//
	if (RWP_BEHAVIOR_EXHIBITED = RWP_Startup_Behavior(&rc, g_pwpContext))
		goto cleanup;
#endif

    // Main initialization routine
    rc = g_pwpContext->Initialize( &wpConfig);
    
    if (NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, "Error (rc=0x%08x) in initalizing AppPool '%ws'. Exiting\n",
                            rc, wpConfig.QueryAppPoolName()
                     ));
        }

        goto cleanup;
    }

    //
    // In future this main thread will be subsumed by one of the
    // worker threads or this may become the OLE Main thread.
    //
    if (NO_ERROR == rc)
    {
        rc = g_pwpContext->RunMainThreadLoop();
    }
    
cleanup:

    ULONG   Cleanup_rc;
    //
    // exit from the function.
    //
    
    IF_DEBUG(TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Exiting the AppPool process\n"));
    }

    // Shutdown XSPRuntime, IPM, etc.
    Cleanup_rc = g_pwpContext->Shutdown();


    // Terminate UL, which will make any out-standing requests to be cancelled.
    UlTerminate();

    // Clean up the requests context, let any outstanding requests drain.
    Cleanup_rc = g_pwpContext->Cleanup();
    
    // Uninitialize the appdomain factory after we're sure there are
    // no outstanding requests (which might end up trying to create a
    // new appdomain).
    wpConfig.UnInitConfiguration();

    // Cleanup ISAPI extension related structures (call TerminateExtension, unload dlls)
    IsapiNativeCleanup();

    delete g_pwpContext;
    g_pwpContext = NULL;
    

    if (g_pRequestTraceLog) {
        DestroyRefTraceLog(g_pRequestTraceLog);
        g_pRequestTraceLog = NULL;
    }

    CoUninitialize();

    //
    // If we exited the main loop cleanly, then signal a clean exit
    // to the web admin service.
    //

    if ( rc == NO_ERROR )
    {
        rc = CLEAN_WORKER_PROCESS_EXIT_CODE;
    }
    else
    {
        rc = ERROR_WORKER_PROCESS_EXIT_CODE;
    }
    
    return rc;
    
} // wmain()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\isapinative.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :

        ISAPINative.cxx

   Abstract :
 
        The code in this file does all the work for the ISAPI handler,
        using methods of ISAPINativeCallBack as needed.

   Author:

        Anil Ruia        (anilr)     31-Aug-1999

   Project:

        Web Server

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
#include <httpext.h>
#include "ISAPINative.hxx"

/********************************************************************++
Global Entry Points for callback from DT
++********************************************************************/

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

/********************************************************************++
++********************************************************************/


// this function is called by the static initializer of the ISAPIHandler
// class to initialize all the data structures
dllexp void NativeIsapiInitialize(void)
{
    if (!IsapiInitialized)
    {
        IsapiInitialized = TRUE;
        // Initialize the lookup table
        for (int i=0;i<TABLE_SIZE;i++)
            dllLookupTable[i] = NULL;

        // Initialize the critical section
        InitializeCriticalSection(&dllTableLock);
        OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &PROC_TOKEN);
    }
}


// This method is the one called by the ISAPI handler to do the real work
dllexp int NativeIsapiProcessRequest(int NativeContext, LPTSTR dllName)
{
    ULONG rc = NO_ERROR;
    xspmrt::_ISAPINativeCallback *m_pISAPI;

    // Create the Managed Callback Object used to get stuff from managed
    // code
    rc = CoCreateInstance(__uuidof(xspmrt::ISAPINativeCallback),
                          NULL, CLSCTX_INPROC_SERVER,
                          __uuidof(xspmrt::_ISAPINativeCallback),
                          (LPVOID *)&m_pISAPI);

    if (FAILED(rc))
    {
        DBGPRINTF((DBG_CONTEXT, "CoCreateInstance of ISAPINativeCallback failed, hr %08x\n", rc));
        return InternalServerError;
    }

    DBG_ASSERT(m_pISAPI != NULL);

    // Initialize the Managed Callback
    m_pISAPI->Init(NativeContext);

    // try to locate the dll in the lookup table, if not make a new entry
    // BUGBUG: not always InternalServerError, sometimes BadGateway
    dllData *dll = FindOrInsertDllInLookupTable(dllName);
    if (dll == NULL)
        return GetLastError();

    // Setup the EXTENSION_CONTROL_BLOCK
    LPEXTENSION_CONTROL_BLOCK lpECB;

    lpECB = new EXTENSION_CONTROL_BLOCK;
    if (lpECB == NULL)
    {
        DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
        return InternalServerError;
    }

    // setup the request specific structure
    requestData *req;

    req = new requestData;
    if (req == NULL)
    {
        DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
        return InternalServerError;
    }
    req->m_pISAPI = m_pISAPI;
    req->lpECB = lpECB;
    req->PFN_HSE_IO_COMPLETION_CALLBACK = NULL;
    req->pContext = NULL;
    req->isPending = FALSE;
    req->writeLock = CreateSemaphore(NULL, 1, 1, NULL);
    if (req->writeLock == NULL)
    {
        DBGPRINTF((DBG_CONTEXT, "Cannot create semaphore\n"));
        delete req;
        return InternalServerError;
    }

    req->reqDll = dll;

    // initialize ECB to pass to HttpExtensionProc
    lpECB->cbSize = sizeof(EXTENSION_CONTROL_BLOCK);
    lpECB->dwVersion = 0x00050000; // BUGBUG: what version?
    lpECB->ConnID = (HCONN)req;
    lpECB->dwHttpStatusCode = 200;

    LPSTR LogData;
    m_pISAPI->GetLogData(&LogData);
    if (LogData == NULL)
        LogData = "";
    if (strlen(LogData) < HSE_LOG_BUFFER_LEN)
        strcpy(lpECB->lpszLogData, LogData);
    else
        memcpy(lpECB->lpszLogData, LogData, HSE_LOG_BUFFER_LEN);

    m_pISAPI->GetServerVariable("REQUEST_METHOD", &lpECB->lpszMethod);
    m_pISAPI->GetServerVariable("QUERY_STRING", &lpECB->lpszQueryString);
    m_pISAPI->GetServerVariable("PATH_INFO", &lpECB->lpszPathInfo);
    m_pISAPI->GetServerVariable("PATH_TRANSLATED", &lpECB->lpszPathTranslated);

    int buflen;
    m_pISAPI->ReadRequestLength(&buflen);
    LPBYTE bufptr;
    m_pISAPI->ReadRequestBytes((LPSTR *)&bufptr);
    DBGPRINTF((DBG_CONTEXT, "Data read: %s\n", bufptr));

    lpECB->cbTotalBytes = buflen;
    lpECB->cbAvailable = buflen;
    lpECB->lpbData = bufptr;

    m_pISAPI->GetServerVariable("CONTENT_TYPE", &lpECB->lpszContentType);

    lpECB->GetServerVariable = InternalGetServerVariable;
    lpECB->WriteClient = InternalWriteClient;
    lpECB->ReadClient = InternalReadClient;
    lpECB->ServerSupportFunction = InternalServerSupportFunction;

    int returnCode;

    // Impersonate the logged on user
    HANDLE token;
    m_pISAPI->UserToken((int *)&token);
    if (token == NULL)
        token = PROC_TOKEN;
    if (!ImpersonateLoggedOnUser(token))
        DBGPRINTF((DBG_CONTEXT, "Impersonation failed\n"));

    switch(dll->HttpExtensionProc(lpECB))
    {
    case HSE_STATUS_SUCCESS:
    case HSE_STATUS_SUCCESS_AND_KEEP_CONN:
    case HSE_STATUS_ERROR:
        returnCode = lpECB->dwHttpStatusCode;
        break;
    case HSE_STATUS_PENDING:
        req->isPending = TRUE;
        returnCode = Pending;
        break;
    default:
        DBGPRINTF((DBG_CONTEXT, "Extension %S returned unknown status\n", dllName));
        returnCode = BadGateway;
    }

    // stop impersonating
    if (!SetThreadToken(NULL, NULL))
        DBGPRINTF((DBG_CONTEXT, "Deimpersonation failed\n"));

    if(returnCode != Pending)
        CleanupReqStrs(req);
    return returnCode;
}


void CleanupReqStrs(requestData *req)
{
    xspmrt::_ISAPINativeCallback *m_pISAPI = req->m_pISAPI;
    LPEXTENSION_CONTROL_BLOCK lpECB = req->lpECB;

    // cleanup all request specific structures.  dll specific structures
    // will be cleaned up when the process terminates
    m_pISAPI->Release();
    CloseHandle(req->writeLock);
    delete req;
    delete lpECB;
}


int GetHashCode(LPWSTR str)
{
    // BUGBUG: TODO
    return 0;
}


dllData *FindOrInsertDllInLookupTable(LPWSTR dllName)
{
    int position = GetHashCode(dllName) % TABLE_SIZE;

    EnterCriticalSection(&dllTableLock);

    // look for the dll first
    dllData *dll = dllLookupTable[position];
    while (dll != NULL)
    {
        if(!_wcsicmp(dllName, dll->lpLibFileName))
            goto End;
        dll = dll->nextDll;
    }

    // not found, create a new entry
    dll = new dllData;
    if (dll == NULL)
    {
        DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
        SetLastError(InternalServerError);
        goto End;
    }

    dll->lpLibFileName = new TCHAR[wcslen(dllName) + 1];
    if (dll->lpLibFileName == NULL)
    {
        DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
        delete dll;
        dll = NULL;
        SetLastError(InternalServerError);
        goto End;
    }
    wcscpy(dll->lpLibFileName, dllName);

    // Load the dll
    dll->hModule = LoadLibrary(dllName);
    if (dll->hModule == NULL)
    {
        DBGPRINTF((DBG_CONTEXT, "Cannot load dll %S\n", dllName));
        delete dll->lpLibFileName;
        delete dll;
        dll = NULL;
        SetLastError(BadGateway);
        goto End;
    }

    // Get pointers to the entrypoint functions
    dll->GetExtensionVersion = (BOOL (WINAPI *)(HSE_VERSION_INFO *))GetProcAddress(dll->hModule, "GetExtensionVersion");
    dll->HttpExtensionProc = (DWORD (WINAPI *)(LPEXTENSION_CONTROL_BLOCK))GetProcAddress(dll->hModule, "HttpExtensionProc");
    dll->TerminateExtension = (BOOL (WINAPI *)(DWORD))GetProcAddress(dll->hModule, "TerminateExtension");

    // The GetExtensionVersion and HttpExtensionProc functions are not
    //optional
    if ((dll->GetExtensionVersion == NULL) ||
        (dll->HttpExtensionProc == NULL))
    {
        DBGPRINTF((DBG_CONTEXT, "%S not an ISAPI dll: Entry-point function missing\n", dllName));
        FreeLibrary(dll->hModule);
        delete dll->lpLibFileName;
        delete dll;
        dll = NULL;
        SetLastError(BadGateway);
        goto End;
    }

    // Call GetExtensionVersion, BUGBUG: Dont know what to do with it
    // Maybe add it to some log
    if (!dll->GetExtensionVersion(&dll->pVer))
    {
        DBGPRINTF((DBG_CONTEXT, "GetExtensionVersion returned false, cannot use the dll %S\n", dllName));
        FreeLibrary(dll->hModule);
        delete dll->lpLibFileName;
        delete dll;
        dll = NULL;
        SetLastError(BadGateway);
        goto End;
    }

    // Insert into lookup table so that future requests to the same dll
    // do not have to reload it
    dll->nextDll = dllLookupTable[position];
    dllLookupTable[position] = dll;

End:
    LeaveCriticalSection(&dllTableLock);

    return dll;
}


// All the cleanup to be done when iiswp is terminating.
void IsapiNativeCleanup()
{
    if (IsapiInitialized)
    {
        CleanupDllLookupTable();
        DeleteCriticalSection(&dllTableLock);
        CloseHandle(PROC_TOKEN);
        IsapiInitialized = FALSE;
    }
}


// cleanup of dll lookup table.  Go through the table, looking for valid
// entries, tell those dll's to cleanup, unload them and free corresponding
// data structure
void CleanupDllLookupTable()
{
    EnterCriticalSection(&dllTableLock);

    for (int i=0; i<TABLE_SIZE; i++)
    {
        dllData *dll = dllLookupTable[i];
        while (dll != NULL)
        {
            if (dll->TerminateExtension != NULL)
                dll->TerminateExtension(HSE_TERM_MUST_UNLOAD);
            FreeLibrary(dll->hModule);
            delete dll->lpLibFileName;
            dllData *nextDll = dll->nextDll;
            delete dll;
            dll = nextDll;
        }
        dllLookupTable[i] = NULL;
    }

    LeaveCriticalSection(&dllTableLock);
}


// The GetServerVariable function passed to ISAPI extensions
BOOL WINAPI InternalGetServerVariable(HCONN hConn,
                                      LPSTR lpszVariableName,
                                      LPVOID lpvBuffer,
                                      LPDWORD lpdwSizeofBuffer)
{
    // check if valid identifier
    if ((hConn == NULL) ||
        (lpszVariableName == NULL) ||
        (lpvBuffer == NULL) ||
        (lpdwSizeofBuffer == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    xspmrt::_ISAPINativeCallback *m_pISAPI = ((requestData *)hConn)->m_pISAPI;

    // Metabase related variables, not supported
    if (!strcmp(lpszVariableName, "APPL_MD_PATH") ||
        !strcmp(lpszVariableName, "INSTANCE_ID") ||
        !strcmp(lpszVariableName, "INSTANCE_META_PATH"))
    {
        SetLastError(ERROR_NO_DATA);
        return FALSE;
    }

    LPSTR lpszValue;

    // BUGBUG: added for FP LWS
    if (!strcmp(lpszVariableName, "HTTP_FRONTPAGE_LWS_PATH"))
        m_pISAPI->MapPath("/", &lpszValue);
    else if (!strcmp(lpszVariableName, "HTTP_FRONTPAGE_LWS_SCRIPT_NAME"))
        m_pISAPI->GetServerVariable("SCRIPT_NAME", &lpszValue);
    else if (!strcmp(lpszVariableName, "CONTENT_ENCODING"))
        m_pISAPI->GetServerVariable("CONTENT_TYPE", &lpszValue);
    else
        m_pISAPI->GetServerVariable(lpszVariableName, &lpszValue);

    DBGPRINTF((DBG_CONTEXT, "Var %s=%s\n", lpszVariableName, lpszValue));

    if (lpszValue != NULL)
        if (*lpdwSizeofBuffer > strlen(lpszValue))
        {
            strcpy((LPSTR)lpvBuffer, lpszValue);
            *lpdwSizeofBuffer = strlen(lpszValue) + 1;
        }
        else
        {
            *lpdwSizeofBuffer = strlen(lpszValue) + 1;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }
    else
    {
        SetLastError(ERROR_NO_DATA);
        return FALSE;
    }

    return TRUE;
}


// The ReadClient function passed to ISAPI extensions.  Doesn't do
// anything.  All the request body is supplied to the client at the start.
BOOL WINAPI InternalReadClient(HCONN hConn, LPVOID lpvBuffer, LPDWORD lpdwSize)
{
    if ((hConn == NULL) ||
        (lpvBuffer == NULL) ||
        (lpdwSize == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    *lpdwSize = 0;
    return TRUE;
    // We are not doing async reads.  Providing all data as part of
    // initial call to HttpExtensionProc.  So, no more data now.
}


// The WriteClient function passed to ISAPI extensions.  Does both synchronous
// and asynchronous I/O
BOOL WINAPI InternalWriteClient(HCONN hConn, LPVOID lpvBuffer, LPDWORD lpdwSize, DWORD dwSync)
{
    if ((hConn == NULL) ||
        (lpvBuffer == NULL) ||
        (lpdwSize == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    requestData *req = (requestData *)hConn;
    xspmrt::_ISAPINativeCallback *m_pISAPI = req->m_pISAPI;

    if (dwSync != HSE_IO_ASYNC)
    {
        WaitForSingleObject(req->writeLock, INFINITE);

        m_pISAPI->Write((int)lpvBuffer, *lpdwSize);
        if (*lpdwSize <= 0x1000) // BUGBUG: DBGPRINTF crashes on large prints
            DBGPRINTF((DBG_CONTEXT, "Data written: %s\n", lpvBuffer));
        else
            DBGPRINTF((DBG_CONTEXT, "%d bytes written.\n", *lpdwSize));

        ReleaseSemaphore(req->writeLock, 1, NULL);
    }
    else // if (dwSync == HSE_IO_ASYNC)
    {
        if (req->PFN_HSE_IO_COMPLETION_CALLBACK == NULL)
        {
            DBGPRINTF((DBG_CONTEXT, "No callback registered\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        asyncWriteStr *asyncWriteData = new asyncWriteStr;
        if (asyncWriteData == NULL)
        {
            DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        asyncWriteData->req = req;
        asyncWriteData->bufptr = lpvBuffer;
        asyncWriteData->buflen = *lpdwSize;
        HANDLE asyncWriteThread = CreateThread(NULL,
                                               0,
                                               asyncWriteFunc,
                                               (LPVOID)asyncWriteData,
                                               0,
                                               NULL);
        CloseHandle(asyncWriteThread);
    }
    return TRUE;
}


// The function which does the async Write (in a separate thread).
DWORD WINAPI asyncWriteFunc(LPVOID lpParameter)
{
    asyncWriteStr *asyncWriteData = (asyncWriteStr *)lpParameter;
    requestData *req = asyncWriteData->req;
    xspmrt::_ISAPINativeCallback *m_pISAPI = req->m_pISAPI;

    WaitForSingleObject(req->writeLock, INFINITE);

    m_pISAPI->Write((int)asyncWriteData->bufptr, asyncWriteData->buflen);

    ReleaseSemaphore(req->writeLock, 1, NULL);

    req->PFN_HSE_IO_COMPLETION_CALLBACK(req->lpECB, req->pContext, asyncWriteData->buflen, 0);

    delete asyncWriteData;
    return 0;
}

    
// The ServerSupportFunction passed to ISAPI extensions
// It looks at the particular task requested and performs it
BOOL WINAPI InternalServerSupportFunction(HCONN ConnID,
                                          DWORD dwHSERRequest,
                                          LPVOID lpvBuffer,
                                          LPDWORD lpdwSize,
                                          LPDWORD lpdwDataType)
{
    if (ConnID == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    requestData *req = (requestData *)ConnID;
    xspmrt::_ISAPINativeCallback *m_pISAPI = req->m_pISAPI;

    switch(dwHSERRequest)
    {
    case HSE_APPEND_LOG_PARAMETER:
        m_pISAPI->AppendToLog((LPSTR)lpvBuffer);
        return TRUE;

    case HSE_REQ_ABORTIVE_CLOSE:
        return TRUE;

    case HSE_REQ_ASYNC_READ_CLIENT:
        // No async reads supported right now
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    case HSE_REQ_CLOSE_CONNECTION:
        m_pISAPI->Close();
        return TRUE;

    case HSE_REQ_DONE_WITH_SESSION:
        if (req->isPending)
        {
            m_pISAPI->Complete();
            CleanupReqStrs(req);
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        return TRUE;

    case HSE_REQ_GET_CERT_INFO_EX:
        // BUGBUG: TODO
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    case HSE_REQ_GET_IMPERSONATION_TOKEN:
        if (lpvBuffer == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        HANDLE token;
        m_pISAPI->UserToken((int *)&token);
        if (token != NULL)
            *(PHANDLE)lpvBuffer = token;
        else
            *(PHANDLE)lpvBuffer = PROC_TOKEN;
        return TRUE;

    case HSE_REQ_GET_SSPI_INFO:
        // BUGBUG: TODO
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    case HSE_REQ_IO_COMPLETION:
        if (lpvBuffer == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        req->PFN_HSE_IO_COMPLETION_CALLBACK =
            (void (WINAPI *)(LPEXTENSION_CONTROL_BLOCK, PVOID, DWORD, DWORD))
            lpvBuffer;
        req->pContext = lpdwDataType;
        return TRUE;

    case HSE_REQ_IS_KEEP_CONN:
        if (lpvBuffer == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        m_pISAPI->KeepAlive((BOOL *)lpvBuffer);
        return TRUE;

    case HSE_REQ_MAP_URL_TO_PATH:
    case HSE_REQ_MAP_URL_TO_PATH_EX:
        {
            if ((lpvBuffer == NULL) ||
                (lpdwSize == NULL) ||
                (lpdwDataType == NULL))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            LPSTR lpszValue;
            m_pISAPI->MapPath((LPSTR)lpvBuffer, &lpszValue);
            if (*lpdwSize > strlen(lpszValue))
            {
                strcpy((LPSTR)lpvBuffer, lpszValue);
                *lpdwSize = strlen(lpszValue) + 1;
                
                LPHSE_URL_MAPEX_INFO mapInfo = (LPHSE_URL_MAPEX_INFO) lpdwDataType;
                if (strlen(lpszValue) < MAX_PATH)
                    strcpy(mapInfo->lpszPath, lpszValue);
                else
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return FALSE;
                }
                // BUGBUG: Need to populate dwFlags by actually finding
                // permissions on this URL
                mapInfo->dwFlags = 0;
                mapInfo->cchMatchingPath = 0;
                mapInfo->cchMatchingURL = 0;
                mapInfo->dwReserved1 = 0;
                mapInfo->dwReserved2 = 0;
                return TRUE;
            }
            else
            {
                *lpdwSize = strlen(lpszValue) + 1;
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }
        }
        
    case HSE_REQ_REFRESH_ISAPI_ACL:
        // BUGBUG: TODO
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    case HSE_REQ_SEND_URL_REDIRECT_RESP:
    case HSE_REQ_SEND_URL:
        if (lpvBuffer == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        m_pISAPI->Redirect((LPSTR)lpvBuffer);
        return TRUE;

    case HSE_REQ_SEND_RESPONSE_HEADER:
        if ((lpvBuffer == NULL) ||
            (lpdwDataType == NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        // BUGBUG: deprecated in IIS 5.0, but added on because FP uses it
        WaitForSingleObject(req->writeLock, INFINITE);
        m_pISAPI->SendStatus((LPSTR)lpvBuffer);
        m_pISAPI->SendHeaders((LPSTR)lpdwDataType);
        ReleaseSemaphore(req->writeLock, 1, NULL);
        return TRUE;

    case HSE_REQ_SEND_RESPONSE_HEADER_EX:
        {
            if (lpvBuffer == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            LPHSE_SEND_HEADER_EX_INFO headers = (LPHSE_SEND_HEADER_EX_INFO) lpvBuffer;
            WaitForSingleObject(req->writeLock, INFINITE);

            m_pISAPI->SendStatus((LPSTR)headers->pszStatus);
            m_pISAPI->SendHeaders((LPSTR)headers->pszHeader);
            // BUGBUG: below closes the connection immediately, we want to
            // be able to close connection at the end of the request
            // if (!headers->fKeepConn)
            //     m_pISAPI->Close();

            ReleaseSemaphore(req->writeLock, 1, NULL);
            return TRUE;
        }

    case HSE_REQ_TRANSMIT_FILE:
        if (lpvBuffer == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        HSE_TF_INFO *fileInfo = (HSE_TF_INFO *)lpvBuffer;
        if ((req->PFN_HSE_IO_COMPLETION_CALLBACK == NULL) &&
           (fileInfo->pfnHseIO == NULL))
        {
            DBGPRINTF((DBG_CONTEXT, "No callback registered\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        xFileStr *xFileData = new xFileStr;
        if (xFileData == NULL)
        {
            DBGPRINTF((DBG_CONTEXT, "Out of memory\n"));
            return FALSE;
        }
        xFileData->req = req;
        xFileData->fileInfo = fileInfo;
        HANDLE xFileThread = CreateThread(NULL,
                                          0,
                                          xFileFunc,
                                          (LPVOID)xFileData,
                                          0,
                                          NULL);
        CloseHandle(xFileThread);
        return TRUE;
    }
    DBGPRINTF((DBG_CONTEXT, "Unknown Server Request\n"));
    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

DWORD WINAPI xFileFunc(LPVOID lpParameter)
{
    xFileStr *xFileData = (xFileStr *) lpParameter;
    HSE_TF_INFO *fileInfo = xFileData->fileInfo;
    requestData *req = xFileData->req;
    xspmrt::_ISAPINativeCallback *m_pISAPI = req->m_pISAPI;

    WaitForSingleObject(req->writeLock, INFINITE);

    m_pISAPI->SendStatus((LPSTR)fileInfo->pszStatusCode);
    m_pISAPI->SendHeaders((LPSTR)fileInfo->pHead);

    // a value of 0 means send the entire file.  I don't know if putting
    // infinite will work.
    // if (fileInfo->BytesToWrite == 0)
    //    fileInfo->BytesToWrite = INFINITE;
    m_pISAPI->WriteFile(fileInfo->hFile,
                        fileInfo->Offset,
                        fileInfo->BytesToWrite);

    m_pISAPI->Write((int)fileInfo->pTail, fileInfo->TailLength);
    // BUGBUG: this will disconnect right now before sending the data
    //if (fileInfo->dwFlags & HSE_IO_DISCONNECT_AFTER_SEND)
    //    m_pISAPI->Close();

    ReleaseSemaphore(req->writeLock, 1, NULL);

    // BUGBUG: No way to tell currently how many bytes were written
    DWORD cbIO = 0;
    if (fileInfo->pfnHseIO != NULL)
        fileInfo->pfnHseIO(req->lpECB, fileInfo->pContext, cbIO, 0);
    else
        req->PFN_HSE_IO_COMPLETION_CALLBACK(req->lpECB, req->pContext, cbIO, 0);
    return 0;
}

// Entrypoint to enable FrontPage Light Weight Server
BOOL __cdecl FPIsLWSEnabled(LPEXTENSION_CONTROL_BLOCK *lpECB)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\ipm_io_c.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ipm_io_c.hxx

Abstract:

    This module contains classes for doing async io in the
    worker process.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include "precomp.hxx"
#include "ipm.hxx"  
#include "ipm_io_c.hxx"


/**
 *  IPMOverlappedCompletionRoutine()
 *  Callback function provided in BindIoCompletionCallback.
 *  This function is called by NT thread pool.
 *
 *  dwErrorCode                 Error Code
 *  dwNumberOfBytesTransfered   Number of Bytes Transfered
 *  lpOverlapped                Overlapped structure
 */
VOID
WINAPI
IPMOverlappedCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
{
    IO_CONTEXT_C * pIoContext = NULL;
    DWORD          errorHack = RtlNtStatusToDosError(dwErrorCode);
    HRESULT        hr = HRESULT_FROM_WIN32(errorHack);
    
    //
    // get the context object
    //
    if (lpOverlapped != NULL)
    {
        pIoContext = CONTAINING_RECORD(lpOverlapped, 
                                    IO_CONTEXT_C,
                                    m_Overlapped);
    }
    if ( pIoContext != NULL) 
    { 
        WpTrace(WPIPM, (
            DBG_CONTEXT,
            "\n    IPMOverlappedCompletionRoutine(%d, %x, pIoContext %x) %s\n",
            dwNumberOfBytesTransfered,
            dwErrorCode,
            pIoContext,
            pIoContext->m_IoType == IPM_IO_WRITE ? "WRITE" : "READ"
            ));
        
        //
        // do the notification
        //
        switch (pIoContext->m_IoType) {
        case IPM_IO_WRITE:
            pIoContext->m_pContext->NotifyWriteCompletion(
                pIoContext->m_pv,
                dwNumberOfBytesTransfered,
                hr
                );
            break;

        case IPM_IO_READ:
            pIoContext->m_pContext->NotifyReadCompletion(
                pIoContext->m_pv,
                dwNumberOfBytesTransfered,
                hr
                );
            break;

        default:
            DBG_ASSERT(FALSE);
            break;
        }

        delete pIoContext;
    } 

    return;
}

/**
 *
 *  Routine Description:
 *   
 *   
 *  Creates an i/o handler
 *   
 *  Arguments:
 *
 *   hPipe           - A handle to the named pipe to be handled
 *   ppPipeIoHandler - receives a pointer to the handler on success
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
IO_FACTORY_C::CreatePipeIoHandler(
    IN  HANDLE             hPipe,
    OUT PIPE_IO_HANDLER ** ppPipeIoHandler
    )
{
    HRESULT        hr = S_OK;
    IO_HANDLER_C * pHandler;
    //
    // create the object
    //

    pHandler = new IO_HANDLER_C(hPipe);
    
    if (pHandler) 
    {
        BOOL           fBind;
        //
        // bind handle to completion port
        //
        
        fBind = BindIoCompletionCallback(
                        pHandler->GetAsyncHandle(),        
                        IPMOverlappedCompletionRoutine,        
                        0 );
        if (fBind) {
            *ppPipeIoHandler = pHandler;
            InterlockedIncrement(&m_cPipes);

            pHandler->Reference();

            WpTrace(WPIPM, (
                DBG_CONTEXT,
                "Created IO_HANDLER_C (%x) - m_cPipes = %d\n",
                pHandler,
                m_cPipes
                ));                
        } 
        else 
        {
            // Error in XspBindIoCompletionCallback()
            LONG   rc = GetLastError();
            delete pHandler;
            pHandler = NULL;

            
            WpTrace(WPIPM, (DBG_CONTEXT, "Create IO_HANDLER_C failed, %d\n", rc));
            hr = HRESULT_FROM_WIN32(rc);
        }
    } 
    else 
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hr;
}


/**
 *
 *  Routine Description:
 *
 *   Closes an i/o handler
 *   
 *   Arguments:
 *
 *   pPipeIoHandler - pointer to the handler to be closed
 *   
 *   Return Value:
 *
 *   HRESULT
 */
HRESULT
IO_FACTORY_C::ClosePipeIoHandler(
    IN PIPE_IO_HANDLER * pPipeIoHandler
    )
{
    IO_HANDLER_C * pIoHandler = (IO_HANDLER_C *) pPipeIoHandler;
    LONG           cPipes;

    if (pIoHandler) {
        cPipes = InterlockedDecrement(&m_cPipes);

        WpTrace(WPIPM, (
            DBG_CONTEXT,
            "Closed IO_HANDLER_C (%x) - m_cPipes = %d\n",
            pPipeIoHandler,
            m_cPipes
            ));

        DBG_ASSERT( cPipes >= 0 );
        
        pIoHandler->Dereference();

        return S_OK;
    } else {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
}


/**
 * Disconnect()
 * Routine Description:
 *
 *   Disconnects the named pipe
 *   
 * Arguments:
 *
 *   None.
 *
 * Return Value:
 *
 *   HRESULT
 *
 */
HRESULT
IO_HANDLER_C::Disconnect(
    VOID
    )
{
    HRESULT hr = S_OK;

    CheckSignature();

    if (!CloseHandle(GetHandle())) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


/**
 *
 *Routine Description:
 *
 *    Writes data to the pipe
 *    
 *Arguments:
 *
 *    pContext - the context to be notified on completion
 *    pv       - a parameter passed to the context
 *    pBuff    - the data to send
 *    cbBuff   - number of bytes in the data
 *    
 *Return Value:
 *
 *    HRESULT
 */
HRESULT
IO_HANDLER_C::Write(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN const BYTE * pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    IO_CONTEXT_C * pIoContext;

    CheckSignature();

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_C;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_WRITE;

        memset(&pIoContext->m_Overlapped, 0, sizeof(OVERLAPPED));

        Reference();
        //
        // write to the pipe
        //
        hr = IpmWriteFile(
                    GetHandle(),
                    (PVOID) pBuff,
                    cbBuff,
                    &pIoContext->m_Overlapped
                    );

        if (FAILED(hr))
        {
            Dereference();              
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    return hr;
}


/**
 *
 *Routine Description:
 *
 *    Reads data from the pipe
 *    
 *Arguments:
 *
 *    pContext - the context to be notified on completion
 *    pv       - a parameter passed to the context
 *    pBuff    - the buffer that receives the data
 *    cbBuff   - size of the buffer
 *    
 *Return Value:
 *
 *    HRESULT
 */
HRESULT
IO_HANDLER_C::Read(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN BYTE *       pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    IO_CONTEXT_C * pIoContext;

    CheckSignature();

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_C;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_READ;

        memset(&pIoContext->m_Overlapped, 0, sizeof(OVERLAPPED));

        Reference();
        //
        // read from the pipe
        //
        hr = IpmReadFile(
                    GetHandle(),
                    pBuff,
                    cbBuff,
                    &pIoContext->m_Overlapped
                    );

        if (FAILED(hr))
        {
            Dereference();
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    return hr;
}

//
// end ipm_io_c.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\sources.inc ===
PROJECT_ROOT=.
!INCLUDE .\FIND_ROOT.INC
!INCLUDE $(PROJECT_ROOT)\PLACE.INC

!INCLUDE $(IISBASEDIR)\ICEPICK.INC

WIN32_WINNT_VERSION=0x0500

TARGETNAME=iiswp
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM

USE_MSVCRT=1

CAT42INCLUDES=$(IISBASEDIR)\import\inc

CAT42LIBS=$(IISBASEDIR)\import\lib\*\cat.lib   \


INCLUDES=.\;..\;$(INCLUDES);            \
         ..\..\inc;                     \
         ..\..\..\inc;                  \
         ..\..\webserver\comxbin;       \
         $(CAT42INCLUDES)

LINKER_FLAGS = $(LINKER_FLAGS) /DEF:..\appwp.def

C_DEFINES=-DUNICODE -D_UNICODE


ULLIBS  =                                                       \
         $(IISBASEDIR)\lib\*\ulapi.lib                          \


SOURCES=                            \
            ..\iiswp.rc                \
            ..\controlchannel.cxx      \
            ..\wpconfig.cxx            \
            ..\wpcontext.cxx           \
            ..\apppool.cxx             \
            ..\workerrequest.cxx       \
            ..\wreqpool.cxx            \
            ..\ipm_io_c.cxx            \
            ..\wpipm.cxx               \
            ..\iiswp.cxx               \
            ..\CgiNative.cxx           \
            ..\ISAPINative.cxx         \
            ..\DateTime.cxx            \
            ..\DAVPropBag.cxx          \

UMTYPE=console
UMENTRY=wmain


TARGETLIBS =                                                    \
        $(SDK_LIB_PATH)\ntdll.lib                               \
        $(SDK_LIB_PATH)\kernel32.lib                            \
        $(SDK_LIB_PATH)\user32.lib                              \
        $(SDK_LIB_PATH)\ole32.lib                               \
        $(SDK_LIB_PATH)\oleaut32.lib                            \
        $(SDK_LIB_PATH)\uuid.lib                                \
        $(IISBASEDIR)\lib\*\iisutil.lib                         \
        $(IISBASEDIR)\lib\*\ipm.lib                             \
        $(ULLIBS)                                               \
        $(CAT42LIBS)



!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\test\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\workerrequest.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       WorkerRequest.cxx

   Abstract:
       Defines the functions for UL_NATIVE_REQUEST object

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    (Porting)

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

//
// Header file required form _alloca
//

#include <malloc.h>
#include <httpext.h>

//
// Need the worker context so that we can flush UL cache items in
// FlushUlCache()
//

extern WP_CONTEXT *     g_pwpContext;

/********************************************************************++
Global Entry Points for callback from XSP
++********************************************************************/

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

/********************************************************************++
++********************************************************************/

//
// Handy inline functions
//

inline LONG ReferenceRequest(UL_NATIVE_REQUEST * pnreq)
{
    LONG refs;

    refs = pnreq->AddRef();

    if (g_pRequestTraceLog) {
        WriteRefTraceLog(g_pRequestTraceLog, refs, pnreq);
    }
    
    return refs;
}

inline LONG DereferenceRequest(UL_NATIVE_REQUEST * pnreq)
{
    LONG refs;

    refs = pnreq->Release();

    if (g_pRequestTraceLog) {
        WriteRefTraceLog(g_pRequestTraceLog, refs, pnreq);
    }

    if ( !refs )
    {
        // BUGBUG: pManaged turns out to be NULL here during shutdown
        WP_CONFIG* config = pnreq->QueryWPContext()->QueryConfig();
        xspmrt::_ULManagedWorker* pManaged = config->ChooseWorker(pnreq->m_pbRequest);
        if (pManaged != NULL)
            pManaged->Release();
        delete pnreq;
    }
    
    return refs;
}

dllexp
ULONGLONG
GetUlResponseBuffer( ULONGLONG   NativeContext,
                     int         nChunks,
                     int         nUnknownHeaders,
                     bool        fHeadersSent
                   )
{
    PUL_NATIVE_REQUEST pReq = (PUL_NATIVE_REQUEST) NativeContext;

    return (ULONGLONG)(pReq->GetResponseBuffer( nChunks,
                                                nUnknownHeaders,
                                                fHeadersSent)) ;
}

/********************************************************************++
++********************************************************************/

dllexp
int
SendUlHttpResponse( ULONGLONG           NativeContext,
                    UL_HTTP_REQUEST_ID  RequestID,
                    int                 Flags,
                    int                 nChunks,
                    bool                fAsync,
                    ULONGLONG           ManagedContext,
                    PUL_CACHE_POLICY    pCachePolicy
                  )
{
    ULONG   rc;

    PUL_NATIVE_REQUEST pReq = (PUL_NATIVE_REQUEST) NativeContext;

    rc = pReq->SendHttpResponse(RequestID,
                                (ULONG)Flags,
                                (ULONG)nChunks,
                                fAsync,
                                ManagedContext,
                                pCachePolicy
                                );

    return rc;
}

/********************************************************************++
++********************************************************************/

dllexp
int
SendUlEntityBody( ULONGLONG           NativeContext,
                  UL_HTTP_REQUEST_ID  RequestID,
                  int                 Flags,
                  int                 nChunks,
                  bool                fAsync,
                  ULONGLONG           ManagedContext
                )
{
    ULONG   rc;

    PUL_NATIVE_REQUEST pReq = (PUL_NATIVE_REQUEST) NativeContext;

    rc = pReq->SendEntityBody(RequestID,
                              (ULONG)Flags,
                              (ULONG)nChunks,
                              fAsync,
                              ManagedContext
                              );

    return rc;
}

/********************************************************************++
++********************************************************************/

dllexp
int
ReceiveUlEntityBody(ULONGLONG           NativeContext,
                    UL_HTTP_REQUEST_ID  RequestID,
                    int                 Flags,
                    ULONGLONG           pBuffer,
                    int                 cbBufferLength,
                    bool                fAsync,
                    ULONGLONG           ManagedContext
                )
{
    int   BytesRead;

    PUL_NATIVE_REQUEST pReq = (PUL_NATIVE_REQUEST) NativeContext;

    BytesRead = pReq->ReceiveEntityBody(RequestID,
                                        (ULONG)Flags,
                                        (PUCHAR)pBuffer,
                                        (ULONG)cbBufferLength,
                                        fAsync,
                                        ManagedContext
                                        );

    return BytesRead;
}

/********************************************************************++
++********************************************************************/

dllexp
void
IndicateUlRequestCompleted(ULONGLONG           NativeContext,
                           UL_HTTP_REQUEST_ID  RequestID,
                           bool                fHeadersSent,
                           bool                fCloseConnection)
{
    PUL_NATIVE_REQUEST pReq = (PUL_NATIVE_REQUEST) NativeContext;

    pReq->IndicateRequestCompleted(RequestID,
                                   fHeadersSent,
                                   fCloseConnection
                                  );
}

/********************************************************************++
/**
 *  Flush a specific URL from the UL cache
 */
//++********************************************************************/

dllexp
void
FlushUlCache( WCHAR* pwszUrl )
{
    UlFlushResponseCache( g_pwpContext->GetAsyncHandle(),
                          pwszUrl,
                          0,
                          NULL );
}

//********************************************************************++
/**
 *  static memeber of UL_NATIVE_REQUEST
 */
//++********************************************************************

ULONG UL_NATIVE_REQUEST::sm_NumRequestsServed = 0;
ULONG UL_NATIVE_REQUEST::sm_RestartCount = 0;
LONG UL_NATIVE_REQUEST::sm_RestartMsgSent = 0;

//********************************************************************++
/**
 *  Member functions of UL_NATIVE_REQUEST
 */
//++********************************************************************

//********************************************************************++
/**
 *  Constructor of UL_NATIVE_REQUEST
 *  @param  pReqPool       Pointer to a request pool.
 *
 */
//++********************************************************************

UL_NATIVE_REQUEST::UL_NATIVE_REQUEST( IN UL_NATIVE_REQUEST_POOL * pReqPool)
  : m_pbRequest         ( (UCHAR *)m_Buffer ),
    m_cbRequest         ( sizeof(m_Buffer) ),
    m_signature         ( UL_NATIVE_REQUEST_SIGNATURE ),
    m_pReqPool          ( pReqPool ),
    m_nRefs             ( 1 )
{
    InitializeListHead( &m_lRequestEntry);

    Reset();

    WpTrace(NREQ, (
        DBG_CONTEXT,
        "Created worker request (%p)\n",
        this
        ));

    DBG_ASSERT( pReqPool != NULL);

} // UL_NATIVE_REQUEST::UL_NATIVE_REQUEST()

/********************************************************************++
++********************************************************************/

/**
 *  Destructor of UL_NATIVE_REQUEST.
 *
 */
UL_NATIVE_REQUEST::~UL_NATIVE_REQUEST(void)
{
    DBG_ASSERT( UL_NATIVE_REQUEST_SIGNATURE == m_signature );

    if (!IsListEmpty( &m_lRequestEntry))
    {
        DBG_ASSERT( m_pReqPool);

        //
        // remove from the list if it not already done so.
        //

        m_pReqPool->RemoveRequestFromList( this);
        m_pReqPool = NULL;
    }

    DBG_ASSERT( m_nRefs == 0);

    m_signature = ( UL_NATIVE_REQUEST_SIGNATURE_FREE);

} // UL_NATIVE_REQUEST::~UL_NATIVE_REQUEST()

//********************************************************************++

/**
 *  Reset the UL_NATIVE_REQUEST after the completion of a request.  After the reset,
 *  the same UL_NATIVE_REQUEST will be recycled and used to process the next request.
 *
 */

//++********************************************************************

void
UL_NATIVE_REQUEST::Reset()
{
    m_ExecState         = NREQ_FREE;
    m_IOState           = NRIO_NONE;
    m_ReadState         = NREADREQUEST_NONE;

    m_ManagedCallbackContext = 0;
    m_fCompletion       = FALSE;

    m_cbRead            = 0;
    m_cbWritten         = 0;
    m_cbAsyncIOData     = 0;
    m_dwAsyncIOError    = NO_ERROR;

    ZeroMemory( &m_overlapped, sizeof(m_overlapped));

} // UL_NATIVE_REQUEST::Reset()

//********************************************************************++

/**
 *
 *   Routine Description:
 * This function is the switch board for processing the current request.
 * The UL_NATIVE_REQUEST object employs a state machine for handling the
 * variuos stages of the operation. This function examines the state
 * and appropriately takes the necessary actions to move the request
 * from one state to another to eventually complete the processing of
 * request.
 *
 *  Arguments:
 * cbData - count of bytes of data handled in last IO operation
 * dwError - Error if any during the processing of request
 * lpo    - pointer to the overlapped structure supplied for handling
 *             this request.
 *  Returns:
 *  NO_ERROR on successful return.
 *
 *  If there is an error, this function sends out error message to the
 *    client and derferences the object preparing for cleanup.
 *
 */
//++********************************************************************

ULONG
UL_NATIVE_REQUEST::DoWork( IN DWORD cbData,
                           IN DWORD dwError,
                           IN LPOVERLAPPED lpo
                        )
{
    ULONG               rc              = 0;
    UL_HTTP_REQUEST     *pULRequest     = NULL;
    NREQ_EXEC_STATUS    Status          = NSTATUS_NEXT;
    BOOL                fDidProcessing  = FALSE;

#if DBG
    DBG_ASSERT( (lpo == &m_overlapped));
#else
    UNREFERENCED_PARAMETER(lpo);
#endif

    ReferenceRequest( this );

    if ( NRIO_NONE != m_IOState)
    {
        DBG_ASSERT(ReferenceCount() > 1);

        m_cbAsyncIOData    = cbData;
        m_dwAsyncIOError   = dwError;

        if (NRIO_READ == m_IOState)
        {
            m_cbRead += cbData;
        }
        else
        {
            m_cbWritten += cbData;
        }

        m_IOState = NRIO_NONE;

        //
        // Dereference the request for Async IO completion.
        //
        
        DereferenceRequest( this );
    }

    //
    // Run loop till somebody indicates PENDING status
    //

ContinueStateMachine:

    fDidProcessing = FALSE;

    while(NSTATUS_NEXT == Status)
    {
        switch (m_ExecState)
        {
        case NREQ_FREE:
            {

                // Do work here to enforce that the number of requests we are going
                // to serve does not exceeds the total requests configuered for
                // this worker process.
                // Reset() issues Async Read IO to accept new requests.
                // TODO:

                // sm_RestartCount == 0, indicates the Time-to-Live count feature
                // is disable.  Live forever.
                //
                if (!QueryWPContext()->IsInShutdown())
                {
                    if ((sm_RestartCount > 0) &&
                        (sm_NumRequestsServed >= sm_RestartCount))
                    {
                        //
                        // It may be time to send the "restart count
                        // reached" message. Determine if this thread
                        // is the lucky one that gets to send it.
                        //

                        if (NeedToSendRestartMsg())
                        {
                            QueryWPContext()->SendMsgToAdminProcess(
                                IPM_WP_RESTART_COUNT_REACHED
                                );
                        }

                        //
                        // Fall through to the normal processing case
                        // and continue handling requests. The admin
                        // process will eventually ask us to shutdown.
                        //
                    }

                    Reset();
                    m_ExecState = NREQ_READ;
                }
                else
                {
                    Reset();
                    m_ExecState = NREQ_SHUTDOWN;
                }

            }
            break;

        case NREQ_READ:
            {
                Status = DoRead();
            }
            break;

        case NREQ_PROCESS:
            {
                WP_IDLE_TIMER*   pTimer = QueryWPContext()->QueryIdleTimer();
                // if the idle timer switch is not provided in the command line,
                // then, no idle timer will be created.
                if (pTimer)
                    {
                        pTimer->ResetCurrentIdleTick();
                    }

                Status = DoProcessRequest();
                fDidProcessing = TRUE;
            }
            break;

        case NREQ_SHUTDOWN:
            {
                DereferenceRequest(this);
                Status = NSTATUS_SHUTDOWN;
            }
            break;
            
        case NREQ_ERROR:
        default:
            {
                //
                // Increment the Number of Requests been served before we sets the
                // native request object to free state.
                //
                InterlockedIncrement((PLONG)&sm_NumRequestsServed);
                m_ExecState = NREQ_FREE;
            }
            break;
        }
    }
    
    if ( DereferenceRequest( this ) == 1 )
    {
        //
        // Proceed to reading the next request, if 
        // a) The last thing we did on this thread was processing AND
        // b) The reference count of the request is 1 (i.e. finished with)
        //
   
        if ( fDidProcessing )
        { 
            //
            // Now reset the state machine and read next request
            //
            
            ReferenceRequest( this );
            InterlockedIncrement((PLONG)&sm_NumRequestsServed);
            m_ExecState = NREQ_FREE;
            Status = NSTATUS_NEXT;
            goto ContinueStateMachine;
        }
    }
    
    return NO_ERROR;

} // UL_NATIVE_REQUEST::DoWork()

/********************************************************************++
--********************************************************************/

NREQ_EXEC_STATUS
UL_NATIVE_REQUEST::DoRead()
{

    NREQ_EXEC_STATUS    Status      = NSTATUS_NEXT;
    UL_HTTP_REQUEST_ID  reqId       = UL_NULL_ID;
    ULONG               cbData, rc;

    if ( NREADREQUEST_NONE == m_ReadState)
    {
        //
        // Ask UL for any request. This may complete synchronously
        //
        m_pReqPool->IncIdleRequests();
        
        cbData = 0;
        rc = ReadHttpRequest(&cbData, reqId);

        if (rc != ERROR_IO_PENDING) {
            m_pReqPool->DecIdleRequests();
        }
    }
    else
    {
        //
        // Async IO Completion Callback
        //
        m_pReqPool->DecIdleRequests();    

        QueryAsyncIOStatus(&cbData, &rc);


        WpTrace(NREQ, (
            DBG_CONTEXT,
            "\n    (%p)->DoRead() Completion cbData = %d, rc = 0x%x\n",
            this,
            cbData,
            rc
            ));
    }

    if (ERROR_MORE_DATA == rc)
    {

        //
        // DO NOT use QueryRequestID here because we have not
        // set the state to WRREADREQUEST_COMPLETED
        //

        reqId = QueryHttpRequest()->RequestId;

        WpTrace(NREQ, (
            DBG_CONTEXT,
            "\n    (%p)->DoRead() need bigger buffer for req %I64x\n",
            this,
            reqId
            ));

        //
        // cbData contains the buffer size needed to get the request.
        //

        if (m_pbRequest != m_Buffer)
        {
            delete [] m_pbRequest;
            m_cbRequest = 0;
        }

        m_pbRequest = new UCHAR[cbData];

        if ( NULL != m_pbRequest)
        {
            m_pReqPool->IncIdleRequests();
            
            m_cbRequest = cbData;
            rc = ReadHttpRequest(&cbData, reqId);

            if (rc != ERROR_IO_PENDING) {
                m_pReqPool->DecIdleRequests();
            }
        }
        else
        {
            rc = ERROR_OUTOFMEMORY;
        }
    }

    if (ERROR_IO_PENDING == rc)
    {
        Status = NSTATUS_PENDING;
    }
    else if (NO_ERROR == rc)
    {
        m_ReadState = NREADREQUEST_COMPLETED;
        m_ExecState = NREQ_PROCESS;
    }
    else if (QueryWPContext()->IsInShutdown())
    {
        //
        // NOTE: We need to check the return value here as well.
        // BUGBUG: Currently the UL returns 0xc0000120 (NT status code) directly
        // from the kernel mode.  Need to verify UL fixed this. LeiJin 4/17/1999
        m_ExecState = NREQ_SHUTDOWN;
    }
    else
    {
        m_ExecState = NREQ_ERROR;
    }

    return Status;
}

/********************************************************************++
--********************************************************************/

NREQ_EXEC_STATUS
UL_NATIVE_REQUEST::DoProcessRequest()
{

    NREQ_EXEC_STATUS Status = NSTATUS_NEXT;

    WP_CONFIG* config = QueryWPContext()->QueryConfig();
    xspmrt::_ULManagedWorker* pManaged = config->ChooseWorker(m_pbRequest);
    if (pManaged == NULL)
    {
        // This usually can't happen, unless we've manually launched the worker
        // process and sent a request that didn't match any of our bindings.
        // BUGBUG! Perhaps we should just terminate the process here... I don't
        // know what kung fu needs to be done to get the worker process back into
        // a usable state.
        m_ExecState = NREQ_SHUTDOWN;
        return Status;
    }
    
    //
    // If we have no managed context, then we must be calling XSP for the 
    // first time (for this request).
    //

    if ( !m_fCompletion )
    {
        // Reference it first corresponding the request starting.
        // Will be Dereferenced when Request is indicated to be complete
        ReferenceRequest( this );

        // Reference it again corresponding to this call.  Gets Dereferenced
        // right below
        ReferenceRequest( this );

        pManaged->DoWork( (ULONGLONG)this, (long) m_pbRequest);

        DereferenceRequest( this );        
    }
    else
    {
        m_fCompletion = FALSE;
        
        //
        // This is an IO Completion callback for Async IO
        //

        DWORD   cbData, dwError;

        QueryAsyncIOStatus(&cbData, &dwError);

        ReferenceRequest( this );
        
        pManaged->CompletionCallback(m_ManagedCallbackContext,
                                     cbData,
                                     dwError);
       
        DereferenceRequest( this );

    }

    return NSTATUS_PENDING;

}   // UL_NATIVE_REQUEST::DoProcessRequest()



/********************************************************************++

Routine Description:
    Submits read operation for the worker request.
    This is used for reading in the headers only at the start of requests.
    It uses the internal buffers maintained in the UL_NATIVE_REQUEST object
    and posts an asynchronous read operation.

Arguments:
    None

Returns:
    ULONG

--********************************************************************/

ULONG
UL_NATIVE_REQUEST::ReadHttpRequest( DWORD *             pcbRequiredLen,
                                    UL_HTTP_REQUEST_ID  reqId
                                  )
{
    ULONG               rc;

    DBG_ASSERT( m_pwpContext != NULL);
    DBG_ASSERT( m_pbRequest != NULL);
    DBG_ASSERT( pcbRequiredLen != NULL );

    //
    // Check if there is already IO pending.
    //

    if ( NRIO_NONE != m_IOState)
    {
        WpTrace(NREQ, (
            DBG_CONTEXT,
            "\n(%p)->ReadHttpRequest(len = %d, reqId = %I64x)\n"
            "   returning ERROR_ALREADY_WAITING\n",
            this,
            *pcbRequiredLen,
            reqId
            ));

        return ERROR_ALREADY_WAITING;
    }

    //
    // Bump up the reference count before making an IO request
    //

    ReferenceRequest(this);
    m_IOState = NRIO_READ;

    //
    // Submit async read operation for request.
    // Use overlapped for async reads.
    //

    m_ReadState = NREADREQUEST_ISSUED;

    rc = UlReceiveHttpRequest(
            m_pwpContext->GetAsyncHandle(),
            reqId,
            UL_RECEIVE_REQUEST_FLAG_COPY_BODY,
            (PUL_HTTP_REQUEST) m_pbRequest,
            m_cbRequest,
            pcbRequiredLen,
            &m_overlapped
            );

    if (ERROR_IO_PENDING != rc)
    {
        WpTrace(NREQ, (
            DBG_CONTEXT,
            "\n(%p)->ReadHttpRequest(len = %d, reqId = %I64x)\n"
            "   UlReceiveHttpRequest returned 0x%x instead of pending\n",
            this,
            *pcbRequiredLen,
            reqId,
            rc
            ));


        //
        // The read completed synchronously or there was an error.
        // If it was not an error, adjust the ref count immediately.
        //

        m_IOState = NRIO_NONE;
        DereferenceRequest( this ); 
    }

    //
    // Update counters
    //

    if (NO_ERROR == rc)
    {
        m_cbRead += *pcbRequiredLen;
    }

    return (rc);

} // UL_NATIVE_REQUEST::ReadHttpRequest()

/********************************************************************++
--********************************************************************/

PVOID
UL_NATIVE_REQUEST::GetResponseBuffer(int    nChunks,
                                     int    nUnknownHeaders,
                                     bool   fHeadersSent
                                    )
{
    DWORD cbTotal  = 0;

    if ( !fHeadersSent)
    {
        cbTotal = sizeof(UL_HTTP_RESPONSE) +
                  nUnknownHeaders * sizeof(UL_UNKNOWN_HTTP_HEADER);
    }

    cbTotal +=  nChunks * sizeof(UL_DATA_CHUNK);

    if (m_buffResponse.QuerySize() < cbTotal )
    {
        if ( !m_buffResponse.Resize(cbTotal))
        {
            return NULL;
        }
    }

    return m_buffResponse.QueryPtr();
}

/********************************************************************++
--********************************************************************/

ULONG
UL_NATIVE_REQUEST::SendHttpResponse( UL_HTTP_REQUEST_ID RequestID,
                                     ULONG              Flags,
                                     ULONG              nChunks,
                                     bool               fAsync,
                                     ULONGLONG          ManagedContext,
                                     PUL_CACHE_POLICY   pCachePolicy
                                   )
{

    ULONG   rc;

    //
    // Check if there is already IO pending.
    //

    if ( NRIO_NONE != m_IOState)
    {
        return ERROR_ALREADY_WAITING;
    }

    //
    // Pull out the various pointers from the buffer
    //

    PUL_DATA_CHUNK      pChunk      = NULL;
    PUL_HTTP_RESPONSE   pResponse   = (PUL_HTTP_RESPONSE) m_buffResponse.QueryPtr();

    ULONG               cbBytesSent = 0;
    LPOVERLAPPED        pOverlapped = fAsync ? (&m_overlapped) : NULL;

    if ( nChunks)
    {
        pChunk = (PUL_DATA_CHUNK)(
                    ((PBYTE)pResponse) +
                    sizeof(UL_HTTP_RESPONSE)  +
                    (pResponse->Headers.UnknownHeaderCount * sizeof(UL_UNKNOWN_HTTP_HEADER))
                   );
    }

    //
    // Bump up the reference count before making an IO request
    //

    ReferenceRequest(this);
    m_IOState = NRIO_WRITE;

    //
    // Remember callback context
    //

    m_ManagedCallbackContext = fAsync ? ManagedContext : 0;
    m_fCompletion = fAsync;

    rc = UlSendHttpResponse(
                m_pwpContext->GetAsyncHandle(),
                RequestID,
                Flags,                              // Flags
                pResponse,
                nChunks,
                pChunk,
                pCachePolicy,
                &cbBytesSent,
                pOverlapped
              );

    // If no more data coming, then dereference corresponding to the
    // initial DoWork
    if (!(Flags & UL_SEND_RESPONSE_FLAG_MORE_DATA))
        DereferenceRequest(this);

    if (ERROR_IO_PENDING != rc)
    {
        //
        // The send completed synchronously or there was an error.
        // Adjust the ref count immediately.
        //

        m_IOState = NRIO_NONE;
        DereferenceRequest( this);
    }

    //
    // Update counters
    //

    if ( (!fAsync) && (NO_ERROR == rc))
    {
        m_cbWritten += cbBytesSent;
    }

    return (rc);

}

/********************************************************************++
--********************************************************************/

ULONG
UL_NATIVE_REQUEST::SendEntityBody( UL_HTTP_REQUEST_ID RequestID,
                                   ULONG              Flags,
                                   ULONG              nChunks,
                                   bool               fAsync,
                                   ULONGLONG          ManagedContext
                                 )
{
    ULONG   rc;

    //
    // Check if there is already IO pending.
    //

    if ( NRIO_NONE != m_IOState)
    {
        return ERROR_ALREADY_WAITING;
    }

    //
    // Bump up the reference count before making an IO request
    //

    ReferenceRequest(this);
    m_IOState = NRIO_WRITE;

    PUL_DATA_CHUNK  pChunk      = (PUL_DATA_CHUNK) m_buffResponse.QueryPtr();
    ULONG           cbBytesSent = 0;
    LPOVERLAPPED    pOverlapped = fAsync ? (&m_overlapped) : NULL;

    //
    // Remember callback context
    //

    m_ManagedCallbackContext = fAsync ? ManagedContext : 0;
    m_fCompletion = fAsync;

    rc = UlSendEntityBody(
                m_pwpContext->GetAsyncHandle(),
                RequestID,
                Flags,                              // Flags
                nChunks,
                pChunk,
                &cbBytesSent,
                pOverlapped
               );

    // If no more data coming, then dereference corresponding to the
    // initial DoWork
    if (!(Flags & UL_SEND_RESPONSE_FLAG_MORE_DATA))
        DereferenceRequest(this);

    if (ERROR_IO_PENDING != rc)
    {
        //
        // The send completed synchronously or there was an error.
        // Adjust the ref count immediately.
        //

         m_IOState = NRIO_NONE;
         DereferenceRequest( this);
    }

    //
    // Update counters
    //

    if ( (!fAsync) && (NO_ERROR == rc))
    {
        m_cbWritten += cbBytesSent;
    }

    return (rc);
}

/********************************************************************++
--********************************************************************/

ULONG
UL_NATIVE_REQUEST::ReceiveEntityBody( UL_HTTP_REQUEST_ID RequestID,
                                      ULONG              Flags,
                                      PUCHAR             pBuffer,
                                      ULONG              cbBufferLength,
                                      bool               fAsync,
                                      ULONGLONG          ManagedContext
                                    )
{
    ULONG   rc;

    //
    // Check if there is already IO pending.
    //

    if ( NRIO_NONE != m_IOState)
    {
        return ERROR_ALREADY_WAITING;
    }

    //
    // Bump up the reference count before making an IO request
    //

    ReferenceRequest(this);
    m_IOState = NRIO_READ;

    ULONG           cbBytesReceived = 0;
    LPOVERLAPPED    pOverlapped = fAsync ? (&m_overlapped) : NULL;

    //
    // Remember callback context
    //

    m_ManagedCallbackContext = fAsync ? ManagedContext : 0;
    m_fCompletion = fAsync;

    rc = UlReceiveEntityBody(
                m_pwpContext->GetAsyncHandle(),
                RequestID,
                Flags,                              // Flags
                pBuffer,
                cbBufferLength,
                &cbBytesReceived,
                pOverlapped
               );

    if (ERROR_IO_PENDING != rc)
    {
        //
        // The receive completed synchronously or there was an error.
        // Adjust the ref count immediately.
        //

         m_IOState = NRIO_NONE;
         DereferenceRequest( this);
    }

    //
    // Update counters
    //

    if ( (!fAsync) && (NO_ERROR == rc))
    {
        m_cbRead += cbBytesReceived;
    }

    return (cbBytesReceived);
}

/********************************************************************++
--********************************************************************/

ULONG
UL_NATIVE_REQUEST::IndicateRequestCompleted(
                    UL_HTTP_REQUEST_ID RequestID,
                    bool               fHeadersSent,
                    bool               fCloseConnection
                   )
{
    ULONG   rc;
    ULONG   flags = 0;

    //
    // Check if there is already IO pending.
    //

    if ( NRIO_NONE != m_IOState)
    {
        return ERROR_ALREADY_WAITING;
    }

    //
    // Bump up the reference count before making an IO request
    //

    ReferenceRequest(this);
    m_IOState = NRIO_WRITE;

    if (fCloseConnection)
    {
        flags |= UL_SEND_RESPONSE_FLAG_DISCONNECT;
    }

    if ( fHeadersSent)
    {
        rc = UlSendEntityBody(
                    m_pwpContext->GetAsyncHandle(),
                    RequestID,
                    flags,
                    0,
                    NULL,
                    NULL,
                    NULL
                    );

    }
    else
    {
        rc = UlSendHttpResponse(
                    m_pwpContext->GetAsyncHandle(),
                    RequestID,
                    flags,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
    }

//    DBG_ASSERT(rc == 0); // BUGBUG looks like this is failing !

    // Dereference here corresponding to the Request starting, request is now
    // complete
    DereferenceRequest(this);

    if ( rc != ERROR_IO_PENDING )
    {
        m_IOState = NRIO_NONE;
        DereferenceRequest( this );
    }

    return rc;
}

/********************************* End of File *******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\dev\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\wreqpool.cxx ===
/********************************************************************++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

      wreqpool.cxx

   Abstract:
      This module implements the functions for managing the 
      pool of worker requests.

   Author:

       Murali R. Krishnan    ( MuraliK )     29-Oct-1998

   Environment:
       Win32 - User Mode
       
   Project:
       IIS Worker Process (web service)

--********************************************************************/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "winbase.h"
#include "precomp.hxx"
#include "wreqpool.hxx"

extern WP_CONTEXT *     g_pwpContext;


/************************************************************
 *    Functions 
 ************************************************************/

/**
 * UL_NATIVE_REQUEST_POOL::UL_NATIVE_REQUEST_POOL()
 *
 * o  Construct a new worker requst pool object.
 * This pool will maintain a list of all native request objects.
 * 
 */
UL_NATIVE_REQUEST_POOL::UL_NATIVE_REQUEST_POOL(void)
    : m_nRequests ( 0),
      m_nIdleRequests( 0),
      m_fShutdown( FALSE),
      m_fAddingItems( FALSE),
      m_dwSignature( NREQ_POOL_SIGNATURE)
{
    InitializeListHead( &m_lRequestList);

    //
    // Use spinned critical section. 
    // All operations using the CS are short lived and 
    //  hence we keep the spins to a small amount.
    //
    //InitializeCriticalSection(&m_csRequestList);
    
    InitializeCriticalSectionAndSpinCount(
        &m_csRequestList,
        UL_NATIVE_REQUEST_CS_SPINS
        );
    
} // UL_NATIVE_REQUEST_POOL::UL_NATIVE_REQUEST_POOL()


/**
 *  ~UL_NATIVE_REQUEST_POOL
 *
 */

UL_NATIVE_REQUEST_POOL::~UL_NATIVE_REQUEST_POOL(void)
{
    if (m_nRequests > 0) 
    {
        ReleaseAllWorkerRequests();
    }

    DeleteCriticalSection( &m_csRequestList);
    InitializeListHead( &m_lRequestList);

    m_dwSignature = ( NREQ_POOL_SIGNATURE_FREE);

} // UL_NATIVE_REQUEST_POOL::~UL_NATIVE_REQUEST_POOL()


/**
 *
 *   UL_NATIVE_REQUEST_POOL::ReleaseAllWorkerRequests()
 * 
 *   o  Walks the global list of all request objects and releases
 *      the requests
 *
 *   NYI: For now it directly frees up the request. We need to post
 *        cancellations for the same as appropriate.
 */
 
HRESULT
UL_NATIVE_REQUEST_POOL::ReleaseAllWorkerRequests(void)
{
    LIST_ENTRY * plScan;

    // Wait for all requests's references drain away.
    while(m_nRequests > 0)
    {
        PUL_NATIVE_REQUEST pwr;

        // Should change to DEBUGGING CODE ONLY
        // IF_DEBUG(DEBUG) {
        DBGPRINTF((DBG_CONTEXT, "%d Requests still needs to be cleaned\n",
                m_nRequests));

        plScan = m_lRequestList.Flink;
        pwr = CONTAINING_RECORD( plScan, UL_NATIVE_REQUEST, m_lRequestEntry);

        DBGPRINTF((DBG_CONTEXT, "The unreleased request's ref count is %d\n", 
            pwr->ReferenceCount()));
        // }
        Sleep(2000);
    }

    DBG_ASSERT(m_nIdleRequests == 0);

    DBGPRINTF((DBG_CONTEXT, "Released all native request objects\n"));
    return (NOERROR);
} // UL_NATIVE_REQUEST_POOL::ReleaseAllWorkerRequests();


/**
 *  AddRequestToList
 *
 *  Add an UL_NATIVE_REQUEST to the request list.
 *
 */
 
void
UL_NATIVE_REQUEST_POOL::AddRequestToList(UL_NATIVE_REQUEST * pRequest)
{
    EnterCriticalSection( &m_csRequestList);
    InsertTailList( &m_lRequestList, &pRequest->m_lRequestEntry);
    m_nRequests++;
    LeaveCriticalSection( &m_csRequestList);

} // UL_NATIVE_REQUEST_POOL::AddRequestToList()


/**
 *  RemoveRequestFromList
 *
 *  Remove an UL_NATIVE_REQUEST from the request list.
 *  This function is called within ~UL_NATIVE_REQUEST.
 *
 */

void
UL_NATIVE_REQUEST_POOL::RemoveRequestFromList(UL_NATIVE_REQUEST * pRequest)
{
    LONG nReqs;

    EnterCriticalSection( &m_csRequestList);
    RemoveEntryList( &pRequest->m_lRequestEntry);
    nReqs = m_nRequests--;
    LeaveCriticalSection( &m_csRequestList);

    InitializeListHead( &pRequest->m_lRequestEntry);

} // UL_NATIVE_REQUEST_POOL::RemoveRequestFromList()

/**
 *  Description:
 *   UL_NATIVE_REQUEST_POOL::AddPoolItems()
 * 
 *   o  Adds a fixed number of items to the pool and adds them to the 
 *    current list of worker requests. After creating the object,
 *    an async read for request is posted on the worker request objects.
 *
 * Arguments:
 *   pContext - pointer to the CONTEXT object for IO operations
 *   nWorkerItemsToAdd - count of new worker requests to be added to the list
 *
 * Returns:
 *   ULONG
 *
 */
 
ULONG 
UL_NATIVE_REQUEST_POOL::AddPoolItems(
     IN WP_CONTEXT * pContext,
     IN int          nWorkerItemsToAdd)
{
    int     i;
    ULONG   rc;
    LONG    nReqs;
    BOOL    fAdding;
    
    PUL_NATIVE_REQUEST pwr;

    EnterCriticalSection( &m_csRequestList);
    if (nWorkerItemsToAdd + m_nRequests > REQUEST_POOL_MAX) {
        nWorkerItemsToAdd = REQUEST_POOL_MAX - m_nRequests;
    }

    if (!m_fAddingItems) {
        m_fAddingItems = TRUE;
        fAdding = TRUE;
    } else {
        nWorkerItemsToAdd = 0;
        fAdding = FALSE;
    }
    LeaveCriticalSection( &m_csRequestList);


    //
    // Loop through and create specified # of worker request objects
    // Attach the current context to these objects
    //

    for (i = 0; i < nWorkerItemsToAdd; i++) 
    {
        if (m_fShutdown) {
            return i;
        }

        pwr = new UL_NATIVE_REQUEST( this);

        if ( NULL == pwr) 
        {
            rc = GetLastError();
            
            if (NO_ERROR != rc) 
            {
                IF_DEBUG( ERROR) 
                {
                    DPERROR(( DBG_CONTEXT, rc, 
                              "Unable to create worker request %d.\n", 
                              i));
                }
            }

            //
            // NYI: Log an event to the evnet log on this failure
            //

            //
            // For now bail out of this loop on error
            //
            break;
        } 
        else 
        {

            AddRequestToList( pwr);

            //
            // Initialize the Context for the object.
            //

            pwr->SetWPContext( pContext);

            rc = pwr->DoWork( 0, 0, &pwr->m_overlapped);
            
            // assume no failure in initial req. read operations
            DBG_ASSERT( NO_ERROR == rc);
        }
    } // for

    if (fAdding) {
        EnterCriticalSection(&m_csRequestList);
        DBG_ASSERT(m_fAddingItems);
        m_fAddingItems = FALSE;
        LeaveCriticalSection(&m_csRequestList);
    }

    return (NOERROR);
    
} // UL_NATIVE_REQUEST_POOL::AddPoolItems()


/**
 *  Description:
 *   UL_NATIVE_REQUEST_POOL::DecIdleRequests()
 * 
 *   Decrements the count of objects available to process new requests.
 *   If we fall below 1/4 the number of initial items, we add some more.
 *
 * Arguments:
 *   None.
 *
 * Returns:
 *   None.
 *
 */
VOID
UL_NATIVE_REQUEST_POOL::DecIdleRequests()
{
    LONG idle;

    idle = InterlockedDecrement(&m_nIdleRequests);
    DBG_ASSERT(idle >= 0);

    if (idle < (NUM_INITIAL_REQUEST_POOL_ITEMS / 4)) {
        AddPoolItems(g_pwpContext, REQUEST_POOL_INCREMENT);
    }
}

/**
 *  Description:
 *   UL_NATIVE_REQUEST_POOL::IncIdleRequests()
 * 
 *   Increments the count of objects available to process new requests.
 *
 * Arguments:
 *   None.
 *
 * Returns:
 *   None.
 *
 */
VOID
UL_NATIVE_REQUEST_POOL::IncIdleRequests()
{
    InterlockedIncrement(&m_nIdleRequests);
}


/***************************** End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\test\rwp_func.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     RWP_Func.cxx

   Abstract:
     Implements the behaviors of the "Rogue Worker Process" -- 
	 to test Appl. Manager

   Author:

       David Wang            ( t-dwang )     14-Jun-1999  Initial

   Project:

       Duct-Tape

--*/

/*********************************************************
 * Include Headers
 *********************************************************/
#include "precomp.hxx"
#include "RWP_Func.hxx"

/*********************************************************
 * Test functions
 *********************************************************/

LONG RWP_BEHAVIOR_EXHIBITED;

LONG RWP_PING_BEHAVIOR;
LONG RWP_SHUTDOWN_BEHAVIOR;
LONG RWP_STARTUP_BEHAVIOR;
LONG RWP_HEALTH_BEHAVIOR;
LONG RWP_RECYCLE_BEHAVIOR;

LONG RWP_EXTRA_DEBUG;

LONG RWP_Ping_Behavior(HRESULT* hr, MESSAGE_PIPE* pPipe) {
	*hr = S_OK;

	//
	//Don't respond to pings
	//
	if (RWP_Get_Behavior(RWP_PING_BEHAVIOR) == RWP_PING_NO_ANSWER) {
		DBGPRINTF((DBG_CONTEXT, "Rogue: Not responding to Ping\n"));
	}

	//
	//Responding with lTimesToRepeat pings
	//
	if (RWP_Get_Behavior(RWP_PING_BEHAVIOR) == RWP_PING_MULTI_ANSWER) {
		LONG lTimesToRepeat = RWP_Get_Behavior_Time_Limit(RWP_PING_BEHAVIOR);
		//char szTimesToRepeat[20];
		
		//_ltoa(lTimesToRepeat, szTimesToRepeat, 10);				//radix 10
		DBGPRINTF((DBG_CONTEXT, "Rogue: Responding to Ping %d times", lTimesToRepeat));
		//DBGPRINTF((DBG_CONTEXT, "Rogue: Responding to Ping for multiple = \n"));
		//DBGPRINTF((DBG_CONTEXT, szTimesToRepeat));

		for (LONG i = 0; i < lTimesToRepeat; i++) {
			*hr = pPipe->WriteMessage(
				IPM_OP_PING_REPLY,  // ping reply opcode
				0,                  // no data to send
				NULL                // pointer to no data
				);
		}
	}

	//
	//Respond in a delayed manner
	//
	if (RWP_Get_Behavior(RWP_PING_BEHAVIOR) == RWP_PING_DELAY_ANSWER) {
		LONG lTimeToSleep = RWP_Get_Behavior_Time_Limit(RWP_PING_BEHAVIOR);
		RWP_Sleep_For(lTimeToSleep, "Rogue: Delay responding to Ping for");

		//return 0 so that we'll keep going (this is a delay, not fail)
		return (RWP_NO_MISBEHAVE);
	}

	//
	//The reason why there is no delayed multi-ping response is because 
	//responding in a delayed manner does not alter the code, whereas 
	//multi-respond actually copies code.  If the response code changes,
	//multi-ping also needs to change.
	//

	return (RWP