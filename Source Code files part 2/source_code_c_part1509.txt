ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    DXGASSERT(cBackBuffers  <= D3DPRESENT_BACK_BUFFERS_MAX);
    for (i = 0; i < cBackBuffers + 1; i++)
    {
        SurfInfoArray[i].cpWidth = width;
        SurfInfoArray[i].cpHeight = height;
    }

    CreateSurfaceData.hDD      = Device()->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfoArray[0];
    bNoDDrawSupport = Device()->Enum()->NoDDrawSupport(Device()->AdapterIndex());

    if (D3DDEVTYPE_HAL == Device()->GetDeviceType() &&
        m_PresentationData.SwapEffect == D3DSWAPEFFECT_FLIP)
    {
        m_PresentUseBlt = FALSE;
        bMirrorBufferCreated = FALSE;
        CreateSurfaceData.dwSCnt   = cBackBuffers + 1;
        CreateSurfaceData.MultiSampleType = MultiSampleType;
    }
    else if ((m_PresentationData.SwapEffect == D3DSWAPEFFECT_COPY &&
             m_PresentationData.FullScreen_PresentationInterval == 
                D3DPRESENT_INTERVAL_IMMEDIATE) || bNoDDrawSupport 
            )
    {
        // If we're doing a copy-swap-effect and the app
        // specifies interval-immediate, then we can blt directly
        // to the primary without a mirror.
        DXGASSERT(MultiSampleType == D3DMULTISAMPLE_NONE);
        m_PresentUseBlt = TRUE;
        bMirrorBufferCreated = FALSE;
        CreateSurfaceData.dwSCnt   = 1;
        CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    }
    else
    {
        //one for m_pPrimarySurface and one for m_pMirrorSurface
        m_PresentUseBlt = TRUE;
        bMirrorBufferCreated = TRUE;
        CreateSurfaceData.dwSCnt   = 2;
        CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    }
    CreateSurfaceData.Type     = D3DRTYPE_SURFACE;
    CreateSurfaceData.Pool     = D3DPOOL_LOCALVIDMEM;
    CreateSurfaceData.dwUsage  = D3DUSAGE_PRIMARYSURFACE | Usage;
    CreateSurfaceData.Format   = Device()->DisplayFormat();

    if(Device()->DisplayFormat() != backBufferFormat)
    {
        CreateSurfaceData.dwUsage  |= D3DUSAGE_ALPHACHANNEL;
    }
        
    if (!bNoDDrawSupport)
    {
        hr = Device()->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(hr))
        {
            if (D3DDEVTYPE_HAL == Device()->GetDeviceType())
            {
                DPF_ERR("Failed to create driver primary surface chain");
                return hr;
            }
            else
            {
                // assume CreateSurfaceData is still intact
                bMirrorBufferCreated = FALSE;
                CreateSurfaceData.dwSCnt = 1;
                hr = Device()->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to create driver primary surface");
                    return hr;
                }
            }
        }
    }
    // Now that we have the handles, create the surface interfaces
    // one by one

    // When creating passing in kernel handles to a driver
    // surface, the surface will assume that it was created in
    // LocalVidMem. We assert this here..
    DXGASSERT(CreateSurfaceData.Pool == D3DPOOL_LOCALVIDMEM);

    m_pPrimarySurface = new CDriverSurface(
        Device(),
        width,
        height,
        CreateSurfaceData.dwUsage | D3DUSAGE_LOCK,
        // there is a problem with thunklayer when NoDDrawSupport
        // DriverData.DisplayWidth and DriverData.DisplayHeight
        // DriverData.DisplayFormat are not getting updated
        // so we use backBufferFormat until Device()->DisplayFormat() 
        bNoDDrawSupport ? backBufferFormat : Device()->DisplayFormat(), // UserFormat
        bNoDDrawSupport ? backBufferFormat : Device()->DisplayFormat(), // RealFormat
        CreateSurfaceData.MultiSampleType,
        SurfInfoArray[0].hKernelHandle,
        REF_INTERNAL,
        &hr);

    if (m_pPrimarySurface == NULL)
    {
        // We'll clean up the kernel handle(s) at the
        // end of the function
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Zero out the kernel-handle so that
        // we don't clean it at exit. If the CDriverSurface
        // function fails; it will still release the kernel
        // handle in its destructor.
        SurfInfoArray[0].hKernelHandle = 0;
    }

    if (SUCCEEDED(hr))
    {

        m_hGDISurface = m_pPrimarySurface->KernelHandle();
        if (bMirrorBufferCreated)
        {
            // Mirror surfaces are only useful if we're going
            // to do a Blt as part of the Present. (We might
            // also do a flip in addition.)
            DXGASSERT(m_PresentUseBlt);

            // When creating passing in kernel handles to a driver
            // surface, the surface will assume that it was created in
            // LocalVidMem. We assert this here..
            DXGASSERT(CreateSurfaceData.Pool == D3DPOOL_LOCALVIDMEM);

            m_pMirrorSurface = new CDriverSurface(
                Device(),
                width,
                height,
                D3DUSAGE_BACKBUFFER,
                Device()->DisplayFormat(),  // UserFormat
                Device()->DisplayFormat(),  // RealFormat
                D3DMULTISAMPLE_NONE,
                SurfInfoArray[1].hKernelHandle,
                REF_INTERNAL,
                &hr);

            if (NULL == m_pMirrorSurface)
            {
                //if out of memory, then destroy the driver object as well
                D3D8_DESTROYSURFACEDATA DestroySurfData;
                DestroySurfData.hDD = Device()->GetHandle();
                DestroySurfData.hSurface = SurfInfoArray[1].hKernelHandle;
                Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                bMirrorBufferCreated = FALSE;
                hr = S_OK;  //but don't fail as m_pMirrorSurface is optional
            }
            else if (FAILED(hr))
            {   
                // Release the surface
                m_pMirrorSurface->DecrementUseCount();
                m_pMirrorSurface = NULL;

                bMirrorBufferCreated = FALSE;
                hr = S_OK;  //but don't fail as m_pMirrorSurface is optional
            }
            else
            {
                //blt from m_ppBackBuffers[m_presentnext] to m_pMirrorSurface
                //then flip from m_pPrimarySurface to m_pMirrorSurface
                m_BltData.hDestSurface =
                    m_pMirrorSurface->KernelHandle();
            }
            
            // In all cases, zero out the kernel handle
            // since it has either been owned by something or freed by now
            SurfInfoArray[1].hKernelHandle = 0;
        }
        if (m_PresentUseBlt)
        {
            if (!bMirrorBufferCreated)
            {
                // If we're blitting and there is no
                // mirror surface; then the primary must be
                // the destination
                DXGASSERT(m_BltData.hDestSurface == NULL);
                m_BltData.hDestSurface = m_pPrimarySurface->KernelHandle();
            }
            if (D3DSWAPEFFECT_FLIP == m_PresentationData.SwapEffect)
            {
                // To emualte flip for SW drivers, create an extra backbuffer
                cBackBuffers = m_PresentationData.BackBufferCount + 1;
            }

            ZeroMemory(SurfInfoArray, sizeof(SurfInfoArray));
            for (i = 1; i < cBackBuffers + 1; i++)
            {
                SurfInfoArray[i].cpWidth = width;
                SurfInfoArray[i].cpHeight = height;
            }

            ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));
            CreateSurfaceData.hDD      = Device()->GetHandle();
            CreateSurfaceData.pSList   = &SurfInfoArray[1];
            CreateSurfaceData.dwSCnt   = cBackBuffers;
            CreateSurfaceData.Type     = D3DRTYPE_SURFACE;
            CreateSurfaceData.Pool     = D3DPOOL_DEFAULT;
            CreateSurfaceData.dwUsage  = D3DUSAGE_BACKBUFFER | D3DUSAGE_RENDERTARGET;
            CreateSurfaceData.Format   = backBufferFormat;
            CreateSurfaceData.MultiSampleType = MultiSampleType;
            hr = Device()->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        }
    }
    if (SUCCEEDED(hr))
    {
        if (m_ppBackBuffers = new CDriverSurface *[cBackBuffers])
        {
            DWORD Usage = D3DUSAGE_BACKBUFFER | D3DUSAGE_RENDERTARGET;
            if ((D3DMULTISAMPLE_NONE == m_PresentationData.MultiSampleType) &&
                bLockable)
            {
                Usage |= D3DUSAGE_LOCK;
            }

            for (; m_cBackBuffers < cBackBuffers; ++m_cBackBuffers)
            {

                m_ppBackBuffers[m_cBackBuffers] = new CDriverSurface(
                    Device(),
                    width,
                    height,
                    Usage,
                    backBufferFormat,
                    backBufferFormat,
                    MultiSampleType,
                    SurfInfoArray[m_cBackBuffers + 1].hKernelHandle,
                    REF_INTRINSIC,
                    &hr);

                if (m_ppBackBuffers[m_cBackBuffers] == NULL)
                {
                    // We'll clean up the kernel handle at the ned
                    // of the function
                    hr = E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    // Zero out the kernel-handle so that
                    // we don't clean it at exit. (Even in failure,
                    // the m_ppBackBuffers[m_cBackBuffers] object
                    // will free the kernel handle now
                    SurfInfoArray[m_cBackBuffers + 1].hKernelHandle = 0;
                }


                if (FAILED(hr))
                {
                    m_ppBackBuffers[m_cBackBuffers]->DecrementUseCount();
                    m_ppBackBuffers[m_cBackBuffers] = NULL;
                    break;
                }
            }

            if (m_cBackBuffers != cBackBuffers)
            {
                // Something went wrong, so clean up now.

                // 2. Destroy Back Buffers, if any.

                while (m_cBackBuffers > 0)
                {
                    m_ppBackBuffers[--m_cBackBuffers]->DecrementUseCount();
                }
                delete [] m_ppBackBuffers;
                m_ppBackBuffers = NULL;
            }
            else
            {
                const D3D8_DRIVERCAPS* pDriverCaps = Device()->GetCoreCaps();
                m_dwFlipFlags = DDFLIP_WAIT;
                if ((D3DPRESENT_INTERVAL_IMMEDIATE == m_PresentationData.FullScreen_PresentationInterval)
#ifdef  WINNT
                    || (D3D_REGFLAGS_FLIPNOVSYNC & m_dwFlags)
#endif
                    )
                {
                    if (DDCAPS2_FLIPNOVSYNC & pDriverCaps->D3DCaps.Caps2)
                    {
                        m_dwFlipFlags   |= DDFLIP_NOVSYNC;
                    }
                }
                else if (DDCAPS2_FLIPINTERVAL & pDriverCaps->D3DCaps.Caps2)
                {
                    switch(m_PresentationData.FullScreen_PresentationInterval)
                    {
                    case D3DPRESENT_INTERVAL_DEFAULT:
                    case D3DPRESENT_INTERVAL_ONE:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL1;
                        break;
                    case D3DPRESENT_INTERVAL_TWO:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL2;
                        break;
                    case D3DPRESENT_INTERVAL_THREE:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL3;
                        break;
                    case D3DPRESENT_INTERVAL_FOUR:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL4;
                        break;
                    }
                }
                m_BltData.hWnd = m_PresentationData.hDeviceWindow;
                m_BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;
                m_ClientWidth = width;
                m_ClientHeight = height;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Error handling cleanup
    if (FAILED(hr))
    {
        // We may need to free surface handles that
        // were not owned by any CDriverSurface that
        // we failed to properly create

        D3D8_DESTROYSURFACEDATA DestroyData;
        ZeroMemory(&DestroyData, sizeof DestroyData);
        DestroyData.hDD = Device()->GetHandle();

        for (UINT i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            if (CreateSurfaceData.pSList[i].hKernelHandle)
            {
                DestroyData.hSurface = CreateSurfaceData.pSList[i].hKernelHandle;
                Device()->GetHalCallbacks()->DestroySurface(&DestroyData);        
            }
        }
    }

    return hr;
} // CreateFullScreen

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Destroy"

//=============================================================================
// CSwapChain::Destroy
//
// Created 11/16/1999 johnstep
//=============================================================================

VOID
CSwapChain::Destroy()
{
    // Destroy surfaces in reverse create order.
    if (m_pCursor)
    {
        delete m_pCursor;
        m_pCursor = NULL;
    }
    // 2. Destroy Back Buffers
    //
    // If the previous mode was windowed, we should have exactly 1
    // back buffer to destroy. Otherwise, there could be more than
    // one, and plus we may need some sort of atomic destruction.
    if (m_ppBackBuffers)
    {
        while (m_cBackBuffers > 0)
        {
            m_ppBackBuffers[--m_cBackBuffers]->DecrementUseCount();
        }
        delete [] m_ppBackBuffers;
        m_ppBackBuffers = NULL;
    }

    // 1. Destroy Mirror Surface
    if (m_pMirrorSurface)
    {
        m_pMirrorSurface->DecrementUseCount();
        m_pMirrorSurface = NULL;
    }
    // 1. Destroy Primary Surface
    if (m_pPrimarySurface)
    {
        if (this == Device()->SwapChain())
            m_pPrimarySurface->DecrementUseCount();
        m_pPrimarySurface = NULL;
        m_hGDISurface = NULL;
    }
    m_presentnext = 0;
} // Destroy

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::GetBackBuffer"

//=============================================================================
// IDirect3DSwapChain8::GetBackBuffer (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP
CSwapChain::GetBackBuffer(
    UINT                iBackBuffer,
    D3DBACKBUFFER_TYPE  Type,
    IDirect3DSurface8 **ppBackBuffer
  )
{
    API_ENTER(Device());

    if (ppBackBuffer == NULL)
    {
        DPF_ERR("Invalid ppBackbuffer parameter passed to GetBackBuffer");
        return D3DERR_INVALIDCALL;
    }

    // We can't just assert we have a valid back buffer array because a
    // Reset may have failed, which puts the device in a disabled state
    // until Reset is called again. Once we have a `disabled' flag, we
    // can check that instead of m_ppBackBuffers.

    if (m_ppBackBuffers == NULL)
    {
        DPF_ERR("GetBackBuffer failed due to Device being lost");
        return D3DERR_INVALIDCALL;
    }

    // in case of windowed D3DSWAPEFFECT_FLIP, m_cBackBuffers
    // == m_PresentationData.BackBufferCount + 1 as we allocate
    // that extra buffer for user without its knowledge
    if (iBackBuffer >= m_PresentationData.BackBufferCount)
    {
        DPF_ERR("Invalid iBackBuffer parameter passed to GetBackBuffer");
        return D3DERR_INVALIDCALL;
    }

    *ppBackBuffer = BackBuffer(iBackBuffer);

    DXGASSERT(*ppBackBuffer != NULL);
    if (*ppBackBuffer)
    {
        (*ppBackBuffer)->AddRef();
        return S_OK;
    }
    else
    {
        DPF(2, "Swapchain doesn't have a BackBuffer[%d]",iBackBuffer);
        return D3DERR_NOTFOUND;
    }
} // GetBackBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Reset"

//=============================================================================
// IDirect3DSwapChain8::Reset (public)
//
// Resizes the device. If this results in a display mode change, then all
// existing surfaces will be lost.
//
// Arguments:
//   width
//   height
//   pcBackBuffers (in/out) !!! Currently an (in) but will be fixed later.
//   backBufferFormat
//   fullscreen
//   pOptionalParams
// Created 11/16/1999 johnstep
//=============================================================================

HRESULT 
CSwapChain::Reset(
    D3DPRESENT_PARAMETERS *pPresentationParameters
  )
{

    BOOL bDeviceLost = FALSE;
    HRESULT hr;

    // Validate First before changing state
    switch (pPresentationParameters->SwapEffect)
    {
    case D3DSWAPEFFECT_DISCARD:
    case D3DSWAPEFFECT_COPY:
    case D3DSWAPEFFECT_COPY_VSYNC:
    case D3DSWAPEFFECT_FLIP:
    case D3DSWAPEFFECT_NO_PRESENT:
        break;
    default:
        DPF_ERR("Invalid parameter for SwapEffect for D3DPRESENT_PARAMETERS. "
                "Must be one of D3DSWAPEFFECTS_COPY, D3DSWAPEFFECTS_COPY_VSYNC, "
                "D3DSWAPEFFECTS_DISCARD, or D3DSWAPEFFECTS_FLIP. CreateDevice/Reset Fails.");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParameters->BackBufferCount)
    {
        if ((D3DSWAPEFFECT_COPY == pPresentationParameters->SwapEffect ||
            D3DSWAPEFFECT_COPY_VSYNC == pPresentationParameters->SwapEffect)
            && (pPresentationParameters->BackBufferCount > 1))
        {
            DPF_ERR("BackBufferCount must be 1 if SwapEffect is COPY/VSYNC. CreateDevice/Reset Fails.");
            pPresentationParameters->BackBufferCount = 1;
            return D3DERR_INVALIDCALL;
        }
        if (pPresentationParameters->BackBufferCount >
            D3DPRESENT_BACK_BUFFERS_MAX)
        {
            DPF_ERR("BackBufferCount must be less "
                "than D3DPRESENT_BACK_BUFFERS_MAX. CreateDevice/Reset Fails.");
            pPresentationParameters->BackBufferCount =
                D3DPRESENT_BACK_BUFFERS_MAX;

            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        pPresentationParameters->BackBufferCount = 1;
        DPF(4, "BackBufferCount not specified, considered default 1 ");
    }

    if (D3DSWAPEFFECT_DISCARD != pPresentationParameters->SwapEffect)
    {
        if (pPresentationParameters->MultiSampleType != D3DMULTISAMPLE_NONE)
        {
            DPF_ERR("Multisampling requires D3DSWAPEFFECT_DISCARD. CreateDevice/Reset Fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // D3DSWAPEFFECT_NO_PRESENT is a hack that only works for windowed mode
    if (D3DSWAPEFFECT_NO_PRESENT == pPresentationParameters->SwapEffect)
    {
        if (!pPresentationParameters->Windowed)
        {
            DPF_ERR("D3DSWAPEFFECT_NO_PRESENT only works when the device is windowed. CreateDevice/Reset Fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    memcpy(&m_PresentationData,
        pPresentationParameters,sizeof m_PresentationData);

    // Remember the original swapeffect
    m_UserSwapEffect = pPresentationParameters->SwapEffect;

    // Convert discard to flip or copy based on stuff
    if (D3DSWAPEFFECT_DISCARD == pPresentationParameters->SwapEffect)
    {
        if (pPresentationParameters->Windowed &&
            pPresentationParameters->BackBufferCount == 1)
        {
            m_PresentationData.SwapEffect = D3DSWAPEFFECT_COPY;
        }
        else
        {
            m_PresentationData.SwapEffect = D3DSWAPEFFECT_FLIP;
        }
    }

    if (NULL == m_PresentationData.hDeviceWindow)
    {
        m_PresentationData.hDeviceWindow= Device()->FocusWindow();
    }

    DXGASSERT( NULL != m_PresentationData.hDeviceWindow);

#ifdef WINNT
    // On NT, SetCooperativeLevel will fail if another device has exclusive
    // mode, so we cannot call it.  On Win9X, it will not fail, but CreateSurface
    // WILL fail if we don't first call it, so we need to special case this call.
    if (m_UserSwapEffect != D3DSWAPEFFECT_NO_PRESENT)
    {
#endif
        hr = SetCooperativeLevel();
        if (FAILED(hr))
        {
            DPF_ERR("SetCooperativeLevel returned failure. CreateDevice/Reset Failed");
            return hr;
        }
#ifdef WINNT
    }
#endif
    // See if the device is lost

    if (D3D8IsDeviceLost(Device()->GetHandle()))
    {
        bDeviceLost = TRUE;
        FetchDirectDrawData(Device()->GetDeviceData(),  
            Device()->GetInitFunction(),
            Device()->Enum()->GetUnknown16(Device()->AdapterIndex()),
            Device()->Enum()->GetHalOpList(Device()->AdapterIndex()),
            Device()->Enum()->GetNumHalOps(Device()->AdapterIndex()));
    }

    // Map the unknown format to a real one. If they will take any format
    // (i.e. the specified UNKNOWN), then we will try to give them the one
    // that matches the display format.

    if (m_PresentationData.Windowed)
    {
        // If we are windowed, we need to use the current display mode.  We may be
        // able to relax this for new drivers.

        if (D3DFMT_UNKNOWN == m_PresentationData.BackBufferFormat)
        {
            m_PresentationData.BackBufferFormat = Device()->DisplayFormat();
        }
        
        if (CPixel::SuppressAlphaChannel(m_PresentationData.BackBufferFormat)
            != Device()->DisplayFormat())
        {
            DPF_ERR("Windowed BackBuffer Format must be compatible with Desktop Format. CreateDevice/Reset fails.");
            return D3DERR_INVALIDCALL;            
        }
    }

    if (m_PresentationData.Windowed)
    {
        if ((m_PresentationData.BackBufferWidth < 1) ||
            (m_PresentationData.BackBufferHeight < 1))
        {
            RECT rc;
            if (GetClientRect(m_PresentationData.hDeviceWindow, &rc))
            {
                if (m_PresentationData.BackBufferWidth < 1)
                    m_PresentationData.BackBufferWidth = rc.right;
                if (m_PresentationData.BackBufferHeight < 1)
                    m_PresentationData.BackBufferHeight = rc.bottom;
            }
            else
            {
                DPF_ERR("zero width and/or height and unable to get client. CreateDevice/Reset fails.");
                return D3DERR_INVALIDCALL;
            }
        }

        // We can handle color conversion from the back buffer if we use
        // GDI BitBlt instead of DirectDraw Blt for presentation.

        switch (m_PresentationData.BackBufferFormat)
        {
        case D3DFMT_X1R5G5B5:
        case D3DFMT_A1R5G5B5:
        case D3DFMT_R5G6B5:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_A8R8G8B8:
            break;

        default:
            DPF_ERR("Unsupported back buffer format specified.");
            return D3DERR_INVALIDCALL;
        }

        // Does the device support offscreen RTs of this format in the current
        // display mode?

        if (FAILED(Device()->Enum()->CheckDeviceFormat(
                Device()->AdapterIndex(), 
                Device()->GetDeviceType(), 
                Device()->DisplayFormat(),
                D3DUSAGE_RENDERTARGET,
                D3DRTYPE_SURFACE,
                m_PresentationData.BackBufferFormat)))
        {
            DPF_ERR("This back buffer format is not supported for a windowed device. CreateDevice/Reset Fails");
            DPF_ERR("   Use CheckDeviceType(Adapter, DeviceType, <Current Display Format>, <Desired BackBufferFormat>,  TRUE /* Windowed */)");
            return D3DERR_INVALIDCALL;
        }



        // For now, always destroy existing surfaces and recreate. Later, we
        // may reuse the surfaces. We should also add an `initialized' flag,
        // but for now will just arbitrarily use m_pPrimarySurface for this
        // purpose.

        if (this == Device()->SwapChain())
        {
            Device()->UpdateRenderTarget(NULL, NULL);
            if (m_pPrimarySurface != NULL)
            {
                Device()->ResourceManager()->DiscardBytes(0);
                static_cast<CD3DBase*>(Device())->Destroy();
                Destroy();
            }
            if (Device()->GetZStencil() != NULL)
            {
                Device()->GetZStencil()->DecrementUseCount();
                Device()->ResetZStencil();
            }
            if (D3D8DoVidmemSurfacesExist(Device()->GetHandle()))
            {
                // user must free any video memory surfaces before doing
                // fullscreen Reset, otherwise we fail.
                DPF_ERR("All user created D3DPOOL_DEFAULT surfaces must be freed"
                    " before Reset can succeed. Reset Fails.");
                return  D3DERR_DEVICELOST;
            }
        }

        // If the device is lost, we should now restore it before creating
        // the new swap chain.

        if (bDeviceLost)
        {
            D3D8RestoreDevice(Device()->GetHandle());
        }

        hr = CreateWindowed(
            Width(),
            Height(),
            BackBufferFormat(),
            m_PresentationData.BackBufferCount,
            m_PresentationData.MultiSampleType,
            (D3DSWAPEFFECT_DISCARD == m_UserSwapEffect),
            (pPresentationParameters->Flags & D3DPRESENTFLAG_LOCKABLE_BACKBUFFER)
           );
    }
    else
    {
        D3DFORMAT   FormatWithoutAlpha;

        #ifdef WINNT
            // Pick the best refresh rate
            m_PresentationData.FullScreen_RefreshRateInHz = PickRefreshRate(
                Width(),
                Height(),
                m_PresentationData.FullScreen_RefreshRateInHz,
                m_PresentationData.BackBufferFormat);
        #endif

        // If they specified a mode, does the mode exist?
        if (Width() != Device()->DisplayWidth()
            || Height() != Device()->DisplayHeight()
            || BackBufferFormat() != Device()->DisplayFormat()
            || ((m_PresentationData.FullScreen_RefreshRateInHz != 0) &&
                (m_PresentationData.FullScreen_RefreshRateInHz !=
                    Device()->DisplayRate()))
           )
        {
            D3DDISPLAYMODE* pModeTable = Device()->GetModeTable();
            DWORD dwNumModes = Device()->GetNumModes();
            DWORD i;
    #if DBG
            for (i = 0; i < dwNumModes; i++)
            {
                DPF(10,"Mode[%d] is %d x %d format=%08lx",
                    i,
                    pModeTable[i].Width,
                    pModeTable[i].Height,
                    pModeTable[i].Format);
            }
    #endif  //DBG

            FormatWithoutAlpha = CPixel::SuppressAlphaChannel(m_PresentationData.BackBufferFormat);
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width()) &&
                    (pModeTable[i].Height == Height()) &&
                    (pModeTable[i].Format == FormatWithoutAlpha))
                {
                    // So far so good.  Check refresh rate if they specified one
                    if ((m_PresentationData.FullScreen_RefreshRateInHz == 0) ||
                        (m_PresentationData.FullScreen_RefreshRateInHz ==
                        pModeTable[i].RefreshRate))
                    {
                        break;
                    }
                }
            }
            if (i == dwNumModes)
            {
                // The specified mode is invalid
                DPF_ERR("The specified mode is unsupported. CreateDevice/Reset Fails");
                return D3DERR_INVALIDCALL;
            }

            // If the mode exists, does the device have caps in it?
            if (FAILED(Device()->Enum()->CheckDeviceType(
                    Device()->AdapterIndex(), 
                    Device()->GetDeviceType(), 
                    FormatWithoutAlpha,
                    m_PresentationData.BackBufferFormat,
                    FALSE)))
            {
                DPF_ERR("Display Mode not supported by this device type. Use CheckDeviceType(X, X, <Desired fullscreen format>). CreateDevice/Reset Fails");
                return D3DERR_INVALIDCALL;
            }

            // The mode is supported, so next we set the cooperative level to fullscreen

            // Now do the mode change and update the driver caps

            D3D8_SETMODEDATA SetModeData;

            SetModeData.hDD = Device()->GetHandle();
            SetModeData.dwWidth = Width();
            SetModeData.dwHeight = Height();
            SetModeData.Format = BackBufferFormat();
            SetModeData.dwRefreshRate =
                m_PresentationData.FullScreen_RefreshRateInHz;
            SetModeData.bRestore = FALSE;

            Device()->GetHalCallbacks()->SetMode(&SetModeData);
            if (SetModeData.ddRVal != DD_OK)
            {
                DPF_ERR("Unable to set the new mode. CreateDevice/Reset Fails");
                return SetModeData.ddRVal;
            }

            FetchDirectDrawData(Device()->GetDeviceData(), Device()->GetInitFunction(), 
                Device()->Enum()->GetUnknown16(Device()->AdapterIndex()),
                Device()->Enum()->GetHalOpList(Device()->AdapterIndex()),
                Device()->Enum()->GetNumHalOps(Device()->AdapterIndex()));

            // We have to restore the device now, since out mode change above would
            // have forced it to become lost.

            bDeviceLost = TRUE; // need to restore right away
        }

        // For now, always destroy existing surfaces and recreate. Later, we
        // may reuse the surfaces. We should also add an `initialized' flag,
        // but for now will just arbitrarily use m_pPrimarySurface for this
        // purpose.

        Device()->UpdateRenderTarget(NULL, NULL);
        if (m_pPrimarySurface != NULL)
        {
            Device()->ResourceManager()->DiscardBytes(0);
            static_cast<CD3DBase*>(Device())->Destroy();
            Destroy();
        }
        if (Device()->GetZStencil() != NULL)
        {
            Device()->GetZStencil()->DecrementUseCount();
            Device()->ResetZStencil();
        }

        if (D3D8DoVidmemSurfacesExist(Device()->GetHandle()))
        {
            // user must free any video memory surfaces before doing
            // fullscreen Reset, otherwise we fail.
            DPF_ERR("All user created D3DPOOL_DEFAULT surfaces must be freed"
                " before Reset can succeed. Reset Fails");
            return  D3DERR_DEVICELOST;
        }
        if (bDeviceLost)
        {
            D3D8RestoreDevice(Device()->GetHandle());
        }

        hr = CreateFullscreen(
            m_PresentationData.BackBufferWidth,
            m_PresentationData.BackBufferHeight,
            m_PresentationData.BackBufferFormat,
            m_PresentationData.BackBufferCount,
            m_PresentationData.FullScreen_PresentationInterval,
            m_PresentationData.MultiSampleType,
            (D3DSWAPEFFECT_DISCARD == m_UserSwapEffect),
            (pPresentationParameters->Flags & D3DPRESENTFLAG_LOCKABLE_BACKBUFFER)
            );
#ifdef  WINNT
        if (SUCCEEDED(hr))
        {
            MakeFullscreen();
        }
#endif  //WINNT

        // Restore the gamma ramp if it was previously set

        if (m_GammaSet && SUCCEEDED(hr))
        {
            SetGammaRamp(0, &m_DesiredGammaRamp);
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pCursor = new CCursor(Device());
        m_bClientChanged = TRUE;
        m_pSrcRect = m_pDstRect = NULL;
    }
    return hr;
} // Reset

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::ClipIntervals"

//=============================================================================
// ClipIntervals
//
// calculate [low1 high1] and [low2 high2] after considering [low high] 
// 
// - [low1 high1] will be the interval corresponding to the width/height of 
//   target's size
//
// - [low2 high2] will be the interval corresponding to the width/height of
//   the source's size
//
// - [low high] will be the interval corresponding of the width/height of
//   the target clip
//
// The intention of this function is to clip the source for certain
// stretch scenarios where the target is clipped.
//
// Created 05/17/2000 kanqiu
//=============================================================================
void ClipIntervals(long & low1, long & high1, 
                   long & low2, long & high2,
                   const long low, const long high)
{
    DXGASSERT(low1 < high1);
    DXGASSERT(low2 < high2);
    DXGASSERT(low < high);    

    // shrink the target interval to lie within our Destination Clip [low high]
    if (low > low1)
    {
        low1 = low;
    }
    if (high < high1)
    {
        high1 = high;
    }

    // if the destination interval is the same size as the destination
    // clip, then we don't need to do anything
    long    length1 = high1 - low1;
    long    length = high - low;

    // see if clamp is needed for low2 and high2 proportionally
    if (length1 != length)
    {
        // find the length of our source interval
        long    length2 = high2 - low2;

        // if the destination clip's low is outside our
        // target's low
        if (low < low1)
        {
            // Adjust the source low proportionally
            low2 += (low1 - low) * length2 / length;
        }

        // if the destination clip's high is outside our
        // target's high
        if (high > high1)
        {
            // Adjust the source high proportionally
            high2 -= (high - high1) * length2 / length;            
        }
        /*
         * Check for zero-sized dimensions and bump if necessary
         */
        DXGASSERT(high2 >= low2);
        if (low2 == high2)
        {
            if (low1 - low >= high - high1)
            {
                low2--;
            }
            else
            {
                high2++;
            }
        }
    }
} // ClipIntervals

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::ClipRects"

//=============================================================================
// ClipRects
//
// calculate pSrc and pDst after considering pSrcRect and pDstRect
//
// Created 05/17/2000 kanqiu
//=============================================================================
inline HRESULT ClipRects(RECT * pSrc,  RECT * pDst, 
    RECT * pSrcRect, const RECT * pDstRect)
{
    RECT    SrcRect;
    if (pDstRect)
    {
        if (pDstRect->top >= pDst->bottom ||
            pDstRect->bottom <= pDst->top ||
            pDstRect->left >= pDst->right ||
            pDstRect->right <= pDst->left ||
            pDstRect->top >= pDstRect->bottom ||
            pDstRect->left >= pDstRect->right
           )
        {
            // in case of insane RECT, fail it
            DPF_ERR("Unable to present with invalid destionation RECT");
            return D3DERR_INVALIDCALL;
        }
        if (pSrcRect)
        {
            SrcRect = *pSrcRect;
            pSrcRect = &SrcRect;    //make a local copy and then update
            ClipIntervals(pDst->top,pDst->bottom,pSrcRect->top,pSrcRect->bottom,
                pDstRect->top,pDstRect->bottom);
            ClipIntervals(pDst->left,pDst->right,pSrcRect->left,pSrcRect->right,
                pDstRect->left,pDstRect->right);        
        }
        else
        {
            ClipIntervals(pDst->top,pDst->bottom,pSrc->top,pSrc->bottom,
                pDstRect->top,pDstRect->bottom);
            ClipIntervals(pDst->left,pDst->right,pSrc->left,pSrc->right,
                pDstRect->left,pDstRect->right);        
        }
    }

    // this pSrcRect is either what the user passed in (if there is no pDstRect)
    // or it now points to "SrcRect" temp which contains the clipped version
    // of what the user passed it.
    if (pSrcRect)
    {
        if (pSrcRect->top >= pSrc->bottom ||
            pSrcRect->bottom <= pSrc->top ||
            pSrcRect->left >= pSrc->right ||
            pSrcRect->right <= pSrc->left ||
            pSrcRect->top >= pSrcRect->bottom ||
            pSrcRect->left >= pSrcRect->right
          )
        {
            // in case of insane RECT, fail it
            DPF_ERR("Unable to present with invalid source RECT");
            return D3DERR_INVALIDCALL;
        }
        ClipIntervals(pSrc->top,pSrc->bottom,pDst->top,pDst->bottom,
            pSrcRect->top,pSrcRect->bottom);
        ClipIntervals(pSrc->left,pSrc->right,pDst->left,pDst->right,
            pSrcRect->left,pSrcRect->right);
    }
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::UpdateFrameRate"

/*
 * updateFrameRate
 */
void 
CSwapChain::UpdateFrameRate( void )
{

    /*
     * work out the frame rate if required...
     */

    if( 0xffffffff == m_dwFlipTime )
    {
	m_dwFlipTime = GetTickCount();
    }

    m_dwFlipCnt++;
    if( m_dwFlipCnt >= 120 )
    {
	DWORD	time2;
	DWORD	fps;
	char	buff[256];
	time2 = GetTickCount() - m_dwFlipTime;

        // Only do this at most every two seconds 
        if (time2 >= 2000)
        {
	    fps = (m_dwFlipCnt*10000)/time2;
            wsprintf(buff, "Adapter %d FPS = %ld.%01ld\r\n",
                Device()->AdapterIndex(), fps/10, fps % 10 );
            OutputDebugString(buff);
	    m_dwFlipTime = GetTickCount();
	    m_dwFlipCnt = 0;
        }
    }
} /* updateFrameRate */

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::DebugDiscardBackBuffer"

#ifdef DEBUG
void CSwapChain::DebugDiscardBackBuffer(HANDLE SurfaceToClear) const
{
    // Disregard SW or Ref
    if (Device()->GetDeviceType() == D3DDEVTYPE_REF ||
        Device()->GetDeviceType() == D3DDEVTYPE_SW)
    {
        return;
    }

    if (m_UserSwapEffect != D3DSWAPEFFECT_DISCARD)
    {
        return;
    }

    D3D8_BLTDATA ColorFill;
    ZeroMemory(&ColorFill, (sizeof ColorFill));
    ColorFill.hDD = Device()->GetHandle();
    ColorFill.hDestSurface = SurfaceToClear;
    ColorFill.dwFlags = DDBLT_COLORFILL | DDBLT_WAIT;
    ColorFill.rDest.right = Width();
    ColorFill.rDest.bottom = Height();

    // Switch between magenta and the inverse
    static BOOL bMagenta = FALSE;

    DWORD Color;
    switch(Device()->DisplayFormat())
    {
    case D3DFMT_X8R8G8B8:
    case D3DFMT_R8G8B8:
        if (bMagenta)
            Color = 0x00FF007F;
        else
            Color = 0x0000FF00;
        break;
    case D3DFMT_X1R5G5B5:
        if (bMagenta)
            Color = 0x7C0F;
        else    
            Color = 0x03E0;
        break;
    case D3DFMT_R5G6B5:
        if (bMagenta)
            Color = 0xF80F;
        else    
            Color = 0x07E0;
        break;
    }
    if (bMagenta)
        bMagenta = FALSE;
    else
        bMagenta = TRUE;

    ColorFill.bltFX.dwFillColor = Color;

    // In debug we want to clear the back-buffer
    // if we're in discard mode
    Device()->GetHalCallbacks()->Blt(&ColorFill);

    return;
} // DebugDiscardBackBuffer

#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Present"

//=============================================================================
// IDirect3DSwapChain8::Present (public)
//
// Moves data from back-buffer to the primary
//
// Created 11/16/1999 johnstep
//=============================================================================
STDMETHODIMP
CSwapChain::Present(
    CONST RECT    *pSrcRect,
    CONST RECT    *pDestRect,
    HWND    hWndDestOverride,
    CONST RGNDATA *pDirtyRegion
  )
{
    API_ENTER(Device());

    HRESULT hr = E_FAIL;

    // First, fail if the device is lost
    if (D3D8IsDeviceLost(Device()->GetHandle()))
    {
        return D3DERR_DEVICELOST;
    }

    if (!m_ppBackBuffers)
    {
        return D3DERR_DEVICELOST;
    }

    if (D3DSWAPEFFECT_FLIP == m_PresentationData.SwapEffect)
    {
        if (NULL != pSrcRect || NULL != pDestRect || NULL != pDirtyRegion)
        {
            DPF_ERR("pSrcRect pDestRect pDirtyRegion must be NULL with "
                "D3DSWAPEFFECT_FLIP. Present Fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (NULL != pDirtyRegion)
    {
        DPF_ERR("Present with non-null pDirtyRegion is not supported");
        return D3DERR_INVALIDCALL;         
    }

    for (UINT i = 0; i < m_cBackBuffers; i++)
    {
        if (m_ppBackBuffers[i]->IsLocked())
        {
            DPF_ERR("A BackBuffer in this swap chain is Locked. Present failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check if we need to act against HW that queues too much
    if (PresentUseBlt())
    {
        if (Device()->GetDeviceData()->DriverData.D3DCaps.MaxStreams == 0)
        {
            // Only pre-DX8 level drivers are suspected...

            if (0 == (Device()->GetDeviceData()->DriverData.KnownDriverFlags & KNOWN_NOTAWINDOWEDBLTQUEUER))
            {
                // We don't want to treat a vis-region change as a failure to
                // prevent the thunk layer from calling Reset. Reset
                // confuses the clip-list caching that is done for Present.
                // 
                // Also we want don't want to spew any errors here.
                DPF_MUTE();

                D3DLOCKED_RECT LockRect;
                // all we need is a Lock sent down to driver so it would flush the queue
                // therefore 1x1 rect is enough, larger area of lock would cause sprites to flick 
                // and therefore also slow down the system.
                RECT    DummyRect={0,0,1,1}; 
                hr = m_pPrimarySurface->InternalLockRect(&LockRect, &DummyRect, DDLOCK_FAILONVISRGNCHANGED);
                if (SUCCEEDED(hr))
                {
                    m_pPrimarySurface->InternalUnlockRect();
                }
                else
                {
                    hr = S_OK;
                }

                DPF_UNMUTE();
            }
        }
    }

#ifdef WINNT
    // If ~ 50 seconds have passed (assuming a 10Hz flip rate)
    // and this is a primary surface, then make a magic call to 
    // disable screen savers.
    // This isn't needed on 9x since we make a SPI call on that OS
    // to disable screen savers.
     
    if (0 == (Device()->BehaviorFlags() & 0x10000000))      //SCREENSAVER magic number
    {
        if (!m_PresentationData.Windowed)
        {
            static DWORD dwMagicTime = 0;
            dwMagicTime++;
            if (dwMagicTime > (50*10) )
            {
                DWORD dw=60*15;
                dwMagicTime = 0;
                SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT,0,&dw,0);
                SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT,dw,0,0);
            }
        }
    }
#endif


    // Flush any pending commands before we send the Flip/Blt
    static_cast<CD3DBase*>(Device())->FlushStatesNoThrow();
    
    if ( FALSE == PresentUseBlt())
    {
        // We are fullscreen, so turn this into a flip
        DXGASSERT(0==m_presentnext);
        hr = FlipToSurface(BackBuffer(0)->KernelHandle());
    }
    else
    {
        if (m_PresentationData.Windowed)
        {
            RECT    DestRect;
            //
            // Choose the presentation window. Override, or device window?
            //
            if (hWndDestOverride)
                m_BltData.hWnd = hWndDestOverride;
            else
                m_BltData.hWnd = m_PresentationData.hDeviceWindow;
            //The left and top members are zero. The right and bottom 
            //members contain the width and height of the window. 
            if (!GetClientRect(m_BltData.hWnd, &DestRect))
            {
                // in case of this unlikely event, fail it
                DPF_ERR("Unable to get client during presentation");
                return D3DERR_INVALIDCALL;
            }
            if (((UINT)DestRect.bottom != m_ClientHeight)
                || ((UINT)DestRect.right != m_ClientWidth)
               )
            {
                m_bClientChanged = TRUE;
                m_ClientHeight = (UINT)DestRect.bottom;
                m_ClientWidth = (UINT)DestRect.right;
            }
        }
        if (D3DSWAPEFFECT_FLIP != m_PresentationData.SwapEffect)
        {
            if (pSrcRect)
            {
                if (m_pSrcRect)
                {
                    if (memcmp(pSrcRect,m_pSrcRect,sizeof RECT))      
                    {
                        m_bClientChanged = TRUE;
                        m_SrcRect = *pSrcRect;
                    }
                }
                else
                {
                    m_bClientChanged = TRUE;
                    m_pSrcRect = &m_SrcRect;
                    m_SrcRect = *pSrcRect;
                }
            }
            else if (m_pSrcRect)
            {
                m_bClientChanged = TRUE;
                m_pSrcRect = NULL;
            }
            if (pDestRect)
            {
                if (m_pDstRect)
                {
                    if (memcmp(pDestRect,m_pDstRect,sizeof RECT))      
                    {
                        m_bClientChanged = TRUE;
                        m_DstRect = *pDestRect;
                    }
                }
                else
                {
                    m_bClientChanged = TRUE;
                    m_pDstRect = &m_DstRect;
                    m_DstRect = *pDestRect;
                }
            }
            else if (m_pDstRect)
            {
                m_bClientChanged = TRUE;
                m_pDstRect = NULL;
            }
        }
        if (m_bClientChanged)
        {
            m_bClientChanged = FALSE;
            m_BltData.rSrc.left = m_BltData.rSrc.top = 0;
            m_BltData.rSrc.right = Width();
            m_BltData.rSrc.bottom = Height();
            m_BltData.rDest.left = m_BltData.rDest.top = 0;
            m_BltData.rDest.right = m_ClientWidth;
            m_BltData.rDest.bottom = m_ClientHeight;
            hr = ClipRects((RECT*)&m_BltData.rSrc, (RECT*)&m_BltData.rDest,
                m_pSrcRect, m_pDstRect);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        m_BltData.hSrcSurface =
            m_ppBackBuffers[m_presentnext]->KernelHandle();

        // Lock the software driver created buffer
        // and unlock it immediately
        if ((D3DDEVTYPE_HAL != Device()->GetDeviceType()) &&
            (D3DMULTISAMPLE_NONE != m_PresentationData.MultiSampleType)
           )
        {
            D3D8_LOCKDATA lockData;
            ZeroMemory(&lockData, sizeof lockData);
            lockData.hDD = Device()->GetHandle();
            lockData.hSurface = m_BltData.hSrcSurface;
            lockData.dwFlags = DDLOCK_READONLY;
            hr = Device()->GetHalCallbacks()->Lock(&lockData);
            if (SUCCEEDED(hr))
            {
                D3D8_UNLOCKDATA unlockData;
                ZeroMemory(&unlockData, sizeof unlockData);

                unlockData.hDD = Device()->GetHandle();
                unlockData.hSurface = m_BltData.hSrcSurface;
                hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
                if (FAILED(hr))
                {
                    DPF_ERR("Driver failed to unlock MultiSample backbuffer. Present fails.");
                    return  hr;
                }
            }
            else
            {
                DPF_ERR("Driver failed to lock MultiSample backbuffer. Present Fails.");
                return  hr;
            }
        }

        if (DDHAL_DRIVER_NOTHANDLED
            == Device()->GetHalCallbacks()->Blt(&m_BltData))
        {
            hr = E_FAIL;
        }
        else
        {
            hr = m_BltData.ddRVal;

            // Handle deferred DP2 errors specially
            if (hr == D3DERR_DEFERRED_DP2ERROR)
            {
                // We only want to make this "error" visible
                // if we have been created with the right flag
                if (Device()->BehaviorFlags() & D3DCREATE_SHOW_DP2ERROR)
                {
                    DPF_ERR("A prior call to DrawPrim2 has failed; returning error from Present.");
                }
                else
                {
                    // Quietly just mask this error; this is ok; because
                    // we known that the Blt succeeded
                    hr = S_OK;
                }
            }
        }

        if (FAILED(hr))
        {
            DPF_ERR("BitBlt or StretchBlt failed in Present");
            return hr;
        }

        // Clear the backbuffer if the user has specified
        // discard semantics
        DebugDiscardBackBuffer(m_BltData.hSrcSurface);

        if (m_pMirrorSurface)
        {
            hr = FlipToSurface(m_pMirrorSurface->KernelHandle());
            // need to reset it
            m_BltData.hDestSurface = m_pMirrorSurface->KernelHandle();
            if (FAILED(hr))
            {
                DPF_ERR("Driver failed Flip. Present Fails.");
                return  hr;
            }
        }

        if (m_cBackBuffers > 1)
        {
            if (m_PresentationData.SwapEffect == D3DSWAPEFFECT_FLIP)
            {
                HANDLE hRenderTargetHandle = 
                            Device()->RenderTarget()->KernelHandle();
                BOOL    bNeedSetRendertarget = FALSE;

                HANDLE  hSurfTarg   = BackBuffer(0)->KernelHandle();

                DXGASSERT(0 == m_presentnext);
                for (int i = m_cBackBuffers - 1; i >= 0; i--)
                {
                    if (hSurfTarg == hRenderTargetHandle)
                        bNeedSetRendertarget = TRUE;

                    // This swap handles function will
                    // return the value that were currently
                    // in the surface; which we use to
                    // pass to the next surface.
                    m_ppBackBuffers[i]->SwapKernelHandles(&hSurfTarg);
                }
                if (bNeedSetRendertarget)
                    (static_cast<CD3DBase*>(Device()))->SetRenderTargetI(
                        Device()->RenderTarget(),
                        Device()->ZBuffer());
            }
            else
            if (++m_presentnext >= m_cBackBuffers)
            {
                m_presentnext = 0;
            }
        }
    }
    if ( D3D_REGFLAGS_SHOWFRAMERATE & m_dwFlags)
    {
        UpdateFrameRate();
    }
    return hr;
} // Present

HRESULT 
CSwapChain::FlipToSurface(HANDLE hTargetSurface)
{
    HRESULT hr;
    D3D8_FLIPDATA   FlipData;
    HANDLE  hSurfTarg;
    FlipData.hDD            = Device()->GetHandle();
    FlipData.hSurfCurr      = PrimarySurface()->KernelHandle();
    FlipData.hSurfTarg      = hTargetSurface;
    FlipData.hSurfCurrLeft  = NULL;
    FlipData.hSurfTargLeft  = NULL;
    FlipData.dwFlags        = m_dwFlipFlags;
    m_pCursor->Flip();
    hr = m_pCursor->Show(FlipData.hSurfTarg);
    Device()->GetHalCallbacks()->Flip(&FlipData);
    m_pCursor->Flip();
    hr = m_pCursor->Hide(FlipData.hSurfCurr);
    m_pCursor->Flip();
    hr = FlipData.ddRVal;

    // Handle deferred DP2 errors specially
    if (hr == D3DERR_DEFERRED_DP2ERROR)
    {
        // We only want to make this "error" visible
        // if we have been created with the right flag
        if (Device()->BehaviorFlags() & D3DCREATE_SHOW_DP2ERROR)
        {
            DPF_ERR("A prior call to DrawPrim2 has failed; returning error from Present.");
        }
        else
        {
            // Quietly just mask this error; this is ok; because
            // we known that the Flip succeeded
            hr = S_OK;
        }
    }


    // In debug, we may need to clear the data from
    // our new back-buffer if the user specified
    // SWAPEFFECT_DISCARD
    DebugDiscardBackBuffer(FlipData.hSurfCurr);   

    if (m_pMirrorSurface)
    {
        hSurfTarg = PrimarySurface()->KernelHandle();
        m_pMirrorSurface->SwapKernelHandles(&hSurfTarg);
        PrimarySurface()->SwapKernelHandles(&hSurfTarg);
    }
    else
    {
        HANDLE hRenderTargetHandle;
        CBaseSurface*   pRenderTarget = Device()->RenderTarget();
        if (pRenderTarget)
            hRenderTargetHandle = pRenderTarget->KernelHandle();
        else
            hRenderTargetHandle = 0;

        while (hTargetSurface != PrimarySurface()->KernelHandle())
        {
            hSurfTarg = PrimarySurface()->KernelHandle();
            for (int i = m_cBackBuffers-1; i>=0; i--)
            {
                BackBuffer(i)->SwapKernelHandles(&hSurfTarg);
            }
            PrimarySurface()->SwapKernelHandles(&hSurfTarg);
        }
        if (hRenderTargetHandle)
        {
            BOOL bNeedSetRendertarget;
            if (PrimarySurface()->KernelHandle() == hRenderTargetHandle)
            {
                bNeedSetRendertarget = TRUE;
            }
            else
            {
                bNeedSetRendertarget = FALSE;
                for (int i = m_cBackBuffers-1; i>=0; i--)
                {
                    if (BackBuffer(i)->KernelHandle() == hRenderTargetHandle)
                    {
                        bNeedSetRendertarget = TRUE;
                        break;
                    }
                }
            }
            if (bNeedSetRendertarget)
            {
                (static_cast<CD3DBase*>(Device()))->SetRenderTargetI(
                    Device()->RenderTarget(),
                    Device()->ZBuffer());
            }
        }
    }
    return hr;
}

HRESULT 
CSwapChain::FlipToGDISurface(void)
{
    D3D8_FLIPTOGDISURFACEDATA FlipToGDISurfaceData;
    FlipToGDISurfaceData.ddRVal = DD_OK;
    FlipToGDISurfaceData.dwToGDI = TRUE;
    FlipToGDISurfaceData.hDD = Device()->GetHandle();
    Device()->GetHalCallbacks()->FlipToGDISurface(&FlipToGDISurfaceData);
    if (NULL != m_hGDISurface && PrimarySurface() &&
        PrimarySurface()->KernelHandle() != m_hGDISurface)
    {
        return  FlipToSurface(m_hGDISurface); 
    }
    return FlipToGDISurfaceData.ddRVal;
} // FlipToGDISurface

void
CSwapChain::SetGammaRamp(
    DWORD dwFlags,          // Calibrated or not.
    CONST D3DGAMMARAMP *pRamp)
{
    D3DGAMMARAMP TempRamp;
    D3DGAMMARAMP * pRampToPassToHardware;

    m_DesiredGammaRamp = *pRamp;

    // Assume this for now. Calibration may use a temporary.
    pRampToPassToHardware = &m_DesiredGammaRamp;


    // If they want to calibrate the gamma, we will do that now.  We will
    // copy this to a different buffer so that we don't mess up the one
    // passed in to us.
    if (dwFlags & D3DSGR_CALIBRATE)
    {

        TempRamp = *pRamp;

        Device()->Enum()->LoadAndCallGammaCalibrator(
            &TempRamp,
            (UCHAR*) Device()->GetDeviceData()->DriverName);

        pRampToPassToHardware = &TempRamp;
    }


    DXGASSERT(pRampToPassToHardware);
    DXGASSERT(Device()->GetDeviceData()->hDD);
    DXGASSERT(Device()->GetDeviceData()->hDC);
    D3D8SetGammaRamp(
        Device()->GetDeviceData()->hDD,
        Device()->GetDeviceData()->hDC,
        pRampToPassToHardware);
    if (pRamp != NULL)
    {
        m_GammaSet = TRUE;
    }
    else
    {
        m_GammaSet = FALSE;
    }
}

void
CSwapChain::GetGammaRamp(
    D3DGAMMARAMP *pRamp)
{
    *pRamp = m_DesiredGammaRamp;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::SetCooperativeLevel"  

/*
 * DD_SetCooperativeLevel
 */
HRESULT 
CSwapChain::SetCooperativeLevel()
{
#if _WIN32_WINNT >= 0x0501
    {
        //Turn off ghosting for any exclusive-mode app
        //(Whistler onwards only)
        typedef void (WINAPI *PFN_NOGHOST)( void );
        HINSTANCE hInst = NULL;
        hInst = LoadLibrary( "user32.dll" );
        if( hInst )
        {
            PFN_NOGHOST pfnNoGhost = NULL;
            pfnNoGhost = (PFN_NOGHOST)GetProcAddress( (HMODULE)hInst, "DisableProcessWindowsGhosting" );
            if( pfnNoGhost )
            {
                pfnNoGhost();
            }
            FreeLibrary( hInst );
        }
    }
#endif // _WIN32_WINNT >= 0x0501

    HRESULT ddrval;
#ifndef  WINNT
    ddrval = D3D8SetCooperativeLevel(Device()->GetHandle(),
        m_PresentationData.hDeviceWindow,
        m_PresentationData.Windowed ? DDSCL_NORMAL : 
            (DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_SETDEVICEWINDOW));
    if (FAILED(ddrval))
        return ddrval;
#else
    BOOL    bThisDeviceOwnsExclusive;
    BOOL    bExclusiveExists;

    bExclusiveExists = 
        Device()->Enum()->CheckExclusiveMode(Device(), 
            &bThisDeviceOwnsExclusive,
            !m_PresentationData.Windowed);
    /*
     * exclusive mode?
     */
    if (m_PresentationData.Windowed)
    /*
     * no, must be regular
     */
    {
        DoneExclusiveMode(FALSE);
        ddrval = SetAppHWnd();
    }
    if (bExclusiveExists && !bThisDeviceOwnsExclusive)
    {
        DPF_ERR("Exclusive Mode has been taken by other app or "
            "other device on the same adapter. "
            "SetCooperativeLevel returns D3DERR_DEVICELOST.");
        return D3DERR_DEVICELOST;            
    }
    if (!m_PresentationData.Windowed)
    {
        if (GetWindowLong(Device()->FocusWindow(), GWL_STYLE) & WS_CHILD)
        {
            DPF_ERR( "Focus Window must be a top level window. CreateDevice fails." );
            return D3DERR_INVALIDCALL;
        }

        ddrval = SetAppHWnd();
        if (S_OK == ddrval)
        {
            StartExclusiveMode(FALSE);
            SetForegroundWindow(m_PresentationData.hDeviceWindow);
        }
    }
#endif
    return ddrval;

} /* SetCooperativeLevel */

#ifdef WINNT
/*
 * PickRefreshRate
 *
 * On NT, we want to pick a high reffresh rate, but we don't want to pick one 
 * too high.  In theory, mode pruning would be 100% safe and we can always pick
 * a high one, but we don't trust it 100%.  
 */
DWORD 
CSwapChain::PickRefreshRate(
    DWORD           Width,
    DWORD           Height,
    DWORD           RefreshRate,
    D3DFORMAT       Format)
{
    D3DFORMAT   FormatWithoutAlpha;
    D3DDISPLAYMODE* pModeTable = Device()->GetModeTable();
    DWORD dwNumModes = Device()->GetNumModes();
    DWORD i;

    FormatWithoutAlpha = CPixel::SuppressAlphaChannel(Format);

    // We will always use the refresh rate from the registry if it's specified.

    if (m_dwForceRefreshRate > 0)
    {
        for (i = 0; i < dwNumModes; i++)
        {
            if ((pModeTable[i].Width  == Width) &&
                (pModeTable[i].Height == Height) &&
                (pModeTable[i].Format == FormatWithoutAlpha) &&
                (m_dwForceRefreshRate == pModeTable[i].RefreshRate))
            {
                return m_dwForceRefreshRate;
            }
        }
    }

    // If the app specified the refresh rate, then we'll use it; otherwise, we
    // will pick one ourselves.

    if (RefreshRate == 0)
    {
        // If the mode requires no more bandwidth than the desktop mode from which
        // the app was launched, we will go ahead and try that mode.

        DEVMODE dm;
        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        EnumDisplaySettings(Device()->GetDeviceData()->DriverName, 
            ENUM_REGISTRY_SETTINGS, &dm);

        if ((Width <= dm.dmPelsWidth) &&
            (Height <= dm.dmPelsHeight))
        {
            // Now check to see if it's supported
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width) &&
                    (pModeTable[i].Height == Height) &&
                    (pModeTable[i].Format == FormatWithoutAlpha) &&
                    (dm.dmDisplayFrequency == pModeTable[i].RefreshRate))
                {
                    RefreshRate = dm.dmDisplayFrequency;
                    break;
                }
            }
        }

        // If we still don't have a refresh rate, try 75hz
        if (RefreshRate == 0)
        {
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width) &&
                    (pModeTable[i].Height == Height) &&
                    (pModeTable[i].Format == FormatWithoutAlpha) &&
                    (75 == pModeTable[i].RefreshRate))
                {
                    RefreshRate = 75;
                    break;
                }
            }
        }

        // If we still don't have a refresh rate, use 60hz
        if (RefreshRate == 0)
        {
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width) &&
                    (pModeTable[i].Height == Height) &&
                    (pModeTable[i].Format == FormatWithoutAlpha) &&
                    (pModeTable[i].RefreshRate == 60))
                {
                    RefreshRate = pModeTable[i].RefreshRate;
                    break;
                }
            }
        }
    }

    return RefreshRate;
}
#endif

// End of file : swapchain.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\texture.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       texture.cpp
 *  Content:    Implementation of the CBaseTexture class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "texture.hpp"
#include "d3di.hpp"
#include "ddi.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::CanTexBlt"

BOOL CBaseTexture::CanTexBlt(CBaseTexture *pDstTexture) const
{
    const D3D8_DRIVERCAPS* pDriverCaps = Device()->GetCoreCaps();
    D3DPOOL SrcPool = GetBufferDesc()->Pool;
    D3DPOOL DstPool = pDstTexture->GetBufferDesc()->Pool;

    // Real pools should not be default
    DXGASSERT(SrcPool != D3DPOOL_DEFAULT);
    DXGASSERT(DstPool != D3DPOOL_DEFAULT);
    DXGASSERT(VALID_INTERNAL_POOL(SrcPool));
    DXGASSERT(VALID_INTERNAL_POOL(DstPool));

    // Check if the device can do TexBlt
    if (Device()->CanTexBlt() == FALSE)
        return FALSE;

    // Check that source and dest formats match
    DXGASSERT(GetBufferDesc()->Format == pDstTexture->GetBufferDesc()->Format);

    // FourCC may not be copy-able        
    if (CPixel::IsFourCC(GetBufferDesc()->Format))
    {
        if (!(pDriverCaps->D3DCaps.Caps2 & DDCAPS2_COPYFOURCC))
        {
            return FALSE;
        }
    }

    // Note that we do not support TexBlt to anything 
    // that is persistent across Reset; because TexBlt is
    // asynchronous and may not succeed if we get lost. 
    // 
    // This can break apps that expect the blt to have
    // succeeded.

    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if ((DstPool == D3DPOOL_NONLOCALVIDMEM) &&
                (pDriverCaps->D3DCaps.DevCaps & D3DDEVCAPS_CANBLTSYSTONONLOCAL))
            {
                return TRUE;
            }
            else if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                      (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if (SrcPool == D3DPOOL_NONLOCALVIDMEM)
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->NLVCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }
    else
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
} // CBaseTexture::CanTexBlt


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::VerifyFormat"

HRESULT CBaseTexture::Validate(CBaseDevice    *pDevice,
                               D3DRESOURCETYPE Type, 
                               D3DPOOL         Pool,
                               DWORD           Usage,
                               D3DFORMAT       Format)
{
    DXGASSERT(pDevice);
    DXGASSERT(Type == D3DRTYPE_TEXTURE       ||
              Type == D3DRTYPE_CUBETEXTURE   ||
              Type == D3DRTYPE_VOLUMETEXTURE);

    // Check pool
    if (!VALID_POOL(Pool))
    {
        DPF_ERR("Invalid Pool specified for texture");
        return D3DERR_INVALIDCALL;
    }

    //pool scratch doesn't allow any usages
    if (Pool == D3DPOOL_SCRATCH)
    {
        if (Usage)
        {
            DPF_ERR("D3DPOOL_SCRATCH resources aren't allowed to have any usage flags");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check usage flags
    if (Usage & ~D3DUSAGE_TEXTURE_VALID)
    {
        DPF_ERR("Invalid usage flag specified for texture.");
        return D3DERR_INVALIDCALL;
    }

    // Check if USAGE_DYNAMIC is allowed
    if (Usage & D3DUSAGE_DYNAMIC)
    {
        if (Pool == D3DPOOL_MANAGED)
        {
            DPF_ERR("Managed textures cannot be dynamic.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check is load-once is supported
    if (Usage & D3DUSAGE_LOADONCE)
    {
        // Only SysMem and Managed are load-once-able
        if (Pool != D3DPOOL_SYSTEMMEM &&
            Pool != D3DPOOL_MANAGED)
        {
            DPF_ERR("Only SysMem and Managed textures support D3DUSAGE_LOADONCE");
            return D3DERR_INVALIDCALL;
        }

        // Only D16_LOCKABLE is a lockable depth; doesn't 
        // make sense to have a non-lockable LOAD_ONCE texture
        if (CPixel::IsNonLockableZ(Format))
        {
            DPF_ERR("Depth formats other than D3DFMT_D16_LOCKABLE are not lockable.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check that only POOL_DEFAULT is supported for
    // RT or DS textures
    if (Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL))
    {
        if (Pool != D3DPOOL_DEFAULT)
        {
            DPF_ERR("Pool must be D3DPOOL_DEFAULT for RenderTarget and"
                    " DepthStencil Usages");
            return D3DERR_INVALIDCALL;
        }
    }

    // Sys scratch or Managed must have a format that we can use directly
    if (Pool == D3DPOOL_SYSTEMMEM  || 
        Pool == D3DPOOL_MANAGED ||
        Pool == D3DPOOL_SCRATCH)
    {
        // Can't create format unless it is supported
        if (!CPixel::IsSupported(Type, Format))
        {
            DPF_ERR("SystemMem, Scratch and Managed textures do not support this"
                    " format.");
            return D3DERR_INVALIDCALL;
        }
        if (CPixel::IsNonLockableZ(Format))
        {
            DPF_ERR("This format is not supported for SystemMem, Scratch or Managed textures");
            return D3DERR_INVALIDCALL;
        }
    }

    if (Pool != D3DPOOL_SCRATCH)
    {
        HRESULT hr = pDevice->CheckDeviceFormat(Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL | D3DUSAGE_DYNAMIC), 
                                                Type, 
                                                Format);
        if (FAILED(hr))
        {
            DPF_ERR("Invalid format specified for texture");
            return D3DERR_INVALIDCALL;
        }
    }

    return S_OK;
}; // CBaseTexture::Validate

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::InferUsageFlags"

// Infer usage flags based on external parameters
DWORD CBaseTexture::InferUsageFlags(D3DPOOL            Pool,
                                    DWORD              Usage,
                                    D3DFORMAT          Format)
{
    //scratch textures have only usage lock
    if (Pool == D3DPOOL_SCRATCH)
        return D3DUSAGE_LOCK;

    // All textures have this usage set
    DWORD UsageInferred = D3DUSAGE_TEXTURE;

    DXGASSERT(!(Usage & D3DUSAGE_LOCK));
    DXGASSERT(!(Usage & D3DUSAGE_TEXTURE));

    // Infer Lock 
    if ((Pool != D3DPOOL_DEFAULT)       &&
        !(CPixel::IsNonLockableZ(Format)) &&
        !(Usage & D3DUSAGE_LOADONCE))
    {
        // Pool Default is not lockable
        // Usage Load Once implies absence of USAGE_LOCK
        // Z formats (other than D16_LOCKABLE) are not lockable

        // Otherwise, locking is support by default
        UsageInferred |= D3DUSAGE_LOCK;
    }
    else if (CPixel::IsIHVFormat(Format))
    {
        // IHV formats are lockable
        UsageInferred |= D3DUSAGE_LOCK;
    }
    else if (Usage & D3DUSAGE_DYNAMIC)
    {
        DXGASSERT(Pool != D3DPOOL_MANAGED);
        // Dynamic textures are lockable
        UsageInferred |= D3DUSAGE_LOCK;
    }

    return (UsageInferred | Usage);

} // CBaseTexture::InferUsageFlags

#ifdef DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ReportWhyLockFailed"

// DPF why Lock failed as clearly as possible
void CBaseTexture::ReportWhyLockFailed(void) const
{
    // If there are multiple reasons that lock failed; we report
    // them all to minimize user confusion
    if (GetUserPool() == D3DPOOL_DEFAULT)
    {
        DPF_ERR("Lock is not supported for textures allocated with"
                " POOL_DEFAULT unless they are marked D3DUSAGE_DYNAMIC.");
    }
    if (CPixel::IsNonLockableZ(GetUserFormat()))
    {
        DPF_ERR("Lock is not supported for depth formats other than D3DFMT_D16_LOCKABLE");
    }
    if (GetBufferDesc()->Usage & D3DUSAGE_LOADONCE)
    {
        DPF_ERR("For textures created with D3DUSAGE_LOADONCE,"
                " each level can only be locked once.");
    }

    // If we got here; then USAGE_LOCK should not have been set
    DXGASSERT(!(GetBufferDesc()->Usage & D3DUSAGE_LOCK));

    return;
} // CBaseTexture::ReportWhyLockFailed
#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::OnDestroy"
// Textures overload this to call OnTextureDestroy on the 
// Device before calling Sync.
void CBaseTexture::OnDestroy(void)
{
    if (GetUserPool() != D3DPOOL_SCRATCH)
    {
        // we need to call this before freeing the texture so
        // that currently set textures get unset.
        if (BaseKernelHandle())
        {
            // m_hKernelHandle might not be available if Create fails early
            CD3DBase *pDev = static_cast<CD3DBase *>(Device());
            pDev->OnTextureDestroy(this);
        }

        // After FE has been notified, then we need
        // to sync; so call our base class
        CResource::OnDestroy();
    }

    return;
} // CBaseTexture::OnDestroy

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::SetLODImpl"

DWORD CBaseTexture::SetLODImpl(DWORD LOD)
{
    // Clamp to max lod since we can't return errors
    if (LOD >= GetLevelCountImpl())
    {
        DPF_ERR("Invalid dwLOD passed to SetLOD; clamping to number-of-levels-minus-one.");
        LOD = GetLevelCountImpl() - 1;
    }

    DWORD oldLOD = 0;
    if (IsD3DManaged())
    {
        oldLOD = Device()->ResourceManager()->SetLOD(RMHandle(), LOD);
    }
    // If IsD3DManaged() is FALSE and if the actual pool
    // is found to be D3DPOOL_MANAGED then the resource
    // MUST be driver managed.
    else if (GetBufferDesc()->Pool == D3DPOOL_MANAGED)
    {
        CD3DBase *pDev = static_cast<CD3DBase*>(Device());
        DXGASSERT(IS_DX8HAL_DEVICE(pDev));
        oldLOD = SetLODI(LOD);
        pDev->SetTexLOD(this, LOD);
    }
    // If above two conditions are false, then we must
    // check if we have fallen back to sysmem for some
    // reason even if the app requested managed. THIS
    // IS IMPOSSIBLE, so ASSERT.
    else if (GetUserPool() == D3DPOOL_MANAGED)
    {
        // We assert because sysmem fallback is not possible
        // for textures (and hence SetLOD)
        DXGASSERT(FALSE);
    }
    else
    {
        DPF_ERR("LOD set on non-managed object");
    }
    return oldLOD;
}; // SetLODImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::GetLODImpl"

DWORD CBaseTexture::GetLODImpl()
{
    if (!IsD3DManaged() && GetBufferDesc()->Pool != D3DPOOL_MANAGED)
    {
        DPF_ERR("LOD accessed on non-managed object");
        return 0;
    }
    return GetLODI();
}; // GetLODImpl

// End of file : texture.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\swddi.c ===
#include "ddrawpr.h"
#include <ddrawint.h>
#include "ddithunk.h"
#include <d3d8sddi.h>

typedef struct
{
    DDRAWI_DDRAWSURFACE_LCL     Lcl;
    DDRAWI_DDRAWSURFACE_GBL     Gbl;
    DDRAWI_DDRAWSURFACE_MORE    More;
    ATTACHLIST                  From;
    ATTACHLIST                  To;
} SWDDIDDRAWI_LCL;

LPDDRAWI_DDRAWSURFACE_LCL
SwDDIBuildHeavyWeightSurface (
    LPDDRAWI_DIRECTDRAW_LCL pDDrawLocal,
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL* pSurfaceLocal,
    DD_SURFACE_GLOBAL* pSurfaceGlobal,
    DD_SURFACE_MORE* pSurfaceMore,
    DWORD index)
{
    SWDDIDDRAWI_LCL             *pSWDDILcl;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;

    pSWDDILcl = MemAlloc(sizeof(*pSWDDILcl));
    if (pSWDDILcl == NULL)
    {
        return NULL;
    }

    pLcl = &pSWDDILcl->Lcl;

    pLcl->lpGbl = &pSWDDILcl->Gbl;
    pLcl->lpSurfMore = &pSWDDILcl->More;

    memcpy(&pLcl->lpGbl->ddpfSurface, &pSurfaceGlobal->ddpfSurface, sizeof(DDPIXELFORMAT));
    pLcl->lpGbl->wWidth                 = (WORD) pSurfaceGlobal->wWidth;
    pLcl->lpGbl->wHeight                = (WORD) pSurfaceGlobal->wHeight;
    pLcl->ddsCaps                       = pSurfaceLocal->ddsCaps;
    pLcl->lpSurfMore->ddsCapsEx         = pSurfaceMore->ddsCapsEx;
    pLcl->lpSurfMore->dwSurfaceHandle   = pSurfaceMore->dwSurfaceHandle;
    pLcl->lpSurfMore->lpDD_lcl          = pDDrawLocal;
    pLcl->dwFlags                       = pSurfaceLocal->dwFlags;

    pLcl->lpGbl->fpVidMem               = (FLATPTR) pCreateSurface->pSList[index].pbPixels;
    pLcl->lpGbl->lPitch                 = pCreateSurface->pSList[index].iPitch;

    if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLcl->lpGbl->lSlicePitch = pCreateSurface->pSList[index].iSlicePitch;
    }

    return pLcl;
}


void
SwDDICreateSurfaceEx(LPDDRAWI_DIRECTDRAW_LCL pDrv,
                     LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_CREATESURFACEEXDATA   CreateExData;

    if ((pLcl != NULL) &&
        (pCallbacks->CreateSurfaceEx != NULL))
    {
        CreateExData.dwFlags = 0;
        CreateExData.lpDDLcl = pDrv;
        CreateExData.lpDDSLcl = pLcl;

        pCallbacks->CreateSurfaceEx(&CreateExData);
    }
}


HRESULT
SwDDICreateSurface(PD3D8_CREATESURFACEDATA pCreateSurface,
                    DD_SURFACE_LOCAL* pDDSurfaceLocal,
                    DD_SURFACE_GLOBAL* pDDSurfaceGlobal,
                    DD_SURFACE_MORE*  pDDSurfaceMore)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv =
        ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDD;
    DDHAL_CREATESURFACEDATA CreateSurfaceData;
    PD3D8_SWCALLBACKS pCallbacks =
        (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    DDSURFACEDESC2 SurfaceDesc;
    DWORD i;


    if (pCallbacks->CreateSurface)
    {
        memset(&CreateSurfaceData, 0, sizeof(CreateSurfaceData));
        CreateSurfaceData.lpDD = pDrv->lpGbl;
        CreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*) &SurfaceDesc;
        CreateSurfaceData.lplpSList = NULL;
        CreateSurfaceData.dwSCnt = pCreateSurface->dwSCnt;
        CreateSurfaceData.lplpSList = (LPDDRAWI_DDRAWSURFACE_LCL*)
            MemAlloc(sizeof(LPDDRAWI_DDRAWSURFACE_LCL) * CreateSurfaceData.dwSCnt);
        if (CreateSurfaceData.lplpSList == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // Build a surface desc

        RtlZeroMemory(&SurfaceDesc, sizeof(SurfaceDesc));
        SurfaceDesc.dwSize = sizeof(SurfaceDesc);
        SurfaceDesc.ddsCaps.dwCaps = pDDSurfaceLocal[0].ddsCaps.dwCaps;
        SurfaceDesc.ddpfPixelFormat = pDDSurfaceGlobal[0].ddpfSurface;
        if (pCreateSurface->Type == D3DRTYPE_TEXTURE)
        {
            SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt;
        }
        else if (pCreateSurface->dwSCnt > 1)
        {
            SurfaceDesc.dwBackBufferCount = pCreateSurface->dwSCnt - 1;
            SurfaceDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        }
        SurfaceDesc.dwHeight = pDDSurfaceGlobal[0].wHeight;
        SurfaceDesc.dwWidth = pDDSurfaceGlobal[0].wWidth;
        SurfaceDesc.dwFlags |= DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
        if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            SurfaceDesc.dwFlags |= DDSD_PIXELFORMAT;
        }
        if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
        {
            SurfaceDesc.dwFVF = pCreateSurface->dwFVF;
            SurfaceDesc.dwFlags |= DDSD_FVF;
        }

        // Have to build a heavy weight surface structure that the driver
        // can understand

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            CreateSurfaceData.lplpSList[i] =
                ((PDDSURFHANDLE)pCreateSurface->pSList[i].hKernelHandle)->pLcl;
        }

        dwRet = pCallbacks->CreateSurface(&CreateSurfaceData);

        // Now copy the fpVidMem and the pitch that the driver setup
        // back to the permanent structures

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            pCreateSurface->pSList[i].pbPixels = (BYTE*)
                CreateSurfaceData.lplpSList[i]->lpGbl->fpVidMem;
            pCreateSurface->pSList[i].iPitch =
                CreateSurfaceData.lplpSList[i]->lpGbl->lPitch;

            if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
                (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pCreateSurface->pSList[i].iSlicePitch =
                    CreateSurfaceData.lplpSList[i]->lpGbl->lSlicePitch;
            }

        }

        // Now clean everything up

        MemFree(CreateSurfaceData.lplpSList);

        if (dwRet == DDHAL_DRIVER_NOTHANDLED)
        {
            DPF_ERR("Software Driver failed creation of surface");
            return E_FAIL;
        }
        return CreateSurfaceData.ddRVal;
    }
    else
    {
        DPF_ERR("Software Driver doesn't support creation of surfaces");
        return DDERR_UNSUPPORTED;
    }
}

void
SwDDIAttachSurfaces(LPDDRAWI_DDRAWSURFACE_LCL psurf_from_lcl, LPDDRAWI_DDRAWSURFACE_LCL psurf_to_lcl)
{
    LPATTACHLIST    pal_from;
    LPATTACHLIST    pal_to;

    /*
     * allocate attachment structures
     */
    pal_from = & (((SWDDIDDRAWI_LCL*) psurf_to_lcl)->From);
    pal_to = & (((SWDDIDDRAWI_LCL*) psurf_to_lcl)->To);

    /*
     * connect the surfaces
     */
    pal_from->lpAttached = psurf_to_lcl;
    pal_from->dwFlags = DDAL_IMPLICIT;
    pal_from->lpLink = psurf_from_lcl->lpAttachList;
    psurf_from_lcl->lpAttachList = pal_from;
    psurf_from_lcl->dwFlags |= DDRAWISURF_ATTACHED;

    pal_to->lpAttached = psurf_from_lcl;
    pal_to->dwFlags = DDAL_IMPLICIT;
    pal_to->lpLink = psurf_to_lcl->lpAttachListFrom;
    psurf_to_lcl->lpAttachListFrom = pal_to;
    psurf_to_lcl->dwFlags |= DDRAWISURF_ATTACHED_FROM;

}


DWORD WINAPI
SwContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)pCreateContext->hDD)->pDD;
    PD3D8_SWCALLBACKS   pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_CONTEXTCREATEDATA    ContextData;

    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    if (pCallbacks->CreateContext != NULL)
    {
        ContextData.lpDDLcl = pDrv;
        ContextData.lpDDSLcl = ((PDDSURFHANDLE)pCreateContext->hSurface)->pLcl;
        if (pCreateContext->hDDSZ == NULL)
        {
            ContextData.lpDDSZLcl = NULL;
        }
        else
        {
            ContextData.lpDDSZLcl = ((PDDSURFHANDLE)pCreateContext->hDDSZ)->pLcl;
        }
        ContextData.dwPID = pCreateContext->dwPID;
        ContextData.dwhContext = pCreateContext->dwhContext;

        dwRet = pCallbacks->CreateContext(&ContextData);

        pCreateContext->dwhContext = ContextData.dwhContext;
        pCreateContext->ddrval = MapLegacyResult(ContextData.ddrval);
    }

    return dwRet;
}


DWORD WINAPI
SwDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDSURFHANDLE)pdp2data->hDDCommands)->pDevice->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_DRAWPRIMITIVES2DATA  DP2Data;
    HRESULT                 hr;
    DWORD                   dwRet;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    if (pCallbacks->DrawPrimitives2 != NULL)
    {
        memcpy(&DP2Data, pdp2data, sizeof(DP2Data));
        DP2Data.lpDDCommands    = ((PDDSURFHANDLE)pdp2data->hDDCommands)->pLcl;
        if (!(DP2Data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            DP2Data.lpDDVertex  = ((PDDSURFHANDLE)pdp2data->hDDVertex)->pLcl;
        }

        dwRet = pCallbacks->DrawPrimitives2(&DP2Data);

        pdp2data->ddrval        = DP2Data.ddrval;
        pdp2data->dwErrorOffset = DP2Data.dwErrorOffset;

        // If the call to the driver succeded, swap the buffers if needed and
        // perform GetAliasVidmem
        if (dwRet == DDHAL_DRIVER_HANDLED && (DP2Data.ddrval == S_OK))
        {
            pdp2data->fpVidMem_CB = 0;
            pdp2data->dwLinearSize_CB = 0;
            pdp2data->fpVidMem_VB = 0;
            pdp2data->dwLinearSize_VB = 0;

            if (DP2Data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER)
            {
                // CONSIDER: Implement VidMem command buffer
            }

            if ((DP2Data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && !(DP2Data.dwFlags & D3DHALDP2_USERMEMVERTICES))
            {
                pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)pdp2data->hDDVertex)->fpVidMem;
                pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)pdp2data->hDDVertex)->dwLinearSize;
            }
        }

    }

    return dwRet;
}


DWORD
SwDDILock(HANDLE hDD, PDDSURFHANDLE   pSurf, DD_LOCKDATA* pLockData)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_LOCKDATA          LockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;

    LockData.lpDD = pDrv->lpGbl;
    LockData.lpDDSurface = pSurf->pLcl;
    LockData.bHasRect = pLockData->bHasRect;
    LockData.rArea = pLockData->rArea;
    LockData.dwFlags = pLockData->dwFlags;
    LockData.ddRVal = DDERR_WASSTILLDRAWING;
    LockData.lpSurfData = NULL;

    pSurf->pLcl->lpGbl->dwUsageCount++;
    while (LockData.ddRVal == DDERR_WASSTILLDRAWING)
    {
        if (pCallbacks->Lock != NULL)
        {
            dwRet = pCallbacks->Lock(&LockData);
        }
        else
        {
            LockData.ddRVal = E_FAIL;
        }
    }
    if (LockData.ddRVal != S_OK)
    {
        pSurf->pLcl->lpGbl->dwUsageCount--;
    }

    pLockData->ddRVal = LockData.ddRVal;
    pLockData->lpSurfData = LockData.lpSurfData;

    return dwRet;
}


DWORD
SwDDIUnlock(HANDLE hDD, PDDSURFHANDLE   pSurf, DD_UNLOCKDATA* pUnlockData)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_UNLOCKDATA        UnlockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;

    UnlockData.lpDD = pDrv->lpGbl;
    UnlockData.lpDDSurface = pSurf->pLcl;
    UnlockData.ddRVal = S_OK;

    pSurf->pLcl->lpGbl->dwUsageCount--;
    if (pCallbacks->Unlock != NULL)
    {
        dwRet = pCallbacks->Unlock(&UnlockData);
    }

    pUnlockData->ddRVal = UnlockData.ddRVal;

    return dwRet;
}

void BreakOutstandingLocks(PDDSURFHANDLE pSurf)
{
    DD_UNLOCKDATA   UnlockData;

    while (pSurf->pLcl->lpGbl->dwUsageCount > 0)
    {
        SwDDIUnlock(pSurf->pDevice, pSurf, &UnlockData);
    }
}


DWORD
SwDDIDestroySurface(HANDLE hDD, PDDSURFHANDLE pSurf)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_DESTROYSURFACEDATA DestroyData;

    DestroyData.lpDD = pDrv->lpGbl;
    DestroyData.lpDDSurface = pSurf->pLcl;
    DestroyData.ddRVal = S_OK;

    BreakOutstandingLocks(pSurf);

    if (pCallbacks->DestroySurface != NULL)
    {
        pCallbacks->DestroySurface(&DestroyData);
    }

    return DestroyData.ddRVal;
}


LPDDRAWI_DIRECTDRAW_LCL
SwDDICreateDirectDraw(void)
{
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    BYTE*                   pTemp;

    pLcl = (LPDDRAWI_DIRECTDRAW_LCL)MemAlloc(sizeof(DDRAWI_DIRECTDRAW_LCL) +
        sizeof(DDRAWI_DIRECTDRAW_GBL));
    if (pLcl == NULL)
    {
        return NULL;
    }

    pTemp = (BYTE*)pLcl;
    pTemp += sizeof(DDRAWI_DIRECTDRAW_LCL);
    pGbl = (LPDDRAWI_DIRECTDRAW_GBL) pTemp;
    pLcl->lpGbl = pGbl;

    pLcl->dwLocalRefCnt = 1;
    pGbl->dwRefCnt = 1;

    return pLcl;
}

extern HRESULT WINAPI
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
               DWORD* pNumTextures, DDSURFACEDESC** ppTexList );

void
SwDDIMungeCaps(HINSTANCE hLibrary, HANDLE hDD,
                PD3D8_DRIVERCAPS    pDriverCaps,
                PD3D8_CALLBACKS     pCallbacks,
                LPDDSURFACEDESC     pTextureFormats,
                UINT*               pcTextureFormats,
                VOID*               pInitFunction
                )
{
    PD3D8GetSWInfo          pfnGetSWInfo = NULL;
    D3DCAPS8                swCaps;
    D3D8_SWCALLBACKS        swCallbacks;
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) hDD;
    DWORD                   i;
    DWORD                   NumTex = 0;
    DDSURFACEDESC*          pTexList = NULL;

    // Get the info from the software driver
    memset (&swCaps, 0, sizeof(swCaps));
    memset (&swCallbacks, 0, sizeof(swCallbacks));
    if (hLibrary != NULL)
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)GetProcAddress (hLibrary, D3D8HOOK_GETSWINFOPROCNAME);
    }
    else
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)pInitFunction;
    }

    if ((hLibrary == NULL) && (pDevice->DeviceType == D3DDEVTYPE_REF))
    {
        // No hLibrary means time to fall back on defeatured ref.
        DPF(0,"Could not find d3dref8.dll, loading internal defeatured ReferenceDevice, no rendering will take place\n");
        D3D8GetSWInfo (&swCaps, &swCallbacks, &NumTex, &pTexList);
    }
    else if (pfnGetSWInfo != NULL)
    {
        (*pfnGetSWInfo)(&swCaps, &swCallbacks, &NumTex, &pTexList);
    }
    
    // Fill in out DDraw structure with the info that we have

    pLcl = pDevice->pDD;
    pGbl = pLcl->lpGbl;
    strcpy (pGbl->cDriverName, pDevice->szDeviceName);
    pGbl->vmiData.dwDisplayWidth = pDriverCaps->DisplayWidth;
    pGbl->vmiData.dwDisplayHeight = pDriverCaps->DisplayHeight;
    ConvertToOldFormat(&pGbl->vmiData.ddpfDisplay, pDriverCaps->DisplayFormatWithAlpha);

    // Overwite the hardware caps w/ the software caps
    memcpy (&pDriverCaps->D3DCaps, &swCaps, sizeof(swCaps));
    pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;

    // Copy over our texture format list if required.
    *pcTextureFormats = NumTex;
    if (pTextureFormats && pTexList)
    {
        memcpy(
            pTextureFormats,
            pTexList,
            sizeof (*pTexList) * NumTex);
    }


    // Now change the callback table to point to the ones for the SW drivers

    if (swCallbacks.CreateContext == NULL)
    {
        pCallbacks->CreateContext           = NULL;
    }
    else
    {
        pCallbacks->CreateContext           = SwContextCreate;
    }
    pCallbacks->ContextDestroy              = (PD3D8DDI_CONTEXTDESTROY) swCallbacks.ContextDestroy;
    pCallbacks->ContextDestroyAll           = (PD3D8DDI_CONTEXTDESTROYALL) swCallbacks.ContextDestroyAll;
    pCallbacks->RenderState                 = (PD3D8DDI_RENDERSTATE) swCallbacks.RenderState;
    pCallbacks->RenderPrimitive             = (PD3D8DDI_RENDERPRIMITIVE) swCallbacks.RenderPrimitive;
    if (swCallbacks.DrawPrimitives2 == NULL)
    {
        pCallbacks->DrawPrimitives2         = NULL;
    }
    else
    {
        pCallbacks->DrawPrimitives2         = SwDrawPrimitives2;
    }
    pCallbacks->GetDriverState              = (PD3D8DDI_GETDRIVERSTATE) swCallbacks.GetDriverState;
    pCallbacks->ValidateTextureStageState   = (PD3D8DDI_VALIDATETEXTURESTAGESTATE) swCallbacks.ValidateTextureStageState;
    pCallbacks->SceneCapture                = (PD3D8DDI_SCENECAPTURE) swCallbacks.SceneCapture;
    pCallbacks->Clear2                      = (PD3D8DDI_CLEAR2) swCallbacks.Clear2;

    // Save the original software callbacks so we can call the software driver later

    if (pGbl->lpDDCBtmp == NULL)
    {
        pGbl->lpDDCBtmp = (LPDDHAL_CALLBACKS) MemAlloc(sizeof(D3D8_SWCALLBACKS));
    }
    if (pGbl->lpDDCBtmp != NULL)
    {
        memcpy(pGbl->lpDDCBtmp, &swCallbacks, sizeof(swCallbacks));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\swapchan.hpp ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
//
// swapchan.hpp
//
// Swap chain implementation. A swap chain contains a primary surface, back
// buffers, and exclusive mode state such as fullscreen, stereoscopy, cover
// window, and the what is required to flip back buffers.
//
// Created 11/16/1999 johnstep (John Stephens)
//=============================================================================

#ifndef __SWAPCHAN_HPP__
#define __SWAPCHAN_HPP__

#include "surface.hpp"
#include "dxcursor.hpp"

//-----------------------------------------------------------------------------
// CSwapChain
//-----------------------------------------------------------------------------

class CSwapChain : public CBaseObject, public IDirect3DSwapChain8
{
public:
    CSwapChain(
        CBaseDevice                 *pDevice,
        REF_TYPE                     refType);

    void Init(
        D3DPRESENT_PARAMETERS *pPresentationParameters,
        HRESULT                     *pHr
        );

    virtual ~CSwapChain();

    CDriverSurface *PrimarySurface() const
    {
        return m_pPrimarySurface;
    }

    CDriverSurface *BackBuffer(UINT i) const
    {
        if (m_ppBackBuffers && i < m_PresentationData.BackBufferCount)
            return m_ppBackBuffers[i];
        else
            return NULL;
    }

    UINT Width() const
    {
        return m_PresentationData.BackBufferWidth;
    }
    
    UINT Height() const
    {
        return m_PresentationData.BackBufferHeight;
    }

    D3DFORMAT BackBufferFormat() const
    {
        return m_PresentationData.BackBufferFormat;
    }

    BOOL Windowed() const
    {
        return m_PresentationData.Windowed;
    }

    BOOL PresentUseBlt() const
    {
        return m_PresentUseBlt;
    }
    
    // IUnknown methods
    
    STDMETHODIMP QueryInterface(REFIID iid, void **ppInterface);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirect3D8SwapChain8 methods
    
    STDMETHODIMP 
    GetBackBuffer(
        UINT                iBackBuffer,
        D3DBACKBUFFER_TYPE  Type,
        IDirect3DSurface8 **ppBackBuffer
        );
    
    STDMETHODIMP
    Present(
        CONST RECT    *pSrcRect,
        CONST RECT    *pDestRect, 
        HWND    hTargetWindow,
        CONST RGNDATA *pDstRegion
        );


    // Internal methods
    HRESULT
    Reset(
        D3DPRESENT_PARAMETERS *pPresentationParameters
        );

    HRESULT FlipToGDISurface(void);

    void SetGammaRamp(DWORD dwFlags, CONST D3DGAMMARAMP *pRamp);

    void GetGammaRamp(D3DGAMMARAMP *pRamp);
#ifdef  WINNT
    void MakeFullscreen();
    void DoneExclusiveMode(BOOL);
    void StartExclusiveMode(BOOL);
    void HIDESHOW_IME();                                          
    BOOL IsWinProcDeactivated() const;

    DWORD PickRefreshRate(
            DWORD           Width,
            DWORD           Height,
            DWORD           RefreshRate,
            D3DFORMAT       Format);
#endif  //WINNT
    VOID Destroy();


protected:
    UINT m_presentnext;

    CDriverSurface  *m_pPrimarySurface;
    //HEL and REF allocate the render targets in system memory themselves
    //but the blt from system memory to the primary surface will cause tearing, 
    //so ideally we'd put the n backbuffers in system memory and then a single 
    //m_pMirrorSurface in video memory.  When presenting the system 
    //memory backbuffer, 
    //we can blt to the video memory backbuffer and then flip
    //Naturally device has to have enough video memory and support flip
    //otherwise m_pMirrorSurface will be NULL, and Present will
    //simply Blt from m_ppBackBuffers to m_pPrimarySurface
    CDriverSurface  *m_pMirrorSurface; 
    CDriverSurface **m_ppBackBuffers;
    UINT m_cBackBuffers;

    HRESULT CreateWindowed(
        UINT width,
        UINT height,
        D3DFORMAT backBufferFormat,
        UINT cBackBuffers,
        D3DMULTISAMPLE_TYPE MultiSampleType,
        BOOL bDiscard,
        BOOL bLockable
        );

    HRESULT CreateFullscreen(
        UINT width,
        UINT height,
        D3DFORMAT backBufferFormat,
        UINT cBackBuffers,
        UINT presentationRate,
        D3DMULTISAMPLE_TYPE MultiSampleType,
        BOOL bDiscard,
        BOOL bLockable
        );

#ifdef DEBUG
    void DebugDiscardBackBuffer(HANDLE SurfaceToClear) const;
#else
    void DebugDiscardBackBuffer(HANDLE SurfaceToClear) const
    {
        // No-op in retail
    }; // DebugDiscardBackBuffer
#endif 
        

private:
    friend CBaseDevice;
    friend CCursor;
    D3DPRESENT_PARAMETERS m_PresentationData;
    CCursor*    m_pCursor;
    HANDLE  m_hGDISurface;
    HRESULT SetCooperativeLevel();
    HRESULT SetAppHWnd();
    HRESULT FlipToSurface(HANDLE hTargetSurface);
    void    UpdateFrameRate( void );
    BOOL        m_bExclusiveMode;
    LPVOID      m_pCursorShadow;
    LPVOID      m_pHotTracking;
    LONG        m_lIMEState;
    LONG        m_lSetIME;
    UINT        m_uiErrorMode;
    DWORD       m_dwFlipFlags;
    D3D8_BLTDATA    m_BltData;
    UINT        m_ClientWidth;
    UINT        m_ClientHeight;
    BOOL        m_bClientChanged;
    RECT        m_DstRect;
    RECT        m_SrcRect;
    RECT*       m_pDstRect;
    RECT*       m_pSrcRect;
    DWORD       m_dwFlags;
#ifdef  WINNT
    DWORD       m_dwForceRefreshRate;
#endif
    DWORD	m_dwFlipCnt;
    DWORD       m_dwFlipTime;
    BOOL        m_PresentUseBlt;
    D3DSWAPEFFECT   m_UserSwapEffect; // what the user specified

    // Please keep this entry at the end of the struct... it'll make assembly-
    // level debugging easier.
    BOOL          m_GammaSet;
    D3DGAMMARAMP  m_DesiredGammaRamp;

    // DO NOT PUT ANYTHING HERE

}; // class CSwapChain
#define D3D_REGFLAGS_SHOWFRAMERATE  0x01
#ifdef  WINNT
#define D3D_REGFLAGS_FLIPNOVSYNC    0x02
#endif
#endif // __SWAPCHAN_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\vbuffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vbuffer.cpp
 *  Content:    Implementation of the CVertexBuffer class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "d3di.hpp"
#include "ddi.h"
#include "drawprim.hpp"
#include "vbuffer.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Create"

// Static class function for creating a VertexBuffer object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

// Creation function for Vertex Buffers
HRESULT CVertexBuffer::Create(CBaseDevice        *pDevice,
                              DWORD               cbLength,
                              DWORD               Usage,
                              DWORD               dwFVF,
                              D3DPOOL             Pool,
                              REF_TYPE            refType,
                              IDirect3DVertexBuffer8 **ppVertexBuffer)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppVertexBuffer))
    {
        DPF_ERR("Bad parameter passed for ppVertexBuffer for creating a vertex buffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppVertexBuffer = NULL;

    if (cbLength == 0)
    {
        DPF_ERR("Vertex buffer cannot be of zero size");
        return D3DERR_INVALIDCALL;
    }

    if (Pool != D3DPOOL_DEFAULT && Pool != D3DPOOL_MANAGED && Pool != D3DPOOL_SYSTEMMEM)
    {
        DPF_ERR("Vertex buffer pool should be default, managed or sysmem");
        return D3DERR_INVALIDCALL;
    }

    // Usage flag allowed for only mixed mode or software device
    if ((Usage & D3DUSAGE_SOFTWAREPROCESSING) != 0 && 
        (pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) == 0 &&
        (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) == 0)
    {
        DPF_ERR("D3DUSAGE_SOFTWAREPROCESSING can be set only when device is mixed or software mode. CreateVertexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // USAGE_DYNAMIC not allowed with management
    if ((Usage & D3DUSAGE_DYNAMIC) != 0 && Pool == D3DPOOL_MANAGED)
    {
        DPF_ERR("D3DUSAGE_DYNAMIC cannot be used with managed vertex buffers");
        return D3DERR_INVALIDCALL;
    }

    // Validate FVF
    if (dwFVF != 0 && cbLength < ComputeVertexSizeFVF(dwFVF))
    {
        DPF_ERR("Vertex buffer size needs to enough to hold one vertex");
        return D3DERR_INVALIDCALL;
    }

    D3DPOOL ActualPool = Pool;
    DWORD ActualUsage = Usage;

    // Infer Lock from absence of LoadOnce
    if (!(Usage & D3DUSAGE_LOADONCE))
    {
        ActualUsage |= D3DUSAGE_LOCK;
    }

    // On a mixed device, POOL_SYSTEMMEM means the same as D3DUSAGE_SOFTWAREPROCESSING
    if ((pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
        Pool == D3DPOOL_SYSTEMMEM)
    {
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    /*
     * Put a VB in system memory if the following conditions are TRUE
     * 1. (USAGE_SOFTWAREPROCESSING is set indicating app. wants to use software pipeline or if it is a software device) except if the vertices are pre-clipped TLVERTEX
     * 2. USAGE_POINTS is set and we might do emulation of point sprites except if it is a managed VB on a mixed device
     * 3. The driver does not support vidmem VBs
     * 4. Usage NPathes and driver does not support NPatches
     */
    if (!pDevice->DriverSupportsVidmemVBs())
    {
        ActualPool = D3DPOOL_SYSTEMMEM; // We don't set D3DUSAGE_SOFTWAREPROCESSING to ensure proper validation in fe code
    }
    if (((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 || (ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0) &&
        !((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW && (ActualUsage & D3DUSAGE_DONOTCLIP) != 0))
    {
        if((ActualUsage & D3DUSAGE_INTERNALBUFFER) == 0)
        {
            if ((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 ||
                ActualPool == D3DPOOL_DEFAULT)
            {
                ActualPool = D3DPOOL_SYSTEMMEM; // For software processing, pool can be only sysmem (POOLMANAGED is overwritten)
            }
            ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
        }
    }
    if ((ActualUsage & D3DUSAGE_NPATCHES) != 0 &&
        (pDevice->GetD3DCaps()->DevCaps & D3DDEVCAPS_NPATCHES) == 0)
    {
        ActualPool = D3DPOOL_SYSTEMMEM;
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    if ((ActualUsage & D3DUSAGE_POINTS) != 0 &&
        (static_cast<LPD3DBASE>(pDevice)->m_dwRuntimeFlags & D3DRT_DOPOINTSPRITEEMULATION) != 0)
    {
        if ((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 ||
            ActualPool == D3DPOOL_DEFAULT)
        {
            ActualPool = D3DPOOL_SYSTEMMEM; // For software processing, pool can be only sysmem (POOLMANAGED is overwritten)
        }
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    CVertexBuffer *pVertexBuffer;

    if (ActualPool == D3DPOOL_SYSTEMMEM ||
        IsTypeD3DManaged(pDevice, D3DRTYPE_VERTEXBUFFER, ActualPool))
    {
        hr = CreateSysmemVertexBuffer(pDevice,
                                      cbLength,
                                      dwFVF,
                                      Usage,
                                      ActualUsage,
                                      Pool,
                                      ActualPool,
                                      refType,
                                      &pVertexBuffer);
    }
    else
    {
        if (IsTypeDriverManaged(pDevice, D3DRTYPE_VERTEXBUFFER, ActualPool))
        {
            // If the vertex buffer is driver managed, but the usage is softwareprocessing, then
            // we turn off writeonly since the fe pipe WILL read from the sysmem backup (which
            // actually lives in the driver). It follows that when a driver manages a VB/IB without
            // writeonly, it MUST have a sysmem backup. (snene - 12/00)
            if ((ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0)
            {
                ActualUsage &= ~D3DUSAGE_WRITEONLY;
            }
            hr = CreateDriverManagedVertexBuffer(pDevice,
                                                 cbLength,
                                                 dwFVF,
                                                 Usage,
                                                 ActualUsage,
                                                 Pool,
                                                 ActualPool,
                                                 refType,
                                                 &pVertexBuffer);
            // Driver managed vertex buffer creates can NEVER fail, except for catastrophic reasons so
            // we don't fallback to sysmem. Even if we do fallback to sysmem here, there is no way
            // deferred creates are going to fallback, so no point.
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            hr = CreateDriverVertexBuffer(pDevice,
                                          cbLength,
                                          dwFVF,
                                          Usage,
                                          ActualUsage,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &pVertexBuffer);
        }
        if (FAILED(hr) && (hr != D3DERR_OUTOFVIDEOMEMORY || (ActualUsage & D3DUSAGE_INTERNALBUFFER) != 0))
        {
            if (hr == D3DERR_OUTOFVIDEOMEMORY)
            {
                DPF(2, "Out of video memory creating internal buffer");
            }
            if (pDevice->VBFailOversDisabled())
            {
                DPF_ERR("Cannot create Vidmem or Driver managed vertex buffer. Will ***NOT*** failover to Sysmem.");
                return hr;
            }
            ActualPool = D3DPOOL_SYSTEMMEM;
            hr = CreateSysmemVertexBuffer(pDevice,
                                          cbLength,
                                          dwFVF,
                                          Usage,
                                          ActualUsage,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &pVertexBuffer);
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    // We're done; just return the object
    *ppVertexBuffer = pVertexBuffer;

    return hr;
} // static Create

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CreateDriverVertexBuffer"

HRESULT CVertexBuffer::CreateDriverVertexBuffer(CBaseDevice *pDevice,
                                                DWORD        cbLength,
                                                DWORD        dwFVF,
                                                DWORD        Usage,
                                                DWORD        ActualUsage,
                                                D3DPOOL      Pool,
                                                D3DPOOL      ActualPool,
                                                REF_TYPE     refType,
                                                CVertexBuffer **pVB)
{
    HRESULT hr;
    CDriverVertexBuffer *pVertexBuffer;

    // Zero out return
    *pVB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pVertexBuffer = new CDriverVertexBufferMT(pDevice,
                                                  cbLength,
                                                  dwFVF,
                                                  Usage,
                                                  ActualUsage,
                                                  Pool,
                                                  ActualPool,
                                                  refType,
                                                  &hr);
    }
    else
    {
        pVertexBuffer = new CDriverVertexBuffer(pDevice,
                                                cbLength,
                                                dwFVF,
                                                Usage,
                                                ActualUsage,
                                                Pool,
                                                ActualPool,
                                                refType,
                                                &hr);
    }
    if (pVertexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating vertex buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pVertexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pVertexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pVB = static_cast<CVertexBuffer*>(pVertexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CreateSysmemVertexBuffer"

HRESULT CVertexBuffer::CreateSysmemVertexBuffer(CBaseDevice *pDevice,
                                                DWORD        cbLength,
                                                DWORD        dwFVF,
                                                DWORD        Usage,
                                                DWORD        ActualUsage,
                                                D3DPOOL      Pool,
                                                D3DPOOL      ActualPool,
                                                REF_TYPE     refType,
                                                CVertexBuffer **pVB)
{
    HRESULT hr;
    CVertexBuffer *pVertexBuffer;

    // Zero out return
    *pVB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pVertexBuffer = new CVertexBufferMT(pDevice,
                                            cbLength,
                                            dwFVF,
                                            Usage,
                                            ActualUsage,
                                            Pool,
                                            ActualPool,
                                            refType,
                                            &hr);
    }
    else
    {
        pVertexBuffer = new CVertexBuffer(pDevice,
                                          cbLength,
                                          dwFVF,
                                          Usage,
                                          ActualUsage,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &hr);
    }
    if (pVertexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating vertex buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pVertexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pVertexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pVB = pVertexBuffer;

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CreateDriverManagedVertexBuffer"

HRESULT CVertexBuffer::CreateDriverManagedVertexBuffer(CBaseDevice *pDevice,
                                                       DWORD        cbLength,
                                                       DWORD        dwFVF,
                                                       DWORD        Usage,
                                                       DWORD        ActualUsage,
                                                       D3DPOOL      Pool,
                                                       D3DPOOL      ActualPool,
                                                       REF_TYPE     refType,
                                                       CVertexBuffer **pVB)
{
    HRESULT hr;
    CDriverManagedVertexBuffer *pVertexBuffer;

    // Zero out return
    *pVB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pVertexBuffer = new CDriverManagedVertexBufferMT(pDevice,
                                                         cbLength,
                                                         dwFVF,
                                                         Usage,
                                                         ActualUsage,
                                                         Pool,
                                                         ActualPool,
                                                         refType,
                                                         &hr);
    }
    else
    {
        pVertexBuffer = new CDriverManagedVertexBuffer(pDevice,
                                                       cbLength,
                                                       dwFVF,
                                                       Usage,
                                                       ActualUsage,
                                                       Pool,
                                                       ActualPool,
                                                       refType,
                                                       &hr);
    }
    if (pVertexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating vertex buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pVertexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pVertexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pVB = static_cast<CVertexBuffer*>(pVertexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CVertexBuffer"

// Constructor the CVertexBuffer class
CVertexBuffer::CVertexBuffer(CBaseDevice *pDevice,
                             DWORD        cbLength,
                             DWORD        dwFVF,
                             DWORD        Usage,
                             DWORD        ActualUsage,
                             D3DPOOL      Pool,
                             D3DPOOL      ActualPool,
                             REF_TYPE     refType,
                             HRESULT     *phr
                             ) :
    CBuffer(pDevice,
            cbLength,
            dwFVF,
            D3DFMT_VERTEXDATA,
            D3DRTYPE_VERTEXBUFFER,
            Usage,              // UserUsage
            ActualUsage,
            Pool,               // UserPool
            ActualPool,
            refType,
            phr)
{
    if (FAILED(*phr))
        return;

    // Initialize basic structures
    m_desc.Format        = D3DFMT_VERTEXDATA;
    m_desc.Pool          = ActualPool;
    m_desc.Usage         = ActualUsage;
    m_desc.Type          = D3DRTYPE_VERTEXBUFFER;
    m_desc.Size          = cbLength;
    m_desc.FVF           = dwFVF;
    m_usageUser          = Usage;

    if (dwFVF != 0)
    {
        m_vertsize       = ComputeVertexSizeFVF(dwFVF);
        DXGASSERT(m_vertsize != 0);
        m_numverts       = cbLength / m_vertsize;
    }
    else
    {
        m_vertsize       = 0;
        m_numverts       = 0;
    }

    m_pClipCodes         = 0;

    // If this is a D3D managed buffer then we need
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_VERTEXBUFFER, ActualPool))
    {
        *phr = InitializeRMHandle();
    }
} // CVertexBuffer::CVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Clone"
HRESULT CVertexBuffer::Clone(D3DPOOL     Pool,
                             CResource **ppResource) const
{
    HRESULT hr;
    CVertexBuffer *pVertexBuffer;
    // Note: we treat clones the same as internal; because
    // they are owned by the resource manager which
    // is owned by the device.
    hr = CreateDriverVertexBuffer(Device(),
                                  m_desc.Size,
                                  m_desc.FVF,
                                  m_desc.Usage,
                                  (m_desc.Usage | D3DUSAGE_WRITEONLY) & ~D3DUSAGE_SOFTWAREPROCESSING, // never seen by API!
                                  Pool,
                                  Pool, // never seen by API!
                                  REF_INTERNAL,
                                  &pVertexBuffer);
    *ppResource = static_cast<CResource*>(pVertexBuffer);
    return hr;
} // CVertexBuffer::Clone


#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetBufferDesc"
const D3DBUFFER_DESC* CVertexBuffer::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CVertexBuffer::GetBufferDesc

// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::QueryInterface"

STDMETHODIMP CVertexBuffer::QueryInterface(REFIID riid,
                                           LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter passed to CVertexBuffer::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for VertexBuffer");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DVertexBuffer8  ||
        riid == IID_IDirect3DResource8      ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DVertexBuffer8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for VertexBuffer");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::AddRef"

STDMETHODIMP_(ULONG) CVertexBuffer::AddRef()
{
    API_ENTER_NO_LOCK(Device());

    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Release"

STDMETHODIMP_(ULONG) CVertexBuffer::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());

    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetDevice"

STDMETHODIMP CVertexBuffer::GetDevice(IDirect3DDevice8 ** ppObj)
{
    API_ENTER(Device());

    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::SetPrivateData"

STDMETHODIMP CVertexBuffer::SetPrivateData(REFGUID riid,
                                           CONST VOID* pvData,
                                           DWORD cbData,
                                           DWORD dwFlags)
{
    API_ENTER(Device());

    // We use level zero for our data
    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, 0);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetPrivateData"

STDMETHODIMP CVertexBuffer::GetPrivateData(REFGUID riid,
                                           LPVOID pvData,
                                           LPDWORD pcbData)
{
    API_ENTER(Device());

    // We use level zero for our data
    return GetPrivateDataImpl(riid, pvData, pcbData, 0);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::FreePrivateData"

STDMETHODIMP CVertexBuffer::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // We use level zero for our data
    return FreePrivateDataImpl(riid, 0);
} // FreePrivateData


#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetPriority"

STDMETHODIMP_(DWORD) CVertexBuffer::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::SetPriority"

STDMETHODIMP_(DWORD) CVertexBuffer::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::PreLoad"

STDMETHODIMP_(void) CVertexBuffer::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CVertexBuffer::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// Vertex Buffer Methods
#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetDesc"

STDMETHODIMP CVertexBuffer::GetDesc(D3DVERTEXBUFFER_DESC *pDesc)
{
    API_ENTER(Device());

    if (!VALID_WRITEPTR(pDesc, sizeof(D3DVERTEXBUFFER_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for VertexBuffer");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_desc;

    // Need to return pool/usage that the user specified
    pDesc->Pool    = GetUserPool();
    pDesc->Usage   = m_usageUser;

    return S_OK;
} // GetDesc

#if DBG
#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::ValidateLockParams"
HRESULT CVertexBuffer::ValidateLockParams(UINT cbOffsetToLock,
                                          UINT SizeToLock,
                                          BYTE **ppbData,
                                          DWORD dwFlags) const
{
    if (!VALID_PTR_PTR(ppbData))
    {
        DPF_ERR("Bad parameter passed for ppbData for locking a vertexbuffer");
        return D3DERR_INVALIDCALL;
    }

    if ((cbOffsetToLock != 0) && (SizeToLock == 0))
    {
        DPF_ERR("Cannot lock zero bytes. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~(D3DLOCK_VALID & ~D3DLOCK_NO_DIRTY_UPDATE)) // D3DLOCK_NO_DIRTY_UPDATE not valid for VBs
    {
        DPF_ERR("Invalid flags specified. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    // Can it be locked?
    if (!m_isLockable)
    {
        DPF_ERR("Vertex buffer with D3DUSAGE_LOADONCE can only be locked once");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) != 0 && (m_usageUser & D3DUSAGE_DYNAMIC) == 0)
    {
        DPF_ERR("Can specify D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE for only Vertex Buffers created with D3DUSAGE_DYNAMIC");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_DISCARD)) == (D3DLOCK_READONLY | D3DLOCK_DISCARD))
    {
        DPF_ERR("Should not specify D3DLOCK_DISCARD along with D3DLOCK_READONLY. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & D3DLOCK_READONLY) != 0 && (m_usageUser & D3DUSAGE_WRITEONLY) != 0)
    {
        DPF_ERR("Cannot do READ_ONLY lock on a WRITE_ONLY buffer. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (ULONGLONG(cbOffsetToLock) + ULONGLONG(SizeToLock) > ULONGLONG(m_desc.Size))
    {
        DPF_ERR("Lock failed: Locked area exceeds size of buffer. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (m_LockCount == 0)
    {
        if ((m_usageUser & D3DUSAGE_DYNAMIC) == 0)
        {
            if (static_cast<CD3DBase*>(Device())->m_SceneStamp == m_SceneStamp &&
                (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                GetUserPool() != D3DPOOL_SYSTEMMEM)
            {
                DPF(1, "Static vertex buffer locked more than once per frame. Could have severe performance penalty.");
            }
            ((CVertexBuffer*)this)->m_SceneStamp = static_cast<CD3DBase*>(Device())->m_SceneStamp;
        }
        else
        {
            if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) == 0)
            {
                if (m_TimesLocked > 0 &&
                    (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                    GetUserPool() != D3DPOOL_SYSTEMMEM)
                {
                    DPF(3, "Dynamic vertex buffer locked twice or more in a row without D3DLOCK_NOOVERWRITE or D3DLOCK_DISCARD. Could have severe performance penalty.");
                }
                ++(((CVertexBuffer*)this)->m_TimesLocked);
            }
            else
            {
                ((CVertexBuffer*)this)->m_TimesLocked = 0;
            }
        }
    }

    DXGASSERT(m_LockCount < 0x80000000);

    return S_OK;
} // ValidateLockParams
#endif //DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Lock"

STDMETHODIMP CVertexBuffer::Lock(UINT cbOffsetToLock,
                                 UINT SizeToLock,
                                 BYTE **ppbData,
                                 DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK_HR however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    HRESULT hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

    // Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(GetPrivateDataPointer() != 0);
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 && m_LockCount == 1) // for repeat locks, no syncing
    {
        Sync(); // Sync with device command queue
    }

    LockImpl(cbOffsetToLock,
             SizeToLock,
             ppbData,
             dwFlags,
             m_desc.Size);

    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Unlock"

STDMETHODIMP CVertexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a buffer; vertex buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::AllocateClipCodes"

void CVertexBuffer::AllocateClipCodes()
{
    if (m_pClipCodes == 0)
    {
        DXGASSERT(m_numverts != 0);
        m_pClipCodes = new WORD[m_numverts];
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::UpdateDirtyPortion"

HRESULT CVertexBuffer::UpdateDirtyPortion(CResource *pResourceTarget)
{
    if (IsDirty())
    {
        if (Device()->CanBufBlt())
        {
            D3DRANGE range;
            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                range.Offset = 0;
                range.Size = m_desc.Size;
            }
            else
            {
                range.Offset = m_cbDirtyMin;
                range.Size = m_cbDirtyMax - m_cbDirtyMin;
            }
            HRESULT hr = static_cast<LPD3DBASE>(Device())->BufBlt(static_cast<CBuffer*>(pResourceTarget), this, m_cbDirtyMin, &range);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to copy vertex buffer");
                return hr;
            }
        }
        else
        {
            DXGASSERT(pResourceTarget->GetBufferDesc()->Pool == D3DPOOL_DEFAULT); // make sure that it is safe to assume that this is a driver VB
            CDriverVertexBuffer *pBufferTarget = static_cast<CDriverVertexBuffer *>(pResourceTarget);

            DXGASSERT((pBufferTarget->m_desc.Usage & D3DUSAGE_DYNAMIC) == 0); // Target can never be dynamic
            DXGASSERT(pBufferTarget->m_pbData == 0); // Target can never be locked

            HRESULT hr = pBufferTarget->LockI(D3DLOCK_NOSYSLOCK);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to lock driver vertex buffer");
                return hr;
            }
            DXGASSERT(pBufferTarget->m_pbData != 0);

            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                memcpy(pBufferTarget->m_pbData, GetPrivateDataPointer(), m_desc.Size);
            }
            else
            {
                memcpy(pBufferTarget->m_pbData + m_cbDirtyMin, GetPrivateDataPointer() + m_cbDirtyMin, m_cbDirtyMax - m_cbDirtyMin);
            }

            hr = pBufferTarget->UnlockI();
            if (FAILED(hr))
            {
                DPF_ERR("Failed to unlock driver vertex buffer");
                return hr;
            }

            DXGASSERT(pBufferTarget->m_pbData == 0); // Target must be unlocked
        }

        // Mark ourselves as all clean now.
        OnResourceClean();
    }

    return S_OK;
} // CVertexBuffer::UpdateDirtyPortion

//=============================================
// Methods for the CDriverVertexBuffer class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::CDriverVertexBuffer"
CDriverVertexBuffer::CDriverVertexBuffer(CBaseDevice *pDevice,
                                         DWORD        cbLength,
                                         DWORD        dwFVF,
                                         DWORD        Usage,
                                         DWORD        ActualUsage,
                                         D3DPOOL      Pool,
                                         D3DPOOL      ActualPool,
                                         REF_TYPE     refType,
                                         HRESULT     *phr
                                         ) :
    CVertexBuffer(pDevice,
                  cbLength,
                  dwFVF,
                  Usage,
                  ActualUsage,
                  Pool,
                  ActualPool,
                  refType,
                  phr),
    m_pbData(0)
{
    if (FAILED(*phr))
    {
        // We want to allow drivers to fail creation of driver vbs. In this
        // case we will fail-over to system memory. However, if we
        // DPF an error here, it will be misunderstood. So don't DPF.
        return;
    }
} // CDriverVertexBuffer::CDriverVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::~CDriverVertexBuffer"
CDriverVertexBuffer::~CDriverVertexBuffer()
{
    if (m_pbData != 0)
    {
        HRESULT hr = UnlockI();
        if (FAILED(hr))
        {
            DPF_ERR("Failed to unlock driver vertex buffer");
        }
    }
} // CDriverVertexBuffer::~CDriverVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::LockI"
HRESULT CDriverVertexBuffer::LockI(DWORD dwFlags)
{
    // We sync first to make sure that the
    // driver has already processed any data that
    // it needs. LockI only gets called if for
    // cases where we need the interlock i.e.
    // not readonly and not nooverwrite.
    Sync();

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD = Device()->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.dwFlags = dwFlags;

    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver vertex buffer");
    }

    // Return value
    m_pbData = (BYTE*)lockData.lpSurfData;

    return hr;
} // LockI

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::UnlockI"
HRESULT CDriverVertexBuffer::UnlockI()
{
    // It is sometimes possible for the pre-DX8 DDI FlushStates to call
    // Unlock twice. We safely filter this case.
    if (m_pbData == 0)
    {
        DXGASSERT(!IS_DX8HAL_DEVICE(Device()));
        return D3D_OK;
    }

    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        Device()->GetHandle(),
        BaseKernelHandle()
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver vertex buffer failed to unlock");
        return hr;
    }

    m_pbData = 0;

    return hr;
    
} // UnlockI

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::Lock"

STDMETHODIMP CDriverVertexBuffer::Lock(UINT cbOffsetToLock,
                                       UINT SizeToLock,
                                       BYTE **ppbData,
                                       DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

    HRESULT hr;
#if DBG
    hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

// Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(m_pbData != 0);
    }
#endif // DBG

    // Increment our lock count
    // This MUST be done first. DO NOT MOVE THIS LINE.
    ++m_LockCount;

    if(((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 || m_pbData == 0) && m_LockCount == 1) // Repeat locks need no work
    {
        hr = static_cast<LPD3DBASE>(Device())->m_pDDI->LockVB(this, dwFlags);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock driver vertex buffer");
            *ppbData = 0;
            --m_LockCount;
            return hr;
        }
    }

    *ppbData = m_pbData + cbOffsetToLock;

    // Done
    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::Unlock"

STDMETHODIMP CDriverVertexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a vertex buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    if ((m_desc.Usage & D3DUSAGE_DYNAMIC) == 0 && m_LockCount == 1) // do work only for the last unlock
    {
        HRESULT hr = static_cast<LPD3DBASE>(Device())->m_pDDI->UnlockVB(this);
        if (FAILED(hr))
        {
            DPF_ERR("Driver failed to unlock vertex buffer");
            return hr;
        }
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    // Done
    return S_OK;
} // Unlock

//=================================================
// Methods for the CDriverManagedVertexBuffer class
//=================================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::CDriverManagedVertexBuffer"
CDriverManagedVertexBuffer::CDriverManagedVertexBuffer(CBaseDevice *pDevice,
                                                       DWORD        cbLength,
                                                       DWORD        dwFVF,
                                                       DWORD        Usage,
                                                       DWORD        ActualUsage,
                                                       D3DPOOL      Pool,
                                                       D3DPOOL      ActualPool,
                                                       REF_TYPE     refType,
                                                       HRESULT     *phr
                                                       ) :
    CVertexBuffer(pDevice,
                  cbLength,
                  dwFVF,
                  Usage,
                  ActualUsage,
                  Pool,
                  ActualPool,
                  refType,
                  phr),
    m_pbData(0),
    m_bDriverCalled(FALSE)
{
    if (FAILED(*phr))
        return;
    // If writeonly is not set, we assume that the vertex/index buffer is going
    // to be read from from time to time. Hence, for optimizing the readonly
    // locks, we lock and cache the pointer. (snene - 12/00)
    if ((ActualUsage & D3DUSAGE_WRITEONLY) == 0)
    {        
        *phr = UpdateCachedPointer(pDevice);
        if (FAILED(*phr))
            return;
    }
} // CDriverManagedVertexBuffer::CDriverManagedVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::UpdateCachedPointer"

HRESULT CDriverManagedVertexBuffer::UpdateCachedPointer(CBaseDevice *pDevice)
{
    HRESULT hr;

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);
    
    lockData.hDD = pDevice->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.range.Offset = 0;
    lockData.range.Size = 0;
    lockData.dwFlags = D3DLOCK_READONLY;
    
    hr = pDevice->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
        return hr;
    
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        pDevice->GetHandle(),
            BaseKernelHandle()
    };
    
    hr = pDevice->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
        return hr;
    
    m_pbData = (BYTE*)lockData.lpSurfData;

    return S_OK;
} // CDriverManagedVertexBuffer::UpdateCachedPointer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::Lock"

STDMETHODIMP CDriverManagedVertexBuffer::Lock(UINT cbOffsetToLock,
                                              UINT SizeToLock,
                                              BYTE **ppbData,
                                              DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

    HRESULT hr = S_OK;
#if DBG
    hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if((dwFlags & D3DLOCK_READONLY) == 0)
    {
        // Sync with device command queue
        Sync();

        // Prepare a LockData structure for the HAL call
        D3D8_LOCKDATA lockData;
        ZeroMemory(&lockData, sizeof lockData);

        lockData.hDD = Device()->GetHandle();
        lockData.hSurface = BaseKernelHandle();
        lockData.bHasRange = (SizeToLock != 0);
        lockData.range.Offset = cbOffsetToLock;
        lockData.range.Size = SizeToLock;
        lockData.dwFlags = dwFlags;

        hr = Device()->GetHalCallbacks()->Lock(&lockData);
        if (FAILED(hr))
        {
            *ppbData = 0;
            DPF_ERR("Failed to lock driver managed vertex buffer");
            return hr;
        }
        else
        {
            // Update cached pointer
            m_pbData = (BYTE*)lockData.lpSurfData - cbOffsetToLock;
            m_bDriverCalled = TRUE;
        }
    }

    *ppbData = m_pbData + cbOffsetToLock;

    return hr;

} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::Unlock"

STDMETHODIMP CDriverManagedVertexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a vertex buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    if (m_bDriverCalled)
    {
        // Call the driver to perform the unlock
        D3D8_UNLOCKDATA unlockData = {
            Device()->GetHandle(),
            BaseKernelHandle()
        };

        HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
        if (FAILED(hr))
        {
            DPF_ERR("Driver vertex buffer failed to unlock");
            return hr;
        }

        m_bDriverCalled = FALSE;
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

// End of file : vbuffer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\texture.hpp ===
#ifndef __TEXTURE_HPP__
#define __TEXTURE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       texture.h
 *  Content:    Base class for all texture objects. Texture management is
 *              done at this level.
 *
 *
 ***************************************************************************/

// The mip texture class has all of the functionality of the
// the Base Object class along with some additional state for
// managing LODs.
#include <limits.h>
#include "resource.hpp"
#include "pixel.hpp"

#define __INVALIDPALETTE    USHRT_MAX

class CBaseTexture : public IDirect3DBaseTexture8, public CResource
{
public:
    // Constructor
    CBaseTexture(
        CBaseDevice *pDevice,
        DWORD        cLevels,
        D3DPOOL      UserPool,
        D3DFORMAT    UserFormat,
        REF_TYPE     refType);

    // Function to convert a IDirect3DBaseTexture8 * to
    // a CBaseTexture *.
    static CBaseTexture *SafeCast(IDirect3DBaseTexture8 *pInterface);

    // Returns the format that the user passed in
    D3DFORMAT GetUserFormat() const
    {
        return m_formatUser;
    } // GetUserFormat

    BOOL IsPaletted() const
    {
        DXGASSERT(GetBufferDesc()->Format == GetUserFormat());
        return CPixel::IsPaletted(GetUserFormat());
    }

    // Returns the current palette
    DWORD GetPalette() const
    {
        DXGASSERT(GetBufferDesc()->Format == GetUserFormat());
        DXGASSERT(CPixel::IsPaletted(GetUserFormat()));
        return m_Palette;
    } // GetPalette

    // Set the current palette
    void SetPalette(DWORD Palette)
    {
        DXGASSERT(GetBufferDesc()->Format == GetUserFormat());
#if DBG
        if(Palette != __INVALIDPALETTE)
        {
            DXGASSERT(CPixel::IsPaletted(GetUserFormat()));
        }
#endif
        DXGASSERT(Palette <= USHRT_MAX);
        m_Palette = (WORD)Palette;
    } // SetPalette

    // Return current LOD
    DWORD GetLODI() const
    {
        return m_LOD;
    }

    // Sets current LOD (but doesn't actually do any work)
    DWORD SetLODI(DWORD LOD)
    {
        DXGASSERT(LOD <= UCHAR_MAX);
        DWORD oldLOD = m_LOD;
        m_LOD = (BYTE)LOD;
        return oldLOD;
    }

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget) PURE;

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked() PURE;
#endif  // DEBUG

#ifdef DEBUG
    // DPF helper for explaining why lock failed
    void ReportWhyLockFailed(void) const;
#else  // !DEBUG
    void ReportWhyLockFailed(void) const
    {
        // Do Nothing In Retail
    } // ReportWhyLockFailed
#endif // !DEBUG

protected:

    // Remember the format that the user passed in
    D3DFORMAT   m_formatUser;

    // Currently all textures have a number of levels;
    // If that changes, then we should create a derived
    // class CMipTexture and move this data member there.
    BYTE        m_cLevels;

    // Contains the current LOD for D3D managed textures
    BYTE        m_LOD;

    // Currently set palette (valid only if format is paletted)
    WORD        m_Palette;

    // Level Count accessor
    DWORD GetLevelCountImpl() const
    {
        return m_cLevels;
    }; // GetLevelCountImpl

    // Function to verify external parameters
    // to various texture create APIs
    static HRESULT Validate(CBaseDevice       *pDevice,
                            D3DRESOURCETYPE    Type,
                            D3DPOOL            Pool,
                            DWORD              Usage,
                            D3DFORMAT          Format);

    // Infer usage flags based on external parameters
    // (All inferences MUST be device-independent.)
    static DWORD InferUsageFlags(D3DPOOL            Pool,
                                 DWORD              Usage,
                                 D3DFORMAT          Format);

    // Helper to check if TexBlt is support on this
    // device for this texture
    BOOL CanTexBlt(CBaseTexture *pDestTexture) const;

    // Helper function to scale a Rect down by some
    // number of powers of two; useful for figuring out
    // what part of mip-sub-levels to copy
    static void ScaleRectDown(RECT *pRect, UINT PowersOfTwo = 1);

    // Box version for volumes
    static void ScaleBoxDown(D3DBOX *pBox, UINT PowersOfTwo = 1);

    // Compute Levels for the user
    static UINT ComputeLevels(UINT width, UINT height = 0, UINT depth = 0);

    // Common implementation for Set/Get LOD.
    DWORD SetLODImpl(DWORD LOD);
    DWORD GetLODImpl();

private:

    // Textures overload this to call OnTextureDestroy on the
    // Device before calling Sync.
    virtual void OnDestroy(void);

}; // class CBaseTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::CBaseTexture"


// Inlines
inline CBaseTexture::CBaseTexture(
    CBaseDevice *pDevice,
    DWORD        cLevels,
    D3DPOOL      UserPool,
    D3DFORMAT    UserFormat,
    REF_TYPE     refType)
    :
    CResource(pDevice, UserPool, refType),
    m_cLevels((BYTE)cLevels),
    m_Palette(__INVALIDPALETTE),
    m_formatUser(UserFormat)
{
    DXGASSERT(cLevels > 0 && cLevels < 256);
}; // CBaseTexture::CBaseTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::SafeCast"

// Function to convert a IDirect3DBaseTexture8 * to
// a CBaseTexture *. Classes that expose IDirect3DBaseTexture8
// must list CBaseTexture FIRST and IDirect3DFoo8*
// SECOND in their list of inheritances. (The Foo8 interface
// must itself inherit from IDirect3DBaseTexture8*.
inline CBaseTexture * CBaseTexture::SafeCast(IDirect3DBaseTexture8 *pInterface)
{
    if (pInterface == NULL)
        return NULL;

    // Textures must by law obey certain layout rules. In
    // particular the CBaseTexture object must reside precisely
    // before the IDirect3DBaseTexture8 interface
    BYTE *pbInt = reinterpret_cast<BYTE *>(pInterface);
    CBaseTexture *pTex = reinterpret_cast<CBaseTexture *>(pbInt - sizeof(CBaseTexture));
    return pTex;
} // CBaseTexture::SafeCast


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ScaleRectDown"

// We round down on for left and top; and we round up for
// right and bottom
inline void CBaseTexture::ScaleRectDown(RECT *pRect, UINT PowersOfTwo)
{
    DXGASSERT(PowersOfTwo > 0);
    DXGASSERT(PowersOfTwo < 32);
    DXGASSERT(pRect->right > 0);
    DXGASSERT(pRect->bottom > 0);
    DXGASSERT(pRect->left < pRect->right);
    DXGASSERT(pRect->top < pRect->bottom);
    DXGASSERT(pRect->left >= 0);
    DXGASSERT(pRect->top >= 0);

    // Rounding down is automatic with the shift operator
    pRect->left >>= PowersOfTwo;
    pRect->top  >>= PowersOfTwo;

    if (pRect->right & ((1 << PowersOfTwo) - 1))
    {
        pRect->right >>= PowersOfTwo;
        pRect->right++;
    }
    else
    {
        pRect->right >>= PowersOfTwo;
    }

    if (pRect->bottom & ((1 << PowersOfTwo) - 1))
    {
        pRect->bottom >>= PowersOfTwo;
        pRect->bottom++;
    }
    else
    {
        pRect->bottom >>= PowersOfTwo;
    }

    return;
} // CBaseTexture::ScaleRectDown

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ScaleBoxDown"

inline void CBaseTexture::ScaleBoxDown(D3DBOX *pBox, UINT PowersOfTwo)
{
    DXGASSERT(pBox);
    DXGASSERT(pBox->Front < pBox->Back);
    DXGASSERT(pBox->Back > 0);

    ScaleRectDown((RECT*)pBox, PowersOfTwo);

    // Rounding down is automatic with the shift operator
    pBox->Front >>= PowersOfTwo;
    if (pBox->Back & ((1 << PowersOfTwo) - 1))
    {
        pBox->Back >>= PowersOfTwo;
        pBox->Back++;
    }
    else
    {
        pBox->Back >>= PowersOfTwo;
    }

} // CBaseTexture::ScaleBoxDown

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ComputeLevels"

inline UINT CBaseTexture::ComputeLevels(UINT width,
                                        UINT height, // = 0,
                                        UINT depth  // = 0
                                        )
{
    UINT maxEdge = max(width, height);
    maxEdge = max(maxEdge, depth);

    UINT cLevels = 0;
    while (maxEdge)
    {
        cLevels++;

        // D3D rule is that sizes round down always
        maxEdge >>= 1;
    }

    return cLevels;
} // CBaseTexture::ComputeLevels

#endif // __TEXTURE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\_dpf.c ===
#include "ddrawpr.h"

#include "..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\volume.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       volume.cpp
 *  Content:    Implementation of the CVolume and CDriverVolumne classes
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "volume.hpp"

// IUnknown methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::QueryInterface"

STDMETHODIMP CVolume::QueryInterface (REFIID       riid, 
                                      VOID       **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter to QueryInterface for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }


    if (riid == IID_IDirect3DVolume8  ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DVolume8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for a level of a VolumeTexture");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::AddRef"

STDMETHODIMP_(ULONG) CVolume::AddRef()
{
    API_ENTER_NO_LOCK(Device());   
    
#ifdef DEBUG
    m_cRefDebug++;
#endif // DEBUG
    return m_pParent->AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::Release"

STDMETHODIMP_(ULONG) CVolume::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   
    
#ifdef DEBUG
    m_cRefDebug--;
    if (m_cRefDebug & 0x80000000)
    {
        DPF_ERR("A level of a mip-volume has been released more often than it has been add-ref'ed! Danger!!");
    }
#endif // DEBUG
    return m_pParent->ReleaseImpl();
} // Release

// IBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::SetPrivateData"

STDMETHODIMP CVolume::SetPrivateData(REFGUID riid, 
                                     CONST VOID   *pvData, 
                                     DWORD   cbData, 
                                     DWORD   dwFlags)
{
    API_ENTER(Device());

    return m_pParent->SetPrivateDataImpl(riid, 
                                         pvData, 
                                         cbData, 
                                         dwFlags, 
                                         m_iLevel);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetPrivateData"

STDMETHODIMP CVolume::GetPrivateData(REFGUID riid, 
                                     VOID   *pvData, 
                                     DWORD  *pcbData)
{
    API_ENTER(Device());

    return m_pParent->GetPrivateDataImpl(riid,
                                         pvData,
                                         pcbData,
                                         m_iLevel);

} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::FreePrivateData"

STDMETHODIMP CVolume::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    return m_pParent->FreePrivateDataImpl(riid,
                                          m_iLevel);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetContainer"

STDMETHODIMP CVolume::GetContainer(REFIID riid, 
                                   void **ppContainer)
{
    API_ENTER(Device());

    return m_pParent->QueryInterface(riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetDevice"

STDMETHODIMP CVolume::GetDevice(IDirect3DDevice8 **ppDevice)
{
    API_ENTER(Device());

    return m_pParent->GetDevice(ppDevice);
} // OpenDevice

// IDirect3DVolume8 methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetDesc"

STDMETHODIMP CVolume::GetDesc(D3DVOLUME_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(D3DVOLUME_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    // We basically get our volume desc from our parent
    // and then modify the width, height, and depth fields.
    *pDesc = *m_pParent->Desc();

    pDesc->Width  >>= m_iLevel;
    pDesc->Height >>= m_iLevel;
    pDesc->Depth  >>= m_iLevel;

    if (pDesc->Width == 0)
    {
        pDesc->Width = 1;
    }
    if (pDesc->Height == 0)
    {
        pDesc->Height = 1;
    }
    if (pDesc->Depth == 0)
    {
        pDesc->Depth = 1;
    }

    // Also need to modify the type field
    pDesc->Type   = D3DRTYPE_VOLUME;

    // Also modify the size field
    pDesc->Size = CPixel::ComputeVolumeSize(pDesc->Width, 
                                            pDesc->Height, 
                                            pDesc->Depth,
                                            pDesc->Format);

    // We also need to modify the pool and format
    // to reflect the data the user passed to us
    pDesc->Pool   = m_pParent->GetUserPool();
    pDesc->Format = m_pParent->GetUserFormat();
    pDesc->Usage &= D3DUSAGE_EXTERNAL;

    // We're done
    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::LockBox"

STDMETHODIMP CVolume::LockBox(D3DLOCKED_BOX *pLockedBoxData, 
                              CONST D3DBOX  *pBox, 
                              DWORD          dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedBoxData, sizeof(D3DLOCKED_BOX)))
    {
        DPF_ERR("bad pointer for pLockedBoxData passed to LockBox for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data 
    ZeroMemory(pLockedBoxData, sizeof(D3DLOCKED_BOX));

    // Validate Box
    if (pBox != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;
        DWORD Depth  = m_pParent->Desc()->Depth  >> m_iLevel;

        if (!CPixel::IsValidBox(m_pParent->Desc()->Format,
                                Width, 
                                Height,
                                Depth,
                                pBox))
        {
            DPF_ERR("LockBox for a Volume fails");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_VOL_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire volume.");
                return D3DERR_INVALIDCALL;
            }
            if (pBox != NULL)
            {
                DPF_ERR("Subboxes not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockBox for a level of a VolumeTexture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_VOL_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }
    
    return InternalLockBox(pLockedBoxData, pBox, dwFlags);
} // LockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::InternalLockBox"

HRESULT CVolume::InternalLockBox(D3DLOCKED_BOX *pLockedBoxData, 
                                 CONST D3DBOX  *pBox, 
                                 DWORD          dwFlags)
{
    // Only one lock outstanding at a time is supported
    if (IsLocked())
    {
        DPF_ERR("LockBox failed on a mip level; volume was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnVolumeLock(m_iLevel, pBox, dwFlags);
    }

    // Figure out our stride/pointer to bits
    m_pParent->ComputeMipVolumeOffset(m_iLevel, 
                                      pBox,
                                      pLockedBoxData);

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return S_OK;
} // InternalLockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::UnlockBox"

STDMETHODIMP CVolume::UnlockBox()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!IsLocked())
    {
        DPF_ERR("UnlockBox failed on a volume level; volume wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
    DXGASSERT(m_isLockable);
    return InternalUnlockBox();
} // UnlockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::InternalUnlockBox"

HRESULT CVolume::InternalUnlockBox()
{
    // Clear our locked state
    m_isLocked = FALSE;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // InternalUnlockBox

//
// CDriverVolume class modifies the implementation
// of the LockBox and UnlockBox methods of the CVolume class
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::LockBox"

STDMETHODIMP CDriverVolume::LockBox(D3DLOCKED_BOX *pLockedBoxData, 
                                    CONST D3DBOX  *pBox, 
                                    DWORD          dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedBoxData, sizeof(D3DLOCKED_BOX)))
    {
        DPF_ERR("bad pointer for pLockedBoxData passed to LockBox for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data 
    ZeroMemory(pLockedBoxData, sizeof(D3DLOCKED_BOX));

    // Validate Box
    if (pBox != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;
        DWORD Depth  = m_pParent->Desc()->Depth  >> m_iLevel;

        if (!CPixel::IsValidBox(m_pParent->Desc()->Format,
                                 Width, 
                                 Height,
                                 Depth,
                                 pBox))
        {
            DPF_ERR("LockBox for a Volume fails");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_VOL_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire volume.");
                return D3DERR_INVALIDCALL;
            }
            if (pBox != NULL)
            {
                DPF_ERR("Subboxes not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockBox for a level of a VolumeTexture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_VOL_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }
    return InternalLockBox(pLockedBoxData, pBox, dwFlags);
} // CDriverVolume::LockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::InternalLockBox"

HRESULT CDriverVolume::InternalLockBox(D3DLOCKED_BOX *pLockedBoxData, 
                                       CONST D3DBOX  *pBox, 
                                       DWORD          dwFlags)
{
    // Only one lock outstanding at a time is supported
    if (IsLocked())
    {
        DPF_ERR("LockBox failed on a volume level; volume was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be accessed.
    // Driver volume textures may be written to by HW through 
    // UpdateTexture. So we may need to sync with the current
    // command batch.
    m_pParent->OnVolumeLock(m_iLevel, pBox, dwFlags);

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD        = m_pParent->Device()->GetHandle();
    lockData.hSurface   = m_hKernelHandle;
    lockData.dwFlags    = dwFlags;
    if (pBox != NULL)
    {
        lockData.bHasBox = TRUE;
        lockData.box     = *pBox;
    }
    
    HRESULT hr = m_pParent->Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock level of a driver volume");
        return hr;
    }

    // Fill in the Locked_Box fields 
    D3DFORMAT Format = m_pParent->Desc()->Format;

    if (CPixel::IsDXT(Format))
    {
        // Start with our current width/height
        DWORD     Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD     Height = m_pParent->Desc()->Height >> m_iLevel;
   
        // Convert to blocks
        Width  = Width  / 4;
        Height = Height / 4;

        // At least one block
        if (Width == 0)
            Width = 1;
        if (Height == 0)
            Height = 1;

        switch (Format)
        {
            // For linear formats, 
            // Row Pitch is a row of blocks; and SlicePitch is for
            // a plane of blocks.

        case D3DFMT_DXT1:
            // DXT1 is 8 bytes per block
            pLockedBoxData->RowPitch    = Width  * 8;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;

        case D3DFMT_DXT2:
        case D3DFMT_DXT3:
        case D3DFMT_DXT4:
        case D3DFMT_DXT5:
            // DXT2-5 are 16 bytes per block
            pLockedBoxData->RowPitch    = Width  * 16;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;

#ifdef VOLUME_DXT
        case D3DFMT_DXV1:
            // DXV1 is 32-bytes per block
            pLockedBoxData->RowPitch    = Width  * 32;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;

        case D3DFMT_DXV2:
        case D3DFMT_DXV3:
        case D3DFMT_DXV4:
        case D3DFMT_DXV5:
            // DXV2-5 are 64-bytes per block
            pLockedBoxData->RowPitch    = Width  * 64;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;
#endif //VOLUME_DXT

        default:
            DPF_ERR("Unknown DXT format?");
            DXGASSERT(FALSE);
        }
    }
    else
    {
        // For all other formats, just return what
        // the driver gave us
        pLockedBoxData->RowPitch    = lockData.lPitch;
        pLockedBoxData->SlicePitch  = lockData.lSlicePitch;
    }


    pLockedBoxData->pBits       = lockData.lpSurfData;

#ifdef DEBUG
    if ((dwFlags & D3DLOCK_DISCARD))
    {
        DXGASSERT(m_iLevel == 0);
        if (!CPixel::IsFourCC(Format) &&
            !CPixel::IsIHVFormat(Format))
        {
            DXGASSERT(pBox == NULL);
            memset(pLockedBoxData->pBits, 0xDD, pLockedBoxData->SlicePitch * m_pParent->Desc()->Depth);
            for (UINT i = 1; i < m_pParent->GetLevelCount(); ++i)
            {
                D3DLOCKED_BOX Box;
                HRESULT hr = m_pParent->LockBox(i, &Box, NULL, 0);
                if (FAILED(hr))
                {
                    DPF(1, "Lock to mipsublevel failed. Not good.");
                    break;
                }
                D3DVOLUME_DESC LevelDesc;
                m_pParent->GetLevelDesc(i, &LevelDesc);
                memset(Box.pBits, 0xDD, Box.SlicePitch * LevelDesc.Depth);
                m_pParent->UnlockBox(i);
            }
        }
    }
#endif // DEBUG

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return S_OK;
} // CDriverVolume::InternalLockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::UnlockBox"

STDMETHODIMP CDriverVolume::UnlockBox()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!IsLocked())
    {
        DPF_ERR("UnlockBox failed on a mip level; volume wasn't locked.");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(m_isLockable);
    return InternalUnlockBox();
} // CDriverVolume::UnlockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::InternalUnlockBox"

HRESULT CDriverVolume::InternalUnlockBox()
{
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        m_pParent->Device()->GetHandle(),
        m_hKernelHandle
    };

    HRESULT hr = m_pParent->Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver volume failed to unlock");
        return hr;
    }

    // Clear our locked state
    m_isLocked = FALSE;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // CDriverVolume::InternalUnlockBox


// End of file : volume.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\volume.hpp ===
#ifndef __VOLUME_HPP__
#define __VOLUME_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       volume.hpp
 *  Content:    Class header the volume class. This class acts
 *              as a level for the MipVolume class. The base class
 *              assumes a system-memory allocation; while the
 *              Driver sub-class will call the driver for every
 *              lock and unlock operation.
 *
 *
 ***************************************************************************/

// Includes
#include "mipvol.hpp"

//
// Each Volume implements the IDirect3DVolume8 interface. 
// To reduce overhead per level, we have
// put most of the "real" guts of each volume into the MipVolume container 
// class; i.e. most of the methods of the Volume really just end 
// up calling something in the MipVolume object.
//
// The base class implementation assumes a sys-mem allocation.
//


//
// The CVolume class is a special class that
// works solely with the CMipVolume class. Each Volume
// corresponds to a single level of the mip-volume. They are
// not stand-alone COM objects because they share the
// same life-time as their CMipVolume parent.
//
// The CDriverVolume class is declared later in this file
//

class CVolume : public IDirect3DVolume8
{
public:
    // Constructor
    CVolume(CMipVolume *pParent, 
            BYTE        iLevel,
            HANDLE      hKernelHandle
            ) :
        m_pParent(pParent),
        m_isLocked(FALSE),
        m_iLevel(iLevel),
        m_hKernelHandle(hKernelHandle)
    {
        DXGASSERT(pParent);
        DXGASSERT(hKernelHandle || (pParent->GetUserPool() == D3DPOOL_SCRATCH) );
    #ifdef DEBUG
        m_cRefDebug = 0; 
    #endif // DEBUG

        if (m_pParent->Desc()->Usage & 
                (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE))
        {
            m_isLockable = TRUE;
        }
        else
        {   
            m_isLockable = FALSE;
        }

        return;
    } // CVolume

    ~CVolume()
    {
        DXGASSERT(m_cRefDebug == 0); 
        if (m_pParent->GetUserPool() != D3DPOOL_SCRATCH)
        {
            // Tell the thunk layer that we need to
            // be freed.
            DXGASSERT(m_hKernelHandle);

            D3D8_DESTROYSURFACEDATA DestroySurfData;
            DestroySurfData.hDD = m_pParent->Device()->GetHandle();
            DestroySurfData.hSurface = m_hKernelHandle;
            m_pParent->Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        }
#ifdef DEBUG
        else
        {
            DXGASSERT(m_pParent->GetUserPool() == D3DPOOL_SCRATCH);
        }
#endif //DEBUG
    }; // ~CVolume

public:
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID   riid, 
                               VOID   **ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID       riid, 
                              CONST VOID   *pvData, 
                              DWORD         cbData, 
                              DWORD         dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID   riid, 
                              VOID     *pvData, 
                              DWORD    *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID  riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);

    // IDirect3DVolume8 methods
    STDMETHOD(GetDesc)(D3DVOLUME_DESC *pDesc);

    STDMETHOD(LockBox)(D3DLOCKED_BOX  *pLockedBox, 
                       CONST D3DBOX   *pBox, 
                       DWORD           dwFlags);
    STDMETHOD(UnlockBox)(void);

    virtual HRESULT InternalLockBox(D3DLOCKED_BOX  *pLockedBox, 
                                    CONST D3DBOX   *pBox, 
                                    DWORD           dwFlags);
    virtual HRESULT InternalUnlockBox();

    BOOL IsLocked() const
    {
        return m_isLocked;
    } // IsLocked

protected:
    CMipVolume *m_pParent;
    BOOL        m_isLocked;
    BOOL        m_isLockable;
    BYTE        m_iLevel;

    // We'll need internal handles so that
    // we can communicate call Destroy 
    // and so that CDriverVolume can call
    // Lock/Unlock etc.
    HANDLE      m_hKernelHandle;

    CBaseDevice * Device() const
    {
        return m_pParent->Device();
    } // Device

    // Debugging trick to help spew better
    // information if someone over-releases a volume
    // (Since our ref's carry over to the parent object; it
    // means that over-releases can be hard to find.)
#ifdef DEBUG
    DWORD   m_cRefDebug;
#endif // DEBUG

}; // CVolume

// The CDriverVolume is a modification of the base volume
// class. It overrides lock and unlock and routes the call to the
// driver
class CDriverVolume : public CVolume
{
public:
    // Constructor
    CDriverVolume(CMipVolume *pParent, 
                  BYTE        iLevel,
                  HANDLE      hKernelHandle
                      ) :
        CVolume(pParent, iLevel, hKernelHandle)
    {
    } // CDriverVolume

public:

    STDMETHOD(LockBox)(D3DLOCKED_BOX  *pLockedBox, 
                       CONST D3DBOX   *pBox, 
                       DWORD            dwFlags);
    STDMETHOD(UnlockBox)();

    virtual HRESULT InternalLockBox(D3DLOCKED_BOX  *pLockedBox, 
                                    CONST D3DBOX   *pBox, 
                                    DWORD           dwFlags);
    virtual HRESULT InternalUnlockBox();

}; // CDriverVolume


#endif // __VOLUME_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\vbuffer.hpp ===
#ifndef __VBUFFER_HPP__
#define __VBUFFER_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vbuffer.hpp
 *  Content:    Class header the vertex buffer class
 *
 ***************************************************************************/

// Includes
#include "buffer.hpp"

// The base-class implementation of the vertex buffer assumes
// that it is resides system-memory. It may be managed.
class CVertexBuffer : public IDirect3DVertexBuffer8, public CBuffer
{
public:
    // Creation function for Vertex Buffers
    static HRESULT Create(CBaseDevice             *pDevice,
                          DWORD                    cbLength,
                          DWORD                    dwUsage,
                          DWORD                    dwFVF,
                          D3DPOOL                  Pool,
                          REF_TYPE                 refType,
                          IDirect3DVertexBuffer8 **ppVertexBuffer);
    
    static HRESULT CreateSysmemVertexBuffer(CBaseDevice *pDevice,
                                            DWORD        cbLength,
                                            DWORD        dwFVF,
                                            DWORD        dwUsage,
                                            DWORD        dwActualUsage,
                                            D3DPOOL      Pool,
                                            D3DPOOL      ActualPool,
                                            REF_TYPE     refType,
                                            CVertexBuffer **pVB);

    static HRESULT CreateDriverVertexBuffer(CBaseDevice *pDevice,
                                            DWORD        cbLength,
                                            DWORD        dwFVF,
                                            DWORD        dwUsage,
                                            DWORD        dwActualUsage,
                                            D3DPOOL      Pool,
                                            D3DPOOL      ActualPool,
                                            REF_TYPE     refType,
                                            CVertexBuffer **pVB);

    static HRESULT CreateDriverManagedVertexBuffer(CBaseDevice *pDevice,
                                                   DWORD        cbLength,
                                                   DWORD        dwFVF,
                                                   DWORD        dwUsage,
                                                   DWORD        dwActualUsage,
                                                   D3DPOOL      Pool,
                                                   D3DPOOL      ActualPool,
                                                   REF_TYPE     refType,
                                                   CVertexBuffer **pVB);

    // Methods for Resource Management

    // Create duplicate of current object in new pool;
    // LOD is ignored for our type
    virtual HRESULT Clone(D3DPOOL     Pool,
                          CResource **ppResource) const;

    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    virtual HRESULT LockI(DWORD dwFlags) {return D3D_OK;}
    virtual HRESULT UnlockI() {return D3D_OK;}
    virtual void SetCachedDataPointer(BYTE *pData) {}

    HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    DWORD GetFVF() const { return m_desc.FVF; }

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid,
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // Some Methods for IDirect3DBuffer
    STDMETHOD(SetPrivateData)(REFGUID riid,
                              CONST VOID *pvData,
                              DWORD cbData,
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid,
                              LPVOID pvData,
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);
    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // Methods for IDirect3DVertexBuffer8
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();
    STDMETHOD(GetDesc)(D3DVERTEXBUFFER_DESC *pDesc);

    DWORD GetVertexSize() const { return m_vertsize; }
    DWORD GetNumVertices() const { return m_numverts; }
    WORD* GetClipCodes() const { return m_pClipCodes; }
    void AllocateClipCodes();

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT(m_desc.Pool == D3DPOOL_SYSTEMMEM || m_desc.Pool == D3DPOOL_MANAGED);
        DXGASSERT(m_LockCount == 0);
        return GetPrivateDataPointer();
    }

protected:

    CVertexBuffer(CBaseDevice *pDevice,
                  DWORD        cbLength,
                  DWORD        dwFVF,
                  DWORD        dwUsage,
                  DWORD        dwActualUsage,
                  D3DPOOL      Pool,
                  D3DPOOL      ActualPool,
                  REF_TYPE     refType,
                  HRESULT     *phr);
    virtual ~CVertexBuffer()
    {
        delete[] m_pClipCodes;
    }

#if DBG
    HRESULT ValidateLockParams(UINT cbOffsetToLock,
                               UINT SizeToLock,
                               BYTE **ppbData,
                               DWORD dwFlags) const;
#endif // DBG

    D3DVERTEXBUFFER_DESC    m_desc;
    DWORD                   m_usageUser;
    DWORD                   m_numverts;
    DWORD                   m_vertsize;
    WORD*                   m_pClipCodes;

}; // class CVertexBuffer

class CVertexBufferMT : public CVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CVertexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CVertexBuffer::Unlock();
    }

    friend CVertexBuffer;

protected:

    CVertexBufferMT(CBaseDevice *pDevice,
                    DWORD        cbLength,
                    DWORD        dwFVF,
                    DWORD        Usage,
                    DWORD        ActualUsage,
                    D3DPOOL      Pool,
                    D3DPOOL      ActualPool,
                    REF_TYPE     refType,
                    HRESULT     *phr) :
        CVertexBuffer(pDevice,
                      cbLength,
                      dwFVF,
                      Usage,
                      ActualUsage,
                      Pool,
                      ActualPool,
                      refType,
                      phr)
    {
    }

}; // class CVertexBufferMT

// This derived version of the vertex buffer class
// overrides lock/unlock to call the driver instead
class CDriverVertexBuffer : public CVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    // Alloc CVertexBuffer to construct this object
    friend CVertexBuffer;

    HRESULT LockI(DWORD dwFlags);
    HRESULT UnlockI();
    BYTE* GetCachedDataPointer() const { return m_pbData; }
    void SetCachedDataPointer(BYTE *pData) { m_pbData = pData; }

    BYTE* Data() const
    {
        DXGASSERT(FALSE); // Direct pointer access not supported
        return 0;
    }

protected:
    CDriverVertexBuffer(CBaseDevice *pDevice,
                        DWORD        cbLength,
                        DWORD        dwFVF,
                        DWORD        Usage,
                        DWORD        ActualUsage,
                        D3DPOOL      Pool,
                        D3DPOOL      ActualPool,
                        REF_TYPE     refType,
                        HRESULT     *phr);
    ~CDriverVertexBuffer();

    BYTE*   m_pbData; // stores cached pointer

}; // class CDriverVertexBuffer

class CDriverVertexBufferMT : public CDriverVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverVertexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverVertexBuffer::Unlock();
    }

    friend CVertexBuffer;

protected:
    CDriverVertexBufferMT(CBaseDevice *pDevice,
                          DWORD        cbLength,
                          DWORD        dwFVF,
                          DWORD        Usage,
                          DWORD        ActualUsage,
                          D3DPOOL      Pool,
                          D3DPOOL      ActualPool,
                          REF_TYPE     refType,
                          HRESULT     *phr) :
        CDriverVertexBuffer(pDevice,
                            cbLength,
                            dwFVF,
                            Usage,
                            ActualUsage,
                            Pool,
                            ActualPool,
                            refType,
                            phr)
    {
    }

}; // class CVertexBufferMT

// This derived version of the vertex buffer class
// overrides lock/unlock to call the driver instead
class CDriverManagedVertexBuffer : public CVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    HRESULT LockI(DWORD dwFlags) {return D3D_OK;}
    HRESULT UnlockI() {return D3D_OK;}

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT((m_desc.Usage & D3DUSAGE_WRITEONLY) == 0);
        DXGASSERT(m_LockCount == 0);
        DXGASSERT(m_pbData != 0);
        return m_pbData;
    }

    // Alloc CVertexBuffer to construct this object
    friend CVertexBuffer;

protected:
    CDriverManagedVertexBuffer(CBaseDevice *pDevice,
                               DWORD        cbLength,
                               DWORD        dwFVF,
                               DWORD        Usage,
                               DWORD        ActualUsage,
                               D3DPOOL      Pool,
                               D3DPOOL      ActualPool,
                               REF_TYPE     refType,
                               HRESULT     *phr);

    HRESULT UpdateCachedPointer(CBaseDevice*);

    friend HRESULT CResource::RestoreDriverManagementState(CBaseDevice*);

    BYTE*   m_pbData; // stores cached pointer
    BOOL    m_bDriverCalled;

}; // class CDriverVertexBuffer

class CDriverManagedVertexBufferMT : public CDriverManagedVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverManagedVertexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverManagedVertexBuffer::Unlock();
    }

    // Alloc CVertexBuffer to construct this object
    friend CVertexBuffer;

protected:
    CDriverManagedVertexBufferMT(CBaseDevice *pDevice,
                                 DWORD        cbLength,
                                 DWORD        dwFVF,
                                 DWORD        Usage,
                                 DWORD        ActualUsage,
                                 D3DPOOL      Pool,
                                 D3DPOOL      ActualPool,
                                 REF_TYPE     refType,
                                 HRESULT     *phr) :
        CDriverManagedVertexBuffer(pDevice,
                                   cbLength,
                                   dwFVF,
                                   Usage,
                                   ActualUsage,
                                   Pool,
                                   ActualPool,
                                   refType,
                                   phr)
    {
    }

}; // class CDriverVertexBufferMT

#endif // __VBUFFER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\fw\_memallo.c ===
#include "ddrawpr.h"
#define __DXGUSEALLOC 1
#include "..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\gensym\sources.inc ===
TARGETNAME=
TARGETPATH=
TARGETTYPE=NOTARGET

INCLUDES = ..;$(INCLUDES);$(D3DDX8)\tnl;$(D3DDX8)\fe
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)

NTTARGETFILE0= \
!if !($(AMD64) || $(IA64))
             $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm
!endif

SOURCES=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\gensym\gensym.cpp ===
/*
 * $Id: gensym.cpp,v 1.7 1995/11/21 14:45:51 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "ddrawpr.h"
#include "dxgint.h"
#include "resource.hpp"
#include "texture.hpp"
#include "volume.hpp"
#include "mipmap.hpp"
#include "mipvol.hpp"
#include "cubemap.hpp"
#include "surface.hpp"
#include "d3d8ddi.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "ddi.h"
#include "d3dpr.hpp"
#include "ddrawp.h"
#include "memalloc.h"
#include "fltval.h"
#include "stateset.hpp"
#include "hmgr.hpp"
#include "d3dexcept.hpp"
#include "drawprim.hpp"
#include "resource.inl"
#include "pipeln.h"

#define DEFINE(type, member) \
    printf(#type "_" #member "  equ 0%xh\n", ((LONG)(&((type *)0)->member)))

#define MACRO(name) \
    printf(#name "  equ 0%xh\n", name)

main()
// pcomment prints a comment.

#define pcomment(s)  printf("; %s\n",s)

// pequate prints an equate statement.

#define pequate(name, value) printf("%s equ 0x%08lX\n",name,value);

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     printf("\n")

#define printVCACHE(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_VCACHE_"#name, OFFSET(D3DFE_PROCESSVERTICES, vcache.##name)); \
}

#define printD3DI_LIGHT(name)   \
{                               \
    printf("%-30s equ 0%LXH\n", "D3DI_LIGHT_"#name, OFFSET(D3DI_LIGHT, name)); \
}

#define printD3DFE_LIGHTING(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, lighting.##name)); \
}

#define printDevice(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "DEVI_"#name, OFFSET(CD3DHal, name)); \
}

#define printPV(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "D3DPV_"#name, OFFSET(D3DFE_PROCESSVERTICES, name)); \
}

#define printDeviceDP2(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", #name, OFFSET(CD3DHalDP2, name)); \
}

{
pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: offsets.asm");
    pcomment("");
    pcomment(" Defines D3D assembly-language structures.");
    pcomment(" This file is generated");
    pcomment("");
    pcomment(" Copyright (c) 1998, 1995 Microsoft Corporation");
pcomment("------------------------------------------------------------------");
    pblank();
    pblank();

    DEFINE(D3DINSTRUCTION, wCount);
    DEFINE(D3DINSTRUCTION, bSize);
    DEFINE(D3DINSTRUCTION, bOpcode);

    DEFINE(D3DVERTEX, x);
    DEFINE(D3DVERTEX, y);
    DEFINE(D3DVERTEX, z);
    DEFINE(D3DVERTEX, tu);
    DEFINE(D3DVERTEX, tv);

    DEFINE(D3DHVERTEX, dwFlags);
    DEFINE(D3DHVERTEX, hx);
    DEFINE(D3DHVERTEX, hy);
    DEFINE(D3DHVERTEX, hz);
    printf("D3DHVERTEX_size equ %d\n", sizeof(D3DHVERTEX));

    DEFINE(D3DTRIANGLE, v1);
    DEFINE(D3DTRIANGLE, v2);
    DEFINE(D3DTRIANGLE, v3);
    DEFINE(D3DTRIANGLE, wFlags);
    printf("D3DTRIANGLE_size equ %d\n", sizeof(D3DTRIANGLE));

    DEFINE(D3DMATRIXI, _11);
    DEFINE(D3DMATRIXI, _12);
    DEFINE(D3DMATRIXI, _13);
    DEFINE(D3DMATRIXI, _14);
    DEFINE(D3DMATRIXI, _21);
    DEFINE(D3DMATRIXI, _22);
    DEFINE(D3DMATRIXI, _23);
    DEFINE(D3DMATRIXI, _24);
    DEFINE(D3DMATRIXI, _31);
    DEFINE(D3DMATRIXI, _32);
    DEFINE(D3DMATRIXI, _33);
    DEFINE(D3DMATRIXI, _34);
    DEFINE(D3DMATRIXI, _41);
    DEFINE(D3DMATRIXI, _42);
    DEFINE(D3DMATRIXI, _43);
    DEFINE(D3DMATRIXI, _44);

    printf("D3DMATRIXI_size equ %d\n", sizeof(D3DMATRIXI));
    printf("D3DFE_LIGHTING_size equ %d\n", sizeof(D3DFE_LIGHTING));
    printf("D3DFE_VIEWPORTCACHE_size equ %d\n", sizeof(D3DFE_VIEWPORTCACHE));

    MACRO(D3DOP_TRIANGLE);

    MACRO(D3DCS_LEFT);
    MACRO(D3DCS_RIGHT);
    MACRO(D3DCS_TOP);
    MACRO(D3DCS_BOTTOM);
    MACRO(D3DCS_FRONT);
    MACRO(D3DCS_BACK);

    MACRO(D3DTBLEND_COPY);
    MACRO(D3DSHADE_FLAT);

    MACRO(D3DCMP_LESSEQUAL);
    MACRO(D3DCMP_GREATEREQUAL);
    MACRO(D3DCMP_ALWAYS);

    MACRO(D3DSTATUS_ZNOTVISIBLE);
    MACRO(D3DDEV_DONOTCLIP);

// Geometry pipeline
pcomment("-------------------- VCACHE ------------------------------------");
    printVCACHE(scaleX);
    printVCACHE(scaleY);
    printVCACHE(scaleZ);
    printVCACHE(offsetX);
    printVCACHE(offsetY);
    printVCACHE(offsetZ);
    printVCACHE(minXgb);
    printVCACHE(minYgb);
    printVCACHE(maxXgb);
    printVCACHE(maxYgb);
    printVCACHE(minX);
    printVCACHE(minY);
    printVCACHE(maxX);
    printVCACHE(maxY);
    printVCACHE(gb11);
    printVCACHE(gb22);
    printVCACHE(gb41);
    printVCACHE(gb42);
    printVCACHE(Kgbx1);
    printVCACHE(Kgby1);
    printVCACHE(Kgbx2);
    printVCACHE(Kgby2);
    printVCACHE(dvX);
    printVCACHE(dvY);
    printVCACHE(dvWidth);
    printVCACHE(dvHeight);
    printVCACHE(scaleXi);
    printVCACHE(scaleYi);
    printVCACHE(minXi);
    printVCACHE(minYi);
    printVCACHE(maxXi);
    printVCACHE(maxYi);
pcomment("---------------- D3DFE_LIGHTING ------------------------------------");
    printD3DFE_LIGHTING(diffuse);
    printD3DFE_LIGHTING(alpha);
    printD3DFE_LIGHTING(diffuse0);
    printD3DFE_LIGHTING(currentSpecTable);
    printD3DFE_LIGHTING(specular);
    printD3DFE_LIGHTING(outDiffuse);
    printD3DFE_LIGHTING(vertexAmbient);
    printD3DFE_LIGHTING(vertexDiffuse);
    printD3DFE_LIGHTING(outSpecular);
    printD3DFE_LIGHTING(vertexSpecular);
    printD3DFE_LIGHTING(dwLightingFlags);
    printD3DFE_LIGHTING(alphaSpecular);
    printD3DFE_LIGHTING(model_eye);
    printD3DFE_LIGHTING(activeLights);
    printD3DFE_LIGHTING(material);
    printD3DFE_LIGHTING(ambientSceneScaled);
    printD3DFE_LIGHTING(ambientScene);
    printD3DFE_LIGHTING(fog_mode);
    printD3DFE_LIGHTING(fog_density);
    printD3DFE_LIGHTING(fog_start);
    printD3DFE_LIGHTING(fog_end);
    printD3DFE_LIGHTING(fog_factor);
    printD3DFE_LIGHTING(specThreshold);
    printD3DFE_LIGHTING(ambient_save);
    printD3DFE_LIGHTING(materialAlpha);
    printD3DFE_LIGHTING(materialAlphaS);
    printD3DFE_LIGHTING(dwDiffuse0);
    printD3DFE_LIGHTING(directionToCamera);
    printD3DFE_LIGHTING(dwAmbientSrcIndex);
    printD3DFE_LIGHTING(dwDiffuseSrcIndex);
    printD3DFE_LIGHTING(dwSpecularSrcIndex);
    printD3DFE_LIGHTING(dwEmissiveSrcIndex);
pcomment("---------------- D3DI_LIGHT ------------------------------------");
    printD3DI_LIGHT(model_position);
    printD3DI_LIGHT(type);
    printD3DI_LIGHT(model_direction);
    printD3DI_LIGHT(flags);
    printD3DI_LIGHT(falloff);
    printD3DI_LIGHT(inv_theta_minus_phi);
    printD3DI_LIGHT(halfway);
    printD3DI_LIGHT(next);
    printD3DI_LIGHT(range_squared);
    printD3DI_LIGHT(attenuation0);
    printD3DI_LIGHT(attenuation1);
    printD3DI_LIGHT(attenuation2);
    printD3DI_LIGHT(cos_theta_by_2);
    printD3DI_LIGHT(cos_phi_by_2);
    printD3DI_LIGHT(position);
    printD3DI_LIGHT(direction);
    printD3DI_LIGHT(range);

pcomment("---------------- D3DFE_PROCESSVERTICES ------------------------------");
    printPV(mCTM);
    printPV(dwMaxTextureIndices);
    printPV(lighting);
    printPV(vcache);
    printPV(lpdwRStates);
    printPV(ClipperState);
    printPV(dwFlags);
    printPV(dwDeviceFlags);
    printPV(dwNumVertices);
    printPV(dwNumPrimitives);
    printPV(dwNumIndices);
    printPV(lpwIndices);
    printPV(primType);
    printPV(nTexCoord);
    printPV(position);
    printPV(normal);
    printPV(diffuse);
    printPV(specular);
    printPV(textures);
    printPV(dwVIDIn);
    printPV(dwVIDOut);
    printPV(dwOutputSize);
    printPV(lpvOut);
    printPV(lpClipFlags);
    printPV(dwClipUnion);
    printPV(dwClipIntersection);
    printPV(texOffset);
    printPV(normalOffset);
    printPV(diffuseOffset);
    printPV(specularOffset);
    printPV(texOffsetOut);
    printPV(diffuseOffsetOut);
    printPV(specularOffsetOut);
    printPV(dwClipMaskOffScreen);
    printPV(dwFirstClippedVertex);
    printPV(userClipPlane);
    printPV(dwFlags2);

pcomment("---------------- CD3DHal ------------------------------------");
    printDevice(m_DeviceType              );
    // printDevice(ddiType                   );
    // printDevice(lpD3DHALCallbacks         );
    // printDevice(lpD3DHALGlobalDriverData  );
    // printDevice(lpD3DHALCallbacks2        );
    // printDevice(lpD3DHALCallbacks3        );
    // printDevice(lpDD                      );
    // printDevice(lpD3DExtendedCaps);
    // printDevice(pfnRastService);
    printDevice(transform                 );
    printDevice(dwFEFlags);
    printDevice(specular_tables);
    printDevice(specular_table);
    printDevice(lightVertexFuncTable);
    printDevice(m_lpD3DMappedTexI);
    printDevice(m_dwHintFlags);
//    printDevice(lpwDPBuffer);
    printDevice(HVbuf);
    printDevice(rstates);
    printDevice(tsstates);
pcomment("---------------- MISC ------------------------------------");
    /*
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    */
    pequate("_R_", 0);
    pequate("_G_", 4);
    pequate("_B_", 8);

    pequate("_X_", 0);
    pequate("_Y_", 4);
    pequate("_Z_", 8);
    pequate("_W_", 12);
    pequate("D3DLIGHTI_COMPUTE_SPECULAR ", D3DLIGHTI_COMPUTE_SPECULAR);

pcomment("---------------- dwHintFlags-----------------------------------");

    pequate("D3DDEVBOOL_HINTFLAGS_INSCENE        ", D3DDEVBOOL_HINTFLAGS_INSCENE      );
    pequate("D3DDEVBOOL_HINTFLAGS_MULTITHREADED  ", D3DDEVBOOL_HINTFLAGS_MULTITHREADED);

pcomment("---------------- m_dwRuntimeFlags ---------------------------------");
    pequate("D3DRT_RECORDSTATEMODE           ", D3DRT_RECORDSTATEMODE         );
    pequate("D3DRT_EXECUTESTATEMODE          ", D3DRT_EXECUTESTATEMODE        );
    pequate("D3DRT_NEED_TEXTURE_UPDATE       ", D3DRT_NEED_TEXTURE_UPDATE     );
pcomment("---------------- dwFEFlags ------------------------------------");

    pequate("D3DFE_WORLDMATRIX_DIRTY         ", D3DFE_WORLDMATRIX_DIRTY       );
    pequate("D3DFE_TLVERTEX                  ", D3DFE_TLVERTEX                );
    pequate("D3DFE_PROJMATRIX_DIRTY          ", D3DFE_PROJMATRIX_DIRTY        );
    pequate("D3DFE_VIEWMATRIX_DIRTY          ", D3DFE_VIEWMATRIX_DIRTY        );
    pequate("D3DFE_NEED_TRANSFORM_LIGHTS     ", D3DFE_NEED_TRANSFORM_LIGHTS   );
    pequate("D3DFE_MATERIAL_DIRTY            ", D3DFE_MATERIAL_DIRTY          );
    pequate("D3DFE_CLIPPLANES_DIRTY          ", D3DFE_CLIPPLANES_DIRTY        );
    pequate("D3DFE_LIGHTS_DIRTY              ", D3DFE_LIGHTS_DIRTY            );
    pequate("D3DFE_VERTEXBLEND_DIRTY         ", D3DFE_VERTEXBLEND_DIRTY       );
    pequate("D3DFE_FRUSTUMPLANES_DIRTY       ", D3DFE_FRUSTUMPLANES_DIRTY     );
    pequate("D3DFE_WORLDVIEWMATRIX_DIRTY     ", D3DFE_WORLDVIEWMATRIX_DIRTY   );
    pequate("D3DFE_FVF_DIRTY                 ", D3DFE_FVF_DIRTY               );
    pequate("D3DFE_MAP_TSS_TO_RS             ", D3DFE_MAP_TSS_TO_RS           );
    pequate("D3DFE_INVWORLDVIEWMATRIX_DIRTY  ", D3DFE_INVWORLDVIEWMATRIX_DIRTY);
    pequate("D3DRT_LOSTSURFACES              ", D3DRT_LOSTSURFACES            );
    pequate("D3DFE_DISABLE_TEXTURES          ", D3DFE_DISABLE_TEXTURES        );
    pequate("D3DFE_CLIPMATRIX_DIRTY          ", D3DFE_CLIPMATRIX_DIRTY        );
    pequate("D3DFE_TLHAL                     ", D3DFE_TLHAL                   );
pcomment("---------------- pv->dwFlags ------------------------------------");
    pequate("D3DPV_FOG                   ", D3DPV_FOG                 );
    pequate("D3DPV_DOCOLORVERTEX         ", D3DPV_DOCOLORVERTEX       );
    pequate("D3DPV_LIGHTING              ", D3DPV_LIGHTING            );
    pequate("D3DPV_SOA                   ", D3DPV_SOA                 );
    pequate("D3DPV_COLORVERTEX_E         ", D3DPV_COLORVERTEX_E       );
    pequate("D3DPV_COLORVERTEX_D         ", D3DPV_COLORVERTEX_D       );
    pequate("D3DPV_COLORVERTEX_S         ", D3DPV_COLORVERTEX_S       );
    pequate("D3DPV_COLORVERTEX_A         ", D3DPV_COLORVERTEX_A       );
    pequate("D3DPV_DONOTCOPYSPECULAR     ", D3DPV_DONOTCOPYSPECULAR   );
    pequate("D3DPV_NONCLIPPED            ", D3DPV_NONCLIPPED          );
    pequate("D3DPV_FRUSTUMPLANES_DIRTY   ", D3DPV_FRUSTUMPLANES_DIRTY );
    pequate("D3DPV_VBCALL                ", D3DPV_VBCALL              );
    pequate("D3DPV_DONOTCOPYTEXTURE      ", D3DPV_DONOTCOPYTEXTURE    );
    pequate("D3DPV_TLVCLIP               ", D3DPV_TLVCLIP             );
    pequate("D3DPV_TRANSFORMONLY         ", D3DPV_TRANSFORMONLY       );
    pequate("D3DPV_DONOTCOPYDIFFUSE      ", D3DPV_DONOTCOPYDIFFUSE    );
    pequate("D3DPV_PERSIST               ", D3DPV_PERSIST             );
pcomment("---------------- pv->dwDeviceFlags ------------------------------");
    pequate("D3DDEV_GUARDBAND                ", D3DDEV_GUARDBAND          );
    pequate("D3DDEV_RANGEBASEDFOG            ", D3DDEV_RANGEBASEDFOG      );
    pequate("D3DDEV_FOG                      ", D3DDEV_FOG                );
    pequate("D3DDEV_SHADERDIRTY              ", D3DDEV_SHADERDIRTY);
    pequate("D3DDEV_DONOTSTRIPELEMENTS       ", D3DDEV_DONOTSTRIPELEMENTS);
    pequate("D3DDEV_VERTEXSHADERS            ", D3DDEV_VERTEXSHADERS);
    pequate("D3DDEV_VBPROCVER                ", D3DDEV_VBPROCVER);
    pequate("D3DDEV_DOPOINTSPRITEEMULATION   ", D3DDEV_DOPOINTSPRITEEMULATION);
    pequate("D3DDEV_FLATSHADEMODE            ", D3DDEV_FLATSHADEMODE);
    pequate("D3DDEV_SPECULARENABLE           ", D3DDEV_SPECULARENABLE);
    pequate("D3DDEV_TRANSFORMEDFVF           ", D3DDEV_TRANSFORMEDFVF);
    pequate("D3DDEV_INDEXEDVERTEXBLENDENABLE ", D3DDEV_INDEXEDVERTEXBLENDENABLE);
    pequate("D3DDEV_FRUSTUMPLANES_DIRTY      ", D3DDEV_FRUSTUMPLANES_DIRTY);
    pequate("D3DDEV_TEXTRANSFORMDIRTY        ", D3DDEV_TEXTRANSFORMDIRTY  );
    pequate("D3DDEV_TRANSFORMDIRTY           ", D3DDEV_TRANSFORMDIRTY     );
    pequate("D3DDEV_REMAPTEXTUREINDICES      ", D3DDEV_REMAPTEXTUREINDICES);
    pequate("D3DDEV_LIGHTSDIRTY              ", D3DDEV_LIGHTSDIRTY        );
    pequate("D3DDEV_DONOTCLIP                ", D3DDEV_DONOTCLIP          );
    pequate("D3DDEV_MODELSPACELIGHTING       ", D3DDEV_MODELSPACELIGHTING );
    pequate("D3DDEV_LOCALVIEWER              ", D3DDEV_LOCALVIEWER        );
    pequate("D3DDEV_NORMALIZENORMALS         ", D3DDEV_NORMALIZENORMALS   );
    pequate("D3DDEV_TEXTURETRANSFORM         ", D3DDEV_TEXTURETRANSFORM   );
    pequate("D3DDEV_STRIDE                   ", D3DDEV_STRIDE             );
    pequate("D3DDEV_COLORVERTEX              ", D3DDEV_COLORVERTEX        );
    pequate("D3DDEV_POSITIONINCAMERASPACE    ", D3DDEV_POSITIONINCAMERASPACE);
    pequate("D3DDEV_NORMALINCAMERASPACE      ", D3DDEV_NORMALINCAMERASPACE);
    pequate("D3DDEV_LIGHTING                 ", D3DDEV_LIGHTING);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\gensym\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

GENSYMFLAGS = -DWINNT -DNT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\gensym\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


OFFSETS = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm

D3D_VERSION = 0x0800

GENSYMFLAGS = -DWIN32 -D_WIN32 -DD3D -Zp -DIS_32 -DDIRECT3D_VERSION=$(D3D_VERSION) 
GENSYMBASE = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gensym
GENSYMEXE = $(GENSYMBASE).exe
GENSYMSOURCE = ..\gensym.cpp
GENSYMINCS = 
GENTGT = $(_OBJ_DIR)\$(TARGET_DIRECTORY)

INCPATHS = \
	-I$(BASEDIR)\public\sdk\inc\
	-I$(BASEDIR)\public\sdk\inc\crt\
	-I$(BASEDIR)\public\oak\inc\
    -I$(BASEDIR)\public\internal\multimedia\inc\
    -I..\
    -I$(BASEDIR)\public\internal\windows\inc\
    -I$(BASEDIR)\public\internal\base\inc\
    -I$(D3DDX8)\inc\
    -I$(D3DDX8)\fe\
    -I$(D3DDX8)\util\
    -I$(D3DDX8)\fw\
    -I$(DXGROOT)\misc\
    -I$(DXGROOT)\inc\
    -I$(DXROOT)\inc\


$(OFFSETS): $(GENSYMSOURCE) $(GENSYMINCS)
    set PASS0ONLY=
    nmake $(GENSYMBASE).obj $(HOST_TARGET_DEFINES) $(HOST_TOOLS) 

    -link -out:$(GENSYMEXE) @<<
-machine:$(HOST_TARGETCPU)
-base:@$(COFFBASE_TXT_FILE),usermode
-subsystem:console
-entry:mainCRTStartup
-ignore:4089
-force:unresolved
-nodefaultlib
$(GENSYMBASE).obj
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\kernel32.lib
$(SDK_LIB_DEST)\$(HOST_TARGETCPU)\msvcrt.lib
$(PERFLIBS)
<<
    -$(GENSYMEXE) > $(OFFSETS)
    -erase $(GENSYMBASE).obj
    -erase $(GENSYMEXE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\gensym\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

GENSYMFLAGS = -DWIN95 
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\d3dfe.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfe.hpp
 *  Content:    Direct3D internal include file
 *              for geometry pipeline implementations
 *
 ***************************************************************************/

// DX8 Copy the whole file to DX8


#ifndef _D3DFE_H
#define _D3DFE_H

#include "d3dtypesp.h"
#include "d3d8p.h"
#include "lists.hpp"
#include "d3ditype.h"

class RTDebugMonitor;
class CD3DDDI;
class ID3DFE_PVFUNCS;
struct CVStream;

const DWORD __MAX_VERTEX_SIZE = 180;    // Max size of FVF vertex in bytes
//-----------------------------------------------------------------------------
// "link" member should be the last, because we copy the structure using
// offsetof(D3DMATRIXI, link)
//
#define D3DMATRIXI D3DMATRIX
#define LPD3DMATRIXI LPD3DMATRIX

// Bits for m_dwOutRegs
const DWORD CPSGPShader_SPECULAR   = 1 << 0;
const DWORD CPSGPShader_DIFFUSE    = 1 << 1;
const DWORD CPSGPShader_POSITION   = 1 << 2;
const DWORD CPSGPShader_PSIZE      = 1 << 3;
const DWORD CPSGPShader_FOG        = 1 << 4;

//-----------------------------------------------------------------------------
// Base class for PSGP vertex shader
// PSGP should derive its internal shader object from the class and return it
// in CreateShader call.
// Desctructor should be implemented.
//
class CPSGPShader
{
public:
    virtual ~CPSGPShader() {}

    // The following data is initialized by Microsoft after CPSGPShader is
    // created

    // Defines output registers (except texture) written by the shader
    // This member is filled by Microsoft's pipeline. PSGP reads it.
    DWORD   m_dwOutRegs;
    // Output FVF for this shaders
    DWORD   m_dwOutFVF;
    // Diffuse color offset in the output vertex in bytes
    DWORD   m_dwPointSizeOffset;
    // Diffuse color offset in the output vertex in bytes
    DWORD   m_dwDiffuseOffset;
    // Specular color offset in the output vertex in bytes
    DWORD   m_dwSpecularOffset;
    // Fog factor offset in the output vertex in bytes
    DWORD   m_dwFogOffset;
    // Texture offset in the output vertex in bytes
    DWORD   m_dwTextureOffset;
    // Output vertex size in bytes
    DWORD   m_dwOutVerSize;
    // Number of output texture coordinate sets
    DWORD   m_nOutTexCoord;
    // Size of each texture set in bytes
    DWORD   m_dwOutTexCoordSize[D3DDP_MAXTEXCOORD];
};
//-----------------------------------------------------------------------------
//
// Software pipeline constants
//
//-----------------------------------------------------------------------------

// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD __DEFAULT_DIFFUSE = 0xFFFFFFFF;
const DWORD __DEFAULT_SPECULAR = 0;

const DWORD __MAXUSERCLIPPLANES = 6;

const DWORD __NUMELEMENTS = 17;
const DWORD __NUMSTREAMS = __NUMELEMENTS;

//-----------------------------------------------------------------------------
// The CSetD3DFPstate is used to facilitate the changing of FPU settings.
// In the constructor the optimal FPU state is set. In the destructor the
// old state is restored.
//
class CD3DFPstate
{
public:
    CD3DFPstate()
        {
        #ifdef _X86_
            WORD wTemp, wSave;
            wSavedFP = FALSE;
            // Disable floating point exceptions and go to single mode
                __asm fstcw wSave
                if (wSave & 0x300 ||            // Not single mode
                    0x3f != (wSave & 0x3f) ||   // Exceptions enabled
                    wSave & 0xC00)              // Not round to nearest mode
                {
                    __asm {
                        mov ax, wSave
                        and ax, not 300h    ;; single mode
                        or  ax, 3fh         ;; disable all exceptions
                        and ax, not 0xC00   ;; round to nearest mode
                        mov wTemp, ax
                        fldcw   wTemp
                    }
                    wSavedFP = TRUE;
                }
                wSaveFP = wSave;
        #endif
        }
    ~CD3DFPstate()
        {
        #ifdef _X86_
            WORD wSave = wSaveFP;
            if (wSavedFP)
                __asm {
                    fnclex
                    fldcw   wSave
                }
        #endif
        }
protected:
#ifdef _X86_
    WORD wSaveFP;
    WORD wSavedFP;  // WORD-sized to make the data an even DWORD
#endif
};

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

// this is not available for alpha or IA64
#ifndef LONG_MAX
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#endif

//-----------------------------------------------------------------------------
// Base definitions
//

// Size of Microsoft's internal clip vertex batch
const DWORD VER_IN_BATCH = 8;

typedef WORD D3DFE_CLIPCODE;

struct BATCHBUFFER;
//-----------------------------------------------------------------------------
struct _D3DFE_LIGHTING;
typedef struct _D3DFE_LIGHTING D3DFE_LIGHTING;

struct _D3DI_LIGHT;
typedef struct _D3DI_LIGHT D3DI_LIGHT;

class D3DFE_PROCESSVERTICES;
typedef class D3DFE_PROCESSVERTICES* LPD3DFE_PROCESSVERTICES;

extern "C"
{
typedef void (*LIGHT_VERTEX_FUNC)(LPD3DFE_PROCESSVERTICES pv,
                                  D3DI_LIGHT *light,
                                  D3DVERTEX *pInpCoord,
                                  D3DVALUE* pWeights,
                                  BYTE* pMatrixIndices,
                                  D3DVECTOR *pInpNormal,
                                  D3DLIGHTINGELEMENT *pEyeSpaceData);
typedef void (*PFN_LIGHTLOOP)(LPD3DFE_PROCESSVERTICES pv,
                              DWORD dwVerCount,
                              BATCHBUFFER *pBatchBuffer,
                              D3DI_LIGHT *light,
                              D3DVERTEX *in,
                              D3DVALUE* pWeights,
                              BYTE* pMatrixIndices,
                              D3DVECTOR *pNormal,
                              DWORD *pDiffuse,
                              DWORD *pSpecular);
}
//-----------------------------------------------------------------------------
// This is per texture stage data
//
typedef struct _D3DFE_TEXTURESTAGE
{
    // Original value of the texture stage - input index
    DWORD       dwInpCoordIndex;
    // Texture coord offset in the FVF vertex
    DWORD       dwInpOffset;
    // Input index of the texture set is mapped to this output index
    DWORD       dwOutCoordIndex;
    DWORD       dwOrgStage;         // Original texture stage
    DWORD       dwOrgWrapMode;      // Original WRAP mode
    // NULL if texture transform is disabled for the stage
    D3DMATRIXI *pmTextureTransform;
    // This is index to a table of functions which perform texture transform.
    // Index is computed as follow:
    //      bits 0-1 - (number of input  texture coordinates - 1)
    //      bits 2-3 - (number of output texture coordinates - 1)
    DWORD       dwTexTransformFuncIndex;
    // Mode of texture generation. This is the same value, passed with 
    // D3DTSS_TEXCOORDINDEX, but with texture index stripped out.
    DWORD       dwTexGenMode;       
    // Set to TRUE, when we need to divide texture coordinates by the last
    // element of a texture coordinate set
    BOOL        bDoTextureProjection;
} D3DFE_TEXTURESTAGE, *LPD3DFE_TEXTURESTAGE;
//-----------------------------------------------------------------------------
typedef struct _RECTV
{
    union
    {
        D3DVALUE x1;
        D3DVALUE dvX1;
    };
    union
    {
        D3DVALUE y1;
        D3DVALUE dvY1;
    };
    union
    {
        D3DVALUE x2;
        D3DVALUE dvX2;
    };
    union
    {
        D3DVALUE y2;
        D3DVALUE dvY2;
    };
} D3DRECTV, *LPD3DRECTV;
//-----------------------------------------------------------------------------
/*
 * Lighting defines
 */
typedef struct _SpecularTable
{
    LIST_MEMBER(_SpecularTable) list;
    float   power;          /* shininess power */
    float   table[260];     /* space for overflows */
} SpecularTable;

typedef struct {D3DVALUE r,g,b;} D3DFE_COLOR;
//-----------------------------------------------------------------------------
// Internal version of lightdata and constants for "flags" member of D3DI_LIGHT
//
const DWORD D3DLIGHTI_ATT0_IS_NONZERO   = 1 << 0;
const DWORD D3DLIGHTI_ATT1_IS_NONZERO   = 1 << 1;
const DWORD D3DLIGHTI_ATT2_IS_NONZERO   = 1 << 2;
const DWORD D3DLIGHTI_LINEAR_FALLOFF    = 1 << 3;
// Set when light data is changed
const DWORD D3DLIGHTI_DIRTY             = 1 << 4;
// This flag depends on D3DRS_SPACULARENABLE and light specular color
const DWORD D3DLIGHTI_COMPUTE_SPECULAR  = 1 << 5;
// Set when the light is enabled
const DWORD D3DLIGHTI_ENABLED           = 1 << 7;
const DWORD D3DLIGHTI_SPECULAR_IS_ZERO  = 1 << 8;
const DWORD D3DLIGHTI_AMBIENT_IS_ZERO   = 1 << 9;
// Set when we need to send the light to the driver when switching to the
// hardware vertex processing mode.
const DWORD D3DLIGHTI_UPDATEDDI         = 1 << 10;
// Set when we need to send "enable" state of the light to the driver when
// switching to the hardware vertex processing mode
const DWORD D3DLIGHTI_UPDATE_ENABLE_DDI = 1 << 11;

const DWORD D3DLIGHTI_OPTIMIZATIONFLAGS = D3DLIGHTI_SPECULAR_IS_ZERO |
                                          D3DLIGHTI_AMBIENT_IS_ZERO  |
                                          D3DLIGHTI_ATT0_IS_NONZERO  |
                                          D3DLIGHTI_ATT1_IS_NONZERO  |
                                          D3DLIGHTI_ATT2_IS_NONZERO  |
                                          D3DLIGHTI_LINEAR_FALLOFF;
//-----------------------------------------------------------------------------
// Members of this structure should be aligned as stated
typedef struct _D3DI_LIGHT
{
    // Should be QWORD aligned
    D3DVECTOR       model_position; // In the camera or model space
    D3DLIGHTTYPE    type;
    // Should be QWORD aligned
    D3DVECTOR       model_direction;// In the camera or model space
    D3DVALUE        falloff;
    // Should be QWORD aligned
    DWORD           flags;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     diffuseMat;     // Material diffuse times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     specularMat;    // Material specular times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     ambientMat;     // Material specular times light color
    D3DVALUE        inv_theta_minus_phi;
    // Should be QWORD aligned
    D3DVECTOR       halfway;        // Used by directional, parallel-point and
                                    // spot lights when camera is in infinity
    struct _D3DI_LIGHT *next;       // Next in the active light list
    // Should be QWORD aligned
    D3DFE_COLOR     diffuse;        // Original color scaled to 0 - 255
    D3DFE_COLOR     specular;       // Original color scaled to 0 - 255
    D3DFE_COLOR     ambient;        // Original color scaled to 0 - 255

    LIGHT_VERTEX_FUNC lightVertexFunc;  // Function to light a D3DVERTEX

    D3DVALUE        range_squared;
    D3DVALUE        attenuation0;
    D3DVALUE        attenuation1;
    D3DVALUE        attenuation2;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVECTOR       position;       // In the world space
    D3DVECTOR       direction;      // In the world space
    D3DVALUE        range;
    // Pointer to a PSGP specific "per light" data
    LPVOID          pPSGPData;
// Microsoft's pipeline specific data
    // Used in multi-loop pipeline for first lights
    PFN_LIGHTLOOP   pfnLightFirst;
    // Used in multi-loop pipeline for not first lights
    PFN_LIGHTLOOP   pfnLightNext;
} D3DI_LIGHT, *LPD3DI_LIGHT;
//-----------------------------------------------------------------------------
// Bits for lighting flags (dwLightingFlags
//
const DWORD __LIGHT_VERTEXTRANSFORMED = 1;  // Vertex is in the camera space
const DWORD __LIGHT_NORMALTRANSFORMED = 2;  // Normal is in the camera space
const DWORD __LIGHT_SPECULARCOMPUTED  = 4;
const DWORD __LIGHT_DIFFUSECOMPUTED   = 8;
//-----------------------------------------------------------------------------
// Members of this structure should be aligned as stated
//
typedef struct _D3DFE_LIGHTING
{
// Temporary data used when computing lighting
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse;
    DWORD             alpha;          // Alpha to use for output vertex color
                                      // (could be overriden by vertex difuse
                                      // color) (0-255) shifted left by 24 bits
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse0;       // Ca*Cma + Cme
    float            *currentSpecTable;
    // Should be QWORD aligned
    D3DFE_COLOR       specular;
    DWORD             outDiffuse;     // Result of lighting
    // Should be QWORD aligned
    D3DVECTOR         model_eye;      // camera position in model (camera) space
    DWORD             vertexAmbient;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientSceneScaled; // Scene ambient color (scaled 0-255)
    DWORD             vertexDiffuse;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientScene;         // Scene ambient color (0.0-1.0)
    DWORD             outSpecular;    // Result of lighting
    // Should be QWORD aligned
    // Direction to camera in the model space. Used in model space lighting
    D3DVECTOR         directionToCamera;
    DWORD             vertexSpecular;       // Provided with a vertex
    // Should be QWORD aligned
    D3DMATERIAL8      material;
    DWORD             dwLightingFlags;
    // Alpha to use for output specular vertex color
    // (could be overriden by vertex specular color)
    // (0-255) shifted left by 24 bits
    DWORD             alphaSpecular;
// End of temporary data
    D3DI_LIGHT       *activeLights;
    int               fog_mode;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)
    D3DVALUE          specThreshold;  // If a dot product less than this value,
                                      // specular factor is zero
    DWORD             ambient_save;   // Original unscaled color
    int               materialAlpha;  // Current material diffuse alpha (0-255)
                                      // shifted left by 24 bits
    int               materialAlphaS; // Current material specular alpha (0-255)
                                      // shifted left by 24 bits
    DWORD             dwDiffuse0;     // Packed diffuse0
    DWORD             dwAmbientSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwDiffuseSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwSpecularSrcIndex;   // 0 - diffuse, 1 - specular
    DWORD             dwEmissiveSrcIndex;   // 0 - diffuse, 1 - specular
} D3DFE_LIGHTING;
//-----------------------------------------------------------------------------
// Some data precomputed for a current viewport
// ATTENTION: If you want to add or re-arrange data, contact IOURIT or ANUJG
//
typedef struct _D3DFE_VIEWPORTCACHE
{
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleX;            // dvWidth
    D3DVALUE scaleY;            // -dvHeight
    D3DVALUE offsetX;           // dvX
    D3DVALUE offsetY;           // dvY + dvHeight
    D3DVALUE scaleZ;            // dvMaxZ - dvMinZ
    D3DVALUE offsetZ;           // dvY + dvHeight
// Min and max window values with gaurd band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;
// Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY
// Coefficients to transform a vertex to perform the guard band clipping
// x*gb11 + w*gb41
// y*gb22 + w*gb42
//
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;
// Coefficients to apply clipping rules for the guard band clipping
// They are used by clipping routins
// w*Kgbx1 < x < w*Kgbx2
// w*Kgby1 < y < w*Kgby2
//
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ
// Min and max values for viewport window in pixels (integer version)
    int      minXi;             // offsetX - scaleX
    int      minYi;             // offsetY - scaleY
    int      maxXi;             // offsetX + scaleX
    int      maxYi;             // offsetY + scaleY
} D3DFE_VIEWPORTCACHE;
//-----------------------------------------------------------------------------
// Process vertices interface
//
// Bits for process vertices flags
//
// D3DDEV_STRIDE D3DPV_SOA
//      0         1       position.dwStride = number of vertices in SOA
//      0         0       position.dwStride = contiguous vertex size
//      1         0       vertex is not contiguous, all dwStride fields are used
//      1         1       reserved
//      1         1       reserved
//
// Do position tweening. Guaranties that position2 pointer is not NULL
const DWORD D3DPV_POSITION_TWEENING = 1 << 6;  
// Do normal tweening. Guaranties that normal2 pointer is not NULL
const DWORD D3DPV_NORMAL_TWEENING= 1 << 7;
const DWORD D3DPV_FOG            = 1 << 8;  // Need to apply fog
const DWORD D3DPV_DOCOLORVERTEX  = 1 << 9;  // Need to apply color vertex
const DWORD D3DPV_LIGHTING       = 1 << 10; // Need to apply lighting
const DWORD D3DPV_SOA            = 1 << 12; // SOA structure is used
// Need to replace emissive material color
const DWORD D3DPV_COLORVERTEX_E  = 1 << 13;
// Need to replace diffuse material color
const DWORD D3DPV_COLORVERTEX_D  = 1 << 14;
// Need to replace specular material color
const DWORD D3DPV_COLORVERTEX_S  = 1 << 15;
// Need to replace ambient material color
const DWORD D3DPV_COLORVERTEX_A  = 1 << 16;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Specular color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYSPECULAR = 1 << 20;
// Set when one pass clipping and vertex processing is used
const DWORD D3DPV_ONEPASSCLIPPING= 1 << 21;
// This indicates that the primitive is non clipped, but we pretend that it is
// clipped to generate DP2HAL inline primitive. Can only be set by tri fan.
const DWORD D3DPV_NONCLIPPED     = 1 << 25;
// Propagated from dwFEFlags
const DWORD D3DPV_FRUSTUMPLANES_DIRTY = 1 << 26;
// Set if the geometry loop is called from VertexBuffer::ProcessVertices.
// Processing is different because the output buffer FVF format is defined by
// user, not by SetupFVFData function.
const DWORD D3DPV_VBCALL         = 1 << 27;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Texture coordinates should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYTEXTURE = 1 << 28;
// To mark whether we are doing TLVERTEX clipping or not
const DWORD D3DPV_TLVCLIP        = 1 << 29;
// Mictosoft internal !!! Set when only transformation is required
// (no lightng or texture copy)
const DWORD D3DPV_TRANSFORMONLY  = 1 << 30;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Diffuse color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYDIFFUSE = 1 << 31;
// These flags persist from call to call till something causes them to change
const DWORD D3DPV_PERSIST = D3DPV_FOG                   |
                            D3DPV_LIGHTING              |
                            D3DPV_DONOTCOPYDIFFUSE      |
                            D3DPV_DONOTCOPYSPECULAR     |
                            D3DPV_DONOTCOPYTEXTURE      |
                            D3DPV_POSITION_TWEENING     |
                            D3DPV_NORMAL_TWEENING       |
                            D3DPV_TRANSFORMONLY ;

// Bits for dwDeviceFlags
//
const DWORD D3DDEV_GUARDBAND     = 1 << 1;  // Use guard band clipping
const DWORD D3DDEV_RANGEBASEDFOG = 1 << 2;  // Set if range based fog is enabled
// This bit is set if fog mode is not FOG_NONE and fog is enabled
const DWORD D3DDEV_FOG           = 1 << 3;
// Set when there is no need to compute clip codes, because there are already
// computed
const DWORD D3DDEV_DONOTCOMPUTECLIPCODES = 1 << 4;
// Set when stream source or a shader have been changed
// PSGP should clear the bit
const DWORD D3DDEV_SHADERDIRTY   = 1 << 5;
// Copy of D3DFVFCAPS_DONOTSTRIPELEMENTS
const DWORD D3DDEV_DONOTSTRIPELEMENTS = 1 << 6;
// Vertex shaders are used. If this bit is not set, fixed function pipeline is
// used
const DWORD D3DDEV_VERTEXSHADERS = 1 << 7;
// Set, when a vertex buffer, which was a destination for ProcessVerticess,
// is used as a stream source
const DWORD D3DDEV_VBPROCVER      = 1 << 8;
// Set when we need to do emulation of point sprites (Microsoft specific)
const D3DDEV_DOPOINTSPRITEEMULATION =   1 << 9;
// These are bits in dwDeviceFlags that could be changed, but not
// necessary per every primitive.
//
// Set when D3DRS_SHADEMODE is D3DSHADE_FLAT
const DWORD D3DDEV_FLATSHADEMODE        = 1 << 10;
// Set when D3DRS_SPECULARENABLE is TRUE
const DWORD D3DDEV_SPECULARENABLE       = 1 << 11;
// Set when transformed vertices are passed to the front-end
const DWORD D3DDEV_TRANSFORMEDFVF       = 1 << 12;
// Set when D3DRS_INDEXEDVERTEXBLENDENABLE is true
const DWORD D3DDEV_INDEXEDVERTEXBLENDENABLE = 1 << 13;
// This flag is for PSGP only. PSGP implementation should clear the flag
const DWORD D3DDEV_FRUSTUMPLANES_DIRTY  = 1 << 14;
// This flag is for PSGP only. PSGP implementation should clear the flag
// Need to re-evaluate texture transforms
const DWORD D3DDEV_TEXTRANSFORMDIRTY    = 1 << 15;
// The flag is set when the number of output texture coord is greater then the
// number of the input ones. This could happen when the same texture transform
// matrix is used with the same input texture coord set. In this case we save
// texture indices from the texture stages in the textureStages and map all
// indices sequentially.
const DWORD D3DDEV_REMAPTEXTUREINDICES  = 1 << 16;

// These two flags are for PSGP only. PSGP implementation should clear the flags
// Transform matrix has been changed
const DWORD D3DDEV_TRANSFORMDIRTY       = 1 << 17;
 // Lights have been changed
const DWORD D3DDEV_LIGHTSDIRTY          = 1 << 18;

 // Clipping is disabled
const DWORD D3DDEV_DONOTCLIP            = 1 << 19;
// World-view matrix does not have scale, so we can do lighting
// in the model space
const DWORD D3DDEV_MODELSPACELIGHTING   = 1 << 23;
// Set if viewer is local (used for lighting)
const DWORD D3DDEV_LOCALVIEWER          = 1 << 24;
// Set if we wave to normalize normals after transforming them to the
// camera space
const DWORD D3DDEV_NORMALIZENORMALS     = 1 << 25;
// Set if we wave to do texture transform
const DWORD D3DDEV_TEXTURETRANSFORM     = 1 << 26;
// Set if the last draw primitive call was strided
const DWORD D3DDEV_STRIDE               = 1 << 27;
// Set if D3DRS_COLORVERTEX is TRUE
const DWORD D3DDEV_COLORVERTEX          = 1 << 28;
// Set if position in camera space is always needed
const DWORD D3DDEV_POSITIONINCAMERASPACE= 1 << 29;
// Set if normal in camera space is always needed
const DWORD D3DDEV_NORMALINCAMERASPACE  = 1 << 30;
// Set if D3DRS_LIGHTING is set
const DWORD D3DDEV_LIGHTING             = 1 << 31;
//-----------------------------------------------------------------------------
// Clipper defines
//

// Six standard clipping planes plus six user defined clipping planes.
// See rl\d3d\d3d\d3dtypes.h.
//

#define MAX_CLIPPING_PLANES 12

// Space for vertices generated/copied while clipping one triangle

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

const DWORD MAX_FVF_TEXCOORD = 8;

class ClipVertex
{
public:
    D3DVALUE    hx;     // Clipping space coordinates. Must be in this order
    D3DVALUE    hy;
    D3DVALUE    hz;
    D3DVALUE    hw;
    int         clip;
    D3DCOLOR    color;
    D3DCOLOR    specular;
    D3DVALUE    sx;     // Screen space coordinates. Must be in this order
    D3DVALUE    sy;
    D3DVALUE    sz;
    D3DVALUE    rhw;
    ClipVertex *next;
    D3DVALUE    tex[MAX_FVF_TEXCOORD*4];
};

typedef struct _ClipTriangle
{
    ClipVertex  *v[3];
} ClipTriangle;

typedef struct _D3DI_CLIPSTATE
{
    ClipVertex  *clip_vbuf1[MAX_CLIP_VERTICES];
    ClipVertex  *clip_vbuf2[MAX_CLIP_VERTICES];
    ClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    ClipVertex  clip_vertices[MAX_CLIP_VERTICES];
    BYTE       *clipBuf;      // Used for TL vertices, generated by the clipper
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
} D3DI_CLIPSTATE, *LPD3DI_CLIPSTATE;

// These bit are set when a vertex is clipped by a frustum plane

#define CLIPPED_LEFT    (D3DCS_PLANE5 << 1)
#define CLIPPED_RIGHT   (D3DCS_PLANE5 << 2)
#define CLIPPED_TOP     (D3DCS_PLANE5 << 3)
#define CLIPPED_BOTTOM  (D3DCS_PLANE5 << 4)
#define CLIPPED_FRONT   (D3DCS_PLANE5 << 5)
#define CLIPPED_BACK    (D3DCS_PLANE5 << 6)

#define CLIPPED_ENABLE  (D3DCS_PLANE5 << 7) /* wireframe enable flag */

// These bit are set when a vertex is clipped by a user clipping plane

const DWORD CLIPPED_PLANE0 = D3DCS_PLANE5 << 8;
const DWORD CLIPPED_PLANE1 = D3DCS_PLANE5 << 9;
const DWORD CLIPPED_PLANE2 = D3DCS_PLANE5 << 10;
const DWORD CLIPPED_PLANE3 = D3DCS_PLANE5 << 11;
const DWORD CLIPPED_PLANE4 = D3DCS_PLANE5 << 12;
const DWORD CLIPPED_PLANE5 = D3DCS_PLANE5 << 13;

// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     D3DCS_LEFT bit is set
// if x < -w*ax1           __D3DCLIPGB_LEFT bit is set
//
#define __D3DCLIPGB_LEFT    (D3DCS_PLANE5 << 1)
#define __D3DCLIPGB_RIGHT   (D3DCS_PLANE5 << 2)
#define __D3DCLIPGB_TOP     (D3DCS_PLANE5 << 3)
#define __D3DCLIPGB_BOTTOM  (D3DCS_PLANE5 << 4)
#define __D3DCLIPGB_ALL (__D3DCLIPGB_LEFT | __D3DCLIPGB_RIGHT | \
                         __D3DCLIPGB_TOP | __D3DCLIPGB_BOTTOM)

const DWORD __D3DCS_USERPLANES =  D3DCS_PLANE0 | D3DCS_PLANE1 |
                                    D3DCS_PLANE2 | D3DCS_PLANE3 |
                                    D3DCS_PLANE4 | D3DCS_PLANE5;
// If only these bits are set, then this point is inside the guard band
//
#define __D3DCS_INGUARDBAND (D3DCS_LEFT | D3DCS_RIGHT | \
                               D3DCS_TOP  | D3DCS_BOTTOM)

//---------------------------------------------------------------------
// Bits in the dwFlags2
//
// The bit is set when the texture transform is enabled
const DWORD __FLAGS2_TEXTRANSFORM0 = 1 << 0;
const DWORD __FLAGS2_TEXTRANSFORM1 = 1 << 1;
const DWORD __FLAGS2_TEXTRANSFORM2 = 1 << 2;
const DWORD __FLAGS2_TEXTRANSFORM3 = 1 << 3;
const DWORD __FLAGS2_TEXTRANSFORM4 = 1 << 4;
const DWORD __FLAGS2_TEXTRANSFORM5 = 1 << 5;
const DWORD __FLAGS2_TEXTRANSFORM6 = 1 << 6;
const DWORD __FLAGS2_TEXTRANSFORM7 = 1 << 7;

const DWORD __FLAGS2_TEXTRANSFORM = __FLAGS2_TEXTRANSFORM0 |
                                    __FLAGS2_TEXTRANSFORM1 |
                                    __FLAGS2_TEXTRANSFORM2 |
                                    __FLAGS2_TEXTRANSFORM3 |
                                    __FLAGS2_TEXTRANSFORM4 |
                                    __FLAGS2_TEXTRANSFORM5 |
                                    __FLAGS2_TEXTRANSFORM6 |
                                    __FLAGS2_TEXTRANSFORM7;
// The bit is set when texture projection is enabled for the stage and we need
// to do emulation, because device does not support projected textures.
const DWORD __FLAGS2_TEXPROJ0 = 1 << 8;
const DWORD __FLAGS2_TEXPROJ1 = 1 << 9;
const DWORD __FLAGS2_TEXPROJ2 = 1 << 10;
const DWORD __FLAGS2_TEXPROJ3 = 1 << 11;
const DWORD __FLAGS2_TEXPROJ4 = 1 << 12;
const DWORD __FLAGS2_TEXPROJ5 = 1 << 13;
const DWORD __FLAGS2_TEXPROJ6 = 1 << 14;
const DWORD __FLAGS2_TEXPROJ7 = 1 << 15;

const DWORD __FLAGS2_TEXPROJ = __FLAGS2_TEXPROJ0 |
                               __FLAGS2_TEXPROJ1 |
                               __FLAGS2_TEXPROJ2 |
                               __FLAGS2_TEXPROJ3 |
                               __FLAGS2_TEXPROJ4 |
                               __FLAGS2_TEXPROJ5 |
                               __FLAGS2_TEXPROJ6 |
                               __FLAGS2_TEXPROJ7;
// The bit is set when the texture coordinate set is taken from the vertex data
// (position or normal)
const DWORD __FLAGS2_TEXGEN0 = 1 << 16;
const DWORD __FLAGS2_TEXGEN1 = 1 << 17;
const DWORD __FLAGS2_TEXGEN2 = 1 << 18;
const DWORD __FLAGS2_TEXGEN3 = 1 << 19;
const DWORD __FLAGS2_TEXGEN4 = 1 << 20;
const DWORD __FLAGS2_TEXGEN5 = 1 << 21;
const DWORD __FLAGS2_TEXGEN6 = 1 << 22;
const DWORD __FLAGS2_TEXGEN7 = 1 << 23;

const DWORD __FLAGS2_TEXGEN = __FLAGS2_TEXGEN0 |
                              __FLAGS2_TEXGEN1 |
                              __FLAGS2_TEXGEN2 |
                              __FLAGS2_TEXGEN3 |
                              __FLAGS2_TEXGEN4 |
                              __FLAGS2_TEXGEN5 |
                              __FLAGS2_TEXGEN6 |
                              __FLAGS2_TEXGEN7;
//---------------------------------------------------------------------
#define __TEXTURETRANSFORMENABLED(pv) (pv->dwFlags2 & __FLAGS2_TEXTRANSFORM)

//---------------------------------------------------------------------
//
// CVElement: Describes a vertex element
//            Array of this type is passed to PSGP to create a vertex shader
//
//---------------------------------------------------------------------
class CVElement
{
public:
    DWORD   m_dwRegister;   // Input register index
    DWORD   m_dwDataType;   // Data type and dimension
    // -------- Private Microsoft Data ---------
    // Pointer to a function to convert input vertex element data type to
    // the VVM_WORD
    LPVOID  m_pfnCopy;
    // API stream index
    DWORD   m_dwStreamIndex;
    // Offset in the input stream in bytes
    DWORD   m_dwOffset;
};
//-----------------------------------------------------------------------------
// Data structure used to initialize vertex pointers
//
struct CVertexDesc
{
    // Element memory pointer. Used in vertex loop. Start vertex is used
    // to compute it
    LPVOID      pMemory;
    // Element stride in bytes
    DWORD       dwStride;
    //------------ Private Microsoft data -------------
    union
    {
        // Input vertex register index
        DWORD   dwRegister;
        // Used to initilize fixed-function pipeline vertex pointers
        D3DDP_PTRSTRIDE *pElement;
    };
    // Copies vertex element data to an input register
    LPVOID      pfnCopy;
    // Stream memory pointer
    CVStream*   pStream;
    // Offset of the element in the vertex in bytes
    DWORD       dwVertexOffset;
};
//-----------------------------------------------------------------------------
const DWORD __MAXWORLDMATRICES  = 256;
const DWORD __WORLDMATRIXBASE   = 256;
//-----------------------------------------------------------------------------
// Visible states, input and output data
//
class D3DFE_PROCESSVERTICES
{
public:
    D3DFE_PROCESSVERTICES();
    ~D3DFE_PROCESSVERTICES();

    // Returns current transformation matrix. Computes it if necessary
    inline D3DMATRIXI* GetMatrixCTM(UINT index)
        {
            D3DMATRIXI* m = &mCTM[index];
            if (CTMCount[index] < MatrixStateCount)
            {
                MatrixProduct(m, &world[index], &mVPC);
                CTMCount[index] = MatrixStateCount;
            }
            return m;
        }
    // Returns current matrix to transform to the camera space.
    // Computes it if necessary
    inline D3DMATRIXI* GetMatrixWV(UINT index)
        {
            D3DMATRIXI* m = &mWV[index];
            if (WVCount[index] < MatrixStateCount)
            {
                MatrixProduct(m, &world[index], &view);
                WVCount[index] = MatrixStateCount;
            }
            return m;
        }
    // Returns current matrix to transform normals to the camera space.
    // This is inverse view-world matrix.
    // Computes it if necessary
    inline D3DMATRIXI* GetMatrixWVI(UINT index)
        {
            D3DMATRIXI* m = &mWVI[index];
            if (WVICount[index] < MatrixStateCount)
            {
                D3DMATRIXI* world_view = GetMatrixWV(index);
                Inverse4x4((D3DMATRIX*)world_view, (D3DMATRIX*)m);
                WVICount[index] = MatrixStateCount;
            }
            return m;
        }
// State
    // Should be 16 byte aligned
    D3DMATRIXI view;                        // View matrix (Mview)
    D3DMATRIXI mVPC;                        // Mview * Mprojection * Mclip
    D3DMATRIXI mTexture[D3DDP_MAXTEXCOORD]; // Texture transform;
    D3DMATRIXI world[__MAXWORLDMATRICES];   // User set world matrices
    D3DMATRIXI mCTM[__MAXWORLDMATRICES];    // Matrices used for vertex blending
    D3DMATRIXI mWV[__MAXWORLDMATRICES];
    D3DMATRIXI mWVI[__MAXWORLDMATRICES];
    // Every time we need a matrix (CTM2, WV2, WVI2) we compare its count with
    // the MatrixStateCount and if it is less than it we compute the required
    // matrix.
    ULONGLONG CTMCount[__MAXWORLDMATRICES];
    ULONGLONG WVCount[__MAXWORLDMATRICES];
    ULONGLONG WVICount[__MAXWORLDMATRICES];
    // Every time world, view or projection matrix is changed, the
    // MatrixStateCount is incremented.
    ULONGLONG MatrixStateCount;
    // Current set of matrix indices used for the vertex blending.
    // If there are no matrix indices in vertices, it is set to (0,1,2,3)
    BYTE       MatrixIndices[4];
    // Weights in a vertex. There could be up to 3 weights in a vertex. The
    // last element is assigned as sum(1.0 - weights(i))
    float      VertexWeights[4];
    // Should be QWORD aligned
    D3DFE_LIGHTING lighting;        // Lighting state
    // Should be QWORD aligned
    D3DFE_VIEWPORTCACHE vcache;     // Data, computed fromto viewport settings
    DWORD    dwClipUnion;           // OR of all vertex clip flags
    DWORD    dwClipIntersection;    // AND of all vertex clip flags

    // Current texture stage vector
    LPVOID   *pD3DMappedTexI;
    D3DI_CLIPSTATE  ClipperState;   // State for triangle/line clipper
    // Cache line should start here
    D3DPRIMITIVETYPE primType;
    DWORD   dwNumVertices;  // Number of vertices to process
    DWORD   dwFlags;        // Flags word describing what to do
    // Location of the first vertex in the vertex buffer (DP2 DDI)
    // ATTENTION May be we can get rid of it?
    DWORD   dwNumIndices;           // 0 for non-indexed primitive
    LPWORD  lpwIndices;
    DWORD   dwNumPrimitives;

    // Cache line should start here
    DWORD   dwVIDIn;        // Vertex ID of input vertices
    DWORD   dwDeviceFlags;          // Flags that are constant per device
                                    // D3DPV_.. and primitive flags are combined
    DWORD   dwOutputSize;           // Output vertex size
    DWORD   dwVIDOut;               // Vertex ID of output vertices
    LPVOID  lpvOut;                 // Output pointer (output always packed)

    D3DFE_CLIPCODE* lpClipFlags;          // Clip flags to output
    DWORD   nTexCoord;      // Number of the input texture coordinate sets
    // Number of the output texture coordinate sets to process.
    // WARNING. It could be different from the texture count in dwVIDOut
    // (it could be zero for example when dwVIDOut has 1 texture coord set).
    // If D3DDEV_REMAPTEXTUREINDICES is set this is equal
    // to the number of active texture stages
    DWORD   nOutTexCoord;
    // Total size of all output texture coordinates in bytes
    DWORD   dwTextureCoordSizeTotal;
    union
    {
        struct
        {
            // Order of the fields is very important.
            // It is the same as the order of input registers in the virtual
            // vertex machine
            union
            {
                D3DDP_PTRSTRIDE position;   // dwStride should always be set !!!
                D3DDP_PTRSTRIDE SOA;
            };
            D3DDP_PTRSTRIDE weights;
            D3DDP_PTRSTRIDE matrixIndices;  // Blend matrix indices
            union
            {
                D3DDP_PTRSTRIDE normal;
                DWORD dwSOAStartVertex;
            };
            D3DDP_PTRSTRIDE psize;
            D3DDP_PTRSTRIDE diffuse;
            D3DDP_PTRSTRIDE specular;
            D3DDP_PTRSTRIDE textures[D3DDP_MAXTEXCOORD];
            D3DDP_PTRSTRIDE position2;
            D3DDP_PTRSTRIDE normal2;
        };
        D3DDP_PTRSTRIDE elements[__NUMELEMENTS];
    };
    // Used to offset indices during processing an indexed primitive
    DWORD   dwIndexOffset;
    // Size of output texture coordinate sets in bytes
    DWORD   dwTextureCoordSize[D3DDP_MAXTEXCOORD];
    // Size of input texture coordinate sets in bytes
    DWORD   dwInpTextureCoordSize[D3DDP_MAXTEXCOORD];
// Output
    LPDWORD  lpdwRStates;           // Current render state vector
    D3DFE_TEXTURESTAGE textureStage[D3DDP_MAXTEXCOORD]; // Texture state stages
    // Used when we have to re-map texture indices
    DWORD   dwNumTextureStages;
    // This array is used when we do not do re-mapping of texture coordinates
    D3DMATRIXI *pmTexture[D3DDP_MAXTEXCOORD];
    D3DVECTORH userClipPlane[__MAXUSERCLIPPLANES];
    // Low 8 bits are texture transform enable:
    // bit 0 corresponds to the texture stage 0
    // Bits 8-15 are used to detect if we need to do emulation of texture 
    // projection for the stage (when no stage re-mapping is needed).
    // Bits 16-23 are set if corresponding texture coord set
    // is taken from the vertex data (position or normal)
    DWORD   dwFlags2;
    // Blend factor used in vertex tweening
    float tweenFactor;
    // Number of matrices to apply for vertex blending. Number of weights in a
    // vertex is (dwNumVerBlends-1). The last weight is 1-sum(VertexWeight[i]).
    DWORD   dwNumVerBlends;
    // Number of weights in a vertex. It is dwNumVerBlends - 1
    DWORD   dwNumWeights;
    DWORD   dwMaxUserClipPlanes;
// Internal data for Microsoft implementation
    // Offsets in the input FVF vertex. Recomputed when FVF is changed.
    DWORD   texOffset;
    DWORD   normalOffset;
    DWORD   diffuseOffset;
    DWORD   specularOffset;
    DWORD   pointSizeOffset;
    // Offsets in the output FVF vertex. Recomputed when FVF is changed.
    DWORD   texOffsetOut;
    DWORD   diffuseOffsetOut;
    DWORD   specularOffsetOut;
    DWORD   pointSizeOffsetOut;
    DWORD   fogOffsetOut;
    // When and this mask with the clip code we have bits that are outside the
    // guard band
    DWORD   dwClipMaskOffScreen;

    // Clip vertices. Used in processing  and clipping in the one loop
    ClipVertex  clipVer[VER_IN_BATCH];
    // Index of the first vertex with non-zero clip code
    DWORD   dwFirstClippedVertex;
    DWORD   dwMaxTextureIndices;    // Max number of texture coord sets
    DWORD   dwIndexSize;            // Index size (2 or 4 bytes)
    CD3DDDI*  pDDI;                 // Copy from the device m_pDDI
    float   PointSizeMax;           // Current max point size
    ID3DFE_PVFUNCS* pGeometryFuncs; // Copy from the CD3DHal device

    //-------------- Vertex Shader data -----------------

    // Store information to initialize virtual machine registers
    // The elements of this array match the elements of pElements array, passed
    // with CreateShader call.
    CVertexDesc VertexDesc[__NUMSTREAMS];
    // How many VertexDescs are used
    // It is equal to the number of vertex elements (dwNumElements), in the
    // current active shader. dwNumElements is passed during CreateShader calls
    DWORD   dwNumUsedVertexDescs;

#if DBG
    RTDebugMonitor* pDbgMon;        // Copy from the device m_pDbgMon
#endif
};
//-----------------------------------------------------------------------------
// Prototype for the function to be written for a given processor implementation
//
class ID3DFE_PVFUNCS
{
public:
    virtual ~ID3DFE_PVFUNCS() {};
    virtual DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT OptimizeVertexBuffer
        (DWORD  dwFVFID,            // Vertex type. XYZ position is allowed
         DWORD  dwNumVertices,      // Number of vertices
         DWORD  dwVertexSize,       // Vertex size in bytes
         LPVOID lpSrcBuffer,        // Source buffer.
         LPVOID lpDstBuffer,        // Output buffer.
         DWORD  dwFlags)            // Should be zero for now
        {return E_NOTIMPL;}
    // Returns number of bytes to allocate for an optimized vertex buffer
    // This function is called before OptimizeVertexBuffer
    virtual DWORD  ComputeOptimizedVertexBufferSize
        (DWORD dwFVF,               // Vertex type
         DWORD dwVertexSize,        // Vertex size in bytes
         DWORD dwNumVertices)       // Number of vertices
        {return 0;}
    // This function could be used if PSGP doesn't want to implement complete
    // clipping pipeline
    // Parameters:
    //      pv  - state data
    //      tri - triangle to clip
    //      clipVertexPointer - pointer to an array of pointers to
    //                          generated vertices
    // Returns:
    //      Number of vertices in clipped triangle
    //      0, if the triangle is off screen
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer) = 0;
    virtual HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES)=0;
    // Create a vertex shader
    //
    // D3D run-time:
    //  - parses shader declaration and shader code and does all validation
    //  - computes output FVF for non-fixed pipeline
    //  - creates a shader handle
    //  - calls ID3DFE_PVFUNCS::CreateShader()
    // PSGP:
    //  - compiles shader code using the vertex element descriptions
    //
    // For fixed function pipeline pdwShaderCode is NULL, dwOutputFVF should be
    // ignored (dwVIDOut should be used in Draw calls).
    //
    virtual HRESULT CreateShader(
        // Describes input vertex elements and mapping them to vertex registers
        CVElement*   pElements,
        // Number of elements
        DWORD       dwNumElements,
        // Binary shader code (NULL for fixed function pipeline)
        DWORD*      pdwShaderCode,
        // Describes output vertex format. Ignored by fixed function pipeline
        DWORD       dwOutputFVF,
        // PSGP-created shader object. D3D does not have access to it.
        CPSGPShader** ppPSGPShader
        ) = 0;

    virtual HRESULT SetActiveShader(CPSGPShader *pPSGPShader) = 0;

    // Load vertex shader constants
    virtual HRESULT LoadShaderConstants(
        DWORD start,        // Constant register address
        DWORD count,        // Number of 4-float vectors to load
        LPVOID buffer) = 0; // Memory to load from
    // This function is called when output vertex format is changed, but the
    // active shader remains the same. It is guaranteed that the new FVF is
    // a superset of the FVF, passed to CreateShader. PSGP implementation
    // could re-compute output vertex offsets or it could use updated
    // output offsets and dwOutputSize from PROCESSVERTICES structure.
    virtual HRESULT SetOutputFVF(DWORD dwFVF) = 0;
    virtual HRESULT GetShaderConstants(
        DWORD start,        // Constant register address
        DWORD count,        // Number of 4-float vectors to load
        LPVOID buffer) = 0;
};

typedef ID3DFE_PVFUNCS *LPD3DFE_PVFUNCS;
//-----------------------------------------------------------------------------
// GeometrySetup function takes a DWORD describing the dirty bits and the new
// state vector and passes back the 3 new leaf routines to use.
//
typedef HRESULT (D3DAPI *LPD3DFE_CONTEXTCREATE)(
         // dwDeviceFlags are passed
         DWORD dwFlags,
         // A pointer to the Microsoft object is passed to call when there is no
         // PSGP implementation available. PSGP returns its object hear.
         LPD3DFE_PVFUNCS *ppMicrosoftFuncs
         );
//-----------------------------------------------------------------------------
// Global pointer to Processor specific PV setup routine
// This is defined in dlld3d.cpp
extern LPD3DFE_CONTEXTCREATE pfnFEContextCreate;

//-----------------------------------------------------------------------------
// Check if we need to do emulation of texture projection for the stage
//
inline BOOL NeedTextureProjection(D3DFE_PROCESSVERTICES* pv, UINT stage) 
{
    return pv->dwFlags2 & (__FLAGS2_TEXPROJ0 << stage);
}

#endif // _D3DFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\d3d8ddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       D3D8ddi.h
 *  Content:    Defines the interface between DirectDraw / Direct3D and the
 *      OS specific layer (win32k.sys on NT and ddraw.dll on Win9X).
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   04-nov-99  smac    initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __D3D8DDI_INCLUDED__
#define __D3D8DDI_INCLUDED__


/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#define PULONG_PTR   LPDWORD
#endif //MAXULONG_PTR


// Caps:

// Note this struct is identical in content to D3DHAL_GLOBALDRIVERDATA.
// The only thing that has changed is the name of the texture list, reflecting
// the fact that this struct holds a list of DX8-style pixel format operations.
typedef struct _D3DD8_GLOBALDRIVERDATA {
    DWORD                       dwSize;                 // Size of this structure
    D3DDEVICEDESC_V1            hwCaps;                 // Capabilities of the hardware
    DWORD                       dwNumVertices;          // see following comment
    DWORD                       dwNumClipVertices;      // see following comment
    DWORD                       GDD8NumSupportedFormatOps;
    DDSURFACEDESC              *pGDD8SupportedFormatOps;
} D3D8_GLOBALDRIVERDATA;

typedef struct _D3D8_DRIVERCAPS
{
    D3DCAPS8                    D3DCaps;
    DWORD                       DisplayWidth;           // Current display width
    DWORD                       DisplayHeight;          // Current display height
    D3DFORMAT                   DisplayFormatWithoutAlpha;     // Current display format
    D3DFORMAT                   DisplayFormatWithAlpha;     // Current display format
    DWORD                       DisplayFrequency;       // Current refresh rate
    DWORD                       NLVCaps;                // AGP->Video blt caps
    DWORD                       SVBCaps;                // Sys->Video blt caps
    DWORD                       VSBCaps;                // Video->Sys blt caps
    DWORD                       SVBCaps2;               // More Sys->Video blt caps
    DWORD                       dwFlags;
    DWORD                       GDD8NumSupportedFormatOps;
    DDSURFACEDESC              *pGDD8SupportedFormatOps;
    DWORD                       KnownDriverFlags;
} D3D8_DRIVERCAPS, * PD3D8_DRIVERCAPS;

// Flags
#define DDIFLAG_D3DCAPS8                    0x00000001

// Known driver flags
#define KNOWN_LIGHTWEIGHT                   0x00000001      // Device can support lightweight surfaces
#define KNOWN_HWCURSOR                      0x00000002      // Device can support hardware cursors in Hi-Res
#define KNOWN_MIPPEDCUBEMAPS                0x00000004      // Device can support mipped cubemaps
#define KNOWN_ZSTENCILDEPTH                 0x00000010      // Device cannot support Z/Stencil depths different than the render target
#define KNOWN_HWCURSORLOWRES                0x00000020      // Device can support hardware cursors in LowRes
#define KNOWN_NOTAWINDOWEDBLTQUEUER         0x00000040      // Device has no drivers known to over-queue windowed presentation blts
#define KNOWN_D16_LOCKABLE                  0x00000080      // Device supports lockable D16 format correctly
#define KNOWN_RTTEXTURE_R5G6B5              0x00000100      // RT+Tex formats that are supported
#define KNOWN_RTTEXTURE_X8R8G8B8            0x00000200
#define KNOWN_RTTEXTURE_A8R8G8B8            0x00000400
#define KNOWN_RTTEXTURE_A1R5G5B5            0x00000800
#define KNOWN_RTTEXTURE_A4R4G4B4            0x00001000
#define KNOWN_RTTEXTURE_X1R5G5B5            0x00002000     
#define KNOWN_CANMISMATCHRT                 0x00004000      // All given RT+Tex formats can be used regardless of current display depth.
                                                            //  (If this bit is not set, then any known RT+Tex formats must match bitdepth of display)


/****************************************************************************
 *
 * D3D8 structures for Surface Object callbacks
 *
 ***************************************************************************/

typedef struct _D3D8_BLTDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hDestSurface;// dest surface
    RECTL                       rDest;      // dest rect
    HANDLE                      hSrcSurface; // src surface
    RECTL                       rSrc;       // src rect
    DWORD                       dwFlags;    // blt flags
    DWORD                       dwROPFlags; // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;      // blt FX
    union
    {
    BOOL                        IsClipped;  // clipped blt?
    HWND                        hWnd;       // Window Handle to clip against
    };
    RECTL                       rOrigDest;  // unclipped dest rect
                                            // (only valid if IsClipped)
    RECTL                       rOrigSrc;   // unclipped src rect
                                            // (only valid if IsClipped)
    DWORD                       dwRectCnt;  // count of dest rects
                                            // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects
    DWORD                       dwAFlags;   // DDABLT_ flags (for AlphaBlt DDI)
    DDARGB                      ddargbScaleFactors;  // RGBA scaling factors (AlphaBlt)

    DWORD                       msLastPresent;      // Time of last blt with DDBLT_COPYVSYNC
    DWORD                       threshold;  // Display Frequency related for adapter need
                                            // for DDBLT_COPYVSYNC

    HRESULT                     ddRVal;     // return value
} D3D8_BLTDATA, * PD3D8_BLTDATA;

typedef struct _D3D8_LOCKDATA
{
    HANDLE                      hDD;        // driver struct
    HANDLE                      hSurface;   // surface struct
    DWORD                       bHasRange;  // range is valid
    D3DRANGE                    range;      // range for locking
    DWORD                       bHasRect;   // rArea is valid
    RECTL                       rArea;      // area being locked
    DWORD                       bHasBox;    // box is valid
    D3DBOX                      box;        // sub-box locking for volumes
    LPVOID                      lpSurfData; // pointer to screen memory (return value)
    long                        lPitch;     // row pitch
    long                        lSlicePitch;// slice pitch for volumes
    DWORD                       dwFlags;    // DDLOCK flags
} D3D8_LOCKDATA, * PD3D8_LOCKDATA;

typedef struct _D3D8_UNLOCKDATA
{
    HANDLE                      hDD;        // driver struct
    HANDLE                      hSurface;   // surface struct
} D3D8_UNLOCKDATA, * PD3D8_UNLOCKDATA;

typedef struct _D3D8_FLIPDATA
{
    HANDLE                      hDD;        // driver struct
    HANDLE                      hSurfCurr;  // current surface
    HANDLE                      hSurfTarg;  // target surface (to flip to)
    HANDLE                      hSurfCurrLeft; // current surface
    HANDLE                      hSurfTargLeft; // target surface (to flip to)
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
} D3D8_FLIPDATA, * PD3D8_FLIPDATA;

typedef struct _D3D8_DESTROYSURFACEDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hSurface;    // surface struct
    HRESULT                     ddRVal;     // return value
} D3D8_DESTROYSURFACEDATA, * PD3D8_DESTROYSURFACEDATA;

typedef struct _D3D8_ADDATTACHEDSURFACEDATA
{
    HANDLE                          hDD;       // driver struct
    HANDLE                          hSurface;    // surface struct
    HANDLE                          hSurfAttached; // surface to attach
    HRESULT                         ddRVal;     // return value
} D3D8_ADDATTACHEDSURFACEDATA, * PD3D8_ADDATTACHEDSURFACEDATA;

typedef struct _D3D8_GETBLTSTATUSDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
} D3D8_GETBLTSTATUSDATA, * PD3D8_GETBLTSTATUSDATA;

typedef struct _D3D8_GETFLIPSTATUSDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
} D3D8_GETFLIPSTATUSDATA, * PD3D8_GETFLIPSTATUSDATA;

typedef struct _DDSURFACEINFO
{
    DWORD               cpWidth;        // For linear, surface and volume
    DWORD               cpHeight;       // For surface and volume
    DWORD               cpDepth;        // For volumes
    BYTE               *pbPixels;       // Pointer to Memory for sys-mem surface
    LONG                iPitch;         // Row Pitch for sys-mem surface
    LONG                iSlicePitch;    // Slice Pitch for sys-mem volume
    HANDLE              hKernelHandle;  // Handle returned by the kernel
} DDSURFACEINFO, *LPDDSURFACEINFO;

typedef struct _D3D8_CREATESURFACEDATA
{
    HANDLE                      hDD;        // driver struct
    LPDDSURFACEINFO             pSList;     // list of created surface objects
    DWORD                       dwSCnt;     // number of surfaces in SList
    D3DRESOURCETYPE             Type;       // Type: MipMap, CubeMap, MipVolume, VertexBuffer, IndexBuffer, CommandBuffer
    DWORD                       dwUsage;    // Usage: Texture or RenderTarget
    D3DPOOL                     Pool;       // SysMem/VidMem/NonLocal
    D3DFORMAT                   Format;     // Format
    D3DMULTISAMPLE_TYPE         MultiSampleType;
    DWORD                       dwFVF;      // FVF format for vertex buffers
    BOOL                        bTreatAsVidMem; // Set if Sys-Mem object was created with POOL_DEFAULT by user.
    BOOL                        bReUse;     // Set if are trying to create driver managed surfaces marked deferred
} D3D8_CREATESURFACEDATA, * PD3D8_CREATESURFACEDATA;

#define DDWAITVB_I_TESTVB           0x80000006l

typedef struct _D3D8_WAITFORVERTICALBLANKDATA
{
    HANDLE                      hDD;       // driver struct
    DWORD                       dwFlags;    // flags
    DWORD                       bIsInVB;    // is in vertical blank
    HRESULT                     ddRVal;     // return value
} D3D8_WAITFORVERTICALBLANKDATA, * PD3D8_WAITFORVERTICALBLANKDATA;

typedef struct _D3D8_SETMODEDATA
{
    HANDLE                      hDD;       // driver struct
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    D3DFORMAT                   Format;
    DWORD                       dwRefreshRate;
    BOOL                        bRestore;
    HRESULT                     ddRVal;     // return value
} D3D8_SETMODEDATA, * PD3D8_SETMODEDATA;

typedef struct _D3D8_GETSCANLINEDATA
{
    HANDLE                      hDD;       // driver struct
    DWORD                       dwScanLine; // returned scan line
    BOOL                        bInVerticalBlank;
    HRESULT                     ddRVal;     // return value
} D3D8_GETSCANLINEDATA, * PD3D8_GETSCANLINEDATA;

typedef struct _D3D8_SETEXCLUSIVEMODEDATA
{
    HANDLE                      hDD;             // driver struct
    DWORD                       dwEnterExcl;      // TRUE if entering exclusive mode, FALSE is leaving
    HRESULT                     ddRVal;           // return value
} D3D8_SETEXCLUSIVEMODEDATA, * PD3D8_SETEXCLUSIVEMODEDATA;

typedef struct _D3D8_FLIPTOGDISURFACEDATA
{
    HANDLE                      hDD;         // driver struct
    DWORD                       dwToGDI;          // TRUE if flipping to the GDI surface, FALSE if flipping away
    HRESULT                     ddRVal;       // return value
} D3D8_FLIPTOGDISURFACEDATA, * PD3D8_FLIPTOGDISURFACEDATA;

typedef struct _D3D8_SETCOLORKEYDATA
{
    HANDLE                      hDD;
    HANDLE                      hSurface;
    DWORD                       ColorValue;
    HRESULT                     ddRVal;
} D3D8_SETCOLORKEYDATA, * PD3D8_SETCOLORKEYDATA;

typedef struct _D3D8_GETAVAILDRIVERMEMORYDATA
{
    HANDLE                  hDD;        // driver struct
    D3DPOOL                Pool;       // Pool they are interested in
    DWORD                   dwUsage;    // What the pool is used for
    DWORD                   dwFree;      // free memory for this kind of surface
    HRESULT                 ddRVal;      // return value
} D3D8_GETAVAILDRIVERMEMORYDATA, * PD3D8_GETAVAILDRIVERMEMORYDATA;

typedef struct _D3D8_GETDRIVERSTATEDATA
{
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    ULONG_PTR                   dwhContext;     // d3d context
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} D3D8_GETDRIVERSTATEDATA, * PD3D8_GETDRIVERSTATEDATA;

typedef struct _D3D8_DESTROYDDLOCALDATA
{
    DWORD                       dwFlags;
    HANDLE                      hDD;
    HRESULT                     ddRVal;
} D3D8_DESTROYDDLOCALDATA, * PD3D8_DESTROYDDLOCALDATA;

typedef struct _D3D8_CONTEXTCREATEDATA
{
    HANDLE                      hDD;        // in:  Driver struct
    HANDLE                      hSurface;   // in:  Surface to be used as target
    HANDLE                      hDDSZ;      // in:  Surface to be used as Z
    DWORD                       dwPID;      // in:  Current process id
    ULONG_PTR                   dwhContext; // in/out: Context handle
    HRESULT                     ddrval;

    // Private buffer information. To make it similar to
    // D3DNTHAL_CONTEXTCREATEI
    PVOID pvBuffer;
    ULONG cjBuffer;
} D3D8_CONTEXTCREATEDATA, * PD3D8_CONTEXTCREATEDATA;

typedef struct _D3D8_CONTEXTDESTROYDATA
{
    ULONG_PTR                   dwhContext; // in:  Context handle
    HRESULT                     ddrval;     // out: Return value
} D3D8_CONTEXTDESTROYDATA, * PD3D8_CONTEXTDESTROYDATA;

typedef struct _D3D8_CONTEXTDESTROYALLDATA
{
    DWORD                       dwPID;      // in:  Process id to destroy contexts for
    HRESULT                     ddrval;     // out: Return value
} D3D8_CONTEXTDESTROYALLDATA, * PD3D8_CONTEXTDESTROYALLDATA;

typedef struct _D3D8_RENDERSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find states in buffer
    DWORD       dwCount;    // in:  How many states to process
    HANDLE      hExeBuf;    // in:  Execute buffer containing data
    HRESULT     ddrval;     // out: Return value
} D3D8_RENDERSTATEDATA, *PD3D8_RENDERSTATEDATA;

typedef struct _D3D8_RENDERPRIMITIVEDATA
{
    ULONG_PTR   dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find primitive data in buffer
    DWORD       dwStatus;   // in/out: Condition branch status
    HANDLE      hExeBuf;    // in:  Execute buffer containing data
    DWORD       dwTLOffset; // in:  Byte offset in lpTLBuf for start of vertex data
    HANDLE      hTLBuf;     // in:  Execute buffer containing TLVertex data
    D3DINSTRUCTION  diInstruction;  // in:  Primitive instruction
    HRESULT     ddrval;     // out: Return value
} D3D8_RENDERPRIMITIVEDATA, *PD3D8_RENDERPRIMITIVEDATA;

typedef struct _D3D8_DRAWPRIMITIVES2DATA
{
    ULONG_PTR  dwhContext;           // in: Context handle
    DWORD      dwFlags;              // in: flags
    DWORD      dwVertexType;         // in: vertex type
    HANDLE     hDDCommands;          // in: vertex buffer command data
    DWORD      dwCommandOffset;      // in: offset to start of vertex buffer commands
    DWORD      dwCommandLength;      // in: number of bytes of command data
    union
    { // based on D3DHALDP2_USERMEMVERTICES flag
       HANDLE  hDDVertex;            // in: surface containing vertex data
       LPVOID  lpVertices;           // in: User mode pointer to vertices
    };
    DWORD      dwVertexOffset;       // in: offset to start of vertex data
    DWORD      dwVertexLength;       // in: number of vertices of vertex data
    DWORD      dwReqVertexBufSize;   // in: number of bytes required for the next vertex buffer
    DWORD      dwReqCommandBufSize;  // in: number of bytes required for the next commnand buffer
    LPDWORD    lpdwRStates;          // in: Pointer to the array where render states are updated
    union
    {
       DWORD   dwVertexSize;         // in: Size of each vertex in bytes
       HRESULT ddrval;               // out: return value
    };
    DWORD      dwErrorOffset;        // out: offset in lpDDCommands to first D3DHAL_COMMAND not handled

    // Private data for the thunk
    ULONG_PTR  fpVidMem_CB;          // out: fpVidMem for the command buffer
    DWORD      dwLinearSize_CB;      // out: dwLinearSize for the command buffer

    ULONG_PTR  fpVidMem_VB;          // out: fpVidMem for the vertex buffer
    DWORD      dwLinearSize_VB;      // out: dwLinearSize for the vertex buffer
} D3D8_DRAWPRIMITIVES2DATA, *PD3D8_DRAWPRIMITIVES2DATA;

typedef struct _D3D8_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR                   dwhContext;     // in:  Context handle
    DWORD                       dwFlags;        // in:  Flags, currently set to 0
    ULONG_PTR                   dwReserved;     //
    DWORD                       dwNumPasses;    // out: Number of passes the hardware
                                                //      can perform the operation in
    HRESULT                     ddrval;         // out: return value
} D3D8_VALIDATETEXTURESTAGESTATEDATA, * PD3D8_VALIDATETEXTURESTAGESTATEDATA;

typedef struct _D3D8_SCENECAPTUREDATA
{
    ULONG_PTR                   dwhContext; // in:  Context handle
    DWORD                       dwFlag;     // in:  Indicates beginning or end
    HRESULT                     ddrval;     // out: Return value
} D3D8_SCENECAPTUREDATA, * PD3D8_SCENECAPTUREDATA;

typedef struct _D3D8_CLEAR2DATA
{
    ULONG_PTR                   dwhContext;     // in:  Context handle

  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD                       dwFlags;        // in:  surfaces to clear

    DWORD                       dwFillColor;    // in:  Color value for rtarget
    D3DVALUE                    dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD                       dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT                   lpRects;        // in:  Rectangles to clear
    DWORD                       dwNumRects;     // in:  Number of rectangles

    HRESULT                     ddrval;         // out: Return value

    // This is extra stuff passed down to the thunk layer for emulation
    // of Clear for those drivers (DX6) that cant do it themselves.
    HANDLE                  hDDS;       // in:  render target
    HANDLE                  hDDSZ;      // in:  Z buffer
} D3D8_CLEAR2DATA, * PD3D8_CLEAR2DATA;


typedef struct _D3D8_CLEARDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3D8_CLEARDATA, * PD3D8_CLEARDATA;

typedef struct _D3D8_SETRENDERTARGETDATA
{
    ULONG_PTR               dwhContext; // in:  Context handle
    HANDLE                  hDDS;       // in:  new render target
    HANDLE                  hDDSZ;      // in:  new Z buffer
    HRESULT                 ddrval;     // out: Return value
    BOOL                    bNeedUpdate;// out: Does runtime need to update
                                        //      driver state.
} D3D8_SETRENDERTARGETDATA, * PD3D8_SETRENDERTARGETDATA;

typedef struct _D3D8_SETPALETTEDATA
{
    HANDLE                  hDD;        // in:  Driver struct
    HANDLE                  hSurface;   // in:  Surface to be used as target
    DWORD                   Palette;    // in:  Palette identifier
    HRESULT                 ddRVal;     // out: Return value
} D3D8_SETPALETTEDATA, * PD3D8_SETPALETTEDATA;

typedef struct _D3D8_UPDATEPALETTEDATA
{
    HANDLE                  hDD;        // in:  Driver struct
    DWORD                   Palette;    // in:  Palette identifier
    LPPALETTEENTRY          ColorTable; // in:  256 entry color table
    HRESULT                 ddRVal;     // out: Return value
} D3D8_UPDATEPALETTEDATA, * PD3D8_UPDATEPALETTEDATA;

//
// Driver callback table
//

DEFINE_GUID( GUID_D3D8Callbacks,    0xb497a1f3, 0x46cc, 0x4fc7, 0xb4, 0xf2, 0x32, 0xd8, 0x9e, 0xf9, 0xcc, 0x27);

typedef HRESULT     (FAR PASCAL *PD3D8DDI_CREATESURFACE)(PD3D8_CREATESURFACEDATA);
typedef HRESULT     (FAR PASCAL *PD3D8DDI_DESTROYSURFACE)(PD3D8_DESTROYSURFACEDATA);
typedef HRESULT     (FAR PASCAL *PD3D8DDI_LOCK)(PD3D8_LOCKDATA);
typedef HRESULT     (FAR PASCAL *PD3D8DDI_UNLOCK)(PD3D8_UNLOCKDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CONTEXTCREATE)(PD3D8_CONTEXTCREATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CONTEXTDESTROY)(PD3D8_CONTEXTDESTROYDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CONTEXTDESTROYALL)(PD3D8_CONTEXTDESTROYALLDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_RENDERSTATE) (PD3D8_RENDERSTATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_RENDERPRIMITIVE) (PD3D8_RENDERPRIMITIVEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_DRAWPRIM2)(PD3D8_DRAWPRIMITIVES2DATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETDRIVERSTATE)(PD3D8_GETDRIVERSTATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_VALIDATETEXTURESTAGESTATE)(PD3D8_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SCENECAPTURE)(PD3D8_SCENECAPTUREDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CLEAR2)(PD3D8_CLEAR2DATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_BLT)(PD3D8_BLTDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETSCANLINE)(PD3D8_GETSCANLINEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_WAITFORVERTICALBLANK)(PD3D8_WAITFORVERTICALBLANKDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_FLIP)(PD3D8_FLIPDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETBLTSTATUS)(PD3D8_GETBLTSTATUSDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETFLIPSTATUS)(PD3D8_GETFLIPSTATUSDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETAVAILDRIVERMEMORY)(PD3D8_GETAVAILDRIVERMEMORYDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETMODE)(PD3D8_SETMODEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_FLIPTOGDISURFACE)(PD3D8_FLIPTOGDISURFACEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETCOLORKEY)(PD3D8_SETCOLORKEYDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETEXCLUSIVEMODE)(PD3D8_SETEXCLUSIVEMODEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_DESTROYDDLOCAL)(PD3D8_DESTROYDDLOCALDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETRENDERTARGET)(PD3D8_SETRENDERTARGETDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CLEAR)(PD3D8_CLEARDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETPALETTE)(PD3D8_SETPALETTEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_UPDATEPALETTE)(PD3D8_UPDATEPALETTEDATA);

typedef struct _D3D8_CALLBACKS
{
    PD3D8DDI_CREATESURFACE                  CreateSurface;
    PD3D8DDI_DESTROYSURFACE                 DestroySurface;
    PD3D8DDI_LOCK                           Lock;
    PD3D8DDI_UNLOCK                         Unlock;
    PD3D8DDI_CONTEXTCREATE                  CreateContext;
    PD3D8DDI_CONTEXTDESTROY                 ContextDestroy;
    PD3D8DDI_CONTEXTDESTROYALL              ContextDestroyAll;
    PD3D8DDI_RENDERSTATE                    RenderState;
    PD3D8DDI_RENDERPRIMITIVE                RenderPrimitive;
    PD3D8DDI_DRAWPRIM2                      DrawPrimitives2;
    PD3D8DDI_GETDRIVERSTATE                 GetDriverState;
    PD3D8DDI_VALIDATETEXTURESTAGESTATE      ValidateTextureStageState;
    PD3D8DDI_SCENECAPTURE                   SceneCapture;
    PD3D8DDI_CLEAR2                         Clear2;
    PD3D8DDI_BLT                            Blt;
    PD3D8DDI_GETSCANLINE                    GetScanLine;
    PD3D8DDI_WAITFORVERTICALBLANK           WaitForVerticalBlank;
    PD3D8DDI_FLIP                           Flip;
    PD3D8DDI_GETBLTSTATUS                   GetBltStatus;
    PD3D8DDI_GETFLIPSTATUS                  GetFlipStatus;
    PD3D8DDI_GETAVAILDRIVERMEMORY           GetAvailDriverMemory;
    PD3D8DDI_GETBLTSTATUS                   GetSysmemBltStatus;
    PD3D8DDI_SETMODE                        SetMode;
    PD3D8DDI_SETEXCLUSIVEMODE               SetExclusiveMode;
    PD3D8DDI_FLIPTOGDISURFACE               FlipToGDISurface;
    PD3D8DDI_SETCOLORKEY                    SetColorkey;

    PD3D8DDI_DESTROYDDLOCAL                 DestroyDDLocal;
    PD3D8DDI_SETRENDERTARGET                SetRenderTarget;
    PD3D8DDI_CLEAR                          Clear;
    PD3D8DDI_SETPALETTE                     SetPalette;
    PD3D8DDI_UPDATEPALETTE                  UpdatePalette;
    LPVOID                                  Reserved1; // For device alignment
    LPVOID                                  Reserved2; // For device alignment
} D3D8_CALLBACKS, * PD3D8_CALLBACKS;


//
// D3D8xxx function prototypes to replace the NT Ddxxxx prototypes from GDI32.
// On NT, these are internal functions, but on Win9X DDRAW.DLL must export
// them, so we will change the export names
//

#ifdef WIN95
#define D3D8CreateDirectDrawObject          DdEntry1
#define D3D8QueryDirectDrawObject           DdEntry2
#define D3D8DeleteDirectDrawObject          DdEntry3
#define D3D8GetDC                           DdEntry4
#define D3D8ReleaseDC                       DdEntry5
#define D3D8ReenableDirectDrawObject        DdEntry6
#define D3D8SetGammaRamp                    DdEntry7
#define D3D8BuildModeTable                  DdEntry8
#define D3D8IsDeviceLost                    DdEntry9
#define D3D8CanRestoreNow                   DdEntry10
#define D3D8RestoreDevice                   DdEntry11
#define D3D8DoVidmemSurfacesExist           DdEntry12
#define D3D8SetMode                         DdEntry13
#define D3D8BeginProfile                    DdEntry14
#define D3D8EndProfile                      DdEntry15
#define D3D8GetMode                         DdEntry16
#define D3D8SetCooperativeLevel             DdEntry17
#define D3D8IsDummySurface                  DdEntry18
#define D3D8LoseDevice                      DdEntry19
#define D3D8GetHALName                      DdEntry20

#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN95

VOID APIENTRY D3D8CreateDirectDrawObject(
    LPGUID          pGuid,
    char*           szDeviceName,
    HANDLE*         phDD,
    D3DDEVTYPE      Type,
    HINSTANCE*      phLibrary,
    VOID*           pInitFunction
    );

#else

VOID APIENTRY D3D8CreateDirectDrawObject(
    HDC             hdc,
    char*           szDeviceName,
    HANDLE*         phDD,
    D3DDEVTYPE      Type,
    HINSTANCE*      phLibrary,
    VOID*           pInitFunction
    );

#endif

BOOL APIENTRY D3D8QueryDirectDrawObject(
    HANDLE                      hDD,
    PD3D8_DRIVERCAPS            DriverCaps,
    PD3D8_CALLBACKS             Callbacks,
    char*                       DeviceName,
    HINSTANCE                   hLibrary,
    D3D8_GLOBALDRIVERDATA*      pGblDriverData,
    D3DHAL_D3DEXTENDEDCAPS*     pExtendedCaps,
    LPDDSURFACEDESC             pTextureFormats,
    LPDDPIXELFORMAT             pZStencilFormats,
    UINT*                       pcTextureFormats,
    UINT*                       pcZStencilFormats
    );

HDC APIENTRY D3D8GetDC(
    HANDLE                    hSurface,
    LPPALETTEENTRY            pPalette
    );

BOOL APIENTRY D3D8ReleaseDC(
    HANDLE                  hSurface,
    HDC                     hdc
    );

BOOL APIENTRY D3D8ReenableDirectDrawObject(
    HANDLE                  hDD,
    BOOL*                   pbNewMode
    );

BOOL APIENTRY D3D8SetGammaRamp(
    HANDLE      hDD,
    HDC         hdc,
    LPVOID      lpGammaRamp
    );

VOID APIENTRY D3D8BuildModeTable(
    char*               pDeviceName,
    D3DDISPLAYMODE*     pModeTable,
    DWORD*              pNumEntries,
    D3DFORMAT           Unknown16,
    HANDLE              hProfile,
    BOOL                b16bppSupported,
    BOOL                b32bppSupported
    );

BOOL APIENTRY D3D8IsDeviceLost(
    HANDLE              hDD
    );

BOOL APIENTRY D3D8CanRestoreNow(
    HANDLE              hDD
    );

VOID APIENTRY D3D8RestoreDevice(
    HANDLE hDD
    );

BOOL APIENTRY D3D8DoVidmemSurfacesExist(
    HANDLE hDD
    );

VOID APIENTRY D3D8DeleteDirectDrawObject(
    HANDLE hDD
   );

HANDLE APIENTRY D3D8BeginProfile(
    char* pDeviceName
    );

VOID APIENTRY D3D8EndProfile(
    HANDLE Handle
    );

DWORD APIENTRY D3D8GetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    D3DDISPLAYMODE* pMode,
    D3DFORMAT       Unknown16
    );

DWORD APIENTRY D3D8SetMode(
    HANDLE  Handle,
    char*   pDeviceName,
    UINT    Width,
    UINT    Height,
    UINT    BPP,
    UINT    RefreshRate,
    BOOL    bRestore
    );

DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags );

VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD);

__inline DWORD D3D8GetDrawPrimHandle(HANDLE hSurface)
{
    return *(DWORD *)(hSurface);
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface );

VOID APIENTRY D3D8GetHALName(
    char* pDisplayName, 
    char *pDriverName );


#ifdef __cplusplus
}
#endif


typedef struct _D3D8_DEVICEDATA
{
    D3D8_DRIVERCAPS         DriverData;
    D3D8_CALLBACKS          Callbacks;
    DWORD                   dwFlags;
    char                    DriverName[MAX_DRIVER_NAME];
//    RECT                    DeviceRect;
    HDC                     hDC;
    GUID                    Guid;
    HANDLE                  hDD;
    D3DDEVTYPE              DeviceType;
    HINSTANCE               hLibrary;
    struct _D3D8_DEVICEDATA* pLink;
//    D3DDISPLAYMODE*       pModeTable;
//    DWORD                   dwNumModes;
} D3D8_DEVICEDATA, * PD3D8_DEVICEDATA;

#define DD_DISPLAYDRV       0x00000001
#define DD_GDIDRV           0x00000002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\d3di.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3di.hpp
 *  Content:    Direct3D internal include file
 *
 *
 ***************************************************************************/

#ifndef _D3DI_HPP
#define _D3DI_HPP

// Allow fast path
#define FAST_PATH

#include "ddrawp.h"
#include "d3d8p.h"
#include "d3dmem.h"

#if !defined(BUILD_DDDDK)
extern "C" {
#include "ddrawi.h"
};
#include "lists.hpp"

#include <d3ditype.h>
#include <d3dutil.h>
#include <d3dfe.hpp>
#include <vshader.hpp>
#include <pshader.hpp>
#include <rtdmon.hpp>
#include "ddi.h"

//--------------------------------------------------------------------
const DWORD __INIT_VERTEX_NUMBER = 1024;// Initial number of vertices in TL and
                                        // clip flag buffers
//--------------------------------------------------------------------
/*
 * Registry defines
 */
#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#define STATS_FONT_FACE "Terminal"
#define STATS_FONT_SIZE 9

extern HINSTANCE hGeometryDLL;

/*
 * CPU family and features flags
 */
extern DWORD dwCPUFamily, dwCPUFeatures;
extern char szCPUString[];

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

// Streaming SIMD2 Extensions (aka Willamete) CPU
#define D3DCPU_WLMT         0x000000040L



#define DEFAULT_GAMMA   DTOVAL(1.4)

/*
    INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
    to deterimine if the number of primitives being drawn is small
    relative to the number of vertices being passed.  If it is then
    the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE   2

#endif // BUILD_DDDDK

#if !defined(BUILD_DDDDK)

class CD3DHal;
class CStateSets;
class CVertexVM;
class CBaseTexture;
class CD3DDDI;
typedef CD3DDDI* LPD3DDDI;

typedef class CD3DHal *LPD3DHAL;
typedef class DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;

BOOL ValidatePixelShaderInternal( const DWORD* pCode, const D3DCAPS8* pCaps );
BOOL ValidateVertexShaderInternal( const DWORD* pCode, const DWORD* pDecl,
                                   const D3DCAPS8* pCaps );

#include "d3dhalp.h"

//-----------------------------------------------------------------------------
// Helper class to hold vertex element pointers and strides
//
class CVertexPointer
{
public:
    BYTE*   pData[__NUMELEMENTS];
    static UINT Stride[__NUMELEMENTS];
    static UINT NumUsedElements;
    static UINT DataType[__NUMELEMENTS];
    
    CVertexPointer() {}
    // Copy constructor
    CVertexPointer(CVertexPointer& vp)
    {
        for (UINT i=0; i < NumUsedElements; i++) 
        {
            pData[i]  = vp.pData[i];
        }
    }
    // Copy constructor
    void operator=(CVertexPointer& vp)
    {
        for (UINT i=0; i < NumUsedElements; i++) 
        {
            pData[i]  = vp.pData[i];
        }
    }
    void SetVertex(CVertexPointer& base, UINT index) 
    {
        for (UINT i=0; i < NumUsedElements; i++) 
            pData[i] = base.pData[i] + index * Stride[i];
    }
    CVertexPointer& operator++(int) 
    {
        for (UINT i=0; i < NumUsedElements; i++) 
            pData[i] += Stride[i];
        return *this;
    }
};
//-----------------------------------------------------------------------------
// Class to convert NPatches to RTPatches
//
class CNPatch2TriPatch
{
public:
    CNPatch2TriPatch();
    ~CNPatch2TriPatch();
    void MakeRectPatch(const CVertexPointer& pV0, 
                       const CVertexPointer& pV1, 
                       const CVertexPointer& pV2);

    CVStream        m_InpStream[__NUMELEMENTS];     // Original vertex streams
    CTLStream*      m_pOutStream[__NUMELEMENTS];    // Computed output vertex streams
    BYTE*           m_pInpStreamMem[__NUMELEMENTS]; // Input stream memory
    BYTE*           m_pOutStreamMem[__NUMELEMENTS]; // Output stream memory
    CVertexPointer  m_InpVertex;                    // Pointers to elements of the first input vertex
    CVertexPointer  m_OutVertex;                    // Pointers to elements of the first output vertex
    UINT            m_PositionIndex;                // Index in vertex element array
    UINT            m_NormalIndex;                  // Index in vertex element array
    D3DORDERTYPE    m_PositionOrder;
    D3DORDERTYPE    m_NormalOrder;
    UINT            m_FirstVertex;                  // Index of the first vertex in the 
                                                    // output buffer
    DWORD           m_bNormalizeNormals;
};
//-----------------------------------------------------------------------------
// Function to compute lighting
//
typedef struct _LIGHT_VERTEX_FUNC_TABLE
{
    LIGHT_VERTEX_FUNC   pfnDirectional;
    LIGHT_VERTEX_FUNC   pfnPointSpot;
// Used in multi-loop pipeline
    PFN_LIGHTLOOP       pfnDirectionalFirst;
    PFN_LIGHTLOOP       pfnDirectionalNext;
    PFN_LIGHTLOOP       pfnPointSpotFirst;
    PFN_LIGHTLOOP       pfnPointSpotNext;
} LIGHT_VERTEX_FUNC_TABLE;
//---------------------------------------------------------------------
class DIRECT3DLIGHTI : public CD3DBaseObj
{
public:
    DIRECT3DLIGHTI() {m_LightI.flags = 0;}   // VALID bit is not set
    HRESULT SetInternalData();
    BOOL Enabled() {return (m_LightI.flags & D3DLIGHTI_ENABLED);}
    // TRUE is we need to send the light to the driver when switching
    // to the hardware vertex processing mode
    BOOL DirtyForDDI() {return (m_LightI.flags & D3DLIGHTI_UPDATEDDI);}
    void SetDirtyForDDI() {m_LightI.flags |= D3DLIGHTI_UPDATEDDI;}
    void ClearDirtyForDDI() {m_LightI.flags &= ~D3DLIGHTI_UPDATEDDI;}
    // TRUE is we need to send the "enable" state of the light to the driver
    // when switching to the hardware vertex processing mode
    BOOL EnableDirtyForDDI() {return (m_LightI.flags & D3DLIGHTI_UPDATE_ENABLE_DDI);}
    void SetEnableDirtyForDDI() {m_LightI.flags |= D3DLIGHTI_UPDATE_ENABLE_DDI;}
    void ClearEnableDirtyForDDI() {m_LightI.flags &= ~D3DLIGHTI_UPDATE_ENABLE_DDI;}

    LIST_MEMBER(DIRECT3DLIGHTI) m_List;     // Active light list member
    D3DLIGHT8   m_Light;
    D3DI_LIGHT  m_LightI;
};
//---------------------------------------------------------------------
struct CPalette : public CD3DBaseObj
{
    CPalette()
    {
        m_dirty = TRUE;
    }

    BOOL         m_dirty;
    PALETTEENTRY m_pEntries[256];
};
#if DBG
//---------------------------------------------------------------------
struct CRTPatchValidationInfo : public CD3DBaseObj
{
    CRTPatchValidationInfo()
    {
        m_ShaderHandle = __INVALIDHANDLE;
    }

    DWORD m_ShaderHandle;
};
#endif // DBG
//---------------------------------------------------------------------
//
// Bits for Runtime state flags (m_dwRuntimeFlags in CD3DBase)
//
// This bit set if UpdateManagedTextures() needs to be called
const DWORD D3DRT_NEED_TEXTURE_UPDATE       = 1 << 1;
// We are in recording state set mode
const DWORD D3DRT_RECORDSTATEMODE           = 1 << 2;
// We are in execution state set mode
// In this mode the front-and executes recorded states but does not pass
// them to the driver (the states will be passed using a set state handle)
const DWORD D3DRT_EXECUTESTATEMODE          = 1 << 3;
//
const DWORD D3DRT_LOSTSURFACES              = 1 << 4;
// Set when D3DRS_SOFTWAREVERTEXPROCESSING is TRUE
const DWORD D3DRT_RSSOFTWAREPROCESSING      = 1 << 5;
// Set when device does not support point sprites
const DWORD D3DRT_DOPOINTSPRITEEMULATION    = 1 << 6;
// Set when input stream has point size. It is computed in the SetVertexShaderI
const DWORD D3DRT_POINTSIZEINVERTEX         = 1 << 7;
// Set when D3DRS_POINTSIZE != 1.0
const DWORD D3DRT_POINTSIZEINRS             = 1 << 8;
// Set when
//  - shader has been changed.
//  - when ForceFVFRecompute has been called
const DWORD D3DRT_SHADERDIRTY               = 1 << 9;
// This bit set if UpdateDirtyStreams() needs to be called
const DWORD D3DRT_NEED_VB_UPDATE            = 1 << 11;
// This bit set if we need to update vertex shader constants in the driver
const DWORD D3DRT_NEED_VSCONST_UPDATE       = 1 << 12;
// Set if device can handle only 2 floats per texture coord set
const DWORD D3DRT_ONLY2FLOATSPERTEXTURE     = 1 << 13;
// Set if device cannot handle projected textures, so we need to emulate them
const DWORD D3DRT_EMULATEPROJECTEDTEXTURE   = 1 << 14;
// Set if a directional light is present in the active light list
const DWORD D3DRT_DIRECTIONALIGHTPRESENT    = 1 << 15;
// Set if a point/spot light is present in the active light list
const DWORD D3DRT_POINTLIGHTPRESENT         = 1 << 16;
// Set if current primitive is user memory primitive
const DWORD D3DRT_USERMEMPRIMITIVE          = 1 << 17;
// Set if reg key to disallow Non-Versioned (FF.FF) pixel shaders was set on device create
const DWORD D3DRT_DISALLOWNVPSHADERS        = 1 << 18;
// Set when MaxPointSize in the device is greater than 1.0
const DWORD D3DRT_SUPPORTSPOINTSPRITES      = 1 << 19;
// Set when we need to do NPatch to RTPatch conversion
const DWORD D3DRT_DONPATCHCONVERSION        = 1 << 20;

const DWORD D3DRT_POINTSIZEPRESENT = D3DRT_POINTSIZEINRS |
                                     D3DRT_POINTSIZEINVERTEX;
//---------------------------------------------------------------------
//
// Bits for D3DFRONTEND flags (dwFEFlags in CD3DHal)
//
const DWORD D3DFE_WORLDMATRIX_DIRTY         = 1 << 0;   // World matrix dirty bits
const DWORD D3DFE_TLVERTEX                  = 1 << 5;
const DWORD D3DFE_PROJMATRIX_DIRTY          = 1 << 8;
const DWORD D3DFE_VIEWMATRIX_DIRTY          = 1 << 9;
// Set when we need to check world-view matrix for orthogonality
const DWORD D3DFE_NEEDCHECKWORLDVIEWVMATRIX = 1 << 10;
// Set when some state has been changed and we have to go through the slow path
// to update state.
// Currently the bit is set when one of the following bits is set:
//     D3DFE_PROJMATRIX_DIRTY
//     D3DFE_VIEWMATRIX_DIRTY
//     D3DFE_WORLDMATRIX_DIRTY
//     D3DFE_VERTEXBLEND_DIRTY
//     D3DFE_LIGHTS_DIRTY
//     D3DFE_MATERIAL_DIRTY
//     D3DFE_FVF_DIRTY
//     D3DFE_CLIPPLANES_DIRTY
//     OutputFVF has been changed
//
const DWORD D3DFE_FRONTEND_DIRTY            = 1 << 11;
const DWORD D3DFE_NEED_TRANSFORM_LIGHTS     = 1 << 14;
const DWORD D3DFE_MATERIAL_DIRTY            = 1 << 15;
const DWORD D3DFE_CLIPPLANES_DIRTY          = 1 << 16;
const DWORD D3DFE_LIGHTS_DIRTY              = 1 << 18;
// This bit is set when vertex blending state is dirty
const DWORD D3DFE_VERTEXBLEND_DIRTY         = 1 << 19;
// Set if the Current Transformation Matrix has been changed
// Reset when frustum planes in the model space have been computed
const DWORD D3DFE_FRUSTUMPLANES_DIRTY       = 1 << 20;
const DWORD D3DFE_WORLDVIEWMATRIX_DIRTY     = 1 << 21;
const DWORD D3DFE_FVF_DIRTY                 = 1 << 22;
// This bit set if mapping DX6 texture blend modes to renderstates is desired
const DWORD D3DFE_MAP_TSS_TO_RS             = 1 << 24;
const DWORD D3DFE_INVWORLDVIEWMATRIX_DIRTY  = 1 << 25;

// This bit set if texturing is disabled
const DWORD D3DFE_DISABLE_TEXTURES          = 1 << 28;
// Clip matrix is used to transform user clipping planes
// to the clipping space
const DWORD D3DFE_CLIPMATRIX_DIRTY          = 1 << 29;
// HAL supports Transformation and Lighting
const DWORD D3DFE_TLHAL                     = 1 << 30;

const DWORD D3DFE_TRANSFORM_DIRTY = D3DFE_PROJMATRIX_DIRTY |
                                    D3DFE_VIEWMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX_DIRTY |
                                    D3DFE_VERTEXBLEND_DIRTY;
// Are we in a scene?
const DWORD D3DDEVBOOL_HINTFLAGS_INSCENE       = 1 << 0;
// Means the FPU is already in preferred state.
const DWORD D3DDEVBOOL_HINTFLAGS_FPUSETUP      = 1 << 3;

//---------------------------------------------------------------------
// Bits for transform.dwFlags
//

//---------------------------------------------------------------------
typedef struct _D3DFE_TRANSFORM
{
    D3DMATRIXI  proj;
    D3DMATRIXI  mPC;        // Mproj * Mclip
    D3DMATRIXI  mVPCI;      // Inverse Mview * PC, used to transform clipping planes
    D3DVECTORH  userClipPlane[D3DMAXUSERCLIPPLANES];
} D3DFE_TRANSFORM;

typedef void (*D3DFEDestroyProc)(LPD3DHAL lpD3DDevI);

//---------------------------------------------------------------------
#ifdef _IA64_   // Removes IA64 compiler alignment warnings
  #pragma pack(16)
#endif

#ifdef _AXP64_   // Removes AXP64 compiler alignment warnings
  #pragma pack(16)
#endif

// We modify the compiler generated VTable for CD3DHal object. To make
// life easy, all virtual functions are defined in CD3DHal. Also since
// DEVICEI has multiple inheritance, there are more than 1 VTable.
// Currently we assume that it only inherits from IDirect3DDevice7 and
// D3DFE_PROCESSVERTICES and, in that order! Thus IDirect3DDevice7 and
// CD3DHal share the same vtable. This is the VTable we copy and
// modify. The define below is the total entries in this vtable. It is the
// sum of the methods in IDirect3DDevice7 (incl. IUnknown) (49) and all the
// virtual methods in CD3DHal ()
#define D3D_NUM_API_FUNCTIONS (49)
#define D3D_NUM_VIRTUAL_FUNCTIONS (D3D_NUM_API_FUNCTIONS+38)

// These constants are based on the assumption that rsVec array is an array
// of 32-bit intergers
const D3D_RSVEC_SHIFT = 5; // log2(sizeof(DWORD)*8);
const D3D_RSVEC_MASK = sizeof(DWORD) * 8 - 1;
//-----------------------------------------------------------------------------
// The class is used to maintain a packed array of bits
//
class CPackedBitArray
{
public:
    CPackedBitArray()  {m_pArray = NULL;}
    ~CPackedBitArray() {delete m_pArray;}
    // This function could be called to re-allocate the array. All data from the
    // previous array is copied into new array
    HRESULT Init(UINT size)
        {
            // Size in bytes
            UINT allocsize = ((size + D3D_RSVEC_MASK) >> D3D_RSVEC_SHIFT) << 2;
            DWORD* pNew = (DWORD*)new BYTE[allocsize];
            if (pNew == NULL)
                return E_OUTOFMEMORY;
            memset(pNew, 0, allocsize);
            if (m_pArray)
            {
                // User asks to re-allocate the array
                memcpy(pNew, m_pArray, m_sizeInBytes);
                delete m_pArray;
            }
            m_pArray = pNew;
            m_size = size;
            m_sizeInBytes = allocsize;
            return S_OK;
        }
    UINT GetSize() {return m_size;}
    void ClearBit(DWORD index)
    {
#if DBG
            CheckIndex(index);
#endif
            m_pArray[index >> D3D_RSVEC_SHIFT] &= ~(1 << (index & D3D_RSVEC_MASK));
    }
    void SetBit(DWORD index)
        {
#if DBG
            CheckIndex(index);
#endif
            m_pArray[index >> D3D_RSVEC_SHIFT] |= 1 << (index & D3D_RSVEC_MASK);
        }
    BOOL IsBitSet(DWORD index)
        {
#if DBG
            CheckIndex(index);
#endif
            return (m_pArray[index >> D3D_RSVEC_SHIFT] &
                   (1ul << (index & D3D_RSVEC_MASK))) != 0;
        }
private:
    DWORD*  m_pArray;
    UINT    m_sizeInBytes;
    UINT    m_size;       // Number of elements (bits) in the array
#if DBG
    void CheckIndex(UINT index);
#endif // DBG
};
//-----------------------------------------------------------------------------

// Map DX8 texture filter enum to D3DTEXTUREMAGFILTER
const texf2texfg[] = {
    D3DTFG_POINT,           // D3DTEXF_NONE            = 0,
    D3DTFG_POINT,           // D3DTEXF_POINT           = 1,
    D3DTFG_LINEAR,          // D3DTEXF_LINEAR          = 2,
    D3DTFG_ANISOTROPIC,     // D3DTEXF_ANISOTROPIC     = 3,
    D3DTFG_FLATCUBIC,       // D3DTEXF_FLATCUBIC       = 4,
    D3DTFG_GAUSSIANCUBIC,   // D3DTEXF_GAUSSIANCUBIC   = 5,
};
// Map DX8 texture filter enum to D3DTEXTUREMINFILTER
const texf2texfn[] = {
    D3DTFN_POINT,           // D3DTEXF_NONE            = 0,
    D3DTFN_POINT,           // D3DTEXF_POINT           = 1,
    D3DTFN_LINEAR,          // D3DTEXF_LINEAR          = 2,
    D3DTFN_ANISOTROPIC,     // D3DTEXF_ANISOTROPIC     = 3,
    D3DTFN_LINEAR,          // D3DTEXF_FLATCUBIC       = 4,
    D3DTFN_LINEAR,          // D3DTEXF_GAUSSIANCUBIC   = 5,
};
// Map DX8 texture filter enum to D3DTEXTUREMIPFILTER
const texf2texfp[] = {
    D3DTFP_NONE,            // D3DTEXF_NONE            = 0,
    D3DTFP_POINT,           // D3DTEXF_POINT           = 1,
    D3DTFP_LINEAR,          // D3DTEXF_LINEAR          = 2,
    D3DTFP_LINEAR,          // D3DTEXF_ANISOTROPIC     = 3,
    D3DTFP_LINEAR,          // D3DTEXF_FLATCUBIC       = 4,
    D3DTFP_LINEAR,          // D3DTEXF_GAUSSIANCUBIC   = 5,
};

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DBase                                                                //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
class CD3DBase : public CBaseDevice
{

public:
    // IDirect3DDevice8 Methods
    HRESULT D3DAPI ResourceManagerDiscardBytes(DWORD cbBytes);                                                          // 5

    HRESULT D3DAPI SetRenderTarget(IDirect3DSurface8 *pRenderTarget, IDirect3DSurface8 *pZStencil);                     // 31
    HRESULT D3DAPI GetRenderTarget(IDirect3DSurface8 **ppRenderTarget);                                                 // 32
    HRESULT D3DAPI GetDepthStencilSurface(IDirect3DSurface8 **ppZStencil);                                              // 33

    HRESULT D3DAPI BeginScene();                                                                                        // 34
    HRESULT D3DAPI EndScene();                                                                                          // 35
    HRESULT D3DAPI Clear( DWORD dwCount, CONST D3DRECT* rects, DWORD dwFlags,
                          D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);                                             // 36
    HRESULT D3DAPI SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                               // 37
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);                                                    // 38
    HRESULT D3DAPI MultiplyTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                          // 39
    HRESULT D3DAPI SetViewport(CONST D3DVIEWPORT8*);                                                                    // 40
    HRESULT D3DAPI GetViewport(D3DVIEWPORT8*);                                                                          // 41
    HRESULT D3DAPI SetMaterial(CONST D3DMATERIAL8*);                                                                    // 42
    HRESULT D3DAPI GetMaterial(D3DMATERIAL8*);                                                                          // 43
    HRESULT D3DAPI SetLight(DWORD, CONST D3DLIGHT8*);                                                                   // 44
    HRESULT D3DAPI GetLight(DWORD, D3DLIGHT8*);                                                                         // 45
    HRESULT D3DAPI LightEnable(DWORD dwLightIndex, BOOL);                                                               // 46
    HRESULT D3DAPI GetLightEnable(DWORD dwLightIndex, BOOL*);                                                           // 47
    HRESULT D3DAPI SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);                                    // 48
    HRESULT D3DAPI GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);                                          // 49
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);                                                           // 50
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);                                                         // 51
    HRESULT D3DAPI BeginStateBlock();                                                                                   // 52
    HRESULT D3DAPI EndStateBlock(LPDWORD);                                                                              // 53
    HRESULT D3DAPI ApplyStateBlock(DWORD);                                                                              // 54
    HRESULT D3DAPI CaptureStateBlock(DWORD Handle);                                                                     // 55
    HRESULT D3DAPI DeleteStateBlock(DWORD);                                                                             // 56
    HRESULT D3DAPI CreateStateBlock(D3DSTATEBLOCKTYPE sbt, LPDWORD pdwHandle);                                          // 57
    HRESULT D3DAPI SetClipStatus(CONST D3DCLIPSTATUS8*);                                                                // 58
    HRESULT D3DAPI GetClipStatus(D3DCLIPSTATUS8*);                                                                      // 59
    HRESULT D3DAPI GetTexture(DWORD, IDirect3DBaseTexture8**);                                                          // 60
    HRESULT D3DAPI SetTexture(DWORD, IDirect3DBaseTexture8*);                                                           // 61
    HRESULT D3DAPI GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, LPDWORD);                                      // 62
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);                                                                 // 63
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);                                                               // 64
    HRESULT D3DAPI GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct,
                           DWORD dwSize);                                                                               // 65
    HRESULT D3DAPI SetPaletteEntries(UINT PaletteNumber, CONST PALETTEENTRY *pEntries);                                 // 66
    HRESULT D3DAPI GetPaletteEntries(UINT PaletteNumber, PALETTEENTRY *pEntries);                                       // 67
    HRESULT D3DAPI SetCurrentTexturePalette(UINT PaletteNumber);                                                        // 68
    HRESULT D3DAPI GetCurrentTexturePalette(UINT *PaletteNumber);                                                       // 69
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE PrimType,
                                 UINT StartVertex, UINT VertexCount);                                                   // 70
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, UINT minIndex,
                                         UINT maxIndex, UINT startIndex,
                                         UINT count);                                                                   // 71
    HRESULT D3DAPI DrawPrimitiveUP(
        D3DPRIMITIVETYPE PrimitiveType,
        UINT PrimitiveCount,
        CONST VOID *pVertexStreamZeroData,
        UINT VertexStreamZeroStride);                                                                                   // 72
    HRESULT D3DAPI DrawIndexedPrimitiveUP(
        D3DPRIMITIVETYPE PrimitiveType,
        UINT MinVertexIndex, UINT NumVertexIndices,
        UINT PrimitiveCount,
        CONST VOID *pIndexData, D3DFORMAT IndexDataFormat,
        CONST VOID *pVertexStreamZeroData, UINT VertexStreamZeroStride);                                                // 73
    HRESULT D3DAPI ProcessVertices(UINT SrcStartIndex, UINT DestIndex,
                                   UINT VertexCount,
                                   IDirect3DVertexBuffer8 *pDestBuffer,
                                   DWORD Flags);                                                                        // 74

    HRESULT D3DAPI CreateVertexShader(CONST DWORD* pdwDeclaration,
                                      CONST DWORD* pdwFunction,
                                      DWORD* pdwHandle, DWORD dwUsage);                                                 // 75
    HRESULT D3DAPI SetVertexShader(DWORD dwHandle);                                                                     // 76
    HRESULT D3DAPI GetVertexShader(LPDWORD pdwHandle);                                                                  // 77
    HRESULT D3DAPI DeleteVertexShader(DWORD dwHandle);                                                                  // 78
    HRESULT D3DAPI SetVertexShaderConstant(DWORD dwRegisterAddress,
                                           CONST VOID* lpvConstantData,
                                           DWORD dwConstantCount);                                                      // 79
    HRESULT D3DAPI GetVertexShaderConstant(DWORD dwRegisterAddress,
                                           LPVOID lpvConstantData,
                                           DWORD dwConstantCount);                                                      // 80
    HRESULT D3DAPI GetVertexShaderDeclaration(DWORD dwHandle, void *pData,
                                              DWORD *pSizeOfData);                                                      // 81
    HRESULT D3DAPI GetVertexShaderFunction(DWORD dwHandle, void *pData,
                                           DWORD *pSizeOfData);                                                         // 82

    HRESULT D3DAPI SetStreamSource(UINT StreamNumber,
                                   IDirect3DVertexBuffer8 *pStreamData,
                                   UINT Stride);                                                                        // 83
    HRESULT D3DAPI GetStreamSource(UINT StreamNumber,
                                   IDirect3DVertexBuffer8 **ppStreamData,
                                   UINT* pStride);                                                                      // 84
    HRESULT D3DAPI SetIndices(IDirect3DIndexBuffer8 *pIndexData,
                              UINT BaseVertexIndex);                                                                    // 85
    HRESULT D3DAPI GetIndices(IDirect3DIndexBuffer8 **ppIndexData,
                              UINT* pBaseVertexIndex);                                                                  // 86

    HRESULT D3DAPI CreatePixelShader(CONST DWORD* pdwFunction,
                                     LPDWORD pdwHandle);                                                                // 87
    HRESULT D3DAPI SetPixelShader(DWORD dwHandle);                                                                      // 88
    HRESULT D3DAPI GetPixelShader(LPDWORD pdwHandle);                                                                   // 89
    HRESULT D3DAPI DeletePixelShader(DWORD dwHandle);                                                                   // 90
    HRESULT D3DAPI SetPixelShaderConstant(DWORD dwRegisterAddress,
                                          CONST VOID* lpvConstantData,
                                          DWORD dwConstantCount);                                                       // 91
    HRESULT D3DAPI GetPixelShaderConstant(DWORD dwRegisterAddress,
                                          LPVOID lpvConstantData,
                                          DWORD dwConstantCount);                                                       // 92
    HRESULT D3DAPI GetPixelShaderFunction(DWORD dwHandle, void *pData,
                                          DWORD *pSizeOfData);                                                          // 93

    HRESULT D3DAPI DrawRectPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                 CONST D3DRECTPATCH_INFO *pSurf);                                                       // 94
    HRESULT D3DAPI DrawTriPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                CONST D3DTRIPATCH_INFO *pSurf);                                                         // 95
    HRESULT D3DAPI DeletePatch(UINT Handle);                                                                            // 96

public:

    // Flags to indicate runtime state
    DWORD              m_dwRuntimeFlags;

    // D3DDEVBOOL flags
    DWORD              m_dwHintFlags;

    // This should only be accessed through
    // CurrentBatch and IncrementBatchCount
    ULONGLONG          m_qwBatch;

    // The object encapsulating the DDI styles
    // At the minimum this is a DX6 driver.
    LPD3DDDIDX6        m_pDDI;

#if DBG
    // Debug Monitor
    D3DDebugMonitor*    m_pDbgMonBase;  // base class only
    RTDebugMonitor*     m_pDbgMon;      // runtime monitor
    BOOL                m_bDbgMonConnectionEnabled;

    void    DebugEvent( UINT32 EventType )
    {
        if (m_pDbgMon) m_pDbgMon->NextEvent( EventType );
    }
    void    DebugStateChanged( UINT32 StateType )
    {
        if (m_pDbgMon) m_pDbgMon->StateChanged( StateType );
    }
#else
    void    DebugEvent( UINT32 ) { };
    void    DebugStateChanged( UINT32 ) { };
#endif


    // Pointer to texture objects for currently installed textures.
    // NULL indicates that the texture is either not set (rstate NULL) or that
    // the handle to tex3 pointer mapping is not done.  This mapping is
    // expensive, so it is deferred until needed. This is needed for finding
    // the WRAPU,V mode for texture index clipping (since the WRAPU,V state is
    // part of the device).
    CBaseTexture* m_lpD3DMappedTexI[D3DHAL_TSS_MAXSTAGES];
    DWORD     m_dwDDITexHandle[D3DHAL_TSS_MAXSTAGES];
    // Max number of blend stages supported by a driver
    DWORD     m_dwMaxTextureBlendStages;
    DWORD     m_dwStageDirty, m_dwStreamDirty;

    // Object to record state sets
    CStateSets* m_pStateSets;

    //
    // The following is for validation only
    //

    // Max TSS that can be passed to the driver
    D3DTEXTURESTAGESTATETYPE m_tssMax;

    // Max RS that can be passed to the driver, used for CanHandleRenderState
    D3DRENDERSTATETYPE m_rsMax;

#if defined(PROFILE4) || defined(PROFILE)
    DWORD m_dwProfStart, m_dwProfStop;
#endif

    // This bit array is used to tell if a light has been created or not
    CPackedBitArray* m_pCreatedLights;

    // DX8 related stuff from here -------------------------------------

    // The current shader handle. It is initialized to Zero.
    // Zero means that there is no current shader. User always has to
    // initialize the shader.
    // It is used only by non-pure device
    DWORD       m_dwCurrentShaderHandle;

    // The current pixel shader handle. It is initialized to zero, and
    // is set to zero for legacy pixel processing
    // It is used only by non-pure device
    DWORD       m_dwCurrentPixelShaderHandle;

     // This object gives us pixel shader handles
    CHandleFactory* m_pPShaderArray;

     // This object gives us vertex shader handles
    CVShaderHandleFactory* m_pVShaderArray;
    // Vertex sctreams
    CVStream*   m_pStream;
    // Index stream
    CVIndexStream* m_pIndexStream;
    // Max number of streams allowed. For D3D software it is __NUMSTREAMS
    // For hardware T&L it could be smaller
    DWORD       m_dwNumStreams;
    // Max number of user clipping streams supported
    DWORD       m_dwMaxUserClipPlanes;
    // Currently set palette
    DWORD       m_dwPalette;
    // Palette array
    CHandleArray *m_pPaletteArray;
#if DBG
    // Needed for RT-Patch validation
    CHandleArray *m_pRTPatchValidationInfo;
    // Needed for VB warnings
    DWORD         m_SceneStamp;
#endif // DBG

    // Function pointers for DrawPrimitive processing
    PFN_DRAWPRIMFAST        m_pfnDrawPrim;
    PFN_DRAWINDEXEDPRIMFAST m_pfnDrawIndexedPrim;
    // Function pointers for DrawPrimitive processing from NPatch 
    // conversion function in case of point or line primitives
    PFN_DRAWPRIMFAST        m_pfnDrawPrimFromNPatch;
    PFN_DRAWINDEXEDPRIMFAST m_pfnDrawIndexedPrimFromNPatch;

    // Number of constant register. This could be different for software and
    // hardware vertex processing
    UINT        m_MaxVertexShaderConst;

#ifdef FAST_PATH
#define NUMVTBLENTRIES  135
    VOID        **m_pOrigVtbl;
    VOID         *m_pVtbl[NUMVTBLENTRIES];

    void FastPathSetRenderStateExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[50] = m_pVtbl[98];
        }
        else
        {
            DXGASSERT(m_pVtbl[50] == m_pOrigVtbl[50]);
        }
    }
    void FastPathSetRenderStateRecord()
    {
        m_pVtbl[50] = m_pOrigVtbl[50];
    }
    void FastPathSetTextureStageStateExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[63] = m_pVtbl[99];
        }
        else
        {
            DXGASSERT(m_pVtbl[63] == m_pOrigVtbl[63]);
        }
    }
    void FastPathSetTextureStageStateRecord()
    {
        m_pVtbl[63] = m_pOrigVtbl[63];
    }
    void FastPathSetTextureExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[61] = m_pVtbl[100];
        }
        else
        {
            DXGASSERT(m_pVtbl[61] == m_pOrigVtbl[61]);
        }
    }
    void FastPathSetTextureRecord()
    {
        m_pVtbl[61] = m_pOrigVtbl[61];
    }
    void FastPathApplyStateBlockExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[54] = m_pVtbl[101];
        }
        else
        {
            DXGASSERT(m_pVtbl[54] == m_pOrigVtbl[54]);
        }
    }
    void FastPathApplyStateBlockRecord()
    {
        m_pVtbl[54] = m_pOrigVtbl[54];
    }
    void FastPathSetVertexShaderFast()
    {
        if((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
            (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[76] = m_pVtbl[102];
        }
        else
        {
            DXGASSERT(m_pVtbl[76] == m_pOrigVtbl[76]);
        }
    }
    void FastPathSetVertexShaderSlow()
    {
        m_pVtbl[76] = m_pOrigVtbl[76];
    }
    void FastPathSetStreamSourceFast()
    {
        if((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
            (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[83] = m_pVtbl[103];
        }
        else
        {
            DXGASSERT(m_pVtbl[83] == m_pOrigVtbl[83]);
        }
    }
    void FastPathSetStreamSourceSlow()
    {
        m_pVtbl[83] = m_pOrigVtbl[83];
    }
    void FastPathSetIndicesFast()
    {
        if((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
            (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[85] = m_pVtbl[104];
        }
        else
        {
            DXGASSERT(m_pVtbl[85] == m_pOrigVtbl[85]);
        }
    }
    void FastPathSetIndicesSlow()
    {
        m_pVtbl[85] = m_pOrigVtbl[85];
    }
    void FastPathSetTransformExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
           (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0)
        {
            m_pVtbl[37] = m_pVtbl[105];
        }
        else
        {
            DXGASSERT(m_pVtbl[37] == m_pOrigVtbl[37]);
        }
    }
    void FastPathSetTransformRecord()
    {
        m_pVtbl[37] = m_pOrigVtbl[37];
    }
    void FastPathMultiplyTransformExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
           (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0)
        {
            m_pVtbl[39] = m_pVtbl[106];
        }
        else
        {
            DXGASSERT(m_pVtbl[39] == m_pOrigVtbl[39]);
        }
    }
    void FastPathMultiplyTransformRecord()
    {
        m_pVtbl[39] = m_pOrigVtbl[39];
    }
    void FastPathSetMaterialExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[42] = m_pVtbl[107];
        }
        else
        {
            DXGASSERT(m_pVtbl[42] == m_pOrigVtbl[42]);
        }
    }
    void FastPathSetMaterialRecord()
    {
        m_pVtbl[42] = m_pOrigVtbl[42];
    }
    void FastPathSetPixelShaderExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[88] = m_pVtbl[108];
        }
        else
        {
            DXGASSERT(m_pVtbl[88] == m_pOrigVtbl[88]);
        }
    }
    void FastPathSetPixelShaderRecord()
    {
        m_pVtbl[88] = m_pOrigVtbl[88];
    }
    void FastPathSetPixelShaderConstantExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[91] = m_pVtbl[109];
        }
        else
        {
            DXGASSERT(m_pVtbl[91] == m_pOrigVtbl[91]);
        }
    }
    void FastPathSetPixelShaderConstantRecord()
    {
        m_pVtbl[91] = m_pOrigVtbl[91];
    }
    void FastPathSetVertexShaderConstantExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
           (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0)
        {
            m_pVtbl[79] = m_pVtbl[110];
        }
        else
        {
            DXGASSERT(m_pVtbl[79] == m_pOrigVtbl[79]);
        }
    }
    void FastPathSetVertexShaderConstantRecord()
    {
        m_pVtbl[79] = m_pOrigVtbl[79];
    }
#endif // FAST_PATH

public:
    CD3DBase();
    virtual ~CD3DBase();                                                                                                // 97

    virtual HRESULT D3DAPI SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value);                                 // 98
    virtual HRESULT D3DAPI SetTextureStageStateFast(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue);    // 99
    virtual HRESULT D3DAPI SetTextureFast(DWORD, IDirect3DBaseTexture8 *lpTex);                                         // 100
    virtual HRESULT D3DAPI ApplyStateBlockFast(DWORD);                                                                  // 101
#ifdef FAST_PATH
    virtual HRESULT D3DAPI SetVertexShaderFast(DWORD);                                                                  // 102
    virtual HRESULT D3DAPI SetStreamSourceFast(UINT StreamNumber, IDirect3DVertexBuffer8 *pStreamData, UINT Stride);    // 103
    virtual HRESULT D3DAPI SetIndicesFast(IDirect3DIndexBuffer8 *pIndexData, UINT BaseVertexIndex);                     // 104
    virtual HRESULT D3DAPI SetTransformFast(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                   // 105
    virtual HRESULT D3DAPI MultiplyTransformFast(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                              // 106
#endif // FAST_PATH
    virtual HRESULT D3DAPI SetMaterialFast(CONST D3DMATERIAL8*);                                                        // 107
    virtual HRESULT D3DAPI SetPixelShaderFast(DWORD dwHandle);                                                          // 108
    virtual HRESULT D3DAPI SetPixelShaderConstantFast(DWORD dwRegisterAddress,                                          // 109
                                                      CONST VOID* lpvConstantData,
                                                      DWORD dwConstantCount);
    virtual HRESULT D3DAPI SetVertexShaderConstantFast(DWORD dwRegisterAddress,                                         // 110
                                                       CONST VOID* lpvConstantData,
                                                       DWORD dwConstantCount);

    virtual void Destroy();                                                                                             // 111

    // Virtual methods for CBaseDevice
    virtual HRESULT InitDevice();                                                                                       // 112
    virtual void StateInitialize(BOOL bZEnable);                                                                        // 113
    virtual void UpdateRenderState(DWORD dwStateType, DWORD value) {}                                                   // 114
    virtual void SetTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                                // 115
    virtual void MultiplyTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                           // 116
    virtual void SetClipPlaneI(DWORD dwPlaneIndex,                                                                      // 117
                               CONST D3DVALUE* pPlaneEquation);
    virtual void UpdateDriverStates(){ DDASSERT( FALSE ); }                                                             // 118
    virtual void SetViewportI(CONST D3DVIEWPORT8*);                                                                     // 119
    virtual void SetStreamSourceI(CVStream*);                                                                           // 120
    virtual void SetIndicesI(CVIndexStream*);                                                                           // 121
    virtual void CreateVertexShaderI(CONST DWORD* pdwDeclaration,                                                       // 122
                                     DWORD dwDeclSize,
                                     CONST DWORD* pdwFunction,
                                     DWORD dwCodeSize,
                                     DWORD dwHandle);
    virtual void SetVertexShaderI(DWORD dwHandle);                                                                      // 123
    virtual void DeleteVertexShaderI(DWORD dwHandle);                                                                   // 124
    virtual void SetVertexShaderConstantI(DWORD dwRegisterAddress,                                                      // 125
                                          CONST VOID* lpvConstantData,
                                          DWORD dwConstantCount);
    virtual void DrawPointsI(D3DPRIMITIVETYPE PrimitiveType,                                                            // 126
                             UINT StartVertex,
                             UINT PrimitiveCount);
    virtual void SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8*);                                                       // 127
    virtual void LightEnableI(DWORD dwLightIndex, BOOL);                                                                // 128
    virtual void SetRenderStateInternal(D3DRENDERSTATETYPE, DWORD);                                                     // 129
    virtual void DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,                                                       // 130
                                 UINT PrimitiveCount);
    virtual void DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,                                                // 131
                                         UINT MinVertexIndex,
                                         UINT NumVertexIndices,
                                         UINT PrimitiveCount);
    virtual void GetPixelShaderConstantI(DWORD Register, DWORD count,                                                   // 132
                                         LPVOID pData );
    virtual void ClearI( DWORD dwCount, CONST D3DRECT* rects, DWORD dwFlags,                                            // 133
                         D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    // Picks the right DrawPrimitive and DrawIndexedPrimitive function to
    // execute
    // Call this function when
    // - vertex shader is changed
    // - stream source is changed
    // - D3DRS_CLIPPING is changed
    // - resource has been changed
    //
    // Base device implementation is empty, because the function pointers are
    // initialized in the constructor and do not change
    virtual void __declspec(nothrow) PickDrawPrimFn() {};                                                               // 134

protected:
    void ValidateDraw(D3DPRIMITIVETYPE primType, UINT StartVertex,
                      UINT PrimitiveCount, UINT NumVertices,
                      BOOL bIndexPrimitive, BOOL bUsedMemPrimitive);
    void CheckIndices(CONST BYTE* pIndices, UINT NumIndices, UINT StartIndex,
                      UINT MinIndex, UINT NumVertices, UINT IndexStride);
    void CheckViewport(CONST D3DVIEWPORT8* lpData);
    void CheckVertexShaderHandle(DWORD dwHandle);
    void CheckPixelShaderHandle(DWORD dwHandle);
    inline void ClearVertexShaderHandle()
    {
        m_dwCurrentShaderHandle = 0;
    }
public:
    // non virtual methods
    HRESULT __declspec(nothrow) Init();
    HRESULT VerifyTexture(DWORD dwStage, IDirect3DBaseTexture8 *lpTex);
    HRESULT CalcDDSurfInfo(BOOL bUpdateZBufferFields);
    // Re-creates hardware pixel and vertex shaders after device is reset
    HRESULT ResetShaders();
    void __declspec(nothrow) NeedResourceStateUpdate()
    {
        this->m_dwRuntimeFlags |= (D3DRT_NEED_TEXTURE_UPDATE | D3DRT_NEED_VB_UPDATE);
        // We shouldn't call PickDrawPrimFn when the device is being destroyed
        if (m_pDDI)
            PickDrawPrimFn();
    }
    HRESULT __declspec(nothrow) SetRenderTargetI(CBaseSurface* pTarget,
                                                 CBaseSurface* pZ);
    // Checks if we can pass the render state to the driver
    BOOL CanHandleRenderState(D3DRENDERSTATETYPE type)
    {
        if (type >= m_rsMax)
        {
            // not an error condition because we don't send front-end stuff to
            // non-TL Hal devices, for example, but don't send to HAL anyway
            return FALSE;
        }
        return TRUE;
    };
    void UpdateTextures();
    void UpdatePalette(CBaseTexture *pTex, DWORD Palette, DWORD dwStage, BOOL bSavedWithinPrimitive);

    HRESULT __declspec(nothrow) TexBlt(CBaseTexture *lpDst,
                                       CBaseTexture* lpSrc,
                                       POINT *pPoint,
                                       RECTL *pRect);

    HRESULT __declspec(nothrow) CubeTexBlt(CBaseTexture *lpDstParent,
                                           CBaseTexture* lpSrcParent,
                                           DWORD dwDestFaceHandle,
                                           DWORD dwSrcFaceHandle,
                                           POINT *pPoint,
                                           RECTL *pRect);

    HRESULT __declspec(nothrow) VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                                       DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox);
    HRESULT __declspec(nothrow) BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                                       D3DRANGE* pRange);

    HRESULT __declspec(nothrow) SetPriority(CResource *pRes, DWORD dwPriority);
    HRESULT __declspec(nothrow) SetTexLOD(CBaseTexture *pTex, DWORD dwLOD);

    HRESULT __declspec(nothrow) AddDirtyRect(CBaseTexture *pTex, CONST RECTL *pRect);
    HRESULT __declspec(nothrow) AddCubeDirtyRect(CBaseTexture *pTex, DWORD dwFaceHandle, CONST RECTL *pRect);
    HRESULT __declspec(nothrow) AddDirtyBox(CBaseTexture *pTex, CONST D3DBOX *pBox);

    void __declspec(nothrow) CleanupTextures();
    void __declspec(nothrow) OnTextureDestroy(CBaseTexture*);

    ULONGLONG __declspec(nothrow) CurrentBatch()
    {
        DDASSERT(m_qwBatch > 0);
        return m_qwBatch;
    }
    void IncrementBatchCount();
    void __declspec(nothrow) Sync(ULONGLONG batch)
    {
        if (m_qwBatch <= batch)
        {
            FlushStatesNoThrow();
        }
    }

    HRESULT __declspec(nothrow) ValidateFVF(DWORD dwFVF);

    void __declspec(nothrow) FlushStatesNoThrow();

#if DBG
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif

    friend class CD3DDDIDX6;
};

typedef CD3DBase *LPD3DBASE;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DHal                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef void (CD3DHal::* PFN_PREPARETODRAW)(UINT StartVertex);

class CD3DHal : public CD3DBase
{
public: // Private Data

    // buffer for H vertices
    CAlignedBuffer32    HVbuf;

    // Front end data
    D3DFE_TRANSFORM     transform;      // Transformation state

    D3DCLIPSTATUS8      m_ClipStatus;

    // Pipeline state info

    D3DFE_PROCESSVERTICES* m_pv;        // common data for D3D and PSGP

    DWORD   dwFEFlags;                  // Front-end flags
    //--------------- Lights start -----------------------
    // List of currently enabled lights
    LIST_ROOT(_dlights, DIRECT3DLIGHTI) m_ActiveLights;

    LIST_ROOT(name10,_SpecularTable) specular_tables;
    SpecularTable*    specular_table;
    LIGHT_VERTEX_FUNC_TABLE *lightVertexFuncTable;

    // Light management support
    CHandleArray* m_pLightArray;
    //--------------- Lights end -----------------------

    // Viewports
    D3DVIEWPORT8    m_Viewport;

    DWORD           m_clrCount;   // Number of rects allocated
    LPD3DRECT       m_clrRects;   // Rects used for clearing

    // Runtime copy of the renderstates
    LPDWORD rstates;

    // Runtime copy of texture stage states
    DWORD tsstates[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];

    // Bit set for a render state means that we have to update internal front-end state
    // Otherwise we can go through a fast path
    CPackedBitArray rsVec;
    // Bit set for a render state means that the render state is retired
    CPackedBitArray rsVecRetired;
    // Bit set for a render state means that the render state is for vertex
    // processing only
    CPackedBitArray rsVertexProcessingOnly;
    // For every transformation matrix there is a bit, which is set if we need
    // to update driver state
    CPackedBitArray* pMatrixDirtyForDDI;

    // Pointer to a specific PrepareToDraw function
    PFN_PREPARETODRAW m_pfnPrepareToDraw;

    // Current vertex shader, corresponding to the dwCurrentShaderHandle
    // NULL for the fixed-function pipeline
    CVShader*   m_pCurrentShader;

    // The instance of the class providing a guaranteed implementation
    D3DFE_PVFUNCSI* GeometryFuncsGuaranteed;

    // Pixel Shader constant registers cached for Hal device
    PVM_WORD    m_PShaderConstReg[D3DPS_CONSTREG_MAX_DX8];

    // Object, used to convert NPatches to TriPatches
    CNPatch2TriPatch*   m_pConvObj;

    // Texture stages, which we need to remap, when number of output texture 
    // coordinates is greater than number of input texture coordinates
    D3DFE_TEXTURESTAGE textureStageToRemap[D3DDP_MAXTEXCOORD]; 
    // Number of texture stages to remap
    DWORD   dwNumTextureStagesToRemap;

    virtual HRESULT D3DAPI SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value);
    virtual HRESULT D3DAPI SetTextureStageStateFast(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue);
#ifdef FAST_PATH
    virtual HRESULT D3DAPI SetVertexShaderFast(DWORD);
#endif // FAST_PATH
    virtual HRESULT D3DAPI SetMaterialFast(CONST D3DMATERIAL8*);
    virtual HRESULT D3DAPI SetPixelShaderFast(DWORD dwHandle);
    virtual HRESULT D3DAPI SetPixelShaderConstantFast(DWORD dwRegisterAddress,
                                                      CONST VOID* lpvConstantData,
                                                      DWORD dwConstantCount);

public:
    CD3DHal();
    virtual ~CD3DHal();
    virtual void Destroy();

    //
    // Pure Methods from CD3DBase implemented here
    //

    virtual HRESULT InitDevice();
    virtual void StateInitialize(BOOL bZEnable);
    virtual void SetTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    virtual void MultiplyTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    virtual void SetViewportI(CONST D3DVIEWPORT8*);
    virtual void SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8*);
    virtual void LightEnableI(DWORD dwLightIndex, BOOL);
    virtual void SetClipPlaneI(DWORD dwPlaneIndex,
                               CONST D3DVALUE* pPlaneEquation);
    virtual void SetStreamSourceI(CVStream*);
    virtual void SetIndicesI(CVIndexStream*);
    virtual void CreateVertexShaderI(CONST DWORD* pdwDeclaration,
                                     DWORD dwDeclSize,
                                     CONST DWORD* pdwFunction,
                                     DWORD dwCodeSize,
                                     DWORD dwHandle);
    virtual void SetVertexShaderI(DWORD dwHandle);
    virtual void DeleteVertexShaderI(DWORD dwHandle);
    virtual void SetVertexShaderConstantI(DWORD dwRegisterAddress,
                                          CONST VOID* lpvConstantData,
                                          DWORD dwConstantCount);
    virtual void DrawPointsI(D3DPRIMITIVETYPE PrimitiveType,
                                   UINT StartVertex,
                                   UINT PrimitiveCount);
    virtual void DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,
                                 UINT PrimitiveCount);
    virtual void DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,
                                         UINT MinVertexIndex,
                                         UINT NumVertexIndices,
                                         UINT PrimitiveCount);
    virtual void ClearI( DWORD dwCount, CONST D3DRECT* rects, DWORD dwFlags,
                         D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    // This function is used when in SetRenderTarget the driver context is
    // recreated
    virtual void UpdateDriverStates();  // 10

    virtual void UpdateRenderState(DWORD dwStateType, DWORD value)
        {rstates[dwStateType] = value;}
    virtual void __declspec(nothrow) PickDrawPrimFn();

public: // non virtual methods

    // Called by drawing functions to prepare vertex stream pointers for
    // legacy vertex shaders
    void PrepareToDrawLegacy(UINT dwStartVertex);
    // Called by drawing functions to prepare vertex stream pointers for
    // programmable pipeline
    void PrepareToDrawVVM(UINT dwStartVertex);
    // Called by drawing functions to prepare vertex stream pointers for
    // fixed-function pipeline with declarations
    void PrepareToDraw(UINT dwStartVertex);
    // dwValue could be changed by the function, when we need to filter
    // PROJECTED bit.
    BOOL UpdateInternalTextureStageState(DWORD dwStage,
                                         D3DTEXTURESTAGESTATETYPE dwState,
                                         DWORD* dwValue);
    HRESULT checkDeviceSurface(LPDDRAWI_DDRAWSURFACE_LCL lpDDS, LPDDRAWI_DDRAWSURFACE_LCL lpZbuffer, LPGUID pGuid);
    void SetupFVFDataCommon();
    void SetupFVFData();
    void SwitchVertexProcessingMode(DWORD SoftwareMode);
    void DrawPoints(UINT StartVertex);
    void GetPixelShaderConstantI(DWORD Register, DWORD count, LPVOID pData );

    void PrepareNPatchConversion(UINT PrimitiveCount, UINT StartVertex);

    BOOL NeedInternalTSSUpdate(DWORD dwState)
    {
        return dwState == D3DTSS_TEXCOORDINDEX || dwState >= D3DTSS_TEXTURETRANSFORMFLAGS ||
               dwState == D3DTSS_COLOROP;
    }
    // Always use this function to update "rstates", because we have to
    // set some internal flags when "rstats" is changed.
    void UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value);
    // Checks for 'retired' render state - returns TRUE if not retired
    BOOL CheckForRetiredRenderState(D3DRENDERSTATETYPE type)
    {
        if (!rsVecRetired.IsBitSet(type))
        {
            // not retired
            return TRUE;
        }
        return FALSE;
    }
    // Update internal state
    inline void SetFogFlags(void);
    void ForceFVFRecompute(void)
        {
            dwFEFlags |= D3DFE_FVF_DIRTY | D3DFE_FRONTEND_DIRTY;
            m_pv->dwDeviceFlags &= ~(D3DDEV_POSITIONINCAMERASPACE |
                                     D3DDEV_NORMALINCAMERASPACE);
            m_dwRuntimeFlags |= D3DRT_SHADERDIRTY;
        };
    void DisplayStats();
    void SetRenderStateInternal(D3DRENDERSTATETYPE, DWORD);
    HRESULT Initialize(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt);
    HRESULT D3DFE_Create();
    void D3DFE_Destroy();
    void ValidateDraw2(D3DPRIMITIVETYPE primType, UINT StartVertex,
                       UINT PrimitiveCount, UINT NumVertices,
                       BOOL bIndexPrimitive, UINT StartIndex = 0);
#if DBG
    void ValidateRTPatch();
#endif // DBG

#if DBG
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif
public:
    // IDirect3DDevice8 Methods
    HRESULT D3DAPI GetViewport(D3DVIEWPORT8*);
    HRESULT D3DAPI GetMaterial(D3DMATERIAL8*);
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI GetLight(DWORD, D3DLIGHT8*);
    HRESULT D3DAPI GetLightEnable(DWORD dwLightIndex, BOOL*);
    HRESULT D3DAPI GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    HRESULT D3DAPI GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE,
                                        LPDWORD);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);

    HRESULT D3DAPI SetClipStatus(CONST D3DCLIPSTATUS8*);
    HRESULT D3DAPI GetClipStatus(D3DCLIPSTATUS8*);
    HRESULT D3DAPI ProcessVertices(UINT SrcStartIndex, UINT DestIndex,
                                   UINT VertexCount,
                                   IDirect3DVertexBuffer8 *DestBuffer,
                                   DWORD Flags);
    HRESULT D3DAPI GetVertexShaderConstant(DWORD dwRegisterAddress,
                                           LPVOID lpvConstantData,
                                           DWORD dwConstantCount);
    HRESULT D3DAPI GetPixelShaderConstant(DWORD dwRegisterAddress,
                                          LPVOID lpvConstantData,
                                          DWORD dwConstantCount);
    HRESULT D3DAPI GetVertexShader(LPDWORD pdwHandle);
    HRESULT D3DAPI GetPixelShader(LPDWORD pdwHandle);
};
//---------------------------------------------------------------------
//  macros to characterize device
//

#define IS_DX7HAL_DEVICE(lpDevI) ((lpDevI)->GetDDIType() >= D3DDDITYPE_DX7)
#define IS_DX8HAL_DEVICE(lpDevI) ((lpDevI)->GetDDIType() >= D3DDDITYPE_DX8)
#define IS_FPU_SETUP(lpDevI) ((lpDevI)->m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_FPUSETUP )
#define IS_HAL_DEVICE(lpDevI) ((lpDevI)->GetDeviceType() == D3DDEVTYPE_HAL)
#define IS_HEL_DEVICE(lpDevI) ((lpDevI)->GetDeviceType() == D3DDEVTYPE_EMULATION)
#define IS_REF_DEVICE(lpDevI) ((lpDevI)->GetDeviceType() == D3DDEVTYPE_REF)

#endif
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __D3DFLOAT__
#define __D3DFLOAT__

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((int)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];

__inline int QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(int *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((float)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec) ((float) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec) ((float)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#include <limits.h>
#if defined(i386)
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX	   \
				 ? LONG_MAX				           \
				 : (f) < LONG_MIN			       \
				 ? LONG_MIN				           \
                                 : (int)(f))
#else
#define SAFE_FLOAT_TO_INT(f)    ((int)(f))
#endif

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\d3dmem.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dmem.h
 *  Content:    Direct3D memory access include file
 *
 ***************************************************************************/
#ifndef _D3DMEM_H_
#define _D3DMEM_H_

#include "vbuffer.hpp"

class CD3DHal;

 /*
 * Register a set of functions to be used in place of malloc
 * and free for memory allocation.  The functions D3DMalloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI      D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc
 */
VOID D3DAPI     D3DFree(LPVOID p);

HRESULT MallocAligned(void** p_return, size_t size);
void FreeAligned(void* p);

#define __USEGLOBALNEWANDDELETE

#ifndef __USEGLOBALNEWANDDELETE
/* Base class for all D3D classes to use our special allocation functions everywhere */
class CD3DAlloc
{
public:
    void* operator new(size_t s) const
    {
        void *p;
        MallocAligned(&p,s);
        return p;
    };
    void operator delete(void* p) const
    {
        FreeAligned(p);
    };
};

#define D3DNEW CD3DAlloc::new
#define D3DDELETE CD3DAlloc::delete
#else
void* operator new(size_t s);
void operator delete(void* p);
#define D3DNEW ::new
#define D3DDELETE ::delete
#endif
//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//
class CAlignedBuffer32
{
public:
    CAlignedBuffer32()  
    {
        size = 0; 
        allocatedBuf = 0; 
        alignedBuf = 0;
    }
    ~CAlignedBuffer32() 
    {
        if (allocatedBuf) 
            D3DFree(allocatedBuf);
    }
    // Returns aligned buffer address
    LPVOID GetAddress() 
    {
        return alignedBuf;
    }
    // Returns aligned buffer size
    DWORD GetSize() 
    {
        return size;
    }
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
    {
        if (dwSize > size)
            return Grow(dwSize + 1024);
        else
            return D3D_OK;
    }
protected:
    LPVOID allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
};

// Forward declarations
class CD3DHal;
class CD3DHalDP2;


#endif //_D3DMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\ddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   ddi.h
 *  Content:    Direct3D DDI encapsulation implementations
 *
 *
 ***************************************************************************/

#ifndef _DDI_H
#define _DDI_H

#include "ddibase.h"

class CVertexBuffer;
class CCommandBuffer;
class CTLStreamRO;
class CTLIndexStreamRO;
class CD3DDDIDX6;

// Number of point sprites in a point sprite batch
const UINT NUM_SPRITES_IN_BATCH = 500;

extern void CD3DDDIDX6_DrawPrimitive(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT StartVertex,
                                     UINT PrimitiveCount);
extern void
CD3DDDIDX8_DrawPrimitive(CD3DBase* pDevice, D3DPRIMITIVETYPE PrimitiveType,
                         UINT StartVertex, UINT PrimitiveCount);
extern void
CD3DDDIDX8_DrawIndexedPrimitive(CD3DBase* pDevice,
                                D3DPRIMITIVETYPE PrimitiveType,
                                UINT BaseVertexIndex,
                                UINT MinIndex, UINT NumVertices,
                                UINT StartIndex, UINT PrimitiveCount);
extern void
CD3DDDITL_DrawIndexedPrimitive(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseVertexIndex,
                               UINT MinIndex,
                               UINT NumVertices, UINT StartIndex,
                               UINT PrimitiveCount);
extern void
CD3DDDIDX6_DrawIndexedPrimitive(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseVertexIndex,
                               UINT MinIndex,
                               UINT NumVertices, UINT StartIndex,
                               UINT PrimitiveCount);

typedef void (*PFN_DRAWPRIMFAST)(CD3DBase* pDevice, D3DPRIMITIVETYPE primType,
                                 UINT StartVertex, UINT PrimitiveCount);
typedef void (*PFN_DRAWINDEXEDPRIMFAST)(CD3DBase* pDevice,
                                        D3DPRIMITIVETYPE PrimitiveType,
                                        UINT BaseVertexIndex,
                                        UINT MinIndex, UINT NumVertices,
                                        UINT StartIndex, UINT PrimitiveCount);
//-----------------------------------------------------------------------------
class CTLStream: public CVStream
{
public:
    CTLStream(BOOL bWriteOnly);
    CTLStream(BOOL bWriteOnly, UINT Usage);
    UINT GetSize()  {return m_dwSize - m_dwUsedSize;}
    void Grow(UINT RequiredSize, CD3DDDIDX6* pDDI);
    void Reset()    {m_dwPrimitiveBase = 0; m_dwUsedSize = 0;}
    DWORD GetVertexSize() {return m_dwStride;}
    void SetVertexSize(DWORD dwVertexSize) {m_dwStride = dwVertexSize;}
    DWORD GetPrimitiveBase() {return m_dwPrimitiveBase;}
    virtual BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    virtual void Unlock();
    virtual void AddVertices(UINT NumVertices)
    {
        m_dwUsedSize = m_dwPrimitiveBase + NumVertices * m_dwStride;
        DXGASSERT(m_dwSize >= m_dwUsedSize);
    }
    virtual void SubVertices(UINT NumVertices)
    {
        DXGASSERT(m_dwUsedSize >= NumVertices * m_dwStride);
        m_dwUsedSize -= NumVertices * m_dwStride;
        DXGASSERT(m_dwSize >= m_dwUsedSize);
    }
    virtual void MovePrimitiveBase(int NumVertices)
    {
        m_dwPrimitiveBase += NumVertices * m_dwStride;
    }
    virtual void SkipVertices(DWORD NumVertices)
    {
        const UINT size = NumVertices * m_dwStride;
        m_dwPrimitiveBase += size;
        m_dwUsedSize = m_dwPrimitiveBase;
        DXGASSERT(m_dwSize >= m_dwUsedSize);
    }
    BOOL CheckFreeSpace(UINT size) {return (m_dwSize - m_dwUsedSize) >= size;}
protected:
    // Number of bytes used in the buffer
    // It is not used by CTLStreamRO
    DWORD   m_dwUsedSize;
    // Offset in bytes from where the current primitive starts
    DWORD   m_dwPrimitiveBase;
    UINT    m_Usage;
    // TRUE, if buffer is used only for writing
    BOOL    m_bWriteOnly;
#if !DBG
    DWORD   m_dwSize;
#endif
};
//-----------------------------------------------------------------------------
class CTLIndexStream: public CVIndexStream
{
public:
    CTLIndexStream();
    UINT GetSize()  {return m_dwSize - m_dwUsedSize;}
    void Grow(UINT RequiredSize, CD3DDDIDX6* pDDI);
    void Reset()    {m_dwPrimitiveBase = 0; m_dwUsedSize = 0;}
    DWORD GetVertexSize() {return m_dwStride;}
    void SetVertexSize(DWORD dwVertexSize) {m_dwStride = dwVertexSize;}
    DWORD GetPrimitiveBase() {return m_dwPrimitiveBase;}
    virtual BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    BYTE* LockDiscard(UINT NeededSize, CD3DDDIDX6* pDDI);
    virtual void Unlock();
    virtual void AddVertices(UINT NumVertices)
        {
            m_dwUsedSize = m_dwPrimitiveBase + NumVertices * m_dwStride;
            DXGASSERT(m_dwSize >= m_dwUsedSize);
        }
    virtual void SubVertices(UINT NumVertices)
        {
            DXGASSERT(m_dwUsedSize >= NumVertices * m_dwStride);
            m_dwUsedSize -= NumVertices * m_dwStride;
            DXGASSERT(m_dwSize >= m_dwUsedSize);
        }
    virtual void MovePrimitiveBase(int NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
    virtual void SkipVertices(DWORD NumVertices)
        {
            const UINT size = NumVertices * m_dwStride;
            m_dwPrimitiveBase += size;
            m_dwUsedSize = m_dwPrimitiveBase;
            DXGASSERT(m_dwSize >= m_dwUsedSize);
        }
protected:
    // Number of bytes used in the buffer
    // It is not used by CTLStreamRO
    DWORD   m_dwUsedSize;
    // Index of a index, which is the start of the current primitive
    DWORD   m_dwPrimitiveBase;
#if !DBG
    DWORD   m_dwSize;
#endif
};

// This class is used to keep track of what set to a DDI stream
struct CDDIStream
{
    CDDIStream()
        {
            m_pStream = NULL;
            m_dwStride = 0;
            m_pBuf = NULL;
        }
    // Pointer to a stream object
    CVStreamBase*   m_pStream;
    // Stride of the currently set stream
    DWORD       m_dwStride;
    // VB pointer of the currently set stream
    CBuffer    *m_pBuf;
};

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX6                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------
// Flags for dwDP2Flags
//
// This flag is set if the current TLVbuf is write only
const DWORD D3DDDI_TLVBUFWRITEONLY      = 1 << 0;
// This flag is set we pass user memory to the DDI
const DWORD D3DDDI_USERMEMVERTICES      = 1 << 1;

// Set when DrawIndexPrim is called. It is used to check if vertices
// of an indexed primitive were used at all. They could not be used because
// of clipping.
const DWORD D3DDDI_INDEXEDPRIMDRAWN     = 1 << 2;

typedef void (CD3DDDIDX6::* PFN_PROCESSPRIM)(D3DFE_PROCESSVERTICES*,
                                             UINT StartVertex);
class CD3DDDIDX6 : public CD3DDDI
{
public:
    CD3DDDIDX6();
    ~CD3DDDIDX6();

    // Virtual functions -----------------------------------------------
    virtual void Init(CD3DBase* pDevice );
    virtual void SetRenderTarget(CBaseSurface*, CBaseSurface*);
    virtual void FlushStates(BOOL bReturnDriverError=FALSE, BOOL bWithinPrimitive = FALSE);
    virtual void ValidateDevice(LPDWORD lpdwNumPasses);
    virtual void Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
                       D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    virtual HRESULT __declspec(nothrow) LockVB(CDriverVertexBuffer*, DWORD dwFlags);
    virtual HRESULT __declspec(nothrow) UnlockVB(CDriverVertexBuffer*);
    virtual void ClearBatch( BOOL bWithinPrimitive );
    virtual void SceneCapture(BOOL bState);
    // This function is called whe software vertex processing is used
    // Handle should be always legacy
    virtual void SetVertexShader(DWORD dwHandle);
    // This function is called whe hardware vertex processing is used
    virtual void SetVertexShaderHW(DWORD dwHandle);

    virtual void UpdatePalette(DWORD,DWORD,DWORD,PALETTEENTRY*);
    virtual void SetPalette(DWORD,DWORD,CBaseTexture*);
    // Used to pick a function to process (indexed) primitive
    // The picking is based on
    //      D3DDEV_DONOTCLIP
    //      FVF_TRANSFORMED(m_pDevice->m_dwCurrentShaderHandle)
    //      D3DDEV_DOPOINTSPRITEEMULATION
    virtual void PickProcessPrimitive();
    virtual void SetTSS(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    virtual void DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                 UINT PrimitiveCount);
    virtual void DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                        UINT MinVertexIndex,
                                        UINT NumVertices,
                                        UINT PrimitiveCount);
    // Returns max number of renderstates, handled by the DDI
    virtual D3DRENDERSTATETYPE GetMaxRenderState()
    {return D3DRENDERSTATE_CLIPPING;}
    // Returns max number of texture stage states, handled by the DDI
    virtual D3DTEXTURESTAGESTATETYPE GetMaxTSS()
    {return D3DTSS_TEXTURETRANSFORMFLAGS;}
    // Returns TRUE if the device supports T&L
    virtual BOOL CanDoTL() {return FALSE;}
    // DDI can directly accept index buffer
    virtual BOOL AcceptIndexBuffer() {return FALSE;}
    virtual BOOL CanDoTLVertexClipping() {return FALSE;}
    // Process primitive with untransformed vertices and with no clipping
    virtual void ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    virtual void ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv,
                                         UINT StartVertex);
    // Process primitive with untransformed vertices and with clipping
    virtual void ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv,
                                   UINT StartVertex);
    virtual void ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv,
                                          UINT StartVertex);
    virtual void SetViewport(CONST D3DVIEWPORT8*);
    virtual void StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                             DWORD dwStartVertex);
    virtual LPVOID StartPrimTL(D3DFE_PROCESSVERTICES*, DWORD dwVertexPoolSize,
                               BOOL bWriteOnly);
    virtual void StartPointSprites();
    virtual void EndPointSprites();

    // Virtual functions: Empty implementations ------------------------
    virtual void SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*){}
    virtual void MultiplyTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*){}
    virtual void SetMaterial(CONST D3DMATERIAL8*){}
    virtual void CreateLight(DWORD dwLightIndex) {}
    virtual void SetLight(DWORD dwLightIndex, CONST D3DLIGHT8*){}
    virtual void LightEnable(DWORD dwLightIndex, BOOL){}
    virtual void SetClipPlane(DWORD dwPlaneIndex,
                              CONST D3DVALUE* pPlaneEquation){}
    virtual void WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt) {}
    // Used to notify DDI that a vertex buffer was released. If the DDI keeps a
    // pointer to the VB it should be zeroed
    virtual void VBReleased(CBuffer *pBuf) {}
    // Used to notify DDI that amn index buffer was released. If the DDI keeps
    // a pointer to the IB it should be zeroed
    virtual void VBIReleased(CBuffer *pBuf) {}
    virtual void ResetVertexShader() {}
    virtual void SetVertexShaderConstant(DWORD dwRegisterAddress,
                                         CONST VOID* lpvConstantData,
                                         DWORD dwConstantCount){}
    virtual void SetPixelShaderConstant(DWORD dwRegisterAddress,
                                        CONST VOID* lpvConstantData,
                                        DWORD dwConstantCount){}

    // Virtual functions: Unsupported implementations ------------------
    virtual void SetPriority(CResource*, DWORD dwPriority)
    { NotSupported("SetPriority");}
    virtual void SetTexLOD(CBaseTexture*, DWORD dwLOD)
    { NotSupported("SetTexLOD");}
    virtual void TexBlt(DWORD dwDst, DWORD dwSrc,
                        LPPOINT p, RECTL *r)
    { NotSupported("TexBlt");}
    virtual void VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc,
                        DWORD dwDestX, DWORD dwDestY, DWORD dwDestZ,
                        D3DBOX *pBox)
    { NotSupported("VolBlt");}
    virtual void BufBlt(CBuffer *lpDst, CBuffer* lpSrc,
                        DWORD dwOffset, D3DRANGE* pRange)
    { NotSupported("BufBlt");}
    virtual void AddDirtyRect(DWORD dwHandle, 
                              CONST RECTL *pRect)
    { NotSupported("AddDirtyRect");}
    virtual void AddDirtyBox(DWORD dwHandle, 
                             CONST D3DBOX *pBox)
    { NotSupported("AddDirtyRect");}
    virtual void InsertStateSetOp(DWORD dwOperation, DWORD dwParam,
                                  D3DSTATEBLOCKTYPE sbt)
    { NotSupported("InsertStateSetOp");}
    virtual void CreateVertexShader(CONST DWORD* pdwDeclaration,
                                    DWORD dwDeclarationSize,
                                    CONST DWORD* pdwFunction,
                                    DWORD dwFunctionSize,
                                    DWORD dwHandle,
                                    BOOL bLegacyFVF)
    { NotSupported("CreateVertexShader");}
    virtual void DeleteVertexShader(DWORD dwHandle)
    { NotSupported("DeleteVertexShader");}
    virtual void CreatePixelShader(CONST DWORD* pdwFunction,
                                   DWORD dwFunctionSize,
                                   DWORD dwHandle)
    { NotSupported("CreatePixelShader");}
    virtual void SetPixelShader(DWORD dwHandle) {}
    virtual void DeletePixelShader(DWORD dwHandle)
    { NotSupported("DeletePixelShader");}
    virtual void GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct,
                         DWORD dwSize)
    { NotSupported("GetInfo");}
    virtual void DrawRectPatch(UINT Handle, CONST D3DRECTPATCH_INFO *pSurf,
                               CONST FLOAT *pNumSegs)
    { NotSupported("DrawRectPatch");}
    virtual void DrawTriPatch(UINT Handle, CONST D3DTRIPATCH_INFO *pSurf,
                              CONST FLOAT *pNumSegs)
    { NotSupported("DrawTriPatch");}

    // Non Virtual functions -------------------------------------------
    void CreateContext();
    void DestroyContext();
    void SetRenderState(D3DRENDERSTATETYPE, DWORD);
    void FlushStatesReq(DWORD dwReqSize);
    void FlushStatesCmdBufReq(DWORD dwReqSize);
    void SetStreamSource(UINT StreamIndex, CVStream*);
    void SetIndices(CVIndexStream*);
    // Update W range in device. Projection matrix is passed as parameter
    void UpdateWInfo(CONST D3DMATRIX* lpMat);
    // Process points with point sprite expansion
    void ProcessPointSprites(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    // Process primitive with transformed vertices and with clipping
    void ProcessPrimitiveTC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitiveTC(D3DFE_PROCESSVERTICES* pv,
                                   UINT StartVertex);
    void NotSupported(char* msg);
    void BeginScene()
    {
        SceneCapture(TRUE);
    }

    void EndScene();
    void EndPrim(UINT vertexSize);
    void NextSprite(float x, float y, float z, float w, DWORD diffuse,
                    DWORD specular, float* pTexture, UINT TextureSize,
                    float PointSize);

    void AddVertices(UINT NumVertices)
    {
        if (dwDP2VertexCountMask)
        {
            dwDP2VertexCount = max(dwVertexBase + NumVertices, dwDP2VertexCount);
        }
    }
    void SubVertices(UINT NumVertices)
    {
        if (dwDP2VertexCountMask)
        {
            DXGASSERT(dwDP2VertexCount >= NumVertices);
            dwDP2VertexCount -= NumVertices;
        }
    }
    void MovePrimitiveBase(int NumVertices)
    {
        dwVertexBase += NumVertices;
    }
    void SkipVertices(DWORD NumVertices)
    {
        dwVertexBase += NumVertices;
        if (dwDP2VertexCountMask)
            dwDP2VertexCount = max(dwVertexBase, dwDP2VertexCount);
    }
    void SetWithinPrimitive( BOOL bWP ){ m_bWithinPrimitive = bWP; }
    BOOL GetWithinPrimitive(){ return m_bWithinPrimitive; }
    D3DDDITYPE GetDDIType() {return m_ddiType;}
    CD3DBase* GetDevice() {return m_pDevice;}
    ULONG_PTR GetDeviceContext() {return m_dwhContext;}
    virtual PFN_DRAWPRIMFAST __declspec(nothrow) GetDrawPrimFunction()
    {
        return CD3DDDIDX6_DrawPrimitive;
    }
    virtual PFN_DRAWINDEXEDPRIMFAST __declspec(nothrow) GetDrawIndexedPrimFunction()
    {
        return CD3DDDIDX6_DrawIndexedPrimitive;
    }

    // Implementation of base functions ---------------------------------
    // Draw non-indexed primitive
    void DrawPrim(D3DFE_PROCESSVERTICES* pv);
    // Draw point sprites with emulation
    void DrawPrimPS(D3DFE_PROCESSVERTICES* pv);
    // Draw primitive, generated by the clipper
    void DrawClippedPrim(D3DFE_PROCESSVERTICES* pv);
    // Draw indexed primitive
    void DrawIndexPrim(D3DFE_PROCESSVERTICES* pv);

protected:
    // DDI Type
    D3DDDITYPE       m_ddiType;
    CD3DBase*        m_pDevice;
    DWORD            m_dwInterfaceNumber;
    // Driver context
    ULONG_PTR        m_dwhContext;
    // Is it within primitive
    BOOL m_bWithinPrimitive;

    PFN_PROCESSPRIM m_pfnProcessPrimitive;
    PFN_PROCESSPRIM m_pfnProcessIndexedPrimitive;

    // Reserve space in the command buffer. Flush and grow if needed.
    // Returns pointer to where new commands could be inserted
    LPVOID ReserveSpaceInCommandBuffer(UINT ByteCount);
    // Reserve space for a new command in the command buffer. Flush if needed
    // New command is initialized.
    // Returns pointer to where the command data could be inserted
    LPVOID GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize);
    DWORD  GetTLVbufSize() { return TLVbuf_size - TLVbuf_base; }
    DWORD& TLVbuf_Base() { return TLVbuf_base; }
    LPVOID TLVbuf_GetAddress() {return (LPBYTE)alignedBuf + TLVbuf_base;}
    void GrowCommandBuffer(DWORD dwSize);
    void GrowTLVbuf(DWORD growSize, BOOL bWriteOnly);
    void PrepareForClipping(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void StartPrimUserMem(D3DFE_PROCESSVERTICES*, UINT VertexPoolSize);
    inline CVertexBuffer* TLVbuf_GetVBI() { return allocatedBuf; }

#if DBG
    void    ValidateVertex(LPDWORD lpdwVertex);
    virtual void    ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd);
#endif

    static const DWORD dwD3DDefaultCommandBatchSize;

    // Index (relative to the TLVbuf start) of the first vertex of
    // the current primitive
    DWORD   dwVertexBase;
    // Number of vertices in the DP2 vertex buffer
    DWORD dwDP2VertexCount;
    // Mask used to prevent modification of dwDP2VertexCount. This is needed
    // when user calls SetStreamSource with TL vertices and uses multiple
    // DrawPrimitive calls with different StartVertex. dwDP2VertexCount should
    // be always set to the number of vertices in the user vertex buffer.
    DWORD dwDP2VertexCountMask;

    // This is the VB interface corresponding to the dp2data.lpDDVertex
    // This is kept so that the VB can be released when done
    // which cannot be done from just the LCL pointer which is lpDDVertex
    CVertexBuffer* lpDP2CurrBatchVBI;

    DWORD TLVbuf_size;
    DWORD TLVbuf_base;

#ifdef VTABLE_HACK
    // Cached dwFlags for fast path
    DWORD dwLastFlags;
    // Last VB used in a call that involved D3D's FE.
    CVertexBuffer* lpDP2LastVBI;
#endif
    DWORD dwDP2CommandBufSize;
    DWORD dwDP2CommandLength;

    // Cache line should start here

    // Pointer to the actual data in CB1
    LPVOID lpvDP2Commands;

    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    // Perf issue: replace the below 3 fields by a 32 bit D3DHAL_DP2COMMAND struct
    WORD wDP2CurrCmdCnt; // Mirror of Count field if the current command
    BYTE bDP2CurrCmdOP;  // Mirror of Opcode of the current command
    BYTE bDummy;         // Force DWORD alignment of next member

    D3D8_DRAWPRIMITIVES2DATA dp2data;

    // The buffer we currently batch into
    CCommandBuffer *lpDDSCB1;
    CVertexBuffer  *allocatedBuf;
    LPVOID alignedBuf;
    CVertexBuffer  *m_pNullVB;

    // Count read/write <-> write-only transistions
    DWORD dwTLVbufChanges;
    // Flags specific to DP2 device
    DWORD dwDP2Flags;

    // This stuff is allocated by the NT Kernel. Need to keep
    // it around to pass it to all the DP2 calls. Kernel validates
    // this pointer.
    WORD *lpwDPBuffer;
    // Used to offset indices in DrawIndexPrim
    DWORD m_dwIndexOffset;

    // Data to draw point sprites

    // Pointer where to insert the next point sprite vertex
    BYTE*   m_pCurSpriteVertex;
    // Pointer where to insert the next point sprite index
    WORD*   m_pCurPointSpriteIndex;
    // Number of sprites in the current point sprite batch
    UINT    m_CurNumberOfSprites;
    // When we need to expand points to quads, we use this stream to process
    // vertices into
    CTLStream*  m_pPointStream;

    // These is used to keep the original dwVertexBase and dwDP2VertexCount,
    // when processing point sprites
    DWORD   m_dwVertexBasePS;
    DWORD   m_dwVertexCountPS;
    // Output vertex FVF for point sprite emulation
    DWORD   m_dwVIDOutPS;
    // Output vertex size for point sprites emulation
    DWORD   m_dwOutputSizePS;

    DWORD dwDPBufferSize;
    // Vertex shader handle currently set to the device driver
    DWORD   m_CurrentVertexShader;
    // Currently used stream 0
    CVStream* m_pStream0;
    // Currently used index stream
    CVIndexStream* m_pIStream;

#if DBG
    // Vertex size, computed from the vertex shader
    DWORD   m_VertexSizeFromShader;
    // Switches on/off command and vertices validation
    BOOL  m_bValidateCommands;
#endif
    friend class CD3DHal;
    friend void CD3DDDIDX6_DrawPrimitive(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE primType,
                               UINT StartVertex,
                               UINT PrimitiveCount);
    friend void CD3DDDIDX6_DrawPrimitiveFast(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE primType,
                               UINT StartVertex,
                               UINT PrimitiveCount);
    friend void CD3DDDIDX6_DrawIndexedPrimitive(CD3DBase* pDevice,
                                         D3DPRIMITIVETYPE PrimitiveType,
                                         UINT BaseVertexIndex,
                                         UINT MinIndex, UINT NumVertices,
                                         UINT StartIndex, UINT PrimitiveCount);
    friend void CD3DDDIDX6_DrawIndexedPrimitiveFast(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT BaseVertexIndex,
                                     UINT MinIndex, UINT NumVertices,
                                     UINT StartIndex, UINT PrimitiveCount);
    friend void CD3DHal_DrawPrimitive(CD3DBase* pBaseDevice,
                                      D3DPRIMITIVETYPE PrimitiveType,
                                      UINT StartVertex, UINT PrimitiveCount);
    friend void CD3DHal_DrawIndexedPrimitive(CD3DBase* pBaseDevice,
                                  D3DPRIMITIVETYPE PrimitiveType,
                                  UINT BaseIndex,
                                  UINT MinIndex, UINT NumVertices,
                                  UINT StartIndex,
                                  UINT PrimitiveCount);
};

typedef CD3DDDIDX6 *LPD3DDDIDX6;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX7                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
class CD3DDDIDX7 : public CD3DDDIDX6
{
public:
    CD3DDDIDX7();
    ~CD3DDDIDX7();
    void SetRenderTarget(CBaseSurface*, CBaseSurface*);
    void InsertStateSetOp(DWORD dwOperation, DWORD dwParam,
                          D3DSTATEBLOCKTYPE sbt);
    void Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
               D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    void TexBlt(DWORD dwDst, DWORD dwSrc, LPPOINT p, RECTL *r);
    void SetPriority(CResource*, DWORD dwPriority);
    void SetTexLOD(CBaseTexture*, DWORD dwLOD);
    void AddDirtyRect(DWORD dwHandle, CONST RECTL *pRect);
    void AddDirtyBox(DWORD dwHandle, CONST D3DBOX *pBox);
    void UpdatePalette(DWORD,DWORD,DWORD,PALETTEENTRY*);
    void SetPalette(DWORD,DWORD,CBaseTexture*);
    void WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt);
    virtual void SceneCapture(BOOL bState);
    virtual D3DTEXTURESTAGESTATETYPE GetMaxTSS()
        {return (D3DTEXTURESTAGESTATETYPE)(D3DTSS_TEXTURETRANSFORMFLAGS+1);}
};

typedef CD3DDDIDX7 *LPD3DDDIDX7;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDITL                                                               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

class CD3DDDITL : public CD3DDDIDX7
{
public:
    CD3DDDITL();
    ~CD3DDDITL();
    void SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    void SetVertexShader(DWORD dwHandle);
    void SetVertexShaderHW(DWORD dwHandle);
    void SetViewport(CONST D3DVIEWPORT8*);
    void SetMaterial(CONST D3DMATERIAL8*);
    void SetLight(DWORD dwLightIndex, CONST D3DLIGHT8*);
    void LightEnable(DWORD dwLightIndex, BOOL);
    void CreateLight(DWORD dwLightIndex);
    void SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);
    D3DRENDERSTATETYPE GetMaxRenderState()
        {return (D3DRENDERSTATETYPE)(D3DRENDERSTATE_CLIPPLANEENABLE + 1);}
    BOOL CanDoTL() {return TRUE;}
    BOOL CanDoTLVertexClipping() {return TRUE;}
    void CreateVertexShader(CONST DWORD* pdwDeclaration,
                            DWORD dwDeclarationSize,
                            CONST DWORD* pdwFunction,
                            DWORD dwFunctionSize,
                            DWORD dwHandle,
                            BOOL bLegacyFVF);
};

typedef CD3DDDITL *LPD3DDDITL;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

class CD3DDDIDX8 : public CD3DDDIDX7
{
public:
    CD3DDDIDX8();
    ~CD3DDDIDX8();
    void Init(CD3DBase* pDevice );
    void SetDummyData();
    void FlushStates(BOOL bReturnDriverError=FALSE, BOOL bWithinPrimitive = FALSE);
    void ClearBatch( BOOL bWithinPrimitive );
    HRESULT __declspec(nothrow) LockVB(CDriverVertexBuffer*, DWORD dwFlags);
    HRESULT __declspec(nothrow) UnlockVB(CDriverVertexBuffer*);
    D3DRENDERSTATETYPE GetMaxRenderState();
    D3DTEXTURESTAGESTATETYPE GetMaxTSS()
        {return (D3DTEXTURESTAGESTATETYPE)(D3DTSS_RESULTARG+1);}
    void SetTSS(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    void SetVertexShader(DWORD dwHandle);
    void SetVertexShaderHW(DWORD dwHandle);
    void ValidateDevice(LPDWORD lpdwNumPasses);
    void VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox);
    void BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                D3DRANGE* pRange);
    void CreatePixelShader(CONST DWORD* pdwFunction,
                            DWORD dwFunctionSize,
                            DWORD dwHandle);
    void SetPixelShader(DWORD dwHandle);
    void DeletePixelShader(DWORD dwHandle);
    void SetPixelShaderConstant(DWORD dwRegisterAddress,
                                CONST VOID* lpvConstantData,
                                DWORD dwConstantCount);
    void DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount);
    void DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                UINT MinVertexIndex,
                                UINT NumVertices,
                                UINT PrimitiveCount);
    BOOL AcceptIndexBuffer() {return TRUE;}
    BOOL CanDoTLVertexClipping() {return TRUE;}
    void DrawRectPatch(UINT Handle, CONST D3DRECTPATCH_INFO *pSurf,
                       CONST FLOAT *pNumSegs);
    void DrawTriPatch(UINT Handle, CONST D3DTRIPATCH_INFO *pSurf,
                      CONST FLOAT *pNumSegs);

    void PickProcessPrimitive();
    // Process primitive with untransformed vertices and with no clipping
    void ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    // Process primitive with untransformed vertices and with clipping
    void ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    // Process primitive with transformed vertices
    void ProcessPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);

    void StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                     DWORD dwStartVertex);
    LPVOID StartPrimTL(D3DFE_PROCESSVERTICES*, DWORD dwVertexPoolSize,
                       BOOL bWriteOnly);
    void DrawPrim(D3DFE_PROCESSVERTICES* pv);
    void DrawIndexPrim(D3DFE_PROCESSVERTICES* pv);
    void DrawClippedPrim(D3DFE_PROCESSVERTICES* pv);
    void VBReleased(CBuffer *pBuf)
        {
            if (m_pDDIStream[0].m_pBuf == pBuf)
                m_pDDIStream[0].m_pBuf = NULL;
        }
    void VBIReleased(CBuffer *pBuf)
        {
            if (m_pDDIStream[__NUMSTREAMS].m_pBuf == pBuf)
                m_pDDIStream[__NUMSTREAMS].m_pBuf = NULL;
        }
    void AddVertices(UINT NumVertices)
        {
            m_pCurrentTLStream->AddVertices(NumVertices);
        }
    void MovePrimitiveBase(int NumVertices)
        {
            m_pCurrentTLStream->MovePrimitiveBase(NumVertices);
        }
    void SkipVertices(DWORD NumVertices)
        {
            m_pCurrentTLStream->SkipVertices(NumVertices);
        }
    // Returns offset in bytes of the start vertex of the current primitive in
    // the current TL stream
    DWORD GetCurrentPrimBase()
        {
            return m_pCurrentTLStream->GetPrimitiveBase();
        }

    void ResetVertexShader()
    {
        m_CurrentVertexShader = 0;
#if DBG
        m_VertexSizeFromShader = 0;
#endif
    }

    PFN_DRAWPRIMFAST __declspec(nothrow) GetDrawPrimFunction() {return CD3DDDIDX8_DrawPrimitive;}
    PFN_DRAWINDEXEDPRIMFAST __declspec(nothrow) GetDrawIndexedPrimFunction()
    {
        return CD3DDDIDX8_DrawIndexedPrimitive;
    }

protected:
    void StartPointSprites();
    void EndPointSprites();

    void StartIndexPrimVB(CVIndexStream* pStream, UINT StartIndex, UINT IndexSize);
    void UpdateDirtyStreams();
    void InsertStreamSource(CVStream*);
    void InsertStreamSourceUP(DWORD);
    void InsertIndices(CVIndexStream*);
#if DBG
    void ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd);
#endif

    // This array is used to keep track of what stream is set to a DDI stream.
    // __NUMSTREAMS element is used for the indexed DDI stream
    CDDIStream  m_pDDIStream[__NUMSTREAMS+1];
    // Stream for TL vertices, which are the result of the front-end pipeline
    CTLStream*  m_pTLStream;
    // Stream for TL vertices, which are the result of the front-end pipeline
    // This is write-only stream
    CTLStream*  m_pTLStreamW;
    // Stream for TL vertices, generated by the clipper. Write-only stream
    CTLStream*  m_pTLStreamClip;
    // Read-only stream. Used with user provided VBs
    CTLStreamRO*  m_pTLStreamRO;
    // Points to the current TL stream. This could be NULL.
    CTLStream*  m_pCurrentTLStream;
    // Points to the current index stream. This could be NULL.
    CTLIndexStream*  m_pCurrentIndexStream;
    // Internal index stream. Used to store indices during clipping
    CTLIndexStream*  m_pIndexStream;
    // Read-only index stream. Used with user provided VBs
    CTLIndexStreamRO*  m_pTLIndexStreamRO;

    // This is a dummy buffer allocated for DP2 call to pass through
    // the kernel.
    VOID*  m_pvDummyArray;
    static const DWORD  m_dwDummyVertexLength;
    static const DWORD  m_dwDummyVertexSize;

    friend void CD3DDDIDX8_DrawPrimitive(CD3DBase* pDevice,
                                         D3DPRIMITIVETYPE PrimitiveType,
                                         UINT StartVertex, UINT PrimitiveCount);
    friend void CD3DDDIDX8_DrawIndexedPrimitive(CD3DBase* pDevice,
                                    D3DPRIMITIVETYPE PrimitiveType,
                                    UINT BaseVertexIndex,
                                    UINT MinIndex, UINT NumVertices,
                                    UINT StartIndex, UINT PrimitiveCount);
};

typedef CD3DDDIDX8 *LPD3DDDIDX8;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8TL                                                            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

class CD3DDDIDX8TL : public CD3DDDIDX8
{
public:
    CD3DDDIDX8TL();
    ~CD3DDDIDX8TL();
    void SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    void MultiplyTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    void SetViewport(CONST D3DVIEWPORT8*);
    void SetMaterial(CONST D3DMATERIAL8*);
    void SetLight(DWORD dwLightIndex, CONST D3DLIGHT8*);
    void LightEnable(DWORD dwLightIndex, BOOL);
    void CreateLight(DWORD dwLightIndex);
    void SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);

    void CreateVertexShader(CONST DWORD* pdwDeclaration,
                            DWORD dwDeclarationSize,
                            CONST DWORD* pdwFunction,
                            DWORD dwFunctionSize,
                            DWORD dwHandle,
                            BOOL bLegacyFVF);
    void DeleteVertexShader(DWORD dwHandle);
    void SetVertexShaderConstant(DWORD dwRegisterAddress,
                                 CONST VOID* lpvConstantData,
                                 DWORD dwConstantCount);
    BOOL CanDoTL() {return TRUE;}
    BOOL AcceptIndexBuffer() {return TRUE;}
};

typedef CD3DDDIDX8TL *LPD3DDDIDX8TL;

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\d3dtempl.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dtempl.hpp
 *  Content:    Direct3D templates include file
 *
 *
 ***************************************************************************/
#ifndef __D3DTEMPL_HPP
#define __D3DTEMPL_HPP

#include <d3dutil.h>
#include "d3dmem.h"

//--------------------------------------------------------------------------
//
// Template for growable arrays
//
//--------------------------------------------------------------------------
template <class ARRAY_ELEMENT>
class GArrayT 
{
public:
    GArrayT() 
    {
        m_pArray = NULL;
        m_dwArraySize = 0;
        m_dwGrowSize = 8;
    }
    
    ~GArrayT()
    {
        if( m_pArray ) 
        {
            DDASSERT( (m_dwArraySize != 0) && (m_pArray != NULL) );
            delete[] m_pArray;
        }
        else
        {
            DDASSERT( (m_dwArraySize == 0) && (m_pArray == NULL) );
        }
    }

    LPVOID GetArrayPointer() const {return m_pArray;}
    
    virtual void SetGrowSize( DWORD dwGrowSize)
    {
         m_dwGrowSize = dwGrowSize;
    }
    
#if 0
    virtual HRESULT Init( DWORD dwInitialSize, DWORD dwGrowSize)
    {
         m_pArray = AllocArray( dwInitialSize );
         if( m_pArray == NULL ) return E_OUTOFMEMORY;
         m_dwArraySize = dwInitialSize;
         m_dwGrowSize = dwGrowSize;
         return S_OK;
    }
#endif
    
    virtual HRESULT Grow( DWORD dwIndex )
    {
        if( dwIndex < m_dwArraySize ) return S_OK;
        DWORD dwNewArraySize = m_dwArraySize;
        while( dwNewArraySize <= dwIndex ) dwNewArraySize += m_dwGrowSize;
        ARRAY_ELEMENT *pNewArray = AllocArray( dwNewArraySize );
        if( pNewArray == NULL ) return E_OUTOFMEMORY;
        
        for( DWORD i = 0; i<m_dwArraySize; i++ )
        {
            pNewArray[i] = m_pArray[i];
            m_pArray[i].m_pObj = NULL; // To prevent deleting the object
        }
        
        delete[] m_pArray;
        m_pArray = pNewArray;
        m_dwArraySize = dwNewArraySize;
        return S_OK;
    }
    
    virtual ARRAY_ELEMENT *AllocArray( DWORD dwSize ) const
    {
        return new ARRAY_ELEMENT[dwSize];
    }
    
    virtual ARRAY_ELEMENT& operator []( DWORD dwIndex ) const
    {
        DDASSERT(dwIndex < m_dwArraySize);
        return m_pArray[dwIndex];
    }

    virtual BOOL Check( DWORD dwIndex ) const
    {
        return (dwIndex < m_dwArraySize);
    }
    
    virtual DWORD GetSize() const
    {
        return m_dwArraySize;
    }
    
    virtual DWORD GetGrowSize() const
    {
        return m_dwGrowSize;
    }
    
protected:
    ARRAY_ELEMENT *m_pArray;
    DWORD          m_dwArraySize;
    DWORD          m_dwGrowSize;
};

#endif //__D3DTEMPL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\d3ditype.h ===
//----------------------------------------------------------------------------
//
// d3ditype.h
//
// Standard types and supporting declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DITYPE_H_
#define _D3DITYPE_H_

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

// Sized types.
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

// Basic float types.
typedef float                   FLOAT;
//typedef double                  DOUBLE;

typedef FLOAT                  *PFLOAT;
typedef DOUBLE                 *PDOUBLE;

typedef float D3DVALUE;

typedef struct _D3DVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} D3DVECTORH, *LPD3DVECTORH;

// Max point size when D3D does point size emulation
const DWORD __MAX_POINT_SIZE = 64;

#endif // #ifndef _D3DITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\debugmon.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// debugmon.hpp
//
// Direct3D Debug Monitor
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _DEBUGMON_HPP
#define _DEBUGMON_HPP

#include "d3ddm.hpp"

//////////////////////////////////////////////////////////////////////////
//
// Shared Memory object - creates or attaches to shared memory identified
// by character string name and of the size (in bytes) provided to
// constructor
//
//////////////////////////////////////////////////////////////////////////
class D3DSharedMem
{
private:
    HANDLE  m_hFileMap;
    void*   m_pMem;
    BOOL    m_bAlreadyExisted;
public:
//
//  6/20/2000(RichGr) - IA64: Change first parameter from int to INT_PTR so that
//     all parameters are the same length.  This is needed to make the va_start 
//     macro work correctly.
    D3DSharedMem(INT_PTR cbSize, const char* pszFormat, ...);
    ~D3DSharedMem(void);
    void* GetPtr(void) { return m_pMem; }
    BOOL  AlreadyExisted(void) { return m_bAlreadyExisted; }
};
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////
class D3DDebugMonitor
{
public:
    D3DDebugMonitor( void );
    ~D3DDebugMonitor( void );

    // communications between target and monitor
    DebugTargetContext*         m_pTgtCtx;
    const DebugMonitorContext*  m_pMonCtx;
    void*                       m_pCmdData;
    HANDLE                      m_hTgtEventBP;
    HANDLE                      m_hTgtEventAck;
    HANDLE                      m_hMonEventCmd;
    BOOL                        m_bDbgMonConnectionEnabled;

    HRESULT AttachToMonitor( int iMon );
    void    DetachMonitorConnection( void );
    BOOL    CheckLostMonitorConnection( void );

    inline BOOL     MonitorConnected( void ) { return (NULL != m_pMonCtx); }
    inline UINT32   MonitorEventBP( void )
        { return MonitorConnected() ? (m_pMonCtx->EventBP) : (0x0); }

    BOOL    IsEventBreak( UINT32 EventType );
    HRESULT MonitorBreakpoint( void );

    virtual HRESULT ProcessMonitorCommand( void ) = 0;

    inline void     StateChanged( UINT32 WhichState )
        { m_pTgtCtx->StateChanged |= WhichState; }

protected:
    // shared-memory segments for the communications resources
    D3DSharedMem*                  m_pMonCtxSM;
    D3DSharedMem*                  m_pTgtCtxSM;
    D3DSharedMem*                  m_pCmdDataSM;

};

///////////////////////////////////////////////////////////////////////////////
#endif // _DEBUGMON_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\ids8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ids.h
 *  Content:    DirectDraw resource ids
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-sep-95  toddla  created
 *   20-sep-95	craige	add IDS_PRIMARYDISPLAY
 *
 ***************************************************************************/

// string ids
#define IDS_TITLE           100     // dialog box title
#define IDS_DONTWORK_BPP    101     // you must be in 256 color mode or higher.
#define IDS_PRIMARYDISPLAY  102     // Primary Display Driver
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\ddibase.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   ddi.h
 *  Content:    Direct3D DDI encapsulation implementations
 *
 *
 ***************************************************************************/

#ifndef _DDIBASE_H
#define _DDIBASE_H

#include "d3ditype.h"
#include "d3dhalp.h"

extern char *HrToStr(HRESULT hr);

class CD3DBase;

struct _D3D8_DEVICEDATA;
typedef struct _D3D8_DEVICEDATA D3D8_DEVICEDATA;

class CSurface;
class D3DFE_PROCESSVERTICES;
class CBaseTexture;
class CDriverVertexBuffer;
struct CVStream;
struct CVIndexStream;
class CBaseSurface;
class CResource;
class CBuffer;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDI                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
class CD3DDDI
{
protected:

    // DrawIndexedStream params
    UINT        m_StartIndex;
    UINT        m_MinVertexIndex;
    UINT        m_NumVertices;
    int         m_BaseVertexIndex;
    
public:
    CD3DDDI();
    virtual ~CD3DDDI();

    //++++++++++++++ Interface which the PSGP is using ++++++++++++++++++++++++
    //
    // These functions are used when vertices are processed by D3D pipeline.

    // Internal driver buffers
    // D3D has three driver buffers: TL buffer, which contains primitive 
    // vertices, command buffer, where drawing commands are recorded, and clip
    // buffer, where vertices, generated by clipper, are recorded. D3D maintains 
    // count of vertices in the TL buffer (TL buffer vertex count) and an index 
    // of the first vertex of the current primitive (primitive base). When a 
    // drawing command is recorded, D3D records the current primitive base.
    // All drawing commands expect that vertices have already been copied to the
    // TL buffer (excluding DrawClippedPrim).
    //
    // If a flush occurs during recording a command, vertex buffer is not 
    // flushed, because m_bWithinPrimitive is set to TRUE. So primitive base
    // and TL vertex count stay the same.
    //
    // When PSGP processes and clip a non-indexed primitive, it should update
    // primitive base and TL vertex count, using SkipVertices and 
    // MovePrimitiveBase functions. AddVertices is not used, because DrawPrim()
    // functions calls AddVertices and MovePrimitiveBase inself.

    // Draw unclipped part of non-indexed primitive
    //
    //   Parameters:
    //      pv->lpvOut          - pointer to the first vertex
    //      pv->primType        - primitiveType;                                
    //      pv->dwNumVertices   - vertexCount
    //      pv->dwNumPrimitives - number of primitives
    //  Remarks:
    //      This function is used when vertices are processed by D3D pipeline.
    //      The function inserts a new command to the command buffer.
    //      Primitive base is increased by the number of vertices.
    //      TL buffer vertex count is increased by the number of vertices.
    //
    virtual void DrawPrim(D3DFE_PROCESSVERTICES* pv)                = 0;

    // Draw unclipped part of an indexed primitive
    //
    //   Parameters:
    //      pv->lpvOut          - pointer to the first vertex of the whole
    //                            primitive
    //      pv->primType        - primitiveType                    
    //      pv->dwNumPrimitives - number of primitives
    //      pv->lpwIndices      - pointer to the first index                                     
    //      pv->dwNumIndices    - number of indices                                  
    //      pv->dwIndexSize     - size of an index in bytes (2 or 4)
    //  Remarks:
    //      Vertices must be already copied to the TL buffer.
    //      The function inserts a new command to the command buffer.
    //      Indices are copied to the index buffer. Vertices must be in the TL
    //      buffer already.
    //      Primitive base and TL buffer vertex count are not changed.
    //
    virtual void DrawIndexPrim(D3DFE_PROCESSVERTICES* pv)           = 0;
    
    // Draw a primitive, generated by clipper
    //
    //   Parameters:
    //      pv->lpvOut          - pointer to the first vertex of the primitive
    //      pv->primType        - primitiveType
    //      pv->dwNumVertices   - vertex count
    //      pv->dwNumPrimitives - number of primitives
    //  Remarks:
    //      Vertices are copied to the clipping buffer
    //      The function inserts a new command to the command buffer.
    //      Primitive base and TL buffer vertex count are not changed.
    //
    virtual void DrawClippedPrim(D3DFE_PROCESSVERTICES* pv)         = 0;

    // Increase TL buffer vertex count
    //
    //  The function addes the number of vertices to the current primitive 
    //  base. So when it is called several times without moving the primitive
    //  base, only the last call will have effect.
    //  This function should be called after vertices are added to the
    //  TL buffer, but before a drawing function is called.
    //
    virtual void AddVertices(UINT NumVertices)                      = 0;

    // Decrease TL buffer vertex count
    //
    //  This function should be called after vertices are added to the
    //  TL buffer, but before a drawing function is called.
    //
    virtual void SubVertices(UINT NumVertices)                      = 0;

    // Update primitive base
    //
    // It should be called when some vertices are skipped because of clipping.
    // NumVertices could be negative, 
    //
    virtual void MovePrimitiveBase(int NumVertices)                 = 0;

    // Update primitive base and TL buffer vertex count
    //
    // Call this function when some vertices in the vertex buffer are used
    // for clipping and should be skipped
    //
    virtual void SkipVertices(DWORD NumVertices)                    = 0;

    void SetIndexedPrimParams(UINT StartIndex, UINT MinIndex, UINT NumVertices,
                              UINT BaseVertexIndex)
    {
        m_StartIndex = StartIndex;
        m_MinVertexIndex = MinIndex;
        m_NumVertices = NumVertices;
        m_BaseVertexIndex = BaseVertexIndex;
    }
    
    // Returns offset in bytes of the start vertex of the current primitive in
    // the current TL stream
    virtual DWORD GetCurrentPrimBase() {return 0;}
    //-------------------- End PSGP functions ---------------------------------
};
typedef CD3DDDI *LPD3DDDI;


#endif /* _D3DIBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\testfile.h ===
//----------------------------------------------------------------------------
//
// testfile.h
//
// Defines for file with test data.
//
// File format:
//      File contains chunks of data. Each chunk has four-byte ID, four-byte data size field and
//      "size" number of bytes of data.
//      Chunks:
//          ID          Meaning           Data
//          1       Scene capture       DWORD flags
//          2       Render state        DWORD states count
//                                      States (D3DSTATE*count)
//          3       Render primitive    DWORD status
//                                      D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      D3DINSTRUCTION
//                                        Primitive record (D3DPOINT, D3DLINE ...)
//                                        Primitive vertices (TLVERTEX)
//                                        ...
//          4       Draw one primitive  D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//          5       Draw one indexed    D3DPRIMITIVETYPE primitive type
//                      primitive       DWORD number of vertices
//                                      DWORD number of indices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//                                      Indices (WORD)
//          6       Draw primitives     The same as DDI data, but without 32 byte
//                                      alignment.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTFILE_H_
#define _TESTFILE_H_

// TF stands for "TestFile"
typedef struct
{
    DWORD id;           // record ID
    DWORD size;         // size of data in bytes (exclude size of REC_HEADER)
} TF_HEADER;

// ID for test file records
const DWORD TFID_SCENECAPTURE               = 1;
const DWORD TFID_RENDERSTATE                = 2;
const DWORD TFID_RENDERPRIMITIVE            = 3;
const DWORD TFID_DRAWONEPRIMITIVE           = 4;
const DWORD TFID_DRAWONEINDEXEDPRIMITIVE    = 5;
const DWORD TFID_DRAWPRIMITIVES             = 6;
const DWORD TFID_DRAWPRIMITIVES2            = 7;

// Fixed size record headers
typedef struct
{
    DWORD               status;
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
} TFREC_RENDERPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               dwFlags;
} TFREC_DRAWONEPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               indexCount;
    DWORD               dwFlags;
} TFREC_DRAWONEINDEXEDPRIMITIVE;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES2;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\lists.hpp ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef _LISTS_H
#define _LISTS_H

#define LIST_ROOT(name, type) struct name {type *Root;}

#define LIST_MEMBER(type) struct { type **Prev; type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
    (root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    if ((element)->field.Prev)\
    {\
        *(element)->field.Prev = (element)->field.Next;\
        (element)->field.Prev = 0;\
    }\
    (element)->field.Next = 0;\
}

#define LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   type *First;\
    type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   type *Next;\
    type **Prev;    /* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   type *Last;\
    type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   type *Prev;\
    type *Next;\
}

#define CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
    (root)->Last->field.Next = (element);\
    else\
    (root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
    (root)->First->field.Prev = (element);\
    else\
    (root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
    (current_element)->field.Prev->field.Next = (element);\
    else\
    (root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
    (element)->field.Prev->field.Next = (element)->field.Next;\
    else\
    (root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

//---------------------------------------------------------------------
// To support singly linked lists with no deletion of entries. Useful
// for active lists (Active Lights etc.)
struct CListEntry
{
    CListEntry()    {m_pNext = NULL;}
    virtual ~CListEntry()   {delete m_pNext;}
    
    void Append(CListEntry* p) {p->m_pNext = m_pNext; m_pNext = p;}

    CListEntry *  m_pNext;
};

///////////////////////////////////////////////////////////////////////////////
#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


void TestList(void)
{
    struct Foo
    {
    int a;
    LIST_MEMBER(Foo) ListStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
    int a;
    TAIL_QUEUE_MEMBER(Foo) TQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
    int a;
    CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
    CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
    switch(WhichInsert)
    {
    case END:
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        WhichInsert = ROOT;
        break;
    case ROOT:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        WhichInsert = PREVIOUS;
        break;
    case PREVIOUS:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
        WhichInsert = DONE;
        break;
    default:
        assert(0);
    }

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

    pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
    pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
    assert(pFoo == &MyFoo3);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */


#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\hmgr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       hmgr.hpp
 *  Content:    Handle Manager header file
 *
 ***************************************************************************/
#ifndef _HMGR_HPP_
#define _HMGR_HPP_

#include "d3dtempl.hpp"


//-----------------------------------------------------------------------------
//
// D3D Base object class. All objects that are referred to by handles
// should inherit from this class
//
//-----------------------------------------------------------------------------
class CD3DBaseObj 
{
public:
    virtual ~CD3DBaseObj()
    {
        return;
    }
    
private:
};
typedef CD3DBaseObj* LPD3DBASEOBJ;


//-----------------------------------------------------------------------------
//
// D3D Handle Class.
//
//-----------------------------------------------------------------------------
struct CHandle
{
    CHandle()
    {
        m_Next = 0;
        m_pObj = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    ~CHandle()
    {
        delete m_pObj;
    }
    DWORD        m_Next;     // Used to make list of free handles
    LPD3DBASEOBJ m_pObj;
#if DBG
    // Non zero means that it has been allocated
    DWORD              m_tag;
#endif    
};


const   DWORD __INVALIDHANDLE = 0xFFFFFFFF;

typedef GArrayT<CHandle> CHandleArray;

//-----------------------------------------------------------------------------
//
// D3D HandleFactory Class:
//
// This handle factory assumes that the handle returned can be directly used
// an index into the handle array. This will not work if there is some
// munging required for the handle (in the vertex shader case)
//
//-----------------------------------------------------------------------------

class CHandleFactory 
{
public:
    CHandleFactory();
    CHandleFactory(DWORD dwGrowSize);
    DWORD GetSize() const { return m_Handles.GetSize(); }
    virtual DWORD CreateNewHandle( LPD3DBASEOBJ pObj  );
    virtual LPD3DBASEOBJ GetObject( DWORD dwHandle ) const;
    virtual UINT HandleFromIndex( DWORD index) const {return index;}
    // Sets new object pointer. Returns TRUE if success. Old object is not deleted
    virtual BOOL SetObject( DWORD dwHandle, LPD3DBASEOBJ ); 
    virtual void ReleaseHandle(DWORD handle, BOOL bDeleteObject = TRUE);
    
protected:
    CHandleArray       m_Handles;
    DWORD              m_Free;       // Header for free elements in the array
};


#endif //_HMGR_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\rtdmon.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rtdmon.hpp
//
// RunTime Debug Monitor
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _RTDMON_HPP
#define _RTDMON_HPP

#include "debugmon.hpp"

class CD3DBase;

class RTDebugMonitor : public D3DDebugMonitor
{
protected:
    CD3DBase*   m_pD3DBase;

public:
    RTDebugMonitor( CD3DBase* pD3DBase, BOOL bMonitorConnectionEnabled );
    ~RTDebugMonitor( void );

    void NextEvent( UINT32 EventType );
    HRESULT ProcessMonitorCommand( void );
};

///////////////////////////////////////////////////////////////////////////////
#endif // _RTDMON_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\pshader.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   pshader.hpp
 *  Content:    Direct3D pixel shader internal include file
 *
 *
 ***************************************************************************/
#ifndef _PSHADER_HPP
#define _PSHADER_HPP

#include "d3dfe.hpp"
#include "hmgr.hpp"

struct PVM_WORD
{
    union
    {
        struct
        {
            D3DVALUE x, y, z, w;
        };
        D3DVALUE v[4];
    };
};

struct CONST_DEF
{
    float   f[4];
    UINT    RegNum;
};

//-----------------------------------------------------------------------------
//
// CPShader: Pixel Shader Class
//
//-----------------------------------------------------------------------------
class CPShader : public CD3DBaseObj
{
public:
    DWORD*      m_pCode;
    UINT        m_dwCodeSize;
    DWORD*      m_pCodeOrig;
    UINT        m_dwCodeSizeOrig;
    DWORD       m_dwNumConstDefs;
    CONST_DEF*  m_pConstDefs;
    
    CPShader(void)
    {
        m_pCodeOrig = NULL;
        m_dwCodeSizeOrig = 0x0;
        m_pCode = m_pCodeOrig;
        m_dwCodeSize = m_dwCodeSizeOrig;
        m_dwNumConstDefs = 0;
        m_pConstDefs = NULL;
    }
    ~CPShader()
    {
        if (NULL != m_pCode) delete[] m_pCode;
        if (NULL != m_pCodeOrig) delete[] m_pCodeOrig;
        if (NULL != m_pConstDefs) delete[] m_pConstDefs;
    }
    HRESULT Initialize(CONST DWORD* pCode, D3DDEVTYPE DevType);
};
typedef CPShader *LPPSHADER;

#endif _PSHADER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\pipeln.h ===
#ifndef __PIPELN_H_
#define __PIPELN_H_
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pipeln.h
 *  Content:    Common definitions between Microsoft PSGP and the front-end
 *
 ***************************************************************************/

//-----------------------------------------------------------------------------
// Prototype of a function to copy data from input vertex stream to an input
// register
typedef void (*PFN_D3DCOPYELEMENT)(LPVOID pInputStream,
                                   UINT InputStreamStride,
                                   UINT count,
                                   VVM_WORD * pVertexRegister);
//---------------------------------------------------------------------
inline void ComputeOutputVertexOffsets(LPD3DFE_PROCESSVERTICES pv)
{
    DWORD i = 4*sizeof(D3DVALUE);
    pv->pointSizeOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_PSIZE)
        i += sizeof(DWORD);
    pv->diffuseOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
        i += sizeof(DWORD);
    pv->specularOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
        i += sizeof(DWORD);
    pv->fogOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_FOG)
        i += sizeof(DWORD);
    pv->texOffsetOut = i;
}
//----------------------------------------------------------------------
inline DWORD MakeTexTransformFuncIndex(DWORD dwNumInpTexCoord, DWORD dwNumOutTexCoord)
{
    DDASSERT(dwNumInpTexCoord <= 4 && dwNumOutTexCoord <= 4);
    return (dwNumInpTexCoord - 1) + ((dwNumOutTexCoord - 1) << 2);
}
//----------------------------------------------------------------------
// Returns TRUE if the token is instruction token, FALSE if the token is
// an operand token
inline BOOL IsInstructionToken(DWORD token)
{
    return (token & 0x80000000) == 0;
}

#endif // __PIPELN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\osthunk.h ===
// Note the following struct should match the declaration in 
// the definition of the kernel mode struct defined in ntgdistr.h
// For D3D context creation information.
typedef struct _D3DNTHAL_CONTEXTCREATEI
{
    // Space for a D3DNTHAL_CONTEXTCREATE record.
    // The structure isn't directly declared here to
    // avoid header inclusion problems.  This field
    // is asserted to be the same size as the actual type.
    ULONG ulContextCreate[6];

    // Private buffer information.
    PVOID pvBuffer;
    ULONG cjBuffer;
} D3DNTHAL_CONTEXTCREATEI;


DWORD APIENTRY OsThunkDdAddAttachedSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached,
    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData);

BOOL APIENTRY OsThunkDdAttachSurface(
    IN     HANDLE hSurfaceFrom,
    IN     HANDLE hSurfaceTo);

DWORD APIENTRY OsThunkDdBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);

DWORD APIENTRY OsThunkDdCanCreateSurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY OsThunkDdColorControl(
    IN     HANDLE hSurface,
    IN OUT PDD_COLORCONTROLDATA puColorControlData);

HANDLE APIENTRY OsThunkDdCreateDirectDrawObject(
    IN     HDC hdc);

DWORD  APIENTRY OsThunkDdCreateSurface(
    IN     HANDLE  hDirectDraw,
    IN     HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
       OUT HANDLE* puhSurface);

HANDLE APIENTRY OsThunkDdCreateSurfaceObject(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurface,
    IN     PDD_SURFACE_LOCAL puSurfaceLocal,
    IN     PDD_SURFACE_MORE puSurfaceMore,
    IN     PDD_SURFACE_GLOBAL puSurfaceGlobal,
    IN     BOOL bComplete);

BOOL APIENTRY OsThunkDdDeleteSurfaceObject(
    IN     HANDLE hSurface);

BOOL APIENTRY OsThunkDdDeleteDirectDrawObject(
    IN     HANDLE hDirectDrawLocal);

DWORD APIENTRY OsThunkDdDestroySurface(
    IN     HANDLE hSurface,
    IN     BOOL bRealDestroy);

DWORD APIENTRY OsThunkDdFlip(
    IN     HANDLE hSurfaceCurrent,
    IN     HANDLE hSurfaceTarget,
    IN     HANDLE hSurfaceCurrentLeft,
    IN     HANDLE hSurfaceTargetLeft,
    IN OUT PDD_FLIPDATA puFlipData);

DWORD APIENTRY OsThunkDdGetAvailDriverMemory(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData);

DWORD APIENTRY OsThunkDdGetBltStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData);

HDC APIENTRY OsThunkDdGetDC(
    IN     HANDLE hSurface,
    IN     PALETTEENTRY* puColorTable);

DWORD APIENTRY OsThunkDdGetDriverInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData);

DWORD APIENTRY OsThunkDdGetFlipStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData);

DWORD APIENTRY OsThunkDdGetScanLine(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETSCANLINEDATA puGetScanLineData);

DWORD APIENTRY OsThunkDdSetExclusiveMode(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData);

DWORD APIENTRY OsThunkDdFlipToGDISurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData);

DWORD APIENTRY OsThunkDdLock(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData,
    IN HDC hdcClip);

BOOL APIENTRY OsThunkDdQueryDirectDrawObject(
    IN     HANDLE,
    IN OUT PDD_HALINFO,
    IN OUT DWORD*,
    IN OUT LPD3DNTHAL_CALLBACKS,
    IN OUT LPD3DNTHAL_GLOBALDRIVERDATA,
    IN OUT PDD_D3DBUFCALLBACKS,
    IN OUT LPDDSURFACEDESC,
    IN OUT DWORD*,
    IN OUT VIDEOMEMORY*,
    IN OUT DWORD*,
    IN OUT DWORD*);
 
BOOL APIENTRY OsThunkDdReenableDirectDrawObject(
    IN     HANDLE hDirectDrawLocal,
    IN OUT BOOL* pubNewMode);

BOOL APIENTRY OsThunkDdReleaseDC(
    IN     HANDLE hSurface);

BOOL APIENTRY OsThunkDdResetVisrgn(
    IN     HANDLE hSurface,
    IN HWND hwnd);

DWORD APIENTRY OsThunkDdSetColorKey(
    IN     HANDLE hSurface,
    IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData);

DWORD APIENTRY OsThunkDdSetOverlayPosition(
    IN     HANDLE hSurfaceSource,
    IN     HANDLE hSurfaceDestination,
    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData);

VOID  APIENTRY OsThunkDdUnattachSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached);

DWORD APIENTRY OsThunkDdUnlock(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY OsThunkDdUpdateOverlay(
    IN     HANDLE hSurfaceDestination,
    IN     HANDLE hSurfaceSource,
    IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData);

DWORD APIENTRY OsThunkDdWaitForVerticalBlank(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData);

HANDLE APIENTRY OsThunkDdGetDxHandle(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     BOOL bRelease);

BOOL APIENTRY OsThunkDdSetGammaRamp(
    IN     HANDLE hDirectDraw,
    IN     HDC hdc,
    IN     LPVOID lpGammaRamp);

DWORD APIENTRY OsThunkDdLockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData);

DWORD APIENTRY OsThunkDdUnlockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY OsThunkDdCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
    IN OUT HANDLE* puhSurface);

DWORD APIENTRY OsThunkDdCanCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY OsThunkDdDestroyD3DBuffer(
    IN     HANDLE hSurface);

DWORD APIENTRY OsThunkD3dContextCreate(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurfColor,
    IN     HANDLE hSurfZ,
    IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci);

DWORD APIENTRY OsThunkD3dContextDestroy(
    IN     LPD3DNTHAL_CONTEXTDESTROYDATA);

DWORD APIENTRY OsThunkD3dContextDestroyAll(
       OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad);

DWORD APIENTRY OsThunkD3dValidateTextureStageState(
    IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD APIENTRY OsThunkD3dDrawPrimitives2(
    IN     HANDLE hCmdBuf,
    IN     HANDLE hVBuf,
    IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
    IN OUT FLATPTR* pfpVidMemCmd,
    IN OUT DWORD* pdwSizeCmd,
    IN OUT FLATPTR* pfpVidMemVtx,
    IN OUT DWORD* pdwSizeVtx);

DWORD APIENTRY OsThunkDdGetDriverState(
    IN OUT PDD_GETDRIVERSTATEDATA pdata);

DWORD APIENTRY OsThunkDdCreateSurfaceEx(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     DWORD dwSurfaceHandle);

DWORD APIENTRY OsThunkDdGetMoCompGuids(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData);

DWORD APIENTRY OsThunkDdGetMoCompFormats(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData);

DWORD APIENTRY OsThunkDdGetMoCompBuffInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData);

DWORD APIENTRY OsThunkDdGetInternalMoCompInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData);

HANDLE APIENTRY OsThunkDdCreateMoComp(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData);

DWORD APIENTRY OsThunkDdDestroyMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData);

DWORD APIENTRY OsThunkDdBeginMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData);

DWORD APIENTRY OsThunkDdEndMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData);

DWORD APIENTRY OsThunkDdRenderMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData);

DWORD APIENTRY OsThunkDdQueryMoCompStatus(
    IN OUT HANDLE hMoComp,
    IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData);

DWORD APIENTRY OsThunkDdAlphaBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\linklib\sources.inc ===
# Sources to link and publish d3d8.lib only

#this file is copied here from ..\linkdll by makefil0
SOURCES = ..\d3d8.rc

!include ..\..\bldlink.inc

# do not binplace from here
NO_BINPLACE=1

# publish d3d8.lib
PASS1_PUBLISH=\
    { $(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(TARGETNAME).lib }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\linkdll\sources.inc ===
# Sources to build and binplace d3d8(d).dll
#
#   generates d3d8.dll for FREE build
#   generates d3d8d.dll for !FREE && DIRECTX_REDIST build

!include ..\..\bldlink.inc

!if !$(FREEBUILD)
!ifdef DIRECTX_REDIST
TARGETNAME=$(TARGETNAME)d
!endif
!endif

SOURCES = ..\d3d8.rc

# do regular binplace
# do not publish lib (do not want d3d8d.lib published)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhalp.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     (((D3D_MAXRENDERSTATES + (D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)) >> 3) + 2)
#define RAST_TSS_DIRTYBIT( _Stage, _State ) \
    ((UINT32)(D3D_MAXRENDERSTATES + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

typedef struct _UV_UNION {
    union {
        D3DVALUE    tu;
        D3DVALUE    dvTU;

        INT32 iU;
        FLOAT fU;

        INT32 iUoW;        // 1.11.20 texture coordinates
        FLOAT fUoW;

        INT32 iDUoWDX;         // 1.11.20
        FLOAT fDUoWDX;

        INT32 iDUoWDY; // 1.11.20
        FLOAT fDUoWDY;
    };
    union {
        D3DVALUE    tv;
        D3DVALUE    dvTV;

        INT32 iV;
        FLOAT fV;

        INT32 iVoW;        // 1.11.20 texture coordinates
        FLOAT fVoW;

        INT32 iDVoWDX;         // 1.11.20
        FLOAT fDVoWDX;

        INT32 iDVoWDY; // 1.11.20
        FLOAT fDVoWDY;
    };
}UV_UNION;

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    UV_UNION UVoW[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value


    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

    UINT8 pPad[16];

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    UV_UNION DUVoWDX[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    UV_UNION DUVoWDY[D3DHAL_TSS_MAXSTAGES];


    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    UINT8 uPad[72];

    // Anything else needed

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE          (0x00000008L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,
    D3DI_SPTFMT_S1Z15    =36,
    D3DI_SPTFMT_S8Z24    =37,

    // NOTE: this must be changed in conjunction with RR_STYPE in ref\inc\refrast.hpp

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write

    UV_UNION TexUV[D3DHAL_TSS_MAXSTAGES];
    D3DCOLOR    TexCol[D3DHAL_TSS_MAXSTAGES];  // [Texture]

    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);
typedef void (CDECL *PFNTEXADDRESS)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS, INT32 iTex);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3D_MAXRENDERSTATES];
        FLOAT pfRenderState[D3D_MAXRENDERSTATES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    DWORD pdwWrap[D3DHAL_TSS_MAXSTAGES];

    union
    {
    DWORD pdwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    FLOAT pfTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    };

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[D3DHAL_TSS_MAXSTAGES];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;
    // Number of active texture stages for blending. It's set in spaninit()
    // and used in TexBlend_TexM_Gen.
    UINT cActBldStage;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNTEXADDRESS   pfnTexAddr[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexAddrEnd;
    PFNTEXREAD      pfnTexRead[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[D3DHAL_TSS_MAXSTAGES];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTexAddr[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexRead[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    UV_UNION  texCoord[D3DHAL_TSS_MAXSTAGES]; /* Texture coordinates */
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\osthunk\whistler\sources.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8
#
# this will cause the checked versions of the object files, libraries, binaries, etc.
#   to land in objd; keeping them seperate from the free versions
#   TARGETPATH should stay as obj or it will get a little wierd
#
CHECKED_ALT_DIR=1
TARGETPATH=obj
#
# the build environment sets the FREEBUILD macro to 1 when it is a freebuild
#  so you can change the name of the built binary to be different in that case.
#  side affects:
#             need 2 entries in placefil.txt (one for each name)
#             if a lib is published it will be called the new name; depending on your
#                viewpoint this could be a good thing or not
#
TARGETNAME=d3d8thk

TARGETPATH=obj

TARGETTYPE=DYNLINK

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

LINKER_FLAGS = $(LINKER_FLAGS) /IGNORE:4088

NO_NTDLL = 1

DLLENTRY = _DllMainCRTStartup

DLLDEF = ..\d3d8thk.def

SOURCES = ..\d3d8thk.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\vvm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vvm.h
 *  Content:    Virtual Vertex Machine declarations
 *
 *
 ***************************************************************************/
#ifndef __VVM_H__
#define __VVM_H__
#include "d3dhalp.h"

class CVShaderCodeI;
extern HRESULT ComputeShaderCodeSize(CONST DWORD* pCode, DWORD* pdwCodeOnlySize, DWORD* pdwCodeAndCommentSize,
                                     DWORD* pdwNumConstDefs);

// Number of vertices in batch to process
const DWORD VVMVERTEXBATCH = 16;
//-----------------------------------------------------------------------------
// Internal word of the vertual vertex machine
//
struct VVM_WORD
{
    union
    {
        struct
        {
            D3DVALUE x, y, z, w;
        };
        D3DVALUE v[4];
    };
};
//-----------------------------------------------------------------------------
struct VVM_REGISTERS
{
    VVM_REGISTERS()  {m_c = NULL;}
    ~VVM_REGISTERS() {delete [] m_c;}
    // Input registers
    VVM_WORD    m_v[D3DVS_INPUTREG_MAX_V1_1][VVMVERTEXBATCH];
    // Temporary registers
    VVM_WORD    m_r[D3DVS_TEMPREG_MAX_V1_1][VVMVERTEXBATCH];
    // Constant registers. Allocated dynamically, base on MaxVertexShaderConst 
    // cap
    VVM_WORD*    m_c;
    // Address registers
    VVM_WORD    m_a[D3DVS_ADDRREG_MAX_V1_1][VVMVERTEXBATCH];
    // Output register file
    VVM_WORD    m_output[3][VVMVERTEXBATCH];
    // Attribute register file
    VVM_WORD    m_color[D3DVS_ATTROUTREG_MAX_V1_1][VVMVERTEXBATCH];
    // Output texture registers
    VVM_WORD    m_texture[D3DVS_TCRDOUTREG_MAX_V1_1][VVMVERTEXBATCH];
};
//-----------------------------------------------------------------------------
//
// CVShaderCode: Vertex Shader Code
//
//-----------------------------------------------------------------------------
class CVShaderCode: public CPSGPShader
{
public:
    CVShaderCode() {};
    virtual ~CVShaderCode() {};

    virtual DWORD  InstCount( void ) { return 0; };
    virtual DWORD* InstTokens( DWORD Inst ) { return NULL; };
    virtual char*  InstDisasm( DWORD Inst ) { return NULL; };
    virtual DWORD* InstComment( DWORD Inst ) { return NULL; };
    virtual DWORD  InstCommentSize( DWORD Inst ) { return 0; };
};
//-----------------------------------------------------------------------------
// Vertex Virtual Machine object
//
//-----------------------------------------------------------------------------

const UINT __MAX_SRC_OPERANDS = 5;

class CVertexVM
{
public:
    CVertexVM();
    ~CVertexVM();
    void Init(UINT MaxVertexShaderConst);
    // Parses binary shader representatio, compiles is and returns
    // compiled object
    CVShaderCode* CreateShader(CVElement* pElements, DWORD dwNumElements,
                               DWORD* code);
    HRESULT SetActiveShader(CVShaderCode* code);
    CVShaderCode* GetActiveShader() {return (CVShaderCode*)m_pCurrentShader;}
    HRESULT ExecuteShader(LPD3DFE_PROCESSVERTICES pv, UINT vertexCount);
    HRESULT GetDataPointer(DWORD dwMemType, VVM_WORD ** pData);
    // Set internal registers to user data
    HRESULT SetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    // Get data from internal registers
    HRESULT GetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    VVM_REGISTERS* GetRegisters();
    DWORD GetCurInstIndex() {return m_CurInstIndex; }

    // Number of allocated constant registers
    UINT            m_MaxVertexShaderConst;
protected:
    void InstMov();
    void InstAdd();
    void InstMad();
    void InstMul();
    void InstRcp();
    void InstRsq();
    void InstDP3();
    void InstDP4();
    void InstMin();
    void InstMax();
    void InstSlt();
    void InstSge();
    void InstExp();
    void InstLog();
    void InstExpP();
    void InstLogP();
    void InstLit();
    void InstDst();
    void InstFrc();
    void InstM4x4();
    void InstM4x3();
    void InstM3x4();
    void InstM3x3();
    void InstM3x2();
    void EvalDestination();
    void EvalSource(DWORD index);
    void EvalSource(DWORD index, DWORD count);
    VVM_WORD* GetDataAddr(DWORD dwRegType, DWORD dwElementIndex);
    void ValidateShader(CVShaderCodeI* shader, DWORD* orgShader);
    void PrintInstCount();
    UINT GetNumSrcOperands(UINT opcode);
    UINT GetInstructionLength(DWORD Inst);
    UINT GetRegisterUsage(UINT opcode, UINT SourceIndex);

    // Virtual machine registers
    VVM_REGISTERS   m_reg;
    // Current shader code
    CVShaderCodeI*  m_pCurrentShader;
    // Current token during parsing
    DWORD*          m_pdwCurToken;
    // Pointer to destination operand
    VVM_WORD*       m_pDest;
    // Offset in the register file for destination operand
    DWORD           m_dwOffset;
    // Write mask for destination operand
    DWORD           m_WriteMask;
    // Current instruction (about to be executed)
    DWORD           m_CurInstIndex;
    // Source operands
    VVM_WORD        m_Source[__MAX_SRC_OPERANDS][VVMVERTEXBATCH];
    // How many vertices to process in a batch
    UINT            m_count;
    // m_count * sizeof(VVM_WORD)
    UINT            m_BatchSize;

    // Initialized flags
#if DBG
    // Constant registers
    BOOL            m_c_initialized[D3DVS_CONSTREG_MAX_V1_1];
#endif // DBG
    friend class D3DFE_PVFUNCSI;
    friend class CD3DHal;
};

#endif // __VVM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\osthunk\win2k\sources.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8

TARGETNAME=d3d8thk

TARGETPATH=obj

TARGETTYPE=DYNLINK

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

LINKER_FLAGS = $(LINKER_FLAGS) /IGNORE:4088

NO_NTDLL = 1

DLLENTRY = _DllMainCRTStartup

DLLDEF = ..\d3d8thk.def

SOURCES = ..\d3d8thk.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\inc\vshader.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vshader.hpp
 *  Content:    Direct3D vertex shader internal include file
 *
 *
 ***************************************************************************/
#ifndef _VSHADER_HPP
#define _VSHADER_HPP

#include "d3dfe.hpp"
#include "vvm.h"
#include "hmgr.hpp"
#include "vbuffer.hpp"
#include "ibuffer.hpp"

void CheckForNull(LPVOID p, DWORD line, char* file);
class CD3DBase;
//---------------------------------------------------------------------
// macros for parsing Declaration Token Array

// TRUE, if shader handle is DX7 FVF code
//
#define D3DVSD_ISLEGACY(ShaderHandle) !(ShaderHandle & D3DFVF_RESERVED0)

enum D3DVSD_DATALOAD
{
    D3DVSD_LOADREGISTER = 0,
    D3DVSD_SKIP
};

#define D3DVSD_GETTOKENTYPE(token) ((token & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT)
#define D3DVSD_ISSTREAMTESS(token) ((token & D3DVSD_STREAMTESSMASK) >> (D3DVSD_TOKENTYPESHIFT - 1))
#define D3DVSD_GETDATALOADTYPE(token) ((token & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT)
#define D3DVSD_GETDATATYPE(token) ((token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT)
#define D3DVSD_GETSKIPCOUNT(token) ((token & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT)
#define D3DVSD_GETSTREAMNUMBER(token) ((token & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT)
#define D3DVSD_GETVERTEXREG(token) ((token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT)
#define D3DVSD_GETCONSTCOUNT(token) ((token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT)
#define D3DVSD_GETCONSTADDRESS(token) ((token & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT)
#define D3DVSD_GETCONSTRS(token) ((token & D3DVSD_CONSTRSMASK) >> D3DVSD_CONSTRSSHIFT)
#define D3DVSD_GETEXTCOUNT(token) ((token & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT)
#define D3DVSD_GETEXTINFO(token) ((token & D3DVSD_EXTINFOMASK) >> D3DVSD_EXTINFOSHIFT)

//---------------------------------------------------------------------
//
// CVConstantData: Constant data that is used by a shader
//
//---------------------------------------------------------------------
struct CVConstantData: public CListEntry
{
    CVConstantData()     {m_pData = NULL; m_dwCount = 0;}
    ~CVConstantData()    {delete m_pData;}

    DWORD   m_dwCount;          // Number of 4*DWORDs to load
    DWORD   m_dwAddress;        // Start constant register
    DWORD*  m_pData;            // Data. Multiple of 4*DWORD
};
//---------------------------------------------------------------------
//
// CVStreamDecl:
//
//      Describes a stream, used by a declaration
//
//---------------------------------------------------------------------
class CVStreamDecl: public CListEntry
{
public:
    CVStreamDecl()
    {
        m_dwNumElements = 0;
        m_dwStride = 0;
        m_dwStreamIndex = 0xFFFFFFFF;
#if DBG
        m_dwFVF = 0;
#endif // DBG
    }
    // Parses declaration.
    // For fixed-function pipeline computes FVF, FVF2 (used to record
    // texture presense) and number of floats after position
    void Parse(CD3DBase* pDevice, DWORD CONST ** ppToken, BOOL bFixedFunction,
               DWORD* pdwFVF, DWORD* pdwFVF2, DWORD* pnFloats, 
               BOOL* pbLegacyFVF, UINT Usage, BOOL bTessStream = FALSE);

    CVElement   m_Elements[__NUMELEMENTS];  // Vertex elements in the stream
    DWORD       m_dwNumElements;            // Number of elements to use
    DWORD       m_dwStride;                 // Vertex size in bytes
    DWORD       m_dwStreamIndex;            // Index to device streams
#if DBG
    // FVF, computed from declaration. Used for fixed function pipeline only
    DWORD       m_dwFVF;
#endif //DBG
};
//---------------------------------------------------------------------
//
// CVDeclaration:
//
//      D3D parses declaration byte-codes and creates this data structure.
//
//-----------------------------------------------------------------------------
class CVDeclaration
{
public:
    CVDeclaration(DWORD dwNumStreams);
    ~CVDeclaration();
    //------------- Used during declaration parsing -----------
    // pDeclSize will have size of the declaration in bytes if not NULL
    void Parse(CD3DBase* pDevice, CONST DWORD * decl, BOOL bFixedFunction, 
               DWORD* pDeclSize, UINT Usage);

    // List of streams, which are used by the declaration
    CVStreamDecl*   m_pActiveStreams;
    CVStreamDecl*   m_pActiveStreamsTail;
    // Corresponding FVF for fixed-function pipeline
    // This is OR of all streams input FVF
    DWORD           m_dwInputFVF;
    // This is computed for legacy TL capable hardware.
    // If this is NULL, that means that the declaration is too complex
    // for these devices.
    BOOL           m_bLegacyFVF;
    // TRUE when a tesselator stream is present in the declaration.
    // We need this to validate that the stream is not passed to DrawPrimitive
    // API.
    BOOL           m_bStreamTessPresent;
    // Max number of available streams
    DWORD           m_dwNumStreams;
    // Constant data that should be loaded when shader becomes active
    CVConstantData* m_pConstants;
    CVConstantData* m_pConstantsTail;
    //------------- Used by PSGP ---------------
    // The description of all vertex elements to be loaded into input registers.
    // The array is built by going through active streams and elements inside
    // each stream
    CVElement       m_VertexElements[__NUMELEMENTS];
    // Number of used members of m_VertexElements
    DWORD           m_dwNumElements;

    friend class CD3DHal;
};
//-----------------------------------------------------------------------------
//
//  CVStreamBase: Class representing the digested information for vertex
//                stream in the MS implementation.
//
//-----------------------------------------------------------------------------
struct CVStreamBase
{
    CVStreamBase()
    {
        m_pData = NULL;
        m_dwStride = 0;
#if DBG
        m_dwSize = 0;
#endif
        m_dwNumVertices = 0;
        m_dwIndex = 0;
    }
    // Stream memory. In case of vertex buffers (m_pVB != NULL), we lock the
    // vertex buffer and assign its memory pointer to the m_pData
    LPBYTE  m_pData;
    // Vertex (or index) stride in bytes
    DWORD           m_dwStride;
#if DBG
    // Buffer size in bytes
    DWORD           m_dwSize;
#endif // DBG
    // Index of the stream. Needed when we access streams through pointers
    // m_dwIndex == __NUMSTREAMS is a flag when CIndexBuffer is used
    DWORD           m_dwIndex;
    // Max number of vertices (or indices in case of index buffer) the buffer
    // can store (valid in DBG only !!!).
    // For internal TL buffers this is used as number of vertices, currently
    // written to the buffer.
    DWORD           m_dwNumVertices;
};
//-----------------------------------------------------------------------------
//
//  CVStream: Class representing the digested information for vertex
//             stream in the MS implementation.
//
//-----------------------------------------------------------------------------
struct CVStream: public CVStreamBase
{
    CVStream() {m_pVB = NULL;}
    BYTE* Data()
        {
            if (m_pVB)
                return m_pVB->Data();
            else
                return m_pData;
        }
    ~CVStream();
    virtual BOOL IsUserMemStream() {return FALSE;}
    CVertexBuffer *m_pVB;      // User passed VB
};
//-----------------------------------------------------------------------------
//
//  CVStream: Class representing the digested information for vertex
//             stream in the MS implementation.
//
//-----------------------------------------------------------------------------
struct CVIndexStream: public CVStreamBase
{
    CVIndexStream()
    {
        m_dwBaseIndex = 0;
        m_dwIndex = __NUMSTREAMS; // Mark the stream as index stream
        m_pVBI = NULL;
    }
    BYTE* Data()
        {
            if (m_pVBI)
                return m_pVBI->Data();
            else
                return m_pData;
        }
    ~CVIndexStream();
    DWORD   m_dwBaseIndex;  // Vertex index, that corresponds to the index 0
    CIndexBuffer  *m_pVBI;  // User passed VB
};
//-----------------------------------------------------------------------------
//
// CVShader: Vertex Shader Class
//
//-----------------------------------------------------------------------------
class CVShader : public CD3DBaseObj
{
public:
    CVShader(DWORD dwNumStreams): m_Declaration(dwNumStreams)
        {
            m_dwFlags = 0;
            m_pCode = NULL;
            m_pOrgDeclaration = NULL;
            m_OrgDeclSize = 0;
            m_pOrgFuncCode = NULL;
            m_OrgFuncCodeSize = 0;
            m_pStrippedFuncCode = NULL;
            m_StrippedFuncCodeSize = 0;
        }
    ~CVShader()
        {
            delete m_pCode;
            delete m_pOrgDeclaration;
            delete m_pOrgFuncCode;
            delete m_pStrippedFuncCode;
        }
    HRESULT Initialize(DWORD* lpdwDeclaration, DWORD* lpdwFunction);

    // Bits for m_dwFlags
    static const DWORD FIXEDFUNCTION;   // This is fixed-function shader
    static const DWORD SOFTWARE;        // Shader is used with software pipeline

    CVDeclaration   m_Declaration;
    CVShaderCode*   m_pCode;            // PSGP vertex shader object
                                        // Used to process point sprites.
    DWORD           m_dwFlags;
    DWORD           m_dwInputFVF;       // Input FVF for fixed-function pipeline
    DWORD*          m_pOrgDeclaration;  // Original declaration
    UINT            m_OrgDeclSize;      // Size in bytes
    DWORD*          m_pOrgFuncCode;     // Original function code
    UINT            m_OrgFuncCodeSize;  // Size in bytes
    DWORD*          m_pStrippedFuncCode;    // Comment-stripped function code
    UINT            m_StrippedFuncCodeSize; // Size in bytes
};
typedef CVShader *LPVSHADER;
//-----------------------------------------------------------------------------
//
// CVShaderHandleFactory: Vertex Shader Handle Factory
//
//-----------------------------------------------------------------------------
class CVShaderHandleFactory : public CHandleFactory
{
public:
    DWORD CreateNewHandle( LPVSHADER pVShader  );
    LPD3DBASEOBJ GetObject( DWORD dwHandle ) const;
    void ReleaseHandle(DWORD handle, BOOL);
    BOOL SetObject( DWORD dwHandle, LPD3DBASEOBJ );
    virtual UINT HandleFromIndex( DWORD index) const {return (index << 1) + 1;}
    CVShader* GetObjectFast(DWORD dwHandle) const
    {
        return (CVShader*)((reinterpret_cast<CHandle*>(m_Handles.GetArrayPointer())[dwHandle >> 1]).m_pObj);
    }
};


#endif _VSHADER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\ref\common.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "..\..\ref8\drv\refif.cpp"
#include "..\..\ref8\drv\dprim2.cpp"
#include "..\..\ref8\drv\surfman.cpp"
#include "..\..\ref8\drv\rralloc.cpp"
#include "..\..\ref8\common\dxtn.cpp"
#include "..\..\ref8\common\rdsurf.cpp"
#include "..\..\ref8\common\rdutil.cpp"
#include "..\..\ref8\common\pixref.cpp"
#include "..\..\ref8\common\refdev.cpp"
#include "..\..\ref8\common\refdevi.cpp"
#include "..\..\ref8\common\rtarget.cpp"
#include "..\..\ref8\rast\refrast.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\ref\sources.inc ===
TARGETPATH=obj
TARGETNAME=d3dref

TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(DDK_INC_PATH);$(DXGROOT)\ref8\inc;$(DXGROOT)\ref8\drv
C_DEFINES = $(C_DEFINES) -D__D3D_NULL_REF
386_STDCALL = 0

SOURCES=\
    ..\common.cpp     \
    ..\empty.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\ref\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "refdev.hpp"

#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\errlog.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// errlog.cpp
//
// Direct3D Reference Device - Error log for shader validation.
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// CErrorLog::CErrorLog
//-----------------------------------------------------------------------------
CErrorLog::CErrorLog( BOOL bRememberAllSpew )
{
    m_TotalStringLength     = 0;
    m_pHead                 = NULL;
    m_pTail                 = NULL;
    m_bRememberAllSpew      = bRememberAllSpew;
}

//-----------------------------------------------------------------------------
// CErrorLog::~CErrorLog
//-----------------------------------------------------------------------------
CErrorLog::~CErrorLog()
{
    ErrorLogNode*    pCurr = m_pHead;
    while( pCurr )
    {
        ErrorLogNode* pDeleteMe = pCurr;
        pCurr = pCurr->pNext;
        delete pDeleteMe;
    }
    m_pHead = NULL;
    m_pTail = NULL;

}

//-----------------------------------------------------------------------------
// CErrorLog::AppendText
//-----------------------------------------------------------------------------
void CErrorLog::AppendText( const char* pszFormat, ... )
{
#if DBG
    OutputDebugString("D3D Shader Validator: ");
#endif

    ErrorLogNode* pNewString = new ErrorLogNode;
    if( NULL == pNewString )
    {
        OutputDebugString("Out of memory.\n");
        return;
    }
    _snprintf( pNewString->String, ERRORLOG_STRINGSIZE-1, "");

    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(pNewString->String+lstrlen(pNewString->String), ERRORLOG_STRINGSIZE - lstrlen(pNewString->String) - 2, pszFormat, marker);
    _snprintf( pNewString->String, ERRORLOG_STRINGSIZE - 2, "%s", pNewString->String );
    strcat( pNewString->String, "\n" ); // force trailing \n
    pNewString->String[ERRORLOG_STRINGSIZE-1] = '\0'; // force trailing \0.
#if DBG
    OutputDebugString(pNewString->String);
#endif

    if( m_bRememberAllSpew )
    {
        // append node
        if( NULL == m_pHead )
            m_pHead = pNewString;

        if( NULL != m_pTail )
            m_pTail->pNext = pNewString;

        m_pTail = pNewString;
        pNewString->pNext = NULL;
        m_TotalStringLength += strlen(pNewString->String);
    }
    else
    {
        delete pNewString;
    }
}

//-----------------------------------------------------------------------------
// CErrorLog::WriteLogToBuffer()
//
// Call GetLogBufferSizeRequired() first to figure out how big to make pBuffer
//-----------------------------------------------------------------------------
void CErrorLog::WriteLogToBuffer( char* pBuffer )
{
    if( NULL == pBuffer )
        return;

    pBuffer[0] = '\0';
    if( NULL != m_pHead )
    {
        ErrorLogNode* pCurr = m_pHead;
        while( pCurr )
        {
            strcat(pBuffer,pCurr->String);
            pCurr = pCurr->pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "ddrawpr.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <windows.h>

#include "d3d8typesp.h"
#include "d3d8p.h"
#include "d3dhalp.h"

#include "errlog.hpp"
#include "valbase.hpp"
#include "pshdrval.hpp"
#include "vshdrval.hpp"

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\ref\empty.cpp ===
#include "pch.cpp"
#pragma hdrstop

HRESULT 
RefDev::DrawPrimitives2( PUINT8 pUMVtx,
                         UINT16 dwStride,
                         DWORD dwFvf,
                         DWORD dwNumVertices,
                         LPD3DHAL_DP2COMMAND *ppCmd,
                         LPDWORD lpdwRStates )
{
    return S_OK;
}

void
RefDev::SetSetStateFunctions(void)
{
}

void
RefRast::SetSampleMode( UINT MultiSamples, BOOL bAntialias )
{
}

HRESULT
RefDev::Dp2SetVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    return S_OK;
}

void
RDDebugMonitor::NextEvent( UINT32 EventType )
{
}

void
RefRast::UpdateTextureControls( void )
{
}

void
RefRast::UpdateLegacyPixelShader( void )
{
}

RDVShader::RDVShader()
{
}

RDVShader::~RDVShader()
{
}

RDVDeclaration::~RDVDeclaration()
{
}

RefRast::~RefRast()
{
}

void 
RefRast::Init( RefDev* pRD )
{
}

RefClipper::RefClipper()
{
}

RefVP::RefVP()
{
}

RDPShader::~RDPShader()
{
}

RDDebugMonitor::~RDDebugMonitor()
{
}

RDLight::RDLight()
{
}

RDVStreamDecl::RDVStreamDecl()
{
}

HRESULT
RDDebugMonitor::ProcessMonitorCommand( void )
{
    return S_OK;
}

RDHOCoeffs& RDHOCoeffs::operator=(const RDHOCoeffs &coeffs)
{
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\errlog.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// errlog.hpp
//
// Direct3D Reference Device - Error log for shader validation.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __ERRLOG_HPP__
#define __ERRLOG_HPP__

#define ERRORLOG_STRINGSIZE 1024

typedef struct _ErrorLogNode
{
    char String[ERRORLOG_STRINGSIZE]; // For individual errors.
    _ErrorLogNode* pNext;
} ErrorLogNode;

class CErrorLog
{
    ErrorLogNode* m_pHead;
    ErrorLogNode* m_pTail;
    DWORD   m_TotalStringLength;
    BOOL    m_bRememberAllSpew;

public:
    CErrorLog( BOOL bRememberAllSpew );
    ~CErrorLog();
    void AppendText( const char* pszFormat, ... );
    DWORD   GetRequiredLogBufferSize() {return m_TotalStringLength + 1;}
    void    WriteLogToBuffer( char* pBuffer ); // call GetLogBufferSizeRequired first.
};

#endif // __ERRLOG_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\pshdrval.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.cpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CPSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_PS_INST   ((CPSInstruction*)m_pCurrInst)
#define _PREV_PS_INST   (m_pCurrInst?((CPSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// CPSInstruction::CalculateComponentReadMasks()
//
// Figure out which components of each source parameter is read by a pixelshader
// instruction.  For certain pixelshader instructions, the some components
// are also read from the dest parameter.
//
// Note: When this function is changed, the changes need to be ported to
// refrast's CalculateSourceReadMasks() function in rast\pshader.cpp
// (Though that function does not care about channels read from the dest parameter
//  like this one does).
//-----------------------------------------------------------------------------
void CPSInstruction::CalculateComponentReadMasks(DWORD dwVersion)
{
    UINT i, j;

    switch( m_Type ) // instructions that actually read from the *Destination* register...
    {
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDEPTH:
        m_DstParam.m_ComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1;
        break;
    case D3DSIO_TEXKILL:
        if( (D3DPS_VERSION(1,4) == dwVersion) && (D3DSPR_TEMP == m_DstParam.m_RegType) )
        {
            // for ps.1.4, texkill on an r# register only reads rgb
            m_DstParam.m_ComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
        }
        else
        {
            m_DstParam.m_ComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
        }
        break;
    }

    for( i = 0; i < m_SrcParamCount; i++ )
    {
        DWORD NeededComponents;
        DWORD ReadComponents = 0;

        switch( m_Type )
        {
        case D3DSIO_TEX:      // only in ps.1.4 does texld have source parameter
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texld has a source parameter
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on tex, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
            }
            break;
        case D3DSIO_TEXCOORD:
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texcrd has a source parameter
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on texcoord, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
            }
            break;
        case D3DSIO_TEXBEM:
        case D3DSIO_TEXBEML:
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1;
            break;
        case D3DSIO_DP3:
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
            break;
        case D3DSIO_DP4:
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
            break;
        case D3DSIO_BEM: // ps.1.4
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1;
            break;
        default: 
            // standard component-wise instruction, 
            // OR an op we know reads .rgba and we also know it will be validated to .rgba writemask
            NeededComponents = m_DstParam.m_WriteMask;
            break;
        }

        // Figure out which components of this source parameter are read (taking into account swizzle)
        for(j = 0; j < 4; j++)
        {
            if( NeededComponents & COMPONENT_MASKS[j] )
                ReadComponents |= COMPONENT_MASKS[(m_SrcParam[i].m_SwizzleShift >> (D3DVS_SWIZZLE_SHIFT + 2*j)) & 0x3];
        }
        m_SrcParam[i].m_ComponentReadMask = ReadComponents;
    }
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::CBasePShaderValidator
//-----------------------------------------------------------------------------
CBasePShaderValidator::CBasePShaderValidator(   const DWORD* pCode,
                                        const D3DCAPS8* pCaps,
                                        DWORD Flags )
                                        : CBaseShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.
    // Only set m_ReturnCode to S_OK if validation has succeeded,
    // before exiting this constructor.

    m_CycleNum              = 0;
    m_TexOpCount            = 0;
    m_BlendOpCount          = 0;
    m_TotalOpCount          = 0;

    m_pTempRegFile          = NULL;
    m_pInputRegFile         = NULL;
    m_pConstRegFile         = NULL;
    m_pTextureRegFile       = NULL;

    if( !m_bBaseInitOk )
        return;
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::~CBasePShaderValidator
//-----------------------------------------------------------------------------
CBasePShaderValidator::~CBasePShaderValidator()
{
    delete m_pTempRegFile;
    delete m_pInputRegFile;
    delete m_pConstRegFile;
    delete m_pTextureRegFile;
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::AllocateNewInstruction
//-----------------------------------------------------------------------------
CBaseInstruction* CBasePShaderValidator::AllocateNewInstruction(CBaseInstruction*pPrevInst)
{
    return new CPSInstruction((CPSInstruction*)pPrevInst);
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::DecodeNextInstruction
//-----------------------------------------------------------------------------
BOOL CBasePShaderValidator::DecodeNextInstruction()
{
    m_pCurrInst->m_Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*m_pCurrToken & D3DSI_OPCODE_MASK);

    if( D3DSIO_COMMENT == m_pCurrInst->m_Type )
    {
        ParseCommentForAssemblerMessages(m_pCurrToken); // does not advance m_pCurrToken

        // Skip comments
        DWORD NumDWORDs = ((*m_pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
        m_pCurrToken += (NumDWORDs+1);
        return TRUE;
    }

    // Find out if the instruction is a TexOp and/or TexMOp.  Needed by multiple validation rules,
    // as well as further below in DecodeNextInstruction.
    IsCurrInstTexOp();

    // If the assembler has sent us file and/or line number messages,
    // received by ParseCommentForAssemblerMesssages(),
    // then bind this information to the current instruction.
    // This info can be used in error spew to direct the shader developer
    // to exactly where a problem is located.
    m_pCurrInst->SetSpewFileNameAndLineNumber(m_pLatestSpewFileName,m_pLatestSpewLineNumber);

    if( *m_pCurrToken & D3DSI_COISSUE )
    {
        _CURR_PS_INST->m_bCoIssue = TRUE;
    }
    else if( D3DSIO_NOP != m_pCurrInst->m_Type )
    {
        m_CycleNum++; // First cycle is 1. (co-issued instructions will have same cycle number)
    }
    _CURR_PS_INST->m_CycleNum = m_CycleNum;

    m_SpewInstructionCount++; // only used for spew, not for any limits
    m_pCurrInst->m_SpewInstructionCount = m_SpewInstructionCount;

    DWORD dwReservedBits = PS_INST_TOKEN_RESERVED_MASK;

    if( (*m_pCurrToken) & dwReservedBits )
    {
        Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in instruction parameter token!  Aborting validation.");
        return FALSE;
    }

    m_pCurrToken++;

    // Decode dst param
    if (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_DstParamCount)++;
        DecodeDstParam( &m_pCurrInst->m_DstParam, *m_pCurrToken );
        if( (*m_pCurrToken) & PS_DSTPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in destination parameter token!  Aborting validation.");
            return FALSE;
        }
        m_pCurrToken++;
        if( D3DSIO_DEF == m_pCurrInst->m_Type )
        {
            // Skip source params (float vector) - nothing to check
            // This is the only instruction with 4 source params,
            // and further, this is the only instruction that has
            // raw numbers as parameters.  This justifies the
            // special case treatment here - we pretend
            // D3DSIO_DEF only has a dst param (which we will check).
            m_pCurrToken += 4;
            return TRUE;
        }
    }

    // Decode src param(s)
    while (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_SrcParamCount)++;
        if( (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount) > SHADER_INSTRUCTION_MAX_PARAMS )
        {
            m_pCurrInst->m_SrcParamCount--;
            m_pCurrToken++; // eat up extra parameters and skip to next
            continue;
        }

        // Below: index is [SrcParamCount - 1] because m_SrcParam array needs 0 based index.
        DecodeSrcParam( &(m_pCurrInst->m_SrcParam[m_pCurrInst->m_SrcParamCount - 1]),*m_pCurrToken );

        if( (*m_pCurrToken) & PS_SRCPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in source %d parameter token!  Aborting validation.",
                            m_pCurrInst->m_SrcParamCount);
            return FALSE;
        }
        m_pCurrToken++;
    }

    // Figure out which components of each source operand actually need to be read,
    // taking into account destination write mask, the type of instruction, source swizzle, etc.
    // (must be after IsCurrInstTexOp() )
    m_pCurrInst->CalculateComponentReadMasks(m_Version);

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// CBasePShaderValidator Wrapper Functions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// GetNewPSValidator
//
// Called by ValidatePixelShaderInternal and ValidatePixelShader below.
//-----------------------------------------------------------------------------
CBasePShaderValidator* GetNewPSValidator( const DWORD* pCode,
                                              const D3DCAPS8* pCaps,
                                              const DWORD Flags )
{
    if( !pCode )
        return NULL;
    else if( D3DPS_VERSION(1,4) > *pCode )
        return new CPShaderValidator10(pCode,pCaps,Flags);
    else
        return new CPShaderValidator14(pCode,pCaps,Flags);
}

//-----------------------------------------------------------------------------
// ValidatePixelShaderInternal
//-----------------------------------------------------------------------------
BOOL ValidatePixelShaderInternal( const DWORD* pCode, const D3DCAPS8* pCaps )
{
    CBasePShaderValidator * pValidator = NULL;
    BOOL bSuccess = FALSE;

    pValidator = GetNewPSValidator( pCode, pCaps, 0 );
    if( NULL == pValidator )
    {
        OutputDebugString("Out of memory.\n");
        return bSuccess;
    }
    bSuccess = SUCCEEDED(pValidator->GetStatus()) ? TRUE : FALSE;
    delete pValidator;
    return bSuccess;
}

//-----------------------------------------------------------------------------
// ValidatePixelShader
//
// Don't forget to call "free" on the buffer returned in ppBuf.
//-----------------------------------------------------------------------------
HRESULT WINAPI ValidatePixelShader( const DWORD* pCode,
                                    const D3DCAPS8* pCaps,
                                    const DWORD Flags,
                                    char** const ppBuf )
{
    CBasePShaderValidator * pValidator = NULL;
    HRESULT hr;

    pValidator = GetNewPSValidator( pCode, pCaps, Flags );
    if( NULL == pValidator )
    {
        OutputDebugString("Out of memory.\n");
        return E_FAIL;
    }
    if( ppBuf )
    {
        *ppBuf = (char*)HeapAlloc(GetProcessHeap(), 0, pValidator->GetRequiredLogBufferSize());
        if( NULL == *ppBuf )
            OutputDebugString("Out of memory.\n");
        else
            pValidator->WriteLogToBuffer(*ppBuf);
    }
    hr = pValidator->GetStatus();
    delete pValidator;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\sources.inc ===
TARGETNAME=d3dsv
TARGETPATH=obj
TARGETTYPE=LIBRARY
INCLUDES = ..;$(INCLUDES)

SOURCES =                  \
    ..\valbase.cpp         \
    ..\pshdrval.cpp        \
    ..\psval10.cpp         \
    ..\psval14.cpp         \
    ..\vshdrval.cpp        \
    ..\errlog.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\pshdrval.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.hpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __PSHDRVAL_HPP__
#define __PSHDRVAL_HPP__

#define PS_INST_TOKEN_RESERVED_MASK         0xbfff0000 // bits 16-23, 24-29, 31 must be 0
#define PS_DSTPARAM_TOKEN_RESERVED_MASK     0x4000e000 // bits 13-15, 30 must be 0
#define PS_SRCPARAM_TOKEN_RESERVED_MASK     0x4000e000 // bits 13-15, 30 must be 0

//-----------------------------------------------------------------------------
// CPSInstruction
//-----------------------------------------------------------------------------
class CPSInstruction : public CBaseInstruction
{
public:
    CPSInstruction(CPSInstruction* pPrevInst) : CBaseInstruction(pPrevInst)
    {
        m_bTexOp                    = FALSE;
        m_bTexMOp                   = FALSE;
        m_bTexOpThatReadsTexture    = FALSE;
        m_bCoIssue                  = FALSE;
        m_CycleNum                  = (UINT)-1;
    };

    void CalculateComponentReadMasks(DWORD dwVersion);

    BOOL    m_bTexOp;
    BOOL    m_bTexMOp;
    BOOL    m_bTexOpThatReadsTexture;
    BOOL    m_bCoIssue;
    UINT    m_CycleNum; // identical for co-issued instructions
};

//-----------------------------------------------------------------------------
// CBasePShaderValidator
//-----------------------------------------------------------------------------
class CBasePShaderValidator : public CBaseShaderValidator
{
protected:
    UINT            m_CycleNum;
    UINT            m_TexOpCount;
    UINT            m_BlendOpCount;
    UINT            m_TotalOpCount; // not necessarily the sum of TexOpCount and BlendOpCount....

    CRegisterFile*  m_pTempRegFile;    
    CRegisterFile*  m_pInputRegFile;
    CRegisterFile*  m_pConstRegFile;
    CRegisterFile*  m_pTextureRegFile;

    CBaseInstruction* AllocateNewInstruction(CBaseInstruction*pPrevInst);
    BOOL DecodeNextInstruction();
    virtual BOOL InitValidation() = 0;
    virtual BOOL ApplyPerInstructionRules() = 0;
    virtual void ApplyPostInstructionsRules() = 0;
    virtual void IsCurrInstTexOp() = 0;
        
public:
    CBasePShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
    ~CBasePShaderValidator();
};

//-----------------------------------------------------------------------------
// CPShaderValidator10
//-----------------------------------------------------------------------------
class CPShaderValidator10 : public CBasePShaderValidator
{
private:
    UINT            m_TexOpCount;
    UINT            m_BlendOpCount;
    UINT            m_TotalOpCount; // not necessarily the sum of TexOpCount and BlendOpCount....
    UINT            m_TexMBaseDstReg;

    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();
    void IsCurrInstTexOp();
    BOOL InitValidation();
 
    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_NegateAfterSat();
    BOOL Rule_SatBeforeBiasOrComplement();
    BOOL Rule_MultipleDependentTextureReads();
    BOOL Rule_SrcNoLongerAvailable(); 
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_TexRegsDeclaredInOrder();
    BOOL Rule_TexOpAfterNonTexOp();
    BOOL Rule_ValidTEXM3xSequence();               // Call per instruction AND after all instructions seen
    BOOL Rule_ValidTEXM3xRegisterNumbers();
    BOOL Rule_ValidCNDInstruction();
    BOOL Rule_ValidCMPInstruction();
    BOOL Rule_ValidLRPInstruction();
    BOOL Rule_ValidDEFInstruction();
    BOOL Rule_ValidDP3Instruction();
    BOOL Rule_ValidDP4Instruction();
    BOOL Rule_ValidInstructionPairing();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_R0Written();                         // Call after all instructions seen.
        
public:
    CPShaderValidator10( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
};

//-----------------------------------------------------------------------------
// CPShaderValidator14
//-----------------------------------------------------------------------------
class CPShaderValidator14 : public CBasePShaderValidator
{
private:
    UINT            m_BlendOpCount;
    int             m_Phase; // 1 == dependent read setup block, 2 == second pass
    BOOL            m_bPhaseMarkerInShader; // shader is preprocessed to set this bool
    CPSInstruction* m_pPhaseMarkerInst; // only set at the moment marker is encountered in shader
    DWORD           m_TempRegsWithZappedAlpha; // bitmask of temp regs for which alpha was zapped
                                               // (initialized->uninitialized) after the phase marker
    DWORD           m_TempRegsWithZappedBlue;  // bitmask of temp regs for which blue was zapped
                                               // (initialized->uninitialized) due to texcrd with .rg writemask

    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();
    void IsCurrInstTexOp();
    BOOL InitValidation();

    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_LimitedUseOfProjModifier(); 
    BOOL Rule_MultipleDependentTextureReads();
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidMarker();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_ValidTexOpStageAndRegisterUsage();
    BOOL Rule_TexOpAfterArithmeticOp();
    BOOL Rule_ValidTEXDEPTHInstruction();
    BOOL Rule_ValidTEXKILLInstruction();
    BOOL Rule_ValidBEMInstruction();
    BOOL Rule_ValidDEFInstruction();
    BOOL Rule_ValidInstructionPairing();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_R0Written();                         // Call after all instructions seen.
        
public:
    CPShaderValidator14( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
};


#endif __PSHDRVAL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\psval10.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.cpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CPSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_PS_INST   ((CPSInstruction*)m_pCurrInst)
#define _PREV_PS_INST   (m_pCurrInst?((CPSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// PixelShader Validation Rule Coverage
//
// Below is the list of rules in "DX8 PixelShader Version Specification",
// matched to the function(s) in this file which enforce them.
// Note that the mapping from rules to funtions can be 1->n or n->1
//
// Generic Rules
// -------------
//
// PS-G1:           Rule_R0Written
// PS-G2:           Rule_SrcInitialized
// PS-G3:           Rule_ValidDstParam
//
// TEX Op Specific Rules
// ---------------------
//
// PS-T1:           Rule_TexOpAfterNonTexOp
// PS-T2:           Rule_ValidDstParam
// PS-T3:           Rule_ValidDstParam, Rule_ValidSrcParams
// PS-T4:           Rule_TexRegsDeclaredInOrder
// PS-T5:           Rule_SrcInitialized
// PS-T6:           Rule_ValidTEXM3xSequence, Rule_ValidTEXM3xRegisterNumbers, Rule_InstructionSupportedByVersion
// PS-T7:           Rule_ValidSrcParams
//
// Co-Issue Specific Rules
// -----------------------
//
// PS-C1:           Rule_ValidInstructionPairing
// PS-C2:           Rule_ValidInstructionPairing
// PS-C3:           Rule_ValidInstructionPairing
// PS-C4:           Rule_ValidInstructionPairing
// PS-C5:           Rule_ValidInstructionPairing
//
// Instruction Specific Rules
// --------------------------
//
// PS-I1:           Rule_ValidLRPInstruction
// PS-I2:           Rule_ValidCNDInstruction
// PS-I3:           Rule_ValidDstParam
// PS-I4:           Rule_ValidDP3Instruction
// PS-I5:           Rule_ValidInstructionCount
//
// Pixel Shader Version 1.0 Rules
// ------------------------------
//
// PS.1.0-1:        InitValidation,
//                  Rule_SrcInitialized
// PS.1.0-2:        Rule_ValidInstructionPairing
// PS.1.0-3:        <empty rule>
// PS.1.0-4:        Rule_ValidInstructionCount
// PS.1.0-5:        <empty rule>

//
// Pixel Shader Version 1.1 Rules
// ------------------------------
//
// PS.1.1-1:        Rule_ValidDstParam
// PS.1.1-2:        Rule_ValidSrcParams
// PS.1.1-3:        Rule_SrcNoLongerAvailable
// PS.1.1-4:        Rule_SrcNoLongerAvailable
// PS.1.1-5:        Rule_SrcNoLongerAvailable
// PS.1.1-6:        Rule_ValidDstParam
// PS.1.1-7:        Rule_NegateAfterSat
// PS.1.1-8:        Rule_MultipleDependentTextureReads
// PS.1.1-9:        <not validated - implemented by refrast though>
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPShaderValidator10::CPShaderValidator10
//-----------------------------------------------------------------------------
CPShaderValidator10::CPShaderValidator10(   const DWORD* pCode,
                                        const D3DCAPS8* pCaps,
                                        DWORD Flags )
                                        : CBasePShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.
    // Only set m_ReturnCode to S_OK if validation has succeeded,
    // before exiting this constructor.

    m_TexMBaseDstReg        = 0;

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::IsCurrInstTexOp
//-----------------------------------------------------------------------------
void CPShaderValidator10::IsCurrInstTexOp()
{
    DXGASSERT(m_pCurrInst);

    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXM3x3:
        _CURR_PS_INST->m_bTexMOp = TRUE;
        // fall through
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXREG2RGB:
        _CURR_PS_INST->m_bTexOp = TRUE;
        break;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXM3x3:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = FALSE;
        break;
    case D3DSIO_TEX:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_TEXDP3TEX:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = TRUE;
        break;
    }
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::InitValidation
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::InitValidation()
{
    switch( m_Version >> 16 )
    {
    case 0xfffe:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****.",
                m_Version);
        return FALSE;
    case 0xffff:
        break; // pixelshader - ok.
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation.",
                m_Version);
        return FALSE;
    }

    if( m_pCaps )
    {
        if( (m_pCaps->PixelShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF) ) 
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Pixel shader version %d.%d is too high for device.  Maximum supported version is %d.%d. Aborting shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version),
                    D3DSHADER_VERSION_MAJOR(m_pCaps->PixelShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->PixelShaderVersion));
            return FALSE;
        }
    }

    switch(m_Version)
    {
    case D3DPS_VERSION(1,0):    // DX8.0
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2,FALSE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile     = new CRegisterFile(2,FALSE,1,TRUE);
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(4,FALSE,1,FALSE);
        break;
    case D3DPS_VERSION(1,1):    // DX8.0
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2,FALSE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile     = new CRegisterFile(2,FALSE,2,TRUE);
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(4,TRUE,2,FALSE);
        break;
    case D3DPS_VERSION(1,2):    // DX8.1
    case D3DPS_VERSION(1,3):    // DX8.1
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2,FALSE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile     = new CRegisterFile(2,FALSE,2,TRUE);
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(4,TRUE,3,FALSE);
        break;
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported pixel shader version. Aborting pixel shader validation.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
        return FALSE;
    }
    if( NULL == m_pTempRegFile ||
        NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pTextureRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;

   // Rules that examine source parameters
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_NegateAfterSat()                   ) goto EXIT;
    if( !   Rule_SatBeforeBiasOrComplement()        ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_MultipleDependentTextureReads()    ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcNoLongerAvailable()             ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before _ValidDstParam()

    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_TexRegsDeclaredInOrder()           ) goto EXIT;
    if( !   Rule_TexOpAfterNonTexOp()               ) goto EXIT;
    if( !   Rule_ValidTEXM3xSequence()              ) goto EXIT;
    if( !   Rule_ValidTEXM3xRegisterNumbers()       ) goto EXIT;
    if( !   Rule_ValidCNDInstruction()              ) goto EXIT;
    if( !   Rule_ValidCMPInstruction()              ) goto EXIT;
    if( !   Rule_ValidLRPInstruction()              ) goto EXIT;
    if( !   Rule_ValidDEFInstruction()              ) goto EXIT;
    if( !   Rule_ValidDP3Instruction()              ) goto EXIT;
    if( !   Rule_ValidDP4Instruction()              ) goto EXIT;
    if( !   Rule_ValidInstructionPairing()          ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CPShaderValidator10::ApplyPostInstructionsRules()
{
    Rule_ValidTEXM3xSequence(); // check once more to see if shader ended dangling in mid-sequence
    Rule_ValidInstructionCount(); // see if we went over the limits
    Rule_R0Written();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_CND:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_END:
    case D3DSIO_NOP:
    case D3DSIO_DEF:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_DP4:
    case D3DSIO_CMP:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXM3x3:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_BEM:
    case D3DSIO_PHASE:
        return TRUE; // instruction recognized - ok.
    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting pixel shader validation.");
    m_ErrorCount++;
    return FALSE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_InstructionSupportedByVersion()
{
    if( D3DPS_VERSION(1,0) <= m_Version ) // 1.0 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_MOV:
        case D3DSIO_ADD:
        case D3DSIO_SUB:
        case D3DSIO_MUL:
        case D3DSIO_MAD:
        case D3DSIO_LRP:
        case D3DSIO_DP3:
        case D3DSIO_TEX:
        case D3DSIO_DEF:
        case D3DSIO_TEXBEM:
        case D3DSIO_TEXBEML:
        case D3DSIO_CND:
        case D3DSIO_TEXKILL:
        case D3DSIO_TEXCOORD:
        case D3DSIO_TEXM3x2PAD:
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x3PAD:
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3SPEC:
        case D3DSIO_TEXM3x3VSPEC:
        case D3DSIO_TEXREG2AR:
        case D3DSIO_TEXREG2GB:
            return TRUE; // instruction supported - ok.
        }
    }
    if( D3DPS_VERSION(1,2) <= m_Version ) // 1.2 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_CMP:
        case D3DSIO_DP4:
        case D3DSIO_TEXDP3:
        case D3DSIO_TEXDP3TEX:
        case D3DSIO_TEXM3x3:
        case D3DSIO_TEXREG2RGB:
            return TRUE; // instruction supported - ok.
        }
    }

    if( D3DPS_VERSION(1,3) <= m_Version ) // 1.3
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_TEXM3x2DEPTH:
            return TRUE; // instruction supported - ok.
        }
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d pixel shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_MOV:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_CND:
    case D3DSIO_CMP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEX:
    case D3DSIO_DEF: // we skipped the last 4 parameters (float vector) - nothing to check
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_TEXM3x3:
    case D3DSIO_TEXDP3TEX:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_TEXM3x3SPEC:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count.");
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidSrcParams
//
// ** Rule:
// for each source parameter,
//      if current instruction is a texture instruction, then
//          source register type must be texture register
//          (with the exception of D3DSIO_SPEC, where Src1 must be c#), and
//          register # must be within range for texture registers, and
//          modifier must be D3DSPSM_NONE (or _BX2 for TexMatrixOps [version<=1.1], 
//                                            _BX2 for any tex* op [version>=1.2])
//          swizzle must be D3DSP_NOSWIZZLE
//      else (non texture instruction)
//          source register type must be D3DSPR_TEMP/_INPUT/_CONST/_TEXTURE
//          register # must be within range for register type
//          modifier must be D3DSPSM_NONE/_NEG/_BIAS/_BIASNEG/_SIGN/_SIGNNEG/_COMP
//          swizzle must be D3DSP_NOSWIZZLE/_REPLICATEALPHA
//                           and for ps.1.1+, D3DSP_REPLICATEBLUE (only on alpha op)
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidSrcParams()  // could break this down for more granularity
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        char* SourceName[3] = {"first", "second", "third"};
        if( _CURR_PS_INST->m_bTexOp )
        {
            if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
            {
                if( D3DSIO_TEXM3x3SPEC == m_pCurrInst->m_Type && (1 == i) )
                {
                    // for _SPEC, last source parameter must be c#
                    if( D3DSPR_CONST != pSrcParam->m_RegType ||
                        D3DSP_NOSWIZZLE != pSrcParam->m_SwizzleShift ||
                        D3DSPSM_NONE != pSrcParam->m_SrcMod )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Second source parameter for texm3x3spec must be c#.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                        goto LOOP_CONTINUE;
                    }
                }
                else
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Src reg for tex* instruction must be t# register (%s source param).",
                                    SourceName[i]);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
            }

            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type (%s source param).",
                        SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
                goto LOOP_CONTINUE;
            }

            if( pSrcParam->m_RegNum >= ValidRegNum )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num %d (%s source param).  Max allowed for this type is %d.",
                        pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch(pSrcParam->m_SrcMod)
            {
            case D3DSPSM_NONE:
                break;
            case D3DSPSM_SIGN:
                if( D3DPS_VERSION(1,1) >= m_Version )
                {
                    if( !(_CURR_PS_INST->m_bTexMOp) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "_bx2 is a valid src mod for texM* instructions only (%s source param).", SourceName[i]);
                        m_ErrorCount++;
                    }
                }
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for tex* instruction (%s source param).", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
            switch (pSrcParam->m_SwizzleShift)
            {
            case D3DSP_NOSWIZZLE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Source swizzle not allowed for tex* instruction (%s source param).", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
        else // not a tex op
        {
            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
            case D3DSPR_INPUT:      ValidRegNum = m_pInputRegFile->GetNumRegs(); break;
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for %s source param.", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            if( (!bFoundSrcError) && (pSrcParam->m_RegNum >= ValidRegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: %d for %s source param. Max allowed for this type is %d.",
                    pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SrcMod )
            {
            case D3DSPSM_NONE:
            case D3DSPSM_NEG:
            case D3DSPSM_BIAS:
            case D3DSPSM_BIASNEG:
            case D3DSPSM_SIGN:
            case D3DSPSM_SIGNNEG:
            case D3DSPSM_COMP:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for %s source param.",
                                    SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SwizzleShift )
            {
            case D3DSP_NOSWIZZLE:
            case D3DSP_REPLICATEALPHA:
                break;
            case D3DSP_REPLICATEBLUE:
                if( D3DPS_VERSION(1,1) <= m_Version )
                {
                    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
                    BOOL bVectorOp = FALSE;
                    switch( _CURR_PS_INST->m_Type )
                    {
                    case D3DSIO_DP3:
                    case D3DSIO_DP4:
                        bVectorOp = TRUE;
                        break;
                    }
                    if((m_pCurrInst->m_DstParam.m_WriteMask & (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2))
                       || bVectorOp )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Src selector .b (%s source param) is only valid for instructions that occur in the alpha pipe.",
                                           SourceName[i]);
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    break;
                }
                    
                // falling through
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src swizzle for %s source param.",
                                   SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
LOOP_CONTINUE:
        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }


    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_NegateAfterSat
//
// ** Rule:
// for each source parameter,
//      if the last write to the register had _sat destination modifier,
//      then _NEG or _BIASNEG source modifiers are not allowed (version 1.1 and below)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_NegateAfterSat()
{
    if( D3DPS_VERSION(1,2) <= m_Version )
        return TRUE;

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[i] )
            continue;

        switch( pSrcParam->m_SrcMod )
        {
        case D3DSPSM_NEG:
        case D3DSPSM_BIASNEG:
            break;
        default:
            continue;
        }

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(COMPONENT_MASKS[Component] & pSrcParam->m_ComponentReadMask) )
                continue;

            CAccessHistoryNode* pMostRecentWriter = NULL;
            switch( pSrcParam->m_RegType )
            {
            case D3DSPR_TEXTURE:
                pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_INPUT:
                pMostRecentWriter = m_pInputRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_TEMP:
                pMostRecentWriter = m_pTempRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_CONST:
                pMostRecentWriter = m_pConstRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            }

            if( pMostRecentWriter &&
                pMostRecentWriter->m_pInst &&
                (((CPSInstruction*)pMostRecentWriter->m_pInst)->m_CycleNum != _CURR_PS_INST->m_CycleNum) &&
                (D3DSPDM_SATURATE == pMostRecentWriter->m_pInst->m_DstParam.m_DstMod )
              )
            {
                AffectedComponents |= COMPONENT_MASKS[Component];
            }
        }
        if( AffectedComponents )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Cannot apply a negation source modifier on data that was last written with the saturate destination modifier. "
                "Affected components(*) of %s source param: %s",
                SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
            m_ErrorCount++;
            m_bSrcParamError[i] = TRUE;
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_SatBeforeBiasOrComplement()
//
// ** Rule:
// for each component of each source parameter,
//     if _BIAS or _COMP is applied to the source parameter, and
//     there was a previous writer that was a non-tex op
//         if the previous writer didn't do a _sat on its write, then
//              -> spew error.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_SatBeforeBiasOrComplement()
{
#ifdef SHOW_VALIDATION_WARNINGS
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[i] )
            continue;

        switch( pSrcParam->m_SrcMod )
        {
        case D3DSPSM_BIAS:
        case D3DSPSM_COMP:
            break;
        default:
            continue;
        }

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(COMPONENT_MASKS[Component] & pSrcParam->m_ComponentReadMask) )
                continue;

            CAccessHistoryNode* pMostRecentWriter = NULL;
            switch( pSrcParam->m_RegType )
            {
            case D3DSPR_TEXTURE:
                pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_INPUT:
                pMostRecentWriter = m_pInputRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_TEMP:
                pMostRecentWriter = m_pTempRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_CONST:
                pMostRecentWriter = m_pConstRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            }

            if( pMostRecentWriter &&
                pMostRecentWriter->m_pInst &&
                (((CPSInstruction*)pMostRecentWriter->m_pInst)->m_CycleNum != _CURR_PS_INST->m_CycleNum) &&
                !((CPSInstruction*)pMostRecentWriter->m_pInst)->m_bTexOp &&
                (D3DSPDM_SATURATE != pMostRecentWriter->m_pInst->m_DstParam.m_DstMod )
              )
            {
                AffectedComponents |= COMPONENT_MASKS[Component];
            }
        }
        if( AffectedComponents )
        {
            // Warnings only

            if( D3DSPSM_BIAS == pSrcParam->m_SrcMod )
                Spew( SPEW_INSTRUCTION_WARNING, m_pCurrInst,
                    "When using the bias source modifier on a register, "
                    "the previous writer should apply the saturate modifier. "
                    "This would ensure consistent behaviour across different hardware. "
                    "Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
            else
                Spew( SPEW_INSTRUCTION_WARNING, m_pCurrInst,
                    "When using the complement source modifier on a register, "
                    "the previous writer should apply the saturate destination modifier. "
                    "This would ensure consistent behaviour across different hardware. "
                    "Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
        }
    }
#endif
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_SrcNoLongerAvailable
//
// ** Rule:
// for each source parameter,
//     if it refers to a texture register then
//          for each component of the source register that needs to be read,
//              the src register cannot have been written by TEXKILL or TEXM*PAD TEXM3x2DEPTH instructions, and
//              if the instruction is a tex op then
//                  the src register cannot have been written by TEXBEM or TEXBEML
//              else
//                  the src register cannot have been read by any tex op (1.0 only)
//                          
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and before Rule_SrcInitialized(),
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_SrcNoLongerAvailable()
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[i] ) continue;

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
            {
                CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                if( pMostRecentWriter && pMostRecentWriter->m_pInst  )
                {
                    switch( pMostRecentWriter->m_pInst->m_Type )
                    {
                    case D3DSIO_TEXKILL:
                    case D3DSIO_TEXM3x2DEPTH:
                    case D3DSIO_TEXM3x2PAD:
                    case D3DSIO_TEXM3x3PAD:
                        AffectedComponents |= COMPONENT_MASKS[Component];
                    }
                }
            }
        }
        if( AffectedComponents )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Texture register result of texkill%s or texm*pad instructions must not be read. Affected components(*) of %s source param: %s",
                (D3DPS_VERSION(1,3) <= m_Version) ? ", texm3x2depth" : "",
                SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
            m_ErrorCount++;
            m_bSrcParamError[i] = TRUE;
        }

        if( _CURR_PS_INST->m_bTexOp )
        {
            AffectedComponents = 0;
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {
                    CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                    if( pMostRecentWriter && pMostRecentWriter->m_pInst )
                    {
                        switch( pMostRecentWriter->m_pInst->m_Type )
                        {
                        case D3DSIO_TEXBEM:
                        case D3DSIO_TEXBEML:
                            AffectedComponents |= COMPONENT_MASKS[Component];
                            break;
                        }
                    }
                }
            }
            if( AffectedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Texture register result of texbem or texbeml instruction must not be read by tex* instruction. Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
            }
        }
        else // non-tex op
        {
            if( D3DPS_VERSION(1,1) <= m_Version )
                continue;

            AffectedComponents = 0;
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {
                    CAccessHistoryNode* pMostRecentAccess = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentAccess;
                    if( pMostRecentAccess &&
                        pMostRecentAccess->m_pInst &&
                        pMostRecentAccess->m_bRead &&
                        ((CPSInstruction*)(pMostRecentAccess->m_pInst))->m_bTexOp )
                    {
                        AffectedComponents |= COMPONENT_MASKS[Component];
                    }
                }
            }
            if( AffectedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Texture register that has been read by a tex* instruction cannot be read by a non-tex* instruction. Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_MultipleDependentTextureReads
//
// ** Rule:
//
// Multiple dependent texture reads are disallowed.  So texture read results
// can be used as an address in a subsequent read, but the results from that
// second read cannot be used as an address in yet another subsequent read.
//
// As pseudocode:
//
// if current instruction (x) is a tex-op that reads a texture
//     for each source param of x
//         if the register is a texture register
//         and there exists a previous writer (y),
//         and y is a tex op that reads a texture
//         if there exists a souce parameter of y that was previously
//              written by an instruction that reads a texture (z)
//              SPEW(Error)
//
// NOTE that it is assumed that tex ops must write to all components, so
// only the read/write history for the R component is being checked.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and Rule_SrcInitialized()
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_MultipleDependentTextureReads()
{
    if( !_CURR_PS_INST->m_bTexOpThatReadsTexture )
        return TRUE;

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};

        if( m_bSrcParamError[i] ) continue;

        // Just looking at component 0 in this function because we assume tex ops write to all components.
        if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[0]) )
            continue;

        if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
            continue;

        CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[0][RegNum].m_pMostRecentWriter;
        if( (!pMostRecentWriter) || (!pMostRecentWriter->m_pInst) )
            continue;

        if(!((CPSInstruction*)(pMostRecentWriter->m_pInst))->m_bTexOp)
            continue;

        if(!((CPSInstruction*)(pMostRecentWriter->m_pInst))->m_bTexOpThatReadsTexture)
            continue;

        for( UINT j = 0; j < pMostRecentWriter->m_pInst->m_SrcParamCount; j++ )
        {
            if( D3DSPR_TEXTURE != pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegType )
                continue;

            CAccessHistoryNode* pRootInstructionHistoryNode =
                m_pTextureRegFile->m_pAccessHistory[0][pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegNum].m_pMostRecentWriter;

            CPSInstruction* pRootInstruction = pRootInstructionHistoryNode ? (CPSInstruction*)pRootInstructionHistoryNode->m_pInst : NULL;

            if( (D3DSPR_TEXTURE == pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegType)
                && pRootInstruction->m_bTexOpThatReadsTexture )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Multiple dependent texture reads are disallowed (%s source param).  Texture read results can be used as an address for subsequent read, but the results from that read cannot be used as an address in yet another subsequent read.",
                    SourceName[i]);
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
                break;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//      if source is a TEMP or TEXTURE register then
//          if the source swizzle is D3DSP_NOSWIZZLE then
//              if the current instruction is DP3 (a cross component op) then
//                  the r, g and b components of of the source reg
//                  must have been previously written
//              else if there is a dest parameter, then
//                  the components in the dest parameter write mask must
//                  have been written to in the source reg. previously
//              else
//                  all components of the source must have been written
//          else if the source swizzle is _REPLICATEALPHA then
//              alpha component of reg must have been previously
//              written
//
// When checking if a component has been written previously,
// it must have been written in a previous cycle - so in the
// case of co-issued instructions, initialization of a component
// by one co-issued instruction is not available to the other for read.
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;
        DWORD UninitializedComponentsMask = 0;
        CAccessHistoryNode* pWriterInCurrCycle[4] = {0, 0, 0, 0};
        UINT NumUninitializedComponents = 0;

        if( m_bSrcParamError[i] ) continue;

        switch( pSrcParam->m_RegType )
        {
            case D3DSPR_TEMP:
                pRegFile = m_pTempRegFile;
                RegChar = "r";
                break;
            case D3DSPR_TEXTURE:
                pRegFile = m_pTextureRegFile;
                RegChar = "t";
                break;
            case D3DSPR_INPUT:
                pRegFile = m_pInputRegFile;
                RegChar = "v";
                break;
            case D3DSPR_CONST:
                pRegFile = m_pConstRegFile;
                RegChar = "c";
                break;
        }
        if( !pRegFile ) continue;

        // check for read of uninitialized components
        if( D3DSPR_TEMP == pSrcParam->m_RegType ||
            D3DSPR_TEXTURE == pSrcParam->m_RegType )
        {
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                CAccessHistoryNode* pPreviousWriter = pRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                CBaseInstruction* pCurrInst = m_pCurrInst;

                // If co-issue, find the real previous writer.
                while( pPreviousWriter
                       && ((CPSInstruction*)pPreviousWriter->m_pInst)->m_CycleNum == _CURR_PS_INST->m_CycleNum )
                {
                    pWriterInCurrCycle[Component] = pPreviousWriter; // log read just before this write for co-issue
                    pPreviousWriter = pPreviousWriter->m_pPreviousWriter;
                }

                // Even if pPreviousWriter == NULL, the component could have been initialized pre-shader.
                // So to check for initialization, we look at m_bInitialized below, rather than pPreviousWrite
                if(pPreviousWriter == NULL && !pRegFile->m_pAccessHistory[Component][RegNum].m_bPreShaderInitialized)
                {
                    NumUninitializedComponents++;
                    UninitializedComponentsMask |= COMPONENT_MASKS[Component];
                }
            }

            if( NumUninitializedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                    NumUninitializedComponents > 1 ? "s" : "",
                    RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
                m_ErrorCount++;
            }
        }

        // Update register file to indicate READ.
        // Multiple reads of the same register component by the current instruction
        // will only be logged as one read in the access history.

        for( UINT Component = 0; Component < 4; Component++ )
        {
            #define PREV_READER(_CHAN,_REG) \
                    ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                    pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)

            if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( NULL != pWriterInCurrCycle[Component] )
            {
                if( !pWriterInCurrCycle[Component]->m_pPreviousReader ||
                    pWriterInCurrCycle[Component]->m_pPreviousReader->m_pInst != m_pCurrInst )
                {
                    if( !pRegFile->m_pAccessHistory[Component][RegNum].InsertReadBeforeWrite(
                                            pWriterInCurrCycle[Component], m_pCurrInst ) )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                        m_ErrorCount++;
                    }
                }
            }
            else if( PREV_READER(Component,RegNum) != m_pCurrInst )
            {
                if( !pRegFile->m_pAccessHistory[Component][RegNum].NewAccess(m_pCurrInst,FALSE) )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                    m_ErrorCount++;
                }
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDstParam
//
// ** Rule:
// if instruction is D3DSIO_DEF, then do nothing - this case has its own separate rule
// the dst register must be writable.
// if the instruction has a dest parameter (i.e. every instruction except NOP), then
//      the dst register must be of type D3DSPR_TEMP or _TEXTURE, and
//      register # must be within range for the register type, and
//      the write mask must be: .rgba, .a or .rgb
//      if instruction is a texture instruction, then
//          the dst register must be of type D3DSPR_TEXTURE, and
//          the writemask must be D3DSP_WRITEMASK_ALL, and
//          the dst modifier must be D3DSPDM_NONE (or _SAT on version > 1.2), and
//          the dst shift must be none
//      else (non tex instruction)
//          the dst modifier must be D3DSPDM_NONE or _SATURATE, and
//          dst shift must be /2, none, *2, or *4
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError = FALSE;
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT RegNum = pDstParam->m_RegNum;
    if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        // _DEF is a special instruction whose dest is a const register.
        // We do the checking for this in a separate function.
        // Also, we don't need to keep track of the fact that
        // this instruction wrote to a register (done below),
        // since _DEF just declares a constant.
        return TRUE;
    }

    if( pDstParam->m_bParamUsed )
    {
        UINT ValidRegNum = 0;

        BOOL bWritable = FALSE;
        switch( pDstParam->m_RegType )
        {
        case D3DSPR_TEMP:
            bWritable = m_pTempRegFile->IsWritable();
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        case D3DSPR_TEXTURE:
            if( _CURR_PS_INST->m_bTexOp )
                bWritable = TRUE;
            else
                bWritable = m_pTextureRegFile->IsWritable();

            ValidRegNum = m_pTextureRegFile->GetNumRegs();
            break;
        }

        if( !bWritable || !ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for dest param." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }
        else if( RegNum >= ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dest reg num: %d. Max allowed for this reg type is %d.",
                RegNum, ValidRegNum - 1);
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }
        else
        {
            // Make sure we aren't writing to a register that is no longer available.

            if( D3DSPR_TEXTURE == pDstParam->m_RegType )
            {
                for( UINT Component = 0; Component < 4; Component++ )
                {
                    CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                    if( pMostRecentWriter && pMostRecentWriter->m_pInst  )
                    {
                        switch( pMostRecentWriter->m_pInst->m_Type )
                        {
                        case D3DSIO_TEXM3x2DEPTH:
                            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                "Destination of texm3x2depth instruction (t%d) is not available elsewhere in shader.",
                                RegNum);
                            m_ErrorCount++;
                            return TRUE;
                        }
                    }
                }
            }
        }

        if( _CURR_PS_INST->m_bTexOp )
        {
            if( D3DSPR_TEXTURE != pDstParam->m_RegType )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Must use texture register a dest param for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "tex* instructions must write all components." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
                break;
            case D3DSPDM_SATURATE:
                // falling through
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction modifiers are not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest shift not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }
        else
        {
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
            case D3DSPDM_SATURATE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dst modifier." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }

            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
            case DSTSHIFT_X2:
            case DSTSHIFT_X4:
            case DSTSHIFT_D2:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dst shift." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }

        if( (D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask)
            && ((D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != pDstParam->m_WriteMask )
            && (D3DSP_WRITEMASK_3 != pDstParam->m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask must be .rgb, .a, or .rgba (all)." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        if( !bFoundDstError )
        {
            // Update register file to indicate write.
            
            CRegisterFile* pRegFile = NULL;
            switch( pDstParam->m_RegType )
            {
            case D3DSPR_TEMP:       pRegFile = m_pTempRegFile; break;
            case D3DSPR_TEXTURE:    pRegFile = m_pTextureRegFile; break;
            }

            if( pRegFile )
            {
                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_0 )
                    pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_1 )
                    pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_2 )
                    pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_3 )
                    pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEMP,TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// Multiple accesses to the same register number (in the same register class)
// only count as one access.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidRegisterPortUsage()
{
    UINT i, j;
    UINT TempRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT TextureRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT NumUniqueTempRegs = 0;
    UINT NumUniqueInputRegs = 0;
    UINT NumUniqueConstRegs = 0;
    UINT NumUniqueTextureRegs = 0;
    D3DSHADER_PARAM_REGISTER_TYPE   RegType;
    UINT                            RegNum;

    static UINT s_TempRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_InputRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_ConstRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_TextureRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_NumUniqueTempRegsAcrossCoIssue;
    static UINT s_NumUniqueInputRegsAcrossCoIssue;
    static UINT s_NumUniqueConstRegsAcrossCoIssue;
    static UINT s_NumUniqueTextureRegsAcrossCoIssue;
 
    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }
 
    for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        UINT*   pRegPortUsage = NULL;
        UINT*   pNumUniqueRegs = NULL;

        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

        switch( RegType )
        {
        case D3DSPR_TEMP:
            pRegPortUsage = TempRegPortUsage;
            pNumUniqueRegs = &NumUniqueTempRegs;
            break;
        case D3DSPR_INPUT:
            pRegPortUsage = InputRegPortUsage;
            pNumUniqueRegs = &NumUniqueInputRegs;
            break;
        case D3DSPR_CONST:
            pRegPortUsage = ConstRegPortUsage;
            pNumUniqueRegs = &NumUniqueConstRegs;
            break;
        case D3DSPR_TEXTURE:
            pRegPortUsage = TextureRegPortUsage;
            pNumUniqueRegs = &NumUniqueTextureRegs;
            break;
        }

        if( !pRegPortUsage ) continue;

        BOOL    bRegAlreadyAccessed = FALSE;
        for( j = 0; j < *pNumUniqueRegs; j++ )
        {
            if( pRegPortUsage[j] == RegNum )
            {
                bRegAlreadyAccessed = TRUE;
                break;
            }
        }
        if( !bRegAlreadyAccessed )
        {
            pRegPortUsage[*pNumUniqueRegs] = RegNum;
            (*pNumUniqueRegs)++;
        }

    }

    if( NumUniqueTempRegs > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.",
                        NumUniqueTempRegs,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueInputRegs > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.",
                        NumUniqueInputRegs,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueConstRegs > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.",
                        NumUniqueConstRegs, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueTextureRegs > m_pTextureRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different texture registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.",
                        NumUniqueTextureRegs, m_pTextureRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    // Read port limit for different register numbers of any one register type across co-issued instructions is MAX_READPORTS_ACROSS_COISSUE total.

    if( _CURR_PS_INST->m_bCoIssue && _PREV_PS_INST && !(_PREV_PS_INST->m_bCoIssue)) // second clause is just a simple sanity check -> co-issue only involved 2 instructions.
    {
        for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
        {
            UINT*   pRegPortUsageAcrossCoIssue = NULL;
            UINT*   pNumUniqueRegsAcrossCoIssue = NULL;

            RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
            RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

            switch( RegType )
            {
            case D3DSPR_TEMP:
                pRegPortUsageAcrossCoIssue = s_TempRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTempRegsAcrossCoIssue;
                break;
            case D3DSPR_INPUT:
                pRegPortUsageAcrossCoIssue = s_InputRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueInputRegsAcrossCoIssue;
                break;
            case D3DSPR_CONST:
                pRegPortUsageAcrossCoIssue = s_ConstRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueConstRegsAcrossCoIssue;
                break;
            case D3DSPR_TEXTURE:
                pRegPortUsageAcrossCoIssue = s_TextureRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTextureRegsAcrossCoIssue;
                break;
            }

            if( !pRegPortUsageAcrossCoIssue ) continue;

            BOOL    bRegAlreadyAccessed = FALSE;
            for( j = 0; j < *pNumUniqueRegsAcrossCoIssue; j++ )
            {
                if( pRegPortUsageAcrossCoIssue[j] == RegNum )
                {
                    bRegAlreadyAccessed = TRUE;
                    break;
                }
            }
            if( !bRegAlreadyAccessed )
            {
                pRegPortUsageAcrossCoIssue[*pNumUniqueRegsAcrossCoIssue] = RegNum;
                (*pNumUniqueRegsAcrossCoIssue)++;
            }
        }

        #define MAX_READPORTS_ACROSS_COISSUE    3

        if( s_NumUniqueTempRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different temp registers (r#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTempRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueInputRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different input registers (v#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueInputRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueConstRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different constant registers (c#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueConstRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueTextureRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different texture registers (t#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTextureRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }
    }

    if( !_CURR_PS_INST->m_bCoIssue )
    {
        // Copy all state to static vars so that in case next instruction is co-issued with this one, 
        // cross-coissue read port limit of 3 can be enforced.
        memcpy(&s_TempRegPortUsageAcrossCoIssue,&TempRegPortUsage,NumUniqueTempRegs*sizeof(UINT));
        memcpy(&s_InputRegPortUsageAcrossCoIssue,&InputRegPortUsage,NumUniqueInputRegs*sizeof(UINT));
        memcpy(&s_ConstRegPortUsageAcrossCoIssue,&ConstRegPortUsage,NumUniqueConstRegs*sizeof(UINT));
        memcpy(&s_TextureRegPortUsageAcrossCoIssue,&TextureRegPortUsage,NumUniqueTextureRegs*sizeof(UINT));
        s_NumUniqueTempRegsAcrossCoIssue = NumUniqueTempRegs;
        s_NumUniqueInputRegsAcrossCoIssue = NumUniqueInputRegs;
        s_NumUniqueConstRegsAcrossCoIssue = NumUniqueConstRegs;
        s_NumUniqueTextureRegsAcrossCoIssue = NumUniqueTextureRegs;
    }
    else
    {
        // reset counts because the next instruction cannot be co-issued with this one.
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_TexRegsDeclaredInOrder
//
// ** Rule:
// Tex registers must declared in increasing order.
// ex. invalid sequence:    tex t0
//                          tex t3
//                          tex t1
//
//     another invalid seq: tex t0
//                          tex t1
//                          texm3x2pad t1, t0 (t1 already declared)
//                          texm3x2pad t2, t0
//
//     valid sequence:      tex t0
//                          tex t1
//                          tex t3 (note missing t2.. OK)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_TexRegsDeclaredInOrder()
{
    static DWORD s_TexOpRegDeclOrder; // bit flags

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_TexOpRegDeclOrder = 0;
    }
    if( !_CURR_PS_INST->m_bTexOp )
        return TRUE;

    DWORD RegNum = m_pCurrInst->m_DstParam.m_RegNum;
    if( (D3DSPR_TEXTURE != m_pCurrInst->m_DstParam.m_RegType) ||
        (RegNum > m_pTextureRegFile->GetNumRegs()) )
    {
        return TRUE;
    }

    DWORD RegMask = 1 << m_pCurrInst->m_DstParam.m_RegNum;
    if( RegMask & s_TexOpRegDeclOrder)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Tex register t%d already declared.",
                        RegNum);
        m_ErrorCount++;
    } 
    else if( s_TexOpRegDeclOrder > RegMask )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "t# registers must appear in sequence (i.e. t0 before t2 OK, but t1 before t0 not valid)." );
        m_ErrorCount++;
    }
    s_TexOpRegDeclOrder |= (1 << m_pCurrInst->m_DstParam.m_RegNum);
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_TexOpAfterNonTexOp
//
// ** Rule:
// Tex ops (see IsTexOp() for which instructions are considered tex ops)
// must appear before any other instruction, with the exception of DEF or NOP.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_TexOpAfterNonTexOp()
{
    static BOOL s_bFoundNonTexOp;
    static BOOL s_bRuleDisabled;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bFoundNonTexOp = FALSE;
        s_bRuleDisabled = FALSE;
    }

    if( s_bRuleDisabled )
        return TRUE;

    // Execute the rule.

    if( !(_CURR_PS_INST->m_bTexOp)
        && m_pCurrInst->m_Type != D3DSIO_NOP
        && m_pCurrInst->m_Type != D3DSIO_DEF)
    {
        s_bFoundNonTexOp = TRUE;
        return TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && s_bFoundNonTexOp )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot use tex* instruction after non-tex* instruction." );
        m_ErrorCount++;
        s_bRuleDisabled = TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidTEXM3xSequence
//
// ** Rule:
// TEXM3x* instructions, if present in the pixel shader, must appear in
// any of the follwing sequences:
//
//      1) texm3x2pad
//      2) texm3x2tex / texdepth
//
// or   1) texm3x3pad
//      2) texm3x3pad
//      3) texm3x3tex
//
// or   1) texm3x3pad
//      2) texm3x3pad
//      3) texm3x3spec / texm3x3vspec
//
// ** When to call:
// Per instruction AND after all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidTEXM3xSequence()
{
    static UINT s_TexMSequence;
    static UINT s_LastInst;

    if( NULL == m_pCurrInst )
    {
        return TRUE;
    }

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
       s_TexMSequence = 0;
       s_LastInst = D3DSIO_NOP;
    }

    if( m_bSeenAllInstructions )
    {
        if( s_TexMSequence )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Incomplete texm* sequence." );
            m_ErrorCount++;
        }
        return TRUE;
    }

    // Execute the rule.

    if( _CURR_PS_INST->m_bTexMOp )
    {
        switch( m_pCurrInst->m_Type )
        {
        case D3DSIO_TEXM3x2PAD:
            if( s_TexMSequence ) goto _TexMSeqInvalid;
            m_TexMBaseDstReg = m_pCurrInst->m_DstParam.m_RegNum;
            s_TexMSequence = 1;
            break;
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x2DEPTH:
            // must be one 3x2PAD previous
            if ( (s_TexMSequence != 1) ||
                 (s_LastInst != D3DSIO_TEXM3x2PAD) ) goto _TexMSeqInvalid;
            s_TexMSequence = 0;
            break;
        case D3DSIO_TEXM3x3PAD:
            if (s_TexMSequence)
            {
                // if in sequence, then must be one 3x3PAD previous
                if ( (s_TexMSequence != 1) ||
                     (s_LastInst != D3DSIO_TEXM3x3PAD) ) goto _TexMSeqInvalid;
                s_TexMSequence = 2;
                break;
            }
            m_TexMBaseDstReg = m_pCurrInst->m_DstParam.m_RegNum;
            s_TexMSequence = 1;
            break;
        case D3DSIO_TEXM3x3:
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3SPEC:
        case D3DSIO_TEXM3x3VSPEC:
            // must be two 3x3PAD previous
            if ( (s_TexMSequence != 2) ||
                 (s_LastInst != D3DSIO_TEXM3x3PAD) ) goto _TexMSeqInvalid;
            s_TexMSequence = 0;
            break;
        default:
            break;
        }
        goto _TexMSeqOK;
_TexMSeqInvalid:
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid texm* sequence." );
        m_ErrorCount++;
    }
_TexMSeqOK:

    s_LastInst = m_pCurrInst->m_Type;
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidTEXM3xRegisterNumbers
//
// ** Rule:
// If instruction is a TEXM3x*, register numbers must be as follows:
//
//      1) texm3x2pad / texm3x2depth    t(x), t(y)
//      2) texm3x2tex                   t(x+1), t(y)
//
//      1) texm3x3pad                   t(x), t(y)
//      2) texm3x3pad                   t(x+1), t(y)
//      3) texm3x3tex/texm3x3           t(x+2), t(y)
//
//      1) texm3x3pad                   t(x), t(y)
//      2) texm3x3pad                   t(x+1), t(y)
//      3) texm3x3spec                  t(x+2), t(y), c#
//
//      1) texm3x3pad                   t(x), t(y)
//      2) texm3x3pad                   t(x+1), t(y)
//      3) texm3x3vspec                 t(x+2), t(y)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidTEXM3xRegisterNumbers()
{
    #define PREV_INST_TYPE(_INST) \
                ((_INST && _INST->m_pPrevInst) ? _INST->m_pPrevInst->m_Type : D3DSIO_NOP)

    #define PREV_INST_SRC0_REGNUM(_INST) \
                ((_INST && _INST->m_pPrevInst) ? _INST->m_pPrevInst->m_SrcParam[0].m_RegNum : -1)

    if( _CURR_PS_INST->m_bTexMOp )
    {
        DWORD DstParamR = m_pCurrInst->m_DstParam.m_RegNum;
        DWORD SrcParam0R = m_pCurrInst->m_SrcParam[0].m_RegNum;
        switch (m_pCurrInst->m_Type)
        {
        case D3DSIO_TEXM3x2PAD:
            break;
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x2DEPTH:
            if ( DstParamR != (m_TexMBaseDstReg + 1) )
                goto _TexMRegInvalid;
            if( SrcParam0R != PREV_INST_SRC0_REGNUM(m_pCurrInst) )
                goto _TexMRegInvalid;
            break;
        case D3DSIO_TEXM3x3PAD:
        {
            if ( D3DSIO_TEXM3x3PAD == PREV_INST_TYPE(m_pCurrInst) &&
                 (DstParamR != (m_TexMBaseDstReg + 1) ) )
                    goto _TexMRegInvalid;

            if ( D3DSIO_TEXM3x3PAD == PREV_INST_TYPE(m_pCurrInst) &&
                 (SrcParam0R != PREV_INST_SRC0_REGNUM(m_pCurrInst)) )
                    goto _TexMRegInvalid;
            break;
        }
        case D3DSIO_TEXM3x3SPEC:
            // SPEC requires second src param to be from const regs
            if ( m_pCurrInst->m_SrcParam[1].m_RegType != D3DSPR_CONST )
                goto _TexMRegInvalid;
            // fall through
        case D3DSIO_TEXM3x3:
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3VSPEC:
            if ( DstParamR != (m_TexMBaseDstReg + 2) )
                goto _TexMRegInvalid;
            if( SrcParam0R != PREV_INST_SRC0_REGNUM(m_pCurrInst) )
                    goto _TexMRegInvalid;
            break;
        default:
            break;
        }
        goto _TexMRegOK;
_TexMRegInvalid:
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid texm* register." );
        m_ErrorCount++;
    }
_TexMRegOK:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidCNDInstruction
//
// ** Rule:
// First source for cnd instruction must be 'r0.a' (exactly).
// i.e. cnd r1, r0.a, t0, t1
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidCNDInstruction()
{
    if( D3DSIO_CND == m_pCurrInst->m_Type )
    {
        SRCPARAM Src0 = m_pCurrInst->m_SrcParam[0];
        if( Src0.m_bParamUsed &&
            D3DSPR_TEMP == Src0.m_RegType &&
            0 == Src0.m_RegNum &&
            D3DSP_REPLICATEALPHA == Src0.m_SwizzleShift &&
            D3DSPSM_NONE == Src0.m_SrcMod )
        {
            return TRUE;    // Src 0 is r0.a
        }

        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "First source for cnd instruction must be 'r0.a'." );
        m_ErrorCount++;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidCMPInstruction
//
// ** Rule:
// There may be at most 3 cmp instructions per shader.
// (only executed for ps.1.2)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidCMPInstruction()
{
    static UINT s_cCMPInstCount;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_cCMPInstCount = 0;
    }

    if( D3DSIO_CMP == m_pCurrInst->m_Type && D3DPS_VERSION(1,3) >= m_Version)
    {
        s_cCMPInstCount++;

        if( 3 < s_cCMPInstCount )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Maximum of 3 cmp instructions allowed." );
            m_ErrorCount++;
        }

    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidLRPInstruction
//
// ** Rule:
// The only valid source modifier for the src0 operand for LRP is complement
// (1-reg)
// i.e. lrp r1, 1-r0, t0, t1
//
// If there was a previous writer to src0, then it must have applied
// the _sat destination modifier.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidLRPInstruction()
{
    if( D3DSIO_LRP == m_pCurrInst->m_Type )
    {
        SRCPARAM Src0 = m_pCurrInst->m_SrcParam[0];
        if( !Src0.m_bParamUsed )
            return TRUE;

        switch( Src0.m_SrcMod )
        {
        case D3DSPSM_NONE:
        case D3DSPSM_COMP:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "The only valid modifiers for the first source parameter of lrp are: reg (no mod) or 1-reg (complement)." );
            m_ErrorCount++;
        }
#ifdef SHOW_VALIDATION_WARNINGS
        UINT RegNum = Src0.m_RegNum;
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[0] )
            return TRUE;

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(COMPONENT_MASKS[Component] & Src0.m_ComponentReadMask) )
                continue;

            CAccessHistoryNode* pMostRecentWriter = NULL;
            switch( Src0.m_RegType )
            {
            case D3DSPR_TEXTURE:
                pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_INPUT:
                pMostRecentWriter = m_pInputRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_TEMP:
                pMostRecentWriter = m_pTempRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_CONST:
                pMostRecentWriter = m_pConstRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            }

            // The previous writer may be the current instruction.
            // If so, go back one step (the previous writer before the current instruction).
            if( pMostRecentWriter && pMostRecentWriter->m_pInst &&
                pMostRecentWriter->m_pInst == m_pCurrInst )
            {
                pMostRecentWriter = pMostRecentWriter->m_pPreviousWriter;
            }

            if( pMostRecentWriter &&
                pMostRecentWriter->m_pInst &&
                !((CPSInstruction*)pMostRecentWriter->m_pInst)->m_bTexOp &&
                (D3DSPDM_SATURATE != pMostRecentWriter->m_pInst->m_DstParam.m_DstMod )
              )
            {
                AffectedComponents |= COMPONENT_MASKS[Component];
            }
        }
        if( AffectedComponents )
        {
            // A warning.
            Spew( SPEW_INSTRUCTION_WARNING, m_pCurrInst,
                "Previous writer to the first source register of lrp instruction "
                "should apply the saturate destination modifier.  This ensures consistent "
                "behaviour across different hardware. "
                "Affected components(*) of first source register: %s",
                MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
        }
#endif // SHOW_VALIDATION_WARNINGS
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDEFInstruction
//
// ** Rule:
// For the DEF instruction, make sure the dest parameter is a valid constant,
// and it has no modifiers.
//
// NOTE that we are pretending this instruction only has a dst parameter.
// We skipped over the 4 source parameters since they are immediate floats,
// for which there is nothing that can be checked.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDEFInstruction()
{

    static BOOL s_bDEFInstructionAllowed;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bDEFInstructionAllowed = TRUE;
    }

    if( D3DSIO_COMMENT != m_pCurrInst->m_Type &&
        D3DSIO_DEF     != m_pCurrInst->m_Type )
    {
        s_bDEFInstructionAllowed = FALSE;
    }
    else if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        if( !s_bDEFInstructionAllowed )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Const declaration (def) must appear before other instructions." );
            m_ErrorCount++;
        }
        DSTPARAM* pDstParam = &m_pCurrInst->m_DstParam;
        if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask ||
            D3DSPDM_NONE != pDstParam->m_DstMod ||
            DSTSHIFT_NONE != pDstParam->m_DstShift ||
            D3DSPR_CONST != pDstParam->m_RegType
            )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination for def instruction must be of the form c# (# = reg number, no modifiers)." );
            m_ErrorCount++;
        }

        // Check that the register number is in bounds
        if( D3DSPR_CONST == pDstParam->m_RegType &&
            pDstParam->m_RegNum >= m_pConstRegFile->GetNumRegs() )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid const register num: %d. Max allowed is %d.",
                        pDstParam->m_RegNum,m_pConstRegFile->GetNumRegs() - 1);
            m_ErrorCount++;

        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDP3Instruction
//
// ** Rule:
// The .a result write mask is not valid for the DP3 instruction.
// (version <= 1.2)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDP3Instruction()
{
    if( D3DSIO_DP3 == m_pCurrInst->m_Type &&
        D3DPS_VERSION(1,3) >= m_Version )
    {
        if( (D3DSP_WRITEMASK_ALL != m_pCurrInst->m_DstParam.m_WriteMask)
            && ((D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != m_pCurrInst->m_DstParam.m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask must be .rgb, or .rgba (all) for dp3." );
            m_ErrorCount++;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDP4Instruction
//
// ** Rule:
// There may be at most 4 DP4 instructions per shader.
// (only executed for ps.1.2)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDP4Instruction()
{
    static UINT s_cDP4InstCount;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_cDP4InstCount = 0;
    }

    if( D3DSIO_DP4 == m_pCurrInst->m_Type && D3DPS_VERSION(1,3) >= m_Version )
    {
        s_cDP4InstCount++;

        if( 4 < s_cDP4InstCount )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Maximum of 4 dp4 instructions allowed." );
            m_ErrorCount++;
        }
    }
    return TRUE;
}


//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidInstructionPairing
//
// ** Rule:
// - If an instruction is co-issued with another instruction,
// make sure that both do not write to any of RGB at the same time,
// and that neither instruction individually writes to all of RGBA.
//
// - Co-issue can only involve 2 instructions,
// so consecutive instructions cannot have the "+" prefix (D3DSI_COISSUE).
//
// - Co-issue of instructions only applies to pixel blend instructions (non tex-ops).
//
// - The first color blend instruction cannot have "+" (D3DSI_COISSUE) set either.
//
// - NOP may not be used in a co-issue pair.
//
// - DP4 may not be used in a co-issue pair.
//
// - DP3 (dot product) always uses the color/vector pipeline (even if it is not writing
// to color components). Thus:
//      - An instruction co-issued with a dot-product can only write to alpha.
//      - A dot-product that writes to alpha cannot be co-issued.
//      - Two dot-products cannot be co-issued.
//
// - For version <= 1.0, coissued instructions must write to the same register.
//
// ------------------
// examples:
//
//      valid pair:             mov r0.a, c0
//                              +add r1.rgb, v1, c1 (note dst reg #'s can be different)
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.rgb, v1, c1
//
//      another valid pair:     dp3 r0.rgb, t1, v1
//                              +mul r0.a, t0, v0
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.a, t0, t1
//
//      invalid pair:           mov r0.rgb, c0
//                              +add r0, t0, t1  (note the dst writes to rgba)
//
//      another invalid pair:   mov r1.rgb, c1
//                              +dp3 r0.a, t0, t1 (dp3 is using up color/vector pipe)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidInstructionPairing()
{
    static BOOL s_bSeenNonTexOp;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_bSeenNonTexOp = FALSE;
    }

    if( !s_bSeenNonTexOp && !_CURR_PS_INST->m_bTexOp )
    {
        // first non-tex op.  this cannot have co-issue set.
        if( _CURR_PS_INST->m_bCoIssue )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "First arithmetic instruction cannot have co-issue ('+') set; there is no previous arithmetic instruction to pair with.");
            m_ErrorCount++;
        }
        s_bSeenNonTexOp = TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && _CURR_PS_INST->m_bCoIssue )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Cannot set co-issue ('+') on a texture instruction.  Co-issue only applies to arithmetic instructions." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        _PREV_PS_INST->m_bCoIssue )
    {
        // consecutive instructions cannot have co-issue set.
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot set co-issue ('+') on consecutive instructions." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        (D3DSIO_NOP == m_pCurrInst->m_pPrevInst->m_Type))
    {
        // NOP cannot be part of co-issue (previous instruction found to be NOP)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst, "nop instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && D3DSIO_NOP == m_pCurrInst->m_Type )
    {
        // NOP cannot be part of co-issue (current instruction found to be NOP)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "nop instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        (D3DSIO_DP4 == m_pCurrInst->m_pPrevInst->m_Type))
    {
        // DP4 cannot be part of co-issue (previous instruction found to be DP4)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst, "dp4 instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && D3DSIO_DP4 == m_pCurrInst->m_Type )
    {
        // DP4 cannot be part of co-issue (current instruction found to be DP4)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "dp4 instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && !_CURR_PS_INST->m_bTexOp &&
        NULL != m_pCurrInst->m_pPrevInst && !_PREV_PS_INST->m_bTexOp &&
        !_PREV_PS_INST->m_bCoIssue )
    {
        // instruction and previous instruction are candidate for co-issue.
        // ...do further validation...
        DWORD ColorWriteMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
        DWORD CurrInstWriteMask = 0;
        DWORD PrevInstWriteMask = 0;

        if( m_pCurrInst->m_DstParam.m_bParamUsed )
            CurrInstWriteMask = m_pCurrInst->m_DstParam.m_WriteMask;
        if( m_pCurrInst->m_pPrevInst->m_DstParam.m_bParamUsed )
            PrevInstWriteMask = m_pCurrInst->m_pPrevInst->m_DstParam.m_WriteMask;

        if( D3DSIO_DP3 == m_pCurrInst->m_Type &&
            D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                "Co-issued instructions cannot both be dot-product, since each require use of the color/vector pipeline to execute." );
            m_ErrorCount++;
        }
        else if( D3DSIO_DP3 == m_pCurrInst->m_Type )
        {
            if( ColorWriteMask & PrevInstWriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components." );
                m_ErrorCount++;
            }
            if( D3DSP_WRITEMASK_3 & CurrInstWriteMask ) // alpha in addition to the implied rgb for dp3
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used." );
                m_ErrorCount++;
            }
        }
        else if( D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
        {
            if( ColorWriteMask & CurrInstWriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components." );
                m_ErrorCount++;
            }
            if( D3DSP_WRITEMASK_3 & PrevInstWriteMask ) // alpha in addition to the implied rgb for dp3
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used by the dot product." );
                m_ErrorCount++;
            }
        }
        else
        {
            if( PrevInstWriteMask == D3DSP_WRITEMASK_ALL )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Co-issued instruction cannot write all components - must write either alpha or color." );
                m_ErrorCount++;
            }
            if( CurrInstWriteMask == D3DSP_WRITEMASK_ALL )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Co-issued instruction cannot write all components - must write either alpha or color." );
                m_ErrorCount++;
            }
            if( (m_pCurrInst->m_DstParam.m_RegType == m_pCurrInst->m_pPrevInst->m_DstParam.m_RegType) &&
                (m_pCurrInst->m_DstParam.m_RegNum == m_pCurrInst->m_pPrevInst->m_DstParam.m_RegNum) &&
                ((CurrInstWriteMask & PrevInstWriteMask) != 0) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Co-issued instructions cannot both write to the same components of a register.  Affected components: %s",
                    MakeAffectedComponentsText(CurrInstWriteMask & PrevInstWriteMask,TRUE,FALSE)
                    );
                m_ErrorCount++;
            }
            if( (CurrInstWriteMask & ColorWriteMask) && (PrevInstWriteMask & ColorWriteMask) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions cannot both write to color components." );
                m_ErrorCount++;
            }
            if( (CurrInstWriteMask & D3DSP_WRITEMASK_3) && (PrevInstWriteMask & D3DSP_WRITEMASK_3) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions cannot both write to alpha component." );
                m_ErrorCount++;
            }
        }

        if( D3DPS_VERSION(1,0) >= m_Version )
        {
            // both co-issued instructions must write to the same register number.
            if( m_pCurrInst->m_DstParam.m_RegType != m_pCurrInst->m_pPrevInst->m_DstParam.m_RegType )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions must both write to the same register type for pixelshader version <= 1.0." );
                m_ErrorCount++;
            }
            if( (m_pCurrInst->m_DstParam.m_RegNum != m_pCurrInst->m_pPrevInst->m_DstParam.m_RegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions must both write to the same register number for pixelshader version <= 1.0." );
                m_ErrorCount++;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for pixel shader version has not been exceeded.
// Separate counts are kept for texture address instructions, for
// pixel blending instructions, and for the total number of instructions.
// Note that the total may not be the sum of texture + pixel instructions.
//
// For version 1.0+, D3DSIO_TEX counts only toward the tex op limit,
// but not towards the total op count.
//
// TEXBEML takes 3 instructions.
//
// Co-issued pixel blending instructions only
// count as one instruction towards the limit.
//
// The def instruction, nop, and comments (already stripped), do not count
// toward any limits.
//
// ** When to call:
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidInstructionCount()
{
    static UINT s_MaxTexOpCount;
    static UINT s_MaxBlendOpCount;
    static UINT s_MaxTotalOpCount;

    if( NULL == m_pCurrInst )
        return TRUE;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        m_TexOpCount = 0;
        m_BlendOpCount = 0;

        switch(m_Version)
        {
        case D3DPS_VERSION(1,0):    // DX8.0
            s_MaxTexOpCount   = 4;
            s_MaxBlendOpCount = 8;
            s_MaxTotalOpCount = 8;
            break;
        default:
        case D3DPS_VERSION(1,1):    // DX8.0
        case D3DPS_VERSION(1,2):    // DX8.1
        case D3DPS_VERSION(1,3):    // DX8.1
            s_MaxTexOpCount   = 4;
            s_MaxBlendOpCount = 8;
            s_MaxTotalOpCount = 12;
            break;
        }
    }

    if( m_bSeenAllInstructions )
    {
        if( m_TexOpCount > s_MaxTexOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Too many texture addressing instruction slots used: %d. Max. allowed is %d. (Note that some texture addressing instructions may use up more than one instruction slot)",
                  m_TexOpCount, s_MaxTexOpCount);
            m_ErrorCount++;
        }
        if( m_BlendOpCount > s_MaxBlendOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Too many arithmetic instruction slots used: %d. Max. allowed (counting any co-issued pairs as 1) is %d.",
                  m_BlendOpCount, s_MaxBlendOpCount);
            m_ErrorCount++;
        }
        if( !(m_TexOpCount > s_MaxTexOpCount && m_BlendOpCount > s_MaxBlendOpCount) // not already spewed avove 2 errors
            && (m_TotalOpCount > s_MaxTotalOpCount) )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Total number of instruction slots used too high: %d. Max. allowed (counting any co-issued pairs as 1) is %d.",
                  m_TotalOpCount, s_MaxTotalOpCount);
            m_ErrorCount++;
        }
        return TRUE;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXBEML:
        m_BlendOpCount += 1;
        m_TotalOpCount += 1;
        // falling through
    case D3DSIO_TEXBEM:
        if(D3DPS_VERSION(1,0) >= m_Version )
        {
            m_TexOpCount += 2;
            m_TotalOpCount += 2;
        }
        else
        {
            m_TexOpCount += 1;
            m_TotalOpCount += 1;
        }
        break;
    case D3DSIO_TEX:
        m_TexOpCount++;
        if(D3DPS_VERSION(1,1) <= m_Version)
            m_TotalOpCount += 1;
        break;
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXM3x3:
        m_TexOpCount++;
        m_TotalOpCount++;
        break;
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_CMP:
    case D3DSIO_CND:
    case D3DSIO_DP4:
        if( !_CURR_PS_INST->m_bCoIssue )
        {
            m_BlendOpCount++;
            m_TotalOpCount++;
        }
        break;
    case D3DSIO_NOP:
    case D3DSIO_END:
    case D3DSIO_DEF:
        break;
    default:
        DXGASSERT(FALSE);
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_R0Written
//
// ** Rule:
// All components (r,g,b,a) of register R0 must have been written by the
// pixel shader.
//
// ** When to call:
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_R0Written()
{
    UINT  NumUninitializedComponents    = 0;
    DWORD UninitializedComponentsMask   = 0;

    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( NULL == m_pTempRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter )
        {
            NumUninitializedComponents++;
            UninitializedComponentsMask |= COMPONENT_MASKS[i];
        }
    }
    if( NumUninitializedComponents )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s",
            NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        m_ErrorCount++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\psval14.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.cpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CPSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_PS_INST   ((CPSInstruction*)m_pCurrInst)
#define _PREV_PS_INST   (m_pCurrInst?((CPSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

#define SWIZZLE_XYZZ (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_Z)
#define SWIZZLE_XYZW (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)
#define SWIZZLE_XYWW (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_W | D3DVS_W_W)

#define ZAPPED_ALPHA_TEXT   "Note that an unfortunate effect of the phase marker earlier in the shader is "\
                            "that the moment it is encountered in certain hardware, values previously "\
                            "written to alpha in any r# register, including the one noted here, are lost. "\
                            "In order to read alpha from an r# register after the phase marker, write to it first."

#define ZAPPED_ALPHA_TEXT2  "Note that an unfortunate effect of the phase marker in the shader is "\
                            "that the moment it is encountered in certain hardware, values previously "\
                            "written to alpha in any r# register, including r0, are lost. "\
                            "So after a phase marker, the alpha component of r0 must be written."

#define ZAPPED_BLUE_TEXT    "Note that when texcrd is used with a .xy(==.rg) writemask, "\
                            "as it is in this shader, a side effect is that anything previously "\
                            "written to the z(==b) component of the destination r# register is lost "\
                            "and this component becomes uninitialized. In order to read blue again, write to it first." 

#define ZAPPED_BLUE_TEXT2   "Note that when texcrd is used with a .xy(==.rg) writemask, "\
                            "as it is in this shader, a side effect is that anything previously "\
                            "written to the z(==b) component of the destination r# register is lost "\
                            "and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd." 

//-----------------------------------------------------------------------------
// CPShaderValidator14::CPShaderValidator14
//-----------------------------------------------------------------------------
CPShaderValidator14::CPShaderValidator14(   const DWORD* pCode,
                                            const D3DCAPS8* pCaps,
                                            DWORD Flags )
                                           : CBasePShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.
    // Only set m_ReturnCode to S_OK if validation has succeeded,
    // before exiting this constructor.

    m_Phase = 2; // default to second pass.
    m_pPhaseMarkerInst = NULL;
    m_bPhaseMarkerInShader = FALSE;
    m_TempRegsWithZappedAlpha = 0;
    m_TempRegsWithZappedBlue  = 0;

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::IsCurrInstTexOp
//-----------------------------------------------------------------------------
void CPShaderValidator14::IsCurrInstTexOp()
{
    DXGASSERT(m_pCurrInst);

    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_TEX:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
        _CURR_PS_INST->m_bTexOp = TRUE;
        break;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_TEXCOORD:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = FALSE;
        break;
    case D3DSIO_TEX:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = TRUE;
        break;
    }
}

#define MAX_NUM_STAGES_2_0  6        // #defined because there are dependencies.
//-----------------------------------------------------------------------------
// CPShaderValidator14::InitValidation
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::InitValidation()
{
    switch( m_Version >> 16 )
    {
    case 0xfffe:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****.",
                m_Version);
        return FALSE;
    case 0xffff:
        break; // pixelshader - ok.
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation.",
                m_Version);
        return FALSE;
    }

    if( m_pCaps )
    {
        if( (m_pCaps->PixelShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF) )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Pixel shader version %d.%d is too high for device.  Maximum supported version is %d.%d. Aborting shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version),
                    D3DSHADER_VERSION_MAJOR(m_pCaps->PixelShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->PixelShaderVersion));
            return FALSE;
        }
    }

    switch(m_Version)
    {
    case D3DPS_VERSION(1,4):    // DX8.1
        m_pInputRegFile     = new CRegisterFile(2,FALSE,2,TRUE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(MAX_NUM_STAGES_2_0,FALSE, 1,TRUE);
        m_pTempRegFile      = new CRegisterFile(MAX_NUM_STAGES_2_0,TRUE,3,FALSE);
        break;
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported pixel shader version. Aborting pixel shader validation.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
        return FALSE;
    }
    if( NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pTextureRegFile ||
        NULL == m_pTempRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    const DWORD* pCurrToken = m_pCurrToken;

    // Loop through all the instructions to see if a phase change marker is present.
    while( *pCurrToken != D3DPS_END() )
    {
        D3DSHADER_INSTRUCTION_OPCODE_TYPE Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*pCurrToken & D3DSI_OPCODE_MASK);

        if( D3DSIO_COMMENT == Type )
        {
            // Skip comments
            DWORD NumDWORDs = ((*pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
            pCurrToken += (NumDWORDs+1);
            continue;
        }

        if( D3DSIO_PHASE == Type )
        {
            m_bPhaseMarkerInShader = TRUE;
            m_Phase = 1;
        }

        pCurrToken++;

        // Dst param
        if (*pCurrToken & (1L<<31))
        {
            pCurrToken++;
            if( D3DSIO_DEF == Type )
            {
                pCurrToken += 4;
                continue;
            }
        }

        // Decode src param(s)
        while (*pCurrToken & (1L<<31))
        {
            pCurrToken++;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;
    if( !   Rule_ValidMarker()                      ) goto EXIT; // must be before any rule that needs to know what the current phase is

   // Rules that examine source parameters
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_MultipleDependentTextureReads()    ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before _ValidDstParam()

    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_TexOpAfterArithmeticOp()           ) goto EXIT;
    if( !   Rule_ValidTexOpStageAndRegisterUsage()  ) goto EXIT;
    if( !   Rule_LimitedUseOfProjModifier()         ) goto EXIT;
    if( !   Rule_ValidTEXDEPTHInstruction()         ) goto EXIT;
    if( !   Rule_ValidTEXKILLInstruction()          ) goto EXIT;
    if( !   Rule_ValidBEMInstruction()              ) goto EXIT;
    if( !   Rule_ValidDEFInstruction()              ) goto EXIT;
    if( !   Rule_ValidInstructionPairing()          ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CPShaderValidator14::ApplyPostInstructionsRules()
{
    Rule_ValidInstructionCount(); // see if we went over the limits
    Rule_R0Written();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_CND:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_END:
    case D3DSIO_NOP:
    case D3DSIO_DEF:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_DP4:
    case D3DSIO_CMP:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXM3x3:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_BEM:
    case D3DSIO_PHASE:
        return TRUE; // instruction recognized - ok.
    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting pixel shader validation.");
    m_ErrorCount++;
    return FALSE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_InstructionSupportedByVersion()
{
    if( D3DPS_VERSION(1,4) <= m_Version ) // 1.3 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_MOV:
        case D3DSIO_ADD:
        case D3DSIO_SUB:
        case D3DSIO_MUL:
        case D3DSIO_MAD:
        case D3DSIO_LRP:
        case D3DSIO_DP3:
        case D3DSIO_DEF:
        case D3DSIO_CND:
        case D3DSIO_CMP:
        case D3DSIO_DP4:
        case D3DSIO_BEM:
        case D3DSIO_TEX:
        case D3DSIO_TEXKILL:
        case D3DSIO_TEXDEPTH:
        case D3DSIO_TEXCOORD:
        case D3DSIO_PHASE:
            return TRUE; // instruction supported - ok.
        }
    }
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d pixel shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
    case D3DSIO_PHASE:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_MOV:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_BEM:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_CND:
    case D3DSIO_CMP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_DEF: // we skipped the last 4 parameters (float vector) - nothing to check
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_TEX:
    case D3DSIO_TEXCOORD:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count.");
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidSrcParams
//
// ** Rule:
// for each source parameter,
//      if current instruction is a texture instruction, then
//          if texcrd, source register type must be t# (texture coordinate input) 
//          else source register type must be t# or r# (temp)
//          register number must be in range
//          _DZ and _DW are the only source modifiers allowed
//          no source selector allowed,
//          except texcrd/texld which can have: .xyz(==.xyzz), nothing(=.xyzw), and .xyw(=.xyww)
//      else (non texture instruction)
//          if in phase 1 of shader, v# registers not allowed
//          t# registers not allowed (only const or temp allowed)
//          register number must be in range
//          source modifier must be one of:
//                  _NONE/_NEG/_BIAS/_BIASNEG/_SIGN/_SIGNNEG/_X2/_X2NEG
//          source selector must be one of:
//                  _NOSWIZZLE/_REPLICATEALPHA/RED/GREEN/BLUE
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidSrcParams()
{
    static DWORD s_TexcrdSrcSwizzle[MAX_NUM_STAGES_2_0];
    static BOOL  s_bSeenTexcrdSrcSwizzle[MAX_NUM_STAGES_2_0];

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        for( UINT i = 0; i < MAX_NUM_STAGES_2_0; i++ )
            s_bSeenTexcrdSrcSwizzle[i] = FALSE;
    }

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        DWORD Swizzle = pSrcParam->m_SwizzleShift;
        char szSourceName[32];
        switch(i + 1)
        {
        case 1:
            if( 1 == m_pCurrInst->m_SrcParamCount )
                sprintf( szSourceName, "(Source param) " );
            else
                sprintf( szSourceName, "(First source param) " );
            break;
        case 2:
            sprintf( szSourceName, "(Second source param) " );
            break;
        case 3:
            sprintf( szSourceName, "(Third source param) " );
            break;
        default:
            DXGASSERT(FALSE);
        }
        if( _CURR_PS_INST->m_bTexOp )
        {
            UINT ValidRegNum = 0;
            switch (m_pCurrInst->m_Type)
            {
            case D3DSIO_TEXCOORD:
                if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sSource register type must be texture coordinate input (t#) for texcrd instruction.",
                            szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
                break;
            default:
                switch(pSrcParam->m_RegType)
                {
                case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
                case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sSource register type must be temp (r#) or texture coordinate input (t#) for tex* instruction.",
                            szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                    goto LOOP_CONTINUE;
                }
                break;
            }


            if( pSrcParam->m_RegNum >= ValidRegNum )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid register number: %d.  Max allowed for this type is %d.",
                        szSourceName, pSrcParam->m_RegNum, ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            BOOL bGenericSrcModError = FALSE;
            switch(pSrcParam->m_SrcMod)
            {
            case D3DSPSM_NONE:
                break;
            case D3DSPSM_DZ:
                switch(m_pCurrInst->m_Type)
                {
                case D3DSIO_TEX: 
                    if( D3DSPR_TEMP != pSrcParam->m_RegType )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier on source param for texld only allowed if source is a temp register (r#)." );
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    if( 1 == m_Phase )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier on source param for texld only allowed in second phase of a shader.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    if( (SWIZZLE_XYZZ != Swizzle) &&
                        (SWIZZLE_XYZW != Swizzle) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier on source param for texld must be paired with source selector .xyz(=.rgb). "\
                            "Note: Using no selector is treated same as .xyz here.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    break;
                case D3DSIO_TEXCOORD:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier cannot be used on source parameter for texcrd. "\
                            "It is only available to texld instruction, when source parameter is temp register (r#).");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                    break;
                default:
                    bGenericSrcModError = TRUE; break;
                }
                break;
            case D3DSPSM_DW:
                switch(m_pCurrInst->m_Type)
                {
                case D3DSIO_TEX: 
                    if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dw(=_da) modifier on source param for texld only allowed if source is a texture coordinate register (t#)." );
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    // falling through
                case D3DSIO_TEXCOORD: 
                    if( SWIZZLE_XYWW != Swizzle )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dw(=_da) modifier on source param must be paired with source selector .xyw(=.rga)." );
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    break;
                default:
                    bGenericSrcModError = TRUE; break;
                }
                break;
            default:
                bGenericSrcModError = TRUE; break;
            }
            if( bGenericSrcModError )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source modifier for tex* instruction.", szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch (m_pCurrInst->m_Type)
            {
            case D3DSIO_TEXCOORD:
                if( (SWIZZLE_XYZZ != Swizzle) &&
                    (SWIZZLE_XYZW != Swizzle) &&
                    (SWIZZLE_XYWW != Swizzle) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Source for texcrd requires component selector .xyw(==.rga), or .xyz(==.rgb). "\
                        "Note: Using no selector is treated same as .xyz here.");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                break;
            case D3DSIO_TEX:
                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {                    
                if( (SWIZZLE_XYZZ != Swizzle) &&
                    (SWIZZLE_XYZW != Swizzle) &&
                    (SWIZZLE_XYWW != Swizzle) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Using a texture coordinate register (t#) as source for texld requires component selector .xyw(=.rga), or .xyz(=.rgb). "\
                            "Note: Using no selector is treated same as .xyz here.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                        
                    }
                }
                else if( D3DSPR_TEMP == pSrcParam->m_RegType )
                {
                    if( (SWIZZLE_XYZZ != Swizzle) &&
                        (SWIZZLE_XYZW != Swizzle) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Using a temp register (r#) as source for texld requires component selector .xyz(==.rgb). "\
                            "Note: Using no selector is treated same as .xyz here.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                }
                break;
            default:
                switch (pSrcParam->m_SwizzleShift)
                {
                case D3DSP_NOSWIZZLE:
                    break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source selector for tex* instruction.", szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                break;
            }

            switch(m_pCurrInst->m_Type)
            {
            case D3DSIO_TEXCOORD:
            case D3DSIO_TEX:
                if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
                    break;

                // Verify that if a specific t# register is read more than once, each read uses the same source selector.
                if( s_bSeenTexcrdSrcSwizzle[pSrcParam->m_RegNum] )
                {
                    // only check rgb swizzle (ignore a)
                    if( (Swizzle & (0x3F << D3DVS_SWIZZLE_SHIFT)) != (s_TexcrdSrcSwizzle[pSrcParam->m_RegNum] & (0x3F << D3DVS_SWIZZLE_SHIFT) ))
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Texture coordinate register t%d read more than once in shader with different source selector (swizzle). "\
                            "Multiple reads of identical texture coordinate register throughout shader must all use identical source selector. "\
                            "Note this does not restrict mixing use and non-use of a source modifier (i.e. _dw/_da or _dz/_db, depending what the swizzle allows) on these coordinate register reads.",
                            pSrcParam->m_RegNum);
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                }
                s_bSeenTexcrdSrcSwizzle[pSrcParam->m_RegNum] = TRUE;
                s_TexcrdSrcSwizzle[pSrcParam->m_RegNum] = Swizzle;
                break;
            }

        }
        else // not a tex op
        {
            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_INPUT:
                if( 1 == m_Phase )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInput registers (v#) are not available in phase 1 of the shader.", szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                else
                {
                    ValidRegNum = m_pInputRegFile->GetNumRegs(); 
                }
                break;
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEMP:       ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sTexture coordinate registers (t#) are not available to arithmetic instructions.", szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid register type.", szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            if( (!bFoundSrcError) && (pSrcParam->m_RegNum >= ValidRegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid register number: %d. Max allowed for this type is %d.",
                    szSourceName, pSrcParam->m_RegNum, ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SrcMod )
            {
            case D3DSPSM_NONE:
            case D3DSPSM_NEG:
            case D3DSPSM_BIAS:
            case D3DSPSM_BIASNEG:
            case D3DSPSM_SIGN:
            case D3DSPSM_SIGNNEG:
            case D3DSPSM_COMP:
            case D3DSPSM_X2:
            case D3DSPSM_X2NEG:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source modifier.",
                                    szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SwizzleShift )
            {
            case D3DSP_NOSWIZZLE:
            case D3DSP_REPLICATERED:
            case D3DSP_REPLICATEGREEN:
            case D3DSP_REPLICATEBLUE:
            case D3DSP_REPLICATEALPHA:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source selector.",
                                   szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
LOOP_CONTINUE:
        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_LimitedUseOfProjModifier
//
// ** Rule:
// _dz may only appear at most 2 times in shader.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_LimitedUseOfProjModifier()
{
    static UINT s_ProjZModifierCount;
    static BOOL s_bSpewedError;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_ProjZModifierCount = 0;
        s_bSpewedError = FALSE;
    }

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        if( m_bSrcParamError[i] )
            continue;

        if( D3DSPSM_DZ == m_pCurrInst->m_SrcParam[i].m_SrcMod)
        {
            s_ProjZModifierCount++;
        }

        if( (2 < s_ProjZModifierCount) && (FALSE == s_bSpewedError)  )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "_dz(=_db) modifier may only be used at most 2 times in a shader." );
            s_bSpewedError = TRUE;
            m_ErrorCount++;
        }
    }
        
    return TRUE;    
}


//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//      if source is a TEMP register then
//          the components flagged in the component read mask
//          (computed elsewhere) for the paramter must have been initialized
//
// When checking if a component has been written previously,
// it must have been written in a previous cycle - so in the
// case of co-issued instructions, initialization of a component
// by one co-issued instruction is not available to the other for read.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    BOOL bDestParamIsSrc = pDstParam->m_ComponentReadMask;
    UINT SrcParamCount = bDestParamIsSrc ? 1 : m_pCurrInst->m_SrcParamCount; // assumes if dest param is src, 
                                                                             // there are no source params in instruction
    for( UINT i = 0; i < SrcParamCount; i++ )
    {
        DWORD UninitializedComponentsMask = 0;
        CAccessHistoryNode* pWriterInCurrCycle[4] = {0, 0, 0, 0};
        UINT NumUninitializedComponents = 0;
        UINT RegNum = bDestParamIsSrc ? pDstParam->m_RegNum : m_pCurrInst->m_SrcParam[i].m_RegNum;
        D3DSHADER_PARAM_REGISTER_TYPE Type = bDestParamIsSrc ? pDstParam->m_RegType : m_pCurrInst->m_SrcParam[i].m_RegType;
        DWORD ComponentReadMask = bDestParamIsSrc ? pDstParam->m_ComponentReadMask : m_pCurrInst->m_SrcParam[i].m_ComponentReadMask;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;

        if( !bDestParamIsSrc && m_bSrcParamError[i] ) 
            continue;

        switch( Type ) 
        {
            case D3DSPR_TEMP:
                pRegFile = m_pTempRegFile;
                RegChar = "r";
                break;
            case D3DSPR_TEXTURE:
                pRegFile = m_pTextureRegFile;
                RegChar = "t";
                break;
            case D3DSPR_INPUT:
                pRegFile = m_pInputRegFile;
                RegChar = "v";
                break;
            case D3DSPR_CONST:
                pRegFile = m_pConstRegFile;
                RegChar = "c";
                break;
        }
        if( !pRegFile ) 
            continue;

        if( RegNum >= pRegFile->GetNumRegs() )
            continue;

        // check for read of uninitialized components
        if( D3DSPR_TEMP == Type ) // only bother doing this for temp regs, since everything else is initialized.
        {
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                CAccessHistoryNode* pPreviousWriter = pRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                CBaseInstruction* pCurrInst = m_pCurrInst;

                // If co-issue, find the real previous writer.
                while( pPreviousWriter
                       && ((CPSInstruction*)pPreviousWriter->m_pInst)->m_CycleNum == _CURR_PS_INST->m_CycleNum )
                {
                    pWriterInCurrCycle[Component] = pPreviousWriter; // log read just before this write for co-issue
                    pPreviousWriter = pPreviousWriter->m_pPreviousWriter;
                }

                // Even if pPreviousWriter == NULL, the component could have been initialized pre-shader.
                // So to check for initialization, we look at m_bInitialized below, rather than pPreviousWrite
                if(pPreviousWriter == NULL && !pRegFile->m_pAccessHistory[Component][RegNum].m_bPreShaderInitialized)
                {
                    NumUninitializedComponents++;
                    UninitializedComponentsMask |= COMPONENT_MASKS[Component];
                }
            }

            if( NumUninitializedComponents )
            {
                if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
                    (m_TempRegsWithZappedAlpha & (1 << RegNum ) ) &&
                    (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
                    (m_TempRegsWithZappedBlue & (1 << RegNum ) ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s. "\
                        ZAPPED_BLUE_TEXT " Also: " ZAPPED_ALPHA_TEXT,
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                } 
                else if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
                    (m_TempRegsWithZappedAlpha & (1 << RegNum ) ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s. "\
                        ZAPPED_ALPHA_TEXT,
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                } 
                else if( (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
                    (m_TempRegsWithZappedBlue & (1 << RegNum ) ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s. "\
                        ZAPPED_BLUE_TEXT,
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                } 
                else
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                }

                m_ErrorCount++;
            }
        }

        // Update register file to indicate READ.
        // Multiple reads of the same register component by the current instruction
        // will only be logged as one read in the access history.

        for( UINT Component = 0; Component < 4; Component++ )
        {
            #define PREV_READER(_CHAN,_REG) \
                    ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                    pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)

            if( !(ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( NULL != pWriterInCurrCycle[Component] )
            {
                if( !pWriterInCurrCycle[Component]->m_pPreviousReader ||
                    pWriterInCurrCycle[Component]->m_pPreviousReader->m_pInst != m_pCurrInst )
                {
                    if( !pRegFile->m_pAccessHistory[Component][RegNum].InsertReadBeforeWrite(
                                            pWriterInCurrCycle[Component], m_pCurrInst ) )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                        m_ErrorCount++;
                    }
                }
            }
            else if( PREV_READER(Component,RegNum) != m_pCurrInst )
            {
                if( !pRegFile->m_pAccessHistory[Component][RegNum].NewAccess(m_pCurrInst,FALSE) )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                    m_ErrorCount++;
                }
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_MultipleDependentTextureReads
//
// ** Rule:
//
// Multiple dependent texture reads are disallowed.  So texture read results
// can be used as an address in a subsequent read, but the results from that
// second read cannot be used as an address in yet another subsequent read.
//
// As pseudocode:
//
// if current instruction (x) is a tex-op that reads a texture
//     for each source param of x
//         if the register is a texture register
//         and there exists a previous writer (y),
//         and y is a tex op that reads a texture
//         if there exists a souce parameter of y that was previously
//              written by an instruction that reads a texture (z)
//              SPEW(Error)
//
// NOTE that it is assumed that tex ops must write to all components, so
// only the read/write history for the R component is being checked.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and Rule_SrcInitialized()
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
BOOL CPShaderValidator14::Rule_MultipleDependentTextureReads()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT DstRegNum = pDstParam->m_RegNum;
    char RegChar;
    #define THREE_TUPLE 3

    if( !_CURR_PS_INST->m_bTexOp )
        return TRUE;

    BOOL bDestParamIsSrc = pDstParam->m_ComponentReadMask;

    UINT SrcParamCount = bDestParamIsSrc ? 1 : m_pCurrInst->m_SrcParamCount; // assumes if dest param is src, 
                                                                             // there are no source params in instruction
    if( D3DSPR_TEMP != pDstParam->m_RegType )
        return TRUE;

    for( UINT SrcParam = 0; SrcParam < SrcParamCount; SrcParam++ ) 
    {
        
        if( !bDestParamIsSrc && m_bSrcParamError[SrcParam] ) 
            continue;

        SRCPARAM* pSrcParam = bDestParamIsSrc ? NULL : &(m_pCurrInst->m_SrcParam[SrcParam]);
        UINT SrcRegNum = bDestParamIsSrc ? DstRegNum : pSrcParam->m_RegNum;
        CRegisterFile* pSrcRegFile = NULL;

        switch( bDestParamIsSrc ? pDstParam->m_RegType : pSrcParam->m_RegType ) 
        {
            case D3DSPR_TEMP:
                pSrcRegFile = m_pTempRegFile;
                RegChar = 'r';
                break;
            case D3DSPR_TEXTURE:
                pSrcRegFile = m_pTextureRegFile;
                RegChar = 't';
                break;
        }
        if( !pSrcRegFile ) 
            continue;

        if( SrcRegNum >= pSrcRegFile->GetNumRegs() )
            continue;

        for( UINT SrcComp = 0; SrcComp < THREE_TUPLE; SrcComp++ ) // Tex ops only read 3-tuples.
        {
            CAccessHistoryNode* pPreviousWriter = pSrcRegFile->m_pAccessHistory[SrcComp][SrcRegNum].m_pMostRecentWriter;
            CPSInstruction* pInst = pPreviousWriter ? (CPSInstruction*)pPreviousWriter->m_pInst : NULL;

            if( !pInst || !pInst->m_bTexOp )
                continue;

            // If the previous writer was in the current phase of the shader, spew an error.
            if( !m_pPhaseMarkerInst || (pInst->m_CycleNum > m_pPhaseMarkerInst->m_CycleNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                    "The current tex* instruction reads from %c%d, which was written earlier by another "\
                    "tex* instruction in the same block of tex* instructions.  Dependent reads "\
                    "are not permitted within a single block of tex* instructions.  To perform a dependent read, "\
                    "separate texture coordinate derivation from the tex* instruction using the coordinates "\
                    "with a 'phase' marker.", 
                    RegChar,SrcRegNum );

                m_ErrorCount++;

                return TRUE; // Lets only spew this warning once per instruction.
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidDstParam
//
// ** Rule:
// I instruction is D3DSIO_DEF, then do nothing - this case has its own separate rule
// The dst register must be writable.
// If the instruction has a dest parameter (i.e. every instruction except NOP), then
//      the dst register must be of type D3DSPR_TEXTURE, and
//      register # must be within range
//      if instruction is a texture instruction, then
//          the dst register must be of type D3DSPR_TEMP, and
//          the writemask must be D3DSP_WRITEMASK_ALL 
//             or (.rgb for texcrd, .rg for texcrd with _dw source mod), and
//          the dst modifier must be D3DSPDM_NONE (or _SAT on version > 1.1), and
//          the dst shift must be none
//      else (non tex instruction)
//          the dst modifier must be D3DSPDM_NONE or _SATURATE, and
//          dst shift must be /2, none, *2, or *4
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError = FALSE;
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT RegNum = pDstParam->m_RegNum;
    if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        // _DEF is a special instruction whose dest is a const register.
        // We do the checking for this in a separate function.
        // Also, we don't need to keep track of the fact that
        // this instruction wrote to a register (done below),
        // since _DEF just declares a constant.
        return TRUE;
    }

    if( pDstParam->m_bParamUsed )
    {
        UINT ValidRegNum = 0;
        BOOL bWritingToDest = TRUE;

        switch( pDstParam->m_RegType )
        {
        case D3DSPR_TEMP:
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        case D3DSPR_TEXTURE:
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        }

        if( D3DSIO_TEXKILL == m_pCurrInst->m_Type )
        {
            bWritingToDest = FALSE;
        }

        if( 0 == ValidRegNum ||
            (D3DSPR_TEXTURE == pDstParam->m_RegType && bWritingToDest) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid register type for destination param." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        } 
        else if( RegNum >= ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid destination register number: %d. Max allowed for this register type is %d.",
                RegNum, ValidRegNum - 1);
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        if( _CURR_PS_INST->m_bTexOp )
        {
            switch( m_pCurrInst->m_Type )
            {
            case D3DSIO_TEXCOORD:
                if( D3DSPSM_DW == m_pCurrInst->m_SrcParam[0].m_SrcMod )
                {
                    if( (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1) != pDstParam->m_WriteMask )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "texcrd with _dw(=_da) source modifier must use .xy(=.rg) destination writemask.");
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
                else
                {
                    if( (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != pDstParam->m_WriteMask )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "texcrd must use .xyz(=.rgb) destination writemask.");
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
                break;
            case D3DSIO_TEX:
            case D3DSIO_TEXKILL:
            case D3DSIO_TEXDEPTH:
                if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "texld/texkill/texdepth instructions must write all components." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }
                break;
            }
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction modifiers not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination shift not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }
        else
        {
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
            case D3DSPDM_SATURATE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid instruction modifier." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }

            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
            case DSTSHIFT_X2:
            case DSTSHIFT_X4:
            case DSTSHIFT_X8:
            case DSTSHIFT_D2:
            case DSTSHIFT_D4:
            case DSTSHIFT_D8:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid destination shift." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }

        // Update register file to indicate write.
        if( !bFoundDstError && bWritingToDest)
        {
            CRegisterFile* pRegFile = NULL;
            DWORD WriteMask = pDstParam->m_WriteMask;

            switch( pDstParam->m_RegType )
            {
            case D3DSPR_TEMP:    pRegFile = m_pTempRegFile; break;
            }

            if( pRegFile )
            {
                if( WriteMask & D3DSP_WRITEMASK_0 )
                    pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( WriteMask & D3DSP_WRITEMASK_1 )
                    pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( WriteMask & D3DSP_WRITEMASK_2 )
                    pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);
                else if( D3DSIO_TEXCOORD == m_pCurrInst->m_Type ) 
                {
                    // texcrd without b writemask uninitializes b channel.
                    // alpha also gets uninitialized, but phase marker alpha-nuke takes care of that anyway,
                    // and if the texcrd was in the first phase, noone could have written to the register
                    // so there would be nothing to nuke.
                    if( pRegFile->m_pAccessHistory[2][RegNum].m_pMostRecentWriter )
                    {
                        m_pTempRegFile->m_pAccessHistory[2][RegNum].~CAccessHistory();
                        m_pTempRegFile->m_pAccessHistory[2][RegNum].CAccessHistory::CAccessHistory();
                        m_TempRegsWithZappedBlue |= 1 << RegNum;
                    }
                }
                    
                if( WriteMask & D3DSP_WRITEMASK_3 )
                    pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// Multiple accesses to the same register number (in the same register class)
// only count as one access.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidRegisterPortUsage()
{
    UINT i, j;
    UINT TempRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT TextureRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT NumUniqueTempRegs = 0;
    UINT NumUniqueInputRegs = 0;
    UINT NumUniqueConstRegs = 0;
    UINT NumUniqueTextureRegs = 0;
    D3DSHADER_PARAM_REGISTER_TYPE   RegType;
    UINT                            RegNum;

    static UINT s_TempRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_InputRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_ConstRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_TextureRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_NumUniqueTempRegsAcrossCoIssue;
    static UINT s_NumUniqueInputRegsAcrossCoIssue;
    static UINT s_NumUniqueConstRegsAcrossCoIssue;
    static UINT s_NumUniqueTextureRegsAcrossCoIssue;
 
    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }
 
    for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        UINT*   pRegPortUsage = NULL;
        UINT*   pNumUniqueRegs = NULL;

        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

        switch( RegType )
        {
        case D3DSPR_TEMP:
            pRegPortUsage = TempRegPortUsage;
            pNumUniqueRegs = &NumUniqueTempRegs;
            break;
        case D3DSPR_INPUT:
            pRegPortUsage = InputRegPortUsage;
            pNumUniqueRegs = &NumUniqueInputRegs;
            break;
        case D3DSPR_CONST:
            pRegPortUsage = ConstRegPortUsage;
            pNumUniqueRegs = &NumUniqueConstRegs;
            break;
        case D3DSPR_TEXTURE:
            pRegPortUsage = TextureRegPortUsage;
            pNumUniqueRegs = &NumUniqueTextureRegs;
            break;
        }

        if( !pRegPortUsage ) continue;

        BOOL    bRegAlreadyAccessed = FALSE;
        for( j = 0; j < *pNumUniqueRegs; j++ )
        {
            if( pRegPortUsage[j] == RegNum )
            {
                bRegAlreadyAccessed = TRUE;
                break;
            }
        }
        if( !bRegAlreadyAccessed )
        {
            pRegPortUsage[*pNumUniqueRegs] = RegNum;
            (*pNumUniqueRegs)++;
        }

    }

    if( NumUniqueTempRegs > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.",
                        NumUniqueTempRegs,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueInputRegs > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.",
                        NumUniqueInputRegs,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueConstRegs > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.",
                        NumUniqueConstRegs, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueTextureRegs > m_pTextureRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different texture coordinate registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.",
                        NumUniqueTextureRegs, m_pTextureRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    // Read port limit for different register numbers of any one register type across co-issued instructions is MAX_READPORTS_ACROSS_COISSUE total.

    if( _CURR_PS_INST->m_bCoIssue && _PREV_PS_INST && !(_PREV_PS_INST->m_bCoIssue)) // second 2 clauses are just a simple sanity check -> co-issue only involved 2 instructions.
    {
        for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
        {
            UINT*   pRegPortUsageAcrossCoIssue = NULL;
            UINT*   pNumUniqueRegsAcrossCoIssue = NULL;

            RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
            RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

            switch( RegType )
            {
            case D3DSPR_TEMP:
                pRegPortUsageAcrossCoIssue = s_TempRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTempRegsAcrossCoIssue;
                break;
            case D3DSPR_INPUT:
                pRegPortUsageAcrossCoIssue = s_InputRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueInputRegsAcrossCoIssue;
                break;
            case D3DSPR_CONST:
                pRegPortUsageAcrossCoIssue = s_ConstRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueConstRegsAcrossCoIssue;
                break;
            case D3DSPR_TEXTURE:
                pRegPortUsageAcrossCoIssue = s_TextureRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTextureRegsAcrossCoIssue;
                break;
            }

            if( !pRegPortUsageAcrossCoIssue ) continue;

            BOOL    bRegAlreadyAccessed = FALSE;
            for( j = 0; j < *pNumUniqueRegsAcrossCoIssue; j++ )
            {
                if( pRegPortUsageAcrossCoIssue[j] == RegNum )
                {
                    bRegAlreadyAccessed = TRUE;
                    break;
                }
            }
            if( !bRegAlreadyAccessed )
            {
                pRegPortUsageAcrossCoIssue[*pNumUniqueRegsAcrossCoIssue] = RegNum;
                (*pNumUniqueRegsAcrossCoIssue)++;
            }
        }

        #define MAX_READPORTS_ACROSS_COISSUE    3

        if( s_NumUniqueTempRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different temp registers (r#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTempRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueInputRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different input registers (v#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueInputRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueConstRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different constant registers (c#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueConstRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueTextureRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different texture coordinate registers (t#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTextureRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }
    }

    if( !_CURR_PS_INST->m_bCoIssue )
    {
        // Copy all state to static vars so that in case next instruction is co-issued with this one, 
        // cross-coissue read port limit of 3 can be enforced.
        memcpy(&s_TempRegPortUsageAcrossCoIssue,&TempRegPortUsage,NumUniqueTempRegs*sizeof(UINT));
        memcpy(&s_InputRegPortUsageAcrossCoIssue,&InputRegPortUsage,NumUniqueInputRegs*sizeof(UINT));
        memcpy(&s_ConstRegPortUsageAcrossCoIssue,&ConstRegPortUsage,NumUniqueConstRegs*sizeof(UINT));
        memcpy(&s_TextureRegPortUsageAcrossCoIssue,&TextureRegPortUsage,NumUniqueTextureRegs*sizeof(UINT));
        s_NumUniqueTempRegsAcrossCoIssue = NumUniqueTempRegs;
        s_NumUniqueInputRegsAcrossCoIssue = NumUniqueInputRegs;
        s_NumUniqueConstRegsAcrossCoIssue = NumUniqueConstRegs;
        s_NumUniqueTextureRegsAcrossCoIssue = NumUniqueTextureRegs;
    }
    else
    {
        // reset counts because the next instruction cannot be co-issued with this one.
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidTexOpStageAndRegisterUsage
//
// ** Rule:
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidTexOpStageAndRegisterUsage()
{
    static DWORD s_RegUsed; // bitfield representing if a retister has been used as a destination in this block of tex ops.

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_RegUsed = 0;
    }
    else if( D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        s_RegUsed = 0;
    }

    if( !_CURR_PS_INST->m_bTexOp )
        return TRUE;

    if( D3DSPR_TEMP != m_pCurrInst->m_DstParam.m_RegType )
        return TRUE;

    UINT RegNum = m_pCurrInst->m_DstParam.m_RegNum;
    if( RegNum >= m_pTempRegFile->GetNumRegs() )
        return TRUE; // error spewed elsewhere

    if( s_RegUsed & (1<<RegNum) )
    {
        if( 1 == m_Phase )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                  "Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. "\
                  "Second use of this register as a tex* destination is only available after the phase marker. ",
                  RegNum, RegNum );
        }
        else // 2 == m_Phase
        {
            if( m_bPhaseMarkerInShader )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                  "Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. "\
                  "An r# register may be used as the destination for a tex* instruction at most once before the phase marker and once after. ",
                  RegNum, RegNum );
            }
            else // no phase marker present.  Different spew to indicate 
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                  "Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. "\
                  "To perform two tex* instructions with the same destination register, they must be separated by inserting a phase marker. ",
                  RegNum, RegNum );
            }
        }
        m_ErrorCount++;
        return TRUE;
    }

    s_RegUsed |= (1<<RegNum);

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_TexOpAfterArithmeticOp
//
// ** Rule:
// Tex ops (see IsTexOp() for which instructions are considered tex ops)
// must appear before any other instruction, with the exception of DEF or NOP.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_TexOpAfterArithmeticOp()
{
    static BOOL s_bSeenArithmeticOp;
    static BOOL s_bRuleDisabled;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenArithmeticOp = FALSE;
    }

    if( !(_CURR_PS_INST->m_bTexOp)
        && (D3DSIO_NOP != m_pCurrInst->m_Type)
        && (D3DSIO_DEF != m_pCurrInst->m_Type)
        && (D3DSIO_PHASE != m_pCurrInst->m_Type) )
    {
        s_bSeenArithmeticOp = TRUE;
        return TRUE;
    }

    if( D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        s_bSeenArithmeticOp = FALSE; // reset flag because we are in new phase of shader.
        return TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && s_bSeenArithmeticOp )
    {
        if( m_bPhaseMarkerInShader )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "tex* instructions cannot be after arithmetic instructions "\
                                                       "within one phase of the shader.  Each phase can have a block of "\
                                                       "tex* instructions followed by a block of arithmetic instructions. " );
        }
        else
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "tex* instructions cannot be after arithmetic instructions. "\
                                                       "The exception is if a phase marker is present in the shader - "\
                                                       "this separates a shader into two phases.  Each phase may have "\
                                                       "a set of tex* instructions followed by a set of arithmetic instructions.  " );
        }
        m_ErrorCount++;
        s_bRuleDisabled = TRUE;
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidMarker
//
// ** Rule:
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE if more than one marker encountered.  Else TRUE
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidMarker()
{
    static BOOL s_bSeenMarker;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenMarker = FALSE;
    }

    if( D3DSIO_PHASE != m_pCurrInst->m_Type )
        return TRUE;

    if( s_bSeenMarker )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Multiple phase markers not permitted.  Aborting shader validation." );
        m_ErrorCount++;
        return FALSE;
    }

    s_bSeenMarker = TRUE;
    m_pPhaseMarkerInst = (CPSInstruction*)m_pCurrInst;
    m_Phase++;

    // Loop through all temp registers and nuke alpha access history (if any).
    // Remember what we nuked, so if the shader tries to read one of these nuked alphas, we
    // can debug spew that certain hardware is wacko and can't help but commit this atrocity.
    for( UINT i = 0; i < m_pTempRegFile->GetNumRegs(); i++ )
    {
        if( m_pTempRegFile->m_pAccessHistory[3][i].m_pMostRecentWriter )
        {
            m_pTempRegFile->m_pAccessHistory[3][i].~CAccessHistory();
            m_pTempRegFile->m_pAccessHistory[3][i].CAccessHistory::CAccessHistory();
            m_TempRegsWithZappedAlpha |= 1 << i;
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidTEXKILLInstruction
//
// ** Rule:
// texkill may only be present in phase 2
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidTEXKILLInstruction()
{
    if( (D3DSIO_TEXKILL == m_pCurrInst->m_Type) && (1 == m_Phase))
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "When a phase marker is present in a shader, texkill is only permitted after the phase marker." );
        m_ErrorCount++;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidBEMInstruction
//
// ** Rule:
// bem must have writemask .r, .g or .rg
// bem may only be present once in a shader, in phase 1.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidBEMInstruction()
{
    static BOOL s_bSeenBem;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenBem = FALSE;
    }

    if( (D3DSIO_BEM == m_pCurrInst->m_Type))
    {
        if( s_bSeenBem )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "bem may only be used once in a shader." );
            m_ErrorCount++;
        }

        if( 2 == m_Phase )
        {
            if( m_bPhaseMarkerInShader )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "bem may only be used before the phase marker." );
            }
            else
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "To use bem, a phase marker must be present later in the shader." );
            }
            m_ErrorCount++;
        }

        if( m_pCurrInst->m_DstParam.m_WriteMask != (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1))
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Writemask for bem must be '.rg'" );
            m_ErrorCount++;            
        }

        for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
        {
            SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);

            if(m_bSrcParamError[i])
                continue;

            if( 0 == i )
            {
                if( (D3DSPR_TEMP != pSrcParam->m_RegType) &&
                    (D3DSPR_CONST != pSrcParam->m_RegType) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "First source parameter for bem must be temp (r#) or constant (c#) register." );
                    m_ErrorCount++;            
                    
                }
            }
            else if( 1 == i )
            {
                if( (D3DSPR_TEMP != pSrcParam->m_RegType ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Second source parameter for bem must be temp (r#) register." );
                    m_ErrorCount++;            
                    
                }
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidTEXDEPTHInstruction
//
// ** Rule:
// texdepth must operate on r5.
// texdepth may only be present after a phase marker.
// texdepth may only be used once.
// Once texdepth has been used in a shader, r5 is no longer available
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidTEXDEPTHInstruction()
{
    static BOOL s_bSeenTexDepth;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenTexDepth = FALSE;
    }

    if( D3DSIO_TEXDEPTH == m_pCurrInst->m_Type )
    {
        if( s_bSeenTexDepth )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Only one use of texdepth is permitted." );
            m_ErrorCount++;
            return TRUE;
        }
        s_bSeenTexDepth = TRUE;

        DSTPARAM* pDstParam = &m_pCurrInst->m_DstParam;
        if( (5 != pDstParam->m_RegNum) || (D3DSPR_TEMP != pDstParam->m_RegType) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination for texdepth must be r5." );
            m_ErrorCount++;
        }

        if( (D3DSIO_TEXDEPTH == m_pCurrInst->m_Type) && (1 == m_Phase))
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "When a phase marker is present in a shader, texdepth is only permitted after the phase marker." );
            m_ErrorCount++;
        }
    }
    else if( s_bSeenTexDepth )
    {
        UINT RegNum;
        D3DSHADER_PARAM_REGISTER_TYPE RegType;
        for( UINT i = 0; i <= m_pCurrInst->m_SrcParamCount; i++ )
        {
            if( m_pCurrInst->m_SrcParamCount == i )
            {
                RegNum = m_pCurrInst->m_DstParam.m_RegNum;
                RegType = m_pCurrInst->m_DstParam.m_RegType;
            }
            else
            {
                RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;
                RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
            }
            if( (5 == RegNum) && (D3DSPR_TEMP == RegType) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "After texdepth instruction, r5 is no longer available in shader." );
                m_ErrorCount++;
                return TRUE;
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidDEFInstruction
//
// ** Rule:
// For the DEF instruction, make sure the dest parameter is a valid constant,
// and it has no modifiers.
//
// NOTE that we are pretending this instruction only has a dst parameter.
// We skipped over the 4 source parameters since they are immediate floats,
// for which there is nothing that can be checked.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidDEFInstruction()
{
    static BOOL s_bDEFInstructionAllowed;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bDEFInstructionAllowed = TRUE;
    }

    if( D3DSIO_COMMENT != m_pCurrInst->m_Type &&
        D3DSIO_DEF     != m_pCurrInst->m_Type )
    {
        s_bDEFInstructionAllowed = FALSE;
    }
    else if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        if( !s_bDEFInstructionAllowed )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Const declaration (def) must appear before other instructions." );
            m_ErrorCount++;
        }
        DSTPARAM* pDstParam = &m_pCurrInst->m_DstParam;
        if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask ||
            D3DSPDM_NONE != pDstParam->m_DstMod ||
            DSTSHIFT_NONE != pDstParam->m_DstShift ||
            D3DSPR_CONST != pDstParam->m_RegType
            )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination for def instruction must be of the form c# (# = reg number, no modifiers)." );
            m_ErrorCount++;
        }

        // Check that the register number is in bounds
        if( D3DSPR_CONST == pDstParam->m_RegType &&
            pDstParam->m_RegNum >= m_pConstRegFile->GetNumRegs() )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid const register num: %d. Max allowed is %d.",
                        pDstParam->m_RegNum,m_pConstRegFile->GetNumRegs() - 1);
            m_ErrorCount++;

        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidInstructionPairing
//
// ** Rule:
// - If an instruction is co-issued with another instruction,
// make sure that both do not write to any of RGB at the same time,
// and that neither instruction individually writes to all of RGBA.
//
// - Co-issue can only involve 2 instructions,
// so consecutive instructions cannot have the "+" prefix (D3DSI_COISSUE).
//
// - Co-issue of instructions only applies to pixel blend instructions (non tex-ops).
//
// - The first color blend instruction cannot have "+" (D3DSI_COISSUE) set either.
//
// - NOP may not be used in a co-issue pair.
//
// - DP3 (dot product) always uses the color/vector pipeline (even if it is not writing
// to color components). Thus:
//      - An instruction co-issued with a dot-product can only write to alpha.
//      - A dot-product that writes to alpha cannot be co-issued.
//      - Two dot-products cannot be co-issued.
//
// - For version <= 1.0, coissued instructions must write to the same register.
//
// ------------------
// examples:
//
//      valid pair:             mov r0.a, c0
//                              +add r1.rgb, v1, c1 (note dst reg #'s can be different)
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.rgb, v1, c1
//
//      another valid pair:     dp3 r0.rgb, t1, v1
//                              +mul r0.a, t0, v0
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.a, t0, t1
//
//      invalid pair:           mov r0.rgb, c0
//                              +add r0, t0, t1  (note the dst writes to rgba)
//
//      another invalid pair:   mov r1.rgb, c1
//                              +dp3 r0.a, t0, t1 (dp3 is using up color/vector pipe)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidInstructionPairing()
{
    static BOOL s_bSeenArithOp;
    BOOL bCurrInstCoIssuable = TRUE;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_bSeenArithOp = FALSE;
    }

    if( !_CURR_PS_INST->m_bTexOp )
    {
        switch( m_pCurrInst->m_Type )
        {
        case D3DSIO_PHASE:
        case D3DSIO_DEF:
        case D3DSIO_NOP:
        case D3DSIO_DP4:
            bCurrInstCoIssuable = FALSE;
            break;
        }
    }

    if( D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        s_bSeenArithOp = FALSE;
    }
    else if( bCurrInstCoIssuable )
    {
        s_bSeenArithOp = TRUE;
    }

    if( !_CURR_PS_INST->m_bCoIssue )
        return TRUE;

    if( _CURR_PS_INST->m_bTexOp )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Cannot set co-issue ('+') on a tex* instruction.  Co-issue only applies to arithmetic instructions." );
        m_ErrorCount++;
        return TRUE;
    }

    if( !s_bSeenArithOp || NULL == m_pCurrInst->m_pPrevInst )
    {
        if( D3DSIO_PHASE == m_pCurrInst->m_Type )
        {
            // cannot have co-issue set because we haven't seen an arithmetic op above.
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Phase marker cannot be co-issued.");
        }
        else
        {
            // cannot have co-issue set because we haven't seen an arithmetic op above.
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Instruction cannot have co-issue ('+') set without a previous arithmetic instruction to pair with.");
        }
        m_ErrorCount++;
        return TRUE;
    }

    if( _PREV_PS_INST->m_bCoIssue )
    {
        // consecutive instructions cannot have co-issue set.
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot set co-issue ('+') on consecutive instructions." );
        m_ErrorCount++;
        return TRUE;
    }

    for( UINT i = 0; i < 2; i++ )
    {
        CBaseInstruction* pInst;
        if( 0 == i )
            pInst = m_pCurrInst;
        else
            pInst = m_pCurrInst->m_pPrevInst;
            
        switch( pInst->m_Type )
        {
        case D3DSIO_PHASE:
            // Phase marker cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "phase marker cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_DEF:
            // DEF cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "def cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_NOP:
            // NOP cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "nop cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_DP4:
            // DP4 cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "dp4 cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_BEM:
            // BEM cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "bem cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        }

    }

    #define COLOR_WRITE_MASK (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2)
    #define ALPHA_WRITE_MASK D3DSP_WRITEMASK_3
    DWORD CurrInstWriteMask = 0;
    DWORD PrevInstWriteMask = 0;

    if( m_pCurrInst->m_DstParam.m_bParamUsed )
        CurrInstWriteMask = m_pCurrInst->m_DstParam.m_WriteMask;
    if( m_pCurrInst->m_pPrevInst->m_DstParam.m_bParamUsed )
        PrevInstWriteMask = m_pCurrInst->m_pPrevInst->m_DstParam.m_WriteMask;

    if( D3DSIO_DP3 == m_pCurrInst->m_Type &&
        D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                            "Co-issued instructions cannot both be dp3, since each require use of the color pipe to execute." );
        m_ErrorCount++;
    }
    else if( D3DSIO_DP3 == m_pCurrInst->m_Type )
    {
        if( COLOR_WRITE_MASK & PrevInstWriteMask )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                            "dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components." );
            m_ErrorCount++;
        }
        if( D3DSP_WRITEMASK_3 & CurrInstWriteMask ) // alpha in addition to the implied rgb for dp3
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                            "dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes." );
            m_ErrorCount++;
        }
    }
    else if( D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
    {
        if( COLOR_WRITE_MASK & CurrInstWriteMask )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                            "dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components." );
            m_ErrorCount++;
        }
        if( D3DSP_WRITEMASK_3 & PrevInstWriteMask ) // alpha in addition to the implied rgb for dp3
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                            "dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes." );
            m_ErrorCount++;
        }
    }

    if( (PrevInstWriteMask & ALPHA_WRITE_MASK) && (PrevInstWriteMask & COLOR_WRITE_MASK))
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                        "Individual instruction in co-issue pair cannot write both alpha and color component(s)." );
        m_ErrorCount++;
    }

    if( (CurrInstWriteMask & ALPHA_WRITE_MASK) && (CurrInstWriteMask & COLOR_WRITE_MASK))
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                        "Individual instruction in co-issue pair cannot write both alpha and color component(s)." );
        m_ErrorCount++;
    }

    if( CurrInstWriteMask & PrevInstWriteMask )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                        "Co-issued instructions cannot both write to the same component(s).  One instruction must write to alpha and the other may write to any combination of red/green/blue.  Destination registers may differ." );
        m_ErrorCount++;
    }

    if( !((CurrInstWriteMask | PrevInstWriteMask) & ALPHA_WRITE_MASK) )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                        "One of the instructions in a co-issue pair must write to alpha only (.a writemask)." );
        m_ErrorCount++;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for pixel shader version has not been exceeded.
//
// Co-issued pixel blending instructions only
// count as one instruction towards the limit.
//
// The def instruction, nop, and comments (already stripped), do not count
// toward any limits.
//
// ** When to call:
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidInstructionCount()
{
    static UINT s_MaxTexOpCount;
    static UINT s_MaxArithmeticOpCount;

    if( NULL == m_pCurrInst )
        return TRUE;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        m_TexOpCount = 0;
        m_BlendOpCount = 0;
        m_TotalOpCount = 0;

        switch(m_Version)
        {
        default:
        case D3DPS_VERSION(1,4):    // DX8.1
            s_MaxTexOpCount         = 6;
            s_MaxArithmeticOpCount  = 8;
            break;
        }
    }

    if( m_bSeenAllInstructions || D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        if( m_pCurrInst && (D3DSIO_PHASE == m_pCurrInst->m_Type) )
        {
            if( m_TexOpCount > s_MaxTexOpCount )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) tex* instructions before phase marker. Max. allowed in a phase is %d.",
                      m_TexOpCount, s_MaxTexOpCount);
                m_ErrorCount++;
            }
            if( m_BlendOpCount > s_MaxArithmeticOpCount )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) arithmetic instructions before phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.",
                      m_BlendOpCount, s_MaxArithmeticOpCount);
                m_ErrorCount++;
            }
        }
        else // 2 == m_Phase
        {
            if( m_bPhaseMarkerInShader )
            {
                if( m_TexOpCount > s_MaxTexOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) tex* instructions after phase marker. Max. allowed in a phase is %d.",
                          m_TexOpCount, s_MaxTexOpCount);
                    m_ErrorCount++;
                }
                if( m_BlendOpCount > s_MaxArithmeticOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) arithmetic instructions after phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.",
                          m_BlendOpCount, s_MaxArithmeticOpCount);
                    m_ErrorCount++;
                }
            }
            else // defaulted to phase 2 because no phase marker was in shader
            {
                if( m_TexOpCount > s_MaxTexOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) tex* instructions. Max. allowed is %d. Note that adding a phase marker to the shader would double the number of instructions available.",
                          m_TexOpCount, s_MaxTexOpCount);
                    m_ErrorCount++;
                }
                if( m_BlendOpCount > s_MaxArithmeticOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) arithmetic instructions. Max. allowed (counting any co-issued pairs as 1) is %d. Note that adding a phase marker to the shader would double the number of instructions available.",
                          m_BlendOpCount, s_MaxArithmeticOpCount);
                    m_ErrorCount++;
                }
            }
        }
        if( m_pCurrInst && D3DSIO_PHASE == m_pCurrInst->m_Type )
        {
            // reset counters for next phase.
            m_TexOpCount = 0;
            m_BlendOpCount = 0;
            m_TotalOpCount = 0;
        }
        return TRUE;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEX:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
        m_TexOpCount++;
        m_TotalOpCount++;
        break;
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_CND:
    case D3DSIO_CMP:
    case D3DSIO_DP4:
        if( !_CURR_PS_INST->m_bCoIssue )
        {
            m_BlendOpCount++;
            m_TotalOpCount++;
        }
        break;
    case D3DSIO_BEM:
        m_BlendOpCount+=2;
        m_TotalOpCount+=2;
        break;
    case D3DSIO_END:
    case D3DSIO_NOP:
    case D3DSIO_DEF:
        break;
    default:
        DXGASSERT(FALSE);
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_R0Written
//
// ** Rule:
// All components (r,g,b,a) of register R0 must have been written by the
// pixel shader.
//
// ** When to call:
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_R0Written()
{
    UINT  NumUninitializedComponents    = 0;
    DWORD UninitializedComponentsMask   = 0;

    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( NULL == m_pTempRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter )
        {
            NumUninitializedComponents++;
            UninitializedComponentsMask |= COMPONENT_MASKS[i];
        }
    }
    if( NumUninitializedComponents )
    {
        if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
            (m_TempRegsWithZappedAlpha & (1 << 0 /*regnum=0*/ ) ) &&
            (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
            (m_TempRegsWithZappedBlue & (1 << 0 /*regnum=0*/ ) ) )
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s. "\
               ZAPPED_BLUE_TEXT2 " Also: " ZAPPED_ALPHA_TEXT2,
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }
        else if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
            (m_TempRegsWithZappedAlpha & (1 << 0 /*regnum=0*/ ) ) )
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s. "\
               ZAPPED_ALPHA_TEXT2,
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }
        else if( (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
           (m_TempRegsWithZappedBlue & (1 << 0 /*regnum=0*/ ) ) )
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s. "\
               ZAPPED_BLUE_TEXT2,
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }
        else
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s",
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }

        m_ErrorCount++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
__CLIP_NAME(D3DFE_PROCESSVERTICES *pv,
            ClipVertex **inv, 
            ClipVertex **outv,
            int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * pv->vcache.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * pv->vcache.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int __CLIP_LINE_NAME(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\valbase.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// valbase.cpp
//
// Direct3D Reference Device - PixelShader validation common infrastructure
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// DSTPARAM::DSTPARAM
//-----------------------------------------------------------------------------
DSTPARAM::DSTPARAM()
{
    m_bParamUsed        = FALSE;
    m_RegNum            = (UINT)-1;
    m_WriteMask         = 0;
    m_DstMod            = D3DSPDM_NONE;
    m_DstShift          = (DSTSHIFT)-1;
    m_RegType           = (D3DSHADER_PARAM_REGISTER_TYPE)-1;
    m_ComponentReadMask = 0;
}

//-----------------------------------------------------------------------------
// SRCPARAM::SRCPARAM
//-----------------------------------------------------------------------------
SRCPARAM::SRCPARAM()
{  
    m_bParamUsed            = FALSE;
    m_RegNum                = (UINT)-1;
    m_SwizzleShift          = D3DSP_NOSWIZZLE;
    m_AddressMode           = D3DVS_ADDRMODE_ABSOLUTE;
    m_RelativeAddrComponent = 0;
    m_SrcMod                = D3DSPSM_NONE;
    m_RegType               = (D3DSHADER_PARAM_REGISTER_TYPE)-1;
    m_ComponentReadMask     = D3DSP_WRITEMASK_ALL;
}

//-----------------------------------------------------------------------------
// CBaseInstruction::CBaseInstruction
//-----------------------------------------------------------------------------
CBaseInstruction::CBaseInstruction(CBaseInstruction* pPrevInst)
{
    m_Type                  = D3DSIO_NOP;
    m_SrcParamCount         = 0;
    m_DstParamCount         = 0;
    m_pPrevInst             = pPrevInst;
    m_pNextInst             = NULL;
    m_pSpewLineNumber       = NULL;
    m_pSpewFileName         = NULL;
    m_SpewInstructionCount  = 0;

    if( pPrevInst )
    {
        pPrevInst->m_pNextInst = this;
    }
}

//-----------------------------------------------------------------------------
// CBaseInstruction::SetSpewFileNameAndLineNumber
//-----------------------------------------------------------------------------
void CBaseInstruction::SetSpewFileNameAndLineNumber(const char* pFileName, const DWORD* pLineNumber)
{
    m_pSpewFileName = pFileName;
    m_pSpewLineNumber = pLineNumber;
}

//-----------------------------------------------------------------------------
// CBaseInstruction::MakeInstructionLocatorString
//
// Don't forget to 'delete' the string returned.
//-----------------------------------------------------------------------------
char* CBaseInstruction::MakeInstructionLocatorString()
{
    
    for(UINT Length = 128; Length < 65536; Length *= 2)
    {
        int BytesStored;
        char *pBuffer = new char[Length];

        if( !pBuffer )
        {
            OutputDebugString("Out of memory.\n");
            return NULL;
        }

        if( m_pSpewFileName )
        {
            BytesStored = _snprintf( pBuffer, Length, "%s(%d) : ", 
                m_pSpewFileName, m_pSpewLineNumber ? *m_pSpewLineNumber : 1);
        }
        else
        {
            BytesStored = _snprintf( pBuffer, Length, "(Statement %d) ", 
                m_SpewInstructionCount );
        }


        if( BytesStored >= 0 )
            return pBuffer;

        delete [] pBuffer;
    }

    return NULL;
}

//-----------------------------------------------------------------------------
// CAccessHistoryNode::CAccessHistoryNode
//-----------------------------------------------------------------------------
CAccessHistoryNode::CAccessHistoryNode( CAccessHistoryNode* pPreviousAccess, 
                                        CAccessHistoryNode* pPreviousWriter,
                                        CAccessHistoryNode* pPreviousReader,
                                        CBaseInstruction* pInst,
                                        BOOL bWrite )
{
    DXGASSERT(pInst);

    m_pNextAccess       = NULL;
    m_pPreviousAccess   = pPreviousAccess;
    if( m_pPreviousAccess )
        m_pPreviousAccess->m_pNextAccess = this;

    m_pPreviousWriter   = pPreviousWriter;
    m_pPreviousReader   = pPreviousReader;
    m_pInst             = pInst;
    m_bWrite            = bWrite;
    m_bRead             = !bWrite;
}

//-----------------------------------------------------------------------------
// CAccessHistory::CAccessHistory
//-----------------------------------------------------------------------------
CAccessHistory::CAccessHistory()
{
    m_pFirstAccess          = NULL;
    m_pMostRecentAccess     = NULL;
    m_pMostRecentWriter     = NULL;
    m_pMostRecentReader     = NULL;
    m_bPreShaderInitialized = FALSE;
}

//-----------------------------------------------------------------------------
// CAccessHistory::~CAccessHistory
//-----------------------------------------------------------------------------
CAccessHistory::~CAccessHistory()
{
    CAccessHistoryNode* pCurrNode = m_pFirstAccess;
    CAccessHistoryNode* pDeleteMe;
    while( pCurrNode )
    {
        pDeleteMe = pCurrNode;
        pCurrNode = pCurrNode->m_pNextAccess;
        delete pDeleteMe;
    }
}

//-----------------------------------------------------------------------------
// CAccessHistory::NewAccess
//-----------------------------------------------------------------------------
BOOL CAccessHistory::NewAccess(CBaseInstruction* pInst, BOOL bWrite )
{
    m_pMostRecentAccess = new CAccessHistoryNode(   m_pMostRecentAccess, 
                                                    m_pMostRecentWriter,
                                                    m_pMostRecentReader,
                                                    pInst,
                                                    bWrite );
    if( NULL == m_pMostRecentAccess )
    {
        return FALSE;   // out of memory
    }
    if( m_pFirstAccess == NULL )
    {
        m_pFirstAccess = m_pMostRecentAccess;            
    }
    if( bWrite )
    {
        m_pMostRecentWriter = m_pMostRecentAccess;
    }
    else // it is a read.
    {
        m_pMostRecentReader = m_pMostRecentAccess;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CAccessHistory::InsertReadBeforeWrite
//-----------------------------------------------------------------------------
BOOL CAccessHistory::InsertReadBeforeWrite(CAccessHistoryNode* pWriteNode, CBaseInstruction* pInst)
{
    DXGASSERT(pWriteNode && pWriteNode->m_bWrite && pInst );

    // append new node after node before pWriteNode
    CAccessHistoryNode* pReadBeforeWrite 
                        = new CAccessHistoryNode(  pWriteNode->m_pPreviousAccess, 
                                                   pWriteNode->m_pPreviousWriter,
                                                   pWriteNode->m_pPreviousReader,
                                                   pInst,
                                                   FALSE);
    if( NULL == pReadBeforeWrite )
    {
        return FALSE; // out of memory
    }

    // Patch up all the dangling pointers

    // Pointer to first access may change
    if( m_pFirstAccess == pWriteNode )
    {
        m_pFirstAccess = pReadBeforeWrite;
    }

    // Pointer to most recent reader may change
    if( m_pMostRecentReader == pWriteNode->m_pPreviousReader )
    {
        m_pMostRecentReader = pReadBeforeWrite;
    }

    // Update all m_pPreviousRead pointers that need to be updated to point to the newly
    // inserted read.
    CAccessHistoryNode* pCurrAccess = pWriteNode;
    while(pCurrAccess && 
         !(pCurrAccess->m_bRead && pCurrAccess->m_pPreviousAccess && pCurrAccess->m_pPreviousAccess->m_bRead) )
    {
        pCurrAccess->m_pPreviousReader = pReadBeforeWrite;
        pCurrAccess = pCurrAccess->m_pPreviousAccess;
    }

    // re-attach pWriteNode and the accesses linked after it back to the original list
    pWriteNode->m_pPreviousAccess = pReadBeforeWrite;
    pReadBeforeWrite->m_pNextAccess = pWriteNode;

    return TRUE;
}

//-----------------------------------------------------------------------------
// CRegisterFile::CRegisterFile
//-----------------------------------------------------------------------------
CRegisterFile::CRegisterFile(UINT NumRegisters, 
                             BOOL bWritable, 
                             UINT NumReadPorts, 
                             BOOL bPreShaderInitialized)
{
    m_bInitOk = FALSE;
    m_NumRegisters = NumRegisters;
    m_bWritable = bWritable;
    m_NumReadPorts = NumReadPorts;

    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( m_NumRegisters )
        {
            m_pAccessHistory[i] = new CAccessHistory[m_NumRegisters];
            if( NULL == m_pAccessHistory[i] )
            {
                OutputDebugString( "Direct3D Shader Validator: Out of memory.\n" );
                m_NumRegisters = 0;
                return;
            }
        }
        for( UINT j = 0; j < m_NumRegisters; j++ )
        {
            m_pAccessHistory[i][j].m_bPreShaderInitialized = bPreShaderInitialized;
        }
        // To get the access history for a component of a register, use:
        // m_pAccessHistory[component][register number]
    }
}

//-----------------------------------------------------------------------------
// CRegisterFile::~CRegisterFile
//-----------------------------------------------------------------------------
CRegisterFile::~CRegisterFile()
{
    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        delete [] m_pAccessHistory[i];
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::CBaseShaderValidator
//-----------------------------------------------------------------------------
CBaseShaderValidator::CBaseShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags )
{
    m_ReturnCode            = E_FAIL;  // do this first.
    m_bBaseInitOk           = FALSE;

    m_pLog                  = new CErrorLog(Flags & SHADER_VALIDATOR_LOG_ERRORS);
    if( NULL == m_pLog )
    {
        OutputDebugString("D3D PixelShader Validator: Out of memory.\n");
        return;
    }

    // ----------------------------------------------------
    // Member variable initialization
    //

    m_pCaps                 = pCaps;
    m_ErrorCount            = 0;
    m_bSeenAllInstructions  = FALSE;
    m_SpewInstructionCount  = 0;
    m_pInstructionList      = NULL;
    m_pCurrInst             = NULL;
    m_pCurrToken            = pCode; // can be null - vertex shader fixed function 
    if( m_pCurrToken )
        m_Version           = *(m_pCurrToken++);
    else
        m_Version           = 0;

    m_pLatestSpewLineNumber = NULL; 
    m_pLatestSpewFileName   = NULL;

    for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
    {
        m_bSrcParamError[i] = FALSE;
    }

    m_bBaseInitOk           = TRUE;
    return;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::~CBaseShaderValidator
//-----------------------------------------------------------------------------
CBaseShaderValidator::~CBaseShaderValidator()
{
    while( m_pCurrInst )    // Delete the linked list of instructions
    {
        CBaseInstruction* pDeleteMe = m_pCurrInst;
        m_pCurrInst = m_pCurrInst->m_pPrevInst;
        delete pDeleteMe;
    }
    delete m_pLog;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::DecodeDstParam
//-----------------------------------------------------------------------------
void CBaseShaderValidator::DecodeDstParam( DSTPARAM* pDstParam, DWORD Token )
{
    DXGASSERT(pDstParam);
    pDstParam->m_bParamUsed = TRUE;
    pDstParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pDstParam->m_WriteMask = Token & D3DSP_WRITEMASK_ALL;
    pDstParam->m_DstMod = (D3DSHADER_PARAM_DSTMOD_TYPE)(Token & D3DSP_DSTMOD_MASK);
    pDstParam->m_DstShift = (DSTSHIFT)((Token & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT );
    pDstParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::DecodeSrcParam
//-----------------------------------------------------------------------------
void CBaseShaderValidator::DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token )
{
    DXGASSERT(pSrcParam);
    pSrcParam->m_bParamUsed = TRUE;
    pSrcParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pSrcParam->m_SwizzleShift = Token & D3DSP_SWIZZLE_MASK;
    pSrcParam->m_AddressMode = (D3DVS_ADDRESSMODE_TYPE)(Token & D3DVS_ADDRESSMODE_MASK);
    pSrcParam->m_RelativeAddrComponent = COMPONENT_MASKS[(Token >> 14) & 0x3];
    pSrcParam->m_SrcMod = (D3DSHADER_PARAM_SRCMOD_TYPE)(Token & D3DSP_SRCMOD_MASK);
    pSrcParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::ValidateShader
//-----------------------------------------------------------------------------
void CBaseShaderValidator::ValidateShader()
{
    m_SpewInstructionCount++; // Consider the version token as the first
                              // statement (1) for spew counting.

    if( !InitValidation() )                 // i.e. Set up max register counts
    {
        // Returns false on:
        // 1) Unrecognized version token, 
        // 2) Vertex shader declaration validation with no shader code (fixed function).
        //    In this case InitValidation() sets m_ReturnCode as appropriate.
        return;
    }

    // Loop through all the instructions
    while( *m_pCurrToken != D3DPS_END() )
    {
        m_pCurrInst = AllocateNewInstruction(m_pCurrInst);  // New instruction in linked list
        if( NULL == m_pCurrInst )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory." );
            return;
        }
        if( NULL == m_pInstructionList )
            m_pInstructionList = m_pCurrInst;

        if( !DecodeNextInstruction() )
            return;
        
        // Skip comments
        if( m_pCurrInst->m_Type == D3DSIO_COMMENT )
        {
            CBaseInstruction* pDeleteMe = m_pCurrInst;
            m_pCurrInst = m_pCurrInst->m_pPrevInst;
            if( pDeleteMe == m_pInstructionList )
                m_pInstructionList = NULL;
            delete pDeleteMe;
            continue; 
        }

        for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
        {
            m_bSrcParamError[i] = FALSE;
        }

        // Apply all the per-instruction rules - order the rule checks sensibly.
        // Note: Rules only return FALSE if they find an error that is so severe that it is impossible to
        //       continue validation.

        if( !ApplyPerInstructionRules() )
            return;
    }

    m_bSeenAllInstructions = TRUE;

    // Apply any rules that also need to run after all instructions seen.
    // 
    // NOTE: It is possible to get here with m_pCurrInst == NULL, if there were no
    // instructions.  So any rules you add here must be able to account for that
    // possiblity.
    //
    ApplyPostInstructionsRules();

    // If no errors, then success!
    if( 0 == m_ErrorCount )
        m_ReturnCode = D3D_OK;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::ParseCommentForAssemblerMessages
//-----------------------------------------------------------------------------
void CBaseShaderValidator::ParseCommentForAssemblerMessages(const DWORD* pComment)
{
    if( !pComment )
        return;

    // There must be at least 2 DWORDS in the comment
    if( (((*(pComment++)) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT) < 2 )
        return;

    switch(*(pComment++))
    {
    case MAKEFOURCC('F','I','L','E'):
        m_pLatestSpewFileName = (const char*)pComment;
        break;
    case MAKEFOURCC('L','I','N','E'):
        m_pLatestSpewLineNumber = pComment;
        break;
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::Spew
//-----------------------------------------------------------------------------
void CBaseShaderValidator::Spew(    SPEW_TYPE SpewType, 
                                    CBaseInstruction* pInst /* can be NULL */, 
                                    const char* pszFormat, ... )
{
    int Length = 128;
    char* pBuffer = NULL;
    va_list marker;

    if( !m_pLog )
        return;
    
    while( pBuffer == NULL )
    {
        int BytesStored = 0;
        int BytesLeft = Length;
        char *pIndex    = NULL;
        char* pErrorLocationText = NULL;

        pBuffer = new char[Length];
        if( !pBuffer )
        {
            OutputDebugString("Out of memory.\n");
            return;
        }
        pIndex = pBuffer;

        // Code location text
        switch( SpewType )
        {
        case SPEW_INSTRUCTION_ERROR:
        case SPEW_INSTRUCTION_WARNING:
            if( pInst )
                pErrorLocationText = pInst->MakeInstructionLocatorString();
            break;
        }

        if( pErrorLocationText )
        {
            BytesStored = _snprintf( pIndex, BytesLeft - 1, pErrorLocationText );
            if( BytesStored < 0 ) goto OverFlow;
            BytesLeft -= BytesStored;
            pIndex += BytesStored;
        }

        // Spew text prefix
        switch( SpewType )
        {
        case SPEW_INSTRUCTION_ERROR:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Error) " );
            break;
        case SPEW_GLOBAL_ERROR:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Global Validation Error) " );
            break;
        case SPEW_INSTRUCTION_WARNING:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Warning) " );
            break;
        case SPEW_GLOBAL_WARNING:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Global Validation Warning) " );
            break;
        }
        if( BytesStored < 0 ) goto OverFlow;
        BytesLeft -= BytesStored; 
        pIndex += BytesStored;

        // Formatted text
        va_start( marker, pszFormat );
        BytesStored = _vsnprintf( pIndex, BytesLeft - 1, pszFormat, marker );
        va_end( marker );

        if( BytesStored < 0 ) goto OverFlow;
        BytesLeft -= BytesStored;
        pIndex += BytesStored;

        m_pLog->AppendText(pBuffer);

        delete [] pErrorLocationText;
        delete [] pBuffer;
        break;
OverFlow:
        delete [] pErrorLocationText;
        delete [] pBuffer;
        pBuffer = NULL;
        Length = Length * 2;
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::MakeAffectedComponentsText
//
// Note that the string returned is STATIC.
//-----------------------------------------------------------------------------
char* CBaseShaderValidator::MakeAffectedComponentsText( DWORD ComponentMask, 
                                                        BOOL bColorLabels, 
                                                        BOOL bPositionLabels)
{
    char* ColorLabels[4] = {"r/", "g/", "b/", "a/"};
    char* PositionLabels[4] = {"x/", "y/", "z/", "w/"};
    char* NumericLabels[4] = {"0 ", "1 ", "2 ", "3"}; // always used
    static char s_AffectedComponents[28]; // enough to hold "*r/x/0 *g/y/1 *b/z/2 *a/w/3"
    UINT  LabelCount = 0;

    s_AffectedComponents[0] = '\0';

    for( UINT i = 0; i < 4; i++ )
    {
        if( COMPONENT_MASKS[i] & ComponentMask )
        {
            strcat( s_AffectedComponents, "*" );
        }
        if( bColorLabels )
            strcat( s_AffectedComponents, ColorLabels[i] );
        if( bPositionLabels )
            strcat( s_AffectedComponents, PositionLabels[i] );

        strcat( s_AffectedComponents, NumericLabels[i] ); // always used
    }
    return s_AffectedComponents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\valbase.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// valbase.hpp
//
// Direct3D Reference Device - Vertex/PixelShader validation common infrastructure
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __VALBASE_HPP__
#define __VALBASE_HPP__

#define NUM_COMPONENTS_IN_REGISTER  4
#define SHADER_INSTRUCTION_MAX_PARAMS       4
#define SHADER_INSTRUCTION_MAX_SRCPARAMS    (SHADER_INSTRUCTION_MAX_PARAMS - 1)

typedef enum _SPEW_TYPE
{
    SPEW_INSTRUCTION_ERROR,
    SPEW_INSTRUCTION_WARNING,
    SPEW_GLOBAL_ERROR,
    SPEW_GLOBAL_WARNING
} SPEW_TYPE;

typedef enum _SHADER_VALIDATOR_FLAGS
{
    SHADER_VALIDATOR_LOG_ERRORS             = 0x1,
    SHADER_VALIDATOR_OPTIMIZE_WRITEMASKS    = 0x2
} SHADER_VALIDATOR_FLAGS;

typedef enum _DSTSHIFT
{
    DSTSHIFT_NONE   = 0x0,
    DSTSHIFT_X2     = 0x1,
    DSTSHIFT_X4     = 0x2,
    DSTSHIFT_X8     = 0x3,
    DSTSHIFT_D2     = 0xF,
    DSTSHIFT_D4     = 0xE,
    DSTSHIFT_D8     = 0xD
} DSTSHIFT;

const DWORD COMPONENT_MASKS[4] = {D3DSP_WRITEMASK_0, D3DSP_WRITEMASK_1, D3DSP_WRITEMASK_2, D3DSP_WRITEMASK_3};

//-----------------------------------------------------------------------------
// DSTPARAM - part of CBaseInstruction
//-----------------------------------------------------------------------------
class DSTPARAM
{
public:
    DSTPARAM();

    BOOL                            m_bParamUsed;   // Does instruction have dest param?
    UINT                            m_RegNum;
    DWORD                           m_WriteMask;    // writemasks (D3DSP_WRITEMASK_*)  
    D3DSHADER_PARAM_DSTMOD_TYPE     m_DstMod;       // D3DSPDM_NONE, D3DSPDM_SATURATE (PShader)
    DSTSHIFT                        m_DstShift;     // _x2, _x4, etc. (PShader)
    D3DSHADER_PARAM_REGISTER_TYPE   m_RegType;      // _TEMP, _ADDRESS, etc.

    DWORD                           m_ComponentReadMask; // Which components instruction needs to read
                                                         // This seems strage, but in ps.2.0 there are some ops
                                                         // that have one parameter (dest), but they read from it, and write back to it.
};

//-----------------------------------------------------------------------------
// SRCPARAM - part of CBaseInstruction
//-----------------------------------------------------------------------------
class SRCPARAM
{
public:
    SRCPARAM();

    BOOL                            m_bParamUsed;   // Does instruction have this src param?
    UINT                            m_RegNum;
    DWORD                           m_SwizzleShift; // D3DVS_*_*, or D3DSP_NOSWIZZLE/
                                                    // D3DSP_REPLICATERED/GREEN/BLUE/ALPHA
    D3DVS_ADDRESSMODE_TYPE          m_AddressMode;  // D3DVS_ADDRMODE_ABSOLUTE / _RELATIVE (VShader)
    DWORD                           m_RelativeAddrComponent; // One of D3DSP_WRITEMASK_0, 1, 2, or 3. (VShader)
    D3DSHADER_PARAM_SRCMOD_TYPE     m_SrcMod;       // _NEG, _BIAS, etc.
    D3DSHADER_PARAM_REGISTER_TYPE   m_RegType;      // _TEMP, _CONST, etc.

    DWORD                           m_ComponentReadMask; // Which components instruction needs to read
};

//-----------------------------------------------------------------------------
// CBaseInstruction
//-----------------------------------------------------------------------------
class CBaseInstruction
{
public:
    CBaseInstruction(CBaseInstruction* pPrevInst);  // Append to linked list
    void SetSpewFileNameAndLineNumber(const char* pFileName, const DWORD* pLineNumber);
    char* MakeInstructionLocatorString();
    virtual void CalculateComponentReadMasks(DWORD dwVersion) = 0; // which components to each source read?

    // Instruction Description
    D3DSHADER_INSTRUCTION_OPCODE_TYPE   m_Type;
    UINT                                m_DstParamCount;
    UINT                                m_SrcParamCount;
    CBaseInstruction*                   m_pPrevInst;
    CBaseInstruction*                   m_pNextInst;
    const DWORD*                        m_pSpewLineNumber; // points to line number embedded in shader by assembler (if present)
    const char*                         m_pSpewFileName;   // points to file name embedded in shader (if present)
    UINT                                m_SpewInstructionCount; // only used for spew, not for any limit checking

    // Destination Parameter Description
    DSTPARAM    m_DstParam;
    
    // Source Parameters
    SRCPARAM    m_SrcParam[SHADER_INSTRUCTION_MAX_SRCPARAMS];
};

//-----------------------------------------------------------------------------
// CAccessHistoryNode
//-----------------------------------------------------------------------------
class CAccessHistoryNode
{
public:
    CAccessHistoryNode(CAccessHistoryNode* pPreviousAccess, 
                       CAccessHistoryNode* pPreviousWriter,
                       CAccessHistoryNode* pPreviousReader,
                       CBaseInstruction* pInst,
                       BOOL bWrite );

    CAccessHistoryNode* m_pPreviousAccess;
    CAccessHistoryNode* m_pNextAccess;
    CAccessHistoryNode* m_pPreviousWriter;
    CAccessHistoryNode* m_pPreviousReader;
    CBaseInstruction*   m_pInst;
    BOOL m_bWrite;
    BOOL m_bRead;
};

//-----------------------------------------------------------------------------
// CAccessHistory
//-----------------------------------------------------------------------------
class CAccessHistory
{
public:
    CAccessHistory();
    ~CAccessHistory();
    CAccessHistoryNode* m_pFirstAccess;
    CAccessHistoryNode* m_pMostRecentAccess;
    CAccessHistoryNode* m_pMostRecentWriter;
    CAccessHistoryNode* m_pMostRecentReader;
    BOOL                m_bPreShaderInitialized;

    BOOL NewAccess(CBaseInstruction* pInst, BOOL bWrite );
    BOOL InsertReadBeforeWrite(CAccessHistoryNode* pWriteNode, CBaseInstruction* pInst);
};

//-----------------------------------------------------------------------------
// CRegisterFile
//-----------------------------------------------------------------------------
class CRegisterFile
{
    UINT    m_NumRegisters;
    BOOL    m_bWritable;
    UINT    m_NumReadPorts;
    BOOL    m_bInitOk;
public:
    CRegisterFile(UINT NumRegisters, BOOL bWritable, UINT NumReadPorts, BOOL bPreShaderInitialized );
    ~CRegisterFile();

    inline UINT GetNumRegs() {return m_NumRegisters;};    
    inline BOOL IsWritable() {return m_bWritable;};    
    inline UINT GetNumReadPorts() {return m_NumReadPorts;};    
    inline BOOL InitOk() {return m_bInitOk;};    
    CAccessHistory*     m_pAccessHistory[NUM_COMPONENTS_IN_REGISTER];
};

//-----------------------------------------------------------------------------
// CBaseShaderValidator
//-----------------------------------------------------------------------------
class CBaseShaderValidator
{
protected:
    BOOL                        m_bBaseInitOk;
    DWORD                       m_Version;
    UINT                        m_SpewInstructionCount; // only used for spew, not for any limit checking
    CBaseInstruction*           m_pInstructionList;
    const DWORD*                m_pCurrToken;
    HRESULT                     m_ReturnCode;
    BOOL                        m_bSeenAllInstructions;
    DWORD                       m_ErrorCount;
    CErrorLog*                  m_pLog;
    CBaseInstruction*           m_pCurrInst;
    const D3DCAPS8*             m_pCaps;  // can be NULL if not provided.
    const DWORD*                m_pLatestSpewLineNumber; // points to latest line number sent in comment from D3DX Assembler
    const char*                 m_pLatestSpewFileName;   // points to latest file name sent in comment from D3DX Assembler

    // m_bSrcParamError needed by Rule_SrcInitialized (in both vshader and pshader)
    BOOL                        m_bSrcParamError[SHADER_INSTRUCTION_MAX_SRCPARAMS]; 

    virtual BOOL                DecodeNextInstruction() = 0;
    void                        DecodeDstParam( DSTPARAM* pDstParam, DWORD Token );
    void                        DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token );
    virtual BOOL                InitValidation() = 0;
    void                        ValidateShader();
    virtual BOOL                ApplyPerInstructionRules() = 0;
    virtual void                ApplyPostInstructionsRules() = 0;
    virtual CBaseInstruction*   AllocateNewInstruction(CBaseInstruction* pPrevInst) = 0;
    void                        ParseCommentForAssemblerMessages(const DWORD* pComment);
    void                        Spew(   SPEW_TYPE SpewType, 
                                        CBaseInstruction* pInst /* can be NULL */, 
                                        const char* pszFormat, ... );
    char*                       MakeAffectedComponentsText( DWORD ComponentMask, 
                                                            BOOL bColorLabels = TRUE, 
                                                            BOOL bPositionLabels = TRUE);

public:
    CBaseShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
    ~CBaseShaderValidator();

    DWORD GetRequiredLogBufferSize()
    {
        if( m_pLog ) 
            return m_pLog->GetRequiredLogBufferSize();
        else
            return 0;
    }

    void WriteLogToBuffer( char* pBuffer )
    {
        if( m_pLog ) m_pLog->WriteLogToBuffer( pBuffer );
    }

    HRESULT GetStatus() { return m_ReturnCode; }; 
};

#endif //__VALBASE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\vshdrval.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// vshdrval.cpp
//
// Direct3D Reference Device - VertexShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CVSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_VS_INST   ((CVSInstruction*)m_pCurrInst)
#define _PREV_VS_INST   (m_pCurrInst?((CVSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// VertexShader Validation Rule Coverage
//
// Below is the list of rules in "DX8 VertexShader Version Specification",
// matched to the function(s) in this file which enforce them.
// Note that the mapping from rules to funtions can be 1->n or n->1
//
// Generic Rules
// -------------
//
// VS-G1:           Rule_oPosWritten
// VS-G2:           Rule_ValidAddressRegWrite
//
// Vertex Shader Version 1.0 Rules
// ------------------------------
//
// VS.1.0-1:        Rule_ValidAddressRegWrite
//
// Vertex Shader Version 1.1 Rules
// ------------------------------
//
// VS.1.1-1:        Rule_ValidInstructionCount
// VS.1.1-2:        Rule_ValidAddressRegWrite, Rule_ValidSrcParams
// VS.1.1-3:        Rule_ValidFRCInstruction
// VS.1.1-4:        ?
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CVSInstruction::CalculateComponentReadMasks(DWORD dwVersion)
//-----------------------------------------------------------------------------
void CVSInstruction::CalculateComponentReadMasks(DWORD dwVersion)
{
    for( UINT i = 0; i < m_SrcParamCount; i++ )
    {
        DWORD PostSwizzleComponentReadMask = 0;
        switch( m_Type )
        {
            case D3DSIO_ADD:
            case D3DSIO_FRC:
            case D3DSIO_MAD:
            case D3DSIO_MAX:
            case D3DSIO_MIN:
            case D3DSIO_MOV:
            case D3DSIO_MUL:
            case D3DSIO_SLT:
            case D3DSIO_SGE:
                PostSwizzleComponentReadMask = m_DstParam.m_WriteMask; // per-component ops.
                break;
            case D3DSIO_DP3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_DP4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_LIT:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_DST:
                if( 0 == i )        PostSwizzleComponentReadMask = D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                else if( 1 == i )   PostSwizzleComponentReadMask = D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_EXP:
            case D3DSIO_LOG:
            case D3DSIO_EXPP:
            case D3DSIO_LOGP:
            case D3DSIO_RCP:
            case D3DSIO_RSQ:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_M3x2:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M3x3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M3x4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M4x3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_M4x4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_NOP:
            default:
                break;
        }

        // Now that we know which components of the source will be used by the instruction,
        // we need to figure out which components of the actual source register need to be read to provide the data,
        // taking into account source component swizzling.
        m_SrcParam[i].m_ComponentReadMask = 0;
        for( UINT j = 0; j < 4; j++ )
        {
            if( PostSwizzleComponentReadMask & COMPONENT_MASKS[j] )
                m_SrcParam[i].m_ComponentReadMask |= COMPONENT_MASKS[(m_SrcParam[i].m_SwizzleShift >> (D3DVS_SWIZZLE_SHIFT + j*2)) & 3];
        }
    }
}

//-----------------------------------------------------------------------------
// CVShaderValidator::CVShaderValidator
//-----------------------------------------------------------------------------
CVShaderValidator::CVShaderValidator( const DWORD* pCode, 
                                      const DWORD* pDecl,
                                      const D3DCAPS8* pCaps,
                                      DWORD Flags ) 
                                      : CBaseShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.  
    // Only set m_ReturnCode to S_OK if validation has succeeded, 
    // before exiting this constructor.

    m_pDecl                     = pDecl;
    m_bFixedFunction            = pDecl && !pCode;
    if( pCaps )
    {
        m_dwMaxVertexShaderConst = pCaps->MaxVertexShaderConst;
        m_bIgnoreConstantInitializationChecks = FALSE;
    }
    else
    {
        m_dwMaxVertexShaderConst = 0;
        m_bIgnoreConstantInitializationChecks = TRUE;
    }

    m_pTempRegFile              = NULL;
    m_pInputRegFile             = NULL;
    m_pConstRegFile             = NULL;
    m_pAddrRegFile              = NULL;
    m_pTexCrdOutputRegFile      = NULL;
    m_pAttrOutputRegFile        = NULL;
    m_pRastOutputRegFile        = NULL;

    if( NULL == pCode && NULL == pDecl )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Code and declaration pointers passed into shader vertex shader validator cannot both be NULL.");
        return;
    }

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CVShaderValidator::~CVShaderValidator
//-----------------------------------------------------------------------------
CVShaderValidator::~CVShaderValidator()
{
    delete m_pTempRegFile;
    delete m_pInputRegFile;
    delete m_pConstRegFile;
    delete m_pAddrRegFile;
    delete m_pTexCrdOutputRegFile;
    delete m_pAttrOutputRegFile;
    delete m_pRastOutputRegFile;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::AllocateNewInstruction
//-----------------------------------------------------------------------------
CBaseInstruction* CVShaderValidator::AllocateNewInstruction(CBaseInstruction*pPrevInst)
{
    return new CVSInstruction((CVSInstruction*)pPrevInst);
}

//-----------------------------------------------------------------------------
// CVShaderValidator::DecodeNextInstruction
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::DecodeNextInstruction()
{
    m_pCurrInst->m_Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*m_pCurrToken & D3DSI_OPCODE_MASK);

    if( m_pCurrInst->m_Type == D3DSIO_COMMENT )
    {
        ParseCommentForAssemblerMessages(m_pCurrToken); // does not advance m_pCurrToken

        // Skip comments
        DWORD NumDWORDs = ((*m_pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
        m_pCurrToken += (NumDWORDs+1);
        return TRUE;
    }

    // If the assembler has sent us file and/or line number messages,
    // received by ParseCommentForAssemblerMesssages(), 
    // then bind this information to the current instruction.
    // This info can be used in error spew to direct the shader developer
    // to exactly where a problem is located.
    m_pCurrInst->SetSpewFileNameAndLineNumber(m_pLatestSpewFileName,m_pLatestSpewLineNumber);

    m_SpewInstructionCount++; // only used for spew, not for any limits
    m_pCurrInst->m_SpewInstructionCount = m_SpewInstructionCount;

    DWORD dwReservedBits = VS_INST_TOKEN_RESERVED_MASK;

    if( (*m_pCurrToken) & dwReservedBits )
    {
        Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in instruction parameter token!  Aborting validation.");
        return FALSE;
    }

    m_pCurrToken++;

    // Decode dst param
    if (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_DstParamCount)++;
        DecodeDstParam( &m_pCurrInst->m_DstParam, *m_pCurrToken );
        if( (*m_pCurrToken) & VS_DSTPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in destination parameter token!  Aborting validation.");
            return FALSE;
        }
        m_pCurrToken++;
    }

    // Decode src param(s)
    while (*m_pCurrToken & (1L<<31))
    {   
        (m_pCurrInst->m_SrcParamCount)++;
        if( (m_pCurrInst->m_DstParamCount + m_pCurrInst->m_SrcParamCount) > SHADER_INSTRUCTION_MAX_PARAMS )
        {
            m_pCurrInst->m_SrcParamCount--;
            m_pCurrToken++; // eat up extra parameters and skip to next
            continue;
        }
        
        // Below: index is [SrcParamCount - 1] because m_SrcParam array needs 0 based index.
        DecodeSrcParam( &(m_pCurrInst->m_SrcParam[m_pCurrInst->m_SrcParamCount - 1]),*m_pCurrToken );

        if( (*m_pCurrToken) & VS_SRCPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in source %d parameter token!  Aborting validation.",
                            m_pCurrInst->m_SrcParamCount);
            return FALSE;
        }
        m_pCurrToken++;
    }

    // Figure out which components of each source operand actually need to be read,
    // taking into account destination write mask, the type of instruction, source swizzle, etc.
    m_pCurrInst->CalculateComponentReadMasks(m_Version);

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::InitValidation
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::InitValidation()
{
    if( m_bFixedFunction ) 
    {
        m_pTempRegFile              = new CRegisterFile(0,FALSE,0,TRUE);// #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile             = new CRegisterFile(17,FALSE,0,TRUE);
        m_pConstRegFile             = new CRegisterFile(0,FALSE,0,TRUE);
        m_pAddrRegFile              = new CRegisterFile(0,FALSE,0,TRUE);
        m_pTexCrdOutputRegFile      = new CRegisterFile(0,FALSE,0,TRUE);
        m_pAttrOutputRegFile        = new CRegisterFile(0,FALSE,0,TRUE);
        m_pRastOutputRegFile        = new CRegisterFile(0,FALSE,0,TRUE);
    }
    else
    {    
        if( m_pCaps )
        {
            if( (m_pCaps->VertexShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF) )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Vertex shader version %d.%d is too high for device. Maximum supported version is %d.%d. Aborting shader validation.",
                        D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version), 
                        D3DSHADER_VERSION_MAJOR(m_pCaps->VertexShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->VertexShaderVersion));
                return FALSE;
            }
        }

        switch( m_Version >> 16 )
        {
        case 0xffff:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****.",
                    m_Version);
            return FALSE;
        case 0xfffe:
            break; // vertexshader - ok.
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation.",
                    m_Version);
            return FALSE;
        }

        switch(m_Version)
        {
        case D3DVS_VERSION(1,0):    // DX8
            m_pTempRegFile              = new CRegisterFile(12,TRUE,3,FALSE);// #regs, bWritable, max# reads/instruction, pre-shader initialized
            m_pInputRegFile             = new CRegisterFile(16,FALSE,1,TRUE);
            if( m_bIgnoreConstantInitializationChecks )
                m_pConstRegFile             = new CRegisterFile(0,FALSE,1,TRUE); // still creating register file so we can validate number of read ports
            else
                m_pConstRegFile             = new CRegisterFile(m_dwMaxVertexShaderConst,FALSE,1,TRUE);
            m_pAddrRegFile              = new CRegisterFile(0,TRUE,0,FALSE);
            m_pTexCrdOutputRegFile      = new CRegisterFile(8,TRUE,0,FALSE);
            m_pAttrOutputRegFile        = new CRegisterFile(2,TRUE,0,FALSE);
            m_pRastOutputRegFile        = new CRegisterFile(3,TRUE,0,FALSE);
            break;
        case D3DVS_VERSION(1,1):    // DX8
            m_pTempRegFile              = new CRegisterFile(12,TRUE,3,FALSE);// #regs, bWritable, max# reads/instruction, pre-shader initialized
            m_pInputRegFile             = new CRegisterFile(16,FALSE,1,TRUE);
            if( m_bIgnoreConstantInitializationChecks )
                m_pConstRegFile             = new CRegisterFile(0,FALSE,1,TRUE); // still creating register file so we can validate number of read ports
            else
                m_pConstRegFile             = new CRegisterFile(m_dwMaxVertexShaderConst,FALSE,1,TRUE);
            m_pAddrRegFile              = new CRegisterFile(1,TRUE,0,FALSE);
            m_pTexCrdOutputRegFile      = new CRegisterFile(8,TRUE,0,FALSE);
            m_pAttrOutputRegFile        = new CRegisterFile(2,TRUE,0,FALSE);
            m_pRastOutputRegFile        = new CRegisterFile(3,TRUE,0,FALSE);
            break;
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported vertex shader version. Aborting vertex shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
            return FALSE;
        }

    }

    if( NULL == m_pTempRegFile ||
        NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pAddrRegFile ||
        NULL == m_pTexCrdOutputRegFile ||
        NULL == m_pAttrOutputRegFile ||
        NULL == m_pRastOutputRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    ValidateDeclaration(); // no matter what happens here, we can continue checking shader code, if present.

    if( m_bFixedFunction ) // no shader code - fixed function, so we only validate declaration
    {
        if( 0 == m_ErrorCount )
            m_ReturnCode = S_OK;

        return FALSE; // returning false just makes validation stop here (not for indicating success/failure of validation)
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ValidateDeclaration
//-----------------------------------------------------------------------------
void CVShaderValidator::ValidateDeclaration()
{
    if( !m_pDecl ) // no shader declaration passed in.
        return;

    DXGASSERT(m_pInputRegFile);

    typedef struct _NORMAL_GEN {
        UINT DestReg;
        UINT SourceReg;
        UINT TokenNum;
    } NORMAL_GEN;

    const DWORD*    pCurrToken                 = m_pDecl;
    DWORD           MaxStreams                 = 0;
    UINT            TokenNum                   = 1;
    UINT            NumInputRegs               = m_pInputRegFile->GetNumRegs();
    BOOL            bInStream                  = FALSE;
    BOOL*           pVertexStreamDeclared      = NULL;
    BOOL            bInTessStream              = FALSE;
    BOOL            bTessStreamDeclared        = FALSE;
    BOOL            bAtLeastOneDataDefinition  = FALSE;
    NORMAL_GEN*     pNormalGenOperations       = new NORMAL_GEN[m_pInputRegFile->GetNumRegs()];
    UINT            NumNormalGenOperations     = 0;
    BOOL            bErrorInForLoop            = FALSE;

    if( NULL == pNormalGenOperations )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.  Aborting shader decl. validation.");
        m_ErrorCount++;
        goto Exit;
    }
                                
    DXGASSERT(m_pConstRegFile && m_pInputRegFile); // if we have a declaration, we better have these two register files 
    DXGASSERT(!m_bIgnoreConstantInitializationChecks); // we better have d3d8 caps if we have a decl to verify!

    if( m_pCaps ) // only validate stream numbers when caps present
    {
        MaxStreams = m_pCaps->MaxStreams;
        if( MaxStreams > 0 )
        {
            pVertexStreamDeclared  = new BOOL[MaxStreams];
            if( NULL == pVertexStreamDeclared )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.  Aborting shader decl. validation.");
                m_ErrorCount++;
                goto Exit;
            }

            for( UINT i = 0; i < MaxStreams; i++ )
                pVertexStreamDeclared[i] = FALSE;
        }
    }

    // The constructor for the input register file assumed that the input regs were initialized,
    // but now that we are parsing a shader declaration, 
    // we can check initialization of input registers.
    for( UINT i = 0; i < 4; i++ )
    {
        for( UINT j = 0; j < m_pInputRegFile->GetNumRegs(); j++ )
            m_pInputRegFile->m_pAccessHistory[i][j].m_bPreShaderInitialized = FALSE;
    }
    
    // Now parse the declaration.
    while( D3DVSD_END() != *pCurrToken )
    {
        DWORD Token             = *pCurrToken;
        switch( (Token & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT )
        {
        case D3DVSD_TOKEN_NOP:
            break;
        case D3DVSD_TOKEN_STREAM:
        {
            UINT StreamNum = (Token & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT;
            bInTessStream = (Token & D3DVSD_STREAMTESSMASK) >> D3DVSD_STREAMTESSSHIFT;
            bInStream = !bInTessStream;
            bAtLeastOneDataDefinition = FALSE;

            if( bInStream )
            {
                if( m_pCaps && (StreamNum >= MaxStreams) )
                {
                    if( MaxStreams )
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d is out of range. Max allowed is %d.  Aborting shader decl. validation.",
                                    TokenNum, StreamNum, m_pCaps->MaxStreams - 1);
                    else
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d is out of range. There are no streams available.  Aborting shader decl. validation.",
                                    TokenNum, StreamNum, m_pCaps->MaxStreams - 1);

                    m_ErrorCount++;
                    goto Exit;
                }
            }
            else if( StreamNum > 0 )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number must not be specified for tesselator stream.",
                            TokenNum);
                m_ErrorCount++;
            }

            if( bInStream && pVertexStreamDeclared )
            {
                if( TRUE == pVertexStreamDeclared[StreamNum] )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d has already been declared.  Aborting shader decl. validation.",
                                TokenNum, StreamNum );
                    m_ErrorCount++;
                    goto Exit;
                }
                pVertexStreamDeclared[StreamNum] = TRUE;                
            }

            if( bInTessStream )
            {
                if( bTessStreamDeclared )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Tesselation stream has already been declared.  Aborting shader decl. validation.",
                                TokenNum);
                    m_ErrorCount++;
                    goto Exit;
                }
                bTessStreamDeclared = TRUE;
            }

            break;
        }
        case D3DVSD_TOKEN_STREAMDATA:
            if( !bInStream )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Cannot set stream input without first setting stream #.  Aborting shader decl. validation.",
                            TokenNum);
                m_ErrorCount++;
                goto Exit;
            }
            if( (Token & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT ) // SKIP
            {
                if( m_bFixedFunction )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: SKIP not permitted in fixed-function declarations.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }
            }
            else
            {
                UINT RegNum = (Token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT; 
                if( RegNum >= m_pInputRegFile->GetNumRegs() )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid reg num: %d. Max allowed is %d.",
                           TokenNum, RegNum, m_pInputRegFile->GetNumRegs() - 1);
                    m_ErrorCount++;
                    break;
                }
                
                switch( (Token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT )
                {
                case D3DVSDT_FLOAT1:
                case D3DVSDT_FLOAT2:
                case D3DVSDT_FLOAT3:
                case D3DVSDT_FLOAT4:
                case D3DVSDT_D3DCOLOR:
                case D3DVSDT_UBYTE4:
                case D3DVSDT_SHORT2:
                case D3DVSDT_SHORT4:
                    break;
                default:
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Unrecognized stream data type.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }

                bErrorInForLoop = FALSE;
                for( UINT i = 0; i < 4; i++ )
                {
                    if( TRUE == m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register %d already declared.",
                                    TokenNum, RegNum);
                        m_ErrorCount++;
                        bErrorInForLoop = TRUE;
                        break;
                    }
                    m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized = TRUE;
                }
                if( bErrorInForLoop )
                    break;

                bAtLeastOneDataDefinition = TRUE;
            }
            break;
        case D3DVSD_TOKEN_TESSELLATOR:
        {
            if( !bInTessStream )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Cannot set tesselator stream input without first setting tesselator stream #.  Aborting shader decl. validation.",
                            TokenNum);
                m_ErrorCount++;
                goto Exit;
            }

            DWORD InRegNum = (Token & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT;
            DWORD RegNum = (Token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
            BOOL  bNormalGen = !(Token & 0x10000000); // TODO: Why isnt there a const for this in the d3d api headers?

            if( RegNum >= m_pInputRegFile->GetNumRegs() )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid reg num: %d. Max allowed is %d.",
                       TokenNum, RegNum, m_pInputRegFile->GetNumRegs() - 1);
                m_ErrorCount++;
                break;
            }
            
            if( bNormalGen )
            {
                if( InRegNum >= m_pInputRegFile->GetNumRegs() )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid input reg num: %d. Max allowed is %d.",
                           TokenNum, InRegNum, m_pInputRegFile->GetNumRegs() - 1);
                    m_ErrorCount++;
                    break;
                }

                bErrorInForLoop = FALSE;
                for( UINT i = 0; i < NumNormalGenOperations; i++ )
                {
                    if( pNormalGenOperations[i].DestReg == RegNum )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Duplicate declaration of input register %d as destination for normal generation.",
                               TokenNum, RegNum );
                        m_ErrorCount++;
                        bErrorInForLoop = TRUE;
                        break;                
                    }
                }
                if( bErrorInForLoop )
                    break;

                // Defer checking of initialization of inputs for normal gen until the entire declaration has been seen.
                // Also, defer setting of normal gen destination reg. to initialized, 
                // in order to disallow normal generation loops.
                pNormalGenOperations[NumNormalGenOperations].DestReg = RegNum;
                pNormalGenOperations[NumNormalGenOperations].SourceReg = InRegNum;
                pNormalGenOperations[NumNormalGenOperations].TokenNum = TokenNum; // used later for spew
                NumNormalGenOperations++;
            }
            else
            {
                if( ((Token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT) != D3DVSDT_FLOAT2 )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Tess datatype must be FLOAT2 for UV generation.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }

                if( InRegNum > 0 )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register number must not be specified (does not apply) for UV tesselation.",
                           TokenNum);
                    m_ErrorCount++;
                    break;                
                }

                for( UINT i = 0; i < 4; i++ )
                {
                    if( TRUE == m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register %d already declared.",
                                    TokenNum, RegNum);
                        m_ErrorCount++;
                        break;
                    }
                    m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized = TRUE;
                }
            }
            bAtLeastOneDataDefinition = TRUE;
            break;
        }
        case D3DVSD_TOKEN_CONSTMEM:
        {
            DWORD ConstCount = (Token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT;
            DWORD MaxOffset = ((Token & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT) + ConstCount;
            DWORD NumConstRegs = m_pConstRegFile->GetNumRegs();
            DXGASSERT(NumConstRegs > 0);
            if( (bInStream || bInTessStream) && !bAtLeastOneDataDefinition )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream selector token must be followed by at least one stream data definition token.",
                            TokenNum);
                m_ErrorCount++;
            }
            if( 0 == NumConstRegs )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Write to const register %d is not valid.  There are no constant registers available.",
                            TokenNum,MaxOffset );
            }
            else if( MaxOffset > NumConstRegs )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Write to const register %d is out of range.  Max offset is %d.",
                            TokenNum,MaxOffset,m_pConstRegFile->GetNumRegs() - 1 );
                m_ErrorCount++;
            }
            pCurrToken += ConstCount*4;
            bInStream = bInTessStream = FALSE;
            break;
        }
        case D3DVSD_TOKEN_EXT:
            pCurrToken += ((Token & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT);
            if( (bInStream || bInTessStream) && !bAtLeastOneDataDefinition )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream selector token must be followed by at least one stream data definition token.",
                            TokenNum);
                m_ErrorCount++;
            }
            bInStream = bInTessStream = FALSE;
            break;
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Unrecognized stream declaration token.  Aborting shader decl. validation.",
                        TokenNum);
            m_ErrorCount++;
            goto Exit;
        }
        pCurrToken++;
    }

    // Make sure inputs to normal gen operations have been initialized
    for( UINT i = 0; i < NumNormalGenOperations; i++ )
    {
        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( FALSE == m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].SourceReg].m_bPreShaderInitialized )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token %d: Source input register %d for normal generation has not been declared.",
                       pNormalGenOperations[i].TokenNum, pNormalGenOperations[i].SourceReg);
                m_ErrorCount++;
                break;                
            }
        }
    }

    // Set outputs of normal gen operations to initialized
    for( UINT i = 0; i < NumNormalGenOperations; i++ )
    {
        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( TRUE == m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].DestReg].m_bPreShaderInitialized )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input reg %d specified as destination for normal generation is already declared elsewhere.",
                            pNormalGenOperations[i].TokenNum, pNormalGenOperations[i].DestReg);
                m_ErrorCount++;
                break;
            }
            m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].DestReg].m_bPreShaderInitialized = TRUE;
        }
    }

Exit:
    if( pVertexStreamDeclared )
        delete [] pVertexStreamDeclared;
    if( pNormalGenOperations )
        delete [] pNormalGenOperations;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before ValidDstParam()
    if( !   Rule_ValidAddressRegWrite()             ) goto EXIT;
    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidFRCInstruction()              ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CVShaderValidator::ApplyPostInstructionsRules()
{
    Rule_ValidInstructionCount(); // see if we went over the limits
    Rule_oPosWritten();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:  
// Per instruction.
//
// ** Returns:  
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_MAD:
    case D3DSIO_MUL:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_MIN:
    case D3DSIO_MAX:
    case D3DSIO_SLT:
    case D3DSIO_SGE:
    case D3DSIO_EXPP:
    case D3DSIO_LOGP:
    case D3DSIO_LIT:
    case D3DSIO_DST:
    case D3DSIO_M4x4:
    case D3DSIO_M4x3:
    case D3DSIO_M3x4:
    case D3DSIO_M3x3:
    case D3DSIO_M3x2:
    case D3DSIO_FRC:
    case D3DSIO_EXP:
    case D3DSIO_LOG:
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction recognized - ok.
    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting vertex shader validation." );
    m_ErrorCount++;
    return FALSE;  
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:  
// Per instruction.
//
// ** Returns:  
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_InstructionSupportedByVersion()
{
  
    if( D3DVS_VERSION(1,0) <= m_Version ) // 1.0 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_MOV:
        case D3DSIO_ADD:
        case D3DSIO_MAD:
        case D3DSIO_MUL:
        case D3DSIO_RCP:
        case D3DSIO_RSQ:
        case D3DSIO_DP3:
        case D3DSIO_DP4:
        case D3DSIO_MIN:
        case D3DSIO_MAX:
        case D3DSIO_SLT:
        case D3DSIO_SGE:
        case D3DSIO_EXPP:
        case D3DSIO_LOGP:
        case D3DSIO_LIT:
        case D3DSIO_DST:
        case D3DSIO_M4x4:
        case D3DSIO_M4x3:
        case D3DSIO_M3x4:
        case D3DSIO_M3x3:
        case D3DSIO_M3x2:
        case D3DSIO_FRC:
        case D3DSIO_EXP:
        case D3DSIO_LOG:
            return TRUE; // instruction supported - ok.
        }
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d vertex shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
// The count includes dest + source parameters.
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
//
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if ((m_pCurrInst->m_DstParamCount + m_pCurrInst->m_SrcParamCount) > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_EXP:
    case D3DSIO_EXPP:
    case D3DSIO_FRC:
    case D3DSIO_LOG:
    case D3DSIO_LOGP:
    case D3DSIO_LIT:
    case D3DSIO_MOV:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_DST:
    case D3DSIO_M3x2:
    case D3DSIO_M3x3:
    case D3DSIO_M3x4:
    case D3DSIO_M4x3:
    case D3DSIO_M4x4:
    case D3DSIO_MAX:
    case D3DSIO_MIN:
    case D3DSIO_MUL:
    case D3DSIO_SGE:
    case D3DSIO_SLT:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count." );
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidSrcParams
//
// ** Rule:
// For each source parameter,
//     Source register type must be D3DSPR_TEMP/_INPUT/_CONST.
//     Register # must be within range for register type,
//     including the special case where matrix macro ops read source reg# + offset.
//     Modifier must be D3DSPSM_NONE or _NEG.
//     If version is < 1.1, addressmode must be absolute.
//     If the register type is not _CONST, addressmode must be absolute.
//     If relative addressing is used for constants, a0.x must be referenced.
//     Swizzle cannot be used for vector*matrix instructions.
//     
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
// 
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidSrcParams()  // could break this down for more granularity
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        DXGASSERT(i < 3);
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT ValidRegNum = 0;
        BOOL bSkipOutOfRangeCheck = FALSE;
        char* SourceName[3] = {"first", "second", "third"};
        switch(pSrcParam->m_RegType)
        {
        case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
        case D3DSPR_INPUT:      ValidRegNum = m_pInputRegFile->GetNumRegs(); break;
        case D3DSPR_CONST:      
            if(m_bIgnoreConstantInitializationChecks)
                bSkipOutOfRangeCheck = TRUE;
            else
                ValidRegNum = m_pConstRegFile->GetNumRegs(); 
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for %s source param.", SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }

        if( (!bFoundSrcError) && (!bSkipOutOfRangeCheck)) 
        {
            UINT NumConsecutiveRegistersUsed = 1;
            if( 1 == i )
            {
                switch( m_pCurrInst->m_Type )
                {
                    case D3DSIO_M3x2:
                        NumConsecutiveRegistersUsed = 2;
                        break;
                    case D3DSIO_M3x3:
                        NumConsecutiveRegistersUsed = 3;
                        break;
                    case D3DSIO_M3x4:
                        NumConsecutiveRegistersUsed = 4;
                        break;
                    case D3DSIO_M4x3:
                        NumConsecutiveRegistersUsed = 3;
                        break;
                    case D3DSIO_M4x4:
                        NumConsecutiveRegistersUsed = 4;
                        break;
                }
            }

            if((pSrcParam->m_RegNum >= ValidRegNum) && (D3DVS_ADDRMODE_ABSOLUTE == pSrcParam->m_AddressMode))
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: %d for %s source param. Max allowed for this type is %d.",
                                    pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
            else if( NumConsecutiveRegistersUsed > 1 )
            {
                if( pSrcParam->m_RegNum + NumConsecutiveRegistersUsed - 1 >= ValidRegNum )
                {
                    if( !((D3DSPR_CONST == pSrcParam->m_RegType) && (D3DVS_ADDRMODE_RELATIVE == pSrcParam->m_AddressMode)) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d.",
                                            pSrcParam->m_RegNum, SourceName[i], pSrcParam->m_RegNum + NumConsecutiveRegistersUsed - 1, ValidRegNum - 1);
                    }
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
            }
        }
        

        switch( pSrcParam->m_SrcMod )
        {
        case D3DSPSM_NEG:
            if( 1 == i )
            {
                switch( m_pCurrInst->m_Type )
                {
                case D3DSIO_M3x2:
                case D3DSIO_M3x3:
                case D3DSIO_M3x4:
                case D3DSIO_M4x3:
                case D3DSIO_M4x4:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot negate second source parameter to vector*matrix instructions.");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;        
                    break;
                }
            }
            break;
        case D3DSPSM_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for %s source param.",
                                SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }
    
        if( pSrcParam->m_AddressMode != D3DVS_ADDRMODE_ABSOLUTE 
            &&
            ( m_Version < D3DVS_VERSION(1,1) || pSrcParam->m_RegType != D3DSPR_CONST )
          )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Address mode must be absolute (%s source param).",
                                SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }
        
        if( (pSrcParam->m_AddressMode == D3DVS_ADDRMODE_RELATIVE) &&
            (D3DSPR_CONST == pSrcParam->m_RegType) )
        {
            if( pSrcParam->m_RelativeAddrComponent != D3DSP_WRITEMASK_0 )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Relative addressing of constant register must reference a0.x only.",
                                    SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }

        if( pSrcParam->m_SwizzleShift != D3DSP_NOSWIZZLE )
        {
            if( 1 == i )
            {
                switch( m_pCurrInst->m_Type )
                {
                case D3DSIO_M3x2:
                case D3DSIO_M3x3:
                case D3DSIO_M3x4:
                case D3DSIO_M4x3:
                case D3DSIO_M4x4:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot swizzle second source parameter to vector*matrix instructions.");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;        
                    break;
                }
            }
        }

        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//     The register type must be _TEMP, _INPUT or _CONST.
//     Certain components of the register need to have been initialized, depending
//     on what the instruction is and also taking into account the source swizzle.
//     For reads of the _CONST register file, do no validation.
//
// ** When to call:  
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;
        UINT NumConsecutiveRegistersUsed = 1; // more than one for matrix mul macros.
        DWORD RelativeAddrComponent = 0;

        if( m_bSrcParamError[i] ) continue;

        switch( pSrcParam->m_RegType )
        {
            case D3DSPR_TEMP:       
                pRegFile = m_pTempRegFile; 
                RegChar = "r";
                break;
            case D3DSPR_INPUT:       
                pRegFile = m_pInputRegFile; 
                RegChar = "v";
                break;
            case D3DSPR_CONST:    
                if( D3DVS_ADDRMODE_RELATIVE == pSrcParam->m_AddressMode )
                {
                    // make sure a0 was initialized.
                    pRegFile = m_pAddrRegFile;
                    RegChar = "a";
                    RegNum = 0;
                    RelativeAddrComponent = pSrcParam->m_RelativeAddrComponent;
                    break;
                }
                continue; // no validation for const register reads (no need to update access history either).
        }
        if( !pRegFile ) continue;

        if( 1 == i )
        {
            switch( m_pCurrInst->m_Type )
            {
                case D3DSIO_M3x2:
                    NumConsecutiveRegistersUsed = 2;
                    break;
                case D3DSIO_M3x3:
                    NumConsecutiveRegistersUsed = 3;
                    break;
                case D3DSIO_M3x4:
                    NumConsecutiveRegistersUsed = 4;
                    break;
                case D3DSIO_M4x3:
                    NumConsecutiveRegistersUsed = 3;
                    break;
                case D3DSIO_M4x4:
                    NumConsecutiveRegistersUsed = 4;
                    break;
            }
        }
        // check for read of uninitialized components
        for( UINT j = 0; j < (RelativeAddrComponent?1:NumConsecutiveRegistersUsed); j++ ) // will loop for macro matrix instructions
        {
            DWORD  UninitializedComponentsMask = 0;
            UINT   NumUninitializedComponents = 0;

            for( UINT k = 0; k < 4; k++ )
            {
                if( (RelativeAddrComponent ? RelativeAddrComponent : pSrcParam->m_ComponentReadMask) & COMPONENT_MASKS[k] )
                {
                    if( NULL == pRegFile->m_pAccessHistory[k][RegNum + j].m_pMostRecentWriter &&
                        !pRegFile->m_pAccessHistory[k][RegNum + j].m_bPreShaderInitialized )
                    {
                        NumUninitializedComponents++;
                        UninitializedComponentsMask |= COMPONENT_MASKS[k];
                    }
                }

            }

            if( NumUninitializedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                    NumUninitializedComponents > 1 ? "s" : "",
                    RegChar, RegNum + j, MakeAffectedComponentsText(UninitializedComponentsMask,FALSE,TRUE));
                m_ErrorCount++;
            }

            // Update register file to indicate READ.
            // Multiple reads of the same register component by the current instruction
            // will only be logged as one read in the access history.

            for( UINT k = 0; k < 4; k++ )
            {
                #define PREV_READER(_CHAN,_REG) \
                        ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                        pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)
                if((RelativeAddrComponent ? RelativeAddrComponent : pSrcParam->m_ComponentReadMask) & COMPONENT_MASKS[k])
                {
                    if( PREV_READER(k,RegNum) != m_pCurrInst )
                    {
                        if( !pRegFile->m_pAccessHistory[k][RegNum].NewAccess(m_pCurrInst,FALSE) )
                        {
                            Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                            m_ErrorCount++;
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}
//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidAddressRegWrite
//
// ** Rule:
// Address register may only be written by MOV, and only for version >= 1.1.
// Register format must be a0.x
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidAddressRegWrite() 
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    if( pDstParam->m_bParamUsed )
    {
        if( D3DSPR_ADDR == pDstParam->m_RegType )
        {
            if( m_Version < D3DVS_VERSION(1,1) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Address register not available for vertex shader version %d.%d.  Version 1.1 required.",
                            D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version) );
                m_ErrorCount++;
            }
            if( D3DSIO_MOV == m_pCurrInst->m_Type )
            {
                if( 0 != pDstParam->m_RegNum ||
                    D3DSP_WRITEMASK_0 != pDstParam->m_WriteMask ||
                    D3DSPDM_NONE != pDstParam->m_DstMod ||
                    DSTSHIFT_NONE != pDstParam->m_DstShift )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Format for address register must be a0.x." );
                    m_ErrorCount++;
                }
            }
            else
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Only the mov instruction is allowed to write to the address register." );
                m_ErrorCount++;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidDstParam
//
// ** Rule:
// Dst register type must be temp/addr/rastout/attrout/texcrdout,
// and reg num must be within range for register type.
//
// There can be no dst modifiers or shifts with vertex shaders.
//
// The writemask cannot be 'none'.
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError = FALSE;
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT RegNum = pDstParam->m_RegNum;

    if( pDstParam->m_bParamUsed )
    {
        UINT ValidRegNum = 0;

        BOOL bWritable = FALSE;
        switch( pDstParam->m_RegType )
        {
        case D3DSPR_TEMP:       
            bWritable = m_pTempRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        case D3DSPR_ADDR:       
            bWritable = m_pAddrRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pAddrRegFile->GetNumRegs();                                
            break;
        case D3DSPR_RASTOUT:    
            bWritable = m_pRastOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pRastOutputRegFile->GetNumRegs();            
            break;
        case D3DSPR_ATTROUT:    
            bWritable = m_pAttrOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pAttrOutputRegFile->GetNumRegs();                        
            break;
        case D3DSPR_TEXCRDOUT:  
            bWritable = m_pTexCrdOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pTexCrdOutputRegFile->GetNumRegs();                                    
            break;
        }

        if( !bWritable || !ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for dest param." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        } 
        else if( RegNum >= ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dest reg num: %d. Max allowed for this reg type is %d.", RegNum, ValidRegNum - 1);
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        switch( pDstParam->m_DstMod )
        {
        case D3DSPDM_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dst modifiers not allowed for vertex shaders." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        switch( pDstParam->m_DstShift )
        {
        case DSTSHIFT_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest shifts not allowed for vertex shaders." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        if( 0 == pDstParam->m_WriteMask )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask cannot be empty." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        // Update register file to indicate write.
        if( !bFoundDstError )
        {
            CRegisterFile* pRegFile = NULL;
            switch( pDstParam->m_RegType )
            {
            case D3DSPR_TEMP:       
                pRegFile = m_pTempRegFile; 
                break;
            case D3DSPR_ADDR:       
                pRegFile = m_pAddrRegFile; 
                break;
            case D3DSPR_RASTOUT:    
                pRegFile = m_pRastOutputRegFile; 
                break;
            case D3DSPR_ATTROUT:    
                pRegFile = m_pAttrOutputRegFile; 
                break;
            case D3DSPR_TEXCRDOUT:  
                pRegFile = m_pTexCrdOutputRegFile; 
                break;
            }

            if( pRegFile )
            {
                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_0 ) 
                    pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_1 ) 
                    pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_2 ) 
                    pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_3 ) 
                    pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidFRCInstruction
//
// ** Rule:
// The only valid write masks for the FRC instruction are .y and .xy
// 
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidFRCInstruction()
{
    if( NULL == m_pCurrInst )
        return TRUE;

    if( D3DSIO_FRC == m_pCurrInst->m_Type )
    {
        if( ( (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1) != m_pCurrInst->m_DstParam.m_WriteMask ) &&
            (                      D3DSP_WRITEMASK_1  != m_pCurrInst->m_DstParam.m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                "The only valid write masks for the FRC instruction are .xy and .y." );
            m_ErrorCount++;                            
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEMP,TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// In additon there is special treatment for constant registers:
//      - absolute and relative addressing of constants cannot be combined
//      - relative addressing of constants can be used more than once in an
//        instruction, as long as each instance is identical
//
// For matrix ops, 
//      - multiple constant registers of any type (including relative offset)
//        can never be paired as sources 
//      - multiple input registers (same or different) can never be paired as sources
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidRegisterPortUsage()
{
    UINT TempRegAccessCount = 0;
    UINT TempRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegAccessCount = 0;
    UINT InputRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegAccessCount = 0; // mad r0, c0, c0, c1 counts as *2* const reg accesses
    UINT ConstRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];

    BOOL bMatrixOp = FALSE;
    BOOL bSeenRelativeAddr = FALSE;
    UINT SeenRelativeAddrBase = 0;
    DWORD SeenRelativeAddrComp = 0;
    BOOL bSeenAbsoluteAddr = FALSE;
    UINT NumConsecutiveRegistersUsed = 1;
    UINT NumConstRegs = 0; // mad r0, c0, c0, c1 counts as *3* const reg accesses with this variable
    UINT NumInputRegs = 0; // mad r0, v0, v0, v1 counts as *3* input reg accesses with this variable

    switch( m_pCurrInst->m_Type )
    {
        case D3DSIO_M3x2:
            NumConsecutiveRegistersUsed = 2;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M3x3:
            NumConsecutiveRegistersUsed = 3;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M3x4:
            NumConsecutiveRegistersUsed = 4;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M4x3:
            NumConsecutiveRegistersUsed = 3;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M4x4:
            NumConsecutiveRegistersUsed = 4;
            bMatrixOp = TRUE;
            break;
        default:
            break;
    }

    for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
    {
        D3DSHADER_PARAM_REGISTER_TYPE   RegType;
        UINT                            RegNum;

        if( !m_pCurrInst->m_SrcParam[i].m_bParamUsed ) continue;
        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum  = m_pCurrInst->m_SrcParam[i].m_RegNum;

        UINT* pCount = NULL;
        UINT* pAccess = NULL;
        switch( RegType )
        {
        case D3DSPR_TEMP:
            pCount = &TempRegAccessCount;
            pAccess = TempRegAccess;
            break;
        case D3DSPR_INPUT:
            NumInputRegs++;
            pCount = &InputRegAccessCount;
            pAccess = InputRegAccess;
            break;
        case D3DSPR_CONST:
            NumConstRegs++;
            pCount = &ConstRegAccessCount;
            pAccess = ConstRegAccess;

            if( D3DVS_ADDRMODE_RELATIVE == m_pCurrInst->m_SrcParam[i].m_AddressMode )
            {
                if( bSeenAbsoluteAddr )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Absolute and relative addressing of constant registers cannot be combined in one instruction.");
                    m_ErrorCount++;        
                }
                else if( bSeenRelativeAddr && 
                        ((SeenRelativeAddrBase != RegNum) || (SeenRelativeAddrComp != m_pCurrInst->m_SrcParam[i].m_RelativeAddrComponent)))
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Different relative addressing of constant registers cannot be combined in one instruction.");
                    m_ErrorCount++;                            
                }

                bSeenRelativeAddr = TRUE;
                SeenRelativeAddrBase = RegNum;
                SeenRelativeAddrComp = m_pCurrInst->m_SrcParam[i].m_RelativeAddrComponent;
            }
            else
            {
                if( bSeenRelativeAddr )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Absolute and relative addressing of constant registers cannot be combined in one instruction.");
                    m_ErrorCount++;        
                }
                bSeenAbsoluteAddr = TRUE;
            }
            break;
        }

        if( pCount && pAccess )
        {
            BOOL bNewRegNumberAccessed = TRUE;
            for( UINT j = 0; j < *pCount; j++ )
            {
                if( RegNum == pAccess[j] )
                {
                    bNewRegNumberAccessed = FALSE;
                    break;
                }
            }
            if( bNewRegNumberAccessed )
            {
                pAccess[*pCount] = RegNum;
                (*pCount)++;
            }
        }
    }

    if( TempRegAccessCount > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.",
                        TempRegAccessCount,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( InputRegAccessCount > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.",
                        InputRegAccessCount,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( ConstRegAccessCount > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.",
                        ConstRegAccessCount, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( bMatrixOp )
    {
        if(1 < NumConstRegs)
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Multiple constant registers cannot be read by a matrix op.");
            m_ErrorCount++;        
        }
        if(1 < NumInputRegs)
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Multiple input registers cannot be read by a matrix op.");
            m_ErrorCount++;        
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for vertex shader version has not been exceeded.
//
// Nop, and comments (already stripped) do not count towards the limit.
//
// ** When to call:  
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidInstructionCount()
{
    static UINT s_OpCount;
    static UINT s_MaxTotalOpCount;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_OpCount = 0;

        switch(m_Version)
        {
        case D3DVS_VERSION(1,0):
        case D3DVS_VERSION(1,1):
        default:
            s_MaxTotalOpCount   = 128;
            break;
        }
    }

    if( m_bSeenAllInstructions )
    {
        if( s_OpCount > s_MaxTotalOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Number of instruction slots used too high: %d. Max. allowed is %d.",
                  s_OpCount, s_MaxTotalOpCount);
            m_ErrorCount++;
        }
        return TRUE;
    }

    switch( m_pCurrInst->m_Type )
    {
    case D3DSIO_NOP:
        s_OpCount += 0; break;
    case D3DSIO_ADD:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_DST:
    case D3DSIO_EXPP:
    case D3DSIO_LIT:
    case D3DSIO_LOGP:
    case D3DSIO_MAD:
    case D3DSIO_MAX:
    case D3DSIO_MIN:
    case D3DSIO_MOV:
    case D3DSIO_MUL:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
    case D3DSIO_SGE:
    case D3DSIO_SLT:
        s_OpCount += 1; break;
    case D3DSIO_M3x2:
        s_OpCount += 2; break;
    case D3DSIO_FRC:
    case D3DSIO_M3x3:
    case D3DSIO_M4x3:
        s_OpCount += 3; break;
    case D3DSIO_M3x4:
    case D3DSIO_M4x4:
        s_OpCount += 4; break;
    case D3DSIO_EXP:
    case D3DSIO_LOG:
        s_OpCount += 10; break;
    }
    
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_oPosWritten
//
// ** Rule:
// First two channels (x,y) of oPos output register must be written.
//
// ** When to call:  
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_oPosWritten()
{
    UINT  NumUninitializedComponents    = 0;
    DWORD UninitializedComponentsMask   = 0;

    for( UINT i = 0; i < 2; i++ ) // looking at component 0 (X) and component 1 (Y)
    {
        if( NULL == m_pRastOutputRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter )
        {
            NumUninitializedComponents++;
            UninitializedComponentsMask |= COMPONENT_MASKS[i];
        }
    }
    if( 1 == NumUninitializedComponents )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Vertex shader must minimally write first two (x,y) components of oPos output register.  Affected component%s(*): %s",
            NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,FALSE,TRUE));
        m_ErrorCount++;
    } 
    else if( 2 == NumUninitializedComponents )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Vertex shader must minimally write first two (x,y) components of oPos output register.");
        m_ErrorCount++;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// CVShaderValidator Wrapper Functions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// ValidateVertexShaderInternal
//-----------------------------------------------------------------------------
BOOL ValidateVertexShaderInternal(   const DWORD* pCode, 
                                     const DWORD* pDecl, 
                                     const D3DCAPS8* pCaps )
{
    CVShaderValidator Validator(pCode,pDecl,pCaps,0);
    return SUCCEEDED(Validator.GetStatus()) ? TRUE : FALSE;
}

//-----------------------------------------------------------------------------
// ValidateVertexShader
//
// Don't forget to call "free" on the buffer returned in ppBuf.
//-----------------------------------------------------------------------------
HRESULT WINAPI ValidateVertexShader(    const DWORD* pCode, 
                                        const DWORD* pDecl,
                                        const D3DCAPS8* pCaps, 
                                        const DWORD Flags, 
                                        char** const ppBuf )
{
    CVShaderValidator Validator(pCode,pDecl,pCaps,Flags);
    if( ppBuf )
    {
        *ppBuf = (char*)HeapAlloc(GetProcessHeap(), 0, Validator.GetRequiredLogBufferSize());
        if( NULL == *ppBuf )
            OutputDebugString("Out of memory.\n");
        else
            Validator.WriteLogToBuffer(*ppBuf);
    }
    return Validator.GetStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\shval\vshdrval.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// vshdrval.hpp
//
// Direct3D Reference Device - VertexShader validation
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __VSHDRVAL_HPP__
#define __VSHDRVAL_HPP__

#define VS_INST_TOKEN_RESERVED_MASK         0xffff0000 // bits 16-23, 24-29, 30, 31 must be 0
#define VS_DSTPARAM_TOKEN_RESERVED_MASK     0x0ff0e000 // bits 13-15, 20-23, 24-27 must be 0
#define VS_SRCPARAM_TOKEN_RESERVED_MASK     0x40000000 // bit 30 must be 0

//-----------------------------------------------------------------------------
// CVSInstruction
//-----------------------------------------------------------------------------
class CVSInstruction : public CBaseInstruction
{
public:
    CVSInstruction(CVSInstruction* pPrevInst) : CBaseInstruction(pPrevInst) {};

    void CalculateComponentReadMasks(DWORD dwVersion);
};

//-----------------------------------------------------------------------------
// CVShaderValidator
//-----------------------------------------------------------------------------
class CVShaderValidator : public CBaseShaderValidator
{
private:
    void ValidateDeclaration();
    const DWORD*    m_pDecl;
    BOOL            m_bFixedFunction;
    DWORD           m_dwMaxVertexShaderConst; // d3d8 cap
    BOOL            m_bIgnoreConstantInitializationChecks;

    CRegisterFile*  m_pTempRegFile;    
    CRegisterFile*  m_pInputRegFile;
    CRegisterFile*  m_pConstRegFile;
    CRegisterFile*  m_pAddrRegFile;
    CRegisterFile*  m_pTexCrdOutputRegFile;
    CRegisterFile*  m_pAttrOutputRegFile;
    CRegisterFile*  m_pRastOutputRegFile;

    CBaseInstruction* AllocateNewInstruction(CBaseInstruction*pPrevInst);
    BOOL DecodeNextInstruction();
    BOOL InitValidation();
    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();

    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidAddressRegWrite();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidFRCInstruction();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_oPosWritten();                       // Call after all instructions seen
        
public:
    CVShaderValidator(  const DWORD* pCode, 
                        const DWORD* pDecl, 
                        const D3DCAPS8* pCaps, 
                        DWORD Flags );
    ~CVShaderValidator();
};

#endif __VSHDRVAL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\dpclip.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpclip.c
 *  Content:    DrawPrimitive clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, 
                            ClipVertex *cv2, 
                            ClipVertex *cv3)
{
    ClipTriangle newtri;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    newtri.v[0] = cv1;
    newtri.v[1] = cv2;
    newtri.v[2] = cv3;

    int count;
    ClipVertex** ver;

    cv1->clip |= CLIPPED_ENABLE;
    cv2->clip |= CLIPPED_ENABLE;
    cv3->clip |= CLIPPED_ENABLE;
    // For the  flat shading mode we have to use first vertex color as 
    // color for all vertices
    D3DCOLOR diffuse1;          // Original colors
    D3DCOLOR specular1;
    D3DCOLOR diffuse2;
    D3DCOLOR specular2;
    if (pv->lpdwRStates[D3DRS_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = cv1->color;
        // Exclude fog factor
        D3DCOLOR specular = cv1->specular & 0x00FFFFFF;

        //Save original colors
        diffuse1  = cv2->color;
        specular1 = cv2->specular;
        diffuse2  = cv3->color;
        specular2 = cv3->specular;

        // Copy the same color to all vertices but preserve fog factor, because
        // fog factor should be interpolated
        cv2->color = diffuse;
        cv3->color = diffuse;
        cv2->specular = (cv2->specular & 0xFF000000) | specular;
        cv3->specular = (cv3->specular & 0xFF000000) | specular;
    }

    if (count = pv->pGeometryFuncs->ClipSingleTriangle(pv, &newtri, &ver))
    {
        int i;
        HRESULT ret;
        BYTE *pTLV = pv->ClipperState.clipBuf;
        BYTE *p = pTLV;

        for (i = 0; i < count; i++) 
        {
            MAKE_TL_VERTEX_FVF(pv, p, ver[i]);
            p += pv->dwOutputSize;
        }
        ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pTLV, count, count-2);
        if (ret)
            return ret;
    }
    // CLIPPED_ENABLE bit could be set in the ClipSingleTriangle.
    // If this bit is not cleared, clipping will be wrong. Because, clip 
    // vertices are re-used by next triangles.
    // This bit should be cleared *after* drawing command. Otherwise, edge flags 
    // will be incorrect
    cv1->clip &= ~CLIPPED_ENABLE;
    cv2->clip &= ~CLIPPED_ENABLE;
    cv3->clip &= ~CLIPPED_ENABLE;

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // Restore original colors
        cv2->color    = diffuse1;
        cv2->specular = specular1;
        cv3->color    = diffuse2;
        cv3->specular = specular2;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//----------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *v1, ClipVertex *v2)
{
    ClipTriangle newline;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    ClipVertex cv1 = *v1;
    ClipVertex cv2 = *v2;
    newline.v[0] = &cv1;
    newline.v[1] = &cv2;

    int count;
    ClipVertex** ver;

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // Copy the same color to all vertices but preserve fog factor, because
        // fog factor should be interpolated
        cv2.color = cv1.color;
        cv2.specular = (cv2.specular & 0xFF000000)|(cv1.specular & 0x00FFFFFF);
    }

    if (ClipSingleLine(pv, &newline))
    {
        BYTE *pTLV = pv->ClipperState.clipBuf;
        BYTE *p = pTLV;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[0]);
        p += pv->dwOutputSize;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[1]);
        HRESULT ret = DRAW_CLIPPED_PRIM(pv, D3DPT_LINELIST, pTLV, 2, 1);
        if (ret)
            return ret;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//------------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    BYTE   *p1;
    DWORD   f1;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    BYTE       *startVertex;                                
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                         
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = (BYTE*)pv->lpvOut;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    f1 = clipCode[0];
    p1 = vertex;
    clipCode++;
    vertex += vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], p1, f1, vertexTransformed);
    for (i = pv->dwNumVertices-2; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        f2 = clipCode[0];
        f3 = clipCode[1];

        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                BYTE tmp[__MAX_VERTEX_SIZE];
                BYTE *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart -= vertexSize;
                    memcpy (tmp, pStart, vertexSize);
                    memcpy (pStart, p1, vertexSize);
                    // Mark this call as gen by clipper, but set non clipped bit
                    pv->dwFlags |= D3DPV_NONCLIPPED; 
                    ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                            vertexCount);
                    pv->dwFlags &= ~D3DPV_NONCLIPPED;
                }
                else
                {
                    ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
                }
                if (startVertex != p1)
                    memcpy (pStart, tmp, vertexSize);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = vertex + vertexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex;
                BYTE *p3 = vertex + vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } else 
            vertexCount++;
        clipCode++;
        vertex += vertexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        BYTE tmp[__MAX_VERTEX_SIZE];
        BYTE *pStart = startVertex;
        if (startVertex == p1)
        {
            ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        }
        else
        {
            pStart -= vertexSize;
            memcpy(tmp, pStart, vertexSize);
            memcpy(pStart, p1, vertexSize);
            // Mark this call as gen by clipper
            pv->dwFlags |= D3DPV_NONCLIPPED; 
            ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
        }
        if (startVertex != p1)
            memcpy(pStart, tmp, vertexSize);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT 
D3DFE_PVFUNCSI::ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    DWORD        f1;    // Clip code for the first vertex
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;     
    // Vertex array
    BYTE       *vertex;  
    // Start indexed of the current in-screen triangle batch
    LPBYTE      startIndex;                               
    // Pointer to second index of the current triangle
    LPBYTE      index = (LPBYTE)pv->lpwIndices;
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    DWORD       dwIndexSize = pv->dwIndexSize;
    DWORD       dwFirstIndex;           // First index of the primitive
    BOOL        vertexTransformed; 
    // If there was a off-screen or clipped triangle we copy the first primitive
    // index to the start of the next in-screen triangle batch
    BOOL        bWasClipping = FALSE;

                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;
    startIndex = (LPBYTE)pv->lpwIndices;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }

    if (dwIndexSize == 2)
        dwFirstIndex = *(WORD*)index;
    else
        dwFirstIndex = *(DWORD*)index;
    f1 = clipCode[dwFirstIndex];
    LPBYTE ver;     // First vertex
    ver = vertex + dwFirstIndex * vertexSize;
    index += dwIndexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], ver, f1, vertexTransformed);
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        DWORD  v1, v2;
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
        }
        f2 = clipCode[v1];
        f3 = clipCode[v2];
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                WORD* pStart = (WORD*)startIndex;
                DWORD tmp;
                if (bWasClipping)
                {
                    // Save old value of the index before the current start 
                    // index and copy the first primitive index there. This 
                    // will the start of the current unclipped batch
                    if (dwIndexSize == 2)
                    {
                        pStart--;
                        tmp = *pStart;
                        *pStart = (WORD)dwFirstIndex;
                    }
                    else
                    {
                        pStart -= 2;
                        tmp = *(DWORD*)pStart;
                        *(DWORD*)pStart = dwFirstIndex;
                    }
                }
                ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                      vertexCount);
                if (bWasClipping)
                { // Restore old value
                    if (dwIndexSize == 2)
                        *pStart = (WORD)tmp;  
                    else
                        *(DWORD*)pStart = tmp;  
                }
                if (ret)
                    return ret;

            }
            bWasClipping = TRUE;
            // reset count and start ptr
            vertexCount = 0;
            startIndex = index + dwIndexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex + v1*vertexSize;
                BYTE *p3 = vertex + v2*vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            vertexCount++;
        index += dwIndexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        WORD* pStart = (WORD*)startIndex;
        DWORD tmp;
        if (bWasClipping)
        {
            // Save old value of the index before the current start 
            // index and copy the first primitive index there. This 
            // will the start of the current unclipped batch
            if (dwIndexSize == 2)
            {
                pStart--;
                tmp = *pStart;
                *pStart = (WORD)dwFirstIndex;
            }
            else
            {
                pStart -= 2;
                tmp = *(DWORD*)pStart;
                *(DWORD*)pStart = dwFirstIndex;
            }
        }
        ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                             vertexCount);
        if (bWasClipping)
        { // Restore old value
            if (dwIndexSize == 2)
                *pStart = (WORD)tmp;  
            else
                *(DWORD*)pStart = tmp;  
        }
        if (ret)
            return ret;

    }
    return D3D_OK;
} 

#define __PROCESS_LINE_NAME ProcessClippedLine
#define __PROCESS_TRI_LIST_NAME ProcessClippedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedTriangleStrip
#include "clipprim.h"

#define __INDEX_PRIM
#define __PROCESS_TRI_LIST_NAME ProcessClippedIndexedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedIndexedTriangleStrip
#define __PROCESS_LINE_NAME ProcessClippedIndexedLine
#include "clipprim.h"

//---------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    for (i=0; i < nVertices; i++) 
    {
        if (clipCode[i]) 
        {       // if this point is clipped
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
            pv->pDDI->SkipVertices(1);
        } 
        else 
        {
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//---------------------------------------------------------------------
// We do not throw away point sprites which centers are off screeen.
// We detect this case and compute screen coordinates for those sprites
//
HRESULT ProcessClippedPointSprites(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    for (i=0; i < nVertices; i++) 
    {
        // If a point is outside screen or guard band, the sprite could still
        // be visible (when the guard band is small enough
        if (clipCode[i] & ~(D3DCS_LEFT | D3DCS_RIGHT | 
                            D3DCS_TOP | D3DCS_BOTTOM | 
                            __D3DCLIPGB_ALL))
        {
            // This point is off viewing frustum
            if (count) 
            { // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
            if (!(pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION))
                pv->pDDI->SkipVertices(1);
        } 
        else 
        {
            if (clipCode[i])
            {
                // When we are here, the point sprite center is off-screen, but
                // could be visible

                // Non zero when the point is outside guard band
                DWORD gbBits = clipCode[i] & __D3DCLIPGB_ALL;   

                // Screen coordinates were not computed for the point if there is 
                // no guard band or the point is outside the guard band
                if (!(pv->dwDeviceFlags & D3DDEV_GUARDBAND) ||
                    (pv->dwDeviceFlags & D3DDEV_GUARDBAND) && gbBits)
                {
                    D3DVECTORH* p = (D3DVECTORH*)lpCurVertex;
                    float w = 1.0f/p->w;
                    p->x = p->x * w * pv->vcache.scaleX + pv->vcache.offsetX;
                    p->y = p->y * w * pv->vcache.scaleY + pv->vcache.offsetY;
                    p->z = p->z * w * pv->vcache.scaleZ + pv->vcache.offsetZ;
                    p->w  = w;
                }
            }
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//---------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ProcessClippedIndexedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartIndex;
    BYTE           *lpCurIndex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nIndices = pv->dwNumIndices;
    DWORD           dwIndexSize = pv->dwIndexSize;
    LPBYTE          pIndices = (LPBYTE)pv->lpwIndices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartIndex = lpCurIndex = (BYTE*)pv->lpwIndices;
    // Update the address of the vertex array to handle the index base
    clipCode -= pv->dwIndexOffset;

    for (i=0; i < nIndices; i++) 
    {
        DWORD  index;
        if (dwIndexSize == 2)
            index = *(WORD*)pIndices;
        else
            index = *(DWORD*)pIndices;
        pIndices += dwIndexSize;
        if (clipCode[index]) 
        {       // if this point is clipped
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_INDEX_PRIM(pv, D3DPT_POINTLIST, (WORD*)lpStartIndex, 
                                      count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurIndex += pv->dwIndexSize;
            lpStartIndex = lpCurIndex;
        } 
        else 
        {
            count++;
            lpCurIndex += pv->dwIndexSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        ret = DRAW_INDEX_PRIM(pv, D3DPT_POINTLIST, (WORD*)lpStartIndex, count, 
                              count);
        if (ret)
            return ret;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\clipper.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.h
 *  Content:    Clipper definitions
 *
 ***************************************************************************/
#ifndef _CLIPPER_H_
#define _CLIPPER_H_

//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define D3DCS_LEFTBIT     1
#define D3DCS_RIGHTBIT    2
#define D3DCS_TOPBIT      3
#define D3DCS_BOTTOMBIT   4
#define D3DCS_FRONTBIT    5
#define D3DCS_BACKBIT     6
#define D3DCLIPGB_LEFTBIT   13
#define D3DCLIPGB_RIGHTBIT  14
#define D3DCLIPGB_TOPBIT    15
#define D3DCLIPGB_BOTTOMBIT 16

//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - CD3DHal *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                         DWORD clipFlag, BOOL transformed);
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - CD3DHal *
// in    - clipVertex
// out   - TL vertex
//
inline void 
MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in)
{
    *(D3DVECTORH*)out = *(D3DVECTORH*)&(in)->sx;
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
        *(DWORD*)&out[pv->diffuseOffsetOut]  =  (in)->color;               
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
        *(DWORD*)&out[pv->specularOffsetOut] =  (in)->specular;               
    memcpy(&out[pv->texOffsetOut], in->tex, pv->dwTextureCoordSizeTotal);
}

#endif // _CLIPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\clipper.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.c
 *  Content:    Clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#define GET_NEW_CLIP_VERTEX \
&pv->ClipperState.clip_vertices[pv->ClipperState.clip_vertices_used++];
//---------------------------------------------------------------------
__inline void
InterpolateColor(DWORD* p,      // Output
                 DWORD p1,
                 DWORD p2,
                 D3DVALUE num_denom )
{
    float r1, g1, b1, a1;
    float r2, g2, b2, a2;

    r1 = (float)(RGBA_GETRED(p1));
    g1 = (float)(RGBA_GETGREEN(p1));
    b1 = (float)(RGBA_GETBLUE(p1));
    a1 = (float)(RGBA_GETALPHA(p1));
    r2 = (float)(RGBA_GETRED(p2));
    g2 = (float)(RGBA_GETGREEN(p2));
    b2 = (float)(RGBA_GETBLUE(p2));
    a2 = (float)(RGBA_GETALPHA(p2));
    DWORD r = FTOI(r1 + (r2 - r1) * num_denom);
    DWORD g = FTOI(g1 + (g2 - g1) * num_denom);
    DWORD b = FTOI(b1 + (b2 - b1) * num_denom);
    DWORD a = FTOI(a1 + (a2 - a1) * num_denom);
    *p = RGBA_MAKE(r, g, b, a);
}
//---------------------------------------------------------------------
__inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
        return ((t2 - t1) * num_denom + t1);
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f)
            t -= 1.0f;
        return t;
    }
}
//---------------------------------------------------------------------
void
Interpolate(D3DFE_PROCESSVERTICES *pv,
            ClipVertex *p,
            ClipVertex *p1,
            ClipVertex *p2,
            int code,
            D3DVALUE num, D3DVALUE denom)
{
    D3DVALUE num_denom = num / denom;

    p->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    p->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    p->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    p->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    p->hw = p1->hw + (p2->hw - p1->hw) * num_denom;

    // Note: for the flat shade mode we assigned the same color (except fog 
    // factor) to all vertices  when we prepared the triangle (line) for 
    // clipping
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
    {
        if (!(pv->dwDeviceFlags & D3DDEV_FLATSHADEMODE))
            InterpolateColor(&p->color, p1->color, p2->color, num_denom);
        else
            p->color = p1->color;
    }
    
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
    {
        if (!(pv->dwDeviceFlags & D3DDEV_FLATSHADEMODE))
            InterpolateColor(&p->specular, p1->specular, p2->specular, num_denom);
        else
        {
            float a1 = (float)(RGBA_GETALPHA(p1->specular));
            float a2 = (float)(RGBA_GETALPHA(p2->specular));
            DWORD a = FTOI(a1 + (a2 - a1) * num_denom);
            p->specular = (p1->specular & 0xFFFFFF) + ((a & 0xFF) << 24);
        }
    }

    // Assume that D3DRENDERSTATE_WRAPi are sequential
    D3DVALUE *pTexture1 = p1->tex;
    D3DVALUE *pTexture2 = p2->tex;
    D3DVALUE *pTexture = p->tex;
    for (DWORD i = 0; i < pv->nOutTexCoord; i++)
    {
        DWORD wrapState = pv->lpdwRStates[D3DRENDERSTATE_WRAP0 + i];
        DWORD n = (DWORD)(pv->dwTextureCoordSize[i] >> 2);
        DWORD dwWrapBit = 1;
        for (DWORD j=0; j < n; j++)
        {
            *pTexture = InterpolateTexture(*pTexture1, *pTexture2,
                                           num_denom, wrapState & dwWrapBit);
            dwWrapBit <<= 1;
            pTexture ++;
            pTexture1++;
            pTexture2++;
        }
    }
}
//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND
//
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//
int ClipByPlane (D3DFE_PROCESSVERTICES *pv,
                 ClipVertex **inv, 
                 ClipVertex **outv,
                 D3DVECTORH *plane,
                 DWORD dwClipFlag,
                 int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->hx*plane->x + prev->hy*plane->y + 
                  prev->hz*plane->z + prev->hw*plane->w;
    for (i = count; i; i--) 
    {
        curr_inside = curr->hx*plane->x + curr->hy*plane->y + 
                      curr->hz*plane->z + curr->hw*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | dwClipFlag,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            dwClipFlag,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int ClipLineByPlane(D3DFE_PROCESSVERTICES *pv, 
                    ClipTriangle *line, 
                    D3DVECTORH *plane,
                    DWORD dwClipBit)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
    in1 = line->v[0]->hx * plane->x + 
          line->v[0]->hy * plane->y + 
          line->v[0]->hz * plane->z + 
          line->v[0]->hw * plane->w;
    in2 = line->v[1]->hx * plane->x + 
          line->v[1]->hy * plane->y + 
          line->v[1]->hz * plane->z + 
          line->v[1]->hw * plane->w;
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void ComputeScreenCoordinates(D3DFE_PROCESSVERTICES *pv,
                              ClipVertex **inv,
                              int count)
{
    int i;
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;

    for (i = 0; i < count; i++)
    {
        ClipVertex *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         *      1) Vertices generated during interpolation
         *      2) Vertices marked for clipping by the transform but
         *              not clipped here due to the finite precision
         *              of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE)
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->sx = VPORT.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VPORT.maxXgb; break;
            default:
                p->sx = p->hx * VPORT.scaleX * w + VPORT.offsetX;
                if (p->sx < VPORT.minXgb)
                        p->sx = VPORT.minXgb;
                if (p->sx > VPORT.maxXgb)
                        p->sx = VPORT.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->sy = VPORT.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VPORT.minYgb; break;
            default:
                p->sy = p->hy * VPORT.scaleY * w + VPORT.offsetY;
                if (p->sy < VPORT.minYgb)
                        p->sy = VPORT.minYgb;
                if (p->sy > VPORT.maxYgb)
                        p->sy = VPORT.maxYgb;
            }
            p->sz = p->hz * w * pv->vcache.scaleZ + pv->vcache.offsetZ;
            p->rhw = w;
        }
    }
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeUserPlanes(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = D3DCS_PLANE0;
    for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
    {
        if ((p->hx*pv->userClipPlane[i].x + 
             p->hy*pv->userClipPlane[i].y + 
             p->hz*pv->userClipPlane[i].z + 
             p->hw*pv->userClipPlane[i].w) < 0)
        {
            clip |= dwClipBit;
        }
        dwClipBit <<= 1;
    }
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * pv->vcache.Kgbx1)
        clip |= __D3DCLIPGB_LEFT;
    if (p->hx > p->hw * pv->vcache.Kgbx2)
        clip |= __D3DCLIPGB_RIGHT;
    if (p->hy < p->hw * pv->vcache.Kgby1)
        clip |= __D3DCLIPGB_BOTTOM;
    if (p->hy > p->hw * pv->vcache.Kgby2)
        clip |= __D3DCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= D3DCS_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= D3DCS_LEFT;
    if (p->hx > p->hw)
        clip |= D3DCS_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= D3DCS_BOTTOM;
    if (p->hy > p->hw)
        clip |= D3DCS_TOP;
    if (p->hz > p->hw)
        clip |= D3DCS_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//***********************************************************************
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int D3DFE_PVFUNCSI::ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                      ClipTriangle *tri,
                                      ClipVertex ***clipVertexPointer)
{
    int accept;
    int i;
    int count;
    ClipVertex **inv;
    ClipVertex **outv;
    ClipVertex *p;
    ULONG_PTR swapv;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;

    count = 3;
    outv = pv->ClipperState.clip_vbuf1;
    pv->ClipperState.clip_color = tri->v[0]->color;
    pv->ClipperState.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)pv->ClipperState.clip_vbuf1;
        tmp2 = (ULONG_PTR)pv->ClipperState.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    pv->ClipperState.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (ClipVertex**) (swapv - (ULONG_PTR) outv)

    if (accept & D3DCS_FRONT)
    {
        count = ClipFront(pv, inv, outv, count);
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCS_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_LEFT)
        {
            count = ClipLeftGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_RIGHT)
        {
            count = ClipRightGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_BOTTOM)
        {
            count = ClipBottomGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_TOP)
        {
            count = ClipTopGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCS_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_LEFT)
        {
            count = ClipLeft(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_RIGHT)
        {
            count = ClipRight(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_BOTTOM)
        {
            count = ClipBottom(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_TOP)
        {
            count = ClipTop(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCS_PLANE0;
        DWORD dwClippedBit = CLIPPED_PLANE0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                count = ClipByPlane(pv, inv, outv, &pv->userClipPlane[i], 
                                    dwClippedBit, count);
                if (count < 3)
                    goto out_of_here;
                SWAP(inv, outv);
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

#undef SWAP

    ComputeScreenCoordinates(pv, inv, count);

    *clipVertexPointer = inv;
    pv->ClipperState.current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}
//*************************************************************************
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleLine"

int D3DFE_PVFUNCSI::ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *line)
{
    int         accept;
    D3DVALUE    in1, in2;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (line->v[0]->clip | line->v[1]->clip);

    pv->ClipperState.clip_color = line->v[0]->color;
    pv->ClipperState.clip_specular = line->v[0]->specular;

    if (accept & D3DCS_FRONT)
        if (ClipLineFront(pv, line))
            goto out_of_here;
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCS_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_LEFT)
            if (ClipLineLeftGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_RIGHT)
            if (ClipLineRightGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_TOP)
            if (ClipLineTopGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_BOTTOM)
            if (ClipLineBottomGB(pv, line))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCS_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & D3DCS_LEFT)
            if (ClipLineLeft(pv, line))
                goto out_of_here;
        if (accept & D3DCS_RIGHT)
            if (ClipLineRight(pv, line))
                goto out_of_here;
        if (accept & D3DCS_TOP)
            if (ClipLineTop(pv, line))
                goto out_of_here;
        if (accept & D3DCS_BOTTOM)
            if (ClipLineBottom(pv, line))
                goto out_of_here;
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCS_PLANE0;
        DWORD dwClippedBit = CLIPPED_PLANE0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                if (ClipLineByPlane(pv, line, &pv->userClipPlane[i], 
                                    dwClippedBit))
                    goto out_of_here;
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

    ComputeScreenCoordinates(pv, line->v, 2);

    return 1;
out_of_here:
    return 0;
} // ClipSingleLine
//----------------------------------------------------------------------
//    GenClipFlags()  Generates clip flags for a set of FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "GenClipFlags"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    DWORD clip_intersection, clip_union;
    float left   = pv->vcache.minX;
    float top    = pv->vcache.minY;
    float right  = pv->vcache.maxX;
    float bottom = pv->vcache.maxY;
    float leftgb  ;         // Guard band window
    float topgb   ;
    float rightgb ;
    float bottomgb;
    DWORD clipZF, clipZB;
    DWORD stride = pv->position.dwStride;

    clipZF = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCS_FRONT : 0;
    clipZB = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCS_BACK : 0;

    clip_intersection = (DWORD)~0;
    clip_union = (DWORD)0;

    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        leftgb   = pv->vcache.minXgb;
        topgb    = pv->vcache.minYgb;
        rightgb  = pv->vcache.maxXgb;
        bottomgb = pv->vcache.maxYgb;
    }
     /* Only generate clip flags */
    D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
    D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
    DWORD i;

    // Point sprites are clipped only by Z planes. Clipping by X and Y planes
    // will be done when we expand point sprites
    if (pv->primType == D3DPT_POINTLIST && 
        pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        for (i = pv->dwNumVertices; i; i--)
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (z < 0.0f)
                clip |= clipZF;
            else
            if (z >= 1.0f)
                clip |= clipZB;

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
    }
    else
    for (i = pv->dwNumVertices; i; i--)
    {
        DWORD clip = 0;
        D3DVALUE x,y,z;
        if (lpVertices->rhw < 0)
        {
            x = -lpVertices->sx;
            y = -lpVertices->sy;
            z = -lpVertices->sz;
        }
        else
        {
            x = lpVertices->sx;
            y = lpVertices->sy;
            z = lpVertices->sz;
        }

        if (x < left)
            clip |= D3DCS_LEFT;
        else
        if (x >= right)
            clip |= D3DCS_RIGHT;

        if (y < top)
            clip |= D3DCS_TOP;
        else
        if (y >= bottom)
            clip |= D3DCS_BOTTOM;

        if (z < 0.0f)
            clip |= clipZF;
        else
        if (z >= 1.0f)
            clip |= clipZB;

        if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
        {
            if (x < leftgb)
                clip |= __D3DCLIPGB_LEFT;
            else
            if (x >= rightgb)
                clip |= __D3DCLIPGB_RIGHT;

            if (y < topgb)
                clip |= __D3DCLIPGB_TOP;
            else
            if (y >= bottomgb)
                clip |= __D3DCLIPGB_BOTTOM;
        }

        clip_intersection &= clip;
        clip_union |= clip;
        *clipCode++ = (D3DFE_CLIPCODE)clip;
        lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
    }
    pv->dwClipIntersection = clip_intersection;
    pv->dwClipUnion = clip_union;

    return clip_intersection;
}   // end of GenClipFlags()
//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - CD3DHal *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                          DWORD clipFlag, BOOL transformed)
{                                                               
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    BYTE *v = (BYTE*)p1;                                               
    if (transformed || !(clipFlag & pv->dwClipMaskOffScreen))         
    {                                                           
        pp1.sx  = ((D3DVALUE*)v)[0];                            
        pp1.sy  = ((D3DVALUE*)v)[1];                            
        pp1.sz  = ((D3DVALUE*)v)[2];                            
        pp1.rhw = ((D3DVALUE*)v)[3];
        pp1.hw  = 1.0f / ((D3DVALUE*)v)[3];                     
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw * VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw * VPORT.scaleYi;                                
        pp1.hz  = (pp1.sz - VPORT.offsetZ) * pp1.hw * VPORT.scaleZi;
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = ((D3DVALUE*)v)[0];                             
        pp1.hy = ((D3DVALUE*)v)[1];                             
        pp1.hz = ((D3DVALUE*)v)[2];                             
        pp1.hw = ((D3DVALUE*)v)[3];                             
    }                                                           
    v += sizeof(D3DVALUE) * 4;                                  
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)                   
    {                                                           
        pp1.color   = *(DWORD*)v;                               
        v += sizeof(D3DVALUE);                                  
                                                                
    }                                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)                  
    {                                                           
        pp1.specular= *(DWORD*)v;                               
        v += sizeof(DWORD);                                     
    }                                                           
    memcpy(pp1.tex, v, pv->dwTextureCoordSizeTotal);
    pp1.clip = clipFlag; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\clipprim.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip primitives
 *
 * The following symbol should be defined before included this file:
 * __PROCESS_LINE_NAME  - name for a function to clip triangles
 * __INDEX_PRIM         - name for a function to clip lines
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
#ifdef __INDEX_PRIM
#define __DRAW DRAW_INDEX_PRIM
#else
#define __DRAW DRAW_PRIM
#endif

//*********************************************************************
HRESULT D3DFE_PVFUNCSI::__PROCESS_TRI_LIST_NAME(D3DFE_PROCESSVERTICES *pv)
{
    int vertexSize3;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    DWORD       dwIndexSize = pv->dwIndexSize;
    DWORD       dwIndexSize3 = pv->dwIndexSize * 3;
    // Start indexed of the current in-screen triangle batch
    WORD*       startVertex = pv->lpwIndices;
    // Start index of the current triangle
    LPBYTE      index = (LPBYTE)pv->lpwIndices;
#else
    // Start vertex of the current in-screen triangle batch
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

#ifdef __INDEX_PRIM
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }
#endif

    vertexSize3 = vertexSize*3;
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;   // Current triangle indices
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
            v3 = *(WORD*)(index + 4);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
            v3 = *(DWORD*)(index + 8);
        }
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {// This tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                DWORD vertexCount = primitiveCount*3;
                ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                             vertexCount, primitiveCount);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = (WORD*)(index + dwIndexSize3);
#else
            pv->pDDI->SkipVertices(3);
            startVertex = vertex + vertexSize3;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped
            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                p1 = vertex + v1*vertexSize;
                p2 = vertex + v2*vertexSize;
                p3 = vertex + v3*vertexSize;
#else
                p1 = vertex;
                p2 = vertex + vertexSize;
                p3 = p2 + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

#ifdef __INDEX_PRIM
#endif
                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            primitiveCount++;
#ifdef __INDEX_PRIM
        index += dwIndexSize3;
#else
        clipCode += 3;
        vertex += vertexSize3;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                     primitiveCount*3, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::__PROCESS_TRI_STRIP_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD lastIndex;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    DWORD       dwIndexSize = pv->dwIndexSize;
    LPWORD      startVertex = pv->lpwIndices;                               
    LPBYTE      index = (LPBYTE)pv->lpwIndices;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int           primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

#ifdef __INDEX_PRIM
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }
#endif

    lastIndex = pv->dwNumPrimitives;
    for (i=0; i < lastIndex; i++) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
            v3 = *(WORD*)(index + 4);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
            v3 = *(DWORD*)(index + 8);
        }
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                             primitiveCount+2, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                // We need to re-use the last vertex of the unclipped primitive
                // So we move the PrimitiveBase and startVertex back
                pv->pDDI->MovePrimitiveBase(-1);
                startVertex = vertex - vertexSize;
#endif
            }
            else
            {
#ifndef __INDEX_PRIM
                // Move PrimitiveBase and UsedVertexCount
                pv->pDDI->SkipVertices(1);
                startVertex = vertex + vertexSize;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = (LPWORD)(index + dwIndexSize);
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                if (i & 1)
                { // For odd triangles we have to change orientation
                  // First vertex should remain the first, because it defines
                  // the color in FLAT shade mode
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v3*vertexSize;
                    p3 = vertex + v2*vertexSize;
                }
                else
                {
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v2*vertexSize;
                    p3 = vertex + v3*vertexSize;
                }

#else
                p1 = vertex;
                if (i & 1)
                { // For odd triangles we have to change orientation
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p3 = vertex + vertexSize;
                    p2 = p3 + vertexSize;
                }
                else
                {
                    p2 = vertex + vertexSize;
                    p3 = p2 + vertexSize;
                }
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
        {
            if (primitiveCount == 0 && i & 1)
            { // Triangle strip can not start from an odd triangle
              // Because we use triangle fan, first vertex in the strip
              // should be the second in the fan. 
              // This vertex defines the color in FLAT shading case.
                BYTE tmp[__MAX_VERTEX_SIZE*3];
                BYTE *p = tmp;
#ifdef __INDEX_PRIM
                BYTE *saveVer = (BYTE*)pv->lpvOut;   
                DWORD numVer = pv->dwNumVertices;  
                memcpy (p, vertex + v2*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v1*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v3*vertexSize, vertexSize);
#else
                memcpy(p, vertex + vertexSize, vertexSize);
                p += vertexSize;
                memcpy(p, vertex, vertexSize);
                p += vertexSize;
                memcpy(p, vertex + vertexSize + vertexSize, vertexSize);
#endif
                pv->dwFlags |= D3DPV_NONCLIPPED; 
                ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, tmp, 3, 1);
                pv->dwFlags &= ~D3DPV_NONCLIPPED;
                if (ret)
                    return ret;
                primitiveCount = 0;
#ifdef __INDEX_PRIM
                startVertex = (LPWORD)(index + dwIndexSize);
                pv->lpvOut = saveVer;
                pv->dwNumVertices = numVer;
#else
                pv->pDDI->SkipVertices(1);
                startVertex = vertex + vertexSize;
#endif
            }   
            else
                primitiveCount++;
        }
#ifdef __INDEX_PRIM
        index += dwIndexSize;
#else
        clipCode++;
        vertex += vertexSize;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                     primitiveCount+2, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//-----------------------------------------------------------------------------
// The same functions is used for line lists and line strips
//
HRESULT D3DFE_PVFUNCSI::__PROCESS_LINE_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD nextLineOffset;       // How many vertices to skip, when going to 
                                // next primitive (1 for strips, 2 for lists)
    DWORD nextLineOffsetIndex;  // Multiplied by the index size
    DWORD countAdd;             // Used to compute "real" number of vertices
                                // from the vertexCount
    D3DPRIMITIVETYPE primType;
    int numPrim = 0;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPBYTE      index = (LPBYTE)pv->lpwIndices;                               
    DWORD       dwIndexSize = pv->dwIndexSize;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         vertexCount;    // Primitive count for line strips, 
                                // vertex count for line lists
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

#ifdef __INDEX_PRIM
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }
#endif

    primType = pv->primType;
    if (primType == D3DPT_LINESTRIP)
    {
#ifdef __INDEX_PRIM
        nextLineOffset = 1;
        nextLineOffsetIndex = dwIndexSize;
#else
        nextLineOffset = 1;
#endif
        countAdd = 1;
    }
    else
    {
#ifdef __INDEX_PRIM
        nextLineOffset = 2;
        nextLineOffsetIndex = dwIndexSize * 2;
#else
        nextLineOffset = 2;
#endif
        countAdd = 0;
    }
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        WORD f1, f2;
#ifdef __INDEX_PRIM
        DWORD v1, v2;
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
        }
        f1 = clipCode[v1];
        f2 = clipCode[v2];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2) 
            offFrustum = TRUE;
        else
        if ((f1 | f2) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {      // if this line does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                // For line strips we have to go one vertex back
                pv->pDDI->MovePrimitiveBase(-(int)countAdd);
                // Now go to the next primitive
                pv->pDDI->MovePrimitiveBase(nextLineOffset);
                startVertex = vertex + nextLineOffset*vertexSize;
#endif
            }
            else
            {
#ifndef __INDEX_PRIM
                pv->pDDI->SkipVertices(nextLineOffset);
                startVertex = vertex + nextLineOffset*vertexSize;
#endif
            }
            // reset count and start ptr
            vertexCount = 0;
            numPrim = 0;
#ifdef __INDEX_PRIM
            startVertex = (LPWORD)(index + nextLineOffsetIndex);
#endif

            // now deal with the single clipped line
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
#ifdef __INDEX_PRIM
                BYTE *p1 = vertex + v1*vertexSize;
                BYTE *p2 = vertex + v2*vertexSize;
#else
                BYTE *p1 = vertex;
                BYTE *p2 = vertex + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);

                ret = ClipLine(pv, &cv[0], &cv[1]);
                if (ret != D3D_OK)
                    return ret;
            }
        } 
        else 
        {
            vertexCount += nextLineOffset;
            numPrim++;
        }
#ifdef __INDEX_PRIM
        index += nextLineOffsetIndex;
#else
        vertex += nextLineOffset*vertexSize;
        clipCode += nextLineOffset;
#endif
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
        if (ret)
            return ret;
    }
    return D3D_OK;
}

#undef __DRAW
#undef __INDEX_PRIM
#undef __PROCESS_LINE_NAME
#undef __PROCESS_TRI_LIST_NAME
#undef __PROCESS_TRI_STRIP_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\clipfunc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipfunc.h
 *  Content:    Clipper functions
 *
 ***************************************************************************/

#ifndef _CLIPFUNC_H_
#define _CLIPFUNC_H_

#include "clipper.h"
#include "ddibase.h"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);

//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of a primitive
//
inline HRESULT DRAW_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType,
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    try
    {
        pv->pDDI->DrawPrim(pv);
    }
    catch( HRESULT hr )
    {
        return hr;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw clipped part of a primitive
//
inline HRESULT DRAW_CLIPPED_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType, 
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;                                    
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    try
    {
        pv->pDDI->DrawClippedPrim(pv);
    }
    catch( HRESULT hr )
    {
        return hr;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of an 
// indexed primitive
//
inline HRESULT DRAW_INDEX_PRIM(D3DFE_PROCESSVERTICES *pv, 
                               D3DPRIMITIVETYPE primitiveType, 
                               LPWORD startIndex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpwIndices = startIndex;                                     
    pv->primType = primitiveType;                                    
    pv->dwNumIndices = vertexCount;                                  
    pv->dwNumPrimitives = numPrim;                                   
    try
    {
        pv->pDDI->DrawIndexPrim(pv);
    }
    catch( HRESULT hr )
    {
        return hr;
    }
    return D3D_OK;
}
//----------------------------------------------------------------------
// Clip a triangle made by 3 vertices
// bCanModifyVertices is set to TRUE, if the function can modify the original 
// vertices
//
HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2, ClipVertex *cv3);
HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2);

#endif // _CLIPFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
            #define DEBUG
        #endif
    #endif

    extern void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);

    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPF_DECLARE(szName) char * __pszDpfName=#szName":"
        #define DPFINIT()   DPFInit()
        #define DPF         DXdprintf
        #define DPF_ERR(a)  DXdprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
            #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
            #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT

        // New for D3D
        #define D3D_ERR       D3DErrorPrintf
        #define D3D_WARN      D3DWarnPrintf
        #define D3D_INFO      D3DInfoPrintf
    #else
        #pragma warning(disable:4002)
        #define DPF_DECLARE(szName)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()

        #define D3D_ERR(a)
        #define D3D_WARN()
        #define D3D_INFO()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD perf_clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= perf_clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += perf_clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\dpf.c ===
#undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
            if( hWndListBox != NULL )
            {
                if( !IsWindow( hWndListBox ) )
                {
                    hWndListBox = NULL;
                }
            }
            if( hWndListBox != NULL )
            {
                UINT    sel;
                int     len;
                len = strlen( str );
                if( len > 0 )
                {
                    if( str[len-1] == '\r' || str[len-1] == '\n' )
                    {
                        str[len-1] = 0;
                    }
                    if( len > 1 )
                    {
                        if( str[len-2] == '\r' || str[len-2] == '\n' )
                        {
                            str[len-2] = 0;
                        }
                    }
                }
                SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
                sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
                if( sel != LB_ERR )
                {
                    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
                }
            }
        #endif

    } /* dumpStr */

    /*
     * DXdprintf
     */
    void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

        va_end(ap);
    } /* DXdprintf */


    static void cdecl D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;

        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            wsprintf( (LPSTR) str+lstrlen( str ), msgType );
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

    } /* D3Dprintf */

    void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap, szFormat);

        D3Dprintf(lvl, "(INFO) :", szFormat, ap);

        va_end(ap);
    }

    void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(lvl, "(WARN) :", szFormat, ap);
        va_end(ap);
    }

    void cdecl D3DErrorPrintf( LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(0, "(ERROR) :", szFormat, ap);
        va_end(ap);
    }

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        DXdprintf( ASSERT_MESSAGE_LEVEL, buffer );
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
            /*
             * Into the debugger we go...
             */
            DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\pch.cpp ===
#include "ddraw.h"
#include "d3d8p.h"
#include <math.h>
#include "dpf.h"
#include "d3dflt.h"
#include "d3dutil.h"
#include "d3dfe.hpp"
#include "vvm.h"
#include "pipeln.h"
#include "clipper.h"
#include "clipfunc.h"
#include "light.h"
#include "pvvid.h"
#include "fe.h"
#include "ddibase.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
.SUFFIXES: .mh .mcp

GENTGT = $(_OBJ_DIR)\$(TARGET_DIRECTORY)

# Create a .h file from a .mh file.
{..}.mh{$(GENTGT)}.h:
    m4 -I.. $< > $*.h

# Create a .cpp file from a .mcp file.
{..}.mcp{$(GENTGT)}.cpp:
    m4 -I.. $< > $(GENTGT)\$(<B).cpp

..\pvvid.mcp: ..\pvvid.mh
..\pvone.mcp: ..\pvvid.mh
..\loops.mcp: ..\pvvid.mh

$(GENTGT)\pvvid.cpp: ..\pvvid.mcp
$(GENTGT)\pvone.cpp: ..\pvone.mcp
$(GENTGT)\loops.cpp: ..\loops.mcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\light.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       light.h
 *  Content:    Direct3D lighting include file
 *
 ***************************************************************************/

#ifndef __LIGHT_H__
#define __LIGHT_H__

struct BATCHBUFFER;

extern "C"
{
void Directional7(LPD3DFE_PROCESSVERTICES pv, 
                  D3DI_LIGHT *light, 
                  D3DVERTEX *pInpCoord, 
                  D3DVALUE* pWeights,
                  BYTE* pMatrixIndices,
                  D3DVECTOR *pInpNormal,
                  D3DLIGHTINGELEMENT *pEyeSpaceData);
void Directional7Model(LPD3DFE_PROCESSVERTICES pv, 
                       D3DI_LIGHT *light, 
                       D3DVERTEX *pInpCoord, 
                       D3DVALUE* pWeights,
                       BYTE* pMatrixIndices,
                       D3DVECTOR *pInpNormal,
                       D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7(LPD3DFE_PROCESSVERTICES pv, 
                D3DI_LIGHT *light, 
                D3DVERTEX *pInpCoord, 
                D3DVALUE* pWeights,
                BYTE* pMatrixIndices,
                D3DVECTOR *pInpNormal,
                D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7Model(LPD3DFE_PROCESSVERTICES pv, 
                     D3DI_LIGHT *light, 
                     D3DVERTEX *pInpCoord, 
                     D3DVALUE* pWeights,
                     BYTE* pMatrixIndices,
                     D3DVECTOR *pInpNormal,
                     D3DLIGHTINGELEMENT *pEyeSpaceData);
void DirectionalFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
}

#endif  /* __LIGHT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\psgp.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   x3d.cpp
 *
 ***************************************************************************/


#include "pch.cpp"
#pragma hdrstop

#include "fe.h"
#include "d3dexcept.hpp"

//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::CreateShader(CVElement* pElements, DWORD dwNumElements,
                                     DWORD* pdwShaderCode, DWORD dwOutputFVF,
                                     CPSGPShader** ppPSGPShader)
{
    *ppPSGPShader = NULL;
    try
    {
//        *ppPSGPShader = m_VertexVM.CreateShader(pdwShaderCode);
    }
    D3D_CATCH;
    return S_OK;
}
//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::SetActiveShader(CPSGPShader* pPSGPShader)
{
    return m_VertexVM.SetActiveShader((CVShaderCode*)pPSGPShader);
}
//-----------------------------------------------------------------------------
// Load vertex shader constants
HRESULT D3DFE_PVFUNCSI::LoadShaderConstants(DWORD start, DWORD count, 
                                            LPVOID buffer)
{
    return m_VertexVM.SetData(D3DSPR_CONST, start, count, buffer);
}
//-----------------------------------------------------------------------------
HRESULT D3DAPI
FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs)
{
    *lpLeafFuncs = new D3DFE_PVFUNCSI;
    return D3D_OK;
}
//-----------------------------------------------------------------------------

HRESULT D3DFE_PVFUNCSI::GetShaderConstants(DWORD start, DWORD count, LPVOID buffer)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\fe.h ===
#ifndef __MSPSGP_H_
#define __MSPSGP_H_
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mspsgp.h
 *  Content:    Defines for Microsoft's PSPG implementation
 *
 ***************************************************************************/

#include "vvm.h"

// DEBUG_PIPELINE is defined to check performance and to allow to choose
// diifferent paths in the geometry pipeline
// Undefine DEBUG_PIPELINE for final

//#define DEBUG_PIPELINE

#ifdef DEBUG_PIPELINE
const DWORD __DEBUG_NORENDERING = 1;    // Disable writing drawing command to the command buffer
const DWORD __DEBUG_ONEPASS = 2;        // Disable clip and light in one pass
const DWORD __DEBUG_MODELSPACE = 4;     // Disable lighting in model space
#endif

//---------------------------------------------------------------------
// Returns TRUE if cipping is needed
//
inline BOOL CheckIfNeedClipping(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        if (pv->dwClipUnion & ~__D3DCS_INGUARDBAND)
            return  TRUE;
    }
    else
        if (pv->dwClipUnion)
            return  TRUE;
    return FALSE;
}
//-----------------------------------------------------------------------------
// Direct3D default implementation of PVFUNCS
//
class D3DFE_PVFUNCSI : public ID3DFE_PVFUNCS
{
public:
    DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES);
    int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                           ClipTriangle *tri,
                           ClipVertex ***clipVertexPointer);
    HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv);
    HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv);
    HRESULT ProcessLineList(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessLineStrip(D3DFE_PROCESSVERTICES *pv);
    DWORD   ProcessVerticesVVM(LPD3DFE_PROCESSVERTICES pv);
    HRESULT CreateShader(CVElement* pElements, DWORD dwNumElements,
                                     DWORD* pdwShaderCode, DWORD dwOutputFVF, 
                                     CPSGPShader** ppPSGPShader);
    HRESULT SetActiveShader(CPSGPShader* pPSGPShader);
    HRESULT LoadShaderConstants(DWORD start, DWORD count, LPVOID buffer);
    HRESULT GetShaderConstants(DWORD start, DWORD count, LPVOID buffer);
    HRESULT SetOutputFVF(DWORD dwFVF) {return D3D_OK;}

    HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES);

    HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, 
                 ClipVertex *cv2, 
                 ClipVertex *cv3);
    int ClipSingleLine(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line);
    HRESULT ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedLine(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedTriangleList(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedTriangleList(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedLine(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedPoints(D3DFE_PROCESSVERTICES *pv);
    HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *v1, ClipVertex *v2);

    CVertexVM m_VertexVM;
    
};
//-----------------------------------------------------------------------------
// Does projected texture emulation
// Parameters:
//      pOut            - output texture coordinates
//      pIn             - input texture coordinates
//      dwOutTexSize    - size of output texture coordinates in bytes
// Assumes that input texture coordinates have one float more than the output
//
inline void DoTextureProjection(float* pIn, float* pOut, DWORD dwOutTexSize)
{
    UINT n = dwOutTexSize >> 2;     // Number of output floats
    float w = 1.0f/pIn[n];
    for (UINT i=0; i < n; i++)
    {
        pOut[i] = pIn[i] * w;
    }
}
//-----------------------------------------------------------------------------
inline void
DoBlending(float blendFactor, D3DVECTOR* v1, D3DVECTOR* v2, D3DVECTOR* out)
{
    out->x = v1->x + (v2->x - v1->x) * blendFactor;
    out->y = v1->y + (v2->y - v1->y) * blendFactor;
    out->z = v1->z + (v2->z - v1->z) * blendFactor;
}
//-----------------------------------------------------------------------------
// Returns TRUE if we can do one pass transformation-lighting-clipping for 
// non-indexed primitives
//
inline BOOL DoOnePassPrimProcessing(D3DFE_PROCESSVERTICES* pv)
{
    return ((pv->dwDeviceFlags & (D3DDEV_DONOTCLIP | D3DDEV_VERTEXSHADERS)) |
            (pv->dwFlags & (D3DPV_POSITION_TWEENING | D3DPV_NORMAL_TWEENING))) == 0;
}
//-----------------------------------------------------------------------------
// Returns TRUE if we never read from the internal TL buffer
//
inline BOOL NeverReadFromTLBuffer(D3DFE_PROCESSVERTICES* pv)
{
    return (pv->dwDeviceFlags & D3DDEV_DONOTCLIP) | DoOnePassPrimProcessing(pv);
}

#endif // __MSPSGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\sources.inc ===
TARGETPATH=obj
TARGETNAME=d3dtnl

TARGETTYPE=LIBRARY
SYNCHRONIZE_DRAIN = 1

INCLUDES=..;  \
         $(_OBJ_DIR)\$(TARGET_DIRECTORY);  \
         $(DXGROOT)\d3d8\inc; \
         $(DXGROOT)\inc; \
         $(DXGROOT)\d3d8\util

C_DEFINES = $(C_DEFINES)

ASM_DEFINES = -DNT=1 -DMICROSOFT_NT -DSTACK_CALL  -DD3D -DOTHER_SEG=0 -DWANT_DLL

NTTARGETFILE0= \
             $O\pvvid.cpp \
             $O\pvone.cpp \
             $O\loops.cpp

SOURCES= \
    ..\clipper.cpp   \
    ..\dpclip.cpp    \
    ..\vvm.cpp       \
    $O\pvvid.cpp     \
    $O\pvone.cpp     \
    $O\loops.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\pvvid.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pvvid.h
 *  Content:    Common defines for the geometry inner loop
 *
 ***************************************************************************/
#ifndef _PVVID_H
#define _PVVID_H

#include "clipper.h"
// This function should be called every time FVF ID is changed
// All pv flags, input and output FVF id should be set before calling the
// function.
extern void UpdateGeometryLoopData(LPD3DFE_PROCESSVERTICES pv);
// Set stride pointers for non-strided case
extern void SetupStrides(D3DFE_PROCESSVERTICES* pv, UINT stride);
// We use power of 2 because it preserves the mantissa when we multiply
const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//--------------------------------------------------------------------------
#define D3DFE_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
//--------------------------------------------------------------------------
inline void ComputeFogFactor(LPD3DFE_PROCESSVERTICES pv, D3DVALUE dist, DWORD *pOutput)
{
    if (pv->lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < pv->lighting.fog_start)
            D3DFE_SET_ALPHA((*pOutput), 255)
        else
        if (dist >= pv->lighting.fog_end)
            D3DFE_SET_ALPHA((*pOutput), 0)
        else
        {
            D3DVALUE v = (pv->lighting.fog_end - dist) * pv->lighting.fog_factor;
            int f = FTOI(v);
            D3DFE_SET_ALPHA((*pOutput), f)
        }
    }
    else
    {
        D3DVALUE tmp = dist*pv->lighting.fog_density;
        if (pv->lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        tmp = (D3DVALUE)exp(-tmp) * 255.0f;
        int f = FTOI(tmp);
        D3DFE_SET_ALPHA((*pOutput), f)
    }
}
//--------------------------------------------------------------------------
// Input:
//      v        - input vertex in the model space
//      pCoord   - vertex, transformed to the camera space
//      pWeights - pointer to the vertex weights
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//
void ComputeFog(LPD3DFE_PROCESSVERTICES pv, D3DVECTOR &v, D3DVECTOR* pCoord,
                D3DVALUE* pWeights, BYTE* pMatrixIndices);
//---------------------------------------------------------------------
typedef void (*PFN_TEXTURETRANSFORM)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m);
typedef void (*PFN_TEXTURETRANSFORMLOOP)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m, 
                                        DWORD dwCount, DWORD dwInpStride, DWORD dwOutStride);

extern PFN_TEXTURETRANSFORM g_pfnTextureTransform[16];
extern PFN_TEXTURETRANSFORMLOOP g_pfnTextureTransformLoop[16];
//---------------------------------------------------------------------
inline void ComputeReflectionVector(D3DVECTOR *vertexPosition, D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVECTOR vertex = *vertexPosition;
    VecNormalizeFast(vertex);
    D3DVALUE dot = 2*(vertex.x * normal->x + vertex.y * normal->y + vertex.z * normal->z); 
    reflectionVector->x = vertex.x - dot*normal->x;
    reflectionVector->y = vertex.y - dot*normal->y;
    reflectionVector->z = vertex.z - dot*normal->z;
}
//---------------------------------------------------------------------
inline void ComputeReflectionVectorInfiniteViewer(D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVALUE dot = 2*normal->z; 
    reflectionVector->x = - dot*normal->x;
    reflectionVector->y = - dot*normal->y;
    reflectionVector->z = 1.0f - dot*normal->z;
}
#endif // _PVVID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\i386\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

	ifdef INTEL
func	macro	name
	public	name
name:
	endm
	else
func	macro	name
	public	_&name
name:			;lay down both labels so I have one I know will
_&name:			;always be available for asm to call.
	endm
	endif

push_all	macro
	irp	z,<edi,esi,edx,ecx,ebx,eax>
	push	z
	endm
	endm

pop_all		macro
	irp	z,<eax,ebx,ecx,edx,esi,edi>
	pop	z
	endm
	endm

push_m	macro	list
	irp	z,<list>
	push	z
	endm
	endm
	
pop_m	macro	list
	irp	z,<list>
	pop	z
	endm
	endm

byte_eax	equ	al
byte_ebx	equ	bl
byte_ecx	equ	cl
byte_edx	equ	dl

word_eax	equ	ax
word_ebx	equ	bx
word_ecx	equ	cx
word_edx	equ	dx
word_edi	equ	di
word_esi	equ	si
word_ebp	equ	bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 017H
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 018h
	shl	eax, 008h
	idiv	divisor
nodivide:
	endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 0fH
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 010h
	shl	eax, 010h
	idiv	divisor
nodivide:
	endm

ES_PREFIX	macro
    ifndef	NT
	db	26h
    endif
	endm

beginargs macro
	align	4
stack	=	4	;return address
vars	=	0	;no vars yet
args	=	0	;no args yet
	endm

endargs	macro
	sub	esp, vars
	endm

savereg	macro	arg
	push	arg
stack	=	stack + 4
	endm

saveregs macro	arglist
	irp	z,<arglist>
	savereg	z
	endm
	endm

defvar  macro	name
name	=	vars
vars	=	vars + 4
stack	=	stack + 4
	endm

defvars	macro	arglist
	irp	z,<arglist>
	defvar	z
	endm
	endm

defarg	macro	name
name	=	stack + args
args	=	args + 4
	endm

defargs	macro	arglist
	irp	z,<arglist>
	defarg	z
	endm
	endm

regarg	macro	name
	ifdef	STACK_CALL
	defarg	name
	else
	defvar	name
	endif
	endm

regargs	macro	arglist
	irp	z,<arglist>
	regarg	z
	endm
	endm

return	macro
	ifdef	STACK_CALL
	ret
	else
	ret	args
	endif
	endm

    ifdef	BCC		;{

beginproc macro	prefix,GF,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	if DEPTH eq 0
prefix&name	equ	_&prefix&GF&Tr&Te&name
	else
	  if DEPTH eq 8
prefix&name	equ	_&prefix&8&GF&Tr&Te&name
	  else
prefix&name	equ	_&prefix&16&GF&Tr&Te&name
	  endif
	endif
	public	prefix&name
prefix&name proc
	endm			;}

    else			;} ifndef BCC {

beginproc macro	prefix,GF,Z,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	ifdef	STACK_CALL	;{
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Z&Tr&Te&name
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8_&GF&Z&Tr&Te&name
	    else
prefix&name	equ	prefix&16_&GF&Z&Tr&Te&name
	    endif
	endif
	else			;} else {
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Tr&Te&name&_
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8&GF&Tr&Te&name&_
	    else
prefix&name	equ	prefix&16&GF&Tr&Te&name&_
	    endif
	endif
	endif			;}
	public	prefix&name
prefix&name proc
	endm			;}
    endif		;}

    ifdef	BCC	;{
endproc	macro prefix,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	if	DEPTH eq 8
_&prefix&name endp
	else
_&prefix&name endp
	endif
	endm			;}

    else		;} ifndef BCC {

endproc	macro prefix,GF,Z,Te,Tr,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	ifdef	STACK_CALL
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name endp
	    else
	    if	DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
	    else
prefix&16_&GF&Z&Tr&Te&name endp
	    endif
	    endif
	else
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
	    else
	    if	DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
	    else
prefix&16&GF&Tr&Te&name&_ endp
	    endif
	    endif
	endif
	endm			;}

    endif		;}

; ************************************************************************
itoval	macro	reg
	shl	reg,10h
	endm

FDUP	macro
	fld	st(0)
	endm

FDROP	macro
	fstp	st(0)
	endm

FRECIPROCAL	macro
	fld1
	fdivrp	st(1),st
	endm

; MASM 6.11d used in NT has native support for fcomi so this macro can't be
; called fcomi

MACRO_FCOMI macro v
	fcom	v
	fnstsw	ax
	sahf
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\i386\_ftransa.asm ===
GEN_XFRM = 0
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\dll\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
!include ..\makefile.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\i386\_ftransg.asm ===
GEN_XFRM = 1
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\vvm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vvm.cpp
 *  Content:    Virtual Vertex Machine implementation
 *
 *  History:
 *      6/16/00 
 *          Added LOGP, EXPP, NM3
 *          RCP, RSQ, LOG, LOGP, EXP, EXPP take input value from W instead of X
 *      7/11/00 
 *          Removed NM3 macro
 *
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#include <stdio.h>
#include "vvm.h"
#include "d3dexcept.hpp"
#include "float.h"

#if DBG
#include "rtdmon.hpp"
#endif

const DWORD __MAX_CODE_SIZE = 4096;
//-----------------------------------------------------------------------------
HRESULT ComputeShaderCodeSize(
    CONST DWORD* pCode,
    DWORD* pdwCodeOnlySize,
    DWORD* pdwCodeAndCommentSize,
    DWORD* pdwNumConstDefs)
{
    // set this now for error return
    *pdwCodeOnlySize = 0;
    *pdwCodeAndCommentSize = 0;
    DWORD dwNumConstDefs = 0;
    DWORD dwCodeOnlySize = 0;
    DWORD dwCodeAndCommentSize = 0;
    CONST DWORD* pToken = pCode;

    DWORD Version = *pToken++; dwCodeOnlySize++; dwCodeAndCommentSize++;
    if ( (((Version >> 16) != 0xFFFF) && (Version >> 16) != 0xFFFE) ||
         ((Version & 0xFFFF) == 0x0))
    {
        D3D_ERR("invalid version token");
        return D3DERR_INVALIDCALL;
    }

    // very basic parse to find number of instructions
    while ( ((*pToken) != 0x0000FFFF) && (dwCodeOnlySize <= __MAX_CODE_SIZE) )
    {
        if (IsInstructionToken(*pToken))
        {
            DWORD opCode = (*pToken) & D3DSI_OPCODE_MASK;
            if ( opCode == D3DSIO_COMMENT )
            {
                UINT DWordSize = ((*pToken)&D3DSI_COMMENTSIZE_MASK)>>D3DSI_COMMENTSIZE_SHIFT;
                dwCodeAndCommentSize += (1+DWordSize); // instruction token + comment
                pToken += (1+DWordSize);
            }
            else if (opCode == D3DSIO_DEF )
            {
                pToken += 6;
                dwCodeOnlySize += 6;
                dwCodeAndCommentSize += 6;
                dwNumConstDefs++;
            }
            else
            {
                pToken++; dwCodeOnlySize++; dwCodeAndCommentSize++;
            }
        }
        else
        {
            pToken++; dwCodeOnlySize++; dwCodeAndCommentSize++;
        }
    }
    dwCodeOnlySize++; dwCodeAndCommentSize++; // for END token
    if (dwCodeOnlySize > __MAX_CODE_SIZE)
    {
        D3D_ERR("Shader code size is too big. Possibly, missing D3DVS_END()");
        return D3DERR_INVALIDCALL;
    }
    *pdwCodeOnlySize        = 4*dwCodeOnlySize;
    *pdwCodeAndCommentSize  = 4*dwCodeAndCommentSize;
    if( pdwNumConstDefs )
        *pdwNumConstDefs = dwNumConstDefs;

    return S_OK;
}
//-----------------------------------------------------------------------------
float MINUS_INFINITY()
{
    return -FLT_MAX;
}

float PLUS_INFINITY()
{
    return FLT_MAX;
}
//-----------------------------------------------------------------------------
// Returns instruction size, based on the op-code
//
UINT CVertexVM::GetNumSrcOperands(UINT opcode)
{
    // returns number of source operands + opcode + destination
    switch (opcode)
    {
    case D3DSIO_MOV : return 1;
    case D3DSIO_ADD : return 2;
    case D3DSIO_MAD : return 3;
    case D3DSIO_MUL : return 2;
    case D3DSIO_RCP : return 1;
    case D3DSIO_RSQ : return 1;
    case D3DSIO_DP3 : return 2;
    case D3DSIO_DP4 : return 2;
    case D3DSIO_MIN : return 2;
    case D3DSIO_MAX : return 2;
    case D3DSIO_SLT : return 2;
    case D3DSIO_SGE : return 2;
    case D3DSIO_EXP : return 1;
    case D3DSIO_LOG : return 1;
    case D3DSIO_EXPP: return 1;
    case D3DSIO_LOGP: return 1;
    case D3DSIO_LIT : return 1;
    case D3DSIO_DST : return 2;
    case D3DSIO_FRC : return 1;
    case D3DSIO_M4x4: return 2;
    case D3DSIO_M4x3: return 2;
    case D3DSIO_M3x4: return 2;
    case D3DSIO_M3x3: return 2;
    case D3DSIO_M3x2: return 2;
    case D3DSIO_NOP:  return 0;
    default:
        PrintInstCount();
        D3D_THROW_FAIL("Illegal instruction");
    }
    return 0;
}
//-----------------------------------------------------------------------------
// Returns a bit field to say which source register components are used to 
// produce the output components. 
// 4 bits are used per each output component:
//     0-3   output component X
//     4-7   output component Y
//     8-11  output component Z
//     12-15 output component W
// Each of the four bits is used to say if this source component is used to 
// produce the output component:
//     bit 0 - X, bit 1 - Y, bit 2 - Z, bit 3 - W.
//
// SourceIndex - sequential index of the source operand
//
UINT CVertexVM::GetRegisterUsage(UINT opcode, UINT SourceIndex)
{
    switch (opcode)
    {
    case D3DSIO_MOV : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_ADD : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_MAD : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_MUL : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_RCP : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_RSQ : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_DP3 : return 7 | (7 << 4) | (7 << 8) | (7 << 12);
    case D3DSIO_DP4 : return 0xF | (0xF << 4) | (0xF << 8) | (0xF << 12);
    case D3DSIO_MIN : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_MAX : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_SLT : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_SGE : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_EXP : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_LOG : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_EXPP: return 8 | (8 << 4) | (8 << 8);
    case D3DSIO_LOGP: return 8 | (8 << 4) | (8 << 8);
    case D3DSIO_LIT : return (1 << 4) | ((1 | 2 | 8) << 8);
    case D3DSIO_DST : 
        if (SourceIndex == 0)
            return (2 << 4) | (4 << 8);
        else
            return (2 << 4) | (8 << 12);
    case D3DSIO_FRC : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_M4x4: return 0xF | (0xF << 4) | (0xF << 8) | (0xF << 12);
    case D3DSIO_M4x3: return 0xF | (0xF << 4) | (0xF << 8);
    case D3DSIO_M3x4: return 7 | (7 << 4) | (7 << 8) | (7 << 12);
    case D3DSIO_M3x3: return 7 | (7 << 4) | (7 << 8);
    case D3DSIO_M3x2: return 7 | (7 << 4);
    case D3DSIO_NOP:  return 0;
    default:
        PrintInstCount();
        D3D_THROW_FAIL("Illegal instruction");
    }
    return 0;
}
//-----------------------------------------------------------------------------
// Returns instruction size in DWORDs, based on the op-code
//
UINT CVertexVM::GetInstructionLength(DWORD inst)
{
    // returns number of source operands + opcode + destination
    DWORD opcode = D3DSI_GETOPCODE(inst);
    if (opcode == D3DSIO_NOP)
        return 1;
    else if (opcode == D3DSIO_COMMENT)
        return ((inst & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT) + 1;
    else
        return GetNumSrcOperands(opcode) + 2;
}
//-----------------------------------------------------------------------------
// VertexShaderInstDisAsm - Generates human-readable character string for a
// single vertex shader instruction.  String interface is similar to _snprintf.
//-----------------------------------------------------------------------------
static int VertexShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags )
{
    DWORD*  pToken = pShader;

    // stage in local string, then copy
    char pStr[256] = "";
#define _ADDSTR( _Str ) { _snprintf( pStr, 256, "%s" _Str , pStr ); }
#define _ADDSTRP( _Str, _Param ) { _snprintf( pStr, 256, "%s" _Str , pStr, _Param ); }

    DWORD Inst = *pToken++;
    DWORD Opcode = (Inst & D3DSI_OPCODE_MASK);
    switch (Opcode)
    {
    case D3DSIO_NOP: _ADDSTR("NOP"); break;
    case D3DSIO_MOV: _ADDSTR("MOV"); break;
    case D3DSIO_ADD: _ADDSTR("ADD"); break;
    case D3DSIO_MAD: _ADDSTR("MAD"); break;
    case D3DSIO_MUL: _ADDSTR("MUL"); break;
    case D3DSIO_RCP: _ADDSTR("RCP"); break;
    case D3DSIO_RSQ: _ADDSTR("RSQ"); break;
    case D3DSIO_DP3: _ADDSTR("DP3"); break;
    case D3DSIO_DP4: _ADDSTR("DP4"); break;
    case D3DSIO_MIN: _ADDSTR("MIN"); break;
    case D3DSIO_MAX: _ADDSTR("MAX"); break;
    case D3DSIO_SLT: _ADDSTR("SLT"); break;
    case D3DSIO_SGE: _ADDSTR("SGE"); break;
    case D3DSIO_EXP: _ADDSTR("EXP"); break;
    case D3DSIO_LOG: _ADDSTR("LOG"); break;
    case D3DSIO_EXPP:_ADDSTR("EXPP"); break;
    case D3DSIO_LOGP:_ADDSTR("LOGP"); break;
    case D3DSIO_LIT: _ADDSTR("LIT"); break;
    case D3DSIO_DST: _ADDSTR("DST"); break;
    case D3DSIO_COMMENT: _ADDSTR("COMMENT"); break;
    default        : _ADDSTR("???"); break;
    }
    if (*pToken & (1L<<31))
    {
        DWORD DstParam = *pToken++;
        switch (DstParam & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP     : _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ADDR     : _ADDSTR(" Addr"); break;
        case D3DSPR_RASTOUT  : _ADDSTRP(" R%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ATTROUT  : _ADDSTRP(" A%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXCRDOUT: _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        }
        if (*pToken & (1L<<31)) _ADDSTR(" ");
        while (*pToken & (1L<<31))
        {
            DWORD SrcParam = *pToken++;
            switch (SrcParam & D3DSP_REGTYPE_MASK)
            {
            case D3DSPR_TEMP     : _ADDSTRP(" T%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_INPUT    : _ADDSTRP(" I%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_CONST    : _ADDSTRP(" C%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            }
            if (*pToken & (1L<<31)) _ADDSTR(",");
        }
    }
    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}
//-----------------------------------------------------------------------------
#if DBG
typedef struct _VShaderInst
{
    DWORD   m_Tokens[D3DDM_MAX_VSINSTDWORD];
    char    m_String[D3DDM_MAX_VSINSTSTRING];
    DWORD*  m_pComment;
    DWORD   m_cdwComment;
} VShaderInst;
#endif
//-----------------------------------------------------------------------------
class CVShaderCodeI: public CVShaderCode
{
public:
    CVShaderCodeI()
    {
        m_pdwCode = NULL;
        m_InstCount = 0;
#if DBG
        m_pInst = NULL;
#endif
    }
    ~CVShaderCodeI()
    {
        delete m_pdwCode;
#if DBG
        if (m_pInst) delete m_pInst;
#endif
    }
    DWORD*          m_pdwCode;  // Pointer to the original code
    DWORD           m_dwSize;   // Size of the code in DWORDs

    DWORD           m_InstCount;
#if DBG
    VShaderInst*    m_pInst;
#endif

    DWORD  InstCount( void ) { return m_InstCount; }
    DWORD* InstTokens( DWORD Inst );
    char*  InstDisasm( DWORD Inst );
    DWORD* InstComment( DWORD Inst );
    DWORD  InstCommentSize( DWORD Inst );
};
//-----------------------------------------------------------------------------
DWORD* CVShaderCodeI::InstTokens( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_Tokens;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
char* CVShaderCodeI::InstDisasm( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_String;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
DWORD* CVShaderCodeI::InstComment( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_pComment;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
DWORD CVShaderCodeI::InstCommentSize( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_cdwComment;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
// Vertex Virtual Machine object implementation
//
//-----------------------------------------------------------------------------
CVertexVM::CVertexVM()
{
    m_pCurrentShader = NULL;
    m_CurInstIndex = 0;
#if DBG
    for (UINT i=0; i < D3DVS_CONSTREG_MAX_V1_1; i++)
        m_c_initialized[i] = FALSE;
#endif
}
//-----------------------------------------------------------------------------
CVertexVM::~CVertexVM()
{
}
//-----------------------------------------------------------------------------
void CVertexVM::Init(UINT MaxVertexShaderConst)
{
    m_MaxVertexShaderConst = max(MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    m_reg.m_c = new VVM_WORD[m_MaxVertexShaderConst];
    if (m_reg.m_c == NULL)
        D3D_THROW_FAIL("Not enough memory to allocate vertex shader constant array");
}
//-----------------------------------------------------------------------------
// Returns addres of the first vertex of the element
//
VVM_WORD * CVertexVM::GetDataAddr(DWORD dwRegType, DWORD dwElementIndex)
{
    switch (dwRegType)
    {
    case D3DSPR_TEMP      : return &m_reg.m_r[dwElementIndex][0];
    case D3DSPR_INPUT     : return &m_reg.m_v[dwElementIndex][0];
    case D3DSPR_CONST     : return &m_reg.m_c[dwElementIndex];
    case D3DSPR_ADDR      : return &m_reg.m_a[dwElementIndex][0];
    case D3DSPR_RASTOUT   : return &m_reg.m_output[dwElementIndex][0];
    case D3DSPR_ATTROUT   : return &m_reg.m_color[dwElementIndex][0];
    case D3DSPR_TEXCRDOUT : return &m_reg.m_texture[dwElementIndex][0];
    default:
        D3D_THROW(D3DERR_INVALIDCALL, "Invalid register type");
    }
    return NULL;
}
//-----------------------------------------------------------------------------
// Sets data of the first vertex pf the register
//
HRESULT CVertexVM::SetData(DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                           LPVOID pBuffer)
{
    try
    {
        VVM_WORD* p = this->GetDataAddr(dwMemType, dwStart);
        if (dwMemType == D3DSPR_CONST)
        {
#if DBG
            if ((dwStart + dwCount) > m_MaxVertexShaderConst)
            {
                D3D_THROW_FAIL("Attemt to write outside constant register array");
            }
            // We only can set initialized flag for software constant registers
            if (dwStart < D3DVS_CONSTREG_MAX_V1_1)
            {
                BOOL* p = &m_c_initialized[dwStart];
                UINT count = dwCount;
                if ((dwStart + dwCount) >= D3DVS_CONSTREG_MAX_V1_1)
                {
                    count = D3DVS_CONSTREG_MAX_V1_1 - dwStart;
                }
                for (UINT i = 0; i < count; i++)
                {
                    p[i] = TRUE;
                }
            }
#endif
            UINT size = dwCount * sizeof(VVM_WORD);
            memcpy(p, pBuffer, size);
        }
        else
        {
            // Set only the first element of the register batch
            for (UINT i=0; i < dwCount; i++)
            {
                p[i * VVMVERTEXBATCH] = ((VVM_WORD*)pBuffer)[i];
            }
        }
    }
    D3D_CATCH;

    return D3D_OK;
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::GetData(DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                           LPVOID pBuffer)
{
    try
    {
        VVM_WORD* p = this->GetDataAddr(dwMemType, dwStart);
        if (dwMemType == D3DSPR_CONST)
        {
            memcpy(pBuffer, p, dwCount * sizeof(VVM_WORD));
        }
        else
        {
            // Set only the first element of the register batch
            for (UINT i=0; i < dwCount; i++)
            {
                ((VVM_WORD*)pBuffer)[i] = p[i * VVMVERTEXBATCH];
            }
        }
    }
    D3D_CATCH;

    return D3D_OK;
}
//-----------------------------------------------------------------------------
// - allocates memory for the shader
// - validates shader code
// - computes output FVF and vertex elements offsets
//
void CVertexVM::ValidateShader(CVShaderCodeI* shader, DWORD* orgShader)
{
    // shader will be already stripped of comments upon reaching here if stripping
    // is necessary, so always use CodeAndComment size
    DWORD dwCodeOnlySize;
    DWORD dwCodeAndCommentSize;
    HRESULT hr = ComputeShaderCodeSize(orgShader, &dwCodeOnlySize, 
                                        &dwCodeAndCommentSize, NULL);
    if (hr != S_OK)
        D3D_THROW(hr, "");
    // Initialize shader header and allocate memory for the shader code

    shader->m_dwSize = dwCodeAndCommentSize >> 2; // Size in DWORDs
    shader->m_pdwCode = new DWORD[shader->m_dwSize];
    if (shader->m_pdwCode == NULL)
    {
        D3D_THROW_FAIL("Cannot allocate memory for shader code");
    }
    memcpy(shader->m_pdwCode, orgShader, dwCodeAndCommentSize);

    // Based on the what output registers are modified, we compute the
    // corresponding FVF id. The id will be used for memory allocation
    // of the output buffer and will be passed to the rasterizer
    DWORD   dwOutFVF = 0;
    DWORD nTexCoord = 0;        // Number of output texture coordinates
    // For each texture register stores the combined write mask.
    // Used to find how many floats are written to each texture coordinates
    DWORD TextureWritten[8];
    memset(TextureWritten, 0, sizeof(TextureWritten));

    m_pdwCurToken = shader->m_pdwCode;
    DWORD* pEnd = shader->m_pdwCode + shader->m_dwSize;

    shader->m_dwOutRegs = 0;
    shader->m_InstCount = 0;
    m_CurInstIndex = 0;

    if ((*m_pdwCurToken != D3DVS_VERSION(1, 1)) &&
        (*m_pdwCurToken != D3DVS_VERSION(1, 0)) )
    {
        D3D_THROW_FAIL("Invalid vertex shader code version");
    }
    m_pdwCurToken++;
    while (m_pdwCurToken < pEnd && *m_pdwCurToken != D3DVS_END())
    {
        DWORD * pdwNextToken = m_pdwCurToken;
        DWORD dwInst = *m_pdwCurToken;
        if (!IsInstructionToken(dwInst))
        {
            PrintInstCount();
            D3D_THROW_FAIL("Intruction token has 31 bit set");
        }
        DWORD dwOpCode = D3DSI_GETOPCODE(dwInst);
        m_pdwCurToken++;

        switch (dwOpCode)
        {
        case D3DSIO_COMMENT:
        case D3DSIO_NOP  : ; break;
        case D3DSIO_MOV  :
        case D3DSIO_ADD  :
        case D3DSIO_MAD  :
        case D3DSIO_MUL  :
        case D3DSIO_RCP  :
        case D3DSIO_RSQ  :
        case D3DSIO_DP3  :
        case D3DSIO_DP4  :
        case D3DSIO_MIN  :
        case D3DSIO_MAX  :
        case D3DSIO_SLT  :
        case D3DSIO_SGE  :
        case D3DSIO_EXP  :
        case D3DSIO_LOG  :
        case D3DSIO_EXPP :
        case D3DSIO_LOGP :
        case D3DSIO_LIT  :
        case D3DSIO_DST  :
        case D3DSIO_FRC  :
        case D3DSIO_M4x4 :
        case D3DSIO_M4x3 :
        case D3DSIO_M3x4 :
        case D3DSIO_M3x3 :
        case D3DSIO_M3x2 :
            {
                // Find out if output register are modified by the command and
                // update the output FVF
                DWORD dwOffset;
                EvalDestination();
                VVM_WORD*   m_pOutRegister = NULL;
                if ((m_pDest - m_dwOffset * VVMVERTEXBATCH) != m_reg.m_r[0])
                {
                    dwOffset = m_dwOffset;
                    m_pOutRegister = m_pDest - m_dwOffset * VVMVERTEXBATCH;

                    if (m_pOutRegister == m_reg.m_output[0])
                    {
                        if (dwOffset == D3DSRO_POSITION)
                        {
                            dwOutFVF |= D3DFVF_XYZRHW;
                            shader->m_dwOutRegs |= CPSGPShader_POSITION;
                        }
                        else
                        if (dwOffset == D3DSRO_FOG)
                        {
                            dwOutFVF |= D3DFVF_FOG;
                            shader->m_dwOutRegs |= CPSGPShader_FOG;
                        }
                        else
                        if (dwOffset == D3DSRO_POINT_SIZE)
                        {
                            dwOutFVF |= D3DFVF_PSIZE;
                            shader->m_dwOutRegs |= CPSGPShader_PSIZE;
                        }
                    }
                    else
                    if (m_pOutRegister == m_reg.m_color[0])
                        if (dwOffset == 0)
                        {
                            dwOutFVF |= D3DFVF_DIFFUSE;
                            shader->m_dwOutRegs |= CPSGPShader_DIFFUSE;
                        }
                        else
                        {
                            dwOutFVF |= D3DFVF_SPECULAR;
                            shader->m_dwOutRegs |= CPSGPShader_SPECULAR;
                        }
                    else
                    if (m_pOutRegister == m_reg.m_texture[0])
                    {
                        if (TextureWritten[dwOffset] == 0)
                        {
                            nTexCoord++;
                        }
                        TextureWritten[dwOffset] |= m_WriteMask;
                    }
                    else
                    if (m_pOutRegister == m_reg.m_a[0])
                    {
                    }
                    else
                    {
                        PrintInstCount();
                        D3D_THROW_FAIL("Invalid output register offset");
                    }
                }
            }
            break;
        default:
            {
                PrintInstCount();
                D3D_THROW_FAIL("Invalid shader opcode");
            }
        }
        m_pdwCurToken = pdwNextToken + GetInstructionLength(dwInst);
        shader->m_InstCount++;
        if (dwOpCode != D3DSIO_COMMENT)
        {
            m_CurInstIndex++;
            if (m_CurInstIndex > D3DVS_MAXINSTRUCTIONCOUNT_V1_1)
            {
                D3D_THROW_FAIL("Too many instructions in the shader");
            }
        }
    }


#ifdef DBG
    // compute per-instruction stuff for shader
    if (shader->m_InstCount)
    {
        shader->m_pInst = new VShaderInst[shader->m_InstCount];
        if (shader->m_pInst == NULL)
        {
            D3D_THROW_FAIL("Cannot allocate memory for shader instructions");
        }
        memset( shader->m_pInst, 0, sizeof(VShaderInst)*shader->m_InstCount );

        DWORD dwCurInst = 0;
        // Remove version
        m_pdwCurToken = shader->m_pdwCode + 1;
        pEnd = shader->m_pdwCode + shader->m_dwSize;
        while( m_pdwCurToken < pEnd && *m_pdwCurToken != D3DVS_END())
        {
            UINT ilength = GetInstructionLength(*m_pdwCurToken);
            DWORD dwOpCode = D3DSI_GETOPCODE(*m_pdwCurToken);
            if (dwOpCode == D3DSIO_COMMENT)
            {
                shader->m_pInst[dwCurInst].m_Tokens[0] = *m_pdwCurToken;
                shader->m_pInst[dwCurInst].m_pComment = (m_pdwCurToken+1);
                shader->m_pInst[dwCurInst].m_cdwComment = ilength - 1;
            }
            else
            {
                memcpy( shader->m_pInst[dwCurInst].m_Tokens, m_pdwCurToken,
                    4*ilength );
                VertexShaderInstDisAsm( shader->m_pInst[dwCurInst].m_String,
                    D3DDM_MAX_VSINSTSTRING, shader->m_pInst[dwCurInst].m_Tokens, 0x0 );
            }
            m_pdwCurToken += ilength;
            dwCurInst++;
        }

    }
#endif

    dwOutFVF |= nTexCoord << D3DFVF_TEXCOUNT_SHIFT;

    // Compute output vertex offsets and size

    shader->m_dwOutVerSize = 4 * sizeof(float); // X, Y, Z, RHW
    shader->m_nOutTexCoord = nTexCoord;
    DWORD dwOffset = 4 * sizeof(float); // Current offset in the output vertex

    if ((dwOutFVF & D3DFVF_XYZRHW) == 0)
    {
        D3D_THROW_FAIL("Position is not written by shader");
    }

    shader->m_dwPointSizeOffset = dwOffset;
    if (dwOutFVF & D3DFVF_PSIZE)
    {
        dwOffset += 4;
        shader->m_dwOutVerSize += 4;
    }
     shader->m_dwDiffuseOffset = dwOffset;
    if (dwOutFVF & D3DFVF_DIFFUSE)
    {
        shader->m_dwOutVerSize += 4;
        dwOffset += 4;
    }
    shader->m_dwSpecularOffset = dwOffset;
    if (dwOutFVF & D3DFVF_SPECULAR)
    {
        dwOffset += 4;
        shader->m_dwOutVerSize += 4;
    }
    shader->m_dwFogOffset = dwOffset;
    if (dwOutFVF & D3DFVF_FOG)
    {
        dwOffset += 4;
        shader->m_dwOutVerSize += 4;
    }
    // Initialize texture coordinates
    shader->m_dwTextureOffset = dwOffset;
    if (nTexCoord)
    {
        for (DWORD i = 0; i < nTexCoord; i++)
        {
            DWORD n;    // Size of texture coordinates
            if (TextureWritten[i] == 0)
            {
                D3D_THROW_FAIL("Texture coordinates are not continuous");
            }
            switch (TextureWritten[i])
            {
            case D3DSP_WRITEMASK_ALL:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE4(i);
                n = 4 * sizeof(float);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE3(i);
                n = 3 * sizeof(float);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE2(i);
                n = 2 * sizeof(float);
                break;
            case D3DSP_WRITEMASK_0:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE1(i);
                n = 1 * sizeof(float);
                break;
            default:
                D3D_THROW_FAIL("Invalid write mask for texture register");
            }
            shader->m_dwOutVerSize += n;
            shader->m_dwOutTexCoordSize[i] = n;
            dwOffset += n;
        }
    }
    shader->m_dwOutFVF = dwOutFVF;
}
//-----------------------------------------------------------------------------
CVShaderCode* CVertexVM::CreateShader(CVElement* pElements, DWORD dwNumElements,
                                      DWORD* pCode)
{
    CVShaderCodeI* pShaderCode = NULL;
    try
    {
        pShaderCode = new CVShaderCodeI();
        if (pShaderCode == NULL)
        {
            D3D_THROW(E_OUTOFMEMORY, "Cannot allocate memory");
        }

        ValidateShader(pShaderCode, pCode);
        return pShaderCode;
    }
    catch (HRESULT e)
    {
        delete pShaderCode;
        D3D_ERR("Error in shader code creation");
        return NULL;
    }
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::SetActiveShader(CVShaderCode* pCode)
{
    m_pCurrentShader = (CVShaderCodeI*)pCode;
    return D3D_OK;
}
//-----------------------------------------------------------------------------
// - parses destination token
// - computes m_pDest, m_WrideMask, m_dwOffset for the destination
// - current token pointer is andvanced to the next token
//
void CVertexVM::EvalDestination()
{
    DWORD dwCurToken = *m_pdwCurToken;
    DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    m_dwOffset = D3DSI_GETREGNUM(dwCurToken);
    m_WriteMask = D3DSI_GETWRITEMASK(dwCurToken);
    switch (dwRegType)
    {
    case D3DSPR_TEMP:
        m_pDest = m_reg.m_r[0];
        break;
    case D3DSPR_RASTOUT:
        m_pDest = m_reg.m_output[0];
        break;
    case D3DSPR_ATTROUT:
        m_pDest = m_reg.m_color[0];
        break;
    case D3DSPR_TEXCRDOUT:
        m_pDest = m_reg.m_texture[0];
        break;
    case D3DSPR_ADDR:
        m_pDest = m_reg.m_a[0];
        break;
    default:
        PrintInstCount();
        D3D_THROW_FAIL("Invalid register for destination");
    }
    m_pdwCurToken++;
    m_pDest += m_dwOffset * VVMVERTEXBATCH;
}
//---------------------------------------------------------------------
void CVertexVM::PrintInstCount()
{
    D3D_ERR("Error in instruction number: %d", m_CurInstIndex + 1);
}
//---------------------------------------------------------------------
// Computes m_Source[index] and advances m_pdwCurToken
//
void CVertexVM::EvalSource(DWORD index)
{
    const DWORD dwCurToken = *m_pdwCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    const DWORD dwOffset = D3DSI_GETREGNUM(dwCurToken);
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);
    VVM_WORD *src;
    VVM_WORD *outsrc = m_Source[index];

    if (dwRegType == D3DSPR_CONST)
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE(dwCurToken);
        int offset = (int)dwOffset;
        if (am == D3DVS_ADDRMODE_RELATIVE)
        {
            for (UINT i=0; i < m_count; i++)
            {
                int relOffset = *(int*)&m_reg.m_a[0][i].x;
                offset = (int)dwOffset + relOffset;
#if DBG
                if (offset < 0 || offset >= D3DVS_CONSTREG_MAX_V1_1)
                {
                    PrintInstCount();
                    D3D_THROW_FAIL("Constant register index is out of bounds");
                }
                if (!m_c_initialized[offset])
                {
                    PrintInstCount();
                    D3D_ERR("Attempt to read from uninitialized constant register %d", offset);
                    D3D_THROW_FAIL("");
                }
#endif
                src = &m_reg.m_c[offset];
                if (swizzle == D3DVS_NOSWIZZLE)
                    *outsrc = *src;
                else
                {
                    // Where to take X
                    const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
                    // Where to take Y
                    const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
                    // Where to take Z
                    const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
                    // Where to take W
                    const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
                    outsrc->x = ((float*)src)[dwSrcX];
                    outsrc->y = ((float*)src)[dwSrcY];
                    outsrc->z = ((float*)src)[dwSrcZ];
                    outsrc->w = ((float*)src)[dwSrcW];
                }
                outsrc++;
            }
        }
        else
        {
#if DBG
            if (!m_c_initialized[offset])
            {
                PrintInstCount();
                D3D_ERR("Attempt to read from uninitialized constant register %d", offset);
                D3D_THROW_FAIL("");
            }
#endif
            src = &m_reg.m_c[offset];
            if (swizzle == D3DVS_NOSWIZZLE)
            {
                for (UINT i=0; i < m_count; i++)
                {
                    outsrc[i] = *src;
                }
            }
            else
            {
                // Where to take X
                const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
                // Where to take Y
                const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
                // Where to take Z
                const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
                // Where to take W
                const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
                VVM_WORD v;
                v.x = ((float*)src)[dwSrcX];
                v.y = ((float*)src)[dwSrcY];
                v.z = ((float*)src)[dwSrcZ];
                v.w = ((float*)src)[dwSrcW];
                for (UINT i=0; i < m_count; i++)
                {
                    outsrc[i] = v;
                }
            }
        }
    }
    else
    {
        src = this->GetDataAddr(dwRegType, dwOffset);

        if (swizzle == D3DVS_NOSWIZZLE)
            memcpy(outsrc, src, m_count * sizeof(VVM_WORD));
        else
        {
            // Where to take X
            const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
            // Where to take Y
            const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
            // Where to take Z
            const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
            // Where to take W
            const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
            for (UINT i=0; i < m_count; i++)
            {
                outsrc->x = ((float*)src)[dwSrcX];
                outsrc->y = ((float*)src)[dwSrcY];
                outsrc->z = ((float*)src)[dwSrcZ];
                outsrc->w = ((float*)src)[dwSrcW];
                outsrc++;
                src++;
            }
        }
    }

    if (D3DVS_GETSRCMODIFIER(dwCurToken) == D3DSPSM_NEG)
    {
        VVM_WORD *outsrc = m_Source[index];
        for (UINT i=0; i < m_count; i++)
        {
            outsrc->x = -outsrc->x;
            outsrc->y = -outsrc->y;
            outsrc->z = -outsrc->z;
            outsrc->w = -outsrc->w;
            outsrc++;
        }
    }
    m_pdwCurToken++;
}
//---------------------------------------------------------------------
// Computes source operands and advances m_pdwCurToken
//
// Parameters:
//      index    - index of the first source operand
//      count    - number of source operands
//
void CVertexVM::EvalSource(DWORD index, DWORD count)
{
    const DWORD dwCurToken = *m_pdwCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    const DWORD dwOffset = D3DSI_GETREGNUM(dwCurToken);
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);

    VVM_WORD *src;
    VVM_WORD *outsrc = m_Source[index];

    if (dwRegType == D3DSPR_CONST)
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE(dwCurToken);
        int offset = (int)dwOffset;
        if (am == D3DVS_ADDRMODE_RELATIVE)
        {
            for (UINT j=0; j < count; j++)
            {
                VVM_WORD *outsrc = m_Source[index + j];
                for (UINT i=0; i < m_count; i++)
                {
                    int relOffset = *(int*)&m_reg.m_a[0][i].x;
                    offset = (int)dwOffset + relOffset;
#if DBG
                    if (offset < 0 || offset >= D3DVS_CONSTREG_MAX_V1_1)
                    {
                        PrintInstCount();
                        D3D_THROW_FAIL("Constant register index is out of bounds");
                    }
                    if (!m_c_initialized[offset])
                    {
                        PrintInstCount();
                        D3D_ERR("Attempt to read from uninitialized constant register %d", offset);
                        D3D_THROW_FAIL("");
                    }
#endif // DBG
                    src = &m_reg.m_c[offset] + j;
                    *outsrc = *src;
                    outsrc++;
                }
            }
        }
        else
        {
#if DBG
            for (UINT i = 0; i < count; i++)
            {
                if (!m_c_initialized[offset + i])
                {
                    PrintInstCount();
                    D3D_ERR("Attempt to read from uninitialized constant register %d", i);
                    D3D_THROW_FAIL("");
                }
            }
#endif
            src = &m_reg.m_c[offset];
            for (UINT j=0; j < count; j++)
            {
                for (UINT i=0; i < m_count; i++)
                {
                    outsrc[i] = *src;
                }
                src++;
                outsrc += VVMVERTEXBATCH;
            }
        }
    }
    else
    {
        src = this->GetDataAddr(dwRegType, dwOffset);
        UINT size = m_count * sizeof(VVM_WORD);
        for (UINT i=0; i < count; i++)
        {
            memcpy(outsrc, src, size);
            outsrc += VVMVERTEXBATCH;
            src += VVMVERTEXBATCH;
        }
    }
    m_pdwCurToken++;
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMov()
{
    EvalDestination();
    EvalSource(0);

    if (m_pDest == m_reg.m_a[0])
    {
        for (UINT i=0; i < m_count; i++)
        {
            float p = (float)floor(m_Source[0][i].x);
            *(int*)&m_pDest[i].x = FTOI(p);
        }
    }
    else
    {
        if (m_WriteMask == D3DSP_WRITEMASK_ALL)
        {
            memcpy(m_pDest,  m_Source[0], m_BatchSize);
        }
        else
        {
            for (UINT i=0; i < m_count; i++)
            {
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = m_Source[0][i].x;
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y = m_Source[0][i].y;
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = m_Source[0][i].z;
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = m_Source[0][i].w;
            }
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstAdd()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x + m_Source[1][i].x;
            m_pDest[i].y = m_Source[0][i].y + m_Source[1][i].y;
            m_pDest[i].z = m_Source[0][i].z + m_Source[1][i].z;
            m_pDest[i].w = m_Source[0][i].w + m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x + m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y + m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z + m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w + m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMad()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);
    EvalSource(2);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x + m_Source[2][i].x;
            m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y + m_Source[2][i].y;
            m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z + m_Source[2][i].z;
            m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w + m_Source[2][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x + m_Source[2][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y + m_Source[2][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z + m_Source[2][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w + m_Source[2][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMul()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x;
            m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z;
            m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstDP3()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =
            m_pDest[i].y =
            m_pDest[i].z =
            m_pDest[i].w = m_Source[0][i].x * m_Source[1][i].x +
                           m_Source[0][i].y * m_Source[1][i].y +
                           m_Source[0][i].z * m_Source[1][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].x * m_Source[1][i].x +
                      m_Source[0][i].y * m_Source[1][i].y +
                      m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstDP4()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =
            m_pDest[i].y =
            m_pDest[i].z =
            m_pDest[i].w = m_Source[0][i].x * m_Source[1][i].x +
                           m_Source[0][i].y * m_Source[1][i].y +
                           m_Source[0][i].z * m_Source[1][i].z +
                           m_Source[0][i].w * m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].x * m_Source[1][i].x +
                      m_Source[0][i].y * m_Source[1][i].y +
                      m_Source[0][i].z * m_Source[1][i].z +
                      m_Source[0][i].w * m_Source[1][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstRcp()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].w;
            if (v == 1.0f)
            {
                // Must be exactly 1.0
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = 1.0f;
            }
            else
            if (v == 0)
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = PLUS_INFINITY();
            }
            else
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = 1.0f/v;
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].w;
            if (FLOAT_EQZ(v))
                v = PLUS_INFINITY();
            else
            if (v != 1.0f)
                v = 1.0f/v;

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstRsq()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v == 1.0f)
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = 1.0f;
            }
            else
            if (v == 0)
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = PLUS_INFINITY();
            }
            else
            {
                v = (float)(1.0f / sqrt(v));
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = v;
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (FLOAT_EQZ(v))
                v = PLUS_INFINITY();
            else
            if (FLOAT_CMP_PONE(v, !=))
                v = (float)(1.0f / sqrt(v));

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstSlt()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = (m_Source[0][i].x < m_Source[1][i].x) ? 1.0f : 0.0f;
            m_pDest[i].y = (m_Source[0][i].y < m_Source[1][i].y) ? 1.0f : 0.0f;
            m_pDest[i].z = (m_Source[0][i].z < m_Source[1][i].z) ? 1.0f : 0.0f;
            m_pDest[i].w = (m_Source[0][i].w < m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = (m_Source[0][i].x < m_Source[1][i].x) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = (m_Source[0][i].y < m_Source[1][i].y) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = (m_Source[0][i].z < m_Source[1][i].z) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = (m_Source[0][i].w < m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstSge()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = (m_Source[0][i].x >= m_Source[1][i].x) ? 1.0f : 0.0f;
            m_pDest[i].y = (m_Source[0][i].y >= m_Source[1][i].y) ? 1.0f : 0.0f;
            m_pDest[i].z = (m_Source[0][i].z >= m_Source[1][i].z) ? 1.0f : 0.0f;
            m_pDest[i].w = (m_Source[0][i].w >= m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = (m_Source[0][i].x >= m_Source[1][i].x) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = (m_Source[0][i].y >= m_Source[1][i].y) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = (m_Source[0][i].z >= m_Source[1][i].z) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = (m_Source[0][i].w >= m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMin()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x=(m_Source[0][i].x < m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            m_pDest[i].y=(m_Source[0][i].y < m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            m_pDest[i].z=(m_Source[0][i].z < m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            m_pDest[i].w=(m_Source[0][i].w < m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x=(m_Source[0][i].x < m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y=(m_Source[0][i].y < m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z=(m_Source[0][i].z < m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w=(m_Source[0][i].w < m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMax()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x=(m_Source[0][i].x >= m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            m_pDest[i].y=(m_Source[0][i].y >= m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            m_pDest[i].z=(m_Source[0][i].z >= m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            m_pDest[i].w=(m_Source[0][i].w >= m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x=(m_Source[0][i].x >= m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y=(m_Source[0][i].y >= m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z=(m_Source[0][i].z >= m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w=(m_Source[0][i].w >= m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
// Approximation 2**x
//
float ExpApprox(float x)
{
    float tmp = (float)pow(2, x);
    // Artificially reduce precision
    DWORD tmpd = *(DWORD*)&tmp & 0xFFFFFF00;
    return *(float*)&tmpd;
}
//-----------------------------------------------------------------------------
// Approximation Log2(x)
//
const float LOG2 = (float)(1.0f/log(2));

float LogApprox(float x)
{
    float tmp = (float)(log(x) * LOG2);
    // Artificially reduce precision
    DWORD tmpd = *(DWORD*)&tmp & 0xFFFFFF00;
    return *(float*)&tmpd;
}
//-----------------------------------------------------------------------------
// Full precision EXP
//
void CVertexVM::InstExp()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = (float)pow(2, m_Source[0][i].w);
            m_pDest[i].x = v;
            m_pDest[i].y = v;
            m_pDest[i].z = v;
            m_pDest[i].w = v;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = (float)pow(2, m_Source[0][i].w);

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
// Low precision EXP
//
void CVertexVM::InstExpP()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float w = m_Source[0][i].w; // Input value
            float v = (float)floor(w);

            m_pDest[i].x = (float)pow(2, v);
            m_pDest[i].y = w - v;
            m_pDest[i].z = ExpApprox(w);
            m_pDest[i].w = 1;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float w = m_Source[0][i].w; // Input value
            float v = (float)floor(w);

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = (float)pow(2, v);
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = w - v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = ExpApprox(w);
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = 1;
        }
    }
}
//-----------------------------------------------------------------------------
// Full precision LOG
//
void CVertexVM::InstLog()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                m_pDest[i].x = 
                m_pDest[i].y = 
                m_pDest[i].z = 
                m_pDest[i].w = (float)(log(v) * LOG2);
            }
            else
            {
                m_pDest[i].x = 
                m_pDest[i].y = 
                m_pDest[i].z = 
                m_pDest[i].w = MINUS_INFINITY();
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                v = (float)(log(v) * LOG2);
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = v;
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y =  v;
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = v;
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = v;
            }
            else
            {
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = MINUS_INFINITY();
            }
        }
    }
}
//-----------------------------------------------------------------------------
// Low precision LOG
//
void CVertexVM::InstLogP()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                // -128.0 <= exponent < 127.0
                int p = (int)(*(DWORD*)&v >> 23) - 127;
                m_pDest[i].x = (float)p;                  
                // 1.0 <= mantissa < 2.0
                p = (*(DWORD*)&v & 0x7FFFFF) | 0x3F800000;
                m_pDest[i].y =  *(float*)&p;              
                m_pDest[i].z = LogApprox(v);
                m_pDest[i].w = 1.0f;
            }
            else
            {
                m_pDest[i].x = MINUS_INFINITY();
                m_pDest[i].y = 1.0f;
                m_pDest[i].z = MINUS_INFINITY();
                m_pDest[i].w = 1.0f;
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                // -128.0 <= exponent < 127.0
                int p = (int)(*(DWORD*)&v >> 23) - 127;
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = (float)p;                  
                // 1.0 <= mantissa < 2.0
                p = (*(DWORD*)&v & 0x7FFFFF) | 0x3F800000;
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y =  *(float*)&p;              
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = LogApprox(v);
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = 1.0f;
            }
            else
            {
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y = 1.0f;
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = 1.0f;
            }
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstFrc()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x - (float)floor(m_Source[0][i].x);
            m_pDest[i].y = m_Source[0][i].y - (float)floor(m_Source[0][i].y);
            m_pDest[i].z = m_Source[0][i].z - (float)floor(m_Source[0][i].z);
            m_pDest[i].w = m_Source[0][i].w - (float)floor(m_Source[0][i].w);
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x - (float)floor(m_Source[0][i].x);
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y - (float)floor(m_Source[0][i].y);
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z - (float)floor(m_Source[0][i].z);
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w - (float)floor(m_Source[0][i].w);
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstLit()
{
    EvalDestination();
    EvalSource(0);

    for (UINT i=0; i < m_count; i++)
    {
        if (m_WriteMask & D3DSP_WRITEMASK_0)
           m_pDest[i].x = 1;
        if (m_WriteMask & D3DSP_WRITEMASK_1)
            m_pDest[i].y = 0;
        if (m_WriteMask & D3DSP_WRITEMASK_2)
            m_pDest[i].z = 0;
        if (m_WriteMask & D3DSP_WRITEMASK_3)
            m_pDest[i].w = 1;
        float power = m_Source[0][i].w;
        const float MAXPOWER = 127.9961f;
        if (power < -MAXPOWER)
            power = -MAXPOWER;          // Fits into 8.8 fixed point format
        else
        if (power > MAXPOWER)
            power = MAXPOWER;          // Fits into 8.8 fixed point format

        if (m_Source[0][i].x > 0)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                if (m_Source[0][i].y > 0)
                {
                    // Allowed approximation is EXP(power * LOG(m_Source[0].y))
                    m_pDest[i].z = (float)(pow(m_Source[0][i].y, power));
                }
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstDst()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = 1;
            m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            m_pDest[i].z = m_Source[0][i].z;
            m_pDest[i].w = m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = 1;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM4x4()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 4);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z +
                            m_Source[0][i].w * m_Source[1][i].w;
            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z +
                            m_Source[0][i].w * m_Source[2][i].w;
            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z +
                            m_Source[0][i].w * m_Source[3][i].w;
            m_pDest[i].w =  m_Source[0][i].x * m_Source[4][i].x +
                            m_Source[0][i].y * m_Source[4][i].y +
                            m_Source[0][i].z * m_Source[4][i].z +
                            m_Source[0][i].w * m_Source[4][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z +
                                m_Source[0][i].w * m_Source[1][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z +
                                m_Source[0][i].w * m_Source[2][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z +
                                m_Source[0][i].w * m_Source[3][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].x * m_Source[4][i].x +
                                m_Source[0][i].y * m_Source[4][i].y +
                                m_Source[0][i].z * m_Source[4][i].z +
                                m_Source[0][i].w * m_Source[4][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM4x3()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 3);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z +
                            m_Source[0][i].w * m_Source[1][i].w;

            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z +
                            m_Source[0][i].w * m_Source[2][i].w;

            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z +
                            m_Source[0][i].w * m_Source[3][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z +
                                m_Source[0][i].w * m_Source[1][i].w;

            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z +
                                m_Source[0][i].w * m_Source[2][i].w;

            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z +
                                m_Source[0][i].w * m_Source[3][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM3x4()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 4);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z;

            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z;

            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z;

            m_pDest[i].w =  m_Source[0][i].x * m_Source[4][i].x +
                            m_Source[0][i].y * m_Source[4][i].y +
                            m_Source[0][i].z * m_Source[4][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z;

            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z;

            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z;

            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w =  m_Source[0][i].x * m_Source[4][i].x +
                                m_Source[0][i].y * m_Source[4][i].y +
                                m_Source[0][i].z * m_Source[4][i].z;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM3x3()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 3);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z;
            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z;
            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM3x2()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 2);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z;
            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z;
        }
    }
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::ExecuteShader(LPD3DFE_PROCESSVERTICES pv, UINT vertexCount)
{
    if (m_pCurrentShader == NULL)
    {
        D3D_ERR("No current shader set in the Virtual Shader Machine");
        return D3DERR_INVALIDCALL;
    }
    try
    {
        m_count = vertexCount;
        m_BatchSize = vertexCount * sizeof(VVM_WORD);
        // Skip version
        m_pdwCurToken = m_pCurrentShader->m_pdwCode + 1;

        DWORD* pEnd = m_pCurrentShader->m_pdwCode + m_pCurrentShader->m_dwSize;
        pEnd -= 1;
        m_CurInstIndex = 0;

        // Initialize position register
        for (UINT i=0; i < m_count; i++)
        {
            m_reg.m_output[0][i].x = 0;
            m_reg.m_output[0][i].y = 0;
            m_reg.m_output[0][i].z = 0;
            m_reg.m_output[0][i].w = 1;
        }
        while (m_pdwCurToken < pEnd)
        {
            DWORD dwInst = *m_pdwCurToken;
            DWORD dwOpCode = D3DSI_GETOPCODE(dwInst);
            m_pdwCurToken++;
            switch (dwOpCode)
            {
            case D3DSIO_COMMENT: m_pdwCurToken += ((GetInstructionLength(dwInst))-1); break;
            case D3DSIO_NOP  : ; break;
            case D3DSIO_MOV  : InstMov(); break;
            case D3DSIO_ADD  : InstAdd(); break;
            case D3DSIO_MAD  : InstMad(); break;
            case D3DSIO_MUL  : InstMul(); break;
            case D3DSIO_RCP  : InstRcp(); break;
            case D3DSIO_RSQ  : InstRsq(); break;
            case D3DSIO_DP3  : InstDP3(); break;
            case D3DSIO_DP4  : InstDP4(); break;
            case D3DSIO_MIN  : InstMin(); break;
            case D3DSIO_MAX  : InstMax(); break;
            case D3DSIO_SLT  : InstSlt(); break;
            case D3DSIO_SGE  : InstSge(); break;
            case D3DSIO_EXP  : InstExp(); break;
            case D3DSIO_LOG  : InstLog(); break;
            case D3DSIO_EXPP : InstExpP(); break;
            case D3DSIO_LOGP : InstLogP(); break;
            case D3DSIO_LIT  : InstLit(); break;
            case D3DSIO_DST  : InstDst(); break;
            case D3DSIO_FRC  : InstFrc(); break;
            case D3DSIO_M4x4 : InstM4x4(); break;
            case D3DSIO_M4x3 : InstM4x3(); break;
            case D3DSIO_M3x4 : InstM3x4(); break;
            case D3DSIO_M3x3 : InstM3x3(); break;
            case D3DSIO_M3x2 : InstM3x2(); break;
            default:
                {
                    PrintInstCount();
                    D3D_THROW_FAIL("Invalid shader opcode");
                }
            }
#ifndef PSGPDLL
#if DBG
            if (pv->pDbgMon) pv->pDbgMon->NextEvent(D3DDM_EVENT_VERTEXSHADERINST);
#endif
#endif // PSGPDLL
            if (dwOpCode != D3DSIO_COMMENT)
                m_CurInstIndex++;
        }
        m_CurInstIndex = 0;
    }
    D3D_CATCH;

    return D3D_OK;
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::GetDataPointer(DWORD dwMemType, VVM_WORD ** pData)
{
    try
    {
        *pData = this->GetDataAddr(dwMemType, 0);
    }
    catch (HRESULT e)
    {
        *pData = NULL;
        return D3DERR_INVALIDCALL;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
VVM_REGISTERS* CVertexVM::GetRegisters()
{
    return &m_reg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\i386\ftrans.asm ===
; $Id: ftrans.asm,v 1.3 1995/10/20 15:14:41 james Exp $
;
; Up to 165K from 143K
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994, 1995
; Version 1.0
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
; NOTE: Need to set integer pop precision...
;
OPTION NOM510
.386p
;.radix  16
                NAME    transform

                include macros.asm
                include offsets.asm

procstart	macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		proc
	    else
&prefix&xfrm_class		proc
	    endif
	    else
&prefix&xfrm_class&_		proc
	    endif
		endm

procend		macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		endp
	    else
&prefix&xfrm_class		endp
	    endif
	    else
&prefix&xfrm_class&_		endp
	    endif
		endm
		
if GEN_XFRM eq 1
xfrmName	equ	General
else
xfrmName	equ	Affine
endif


;ifndef WINNT
;DGROUP          GROUP   _DATA
;endif

_DATA           SEGMENT PARA PUBLIC USE32 'DATA'

; These two are in the same cache line
tx              dq	0
ty		dq	0

_DATA           ENDS

_TEXT           SEGMENT DWORD PUBLIC USE32 'CODE'
;ifdef WINNT
                ASSUME  CS:_TEXT ,DS:_DATA,SS:_DATA
;else
;               ASSUME  CS:_TEXT ,DS:DGROUP,SS:DGROUP
;endif

FDROP   macro
        fstp    st(0)
        endm

fmat	macro	op,row,col
	op	dword ptr [ebp + 4 * ((4 * row) + col)]
	endm

column	macro	i,depth
	fld	dword ptr [esi + D3DVERTEX_x]	; [1]	x

	fmat	fmul,0,i			; [2]	x

	fld	dword ptr [esi + D3DVERTEX_y]	; [3]	y	x

	fmat	fmul,1,i			; [4]	y	x

	fld	dword ptr [esi + D3DVERTEX_z]	; [5]	z	y	x

	fmat	fmul,2,i			; [6]	z	y	x
	fxch	st(2)				; 	x	y	z

	fmat	fadd,3,i			; [7]	x	y	z
	endm
		
	procstart	RLDDITransformUnclippedLoop,%xfrmName

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, m, in_size, out_size, z_scale, z_offset>
	defargs	<minx, maxx, miny, maxy>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        endif

	mov     ebx,[esp + count]
	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov     edi,[esp + vout]

	mov	ebp,[esp + m]

	;	eax	ebx	ecx	edx
	;	minx	maxx	miny	maxy

	; Need to do first loop iteration
	column	0,0
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z' x y z
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; tx
	
	column	1,1		;	x'	y'	z'	x
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			;	x'+y'	z'	tx
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx
	
if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count + 8],1
	je	dontscan
	mov	eax,[esi + 32]
	mov	ebx,[edi + 32]
dontscan:
	pop	ebx
	pop	eax

	fxch	st(3)		; tx tz ty 1/tz

	fmul	st,st(3)	; tx/w tz ty 1/tz
	fxch	st(2)		; ty tz tx/w 1/tz

	fmul	st,st(3)	; ty/w tz tx/w 1/tz
	fxch	st(2)		; tx/w tz ty/w 1/tz

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tz
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tz
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tz
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif
	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz

	fmul	st,st(1)
	fxch	st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]

	fstp	dword ptr [edi + D3DTLVERTEX_sz]

	add	edi,32
	add	esi,32

	dec	dword ptr [esp + count]
	jnz	transloop

	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformUnclippedLoop,%xfrmName


cpick	macro	dst,c0,c1			; NO CARRY	CARRY
	sbb	dst,dst				; 0		~0
	and	dst,c0 xor c1			; 0		c0^c1
	xor	dst,c0				; c0		c1
	endm

;************************************************************************

		
	procstart	RLDDITransformClippedLoop,%xfrmName
		

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, hout, m, in_size, out_size, z_scale, z_offset>
	defargs	<x_bound, y_bound, r_scale_x, r_scale_y>
	defargs	<minx, maxx, miny, maxy>
	defargs	<clip_intersection, clip_union>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        else
		mov     ebx,[esp + count]
		mov     ecx,[esp + vout]
        endif

	fldpi

	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov	ebp,[esp + m]
	mov	edi,[esp + vout]

	; Need to do first loop iteration

	column	0,0		; 2 cycle wait here
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z'
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; x'+y'+z'
	
	column	1,1		; 2 cycle wait here
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			; x'+y' z'
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	; Now set up the clip flags in ebp
	xor	ebp,ebp
	fld	dword ptr [esp + 8 + x_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(3+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	x1		; Skip this if (tmp > tx)
	or	ebp,D3DCS_RIGHT
x1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(3+GEN_XFRM)	; (tw) tz ty tx
	fnstsw	ax
	sahf
	jbe	xpasses		; Skip this if (-tmp <= tx)
	or	ebp,D3DCS_LEFT
xpasses:
	fld	dword ptr [esp + 8 + y_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	y1		; Skip this if (tmp > ty)
	or	ebp,D3DCS_TOP
y1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	jbe	ypasses		; Skip this if (-tmp <= ty)
	or	ebp,D3DCS_BOTTOM
ypasses:
	fst	[ty]		; ty will hold tw for a while...
	
	; if GEN_XFRM eq 0 then tw == tz
	; if GEN_XFRM eq 1 then tw != tz in general, so we
	; calculate a true 1/tw and then drop the extra tw
	; off the FP stack

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx

if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count],1
	je	dontscan
	mov	eax,[esp + in_size + 8]
	mov	ebx,[esp + out_size + 8]
	mov	eax,[esi + eax]
	mov	ebx,[edi + ebx]
dontscan:
	pop	ebx
	pop	eax

	mov	[esp + vout],edi		
	mov	edi,[esp + hout]
				; 1/tw tz ty tx
	fxch	st(3)		; tx tz ty 1/tw

	fld	dword ptr [esp + r_scale_x]
	fmul	st,st(1)	; hx tx tz ty 1/tw
	fld	dword ptr [esp + r_scale_y]
	fmul	st,st(4)	; hy hx tx tz ty 1/tw
	fxch	st(1)		; hx hy tx tz ty 1/tw

	fstp	dword ptr [edi + D3DHVERTEX_hx]
	fstp	dword ptr [edi + D3DHVERTEX_hy]

	fmul	st,st(3)	; tx/w tz ty 1/tw
	fxch	st(2)		; ty tz tx/w 1/tw

	fmul	st,st(3)	; ty/w tz tx/w 1/tw
	fxch	st(2)		; tx/w tz ty/w 1/tw

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tw
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tw
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tw
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif

	; Last clipping flags
	fst	dword ptr [edi + D3DHVERTEX_hz]
	test	byte ptr [edi + D3DHVERTEX_hz + 3],80h
	jz	nofront
	or	ebp,D3DCS_FRONT
nofront:
	fcom	[ty]
	push	eax		;[
	fnstsw	ax
	sahf
	pop	eax		;]
	jb	noback
	or	ebp,D3DCS_BACK
noback:
	mov	[edi + D3DHVERTEX_dwFlags],ebp
	mov	edi,[esp + clip_intersection]
	and	[edi],ebp
	mov	edi,[esp + clip_union]
	or	[edi],ebp

	test	ebp,ebp
	jnz	outofplay

	mov	edi,[esp + vout]

	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz y

	fmul	st,st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_sz]
				; 1/tz y

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]
				; y

	add	esi,[esp + in_size]

	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp
	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jnz	transloop
	jmp	cleanup

outofplay:				; tz sx sy 1/tz
	FDROP				; sx sy 1/tz
	FDROP				; sy 1/tz y
	FDROP				; 1/tz y
	mov	edi,[esp + vout]
	fstp	dword ptr [edi + D3DTLVERTEX_rhw]	

	add	esi,[esp + in_size]
	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp

	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jz	calcminmax

	column	0,0		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	jmp	smaxy


cleanup:
	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

calcminmax:
	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

	FDROP

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformClippedLoop,%xfrmName

		
if GEN_XFRM
_Rdtsc	proc
	db	0fh,31h
	shrd	eax,edx,10
	ret
	
_Rdtsc	endp
endif

_TEXT           ENDS

        extrn	_g_fOne:dword
        extrn	_g_fOoTwoPow16:dword
	extrn	_g_dSnap:qword

                END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\i386\light.asm ===
.486p

.model flat

include offsets.asm

.data

one DWORD   3f800000h

a1      dd 0.47                 ; Constants to compute inverse square root
a2      dd 1.47
v255    dd 65280.0              ; 255*256
v1_256  dd 0.00390625           ; 1/255
.code

PUBLIC  _Directional2P5S        ; Pentium optimized, specular, unit scale
PUBLIC  _Directional2P5         ; Pentium optimized, no specular, unit scale
;-------------------------------------------------------------------------
; Jim Blinn's method is used to compute inverse square root s = 1/sqrt(x):
;   ONE_AS_INTEGER = 0x3F800000
;   float y;
;   int tmp = ((ONE_AS_INTEGER << 1 + ONE_AS_INTEGER)  - *(long*)&x) >> 1;   
;   y = *(float*)&tmp;  
;   s = y*(1.47f - 0.47f*x*y*y);
; Input:
;   st(0)   = vector length
;   y, len  = should be defined as DWORD PTR
;   a1, a2  = 0.27 and 1.47
; Output:
;   st(0)   = 1/sqrt(vector length)
;
COMPUTE_ISQRT MACRO
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     len                         ; Vector length (x = len)
    sub     eax, len
    sar     eax, 1
    mov     y, eax                      ; y
    fmul    a1                          ; len*0.47  x y z
    fld     y                           ; y len*0.47 x y z
    fld     st(0)                       ; y y len*0.47 x y z
    fmul    st(0), st(1)                ; y*y y len*0.47 x y z
    fld     a2                          ; 1.47 y*y y len*0.47 x y z
    fxch    st(3)                       ; len*0.47 y*y y 1.47 x y z
    fmulp   st(1), st(0)                ; len*0.47*y*y y 1.47 x y z
    fsubp   st(2), st(0)                ; y aaa x y z
    fmulp   st(1), st(0)                ; 1/sqrt(len) x y z
ENDM
;-------------------------------------------------------------------------
; Exit from the function
;
EXIT_FUNC   MACRO
    pop     edx
    pop     ebx
    pop     ecx
    mov     esp, ebp
    pop     ebp
    ret
ENDM
;-------------------------------------------------------------------------
; void Directional2P5S(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Specular is always computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse and pv.lighting.specular are updated
;   pv.lighting.specularComputed is set to 1, if there is specular component
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5S PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit1

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

; if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)

;    test    DWORD PTR [ecx + D3DI_LIGHT_flags], D3DLIGHTI_COMPUTE_SPECULAR
;    jz      exit

; VecSub(in->dvPosition, light->model_eye, eye);

    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _X_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _X_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Y_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Y_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Z_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Z_]    ; z y x
    fxch    st(2)                                           ; x y z

; VecNormalizeFast(eye);
;

; Compute vector length. Leave vector on the FPU stack, because we will use it
;
    fld     st(1)                       ; x x y z
    fmul    st(0), st(0)                ; x*x x y z
    fld     st(2)
    fmul    st(0), st(0)                ; y*y x*x x y z
    fld     st(4)
    fmul    st(0), st(0)                ; z*z y*y x*x x y z
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len x y z

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

; Start normalizing the eye vector
    fmul    st(1), st(0)
    fmul    st(2), st(0)
    fmulp   st(3), st(0)                ; x y z  Normalized "eye" vector

; Calc halfway vector
; VecSub(light->model_direction, eye, h);
;
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fxch    st(1)                       ; y x z
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fxch    st(2)                       ; z x y 
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fxch    st(1)                       ; x z y 

; dot = VecDot(h, in->dvNormal);

    fld     st(0)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     st(3)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     st(3)                       ; z*Nz y*Ny x*Nx x z y
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_]
    fxch    st(2)
    faddp   st(1), st(0)
    faddp   st(1), st(0)                ; dot x z y
    fstp    dot                         ; x z y

; if (FLOAT_GTZ(dot)) 

    cmp     dot, 0
    jle     exit2

; dot *= ISQRTF(VecLenSq(h));
;
    fmul    st(0), st(0)                ; x*x y z
    fxch    st(1)                       ; y x*x z
    fmul    st(0), st(0)                ; y*y x*x z
    fxch    st(2)
    fmul    st(0), st(0)                ; z*z y*y x*x
    fxch    st(2)			            ; 
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

    fmul    dot                         ; dot
    mov     eax, [edx + PV_LIGHT_specThreshold]
    fst     dot

; if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))

    cmp     dot, eax
    jle     exit1

; power = COMPUTE_DOT_POW(&ldrv, dot);
;    int     indx;                
;    float   v;
;    dot *= 255.0f;
;    indx = (int)dot;
;    dot -= indx;                                            
;    ldrv->specularComputed = TRUE;                          
;    v = ldrv->currentSpecTable[indx];
;    return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
;
    fmul    v255            ; dot*255*256
    push    ebx
    fistp   dot             ; indx << 8. 8 bits used to compute dot fraction
    mov     ebx, dot        ; 
    and     dot, 0FFh       ; fractional part of dot
    shr     ebx, 8          ; Table index
    mov     eax, [edx + PV_LIGHT_currentSpecTable]
    lea     eax, [eax + ebx*4]
    fild    dot             ; fractional part of dot
    fmul    v1_256          ; dot*1/256 -> integer fraction to floating point
    fld     DWORD PTR [eax + 4]     ; currentSpecTable[indx+1]
    fsub    DWORD PTR [eax]         ; currentSpecTable[indx]
    fmulp   st(1), st(0)            ; dot*(v2-v1)
    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
    pop     ebx
    fadd    DWORD PTR [eax]

; power = COMPUTE_DOT_POW(&ldrv, dot);
; This is an alternative method to compute x power y.
; Jim Blinn's method is used:
; int tmp = (int)(power*(*(long*)&dot - ONE_AS_INTEGER)) + ONE_AS_INTEGER;
; dot ^ power = *(float*)&tmp;                                           
;
;    sub     dot, 03F800000h
;    fstp    st(0)                       ; Remove dot
;    fld     DWORD PTR [edx + PV_LIGHT_material_power]
;    fimul   dot
;    fistp   dot
;    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
;    add     dot, 03F800000h
;    fld     dot

; ldrv.specular.r += light->local_specR * power;
; ldrv.specular.g += light->local_specG * power;
; ldrv.specular.b += light->local_specB * power;
;
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specB]
    fmulp   st(3), st(0)                ; g r b
    fxch    st(1)                       ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fxch    st(1)                       ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(2)                       ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(1)                       ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _G_]
exit:
    EXIT_FUNC
exit1:
    fstp    st(0)
    EXIT_FUNC
exit2:
    fstp    st(0)
    fstp    st(0)
    fstp    st(0)
    EXIT_FUNC

_Directional2P5S ENDP
;-------------------------------------------------------------------------
; void Directional2P5(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Only diffuse component is computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse is updated
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5 PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit3

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

    EXIT_FUNC
exit3:
    fstp    st(0)
    EXIT_FUNC

_Directional2P5 ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\cppdbg.cpp ===
//----------------------------------------------------------------------------
//
// cppdbg.cpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

#ifdef _ALPHA_
// On Alpha va_list is a structure so it's not compatible with NULL.
static va_list NULLVA;
#else
#define NULLVA NULL
#endif

static DebugModuleFlags g_FailureFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_FAILURE, BREAK),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, OUTPUT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, PROMPT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, FILENAME_ONLY),
    0, NULL,
};

static DebugModuleFlags g_OutputFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, SUPPRESS),
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, ALL_MATCH),
    0, NULL,
};

static char *g_pFlagNames[] =
{
    "AssertFlags",
    "HrFlags",
    "OutputFlags",
    "OutputMask",
    "UserFlags"
};

//----------------------------------------------------------------------------
//
// DebugModule::DebugModule
//
//----------------------------------------------------------------------------

DebugModule::DebugModule(char *pModule, char *pPrefix,
                         DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                         DebugModuleFlags *pUserFlags, UINT uUserFlags)
{
    m_pModule = pModule;
    m_iModuleStartCol = strlen(m_pModule) + 2;
    m_pPrefix = pPrefix;

    m_pModFlags[DBG_ASSERT_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_HR_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_OUTPUT_FLAGS] = g_OutputFlags;
    m_pModFlags[DBG_OUTPUT_MASK] = pOutputMasks;
    m_pModFlags[DBG_USER_FLAGS] = pUserFlags;

    m_uFlags[DBG_ASSERT_FLAGS] = DBG_FAILURE_OUTPUT | DBG_FAILURE_BREAK |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_HR_FLAGS] = DBG_FAILURE_OUTPUT |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_OUTPUT_FLAGS] = 0;
    m_uFlags[DBG_OUTPUT_MASK] = uOutputMask;
    m_uFlags[DBG_USER_FLAGS] = uUserFlags;

    ReadReg();
}

//----------------------------------------------------------------------------
//
// DebugModule::OutVa
//
// Base debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::OutVa(UINT uMask, char *pFmt, va_list Args)
{
    if (m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_SUPPRESS)
    {
        return;
    }

    if ((uMask & DBG_MASK_NO_PREFIX) == 0)
    {
        OutputDebugStringA(m_pModule);
        OutputDebugStringA(": ");
    }

    char chMsg[1024];

    _vsnprintf(chMsg, sizeof(chMsg), pFmt, Args);
    OutputDebugStringA(chMsg);
}

//----------------------------------------------------------------------------
//
// DebugModule::Out
//
// Always-output debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::Out(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    OutVa(0, pFmt, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedVa
//
// Handles assertion failure output and interface.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine)
{
    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        if (OutPathFile("Assertion failed", m_uFlags[DBG_ASSERT_FLAGS]))
        {
            OutVa(DBG_MASK_NO_PREFIX, ":\n    ", NULLVA);
        }
        else
        {
            OutVa(DBG_MASK_NO_PREFIX, ": ", NULLVA);
        }

        OutVa(DBG_MASK_NO_PREFIX, pFmt, Args);
        if (bNewLine)
        {
            OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        }
    }

    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_BREAK)
    {
        DebugBreak();
    }
    else if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailed
//
// Handles simple expression assertion failures.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailed(char *pExp)
{
    AssertFailedVa(pExp, NULLVA, TRUE);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedMsg
//
// Handles assertion failures with arbitrary debug output.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedMsg(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    AssertFailedVa(pFmt, Args, FALSE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::HrFailure
//
// Handles HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrFailure(HRESULT hr, char *pPrefix)
{
    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        OutPathFile(pPrefix, m_uFlags[DBG_HR_FLAGS]);
        OutMask(DBG_MASK_FORCE_CONT, ": %s\n", HrString(hr));
    }

    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_BREAK)
    {
        DebugBreak();
    }
    else if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::HrStmtFailed
//
// Handles statement-style HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrStmtFailed(HRESULT hr)
{
    HrFailure(hr, "HR test fail");
}

//----------------------------------------------------------------------------
//
// DebugModule::ReturnHr
//
// Handles expression-style HRESULT failures.
//
//----------------------------------------------------------------------------

HRESULT DebugModule::HrExpFailed(HRESULT hr)
{
    HrFailure(hr, "HR expr fail");
    return hr;
}

//----------------------------------------------------------------------------
//
// DebugModule::Prompt
//
// Allows control over debug options via interactive input.
//
//----------------------------------------------------------------------------

void DebugModule::Prompt(char *pFmt, ...)
{
    va_list Args;

    if (pFmt != NULL)
    {
        va_start(Args, pFmt);
        OutVa(0, pFmt, Args);
        va_end(Args);
    }

#if 0   // ndef WIN95
    // This is DEADCODE, that is can be potentially used on NT ONLY to
    // bring up a debugging prompt. It requires linking with NTDLL.LIB
    char szInput[512];
    char *pIdx;
    int iIdx;
    static char szFlagCommands[] = "ahomu";

    for (;;)
    {
        ULONG uLen;

        uLen = DbgPrompt("[bgaAFhHmMoOrRuU] ", szInput, sizeof(szInput) - 1);
        if (uLen < 2)
        {
            Out("DbgPrompt failed\n");
            DebugBreak();
            return;
        }

        // ATTENTION - Currently DbgPrompt returns a length that is two
        // greater than the actual number of characters.  Presumably this
        // is an artifact of the Unicode/ANSI conversion and should
        // really only be one greater, so attempt to handle both.

        uLen -= 2;
        if (szInput[uLen] != 0)
        {
            uLen++;
            szInput[uLen] = 0;
        }

        if (uLen < 1)
        {
            Out("Empty command ignored\n");
            continue;
        }

        switch(szInput[0])
        {
        case 'b':
            DebugBreak();
            break;
        case 'g':
            return;

        case 'r':
            WriteReg();
            break;
        case 'R':
            ReadReg();
            break;

        case 'a':
        case 'A':
        case 'h':
        case 'H':
        case 'm':
        case 'M':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            char chLower;

            if (szInput[0] >= 'A' && szInput[0] <= 'Z')
            {
                chLower = szInput[0] - 'A' + 'a';
            }
            else
            {
                chLower = szInput[0];
            }

            pIdx = strchr(szFlagCommands, chLower);
            if (pIdx == NULL)
            {
                // Should never happen.
                break;
            }

            iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
            if (szInput[0] == chLower)
            {
                // Set.
                m_uFlags[iIdx] = ParseUint(szInput + 1, m_pModFlags[iIdx]);
            }

            // Set or Get.
            OutUint(g_pFlagNames[iIdx], m_pModFlags[iIdx], m_uFlags[iIdx]);
            break;

        case 'F':
            if (uLen < 2)
            {
                Out("'F' must be followed by a flag group specifier\n");
                break;
            }

            pIdx = strchr(szFlagCommands, szInput[1]);
            if (pIdx == NULL)
            {
                Out("Unknown flag group '%c'\n", szInput[1]);
            }
            else
            {
                iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
                ShowFlags(g_pFlagNames[iIdx], m_pModFlags[iIdx]);
            }
            break;

        default:
            Out("Unknown command '%c'\n", szInput[0]);
            break;
        }
    }
#else
    OutUint("OutputMask", m_pModFlags[DBG_OUTPUT_MASK],
            m_uFlags[DBG_OUTPUT_MASK]);
    Out("Prompt not available\n");
    DebugBreak();
#endif
}

//----------------------------------------------------------------------------
//
// DebugModule::OpenDebugKey
//
// Opens the Direct3D\Debug\m_pModule key.
//
//----------------------------------------------------------------------------

HKEY DebugModule::OpenDebugKey(void)
{
    HKEY hKey;
    char szKeyName[128];

    strcpy(szKeyName, "Software\\Microsoft\\Direct3D\\Debug\\");
    strcat(szKeyName, m_pModule);
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS,
                      &hKey) != ERROR_SUCCESS)
    {
        return NULL;
    }
    else
    {
        return hKey;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::GetRegUint
//
// Gets a UINT value from the given key.
//
//----------------------------------------------------------------------------

UINT DebugModule::GetRegUint(HKEY hKey, char *pValue, UINT uDefault)
{
    DWORD dwType, dwSize;
    DWORD dwVal;

    dwSize = sizeof(dwVal);
    if (RegQueryValueExA(hKey, pValue, NULL, &dwType, (BYTE *)&dwVal,
                         &dwSize) != ERROR_SUCCESS ||
        dwType != REG_DWORD)
    {
        return uDefault;
    }
    else
    {
        return (UINT)dwVal;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::SetRegUint
//
// Sets a UINT value for the given key.
//
//----------------------------------------------------------------------------

BOOL DebugModule::SetRegUint(HKEY hKey, char *pValue, UINT uValue)
{
    return RegSetValueExA(hKey, pValue, NULL, REG_DWORD, (BYTE *)&uValue,
                          sizeof(uValue)) == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
//
// DebugModule::ReadReg
//
// Reads settings from the registry.
//
//----------------------------------------------------------------------------

void DebugModule::ReadReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            m_uFlags[iIdx] = GetRegUint(hKey, g_pFlagNames[iIdx],
                                        m_uFlags[iIdx]);
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::WriteReg
//
// Writes values to the registry.
//
//----------------------------------------------------------------------------

void DebugModule::WriteReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            if (!SetRegUint(hKey, g_pFlagNames[iIdx], m_uFlags[iIdx]))
            {
                OutputDebugStringA("Error writing registry information\n");
            }
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ParseUint
//
// Parses a string for a numeric value or a set of flag strings.
//
//----------------------------------------------------------------------------

UINT DebugModule::ParseUint(char *pString, DebugModuleFlags *pFlags)
{
    UINT uVal;

    uVal = 0;

    for (;;)
    {
        while (*pString != 0 &&
               (*pString == ' ' || *pString == '\t'))
        {
            pString++;
        }

        if (*pString == 0)
        {
            break;
        }

        char *pEnd;
        int iStepAfter;

        pEnd = pString;
        while (*pEnd != 0 && *pEnd != ' ' && *pEnd != '\t')
        {
            pEnd++;
        }
        iStepAfter = *pEnd != 0 ? 1 : 0;
        *pEnd = 0;

        if (*pString >= '0' && *pString <= '9')
        {
            uVal |= strtoul(pString, &pString, 0);
            if (*pString != 0 && *pString != ' ' && *pString != '\t')
            {
                Out("Unrecognized characters '%s' after number\n", pString);
            }
        }
        else if (pFlags != NULL)
        {
            DebugModuleFlags *pFlag;

            for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
            {
                if (!_stricmp(pString, pFlag->pName))
                {
                    break;
                }
            }

            if (pFlag->uFlag == 0)
            {
                Out("Unrecognized flag string '%s'\n", pString);
            }
            else
            {
                uVal |= pFlag->uFlag;
            }
        }
        else
        {
            Out("No flag definitions, unable to convert '%s'\n", pString);
        }

        pString = pEnd + iStepAfter;
    }

    return uVal;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutUint
//
// Displays a UINT as a set of flag strings.
//
//----------------------------------------------------------------------------

void DebugModule::OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue)
{
    if (pFlags == NULL || uValue == 0)
    {
        Out("%s: 0x%08X\n", pName, uValue);
        return;
    }

    Out("%s:", pName);
    m_iStartCol = m_iModuleStartCol + strlen(pName) + 1;
    m_iCol = m_iStartCol;

    while (uValue != 0)
    {
        DebugModuleFlags *pFlag;

        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            if ((pFlag->uFlag & uValue) == pFlag->uFlag)
            {
                AdvanceCols(strlen(pFlag->pName) + 1);
                OutMask(DBG_MASK_FORCE_CONT, " %s", pFlag->pName);
                uValue &= ~pFlag->uFlag;
                break;
            }
        }

        if (pFlag->uFlag == 0)
        {
            AdvanceCols(11);
            OutMask(DBG_MASK_FORCE_CONT, " 0x%X", uValue);
            uValue = 0;
        }
    }

    OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
}

//----------------------------------------------------------------------------
//
// DebugModule::AdvanceCols
//
// Determines if there's enough space on the current line for
// the given number of columns.  If not, a new line is started.
//
//----------------------------------------------------------------------------

void DebugModule::AdvanceCols(int iCols)
{
    static char szSpaces[] = "                                ";

    m_iCol += iCols;
    if (m_iCol >= 79)
    {
        int iSpace;

        OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        // Force a prefix to be printed to start the line.
        Out("");

        m_iCol = m_iModuleStartCol;
        while (m_iCol < m_iStartCol)
        {
            iSpace = (int)min(sizeof(szSpaces) - 1, m_iStartCol - m_iCol);
            OutMask(DBG_MASK_FORCE_CONT, "%.*s", iSpace, szSpaces);
            m_iCol += iSpace;
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ShowFlags
//
// Shows the given flag set.
//
//----------------------------------------------------------------------------

void DebugModule::ShowFlags(char *pName, DebugModuleFlags *pFlags)
{
    DebugModuleFlags *pFlag;

    Out("%s:\n", pName);
    if (pFlags == NULL)
    {
        Out("    None defined\n");
    }
    else
    {
        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            Out("    0x%08X - %s\n", pFlag->uFlag, pFlag->pName);
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::PathFile
//
// Returns the trailing filename component or NULL if the path is
// only a filename.
//
//----------------------------------------------------------------------------

char *DebugModule::PathFile(char *pPath)
{
    char *pFile, *pSlash, *pBack, *pColon;

    pBack = strrchr(pPath, '\\');
    pSlash = strrchr(pPath, '/');
    pColon = strrchr(pPath, ':');

    pFile = pBack;
    if (pSlash > pFile)
    {
        pFile = pSlash;
    }
    if (pColon > pFile)
    {
        pFile = pColon;
    }

    return pFile != NULL ? pFile + 1 : NULL;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutPathFile
//
// Outputs the given string plus a path and filename.
// Returns whether the full path was output or not.
//
//----------------------------------------------------------------------------

BOOL DebugModule::OutPathFile(char *pPrefix, UINT uFailureFlags)
{
    char *pFile;

    if (uFailureFlags & DBG_FAILURE_FILENAME_ONLY)
    {
        pFile = PathFile(m_pFile);
    }
    else
    {
        pFile = NULL;
    }

    if (pFile == NULL)
    {
        Out("%s %s(%d)", pPrefix, m_pFile, m_iLine);
        return TRUE;
    }
    else
    {
        Out("%s <>\\%s(%d)", pPrefix, pFile, m_iLine);
        return FALSE;
    }
}

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_ONCE(Global, G, NULL, 0, NULL, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\i386\tclipp5.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul5

_matmul5  PROC    

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;


        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;


; notation in comments on stack gives the progress on the element.
; x, y, z mean input x y z
; x1-4 means x*_11, x*_11+y*_21, x*_11+y*_21+z*_31, x*_11+y*_21+z*_31+_41
; Some intermediate results x*_11+_41 and y*_21+z*_31 are denoted as x2

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31 y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fxch    st(2)                           ; y*_21 y*_24 z*_31 w1 x1
        faddp   st(4),st                        ; y*_24 z*_31 w1 x2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34 y*_24 z*_31 w1 x2
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fxch    st(1)                           ; y*_24 z*_34 z*_31 w1 x2
        faddp   st(3),st                        ; z*_34 z*_31 w2 x2
        fxch    st(1)                           ; z*_31 z*_34 w2 x2
        faddp   st(3),st                        ; z*_34 w2 x3
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 z*_34 w2 x3
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fxch    st(1)                           ; z*_34 y1 w2 x3
        faddp   st(2),st                        ; y1 w3 x3
        fxch    st(2)                           ; x3 w3 y1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x4 w3 y1
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23 y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;
        fxch    st(4)                           ; w3 y*_22 z1 x4 y*_23 y1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w4 y*_22 z1 x4 y*_23 y1
        fxch    st(3)                           ; x4 y*_22 z1 w4 y*_23 y1
        fst     dword ptr [ebp]                 ;
        fxch    st(1)                           ; y*_22 x4 z1 w4 y*_23 y1
        faddp   st(5),st                        ; x4 z1 w4 y*_23 y2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33 z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;
        fxch    st(6)                           ; y2 z*_32 x4 z1 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y3 z*_32 x4 z1 w4 y*_23 z*_33
        fxch    st(3)                           ; z1 z*_32 x4 y3 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 z*_32 x4 y3 w4 y*_23 z*_33
        fxch    st(5)                           ; y*_23 z*_32 x4 y3 w4 z2 z*_33
        faddp   st(6),st                        ; z*_32 x4 y3 w4 z2 z2
        faddp   st(2),st                        ; x4 y4 w4 z2 z2

;;
        fsubr   st,st(2)                        ; xx y4 w4 z2 z2
        fxch    st(4)                           ; z2 y4 w4 z2 xx
        faddp   st(3),st                        ; y4 w4 z4 xx
        fld     st                              ; y4 y4 w4 z4 xx
        fsubr   st,st(2)                        ; yy y4 w4 z4 xx
        fxch    st(1)                           ; y4 yy w4 z4 xx
        fstp    dword ptr [ebp+4]               ; yy w4 z4 xx
        fxch    st(3)                           ; xx w4 z4 yy
        fstp    tempxx                          ; w4 z4 yy
        fxch    st(1)                           ; z4 w4 yy
        fst     dword ptr [ebp+8]               ;
        fsubr   st,st(1)                        ; zz w4 yy
        fxch    st(2)                           ; yy w4 zz
        fstp    tempyy                          ; w4 zz
        fxch    st(1)                           ; zz w4
        fstp    tempzz                          ;

        fld1                                    ; 1 w4
        fdiv	st,st(1)                        ; 1/w w

;; Now compute the clipcodes.


;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCS_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCS_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCS_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCS_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCS_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCS_BACK

        mov     eax,dword ptr [ebp]     ; Get x
        mov     ebx,dword ptr [ebp+4]   ; Get y

        and     eax,esi                 ;
        and     ebx,esi                 ;

        shr     eax,32-1                ; D3DCS_LEFT
        mov     ecx,dword ptr [ebp+8]   ; Get z

        shr     ebx,32-4		; D3DCS_BOTTOM
        mov     edx,tempxx		;

        or      eax,ebx			; OR together clip flags
        and     ecx,esi			;

        shr     ecx,32-5		; D3DCS_FRONT
        and     edx,esi                 ;

        shr     edx,32-2                ; D3DCS_RIGHT
        mov     ebx,tempyy		;

        or      eax,ecx                 ;
        and     ebx,esi                 ;

        shr     ebx,32-3                ; D3DCS_TOP
        or      eax,edx                 ;

        mov     edx,tempzz
        or      eax,ebx                 ;

        and     edx,esi                 ;

        shr     edx,32-6                ; D3DCS_BACK
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv

        or      eax,edx                 ; Finish clip flag generation
        mov     ebx,pmat                ;

        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;

        test    eax,eax                 ; Bail if clip!=0
        jnz     ClipNonzero             ;

        push    eax                     ; Save clip flags
                                        ; ax gets trashed by fstsw in min/max calcs

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx


        fxch    st(1)                   ; we w
        fstp    st                      ;
                                        ; w
        fld     dword ptr [ebp]         ; x w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fld     dword ptr [ebp+4]       ; y x*scaleX w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(1)                   ; x*scaleX y*scaleY w
        fmul    st,st(2)                ; x*w*scaleX y*scaleY w
        fxch    st(1)                   ; y*scaleY x*w*scaleX w
        fmul    st,st(2)                ; y*w*scaleY x*w*scaleX w
        fxch    st(1)                   ; x*w*scaleX y*w*scaleY w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(1)                   ; y x w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fld     dword ptr [ebp+8]       ; z y x w
        fmul    st,st(3)                ; z y x w
        fxch    st(2)                   ; x y z w

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; x y z w
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
@@:     fxch    st(1)
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
@@:     fxch    st(1)
NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]

        pop     eax         ; Get clip flags back
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    st          ; Get rid of 1/w
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw] ; store we
        jmp     short Return

_matmul5  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\cppdbg.hpp ===
//----------------------------------------------------------------------------
//
// cppdbg.hpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _CPPDBG_HPP_
#define _CPPDBG_HPP_

#if DBG

#include <stdarg.h>

typedef unsigned int UINT;
        
//
// Mask bits common to all modules.
//

#define DBG_MASK_NO_PREFIX              0x80000000
#define DBG_MASK_FORCE                  0x40000000

// Mask bits checked against output mask.
#define DBG_MASK_CHECK                  (~(DBG_MASK_NO_PREFIX | \
                                           DBG_MASK_FORCE))

// Forced continuation mask.
#define DBG_MASK_FORCE_CONT             (DBG_MASK_NO_PREFIX | DBG_MASK_FORCE)

//
// Failure control bits for assert and HRESULT failures.
//

#define DBG_FAILURE_BREAK               0x00000001
#define DBG_FAILURE_OUTPUT              0x00000002
#define DBG_FAILURE_PROMPT              0x00000004
#define DBG_FAILURE_FILENAME_ONLY       0x00000008

//
// Overall output control bits.
//

#define DBG_OUTPUT_SUPPRESS             0x00000001
#define DBG_OUTPUT_ALL_MATCH            0x00000002

//----------------------------------------------------------------------------
//
// DebugModule
//
//----------------------------------------------------------------------------

struct DebugModuleFlags
{
    UINT uFlag;
    char *pName;
};

// Declares a DebugModuleFlags entry.
#define DBG_DECLARE_MODFLAG(Group, Name) \
    Group ## _ ## Name, #Name

enum
{
    DBG_ASSERT_FLAGS,
    DBG_HR_FLAGS,
    DBG_OUTPUT_FLAGS,
    DBG_OUTPUT_MASK,
    DBG_USER_FLAGS,
    DBG_FLAGS_COUNT
};

class DebugModule
{
public:
    DebugModule(char *pModule, char *pPrefix,
                DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                DebugModuleFlags *pUserFlags, UINT uUserFlags);

    void Out(char *pFmt, ...);

    void OutMask(UINT uMask, char *pFmt, ...)
    {
        if ((uMask & DBG_MASK_FORCE) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) == uMask) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) == 0 &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) != 0))
        {
            va_list Args;

            va_start(Args, pFmt);
            OutVa(uMask, pFmt, Args);
            va_end(Args);
        }
    }
    
    void AssertFailed(char *pExp);
    void AssertFailedMsg(char *pFmt, ...);

    void HrStmtFailed(HRESULT hr);
    HRESULT HrExpFailed(HRESULT hr);
    
    void SetFileLine(char *pFile, int iLine)
    {
        m_pFile = pFile;
        m_iLine = iLine;
    }

    void Prompt(char *pFmt, ...);

    UINT GetFlags(int iIdx)
    {
        return m_uFlags[iIdx];
    }
    void SetFlags(int iIdx, UINT uValue)
    {
        m_uFlags[iIdx] = uValue;
    }

private:
    void OutVa(UINT uMask, char *pFmt, va_list Args);
    void AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine);

    HKEY OpenDebugKey(void);
    UINT GetRegUint(HKEY hKey, char *pValue, UINT uDefault);
    BOOL SetRegUint(HKEY hKey, char *pValue, UINT uValue);
    void ReadReg(void);
    void WriteReg(void);

    UINT ParseUint(char *pString, DebugModuleFlags *pFlags);
    void OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue);

    void AdvanceCols(int iCols);

    void ShowFlags(char *pName, DebugModuleFlags *pFlags);

    char *PathFile(char *pPath);
    BOOL OutPathFile(char *pPrefix, UINT uFailureFlags);

    void HrFailure(HRESULT hr, char *pPrefix);
    char *HrString(HRESULT hr);
    
    // Module information given.
    char *m_pModule;
    char *m_pPrefix;
    
    // Flag descriptions and values.
    DebugModuleFlags *m_pModFlags[DBG_FLAGS_COUNT];
    UINT m_uFlags[DBG_FLAGS_COUNT];

    // Temporary file and line number storage.
    char *m_pFile;
    int m_iLine;

    // Output column during multiline display.
    int m_iModuleStartCol;
    int m_iCol;
    int m_iStartCol;
};

//----------------------------------------------------------------------------
//
// Support macros.
//
//----------------------------------------------------------------------------

#define DBG_MODULE(Prefix) Prefix ## _Debug

// Put this in one source file.
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags) \
    DebugModule DBG_MODULE(Prefix)(#Module, #Prefix, \
                                   pOutputMasks, uOutputMask, \
                                   pUserFlags, uUserFlags)

// Put this in your derived debugging header.
#define DBG_DECLARE_HEADER(Prefix) \
    extern DebugModule DBG_MODULE(Prefix)

// Put this in every file.
#define DBG_DECLARE_FILE() \
    static char *g_pStaticDebugFile = __FILE__

#define DBG_DECLARE_DPF(Prefix, Args) \
    DBG_MODULE(Prefix).Out Args
#define DBG_DECLARE_DPFM(Prefix, Args) \
    DBG_MODULE(Prefix).OutMask Args

#define DBG_DECLARE_ASSERT(Prefix, Exp) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailed(#Exp); } \
    else 0
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailedMsg Args ; } \
    else 0
#define DBG_DECLARE_VERIFY(Prefix, Exp) \
    DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args)\
    DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)

#define DBG_DECLARE_PROMPT(Prefix, Args) \
    DBG_MODULE(Prefix).Prompt Args

#define DBG_DECLARE_GETFLAGS(Prefix, Idx) \
    DBG_MODULE(Prefix).GetFlags(Idx)
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value) \
    DBG_MODULE(Prefix).SetFlags(Idx, Value)

//
// These macros assume a variable 'hr' exists.
//

// HRESULT test in expression form.
#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    ((hr = (Exp)) != S_OK ? \
      (DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__), \
       DBG_MODULE(Prefix).HrExpFailed(hr)) : hr)

// HRESULT test in if/then form.
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).HrStmtFailed(hr); \
      DoFail; } \
    else hr

#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#else // #if DBG

//
// Empty macros for free builds.
//

#define DBG_MODULE(Prefix) 0
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags)
#define DBG_DECLARE_HEADER(Prefix)
#define DBG_DECLARE_FILE()

#define DBG_DECLARE_DPF(Prefix, Args)
#define DBG_DECLARE_DPFM(Prefix, Args)
#define DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)
#define DBG_DECLARE_PROMPT(Prefix, Args)
#define DBG_DECLARE_GETFLAGS(Prefix, Idx) 0
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value)

//
// Macros which evaluate to code on free builds.
//

#define DBG_DECLARE_VERIFY(Prefix, Exp) (Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args) (Exp)

#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    (hr = (Exp))
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) DoFail; else hr
#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_HEADER(G);

#define GDPF(Args)              DBG_DECLARE_DPF(G, Args)
#define GDPFM(Args)             DBG_DECLARE_DPFM(G, Args)
#define GASSERT(Exp)            DBG_DECLARE_ASSERT(G, Exp)
#define GASSERTMSG(Exp, Args)   DBG_DECLARE_ASSERTMSG(G, Exp, Args)
#define GVERIFY(Exp)            DBG_DECLARE_VERIFY(G, Exp)
#define GVERIFYMSG(Exp)         DBG_DECLARE_VERIFYMSG(G, Exp, Args)
#define GPROMPT(Args)           DBG_DECLARE_PROMPT(G, Args)
#define GGETFLAGS(Idx)          DBG_DECLARE_GETFLAGS(G, Idx)
#define GSETFLAGS(Idx, Value)   DBG_DECLARE_SETFLAGS(G, Idx, Value)
#define GHRCHK(Exp)             DBG_DECLARE_HRCHK(G, Exp)
#define GHRGO(Exp, Label)       DBG_DECLARE_HRGO(G, Exp, Label)
#define GHRERR(Exp)             DBG_DECLARE_HRERR(G, Exp)
#define GHRRET(Exp)             DBG_DECLARE_HRRET(G, Exp)

#endif // #ifndef _CPPDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\tnl\i386\tclipp6.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.data

gD3DCS_LEFT   dd  01h
gD3DCS_RIGHT  dd  02h
gD3DCS_TOP    dd  04h
gD3DCS_BOTTOM dd  08h
gD3DCS_FRONT  dd  10h
gD3DCS_BACK   dd  20h

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul6

_matmul6  PROC

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;

        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;

        fxch    st(3)                           ; x1 y1 w1 z1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x2 y1 w1 z1
        fxch    st(2)                           ; w1 y1 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w2 y1 x2 z1
        fxch    st(1)                           ; y1 w2 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y2 w2 x2 z1
        fxch    st(3)                           ; z1 w2 x2 y2
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 w2 x2 y2

        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;

        fxch    st(3)       ; y*_21 y*_22 y*_24 y*_23 z2 w2 x2 y2
        faddp   st(6),st    ; y*_22 y*_24 y*_23 z2 w2 x3 y2
        fxch    st(1)       ; y*_24 y*_22 y*_23 z2 w2 x3 y2
        faddp   st(4),st    ; y*_22 y*_23 z2 w3 x3 y2
        faddp   st(5),st    ; y*_23 z2 w3 x3 y3
        faddp   st(1),st    ; z3 w3 x3 y3

        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;

        fxch    st(3)       ; z*_31 z*_32 z*_34 z*_33 z3 w3 x3 y3
        faddp   st(6),st    ; z*_32 z*_34 z*_33 z3 w3 x4 y3
        fxch    st(1)       ; z*_34 z*_32 z*_33 z3 w3 x4 y3
        faddp   st(4),st    ; z*_32 z*_33 z3 w4 x4 y3
        faddp   st(5),st    ; z*_33 z3 w4 x4 y4
        faddp   st(1),st    ; z4 w4 x4 y4

        fldz                ; 0 z4 w4 x4 y4
        fxch    st(4)       ; y4 z4 w4 x4 0
        fxch    st(3)       ; x4 z4 w4 y4 0
        xor     eax,eax     ;
        xor     ebx,ebx     ;
        xor     ecx,ecx     ;
        xor     edx,edx     ;
        fcomi   st,st(4)    ;
        cmovb   eax,gD3DCS_LEFT
        fcomi   st,st(2)    ;
        cmovnb  ebx,gD3DCS_RIGHT
        fxch    st(3)       ; y4 z4 w4 x4 0
        or      eax,ebx
        xor     ebx,ebx
        fcomi   st,st(4)    ;
        cmovb   ecx,gD3DCS_BOTTOM
        fcomi   st,st(2)    ;
        cmovnb  edx,gD3DCS_TOP
        or      eax,ecx
        xor     ecx,ecx
        fxch    st(1)       ; z4 y4 w4 x4 0
        fcomi   st,st(4)    ;
        or      edx,edx
        cmovb   ebx,gD3DCS_FRONT
        fcomi   st,st(2)    ;
        cmovnb  ecx,gD3DCS_BACK
        or      eax,ebx
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv
        or      eax,ecx
        mov     ebx,pmat                ;
        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;
        fxch    st(4)   ; 0 y4 w4 x4 z4
        fstp    st      ; y4 w4 x4 z4

;; Now compute the clipcodes.

;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCS_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCS_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCS_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCS_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCS_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCS_BACK

;; actually the flags have not been touched since the final OR so we don't 
;; need to test this explicitly
;;      test    eax,eax
        jnz     ClipNonzero             ; jump if clip flags nonzero

        fld1                ; 1 y w x z
        fdivrp  st(2),st    ; y w x z

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx

        ; y w x z
        fabs
        fxch    st(2)
        fabs
        fxch    st(2)

        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(2)   ;
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fxch    st(2)   ; y w x z
        fmul    st,st(1)
        fxch    st(2)   ; x w y z
        fmul    st,st(1) ;
        fxch    st(2)   ; y w x z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fxch    st(2)   ; x w y z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(3)   ; z w y x
        fmul    st,st(1)
        fxch    st(3)   ; x w y z

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; minx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fcomi   st,st(1)
        fcmovnb st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]

    ; maxx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fcomi   st,st(1)
        fcmovb  st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]

    ; miny x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fcomi   st,st(3)
        fcmovnb st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]

    ; maxy x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fcomi   st,st(3)
        fcmovb  st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]

NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        jmp     short Return

_matmul6  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\d3dexcept.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dexcept.h
 *  Content:    Exception support
 *
 ***************************************************************************/
#ifndef __D3DEXCEPT_H__
#define __D3DEXCEPT_H__

#include <string.h>

#define D3D_THROW( hResult, string )                                        \
    {                                                                       \
        char s[_MAX_PATH];                                                  \
        _snprintf(s, _MAX_PATH, "*** Exception in %s Line: %d", __FILE__,   \
                  __LINE__);                                                \
        D3D_ERR(s);                                                         \
        if (strcmp(string,"") != 0)                                         \
        {                                                                   \
            D3D_ERR(string);                                                \
        }                                                                   \
        throw hResult;                                                      \
    }
#define D3D_THROW_LINE( hResult, string, line, file)                        \
    {                                                                       \
        char s[_MAX_PATH];                                                  \
        _snprintf(s, _MAX_PATH, "*** Exception in %s Line: %d", file,       \
                  line);                                                    \
        D3D_ERR(s);                                                         \
        D3D_ERR(string);                                                    \
        throw hResult;                                                      \
    }
#define D3D_THROW_FAIL(string) D3D_THROW(D3DERR_INVALIDCALL, string)
#define D3D_CATCH   catch( HRESULT e ) { return e; }
#define D3D_TRY     try

class CD3DException
{
public:
    CD3DException(HRESULT res, char *msg, int LineNumber, char* file) 
    {
        error = res; 
        strcpy(message, msg); 
        strcpy(this->file, file); 
        line = LineNumber;
    }
    char message[128];
    char file[_MAX_PATH];
    HRESULT error;
    int line;
    
    void DebugString();
    void Popup();
};

#endif // __D3DEXCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\texdiff.h ===
//----------------------------------------------------------------------------
//
// texdiff.h
//
// TextureDiff base code for inclusion as an inline function or
// regular function from common code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------

{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef WINNT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include "ddraw.h"
#include <cppdbg.hpp>
#include "d3d8p.h"
#include "d3dtypesp.h"
#include "d3ditype.h"
#include "d3dflt.h"
#include "d3dutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\_dpf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define PROF_SECT "Direct3D"
#define START_STR "Direct3D7: "
#include "..\..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\hrstr.cpp ===
//----------------------------------------------------------------------------
//
// hrstr.cpp
//
// HRESULT-to-string mapper.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

struct HrStringDef
{
    HRESULT hr;
    char *pString;
};

#define HRDEF(Name) \
    Name, #Name

static HrStringDef g_HrStringDefs[] =
{
    // Put specific codes before generic codes so that specific codes
    // are returned in the cases where the HRESULT is the same.
    HRDEF(DDERR_ALREADYINITIALIZED),
    HRDEF(DDERR_BLTFASTCANTCLIP),
    HRDEF(DDERR_CANNOTATTACHSURFACE),
    HRDEF(DDERR_CANNOTDETACHSURFACE),
    HRDEF(DDERR_CANTCREATEDC),
    HRDEF(DDERR_CANTDUPLICATE),
    HRDEF(DDERR_CLIPPERISUSINGHWND),
    HRDEF(DDERR_COLORKEYNOTSET),
    HRDEF(DDERR_CURRENTLYNOTAVAIL),
    HRDEF(DDERR_DIRECTDRAWALREADYCREATED),
    HRDEF(DDERR_EXCEPTION),
    HRDEF(DDERR_EXCLUSIVEMODEALREADYSET),
    HRDEF(DDERR_GENERIC),
    HRDEF(DDERR_HEIGHTALIGN),
    HRDEF(DDERR_HWNDALREADYSET),
    HRDEF(DDERR_HWNDSUBCLASSED),
    HRDEF(DDERR_IMPLICITLYCREATED),
    HRDEF(DDERR_INCOMPATIBLEPRIMARY),
    HRDEF(DDERR_INVALIDCAPS),
    HRDEF(DDERR_INVALIDCLIPLIST),
    HRDEF(DDERR_INVALIDDIRECTDRAWGUID),
    HRDEF(DDERR_INVALIDMODE),
    HRDEF(DDERR_INVALIDOBJECT),
    HRDEF(DDERR_INVALIDPARAMS),
    HRDEF(DDERR_INVALIDPIXELFORMAT),
    HRDEF(DDERR_INVALIDPOSITION),
    HRDEF(DDERR_INVALIDRECT),
    HRDEF(DDERR_LOCKEDSURFACES),
    HRDEF(DDERR_NO3D),
    HRDEF(DDERR_NOALPHAHW),
    HRDEF(DDERR_NOBLTHW),
    HRDEF(DDERR_NOCLIPLIST),
    HRDEF(DDERR_NOCLIPPERATTACHED),
    HRDEF(DDERR_NOCOLORCONVHW),
    HRDEF(DDERR_NOCOLORKEY),
    HRDEF(DDERR_NOCOLORKEYHW),
    HRDEF(DDERR_NOCOOPERATIVELEVELSET),
    HRDEF(DDERR_NODC),
    HRDEF(DDERR_NODDROPSHW),
    HRDEF(DDERR_NODIRECTDRAWHW),
    HRDEF(DDERR_NOEMULATION),
    HRDEF(DDERR_NOEXCLUSIVEMODE),
    HRDEF(DDERR_NOFLIPHW),
    HRDEF(DDERR_NOGDI),
    HRDEF(DDERR_NOHWND),
    HRDEF(DDERR_NOMIRRORHW),
    HRDEF(DDERR_NOOVERLAYDEST),
    HRDEF(DDERR_NOOVERLAYHW),
    HRDEF(DDERR_NOPALETTEATTACHED),
    HRDEF(DDERR_NOPALETTEHW),
    HRDEF(DDERR_NORASTEROPHW),
    HRDEF(DDERR_NOROTATIONHW),
    HRDEF(DDERR_NOSTRETCHHW),
    HRDEF(DDERR_NOT4BITCOLOR),
    HRDEF(DDERR_NOT4BITCOLORINDEX),
    HRDEF(DDERR_NOT8BITCOLOR),
    HRDEF(DDERR_NOTAOVERLAYSURFACE),
    HRDEF(DDERR_NOTEXTUREHW),
    HRDEF(DDERR_NOTFLIPPABLE),
    HRDEF(DDERR_NOTFOUND),
    HRDEF(DDERR_NOTLOCKED),
    HRDEF(DDERR_NOTPALETTIZED),
    HRDEF(DDERR_NOVSYNCHW),
    HRDEF(DDERR_NOZBUFFERHW),
    HRDEF(DDERR_NOZOVERLAYHW),
    HRDEF(DDERR_OUTOFCAPS),
    HRDEF(DDERR_OUTOFMEMORY),
    HRDEF(DDERR_OUTOFVIDEOMEMORY),
    HRDEF(DDERR_OVERLAYCANTCLIP),
    HRDEF(DDERR_OVERLAYCOLORKEYONLYONEACTIVE),
    HRDEF(DDERR_OVERLAYNOTVISIBLE),
    HRDEF(DDERR_PALETTEBUSY),
    HRDEF(DDERR_PRIMARYSURFACEALREADYEXISTS),
    HRDEF(DDERR_REGIONTOOSMALL),
    HRDEF(DDERR_SURFACEALREADYATTACHED),
    HRDEF(DDERR_SURFACEALREADYDEPENDENT),
    HRDEF(DDERR_SURFACEBUSY),
    HRDEF(DDERR_SURFACEISOBSCURED),
    HRDEF(DDERR_SURFACELOST),
    HRDEF(DDERR_SURFACENOTATTACHED),
    HRDEF(DDERR_TOOBIGHEIGHT),
    HRDEF(DDERR_TOOBIGSIZE),
    HRDEF(DDERR_TOOBIGWIDTH),
    HRDEF(DDERR_UNSUPPORTED),
    HRDEF(DDERR_UNSUPPORTEDFORMAT),
    HRDEF(DDERR_UNSUPPORTEDMASK),
    HRDEF(DDERR_VERTICALBLANKINPROGRESS),
    HRDEF(DDERR_WASSTILLDRAWING),
    HRDEF(DDERR_WRONGMODE),
    HRDEF(DDERR_XALIGN),
    HRDEF(E_OUTOFMEMORY),
    HRDEF(E_INVALIDARG),
    HRDEF(E_FAIL),
    HRDEF(S_FALSE),
    HRDEF(S_OK),
    HRDEF(D3DERR_WRONGTEXTUREFORMAT),
    HRDEF(D3DERR_UNSUPPORTEDCOLOROPERATION),
    HRDEF(D3DERR_UNSUPPORTEDCOLORARG),
    HRDEF(D3DERR_UNSUPPORTEDALPHAOPERATION),
    HRDEF(D3DERR_UNSUPPORTEDALPHAARG),
    HRDEF(D3DERR_TOOMANYOPERATIONS),
    HRDEF(D3DERR_CONFLICTINGTEXTUREFILTER),
    HRDEF(D3DERR_UNSUPPORTEDFACTORVALUE),
    HRDEF(D3DERR_CONFLICTINGRENDERSTATE),
    HRDEF(D3DERR_UNSUPPORTEDTEXTUREFILTER),
    HRDEF(D3DERR_CONFLICTINGTEXTUREPALETTE),
    HRDEF(D3DERR_DRIVERINTERNALERROR),
    HRDEF(D3DERR_NOTFOUND),
    HRDEF(D3DERR_MOREDATA),
    HRDEF(D3DERR_DEVICENOTRESET),
    HRDEF(D3DERR_DEVICELOST),
    HRDEF(D3DERR_NOTAVAILABLE),
    HRDEF(D3DERR_INVALIDDEVICE),
    HRDEF(D3DERR_INVALIDCALL),
    0, NULL,
};

//----------------------------------------------------------------------------
//
// DebugModule::HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *DebugModule::HrString(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

//----------------------------------------------------------------------------
//
// HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *HrToStr(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern double g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <span.h>
#include "cppdbg.hpp"

DBG_DECLARE_FILE();

// Declare TextureDiff as an out-of-line function.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    GDPF(("!! DebugBreakFn called.  Leaving this function may destroy\n"));
    GDPF(("   the stack frame. !!\n"));
    DebugBreak();
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif
#define MAX_LEN 1
#ifdef MAX_LEN
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and take the max of each length
    // like classic OpenGL and the current RefRast implementation
    fCoverage = max(OctagonNorm(fDUDX, fDVDX), OctagonNorm(fDUDY, fDVDY));
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGSTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    GASSERTMSG(FALSE, ("ComputeTableFog unreachable\n"));
    return 0;
}

//----------------------------------------------------------------------------
//
// pVecNormalize2
//
// Normalizes the given D3DVECTOR.  Supports in-place operation.
//
//----------------------------------------------------------------------------

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes)
{
    FLOAT fLen;

    fLen = pVecLenSq(pVec);
    if (FLOAT_CMP_POS(fLen, <=, g_fNearZero))
    {
        pVecSet(pRes, 0.0f, 0.0f, 0.0f);
        return;
    }
    fLen = ISQRTF(fLen);
    pVecScale(pVec, fLen, pRes);
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3, D3DVECTORH *plane)
{
    D3DVECTOR a;
    D3DVECTOR b;

    pVecSub(v2, v1, &a);
    pVecSub(v3, v1, &b);

    plane->x = a.y*b.z - a.z*b.y;
    plane->y = a.z*b.x - a.x*b.z;
    plane->z = a.x*b.y - a.y*b.x;
    plane->w = - pVecDot(v1, plane);

    double tmp = pVecDot(plane, plane);
    if (tmp <= 0)
        return -1;
    tmp = 1.0/sqrt(tmp);

    plane->x = (D3DVALUE)(plane->x * tmp);
    plane->y = (D3DVALUE)(plane->y * tmp);
    plane->z = (D3DVALUE)(plane->z * tmp);
    plane->w = (D3DVALUE)(plane->w * tmp);
    return 0;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_PSIZE)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        for (INT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(dwFVF, i))
            {
            case D3DFVF_TEXTUREFORMAT2: dwStride += sizeof(D3DVALUE) * 2; break;
            case D3DFVF_TEXTUREFORMAT1: dwStride += sizeof(D3DVALUE) * 1; break;
            case D3DFVF_TEXTUREFORMAT3: dwStride += sizeof(D3DVALUE) * 3; break;
            case D3DFVF_TEXTUREFORMAT4: dwStride += sizeof(D3DVALUE) * 4; break;
            }
        }
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return D3D_OK;
}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#include <d3d8typesp.h>
#include <d3dflt.h>
#include <d3ditype.h>

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#ifdef __cplusplus
extern "C" {
#endif

typedef D3DVECTOR* LPD3DVECTOR;

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//
// D3DVECTOR operations.
//

#define pVecLenSq(pVec)                                                       \
    pVecDot(pVec, pVec)
#define pVecLen(pVec)                                                         \
    SQRTF(pVecLenSq(pVec))

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes);

#define pVecNormalize(pVec)             pVecNormalize2(pVec, pVec)
#define VecNormalize(Vec)               pVecNormalize(&(Vec))
#define VecNormalize2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))

#define pVecDot(pVec1, pVec2)                                                 \
    ((pVec1)->x * (pVec2)->x + (pVec1)->y * (pVec2)->y +                      \
     (pVec1)->z * (pVec2)->z)

#define pVecAdd(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x + (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y + (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z + (pVec2)->z)

#define pVecSub(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x - (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y - (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z - (pVec2)->z)

#define pVecScale(pVec, fScale, pRes)                                         \
    ((pRes)->x = (pVec)->x * (fScale),                                        \
     (pRes)->y = (pVec)->y * (fScale),                                        \
     (pRes)->z = (pVec)->z * (fScale))

#define pVecNeg(pVec, pRes)                                                   \
    ((pRes)->x = NEGF((pVec)->x),                                             \
     (pRes)->y = NEGF((pVec)->y),                                             \
     (pRes)->z = NEGF((pVec)->z))

#define pVecSet(pVec, fX, fY, fZ)                                             \
    ((pVec)->x = (fX), (pVec)->y = (fY), (pVec)->z = (fZ))

#define VecLenSq(Vec)                   pVecLenSq(&(Vec))
#define VecLen(Vec)                     pVecLen(&(Vec))

#ifdef _X86_

// Vector normalize through a table
void  FASTCALL TableVecNormalize(float *result, float *normal);
// Vector normalize using Jim Blinn's floating point trick
void  FASTCALL JBVecNormalize(float *result, float *normal);

#define VecNormalizeFast(Vec)          TableVecNormalize((float*)&(Vec), (float*)&(Vec))
#define VecNormalizeFast2(Vec, Res)    TableVecNormalize((float*)&(Res), (float*)&(Vec))
#define pVecNormalizeFast(Vec)         TableVecNormalize((float*)pVec, (float*)pVec)
#define pVecNormalizeFast2(pVec, pRes) TableVecNormalize((float*)pRes, (float*)pVec)

#else

#define VecNormalizeFast(Vec)               pVecNormalize((LPD3DVECTOR)&(Vec))
#define VecNormalizeFast2(Vec, Res)         pVecNormalize2((LPD3DVECTOR)&(Vec), &(Res))
#define pVecNormalizeFast(pVec)             pVecNormalize((LPD3DVECTOR)(pVec))
#define pVecNormalizeFast2(pVec, pRes)      pVecNormalize2((LPD3DVECTOR)(pVec), pRes)

#endif // _X86_

#define VecDot(Vec1, Vec2)              pVecDot(&(Vec1), &(Vec2))
#define VecAdd(Vec1, Vec2, Res)         pVecAdd(&(Vec1), &(Vec2), &(Res))
#define VecSub(Vec1, Vec2, Res)         pVecSub(&(Vec1), &(Vec2), &(Res))
#define VecScale(Vec1, fScale, Res)     pVecScale(&(Vec1), fScale, &(Res))
#define VecNeg(Vec, Res)                pVecNeg(&(Vec), &(Res))
#define VecSet(Vec, fX, fY, fZ)         pVecSet(&(Vec), fX, fY, fZ)

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by transposed 4x4 matrix, producing a
// homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4HT(D3DVECTORH *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3,
                     D3DVECTORH *plane);
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
//  4 by 4 matrix product
//
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\sources.inc ===
TARGETPATH=obj
TARGETNAME = d3dutil

TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX8)\tnl

SOURCES = \
        ..\cppdbg.cpp\
        ..\d3dflt.cpp\
        ..\d3dutil.cpp\
        ..\hrstr.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\_memalloc.c ===
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw.inc ===
UMTYPE = windows

C_DEFINES = $(C_DEFINES) /DIS_32 /DMSBUILD /DDIRECT3D_VERSION=0x800

386_STDCALL = 0

!if "$(DXROOT)" == ""
DXROOT=$(BASEDIR)\private\ntos\w32\ntgdi\direct
!endif

INCLUDES =  \
    ..;                         \
    $(DXROOT)\inc;              \
    $(DXROOT)\dxg\dd\ddraw\inc; \
    $(DXROOT)\dxg\inc;          \
    $(DXROOT)\dxg\misc;         \
    $(DXROOT)\dxg\d3d8\inc;     \
    $(BASEDIR)\public\oak\inc;  \
    $(DDK_INC_PATH);  \
    $(INCLUDES);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\win9x.inc ===
PLAT_DIR           = win9x
ALT_PROJECT_TARGET = win9x

!include ddraw.inc

# DO NOT USE MSVCRT FOR DDRAW DLL
#
# Some legacy apps have their own copy in their own
# directories.
#
# USE_CRTDLL = 1
#


USE_MAPSYM = 1

ASM_DEFINES  = $(ASM_DEFINES) /Zp4
C_DEFINES    = $(C_DEFINES) /DWIN95 /D__DD_OPT_SURFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\daytona.inc ===
PLAT_DIR           = daytona

!include ddraw.inc

USE_CRTDLL = 1

C_DEFINES = $(C_DEFINES) /DNT /DWINNT /D_NOCSECT_TYPE /D_NO_ENUM

INCLUDES = \
    $(INCLUDES);                          \
    $(BASEDIR)\public\internal\windows\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d8\util\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .list

; float __fastcall TableInvSqrt(float value);
;
; void  __fastcall TableVecNormalize(float *resultNormal, floar *normal);
;
;           resultNormal and normal could have the same address
;

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

a1  dd 0.47
a2  dd 1.47

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


__FLOAT_ONE equ 03F800000h

;----------------------------------------------------------------------
;
; float __fastcall JBInvSqrt(float x);
;
; Input:
;   esp + 4 = x
; Output:
;   result is on the floating point stack
; Algorithm:
;   The floating point trick, described in IEEE Computer Graphics and 
;   Applications v.17 number 4 in Jim Blinn's article, is used.
;
;   ONE_AS_INTEGER = 0x3F800000;
;   int   tmp = (ONE_AS_INTEGER << 1 + ONE_AS_INTEGER - *(long*)&x) >> 1;   
;   float y = *(float*)&tmp;                                             
;   result = y*(1.47f - 0.47f*x*y*y);
;
@JBInvSqrt@4 PROC NEAR
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    sub     eax, [esp+4]
    sub     esp, 4                      ; place for temporary variable "y"
    sar     eax, 1
    mov     [esp], eax                  ; y
    fld     a1
    fmul    DWORD PTR [esp+8]           ; x*0.47
    fld     DWORD PTR [esp]
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y 1.47-x*0.47*y*y
    fmulp   st(1), st(0)                ; result
    add     esp, 4
    ret     4
@JBInvSqrt@4 endp
;----------------------------------------------------------------------
; void __fastcall JBInvSqrt(float *result, float *nomal);
;
; Input:
;   ecx = address of the result
;   edx = address of the normal
;
;
@JBVecNormalize@8 PROC NEAR
    fld     DWORD PTR [edx]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 4]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 8]
    fmul    st(0), st(0)                ; z y x
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len
    sub     esp, 4                      ; Place for temporary variable "y"
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     DWORD PTR [esp]             ; Vector length
    sub     eax, [esp]
    sar     eax, 1
    mov     [esp], eax                  ; y
    fmul    a1                          ; x*0.47
    fld     DWORD PTR [esp]             ; y x*0.47
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y aaa       
    fmulp   st(1), st(0)                ; 1/sqrt(len)
    fld     DWORD PTR [edx]             ; Start normalizing the normal
    fmul    st, st(1)
    fld     DWORD PTR [edx + 4]
    fmul    st, st(2)
    fld     DWORD PTR [edx + 8]
    fmulp   st(3), st(0)                ; y x z
    fxch    st(1)
    add     esp, 4
    fstp    DWORD PTR [ecx]
    fstp    DWORD PTR [ecx + 4]
    fstp    DWORD PTR [ecx + 8]
	ret	
@JBVecNormalize@8 endp
;----------------------------------------------------------------------
; Input:
;     [esp+4] = x
;
;
x 	    equ DWORD PTR [esp + 12]
num 	equ DWORD PTR [esp]

@TableInvSqrt@4 PROC NEAR
    mov     eax, [esp + 4]          ; x
    push    ecx
    mov     ecx, eax
	sub	    esp, 4                  ; Place for num
    shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
    and     eax, CLAMP_MASK		    ;; clamp number to [0.5, 2.0]
    and     ecx, TABLE_MASK		    ;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+ecx]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, x                  ;; divide exponent by 2
    fadd    [invSqrtTab+ecx+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent
    add     esp, 4
    pop     ecx
	ret     4
@TableInvSqrt@4 endp
;----------------------------------------------------------------------
;
len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@TableVecNormalize@8 PROC NEAR
	push	ebp
	mov	    ebp, esp
	sub	    esp, 8
	fld	    DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	    DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	    DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
    mov     edi, eax
    shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
    and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
    and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+edi]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, len                ;; divide exponent by 2
    fadd    [invSqrtTab+edi+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent

	fld	    DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	    DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	    DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@TableVecNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\assert4d.cxx ===
#include "precomp.hxx"

#include "util4d.h"
#include "assert4d.h"

#ifdef	__cplusplus
extern "C" {
#endif
/****************************************************************************

	FUNCTION:   _assert

	PURPOSE:    Override system _assert function.

	RETURNS:    void

****************************************************************************/
void __stdcall _assert4d( LPTSTR condition, LPTSTR file, unsigned line)
{
	TCHAR szAssertText[512];

	//Build line, show assertion and exit program
	wsprintf(szAssertText,
			 TEXT("Assertion failed. - Line:%u, File:%s, Condition:%s"),
			 line, file, condition);

	switch (MessageBox(NULL, szAssertText, TEXT("ASSERTION FAILURE"),
					   MB_OKCANCEL | MB_ICONHAND | MB_TASKMODAL))
	{
		case IDCANCEL:
			// Cause a breakpoint so the debugger is activated.
			// I would call DebugBreak() here but the IDE gives a bogus
			// callstack if I do that.
			__asm int 3
			break;
	}
}

#ifdef	__cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\assert4d.h ===
/**************************************************************************
	Prototype COM animation system
	Debug assertion support

	1/20/94  JonBl  Created

	Copyright (c)1994 Microsoft Corporation. All Rights Reserved.
 **************************************************************************/

#ifndef _ASSERT4D_H_
#define _ASSERT4D_H_

#include "util4d.h"

#undef  assert

// debug are assertion conditions that will stay in final Release.
// If false assert Opens a fatal error message Box and Stops program

#ifdef _DEBUG

	#ifdef __cplusplus
		extern "C" {
	#endif 
	void __stdcall _assert4d(LPTSTR, LPTSTR, unsigned);
	#ifdef __cplusplus
		}
	#endif 
	
	#define assert(exp) ( (exp) ? (void) 0 : _assert4d(TEXT(#exp), TEXT(__FILE__), __LINE__) )
	#define debug(condition) assert(condition)
#else
	#define assert(exp) ((void)0)
	#define debug(condition) condition
#endif 

#endif // _ASSERT4D_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bitblt.cxx ===
///////////////////////////////////////////////////////////////////////
//
//  BitBlt.CXX - Contains the BitBlt Library functions
//
//	Copyright (c) 1994 Microsoft Corporation
//
//	Notes:
//		Conditional Compiliation Definitions:
//				DESKTOP = Penguin platform emulation on the Desktop 
//						  platform (32 bit).
//				PENGUIN = Penguin H/W platform support.
//				PULSAR  = Pulsar platform support.
//              DDRAW   = DirectDraw support
//
//	History:
//		10/18/94 - Scott Leatham Created it w/8BPP support only
//		10/26/94 - Olivier Garamfalvi Rewrote blitting code
//					                  Added SRCINVERT ROP support
//		10/30/94 - Olivier Garamfalvi Added 24 to 24 bit blitting
//		05/08/95 - Myron Thomas Added 8+Alpha to 24 bit blitting
//								Added 24+Alpha to 24 bit blitting
//		07/19/95 - Myron Thomas Ripped out SRCINVERT ROP support
//		09/05/95 - Myron Thomas Added 24P to 8 bit blitting
//              01/15/96 - Michael McDaniel changed conditional compilation
//                                      for DirectDraw
//              04/16/96 - Michael McDaniel removed FillRect's test for
//                             CLR_INVALID so Z-Buffer filling will work.
//
//
///////////////////////////////////////////////////////////////////////

#include "precomp.hxx"

#include "bltos.h"
#include "blt0101.hxx"
#include "blt0108.hxx"
#include "blt0124.hxx"
#include "blt0801.hxx"
#include "blt0808.hxx"
#include "blt0824.hxx"
#include "blt0824p.hxx"
#include "blt08a24.hxx"
#include "blt8a24p.hxx"
#include "blt1616.hxx"
#include "blt1624.hxx"
#include "blt1624p.hxx"
#include "blt2401.hxx"
#include "blt24p01.hxx"
#include "blt24p08.hxx"
#include "blt2408.hxx"
#include "blt2424.hxx"
#include "blt2424p.hxx"
#include "blt24a24.hxx"
#include "bt24a24p.hxx"
#include "bt24p24p.hxx"

#if 0
#if defined( WIN95 ) || defined(WINNT)
#define DDRAW
#endif // WIN95

#ifdef DDRAW
#if defined ( WIN95 ) && !defined( NT_BUILD_ENVIRONMENT )
    #include "..\ddraw\ddrawp.h"
#else
    /*
     * This is parsed if NT build or win95 build under NT environment
     */
    #include "..\..\ddraw\ddrawp.h"
#endif
#ifdef __cplusplus
extern "C" {
#endif // c++
#include "dpf.h"
#ifdef __cplusplus
}
#endif // c++
#endif // DDRAW
#endif

///////////////////////////////////////////////////////////////////////
//
//	Local Declarations
//
///////////////////////////////////////////////////////////////////////
void FlipRectHorizontal (RECT *rc)
{
    int			temp;

    temp = rc->right;
    rc->right = rc->left;
    rc->left = temp;
}


void FlipRectVertical (RECT *rc)
{
    int			temp;

    temp = rc->bottom;
    rc->bottom = rc->top;
    rc->top = temp;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt01to01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt01to01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iBytesPerSrcScanLine,
	iSrcBitOffset,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iDstBitOffset,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine;

    // alpha blending not currently supported in the 1 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iBytesPerSrcScanLine
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left / 8);
    iSrcBitOffset = prcSrc->left % 8;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
#if 0	// OGaramfa - bug workaround for now, Hcopy versions seem to
		//            have a problem with the last few pixels of each
		//            scanline
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt01to01_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine,
							  iNumDstCols,iNumDstRows);
		} else {
		    Blt01to01_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcRows,pbDstScanLine,iDstBitOffset,
							    iBytesPerDstScanLine * iVertMirror,
							    iNumDstCols,iNumDstRows);
		}
#else
		Blt01to01_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror);
#endif
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to01_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {

	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check what ROP we'll be performing
	if (dwRop == SRCCOPY) {
	    Blt01to01_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
					    iNumSrcCols,iNumSrcRows,
					    pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine * iVertMirror,
					    iNumDstCols,iNumDstRows,iHorizMirror,
					    bTransparentIndex);
	} else sc |= E_UNEXPECTED;		// !!!! we need better error codes

    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt01to08 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt01to08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iBytesPerSrcScanLine,
	iSrcBitOffset,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine,
	bOnColorIndex,
	bOffColorIndex;

    // alpha blending not currently supported in the 1 to 8 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // get background and foreground palette indices out of src bitmap's header
    // !!!! this is a total hack and must be fixed!
    bOffColorIndex = BlitLib_PalIndexFromRGB(
	*((COLORREF*)(pDibInfoSrc->bmiColors)),
	(COLORREF*) pDibInfoDst->bmiColors,256);
    bOnColorIndex  = BlitLib_PalIndexFromRGB(
	*((COLORREF*) (pDibInfoSrc->bmiColors) + 1),
	(COLORREF*) pDibInfoDst->bmiColors,256);

    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iBytesPerSrcScanLine
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left / 8);
    iSrcBitOffset = prcSrc->left % 8;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength =
							 DibWidthBytes(pDibInfoDst)) + prcDst->left;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt01to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  pbDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows,
							  bOffColorIndex,bOnColorIndex);
		} else {
		    Blt01to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcRows,pbDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,
							    bOffColorIndex,bOnColorIndex);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to08_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstScanLength * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror,
						  bOffColorIndex,bOnColorIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {
	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to08_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
					      iNumSrcRows,pbDstScanLine,
					      iDstScanLength * iVertMirror,
					      iNumDstCols,iNumDstRows,
					      bTransparentIndex,
					      bOffColorIndex,bOnColorIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to08_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						iNumSrcCols,iNumSrcRows,
						pbDstScanLine,iDstScanLength * iVertMirror,
						iNumDstCols,iNumDstRows,iHorizMirror,
						bTransparentIndex,
						bOffColorIndex,bOnColorIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt01to24 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt01to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE		sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iBytesPerSrcScanLine,
	iSrcBitOffset,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    DWORD		*pdDstScanLine;
    COLORREF	crOnColor,
	crOffColor;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // get background and foreground colors out of src bitmap's header
    crOffColor = *((COLORREF*) &(pDibInfoSrc->bmiColors[0]));
    crOnColor  = *((COLORREF*) &(pDibInfoSrc->bmiColors[1]));

    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iBytesPerSrcScanLine
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left / 8);
    iSrcBitOffset = prcSrc->left % 8;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength =
							  DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;
	
    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {
		
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {

	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
	
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt01to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,
								      crOffColor,crOnColor);
		    } else {
			Blt01to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows,
									crOffColor,crOnColor);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  bTransparentIndex,
							  crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    bTransparentIndex,
							    crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}

    } else {	// doing alpha blending

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {

	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							bTransparentIndex,
							arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  bTransparentIndex,
							  arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iHorizMirror = 1,
	iVertMirror = 1,
	iDstBitOffset;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine,
	bFillVal;

    // alpha blending not currently supported in the 8 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // the only ROPs supported are BLACKNESS and WHITENESS
    if (dwRop == BLACKNESS) {
	bFillVal = 0;
    } else if (dwRop == WHITENESS) {
	bFillVal = 0xFF;
    } else {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength =
							 DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// no transparency plus a constant ROP equals a rectangle fill!
	// first we have to normalize destination rectangle orientation - 
	// FillRect01() expects it
	if (BLITLIB_RECTWIDTH(prcDst) < 0) {
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	if (BLITLIB_RECTHEIGHT(prcDst) < 0) {
	    prcDst->top--;
	    prcDst->bottom--;
	    FlipRectVertical(prcDst);
	}
	sc |= BlitLib_FillRect01(pDibInfoDst,pDibBitsDst,prcDst->left,prcDst->top,
				 iNumDstCols,iNumDstRows,bFillVal);

    } else {
	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	    Blt08to01_Trans_Hcopy_ConstRop(pbSrcScanLine,iSrcScanLength,iNumSrcRows,
					   pbDstScanLine,iDstBitOffset,
					   iBytesPerDstScanLine * iVertMirror,
					   iNumDstCols,iNumDstRows,bTransparentIndex,
					   bFillVal);
	} else {
	    Blt08to01_Trans_NoHcopy_ConstRop(pbSrcScanLine,iSrcScanLength,iNumSrcCols,
					     iNumSrcRows,pbDstScanLine,iDstBitOffset,
					     iBytesPerDstScanLine * iVertMirror,
					     iNumDstCols,iNumDstRows,iHorizMirror,
					     bTransparentIndex,bFillVal);
	}
    }

    return sc;
}
#endif // DDRAW

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to08 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine;

    // alpha blending not currently supported in the 8 to 8 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }


    // If the bitmaps overlap, we need to use overlapping code
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
	return BlitLib_BitBlt08to08_Intersect(pDibInfoDst, pDibBitsDst,	prcDst,
					      pDibInfoSrc, pDibBitsSrc, prcSrc, crTransparent, dwRop);


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
							   = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							   = DibWidthBytes(pDibInfoDst)) + prcDst->left;

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
							  pbDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
		} else {
		    Blt08to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
							    iNumSrcRows,pbDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08to08_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstScanLength * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {
	// myronth -- changed for DDraw Transparent colors (always a palette index)
	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08to08_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
					      iNumSrcRows,pbDstScanLine,
					      iDstScanLength * iVertMirror,
					      iNumDstCols,iNumDstRows,
					      bTransparentIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08to08_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
						iNumSrcCols,iNumSrcRows,
						pbDstScanLine,iDstScanLength * iVertMirror,
						iNumDstCols,iNumDstRows,iHorizMirror,
						bTransparentIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to08_Intersect - 
//		BitBlit from source bitmap to destination bitmap (and these
//		bitmaps overlap each other) with optional transparency and/or
//		alpha blending using the specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to08_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
				     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
				     COLORREF crTransparent, DWORD dwRop)
{
    SCODE       sc = NOERROR;
    int         iNumSrcRows,
    iNumSrcCols,
    iSrcScanLength,
    iNumDstRows,
    iNumDstCols,
    iDstScanLength,
    iHorizMirror = 1,
    iVertMirror  = 1;
    BYTE	*pbSrcScanLine,
    *pbDstScanLine,
    *pbTempScanLine,
    bTransparentIndex;
    PDIBBITS	pDibBitsTemp;


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // We aren't currently support any ROP's besides SRCCOPY
    if(dwRop != SRCCOPY)
	return E_UNEXPECTED;


    //
    // Here are all the stretching and mirroring blits for overlapping rects
    //
	
    // REVIEW!!! -- The following code could be optimized for the caching
    // cases.  Currently, it allocates a second bitmap that is the same
    // size as the original destination, and then uses the original blit
    // rectangle to do the caching.  To save space, this blit should 
    // eventually be changed to only allocate the size of the overlapped
    // rectangle, and the blit rects should be adjusted accordingly.

    // Check if we are stretching (horiz or vert), or if we are mirroring --
    // In all of these cases, we must create a cache bitmap and double blit
    if((iNumDstCols != iNumSrcCols) || (iNumDstRows != iNumSrcRows) ||
       (iHorizMirror != 1) || (iVertMirror != 1))
    {
		
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));

        if (pDibBitsTemp == NULL)
            return E_UNEXPECTED;

	// compute pointers to the starting rows in the src and temp bitmaps
	pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
							       = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	pbTempScanLine = (BYTE*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)){

	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						      pbTempScanLine,iDstScanLength,
						      iNumDstCols,iNumDstRows);
	    } else {
		Blt08to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
							iNumSrcRows,pbTempScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows);
	    }
	}
	else
	{

	    Blt08to08_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
					      iNumSrcCols,iNumSrcRows,
					      pbTempScanLine,iDstScanLength * iVertMirror,
					      iNumDstCols,iNumDstRows,iHorizMirror);
		
        }
		
	// Recalculate the scan line pointers for the second blit

	if(BLITLIB_RECTWIDTH(prcDst) < 0){
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}

	if(BLITLIB_RECTHEIGHT(prcDst) < 0){
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}

	// compute pointers to the starting rows in the temp and dest bitmaps
	pbTempScanLine = (BYTE*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst)) + prcDst->left;
	pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							       = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID){
	    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbTempScanLine,iDstScanLength,
						  pbDstScanLine,iDstScanLength,
						  iNumDstCols,iNumDstRows);
	}
	else{
	    bTransparentIndex = (BYTE)crTransparent;
	    Blt08to08_Trans_Hcopy_SRCCOPY(pbTempScanLine,iDstScanLength,
					  iNumDstRows,pbDstScanLine,
					  iDstScanLength, iNumDstCols,
					  iNumDstRows, bTransparentIndex);
        }
		
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
	    osMemFree(pDibBitsTemp);		
		
	return sc;
    }
 	
    //
    // Here are all the non-stretching and non-mirroring blits for overlapping rects
    //

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
	    return sc;

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the bottom rect edge since we are
	    // going from bottom to top
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_LeftToRight_BottomToTop_SRCCOPY(pbSrcScanLine,
						      iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						  pbDstScanLine,iDstScanLength,
						  iNumDstCols,iNumDstRows);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the right rect edge since we are
	    // going from right to left
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + (prcSrc->right - 1);
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt08to08_RightToLeft_TopToBottom_SRCCOPY(pbSrcScanLine,
						      iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}
    }
    else{
	bTransparentIndex = (BYTE)crTransparent;
		
	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
	    return sc;

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the bottom rect edge since we are
	    // going from bottom to top
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_LeftToRight_BottomToTop_Trans_SRCCOPY(pbSrcScanLine,
							    iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, bTransparentIndex);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
					  iNumSrcRows, pbDstScanLine,
					  iDstScanLength, iNumDstCols,
					  iNumDstRows, bTransparentIndex);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the right rect edge since we are
	    // going from right to left
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + (prcSrc->right - 1);
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt08to08_RightToLeft_TopToBottom_Trans_SRCCOPY(pbSrcScanLine,
							    iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, bTransparentIndex);
	}
    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    DWORD		*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength =
							 DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength =
							  DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine,
	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE *) pDibBitsSrc + prcSrc->top * (iSrcScanLength =
							  DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength =
							  DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pdDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08Ato24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08Ato24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    DWORD		*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired
// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
		BYTE bTransparentIndex = (BYTE)crTransparent;
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08Ato24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08Ato24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    BYTE		*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
									pdDstScanLine,iDstScanLength,
									iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									  iNumSrcRows,pdDstScanLine,
									  iDstScanLength * iVertMirror,
									  iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
								iNumSrcCols,iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24P_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							    iNumSrcRows,pdDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,
							    bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24P_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired
// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
		BYTE bTransparentIndex = (BYTE)crTransparent;
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08Ato08A - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency using the
//		specified raster operation.
//
//		This blit is special because it uses the 16to16 blits for
//		all of it's non-transparent color blits.  This can be
//		accomplished because we are ignoring the 8-bit alpha channel
//		and just copying 16 bits to the destination.  For the blits
//		with a transparent color, new functions are called which check
//		for only a transparent color palette index (8 bits) and then
//		copies 16 bits where the color doesn't match. This is a COPY
//		ONLY blit, thus, it does NOT do any alpha blending.
//
//		Note: The 08Ato08A routines are located with the other 16to16
//		blits because it is just an extension of them.  (These currently
//		reside in blt1616.cxx).
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08Ato08A(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine,
	*pwDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pwDstScanLine = (WORD*) pDibBitsDst + prcDst->top *	(iDstScanLength
							 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

    // Make sure we are not doing any blending. This is ONLY a copy blit!
    if (arAlpha != ALPHA_INVALID)
	return E_INVALIDARG;
			
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {
		
	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
		
	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								  pwDstScanLine,iDstScanLength,
								  iNumDstCols,iNumDstRows);
		} else {
		    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
								    iNumSrcRows,pwDstScanLine,
								    iDstScanLength * iVertMirror,
								    iNumDstCols,iNumDstRows);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pwDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } 
    else {	// transparency desired
		
	BYTE bTransparentColor = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08Ato08A_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							iNumSrcRows,pwDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							bTransparentColor);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08Ato08A_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pwDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  bTransparentColor);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }
    return sc;
}
#endif // DDRAW

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to16 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to16(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine,
	*pwDstScanLine;


    // If the bitmaps overlap, we need to use overlapping code
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
	return BlitLib_BitBlt16to16_Intersect(pDibInfoDst, pDibBitsDst,	prcDst,
					      pDibInfoSrc, pDibBitsSrc, prcSrc, crTransparent, dwRop);

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pwDstScanLine = (WORD*) pDibBitsDst + prcDst->top *	(iDstScanLength
							 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								      pwDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows);
		    } else {
			Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
									iNumSrcRows,pwDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pwDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {	// transparency desired
			
	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pwDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  wTransparentColor);
		} 
                else 
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pwDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    }
#ifndef DDRAW
#ifndef WIN95
    else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
                   
		    Blt16to16_Blend_NoTrans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pwDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_Blend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pwDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 	// transparency desired

	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_Blend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							iNumSrcRows,pwDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_Blend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pwDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }
#endif
#endif
    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to16_Intersect - 
//		BitBlit from source bitmap to destination bitmap (and these
//		bitmaps overlap each other) with optional transparency
//		using the specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to16_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
				     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
				     COLORREF crTransparent, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine,
	*pwDstScanLine,
	*pwTempScanLine,
	wTransparentIndex;
    PDIBBITS	pDibBitsTemp;


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // We aren't currently support any ROP's besides SRCCOPY
    if(dwRop != SRCCOPY)
	return E_UNEXPECTED;


    //
    // Here are all the stretching and mirroring blits for overlapping rects
    //
	
    // REVIEW!!! -- The following code could be optimized for the caching
    // cases.  Currently, it allocates a second bitmap that is the same
    // size as the original destination, and then uses the original blit
    // rectangle to do the caching.  To save space, this blit should 
    // eventually be changed to only allocate the size of the overlapped
    // rectangle, and the blit rects should be adjusted accordingly.
	
    // Check if we are stretching (horiz or vert), or if we are mirroring --
    // In all of these cases, we must create a cache bitmap and double blit
    if((iNumDstCols != iNumSrcCols) || (iNumDstRows != iNumSrcRows) ||
       (iHorizMirror != 1) || (iVertMirror != 1))
    {
		
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));

        if (pDibBitsTemp == NULL)
            return E_UNEXPECTED;

	// compute pointers to the starting rows in the src and temp bitmaps
	pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
							       = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	pwTempScanLine = (WORD*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1))
	{

	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
	    {
		Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
							      pwTempScanLine,iDstScanLength,
							      iNumDstCols,iNumDstRows);
	    } 
	    else 
	    {
		Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
								iNumSrcRows,pwTempScanLine,
								iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows);
	    }
	}
        else
        {
	    Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
						      iNumSrcCols,iNumSrcRows,
		    	                              pwTempScanLine,iDstScanLength * iVertMirror,
						      iNumDstCols,iNumDstRows,iHorizMirror);
	}
		

	// Recalculate the scan line pointers for the second blit

	if(BLITLIB_RECTWIDTH(prcDst) < 0)
	{
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}

	if(BLITLIB_RECTHEIGHT(prcDst) < 0)
	{
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}

	// compute pointers to the starting rows in the temp and dest bitmaps
	pwTempScanLine = (WORD*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;
	pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							       = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID)
	{
	    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwTempScanLine,iDstScanLength,
							  pwDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
	}
	else
	{
	    wTransparentIndex = (WORD)crTransparent;

	    Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(pwTempScanLine,iDstScanLength,
						  iNumDstRows,pwDstScanLine,
						  iDstScanLength, iNumDstCols,
						  iNumDstRows, wTransparentIndex);
	}
		
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
	    osMemFree(pDibBitsTemp);		
		
	return sc;
    }
 	
    //
    // Here are all the non-stretching and non-mirroring blits for overlapping rects
    //

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
        {
	    return sc;
        }

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top)
	{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_LeftToRight_BottomToTop_SRCCOPY(pwSrcScanLine,
						      iSrcScanLength,	pwDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
							  pwDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + (prcSrc->right - 1);
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt16to16_RightToLeft_TopToBottom_SRCCOPY(pwSrcScanLine,
						      iSrcScanLength,	pwDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}
    }
    else{
	wTransparentIndex = (WORD)crTransparent;
		
	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
	    return sc;

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_LeftToRight_BottomToTop_Trans_SRCCOPY(pwSrcScanLine,
							    iSrcScanLength, pwDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, wTransparentIndex);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
						  iNumSrcRows,pwDstScanLine,
						  iDstScanLength, iNumDstCols,iNumDstRows,
						  wTransparentIndex);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + (prcSrc->right - 1);
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt16to16_RightToLeft_TopToBottom_Trans_SRCCOPY(pwSrcScanLine,
							    iSrcScanLength, pwDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, wTransparentIndex);
	}
    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine;
    DWORD	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt16to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows);
		    } else {
			Blt16to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {	// transparency desired
			
	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_NoTrans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 	// transparency desired

	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine;
    BYTE	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD *) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt16to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows);
		    } else {
			Blt16to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {	// transparency desired
			
	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_NoTrans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 	// transparency desired

	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pdDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iHorizMirror = 1,
	iVertMirror = 1,
	iDstBitOffset;
    DWORD	*pdSrcScanLine;
    BYTE	*pbDstScanLine,
	bFillVal;

    // alpha blending not currently supported in the 24 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // the only ROPs supported are BLACKNESS and WHITENESS
    if (dwRop == BLACKNESS) {
	bFillVal = 0;
    } else if (dwRop == WHITENESS) {
	bFillVal = 0xFF;
    } else {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// no transparency plus a constant ROP equals a rectangle fill!
	// first we have to normalize dst rect orientation
	// - FillRect01() expects it
	if (BLITLIB_RECTWIDTH(prcDst) < 0) {
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	if (BLITLIB_RECTHEIGHT(prcDst) < 0) {
	    prcDst->top--;
	    prcDst->bottom--;
	    FlipRectVertical(prcDst);
	}
	sc |= BlitLib_FillRect01(pDibInfoDst,pDibBitsDst,prcDst->left,prcDst->top,
				 iNumDstCols,iNumDstRows,bFillVal);

    } else {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	    Blt24to01_Trans_Hcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcRows,
					   pbDstScanLine,iDstBitOffset,
					   iBytesPerDstScanLine * iVertMirror,
					   iNumDstCols,iNumDstRows,crTransparent,
					   bFillVal);
	} else {
	    Blt24to01_Trans_NoHcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcCols,
					     iNumSrcRows,pbDstScanLine,iDstBitOffset,
					     iBytesPerDstScanLine * iVertMirror,
					     iNumDstCols,iNumDstRows,iHorizMirror,
					     crTransparent,bFillVal);
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iHorizMirror = 1,
	iVertMirror = 1,
	iDstBitOffset;
    BYTE	*pdSrcScanLine;
    BYTE	*pbDstScanLine,
	bFillVal;

    // alpha blending not currently supported in the 24 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // the only ROPs supported are BLACKNESS and WHITENESS
    if (dwRop == BLACKNESS) {
	bFillVal = 0;
    } else if (dwRop == WHITENESS) {
	bFillVal = 0xFF;
    } else {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// no transparency plus a constant ROP equals a rectangle fill!
	// first we have to normalize dst rect orientation
	// - FillRect01() expects it
	if (BLITLIB_RECTWIDTH(prcDst) < 0) {
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	if (BLITLIB_RECTHEIGHT(prcDst) < 0) {
	    prcDst->top--;
	    prcDst->bottom--;
	    FlipRectVertical(prcDst);
	}
	sc |= BlitLib_FillRect01(pDibInfoDst,pDibBitsDst,prcDst->left,prcDst->top,
				 iNumDstCols,iNumDstRows,bFillVal);

    } else {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	    Blt24Pto01_Trans_Hcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcRows,
					    pbDstScanLine,iDstBitOffset,
					    iBytesPerDstScanLine * iVertMirror,
					    iNumDstCols,iNumDstRows,crTransparent,
					    bFillVal);
	} else {
	    Blt24Pto01_Trans_NoHcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcCols,
					      iNumSrcRows,pbDstScanLine,iDstBitOffset,
					      iBytesPerDstScanLine * iVertMirror,
					      iNumDstCols,iNumDstRows,iHorizMirror,
					      crTransparent,bFillVal);
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to08 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE		sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD		*pdSrcScanLine;
    BYTE		*pbDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength
							 = DibWidthBytes(pDibInfoDst)) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24to08_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								      pbDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    } else {
			Blt24to08_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									iNumSrcRows,pbDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pbDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pbDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pbDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pbDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pbDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							iNumSrcRows,pbDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pbDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto08 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE		sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    BYTE		*pbDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength
							 = DibWidthBytes(pDibInfoDst)) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24Pto08_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								       pbDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    } else {
			Blt24Pto08_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pbDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pbDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pbDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pbDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pbDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pbDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pbDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pbDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}
#endif // DDRAW


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine,
	*pdDstScanLine,
	*pdTempScanLine;
    PDIBBITS pDibBitsTemp;

    if(dwRop != SRCCOPY)
        return DDERR_INVALIDPARAMS;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }

    // Handle intersecting blits in a completely unintelegent manner.
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
    {
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));
	if(pDibBitsTemp == NULL)
	    return DDERR_OUTOFMEMORY;

	// compute pointers to the starting rows in the src and temp bitmaps
	pdSrcScanLine = (DWORD *) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								 = DibWidthBytes(pDibInfoSrc)/4) + prcSrc->left;
	pdTempScanLine = (DWORD *) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)/4) + prcDst->left;
	    
	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1))
	{
		
	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
	    {
		Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
							      pdTempScanLine,iDstScanLength,
							      iNumDstCols,iNumDstRows);
	    } 
	    else 
	    {
		Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
								iNumSrcRows,pdTempScanLine,
								iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows);
	    }
	}
	else
	{
	    Blt24to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
						      iNumSrcCols,iNumSrcRows,
						      pdTempScanLine,iDstScanLength * iVertMirror,
						      iNumDstCols,iNumDstRows,iHorizMirror);
	}
	    
	    
	// Recalculate the scan line pointers for the second blit
	    
	if(BLITLIB_RECTWIDTH(prcDst) < 0)
	{
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	    
	if(BLITLIB_RECTHEIGHT(prcDst) < 0)
	{
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}
	    
	// compute pointers to the starting rows in the temp and dest bitmaps
	pdTempScanLine = (DWORD*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								  = DibWidthBytes(pDibInfoDst)/4) + prcDst->left;
	pdDstScanLine = (DWORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								= DibWidthBytes(pDibInfoDst)/4) + prcDst->left;
	    
	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID)
	{
	    Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdTempScanLine,iDstScanLength,
							  pdDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
	}
	else
	{
	    Blt24to24_NoBlend_Trans_Hcopy_SRCCOPY(pdTempScanLine,iDstScanLength,
						  iNumDstRows,pdDstScanLine,
						  iDstScanLength,
						  iNumDstCols,iNumDstRows,
						  crTransparent);
	}
	    
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
	{
	    osMemFree(pDibBitsTemp);
	}
	pDibBitsTemp = NULL;
	return sc;
    }
	
    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;
	
    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) 
    {		// no blending desired
	    
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
	{
		
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
		{
			
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
		    {
			Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows);
		    } 
		    else // must stretch/mirror vertically
		    {
			Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows);
		    }
		} 
		else // not SRCCOPY
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    } 
	    else // must stretch/mirror horizontally
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
		{
		    Blt24to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror);
		} 
		else // not SRCCOPY
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    }
	} 
	else // transparent blit
	{
		
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
		{
		    Blt24to24_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  crTransparent);
		} 
		else // not SRCCOPY
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    } 
	    else // must stretch/mirror horizontally
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    crTransparent);
		} 
		else // not srccopy
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    }
	}
    } 
    else // blending desired
    {		
#ifdef DDRAW
	return E_UNEXPECTED;
#else
	    
	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) 
        {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } 
            else // must mirror/stretch horizontally
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} 
        else // transparent blit
        { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							crTransparent,arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } 
            else // must stretch/mirror horizontally
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  crTransparent,arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
#endif /* !DDRAW */
    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine;
    BYTE	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows);
		    } else {
			Blt24to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pdDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}
#endif // DDRAW

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pdSrcScanLine;
    BYTE	*pdDstScanLine;


    // If the bitmaps overlap, we need to use overlapping code
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
	return BlitLib_BitBlt24Pto24P_Intersect(pDibInfoDst, pDibBitsDst, prcDst,
						pDibInfoSrc, pDibBitsSrc, prcSrc, crTransparent, arAlpha, dwRop);

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) 
    {		// no blending desired
		
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			// This is the 8->8 blit with 3 times as many columns
			Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
							      pdDstScanLine,iDstScanLength,
							      iNumDstCols * 3,iNumDstRows);
		    } 
                    else // must stretch/mirror vertically
                    {
			Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									  iNumSrcRows,pdDstScanLine,
									  iDstScanLength * iVertMirror,
									  iNumDstCols,iNumDstRows);

		    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// non-SRCCOPY unsupported!!!! we need better error codes
		
	    } 
            else // must stretch/mirror horizontally (and maybe vertically)
            {
		if (dwRop == SRCCOPY) 
                {
		    Blt24Pto24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
								iNumSrcCols,iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,iHorizMirror);
		} 
                else 
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	} 
        else // Transparent blt
        { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY_VCopy(pdSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,
								      crTransparent);
		    } 
                    else // must stretch/mirror vertically
                    {
			Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
								iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,
								crTransparent);
                    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } 
            else // must stretch/mirror horizontally and maybe vertically
            {
                // check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24Pto24P_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      crTransparent);

                }
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes

            }
	}
    } 
    else // blending desired
    {		
#ifdef DDRAW
	return E_UNEXPECTED;
#else
	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) 
        {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			Blt24Pto24P_Blend_NoTrans_Hcopy_SRCCOPY_VCopy(pdSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,
								      arAlpha);
		    } 
                    else // must stretch/mirror vertically
                    {
			sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } 
            else // must mirror/stretch horizontally
            {
	
		sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} 
        else // transparent blit
        { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			Blt24Pto24P_Blend_Trans_Hcopy_SRCCOPY_VCopy(pdSrcScanLine,iSrcScanLength,
								    pdDstScanLine,iDstScanLength,
								    iNumDstCols,iNumDstRows,
								    crTransparent,arAlpha);
		    } 
                    else // must stretch/mirror vertically
                    {
			sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } 
            else // must stretch/mirror horizontally
            {
                sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
#endif
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto24P_Intersect - 
//		BitBlit from source bitmap to destination bitmap (and these
//		bitmaps overlap each other) with optional transparency and/or
//		alpha blending using the specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto24P_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
				       PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
				       COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine,
	*pbTempScanLine;
    PDIBBITS	pDibBitsTemp;


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // We aren't currently support any ROP's besides SRCCOPY
    if(dwRop != SRCCOPY)
	return E_UNEXPECTED;

	
    //
    // Here are all the stretching and mirroring blits for overlapping rects
    //
	
    // REVIEW!!! -- The following code could be optimized for the caching
    // cases.  Currently, it allocates a second bitmap that is the same
    // size as the original destination, and then uses the original blit
    // rectangle to do the caching.  To save space, this blit should 
    // eventually be changed to only allocate the size of the overlapped
    // rectangle, and the blit rects should be adjusted accordingly.
	
    // Check if we are stretching (horiz or vert), or if we are mirroring --
    // In all of these cases, we must create a cache bitmap and double blit
    if((iNumDstCols != iNumSrcCols) || (iNumDstRows != iNumSrcRows) ||
       (iHorizMirror != 1) || (iVertMirror != 1))
    {
		
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));
        if(pDibBitsTemp == NULL)
            return DDERR_OUTOFMEMORY;
	// compute pointers to the starting rows in the src and temp bitmaps
	pbSrcScanLine = (BYTE *) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								= DibWidthBytes(pDibInfoSrc)) + prcSrc->left*3;
	pbTempScanLine = (BYTE *) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								  = DibWidthBytes(pDibInfoDst)) + prcDst->left*3;

	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1))
	{

	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
	    {
		Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						      pbTempScanLine,iDstScanLength,
						      iNumDstCols*3,iNumDstRows);
	    } 
	    else 
	    {
		Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
								  iNumSrcRows,pbTempScanLine,
								  iDstScanLength * iVertMirror,
								  iNumDstCols,iNumDstRows);
	    }
	}
        else
        {
	    Blt24Pto24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							iNumSrcCols,iNumSrcRows,
							pbTempScanLine,iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,iHorizMirror);	
        }
		

	// Recalculate the scan line pointers for the second blit

	if(BLITLIB_RECTWIDTH(prcDst) < 0)
	{
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}

	if(BLITLIB_RECTHEIGHT(prcDst) < 0)
	{
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}

	// compute pointers to the starting rows in the temp and dest bitmaps
	pbTempScanLine = (BYTE*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst)) + prcDst->left*3;
	pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							       = DibWidthBytes(pDibInfoDst)) + prcDst->left*3;

	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID)
	{
	    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbTempScanLine,iDstScanLength,
						  pbDstScanLine,iDstScanLength,
						  3*iNumDstCols,iNumDstRows);
	}
	else
	{
	    Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY(pbTempScanLine,iDstScanLength,
						    iNumDstRows,pbDstScanLine,
						    iDstScanLength, iNumDstCols,
						    iNumDstRows, crTransparent);
	}
		
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
        {
	    osMemFree(pDibBitsTemp);
        }
        pDibBitsTemp = NULL;
		
	return sc;
    }

    //
    // Here are all the non-stretching and non-mirroring blits for overlapping rects
    //

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) 
    {		// no blending desired

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt08to08_LeftToRight_BottomToTop_SRCCOPY(pbSrcScanLine,
							  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols * 3,
							  iNumDstRows);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						      pbDstScanLine,iDstScanLength,
						      iNumDstCols * 3,iNumDstRows);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (((prcSrc->right - 1) * 3) + 2);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (((prcDst->right - 1) * 3) + 2);

		//  Call the appropriate blit
		Blt08to08_RightToLeft_TopToBottom_SRCCOPY(pbSrcScanLine,
							  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols * 3,
							  iNumDstRows);
	    }
	}
	else // transparent blt
        {
	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_LeftToRight_BottomToTop_Trans_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, crTransparent);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY_VCopy(pbSrcScanLine,iSrcScanLength,
							      pbDstScanLine,
							      iDstScanLength, iNumDstCols,
							      iNumDstRows, crTransparent);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + ((prcSrc->right - 1) * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + ((prcDst->right - 1) * 3);

		//  Call the appropriate blit
		Blt24Pto24P_RightToLeft_TopToBottom_Trans_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, crTransparent);
	    }
	}
    }
    else
    {	// We're doing alpha blending
#ifdef DDRAW
	return E_UNEXPECTED;
#else
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {

	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_LeftToRight_BottomToTop_Alpha_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, arAlpha);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_Blend_NoTrans_Hcopy_SRCCOPY_VCopy(pbSrcScanLine,iSrcScanLength,
							      pbDstScanLine,iDstScanLength,
							      iNumDstCols,iNumDstRows,arAlpha);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + ((prcSrc->right - 1) * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + ((prcDst->right - 1) * 3);

		//  Call the appropriate blit
		Blt24Pto24P_RightToLeft_TopToBottom_Alpha_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, arAlpha);
	    }
	}
	else
        {
	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_LeftToRight_BottomToTop_Trans_Alpha_SRCCOPY(pbSrcScanLine,
									iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
									iNumDstRows, crTransparent, arAlpha);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_Blend_Trans_Hcopy_SRCCOPY_VCopy(pbSrcScanLine,iSrcScanLength,
							    pbDstScanLine,
							    iDstScanLength, iNumDstCols,
							    iNumDstRows, crTransparent, arAlpha);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + ((prcSrc->right - 1) * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + ((prcDst->right - 1) * 3);

		//  Call the appropriate blit
		Blt24Pto24P_RightToLeft_TopToBottom_Trans_Alpha_SRCCOPY(pbSrcScanLine,
									iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
									iNumDstRows, crTransparent, arAlpha);
	    }
	}
#endif /* !DDRAW */
    }
    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Ato24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Ato24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine,
	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows);
		    } else {
			Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Ato24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Ato24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine;
    BYTE	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
									pdDstScanLine,iDstScanLength,
									iNumDstCols,iNumDstRows);
		    } else {
			Blt24Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									  iNumSrcRows,pdDstScanLine,
									  iDstScanLength * iVertMirror,
									  iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
								iNumSrcCols,iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24P_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcRows,pdDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,
							    crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24P_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Ato24A - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
//		This blit is special because it uses the regular 24to24 blits
//		to do all of its work.  This blit is a COPY ONLY blit, thus,
//		it does NOT do any alpha blending.  However, it does copy the
//		alpha channel value for each pixel to the destination.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Ato24A(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine,
	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // Make sure we are not trying to alpha blend.  This is a COPY ONLY blit
    if (arAlpha != ALPHA_INVALID)
	return E_INVALIDARG;
			
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {
		
	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
		
	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								   pdDstScanLine,iDstScanLength,
								   iNumDstCols,iNumDstRows);
		} else {
		    Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
								     iNumSrcRows,pdDstScanLine,
								     iDstScanLength * iVertMirror,
								     iNumDstCols,iNumDstRows);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt24Ato24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt24Ato24_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
						       iNumSrcRows,pdDstScanLine,
						       iDstScanLength * iVertMirror,
						       iNumDstCols,iNumDstRows,
						       crTransparent);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt24Ato24_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							 iNumSrcCols,iNumSrcRows,
							 pdDstScanLine,iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,iHorizMirror,
							 crTransparent);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }

    return sc;
}
#endif // DDRAW


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect01 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	BYTE crValue	- Color index
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
static const BYTE bTopMask[8]    = {0x00, 0x80, 0xC0, 0xE0, 
                                    0xF0, 0xF8, 0xFC, 0xFE}; 
static const BYTE bBottomMask[8] = {0xFF, 0x7F, 0x3F, 0x1F, 
                                    0x0F, 0x07, 0x03, 0x01};

SCODE BlitLib_FillRect01(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, BYTE crValue)
{
    SCODE 	sc = NOERROR;
    long	DstDeltaScan,
	WidthBytes;
    int		y,
	iPixelOffset,
	iStartPixels,
	iFullBytes,
	iEndPixels;
    BYTE	*pbDst,
	*pbEndDst,
	*pbDstScanline = (BYTE*) 0,
	bFillVal;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst);
    WidthBytes = DstDeltaScan;

    // Calculate the starting pixel address
    pbDstScanline = (BYTE*) pDst + XDst / 8 + YDst * WidthBytes;
    iPixelOffset = XDst % 8;

    // set up memory fill value
    if (crValue) {
	bFillVal = 0xFF;
    } else {
	bFillVal = 0;
    }

    // calculate how many bits of first byte we have to set, how many
    // full bytes to set, and how many bits of last byte to set on
    // each scanline
    if (iPixelOffset) {
	iStartPixels = 8 - iPixelOffset;
	iFullBytes = (nWidthDst - iStartPixels) / 8;
	iEndPixels = (nWidthDst - iStartPixels) % 8;
    } else {
	iStartPixels = 0;
	iFullBytes = nWidthDst / 8;
	iEndPixels = nWidthDst % 8;
    }		

    // loop to fill one scanline at a time
    for (y = 0; y < nHeightDst; y++) {

	// set pointer to beginning of scanline
	pbDst = pbDstScanline;

	// take care of pixels lying on a byte not entirely
	// in the scanline
	if (iStartPixels) {
	    if (nWidthDst >= iStartPixels) {
		if (bFillVal) {
		    *pbDst++ |= bBottomMask[iPixelOffset];
		} else {
		    *pbDst++ &= bTopMask[iPixelOffset];
		}
	    } else {
		if (bFillVal) {
		    *pbDst++ |= (bBottomMask[iPixelOffset] & 
				 bTopMask[iPixelOffset + nWidthDst]);
		} else {
		    *pbDst++ &= (bTopMask[iPixelOffset] | 
				 bBottomMask[iPixelOffset + nWidthDst]);
		}
	    }
	}

	// fill bytes filled entirely with pixels to be set
	pbEndDst = pbDst + iFullBytes;
	for (; pbDst != pbEndDst; pbDst++) {
	    *pbDst = bFillVal;
	}

	// take care of pixels hanging off other end into byte
	// not entirely on scanline
	if (iEndPixels) {
	    if (bFillVal) {
		*pbDst |= bTopMask[iEndPixels];
	    } else {
		*pbDst &= bBottomMask[iEndPixels];
	    }
	}
				
	pbDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect08 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	BYTE crValue	- Color index
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect08(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, BYTE crValue)
{
    DWORD	*pBigDstPixel,
	*pBigEndDstPixel;
    BYTE	*pDstScanline,
	*pDstPixel = (BYTE *)pDst,
	*pAlignedDstPixel;
    int		iNumDwordsPerLine = nWidthDst / 4,
	iNumBytesLeftDst = nWidthDst % 4,
	iNumUnalignedDstBytes = 0,
	i,j,
	iDstDeltaScan;
    register DWORD	dwValue = (DWORD)(crValue | (crValue << 8) | (crValue << 16) | (crValue <<24));


    // Calculate the delta scan amount
    iDstDeltaScan = (long)(pbiDst->bmiHeader.biWidth) * 8;
    iDstDeltaScan = ((iDstDeltaScan + 31) & (~31)) / 8;

    // Calculate the starting pixel address
    pDstScanline = (BYTE *)pDst + XDst + YDst * iDstDeltaScan;

    // If the num dwords per line is less than 0, then we will just
    // do a byte wise fill for the < 4 bytes
    if(iNumDwordsPerLine){
	// Find out if the src and dest pointers are dword aligned
	pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanline) + 3) & (~3));
	iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanline);

	// Now decrement the number of dwords per line and the
	// number of bytes left over as appropriate
	if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
	    iNumBytesLeftDst -= iNumUnalignedDstBytes;
	else{
	    iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
	    if(iNumBytesLeftDst != sizeof(DWORD))
		iNumDwordsPerLine--;
	}
    }

    // Do the fill
    for (i = 0; i < nHeightDst; i++) {
	// Set up the first pointer
	pDstPixel = pDstScanline;
	
	// First we need to copy the bytes to get to an aligned dword
	for(j=0; j<iNumUnalignedDstBytes; j++)
	    *pDstPixel++ = crValue;

	// set up pointers to the first 4-pixel chunks
	// on src and dst scanlines, and last chunk on
	// dst scanline
	pBigDstPixel = (DWORD*) pDstPixel;
	pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

	// copy scanline one 4-pixel chunk at a time
	while (pBigDstPixel != pBigEndDstPixel) {
	    *pBigDstPixel++ = dwValue;
	}

	// take care of remaining pixels on scanline
	if (iNumBytesLeftDst) {
	    pDstPixel = (BYTE*) pBigDstPixel;
	    for(j=0; j<iNumBytesLeftDst; j++){
		*pDstPixel++ = crValue;
	    }
	}

	// advance to next scanline
	pDstScanline += iDstDeltaScan;
    }

    return NO_ERROR;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect16 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	WORD crValue - ColorRef value (RGB 5-6-5)
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect16(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, WORD crValue)
{
    DWORD	*pBigDstPixel,
	*pBigEndDstPixel;
    WORD	*pDstScanline,
	*pDstPixel = (WORD *)pDst,
	*pAlignedDstPixel;
    int		iNumDwordsPerLine = nWidthDst / 2,
	iNumWordsLeftDst = nWidthDst % 2,
	iNumUnalignedDstWords = 0,
	i,j,
	iDstDeltaScan;
    register DWORD	dwValue = (DWORD)(crValue | (crValue << 16));


    // Calculate the delta scan amount
    iDstDeltaScan = (long)(pbiDst->bmiHeader.biWidth) * 16;
    iDstDeltaScan = ((iDstDeltaScan + 31) & (~31)) / 16;

    // Calculate the starting pixel address
    pDstScanline = (WORD *)pDst + XDst + YDst * iDstDeltaScan;

    // If the num dwords per line is less than 0, then we will just
    // do a word wise fill for the single pixel
    if(iNumDwordsPerLine){
	// Find out if the dest pointer is dword aligned
	pAlignedDstPixel = (WORD *)((((ULONG_PTR)pDstScanline) + 3) & (~3));
	iNumUnalignedDstWords = (int)(pAlignedDstPixel - pDstScanline);


	// Now decrement the number of dwords per line and the
	// number of bytes left over as appropriate
	if(iNumUnalignedDstWords <= iNumWordsLeftDst)
	    iNumWordsLeftDst -= iNumUnalignedDstWords;
	else{
	    iNumWordsLeftDst = (sizeof(DWORD)/2) - iNumUnalignedDstWords;
	    if(iNumWordsLeftDst != (sizeof(DWORD)/2))
		iNumDwordsPerLine--;
	}
    }


    // Do the fill
    for (i = 0; i < nHeightDst; i++) {
	// Set up the first pointer
	pDstPixel = pDstScanline;
	
	// First we need to copy the bytes to get to an aligned dword
	for(j=0; j<iNumUnalignedDstWords; j++)
	    *pDstPixel++ = crValue;

	// set up pointers to the first 4-pixel chunks
	// on src and dst scanlines, and last chunk on
	// dst scanline
	pBigDstPixel = (DWORD*) pDstPixel;
	pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

	// copy scanline one 4-pixel chunk at a time
	while (pBigDstPixel != pBigEndDstPixel) {
	    *pBigDstPixel++ = dwValue;
	}

	// take care of remaining pixels on scanline
	if (iNumWordsLeftDst) {
	    pDstPixel = (WORD *) pBigDstPixel;
	    for(j=0; j<iNumWordsLeftDst; j++){
		*pDstPixel++ = crValue;
	    }
	}

	// advance to next scanline
	pDstScanline += iDstDeltaScan;
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect24 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	RGBTRIPLE rgb	- RGBTRIPLE representing the fill color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect24(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, DWORD rgb)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    char *pDstScanline = NULL;
    int x = 0;
    int y = 0;
    RGBTRIPLE *pDstPixel;
    RGBTRIPLE *pEndPixel;
    RGBTRIPLE rgbt;
    DWORD d1,d2,d3;

    // Set up rgbt (ignore the color names - they are meaningless)
    rgbt.rgbtBlue = (BYTE)(rgb & 0x0000ff); 
    rgbt.rgbtGreen = (BYTE)((rgb & 0x00ff00) >> 8);
    rgbt.rgbtRed = (BYTE)((rgb & 0xff0000) >> 16);

    // Calculate the number of pixels per scan line
    DstDeltaScan = DibWidthBytes(pbiDst);
	

    // Calculate the starting pixel address
    pDstScanline = ((char*)pDst) + (XDst*sizeof(RGBTRIPLE) + YDst * DstDeltaScan);

    // Set up aligned stores
    d1 = rgb | (rgb << 24);
    d2 = (rgb << 16) | (rgb >> 8);
    d3 = (rgb << 8) | (rgb >> 16);

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = (RGBTRIPLE*)pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

    while ( ((ULONG_PTR)pDstPixel & 0x03) && (pDstPixel < pEndPixel) )
	{
	    ((BYTE*)pDstPixel)[0] = ((BYTE*)&rgbt)[0];
	    ((BYTE*)pDstPixel)[1] = ((BYTE*)&rgbt)[1];
	    ((BYTE*)pDstPixel)[2] = ((BYTE*)&rgbt)[2];
	    pDstPixel++;
	}

	while (((ULONG_PTR)pDstPixel) <= (((ULONG_PTR)(pEndPixel-4)) & ~0x03))
	{
	    *(((DWORD*)pDstPixel)) = d1;
	    *(((DWORD*)pDstPixel)+1) = d2;
	    *(((DWORD*)pDstPixel)+2) = d3;
	    pDstPixel +=4;
	}

	while (pDstPixel < pEndPixel)
	{
	    ((BYTE*)pDstPixel)[0] = ((BYTE*)&rgbt)[0];
	    ((BYTE*)pDstPixel)[1] = ((BYTE*)&rgbt)[1];
	    ((BYTE*)pDstPixel)[2] = ((BYTE*)&rgbt)[2];
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect32 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect32(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, DWORD crValue)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    long WidthDWords;
    DWORD *pDstScanline = (DWORD *) 0;
    int y = 0;
    DWORD *pDstPixel;
    DWORD *pEndPixel;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst) >> 2; // don't trust the compile to deal with "/4"
    WidthDWords = DstDeltaScan;

    // Calculate the starting pixel address
    pDstScanline = (DWORD *)pDst + XDst + YDst * WidthDWords;

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

	while (pDstPixel < pEndPixel)
	{
	    *pDstPixel = crValue;
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_WriteMaskFillRect32 - 
//   Fill a rectangle in the specified DIB with the desired color using a writemask
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//      dwWriteMask - write only those pixel bits that are turned on
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_WriteMaskFillRect32(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, DWORD crValue,DWORD dwWriteMask)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    long WidthDWords;
    DWORD *pDstScanline = (DWORD *) 0;
    int y = 0;
    DWORD *pDstPixel;
    DWORD *pEndPixel;
    DWORD dwInvWriteMask;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst) >> 2; // don't trust the compiler to deal with "/4"
    WidthDWords = DstDeltaScan;

    // Calculate the starting pixel address
    pDstScanline = (DWORD *)pDst + XDst + YDst * WidthDWords;

    crValue&=dwWriteMask;  // turn off bits in fill value that wont be used
    dwInvWriteMask= ~dwWriteMask;  // will turn off bits to be overwritten in DstPixel 

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

	while (pDstPixel < pEndPixel)
	{
	    *pDstPixel = (*pDstPixel & dwInvWriteMask) | crValue;
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_WriteMaskFillRect16 - 
//   Fill a rectangle in the specified DIB with the desired color using a writemask
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//      wWriteMask - write only those pixel bits that are turned on
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_WriteMaskFillRect16(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, WORD crValue,WORD wWriteMask)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    long WidthDWords;
    WORD *pDstScanline = (WORD *) 0;
    int y = 0;
    WORD *pDstPixel;
    WORD *pEndPixel;
    WORD wInvWriteMask;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst) >> 1; // don't trust the compiler to deal with "/2"
    WidthDWords = DstDeltaScan;

    // Calculate the starting pixel address
    pDstScanline = (WORD *)pDst + XDst + YDst * WidthDWords;

    crValue &= wWriteMask;  // turn off bits in fill value that wont be used
    wInvWriteMask= ~wWriteMask;  // will turn off bits to be overwritten in DstPixel 

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

	while (pDstPixel < pEndPixel)
	{
	    *pDstPixel = (*pDstPixel & wInvWriteMask) | crValue;
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt - 
//		Select the correct BitBlit and call it.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
DWORD gdwUnusedBitsMask;

SCODE BlitLib_BitBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    DWORD	dwBltConvType;
    RECT	rcSrc = *prcSrc,
	rcDst = *prcDst;
    
    // Make sure that destination rect is at least one pixel wide and tall.
    // Important!  Without this check we're vulnerable to divide by zero
    // errors in the blit routines.
    if ((BLITLIB_RECTWIDTH(&rcDst) == 0) || 
	(BLITLIB_RECTHEIGHT(&rcDst) == 0)) {
	return sc;
    }

    /*
     * Set unused pixel mask to default for all non RGBA blts"
     */
    gdwUnusedBitsMask = 0xffffff;
    if (((LPBITMAPINFO)pDibInfoSrc)->bmiHeader.biCompression==BI_BITFIELDS &&
        ((LPBITMAPINFO)pDibInfoSrc)->bmiHeader.biBitCount==32)
    {
        gdwUnusedBitsMask =
            *(DWORD*)&((LPBITMAPINFO)pDibInfoSrc)->bmiColors[0] |
            *(DWORD*)&((LPBITMAPINFO)pDibInfoSrc)->bmiColors[1] |
            *(DWORD*)&((LPBITMAPINFO)pDibInfoSrc)->bmiColors[2];
    }

    
    // Figure out the Blt Conversion type
    dwBltConvType = MAKELONG(GetImageFormatSpecifier(DibCompression(pDibInfoDst),
						     DibBitCount(pDibInfoDst)),
			     GetImageFormatSpecifier(DibCompression(pDibInfoSrc),
						     DibBitCount(pDibInfoSrc)));
    switch (dwBltConvType) {
    case BLT_01TO01:
	sc |= BlitLib_BitBlt01to01(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_01TO08:
	sc |= BlitLib_BitBlt01to08(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_01TO24:
	sc |= BlitLib_BitBlt01to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_08TO01:
	sc |= BlitLib_BitBlt08to01(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_08TO08:
	sc |= BlitLib_BitBlt08to08(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_08TO24:
	sc |= BlitLib_BitBlt08to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_08TO24P:
	sc |= BlitLib_BitBlt08to24P(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_08ATO08A:
	sc |= BlitLib_BitBlt08Ato08A(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    case BLT_08ATO24:
	sc |= BlitLib_BitBlt08Ato24(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_08ATO24P:
	sc |= BlitLib_BitBlt08Ato24P(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_16TO16:
	sc |= BlitLib_BitBlt16to16(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_16TO24:
	sc |= BlitLib_BitBlt16to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_16TO24P:
	sc |= BlitLib_BitBlt16to24P(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24TO01:
	sc |= BlitLib_BitBlt24to01(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_24PTO01:
	sc |= BlitLib_BitBlt24Pto01(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24TO08:
	sc |= BlitLib_BitBlt24to08(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_24PTO08:
	sc |= BlitLib_BitBlt24Pto08(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_24TO24:
	sc |= BlitLib_BitBlt24to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_24TO24P:
	sc |= BlitLib_BitBlt24to24P(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24ATO24:
	sc |= BlitLib_BitBlt24Ato24(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24ATO24P:
	sc |= BlitLib_BitBlt24Ato24P(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    case BLT_24ATO24A:
	sc |= BlitLib_BitBlt24Ato24A(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_24PTO24P:
	sc |= BlitLib_BitBlt24Pto24P(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    default:
	sc |= E_UNEXPECTED;	// !!!! Need better error codes!
    } 
    
    return sc;
}

#define DPF_MODNAME BlitLib_WriteMaskFillRect
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_WriteMaskFillRect - 
//		Select the correct WriteMaskFillRect and call it.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//      DWORD - dwWriteMask: 1's indicate bits that can be overwritten in pixel
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete 
//
///////////////////////////////////////////////////////////////////////

SCODE BlitLib_WriteMaskFillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		       RECT * pRect, COLORREF crColor, DWORD dwWriteMask)
{
    SCODE	sc = NOERROR;
    int		nWidthDst, nHeightDst;
    
    if (!pbiDst || !pDst || !pRect) {
	sc |= E_UNEXPECTED;
	goto ERROR_EXIT;
    }
    
    nWidthDst = BLITLIB_RECTWIDTH(pRect);
    nHeightDst = BLITLIB_RECTHEIGHT(pRect);
    
    switch (GetImageFormatSpecifier(DibCompression(pbiDst),
				    DibBitCount(pbiDst)))
    {	
    
    case BPP_24_RGB:
	sc |= BlitLib_WriteMaskFillRect32(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crColor,dwWriteMask);
	break;

    case BPP_16_RGB:
	sc |= BlitLib_WriteMaskFillRect16(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, (WORD) crColor, (WORD) dwWriteMask);
        break;
    case BPP_8_PALETTEIDX:
    case BPP_24_RGBPACKED:  // dont need these now because only stencil fmt is 32-bit (24-8)
        return E_NOTIMPL;

    case BPP_1_MONOCHROME:
    case BPP_16_8WALPHA:
    case BPP_32_24WALPHA:
    case BPP_16_YCRCB:
    case BPP_INVALID:
    default:
	sc |= E_UNEXPECTED;	
    } 
    // fall through
ERROR_EXIT:
    return sc;
}
#undef DPF_MODNAME

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect - 
//		Select the correct FillRect and call it.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete 
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////

SCODE BlitLib_FillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		       RECT * pRect, COLORREF crColor)
{
    SCODE	sc = NOERROR;
    int		nWidthDst, nHeightDst;
    
    if (!pbiDst || !pDst || !pRect) {
	sc |= E_UNEXPECTED;
	goto ERROR_EXIT;
    }
    
    nWidthDst = BLITLIB_RECTWIDTH(pRect);
    nHeightDst = BLITLIB_RECTHEIGHT(pRect);
    
    switch (GetImageFormatSpecifier(DibCompression(pbiDst),
				    DibBitCount(pbiDst)))
    {	
    case BPP_1_MONOCHROME:
    {
	BYTE crValue = (BYTE)crColor;
	sc |= BlitLib_FillRect01(pbiDst, pDst, pRect->left,
				 pRect->top,	nWidthDst,nHeightDst, crValue);
    }
    break;
    
    case BPP_8_PALETTEIDX:
    {
	BYTE crValue = (BYTE)crColor;
	
	sc |= BlitLib_FillRect08(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crValue);
    }
    break;
    
    case BPP_16_RGB:
    {
	WORD	crValue = (WORD)crColor;
	
	sc |= BlitLib_FillRect16(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crValue);
    }
    break;
    
    case BPP_24_RGBPACKED:
	sc |= BlitLib_FillRect24(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crColor);
	break;
	
    case BPP_24_RGB:
	sc |= BlitLib_FillRect32(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crColor);
	break;
	
    case BPP_16_8WALPHA:
    case BPP_32_24WALPHA:
    case BPP_16_YCRCB:
    case BPP_INVALID:
    default:
	sc |= E_UNEXPECTED;	
    } 
    // fall through
ERROR_EXIT:
    return sc;
}



///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_PatBlt - 
//		Fill an entire destination rectangle by tiling a given bitmap
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////

    SCODE BlitLib_PatBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			 PRECT prcDst, PDIBINFO pDibInfoPat, PDIBBITS pDibBitsPat,
			 PRECT prcPat, COLORREF crTransparent, ALPHAREF arAlpha,
			 DWORD dwRop)
	{
	    SCODE	sc = NOERROR;
	    long	iPatWidth;
	    long	iPatHeight;
	    long	iCurXPos;
	    long	iCurYPos;
	    long	iBlitWidth;
	    long	iBlitHeight;
	    long	iWidthLeft;
	    long	iHeightLeft;
	    RECT	rcPat = {0,0,0,0};
	    RECT	rcDst = {0,0,0,0};

	
	    // Check for invalid rectangles -- PatBlt only works for rects that
	    // are both (src and dest) right-side up (positive height and width).
	    // Also set our bounding rectangle sizes in the process
	    if(((iPatWidth = BLITLIB_RECTWIDTH(prcPat)) < 0)
	       || ((iPatHeight = BLITLIB_RECTHEIGHT(prcPat)) < 0)
	       || (BLITLIB_RECTWIDTH(prcDst) < 0)
	       || (BLITLIB_RECTHEIGHT(prcDst) < 0))
		return E_INVALIDARG;
	
	    // Reset the Y postion to the top edge of the dest
	    iCurYPos = prcDst->top;

	    // Tile the pattern into the destination rectangle
	    while (iCurYPos < prcDst->bottom){
		// Set up the source rectangle heights
		rcPat.top = iCurYPos % iPatHeight;
		iHeightLeft = (prcDst->bottom - iCurYPos);

		// Calculate the height we are actually going to blit
		iBlitHeight = min(iHeightLeft, (iPatHeight - rcPat.top));

		rcPat.bottom = rcPat.top + iBlitHeight;

		// Set up the destination rectangle heights
		rcDst.top = iCurYPos;
		rcDst.bottom = iCurYPos + iBlitHeight;

		// Reset the current X position to the left edge of the dest
		iCurXPos = prcDst->left;

		// Tile the pattern into the destination rectangle
		while (iCurXPos < prcDst->right){
		    // Set up the source rectangle width
		    rcPat.left = iCurXPos % iPatWidth;
		    iWidthLeft = (prcDst->right - iCurXPos);

		    // Calculate the width we are actually going to blit
		    iBlitWidth = min(iWidthLeft, (iPatWidth - rcPat.left));

		    rcPat.right = rcPat.left + iBlitWidth;

		    // Set up the destination rectangle heights
		    rcDst.left = iCurXPos;
		    rcDst.right = iCurXPos + iBlitWidth;

		    // REVIEW!!!! -- Do we want to check sc after each blit and return on an error?
		    sc = BlitLib_BitBlt(pDibInfoDst, pDibBitsDst, &rcDst, pDibInfoPat,
					pDibBitsPat, &rcPat, crTransparent, arAlpha,
					dwRop);

		    // Increment the current index value
		    iCurXPos += iBlitWidth;
		} 

		// Increment the current index value
		iCurYPos += iBlitHeight;
	    } 
	

	    return sc;
	}



///////////////////////////////////////////////////////////////////////
//
// Private GetImageFormatSpecifier - 
//		Select the correct bitmap format based on the compression and
//		bit count.
//
// Parameters:
//	dwDibComp		- The DIB's compression
//	wdBitCount		- The DIB's bit count
//
// Return Value:
//  BPP_INVALID or a valid bitmap format
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
WORD GetImageFormatSpecifier(DWORD dwDibComp, WORD wdBitCount)
{
    // Bit count could have Penguin codes in the high byte, mask them 
    // out for a correct comparison.
    wdBitCount &= 0x00ff;

    switch (dwDibComp)
    {
    case BI_RGB:
	switch (wdBitCount)
	{
	case 1:
	    return BPP_1_MONOCHROME;
	case 8:
	    return BPP_8_PALETTEIDX;
	case 16:
	    return BPP_16_RGB;
	case 24:
	    return BPP_24_RGBPACKED;
	case 32:
	    return BPP_24_RGB;
	default:
	    return BPP_INVALID;
	}
    case BI_RGBA:
	switch (wdBitCount)
	{
	case 16:
	    return BPP_16_8WALPHA;
	case 32:
	    return BPP_32_24WALPHA;
	default:
	    return BPP_INVALID;
	}
    case BI_BITFIELDS:
	switch (wdBitCount)
	{
	case 16:
	    return BPP_16_RGB;	// BlitLib assumes 5-6-5 RGB
	case 32:
	    return BPP_24_RGB;
	default:
	    return BPP_INVALID;
	}
    case BI_YCRCB:
	return BPP_16_YCRCB;

    default:
	switch (wdBitCount)
	{
	case 1:
	    return BPP_1_MONOCHROME;
	default:
	    return BPP_INVALID;
	}
    }

    return BPP_INVALID;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_PalIndexFromRGB - 
//		Calculates the closest entry in an array of COLORREF's to a
//		given COLORREF
//
// Parameters:
//	crColor			- Color to match
//	rgcrPal			- Array of colors to match to
//	iNumPalColors	- Number of colors in the array
//
// Return Value:
//  Palette index of the nearest color
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
BYTE BlitLib_PalIndexFromRGB(COLORREF crColor,COLORREF* rgcrPal,
			     unsigned int iNumPalColors)
{
    BYTE 	bIndex = 0;
    int		iRed = crColor & RED_MASK,
	iRedError,
	iGreen = (crColor & GREEN_MASK) >> 8,
	iGreenError,
	iBlue = (crColor & BLUE_MASK) >> 16,
	iBlueError,
	iError,
	iLeastError = MAX_POS_INT;

    for (unsigned int i = 0; i < iNumPalColors; i++) {
	iRedError = iRed - (rgcrPal[i] & RED_MASK);
	iGreenError = iGreen - ((rgcrPal[i] & GREEN_MASK) >> 8);
	iBlueError = iBlue - ((rgcrPal[i] & BLUE_MASK) >> 16);
	iError = iRedError * iRedError + iGreenError * iGreenError +
	    iBlueError * iBlueError;
	if (iError < iLeastError) {
	    iLeastError = iError;
	    bIndex = (BYTE) i;
	}
    }

    return bIndex;
}
#endif // DDRAW

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BLIT_BLEND24 - 
//		Performs alpha blending on 24bpp(packed) blits.
//
// Parameters:
//	ptSrc			- Pointer to the Source RGBTRIPLE
//	ptDst			- Pointer to the Destination RGBTRIPLE
//	alpha			- Alpha value (Range: 1 - 256)
//	alphacomp		- Alpha complement (256 - alpha)
//
// Return Value:
//  None
// 
///////////////////////////////////////////////////////////////////////
void BlitLib_BLIT_BLEND24(COLORREF crSrc, RGBTRIPLE * ptDst,
			  UINT alpha, UINT alphacomp)
{
    BYTE *	pbSrc = (BYTE *)&crSrc;
    BYTE *	pbDst = (BYTE *)ptDst;
    DWORD 	dwSrc;
    DWORD 	dwDst;
    UINT	i;

    for(i=0; i<sizeof(RGBTRIPLE); i++){
	dwSrc = (DWORD)*pbSrc++;
	dwDst = (DWORD)*pbDst;

	dwDst = ((dwSrc * alpha + dwDst * alphacomp) >> 8);
	*pbDst++ = (BYTE)dwDst;
    }
}

#endif

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_Detect_Intersection - 
//		Detects if both the source and destination bitmaps overlap
//
// Parameters:
//	pdibbitsDst		- Pointer to the Destination Bits
//	prcDst			- Pointer to the Destination Rectangle
//	pdibbitsSrc		- Pointer to the Source Bits
//	prcSrc			- Pointer to the Source Rectangle
//	
//
// Return Value:
//  TRUE if the bitmaps overlap, FALSE if they do not
// 
///////////////////////////////////////////////////////////////////////
BOOL BlitLib_Detect_Intersection (PDIBBITS pdibbitsDst, PRECT prcDst,
				  PDIBBITS pdibbitsSrc, PRECT prcSrc)
{
    RECT	rc,
	rcSrc,
	rcDst;
	
    // First check to see if the pdibbits pointers point to the same bitmap
    if(pdibbitsDst != pdibbitsSrc)
	return FALSE;

    // REVIEW!!! - This is just a hack because IntersectRect expects
    // bitmaps to be oriented correctly, but I can't afford to do
    // it to my original prects yet
    rcSrc.left = prcSrc->left;
    rcSrc.top = prcSrc->top;
    rcSrc.right = prcSrc->right;
    rcSrc.bottom = prcSrc->bottom;

    rcDst.left = prcDst->left;
    rcDst.top = prcDst->top;
    rcDst.right = prcDst->right;
    rcDst.bottom = prcDst->bottom;

    if (BLITLIB_RECTWIDTH(&rcSrc) < 0)
	FlipRectHorizontal(&rcSrc);
    if (BLITLIB_RECTHEIGHT(&rcSrc) < 0)
	FlipRectVertical(&rcSrc);
    if (BLITLIB_RECTWIDTH(&rcDst) < 0)
	FlipRectHorizontal(&rcDst);
    if (BLITLIB_RECTHEIGHT(&rcDst) < 0)
	FlipRectVertical(&rcDst);
	
    // Now check for rectangle intersection
    return IntersectRect(&rc, &rcDst, &rcSrc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt0101.cxx ===
#include "precomp.hxx"


static const BYTE bTopMask[8]    = {0x00, 0x80, 0xC0, 0xE0, 
                                    0xF0, 0xF8, 0xFC, 0xFE}; 
static const BYTE bBottomMask[8] = {0xFF, 0x7F, 0x3F, 0x1F, 
                                    0x0F, 0x07, 0x03, 0x01};
static const BYTE bSelectMask[8] = {0x80, 0x40, 0x20, 0x10,
                                    0x08, 0x04, 0x02, 0x01};


void Blt01to01_NoTrans_Hcopy_SRCCOPY_Vcopy(
								BYTE* pbSrcScanLine,
								int iSrcBitOffset,
								int iSrcScanStride,
								BYTE* pbDstScanLine,
								int iDstBitOffset,
								int iDstScanStride,
								int iNumDstCols,
								int iNumDstRows)
{
	BYTE	*pbSrc,
			*pbDst,
			*pbEndDst;
	int		iDstStartPixels,
			iDstFullBytes,
			iDstEndPixels,
			iRelBitOffset,
			iCompRelBitOffset;

	// compute how many pixels in the dst scanline are hanging off into a 
	// byte that's not completely on the dst scanline, how many full bytes
	// are on the dst scanline, and how many pixels hang off the other end
	if (iDstBitOffset == 0) {
		iDstStartPixels = 0;
		iDstFullBytes = iNumDstCols / 8;
		iDstEndPixels = iNumDstCols % 8;
	} else {
		iDstStartPixels = 8 - iDstBitOffset;
		iDstFullBytes = (iNumDstCols - iDstStartPixels) / 8;
		iDstEndPixels = (iNumDstCols - iDstStartPixels) % 8;
	}

	iRelBitOffset = abs(iSrcBitOffset - iDstBitOffset);
	iCompRelBitOffset = 8 - iRelBitOffset;

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to first bytes on src and dst scanlines
		pbSrc = pbSrcScanLine;
		pbDst = pbDstScanLine;
		
		// take care of first few dst pixels that are hanging off in a byte
		// that's not completely on the scanline
		if (iDstStartPixels) {
			if (iNumDstCols >= iDstStartPixels) {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset]) | 
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					            bBottomMask[iDstBitOffset]) |
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
				}	
			} else {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset] &
					            bTopMask[iSrcBitOffset + iNumDstCols]) | 
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					           bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]) |
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
				}	
			}
		}

		// take care of pixels that fall on bytes that are entirely
		// within the dst scanline
		pbEndDst = pbDst + iDstFullBytes;
		for (; pbDst != pbEndDst; pbDst++) {
			*pbDst = (*pbSrc << iRelBitOffset) | 
			         (*(pbSrc + 1) >> iCompRelBitOffset);
			pbSrc++;
		}

		// take care of pixels hanging off the end into a byte not
		// entirely in the scanline
		*pbDst = ((*pbSrc << iRelBitOffset) & bTopMask[iDstEndPixels]) |
		         (*pbDst & ~bTopMask[iDstEndPixels]);

		// advance to next scanline

		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

void Blt01to01_NoTrans_Hcopy_SRCCOPY_NoVcopy(
								BYTE* pbSrcScanLine,
								int iSrcBitOffset,
								int iSrcScanStride,
								int iNumSrcRows,
								BYTE* pbDstScanLine,	
								int iDstBitOffset,
								int iDstScanStride,
								int iNumDstCols,
								int iNumDstRows)
{
	BYTE	*pbSrc,
			*pbDst,
			*pbEndDst;
	int		iDstStartPixels,
			iDstFullBytes,
			iDstEndPixels,
			iRelBitOffset,
			iCompRelBitOffset,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute how many pixels in the dst scanline are hanging off into a 
	// byte that's not completely on the dst scanline, how many full bytes
	// are on the dst scanline, and how many pixels hang off the other end
	if (iDstBitOffset == 0) {
		iDstStartPixels = 0;
		iDstFullBytes = iNumDstCols / 8;
		iDstEndPixels = iNumDstCols % 8;
	} else {
		iDstStartPixels = 8 - iDstBitOffset;
		iDstFullBytes = (iNumDstCols - iDstStartPixels) / 8;
		iDstEndPixels = (iNumDstCols - iDstStartPixels) % 8;
	}

	iRelBitOffset = abs(iSrcBitOffset - iDstBitOffset);
	iCompRelBitOffset = 8 - iRelBitOffset;

	for (int i = 0; i < iNumDstRows; i++) {

 		pbSrc = pbSrcScanLine;
		pbDst = pbDstScanLine;
		
		// take care of first few dst pixels that are hanging off in a byte
		// that's not completely on the scanline
		if (iDstStartPixels) {
			if (iNumDstCols >= iDstStartPixels) {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset]) | 
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					            bBottomMask[iDstBitOffset]) |
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
				}	
			} else {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset] &
					            bTopMask[iSrcBitOffset + iNumDstCols]) | 
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					           bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]) |
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
				}	
			}
		}

		// take care of pixels that fall on bytes that are entirely
		// within the dst scanline
		pbEndDst = pbDst + iDstFullBytes;
		for (; pbDst != pbEndDst; pbDst++) {
			*pbDst = (*pbSrc << iRelBitOffset) | 
			         (*(pbSrc + 1) >> iCompRelBitOffset);
			pbSrc++;
		}

		// take care of pixels hanging off the end into a byte not
		// entirely in the scanline
		*pbDst = ((*pbSrc << iRelBitOffset) & bTopMask[iDstEndPixels]) |
		         (*pbDst & ~bTopMask[iDstEndPixels]);

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt01to01_NoTrans_NoHcopy_SRCCOPY(
								BYTE* pbSrcScanLine,	
								int iSrcBitOffset,
								int iSrcScanStride,
								int iNumSrcCols,
								int iNumSrcRows,
								BYTE* pbDstScanLine,
								int iDstBitOffset,
								int iDstScanStride,
 								int iNumDstCols,
								int iNumDstRows,
								int iHorizMirror)
{
	BYTE	*pbSrc,
			*pbDst,
			bDstVal;
	int		iSrcPixel,
			iDstPixel,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcByteAdvance,
			iSrcBitAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcByteAdvance = 0;
		iSrcBitAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcByteAdvance = (iNumSrcCols / iNumDstCols) / 8;
		iSrcBitAdvance = (iNumSrcCols / iNumDstCols) % 8;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pbSrc = pbSrcScanLine;
		iSrcPixel = iSrcBitOffset;
		pbDst = pbDstScanLine;
		iDstPixel = iDstBitOffset;
		iHorizError = 0;
		bDstVal = *pbDst;

		for (int j = 0; j < iNumDstCols; j++) {

			// get value of src pixel, put it in dst byte
			if (*pbSrc & bSelectMask[iSrcPixel]) {
				bDstVal |= bSelectMask[iDstPixel];
			} else {
				bDstVal &= ~bSelectMask[iDstPixel];
			}

			// advance to next src pixel
			pbSrc += iSrcByteAdvance;
			iSrcPixel += iSrcBitAdvance;
			if (iSrcPixel > 7) {
				pbSrc++;
				iSrcPixel -= 8;
			}

			// advance to next dst pixel
			// if we hit byte boundary, write
			// full one and get new one
			iDstPixel += iHorizMirror;
			if (iDstPixel < 0) {
				*pbDst-- = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 7;
			} else if (iDstPixel > 7) {
				*pbDst++ = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 0;
			}

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				if (++iSrcPixel > 7) {
					pbSrc++;
					iSrcPixel = 0;
				}
				iHorizError -= iNumDstCols;
			}
		}

		// write last byte to dst scanline
		*pbDst = bDstVal;

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt01to01_Trans_NoHcopy_SRCCOPY(
								BYTE* pbSrcScanLine,
								int iSrcBitOffset,
								int iSrcScanStride,
								int iNumSrcCols,
								int iNumSrcRows,
								BYTE* pbDstScanLine,
								int iDstBitOffset,
								int iDstScanStride,
								int iNumDstCols,
								int iNumDstRows,
								int iHorizMirror,
								BYTE bTransparentIndex)
{
	BYTE	*pbSrc,
			*pbDst,
			bDstVal,
			bTransparentTest;
	int		iSrcPixel,
			iDstPixel,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcByteAdvance,
			iSrcBitAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcByteAdvance = 0;
		iSrcBitAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcByteAdvance = (iNumSrcCols / iNumDstCols) / 8;
		iSrcBitAdvance = (iNumSrcCols / iNumDstCols) % 8;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	// create transparent color testing mask
	if (bTransparentIndex) {
		bTransparentTest = 0xFF;
	} else {
		bTransparentTest = 0;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pbSrc = pbSrcScanLine;
		iSrcPixel = iSrcBitOffset;
		pbDst = pbDstScanLine;
		iDstPixel = iDstBitOffset;
		iHorizError = 0;
		bDstVal = *pbDst;

		for (int j = 0; j < iNumDstCols; j++) {

			// get value of src pixel, put it in dst byte
			if ((*pbSrc ^ bTransparentTest) & bSelectMask[iSrcPixel]) {
				if (*pbSrc & bSelectMask[iSrcPixel]) {
					bDstVal |= bSelectMask[iDstPixel];
				} else {
					bDstVal &= ~bSelectMask[iDstPixel];
				}
			}

			// advance to next src pixel
			pbSrc += iSrcByteAdvance;
			iSrcPixel += iSrcBitAdvance;
			if (iSrcPixel > 7) {
				pbSrc++;
				iSrcPixel -= 8;
			}

			// advance to next dst pixel
			// if we hit byte boundary, write
			// full one and get new one
			iDstPixel += iHorizMirror;
			if (iDstPixel < 0) {
				*pbDst-- = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 7;
			} else if (iDstPixel > 7) {
				*pbDst++ = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 0;
			}

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				if (++iSrcPixel > 7) {
					pbSrc++;
					iSrcPixel = 0;
				}
				iHorizError -= iNumDstCols;
			}
		}

		// write last byte to dst scanline
		*pbDst = bDstVal;

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt2424.cxx ===
#include "precomp.hxx"



void Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel,
			*pdEndDstPixel,
			*pdEndDstScanLine;

	// set up pointer to next dst scanline beyond last
	pdEndDstScanLine = pdDstScanLine + iNumDstRows * iDstScanStride;

	while (pdDstScanLine != pdEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		pdEndDstPixel = pdDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pdDstPixel != pdEndDstPixel) {
			*pdDstPixel++ = *pdSrcPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanStride;
		pdDstScanLine += iDstScanStride;
	}
}

void Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel,
			*pdEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		pdEndDstPixel = pdDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pdDstPixel != pdEndDstPixel) {
			*pdDstPixel++ = *pdSrcPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
			*pdDstPixel = *pdSrcPixel;

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_NoBlend_Trans_Hcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK) {
				*pdDstPixel = *pdSrcPixel;
			}
			pdSrcPixel++;
			pdDstPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_NoBlend_Trans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    COLORREF crTransparent)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK) {
				*pdDstPixel = *pdSrcPixel;
			}

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#ifndef DDRAW 
void Blt24to24_Blend_NoTrans_Hcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
                                    int iSrcScanStride,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel,
			*pdEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		pdEndDstPixel = pdDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pdDstPixel != pdEndDstPixel) {
			*pdDstPixel++ = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
										uiAlpha,uiAlphaComp);
			pdSrcPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_Blend_NoTrans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
 			*pdDstPixel = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
 										uiAlpha,uiAlphaComp);

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_Blend_Trans_Hcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
                                    int iSrcScanStride,
								    int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    COLORREF crTransparent,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK){
				*pdDstPixel = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
											uiAlpha,uiAlphaComp);
			}
			pdSrcPixel++;
			pdDstPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_Blend_Trans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    COLORREF crTransparent,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK) {
				*pdDstPixel = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
											uiAlpha,uiAlphaComp);
			}

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt0808.cxx ===
#include "precomp.hxx"
#ifdef __cplusplus
extern "C" {
#endif
#include "dpf.h"
#ifdef __cplusplus
}
#endif


//#define BLT0808_FAST_TRANSPARENCY	1	// set to 1 if one wants a faster, less legal
										// transparency comparison, set to 0 for a 
										// perfect safe but slower transparency
										// comparison

void Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(BYTE* pSrcScanLine,
                                                  int iSrcScanStride,
                                                  BYTE* pDstScanLine,
												  int iDstScanStride,
                                                  int iNumDstCols,
                                                  int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			i,j;
	DWORD	dwSrc1, dwSrc2;

	
	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the src and dest pointers are dword aligned
		pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanLine) + 3) & (~3));
		iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanLine);

		pAlignedSrcPixel = (BYTE *)((((ULONG_PTR)pSrcScanLine) + 3) & (~3));
		iNumUnalignedSrcBytes = (int)(pAlignedSrcPixel - pSrcScanLine);

		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			if(iNumBytesLeftDst != sizeof(DWORD))
				iNumDwordsPerLine--;
			}
		}

	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// Do the fast dword copy since the alignments match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel++ = *pSrcPixel++;
	
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) pSrcPixel;
			pBigDstPixel = (DWORD*) pDstPixel;
			pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel++ = *pBigSrcPixel++;
			}

			// take care of remaining pixels on scanline
			if (iNumBytesLeftDst) {
				pSrcPixel = (BYTE*) pBigSrcPixel;
				pDstPixel = (BYTE*) pBigDstPixel;
				for(j=0; j<iNumBytesLeftDst; j++){
					*pDstPixel++ = *pSrcPixel++;
				}
			}

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes > iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedDstBytes - iNumUnalignedSrcBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedSrcBytes -
										iNumUnalignedDstBytes);

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel++ = *pSrcPixel++;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) pDstPixel;
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc1 = *pBigSrcPixel++;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc1 = dwSrc2;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc1 = dwSrc2;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc1 = dwSrc2;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = (BYTE *)pBigDstPixel;
			pSrcPixel = ((BYTE *)(pBigSrcPixel)) - (sizeof(DWORD) - iNumUnalignByteDiff);

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel++ = *pSrcPixel++;

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}


}


void Blt08to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(BYTE* pSrcScanLine,
                                                  int iSrcScanStride,
												  int iNumSrcRows,
                                                  BYTE* pDstScanLine,
												  int iDstScanStride,
                                                  int iNumDstCols,
                                                  int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			i,j;
	DWORD	dwSrc1, dwSrc2;

	
	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the src and dest pointers are dword aligned
		pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanLine) + 3) & (~3));
		iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanLine);

		pAlignedSrcPixel = (BYTE *)((((ULONG_PTR)pSrcScanLine) + 3) & (~3));
		iNumUnalignedSrcBytes = (int)(pAlignedSrcPixel - pSrcScanLine);

		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			if(iNumBytesLeftDst != sizeof(DWORD))
				iNumDwordsPerLine--;
			}
		}


	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// compute advance and error terms for stepping
		// vertically through the src bitmap
		if (iNumSrcRows < iNumDstRows) {
			iSrcScanAdvance = 0;
			iVertAdvanceError = iNumSrcRows;
			}
		else{
			iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
			iVertAdvanceError = iNumSrcRows % iNumDstRows;
			}

		// Do the fast dword copy since the alignments match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel++ = *pSrcPixel++;
	
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) pSrcPixel;
			pBigDstPixel = (DWORD*) pDstPixel;
			pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel++ = *pBigSrcPixel++;
				}

			// take care of remaining pixels on scanline
			if (iNumBytesLeftDst) {
				pSrcPixel = (BYTE*) pBigSrcPixel;
				pDstPixel = (BYTE*) pBigDstPixel;
				for(j=0; j<iNumBytesLeftDst; j++){
					*pDstPixel++ = *pSrcPixel++;
					}
				}

			// advance to next scanline
			pSrcScanLine += iSrcScanAdvance;
			pDstScanLine += iDstScanStride;

			// update and check vertical stepping error,
			// adjust src scanline pointer if necessary
			iVertError += iVertAdvanceError;
			if (iVertError >= iNumDstRows) {
				pSrcScanLine += iSrcScanStride;
				iVertError -= iNumDstRows;
				}
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes > iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedDstBytes - iNumUnalignedSrcBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedSrcBytes -
										iNumUnalignedDstBytes);

		// compute advance and error terms for stepping
		// vertically through the src bitmap
		if (iNumSrcRows < iNumDstRows) {
			iSrcScanAdvance = 0;
			iVertAdvanceError = iNumSrcRows;
			}
		else{
			iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
			iVertAdvanceError = iNumSrcRows % iNumDstRows;
			}

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel++ = *pSrcPixel++;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) pDstPixel;
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc1 = *pBigSrcPixel++;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc1 = dwSrc2;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc1 = dwSrc2;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc1 = dwSrc2;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = (BYTE *)pBigDstPixel;
			pSrcPixel = ((BYTE *)(pBigSrcPixel)) - (sizeof(DWORD) - iNumUnalignByteDiff);

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel++ = *pSrcPixel++;

			// advance to next scanline
			pSrcScanLine += iSrcScanAdvance;
			pDstScanLine += iDstScanStride;

			// update and check vertical stepping error,
			// adjust src scanline pointer if necessary
			iVertError += iVertAdvanceError;
			if (iVertError >= iNumDstRows) {
				pSrcScanLine += iSrcScanStride;
				iVertError -= iNumDstRows;
				}
			}
		}

}


void	Blt08to08_NoTrans_NoHcopy_SRCCOPY(BYTE* pSrcScanLine,
											  int iSrcScanStride,
											  int iNumSrcCols,
											  int iNumSrcRows,
                                              BYTE* pDstScanLine,
                                              int iDstScanStride,
                                              int iNumDstCols,
                                              int iNumDstRows,
                                              int iHorizMirror)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
			*pDstPixel = *pSrcPixel;

			// advance to next pixel
			pSrcPixel += iSrcPixelAdvance;
			pDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanAdvance;
		pDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt08to08_Trans_Hcopy_SRCCOPY(BYTE* pSrcScanLine,
                                          int iSrcScanStride,
										  int iNumSrcRows,
                                          BYTE* pDstScanLine,
                                          int iDstScanStride,
                                          int iNumDstCols,
                                          int iNumDstRows,
                                          BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	 
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
#if BLT0808_FAST_TRANSPARENCY
			*pDstPixel ^= (*pDstPixel ^ *pSrcPixel) * 
			              (BYTE) !(*pSrcPixel == bTransparentIndex);
#else
			if (*pSrcPixel != bTransparentIndex) 
			{
				*pDstPixel = *pSrcPixel;
			}
#endif
			pSrcPixel++;
			pDstPixel++;
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanAdvance;
		pDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	

}

void	Blt08to08_Trans_NoHcopy_SRCCOPY(BYTE* pSrcScanLine,
											int iSrcScanStride,
											int iNumSrcCols,
											int iNumSrcRows,
                                            BYTE* pDstScanLine,
                                            int iDstScanStride,
                                            int iNumDstCols,
                                            int iNumDstRows,
                                            int iHorizMirror,
                                            BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
#if BLT0808_FAST_TRANSPARENCY
			*pDstPixel ^= (*pDstPixel ^ *pSrcPixel) *
			              (BYTE) !(*pSrcPixel == bTransparentIndex);
#else
			if (*pSrcPixel != bTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
#endif

			// advance to next pixel
			pSrcPixel += iSrcPixelAdvance;
			pDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanAdvance;
		pDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_Chunk32_BitBlt08to08 - 
//		BitBlit from source bitmap to destination bitmap in 32 x 32
//		bit chunks
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif 

SCODE BlitLib_Chunk32_BitBlt08to08(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc)
{

	DWORD *pbDst,*pbSrc,*pend;
	int j;
	int iDstStride=DibWidthBytes(pDibInfoDst);


	// calc pbsrc and pbdst
	pbDst = (DWORD *) ((BYTE *) pDibBitsDst + (prcDst->top) * (iDstStride)
	 + prcDst->left);
	pbSrc=(DWORD *)pDibBitsSrc;
      
	iDstStride-=32;
	// convert stride to dwords
      iDstStride/=4;
	

	// copy a scanline
	// counting down to 0 faster
	for (j=32;j>0 ;j-- )
	{	
		pend=(DWORD *)pbSrc+8;
		for (; pbSrc < pend; pbSrc++ )
		{
			*pbDst++=*pbSrc;
		}  
		pbDst+=iDstStride;
 	}
     
	return(S_OK);
	
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_Chunk32_BitBlt08to08_Trans - 
//		BitBlit from source bitmap to destination bitmap in 32 x 32
//		bit chunks with optional transparency
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	crTransparent		Tranparent color value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_Chunk32_BitBlt08to08_Trans(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc, COLORREF crTransparent)
{

	BYTE * pbDst,*pend;
	int j;
	int iDstStride=DibWidthBytes(pDibInfoDst);	   


	
	// calc pbsrc and pbdst
	pbDst = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstStride)
	 + prcDst->left;

	iDstStride-=32;

	// copy a scanline
	// counting down to 0 faster
	for (j=32;j>0 ;j-- )
	{	
		pend=pDibBitsSrc+32;
		for (;pDibBitsSrc<pend;pDibBitsSrc++ )
		{
			if (*pDibBitsSrc != (BYTE)crTransparent)
				*pbDst=*pDibBitsSrc;
		
		pbDst++;
		}  
		pbDst+=iDstStride;
 	}
     
	return(S_OK);
	
}

#ifdef __cplusplus
	}
#endif 
#endif

///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_LeftToRight_BottomToTop_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from left to right and bottom to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_LeftToRight_BottomToTop_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			i,j;
	DWORD	dwSrc1, dwSrc2;


	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the source and dest pointers are dword aligned
		pAlignedSrcPixel = (BYTE *)((((ULONG_PTR)pSrcScanLine) + 3) & (~3));
		iNumUnalignedSrcBytes = (int)(pAlignedSrcPixel - pSrcScanLine);

		pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanLine) + 3) & (~3));
		iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanLine);
	
		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			if(iNumBytesLeftDst != sizeof(DWORD))
				iNumDwordsPerLine--;
			}
		}


	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// Do the fast dword copy since the alignments match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel++ = *pSrcPixel++;
	
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) pSrcPixel;
			pBigDstPixel = (DWORD*) pDstPixel;
			pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel++ = *pBigSrcPixel++;
			}

			// take care of remaining pixels on scanline
			if (iNumBytesLeftDst) {
				pSrcPixel = (BYTE*) pBigSrcPixel;
				pDstPixel = (BYTE*) pBigDstPixel;
				for(j=0; j<iNumBytesLeftDst; j++){
					*pDstPixel++ = *pSrcPixel++;
				}
			}

			// advance to next scanline
			pSrcScanLine -= iSrcScanStride;
			pDstScanLine -= iDstScanStride;
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes > iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedDstBytes - iNumUnalignedSrcBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedSrcBytes -
										iNumUnalignedDstBytes);

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel++ = *pSrcPixel++;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) pDstPixel;
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc1 = *pBigSrcPixel++;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc1 = dwSrc2;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc1 = dwSrc2;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc1 = dwSrc2;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = (BYTE *)pBigDstPixel;
			pSrcPixel = ((BYTE *)(pBigSrcPixel)) - (sizeof(DWORD) - iNumUnalignByteDiff);

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel++ = *pSrcPixel++;

			// advance to next scanline
			pSrcScanLine -= iSrcScanStride;
			pDstScanLine -= iDstScanStride;
			}
		}
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_RightToLeft_TopToBottom_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from right to left and top to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_RightToLeft_TopToBottom_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			i,j;
	DWORD	dwSrc1, dwSrc2;

	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the source and dest pointers are dword aligned
		pAlignedSrcPixel = (BYTE *)(((ULONG_PTR)pSrcScanLine) & (~3));
		iNumUnalignedSrcBytes = (int)(pSrcScanLine - pAlignedSrcPixel) + 1;

		pAlignedDstPixel = (BYTE *)(((ULONG_PTR)pDstScanLine) & (~3));
		iNumUnalignedDstBytes = (int)(pDstScanLine - pAlignedDstPixel) + 1;
	
		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes == sizeof(DWORD))
			iNumUnalignedDstBytes = 0;
		if(iNumUnalignedSrcBytes == sizeof(DWORD))
			iNumUnalignedSrcBytes = 0;
		else if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst =  sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			iNumDwordsPerLine--;
			}
		}


	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// Do the fast dword copy since the alignments match
		for (int i = 0; i < iNumDstRows; i++) {

			// First set up the pointer to take care of unaligned DWORD bytes
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel-- = *pSrcPixel--;
		
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) (pSrcPixel - 3);
			pBigDstPixel = (DWORD*) (pDstPixel - 3);
			pBigEndDstPixel = pBigDstPixel - iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel-- = *pBigSrcPixel--;
			}

			if(iNumBytesLeftDst)
				pSrcPixel = ((BYTE *)pBigSrcPixel) + 3;
				pDstPixel = ((BYTE *)pBigDstPixel) + 3;
				for (j = 0; j < iNumBytesLeftDst; j++)
					*pDstPixel-- = *pSrcPixel--;

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes < iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedSrcBytes - iNumUnalignedDstBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedDstBytes -
										iNumUnalignedSrcBytes);

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel-- = *pSrcPixel--;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) (pDstPixel - 3);
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc2 = *pBigSrcPixel--;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc1 = *pBigSrcPixel--;
						*pBigDstPixel-- = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc2 = dwSrc1;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc1 = *pBigSrcPixel--;
						*pBigDstPixel-- = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc2 = dwSrc1;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc1 = *pBigSrcPixel--;
						*pBigDstPixel-- = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc2 = dwSrc1;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = ((BYTE *)pBigDstPixel + 3);
			pSrcPixel = (((BYTE *)(pBigSrcPixel)) + 4 + 
								(iNumUnalignByteDiff - 1));

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel-- = *pSrcPixel--;

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}

}


///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_LeftToRight_BottomToTop_Trans_SRCCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_LeftToRight_BottomToTop_Trans_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != bTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel++;
			pDstPixel++;
		}

		// advance to next scanline
		pSrcScanLine -= iSrcScanStride;
		pDstScanLine -= iDstScanStride;

	}	
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_RightToLeft_TopToBottom_Trans_SRCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_RightToLeft_TopToBottom_Trans_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != bTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel--;
			pDstPixel--;
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanStride;
		pDstScanLine += iDstScanStride;

	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bitblt.h ===
///////////////////////////////////////////////////////////////////////
//
//  BitBlt.H - Contains the BitBlt prototypes
//
//	Copyright (c) 1994 Microsoft Corporation
//
//	History:
//		10/18/94 - Scott Leatham Created it w/8BPP support only
//		10/19/94 - Olivier Garamfalvi Chopped out unneeded stuff
//		05/30/95 - Myron Thomas Code clean up
//
///////////////////////////////////////////////////////////////////////

#ifdef NT_BUILD_ENVIRONMENT
    typedef ULONG SCODE;
    typedef long HRESULT;
#endif

#ifdef MMOSA
//#include <pshpack1.h>
typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;
//#include <poppack.h>
#endif

// Bits Per Pixel Formats
// 	  HIBYTE=Penguin Image Format specifier, FF = not supported by Penguin
// 	  LOBYTE=PhysicalBitsPerPixel, FF = not support by bitblt
#define BPP_MSK_BITCOUNT	0x00ff	// Get the bitcount from a BPP_ constant
#define BPP_MSK_IMAGECODE	0xff00	// Get the Penguin IMage code from a BPP_ constant
#define BPP_INVALID			0xffff	// LO = 256 & HI = 256 =  Bad format
#define BPP_1_MONOCHROME	0xff01	// LO = 256 bpp, HI = 1 bit monochrome not supported on Penguin
#define BPP_2_4GRAYSCALE	0xff02	// LO = 256 bpp, HI = 2 bits 4 shades of gray not supported on Penguin
#define BPP_4_16GRAYSCALE	0xff04	// LO = 256 bpp, HI = 4 bits 16 shades of gray not supported on Penguin
#define BPP_8_PALETTEIDX	0x0008	// LO = 8  bpp, HI = Penguin H/W code 000 = 8 bits 256 colors palette indexed
#define BPP_16_FILLSPAN		0x01FF	// LO = 256bpp, HI = Penguin H/W code 001 (SrcAdr of span desc. if used as an RGB value
#define BPP_16_8WALPHA		0x0510	// LO = 16 bpp, HI = Penguin H/W code 101 = 8 bits 256 colors palette indexed, 8 bits alpha
#define BPP_16_RGB			0x0610	// LO = 16 bpp, HI = Penguin H/W code 110 = 16 bits used for RGB in 5-6-5 format
#define BPP_16_YCRCB		0x0710	// LO = 16 bpp, HI = Penguin H/W code 111 = 16 bits Cr Cb Sample and subsample 2 bytes at a time
#define BPP_24_RGBPACKED	0xff18	// LO = 256 bpp, HI = 24 bit RGB not supported by Penguin
#define BPP_24_RGB			0x0220	// LO = 32 bpp, HI = Penguin H/W code 010 = 24 bits used for RGB color and 8 empty bits
#define BPP_32_24WALPHA		0x0320	// LO = 32 bpp, HI = Penguin H/W code 011 = 24 bits used for RGB color and 8 bit alpha byte
// New Bit Compression Values:
#define BI_RGBA				4L
#define BI_YCRCB			5L

#ifdef __cplusplus
extern "C" {
#endif 
	
SCODE BlitLib_BitBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha,
		DWORD dwRop);

SCODE BlitLib_FillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		RECT * pRect, COLORREF crValue);

SCODE BlitLib_WriteMaskFillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		RECT * pRect, COLORREF crValue, DWORD dwWritemask);

SCODE BlitLib_Chunk32_BitBlt08to08(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc);

SCODE BlitLib_Chunk32_BitBlt08to08_Trans(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc, COLORREF crTransparent);

SCODE BlitLib_PatBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoPat, PDIBBITS pDibBitsPat,
		PRECT prcPat, COLORREF crTransparent, ALPHAREF arAlpha,
		DWORD dwRop);


#ifdef __cplusplus
	}
#endif 

SCODE BlitLib_BitBlt01to01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt01to08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt01to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08Ato24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08Ato24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08Ato08A(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt16to16(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt16to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt16to24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Ato24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Ato24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Ato24A(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_FillRect01(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		BYTE crValue);

SCODE BlitLib_FillRect08(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		BYTE crValue);

SCODE BlitLib_FillRect16(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		WORD crValue);

SCODE BlitLib_FillRect24(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		DWORD rgb);

SCODE BlitLib_FillRect32(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		DWORD crValue);

SCODE BlitLib_WriteMaskFillRect32(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		DWORD crValue, DWORD dwWriteMask);

BOOL BlitLib_Detect_Intersection (PDIBBITS pdibbitsDst, PRECT prcDst,
								PDIBBITS pdibbitsSrc, PRECT prcSrc);

SCODE BlitLib_BitBlt08to08_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
		COLORREF crTransparent, DWORD dwRop);

SCODE BlitLib_BitBlt16to16_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
		COLORREF crTransparent, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto24P_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
		COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

// function used to calculate the closest entry in an array of
// COLORREFs to a given COLORREF
BYTE BlitLib_PalIndexFromRGB(COLORREF crColor,COLORREF* rgcrPal,
		unsigned int iNumPalColors);

// Based on Dib Compression type and Bit Count find a matching BPP_*
WORD GetImageFormatSpecifier(DWORD dwDibComp, WORD wdBitCount);

#ifndef DDRAW
// BLIT_BLEND_24 -- used to alpha blend to 24bpp(packed) destinations
void BlitLib_BLIT_BLEND24(COLORREF crSrc, RGBTRIPLE * ptDst,
							UINT alpha, UINT alphacomp);
#endif

// similar macros are defined in idib.hxx, be careful in changing these
#define BLITLIB_RECTWIDTH(prc)  ((prc)->right  - (prc)->left)
#define BLITLIB_RECTHEIGHT(prc) ((prc)->bottom - (prc)->top )
#define BLITLIB_RECTORIGINX(prc) ((prc)->left)
#define BLITLIB_RECTORIGINY(prc) ((prc)->top)
#define BLITLIB_RECTORIGINPT(prc) ((POINT *)(prc))

// masks that define what's stored in a DWORD-sized pixel
#define RED_MASK		0x000000FF
#define GREEN_MASK		0x0000FF00
#define BLUE_MASK		0x00FF0000
#define ALPHA_MASK		0x000000FF
#define NOALPHA_MASK	0xFFFFFF00
#define PERPIX_ALPHA_MASK	0xFF000000

/*
 * PROBLEM for RGBA surfaces:
 * The way it used to be:
        #define UNUSED_MASK		0x00FFFFFF
 */
#define UNUSED_MASK		gdwUnusedBitsMask
extern DWORD gdwUnusedBitsMask;


// masks that define what's inside a WORD-sized pixel
#define RED_MASK16		0x001F
#define GREEN_MASK16	0x07E0
#define BLUE_MASK16		0xF800

// scottle 1bbp is not a Penguin supported format, ff must be specified in the high bytes of
//		both the hi & lo words.
#define BLT_01TO01	0xff01ff01	// Src (hiword) = 1 Dst (loword) = 1
#define BLT_01TO08	0xff010008	// Src (hiword) = 1 Dst (loword) = 8
#define BLT_01TO24	0xff010220	// Src (hiword) = 1 Dst (loword) = 32 (20hex)
#define BLT_08TO01	0x0008ff01	// Src (hiword) = 8 Dst (loword) = 1
// andyco 24 bit dibs are actually 32 bits (888 rgb, + 8 unused). Penguin is the 0x2 preface.
#define BLT_08TO08  0x00080008	// Src (hiword) = 8 Dst (loword) = 8
#define BLT_08TO24	0x00080220	// Src (hiword) = 8 Dst (loword) = 32 (20hex)
#define BLT_08TO24P	0x0008ff18	// Src (hiword) = 8 Dst (loword) = 24 (18hex)
#define BLT_08ATO08A 0x05100510	// Src (hiword) = 16 (10hex) Dst (loword) = 16 (10hex)
#define BLT_08ATO24	0x05100220	// Src (hiword) = 16 (10hex) Dst (loword) = 32 (20hex)
#define BLT_08ATO24P 0x0510ff18	// Src (hiword) = 16 (10hex) Dst (loword) = 24 (18hex)
#define BLT_16TO16	0x06100610	// Src (hiword) = 16 (10hex) Dst (loword) = 16 (10hex)
#define BLT_16TO24	0x06100220	// Src (hiword) = 16 (10hex) Dst (loword) = 32 (20hex)
#define BLT_16TO24P	0x0610ff18	// Src (hiword) = 16 (10hex) Dst (loword) = 24 (18hex)
#define BLT_24TO01	0x0220ff01	// Src (hiword) = 32 (20hex) Dst (loword) = 1
#define BLT_24PTO01	0xff18ff01	// Src (hiword) = 24 (18hex) Dst (loword) = 1
#define BLT_24TO08	0x02200008	// Src (hiword) = 32 (20hex) Dst (loword) = 8
#define BLT_24PTO08	0xff180008	// Src (hiword) = 32 (20hex) Dst (loword) = 8
#define BLT_24TO24	0x02200220	// Src (hiword) = 32 (20hex) Dst (loword) = 32 (20hex)
#define BLT_24TO24P	0x0220ff18	// Src (hiword) = 32 (20hex) Dst (loword) = 24 (18hex)
#define BLT_24ATO24	0x03200220	// Src (hiword) = 32 (20hex) Dst (loword) = 32 (20hex)
#define BLT_24ATO24P 0x0320ff18	// Src (hiword) = 32 (20hex) Dst (loword) = 24 (18hex)
#define BLT_24ATO24A 0x03200320	// Src (hiword) = 32 (20hex) Dst (loword) = 32 (20hex)
#define BLT_24PTO24P 0xff18ff18	// Src (hiword) = 24 (18hex) Dst (loword) = 24 (18hex)

// macro used to blend src and dst together.  "alpha" should range 1...256
// alphacomp = 256 - alpha.	Used for 24bpp
#define BLIT_BLEND(src,dst,alpha,alphacomp) \
	(((((src) & BLUE_MASK)  * (alpha) + ((dst) & BLUE_MASK) \
		* (alphacomp)) >> 8) & BLUE_MASK) | \
	(((((src) & GREEN_MASK) * (alpha) + ((dst) & GREEN_MASK) \
		* (alphacomp)) >> 8) & GREEN_MASK) | \
	(((((src) & RED_MASK)   * (alpha) + ((dst) & RED_MASK) \
		* (alphacomp)) >> 8) & RED_MASK) 
#ifndef DDRAW
// macro used to blend src and dst together.  "alpha" should range 1...256
// alphacomp = 256 - alpha. Used for 16bpp
#define BLIT_BLEND16(src,dst,alpha,alphacomp) \
	((WORD) ((((((DWORD) (src) & BLUE_MASK16)  * (alpha) + \
        ((DWORD) (dst) & BLUE_MASK16)  * (alphacomp)) >> 8) & BLUE_MASK16) | \
     (((((DWORD) (src) & GREEN_MASK16) * (alpha) + \
        ((DWORD) (dst) & GREEN_MASK16) * (alphacomp)) >> 8) & GREEN_MASK16) | \
     (((((DWORD) (src) & RED_MASK16)   * (alpha) + \
        ((DWORD) (dst) & RED_MASK16)   * (alphacomp)) >> 8) & RED_MASK16)))
#endif

#define BLIT_COLOR16_FROM_COLORREF(cr) \
	((WORD) ((((cr) >> 8) & BLUE_MASK16) | (((cr) >> 5) & \
		GREEN_MASK16) | (((cr) >> 3) & RED_MASK16)))

#define BLIT_COLORREF_FROM_COLOR16(w) \
	((DWORD) ((((w) & BLUE_MASK16) << 8) | (((w) & GREEN_MASK16) << 5) | \
		(((w) & RED_MASK16) << 3)))

#define MAX_POS_INT		0x7FFFFFFF

#define ALPHAFROMDWORD(a) ((a & ALPHA_MASK) + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bt24p24p.cxx ===
#include "precomp.hxx"

extern "C"
{
#include <dpf.h>
}

#if 0
// This slightly faster bitblt code does it the hard way.  I'm not
// entirely sure about the going backwards and up case, but I'm
// confident otherwise.  We decided not to turn this on since it is a
// small performance gain in an obscure case and didn't justify the
// risk we would introduce at this late date.  The origional, slower
// implementation is below. -mdm 04/18/96
void Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
    BYTE* pbSrcScanLine,
    int iSrcScanStride,
    int iNumSrcRows,
    BYTE* pbDstScanLine,
    int iDstScanStride,
    int iNumDstCols,
    int iNumDstRows)
{   
    DWORD *pdSrcData, *pdDstData,*pdEndOfData;
    int iVertError=0,iVertAdvanceError,iSrcScanAdvance;
    int iAlign, iAlignSrc, iAlignDst,iAlignDstEnd;
    int iLeftSrcShift,iRightSrcShift;
    DWORD dLeftDstMask, dLeftSrcMask, dAlignMask,dRightDstMask;

    // compute advance and error terms for stepping
    // vertically through the src bitmap
    if (iNumSrcRows < iNumDstRows) 
    {
	iSrcScanAdvance = 0;
	iVertAdvanceError = iNumSrcRows;
    } 
    else 
    {
	iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
	iVertAdvanceError = iNumSrcRows % iNumDstRows;
    }

    // Calculate relative alignment ofthe data.  We'll have to shift
    // the data to the right by (dst-src) bits to do DWORD-aligned
    // stores.  In the general unaligned case, we'll be using data
    // from 2 src dwords to fill in the data for the dst.
    iAlignSrc = (((DWORD)pbSrcScanLine) & 0x03) * 8;
    iAlignDst = (((DWORD)pbDstScanLine) & 0x03) * 8;
    iAlignDstEnd = ((((DWORD)pbDstScanLine) + iNumDstCols * 3) & 0x03) * 8;
    iAlign = iAlignDst - iAlignSrc;

    // Calculate the masks in advance.  Yes, this gives me a headache,
    // too.  The idea is that we're going to break up the blt into a
    // left column, a center part, and a right column.  Since the left
    // and right columns will have DWORDS with data we won't be
    // touching, we'll need some masks to make sure we keep the data.
    dLeftDstMask = ((1 << (32 - iAlignDst)) - 1) << iAlignDst; // mask of bits we'll be replacing in leftmost dst dword
    dLeftSrcMask = ((1 << (32 - iAlignSrc)) - 1) << iAlignSrc; // mask of bits we'll be using form the leftmost src dword.
    if(iAlign < 0)
    {
	dAlignMask = ((1 << (-iAlign)) - 1); // mask of bits we'll be using from the second src dword
    }
    else
    {
	dAlignMask = (1 << (32 - iAlign)) - 1; // mask of bits we'll be using from the second src dword
    }
    dRightDstMask = (1 << iAlignDstEnd) - 1; // mask of bits we'll be replacing in the rightmost dst dword

    // calculate shift necessary to properly align data
    if(iAlign > 0)
    {
	pdSrcData--; // back up because we want our data in the right src dword (for consistency)
	iLeftSrcShift = 32 - iAlign;
	iRightSrcShift = iAlign;
    }
    else if(iAlign < 0)
    {
	iLeftSrcShift = -iAlign;
	iRightSrcShift = 32 - (-iAlign);
    }
    else // iAlign == 0
    {
	iLeftSrcShift = 0;
	iRightSrcShift = 31;
    }

// NOTE WATCH OUT FOR CASES WHERE WE ARE ACTUALLY GOING FROM RIGHT TO LEFT.  NOT HANDLED YET!
    for (int i = 0; i < iNumDstRows; i++) 
    {
	// set up pointers to the first DWORDS on src and dst
	// scanlines, and last DWORD on dst scanline
	pdSrcData = (DWORD*)(((DWORD)pbSrcScanLine) & ~0x03);
	pdDstData = (DWORD*)(((DWORD)pbDstScanLine) & ~0x03);
	pdEndOfData = (DWORD*)(((DWORD)pbDstScanLine + iNumDstCols * 3) & ~0x03);

	// Do the left column
	if(iAlignSrc || iAlignDst)
	{
	    if(iAlign)
	    {
		*pdDstData = ( (*pdDstData & ~dLeftDstMask) | // old data
			       (((pdSrcData[0] & dLeftSrcMask) >> iLeftSrcShift) | // data from first src dword
				(((pdSrcData[1] & dAlignMask) << iRightSrcShift )) & dLeftDstMask) );
	    }
	    else // iAlign == 0
	    {
		// No shift needed here, just watch out for the old data
		*pdDstData = (*pdDstData & ~dLeftDstMask) | (*pdSrcData & dLeftSrcMask);
	    }

	    pdSrcData++;
	    pdDstData++;
	}

	// Now do the center section
	if(iAlign)
	{
	    while(pdDstData < pdEndOfData)
	    {
		*pdDstData = (((pdSrcData[0] & ~dAlignMask) >> iLeftSrcShift) | // data from first src dword
			      ((pdSrcData[1] & dAlignMask) << iRightSrcShift));
		pdSrcData++;
		pdDstData++;
	    }
	}
	else // iAlign == 0
	{
	    while(pdDstData < pdEndOfData)
	    {
		*pdDstData++ = *pdSrcData++;
	    }
	}

	// Do the right column
	if(dRightDstMask)
	{
	    if(iAlign)
	    {
		*pdDstData = ( (*pdDstData & ~dRightDstMask) | // old data
			       ( (((pdSrcData[0] & ~dAlignMask) >> iLeftSrcShift) | // data from first src dword
				  ((pdSrcData[1] & dAlignMask) << iRightSrcShift)) & dRightDstMask) );
	    }
	    else // iAlign == 0
	    {
		*pdDstData =(*pdDstData & ~dRightDstMask) | (*pdSrcData & dRightDstMask);
	    }
	}

	// advance to next scanline
	pbSrcScanLine += iSrcScanAdvance;
	pbDstScanLine += iDstScanStride;
	
        // update and check vertical stepping error,
	// adjust src scanline pointer if necessary
	iVertError += iVertAdvanceError;
	if (iVertError >= iNumDstRows) 
	{
	    pbSrcScanLine += iSrcScanStride;
	    iVertError -= iNumDstRows;
	}
    }
}
#endif // 0

void Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel,
				*ptEndDstPixel;
    int		    iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance;

    // compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel)
		{
		    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
		    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
		    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
		    ptDstPixel++;
		    ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

        // update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}

	}
}

void Blt24Pto24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
    int		    iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance,
			    iHorizError,
			    iHorizAdvanceError,
			    iSrcPixelAdvance;

    // compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {
		// set up pointers to the first pixels
		// on src and dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++)
		{
		    // copy a pixel
		    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
		    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
		    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
		
		    // advance to next pixel
		    ptSrcPixel += iSrcPixelAdvance;
		    ptDstPixel += iHorizMirror;
		
		    // update and check horizontal stepping error,
		    // adjust src pixel pointer if necessary
		    iHorizError += iHorizAdvanceError;
		    if (iHorizError >= iNumDstCols) {
			ptSrcPixel++;
			iHorizError -= iNumDstCols;
		    }
		}
		
		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;
		
		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
		    pbSrcScanLine += iSrcScanStride;
		    iVertError -= iNumDstRows;
		}
	}
}

void Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	int		iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance;


	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
			{
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

        // update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}

	}
}

void Blt24Pto24P_NoBlend_Trans_NoHcopy_SRCCOPY(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror,
									COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	int		    iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance,
			    iHorizError,
			    iHorizAdvanceError,
			    iSrcPixelAdvance;

	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
			{
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}

            // advance to next pixel
			ptSrcPixel += iSrcPixelAdvance;
			ptDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				ptSrcPixel++;
				iHorizError -= iNumDstCols;
			}

		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

       	// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows)
        {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}

	}
}


void Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY_VCopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent)
{
	RGBTRIPLE    *ptSrcPixel;
	RGBTRIPLE    *ptDstPixel;
	RGBTRIPLE    *ptEndDstPixel;
	BYTE		*pbEndDstScanLine;
	DWORD		dwPixel;

	// set up pointer to next dst scanline beyond last
	pbEndDstScanLine = pbDstScanLine + iNumDstRows * iDstScanStride;

	while (pbDstScanLine != pbEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
			{
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

#ifndef DDRAW
void Blt24Pto24P_Blend_NoTrans_Hcopy_SRCCOPY_VCopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel,
				*ptEndDstPixel;
	BYTE		*pbEndDstScanLine;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;
	DWORD		dwSrcColor; 

	// set up pointer to next dst scanline beyond last
	pbEndDstScanLine = pbDstScanLine + iNumDstRows * iDstScanStride;

	while (pbDstScanLine != pbEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel) {
			dwSrcColor = (ptSrcPixel->rgbtRed << 16) | 
				     (ptSrcPixel->rgbtGreen << 8) | 
				     (ptSrcPixel->rgbtBlue);

			BlitLib_BLIT_BLEND24(dwSrcColor, ptDstPixel++, uiAlpha, uiAlphaComp);
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

void Blt24Pto24P_Blend_Trans_Hcopy_SRCCOPY_VCopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent,
									ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel,
				*ptEndDstPixel;
	BYTE		*pbEndDstScanLine;
	DWORD		dwPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;

	// set up pointer to next dst scanline beyond last
	pbEndDstScanLine = pbDstScanLine + iNumDstRows * iDstScanStride;

	while (pbDstScanLine != pbEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
				BlitLib_BLIT_BLEND24(dwPixel, ptDstPixel,
									uiAlpha, uiAlphaComp);
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}
#endif

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_LeftToRight_BottomToTop_Trans_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_LeftToRight_BottomToTop_Trans_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK){
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine -= iSrcScanStride;
		pbDstScanLine -= iDstScanStride;
	}

}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_RightToLeft_TopToBottom_Trans_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_RightToLeft_TopToBottom_Trans_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK){
    			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel--;
			ptSrcPixel--;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_LeftToRight_BottomToTop_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_LeftToRight_BottomToTop_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;
	DWORD		dwSrcColor;


	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {
		    	dwSrcColor = (ptSrcPixel->rgbtRed << 16) | 
				     (ptSrcPixel->rgbtGreen << 8) | 
				     (ptSrcPixel->rgbtBlue);

			BlitLib_BLIT_BLEND24(dwSrcColor, ptDstPixel++,
									uiAlpha, uiAlphaComp);
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine -= iSrcScanStride;
		pbDstScanLine -= iDstScanStride;
	}

}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_RightToLeft_TopToBottom_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_RightToLeft_TopToBottom_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;
	DWORD		dwSrcColor;


	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {
		    	dwSrcColor = (ptSrcPixel->rgbtRed << 16) | 
				     (ptSrcPixel->rgbtGreen << 8) | 
				     (ptSrcPixel->rgbtBlue);
			BlitLib_BLIT_BLEND24(dwSrcColor, ptDstPixel--,
									uiAlpha, uiAlphaComp);
			ptSrcPixel--;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_LeftToRight_BottomToTop_Trans_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_LeftToRight_BottomToTop_Trans_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

		    	dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
				BlitLib_BLIT_BLEND24(dwPixel, ptDstPixel,
									uiAlpha, uiAlphaComp);
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine -= iSrcScanStride;
		pbDstScanLine -= iDstScanStride;
	}

}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_RightToLeft_TopToBottom_Trans_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_RightToLeft_TopToBottom_Trans_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;


	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

		    	dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
				BlitLib_BLIT_BLEND24(dwPixel, ptDstPixel,
									uiAlpha, uiAlphaComp);
			ptDstPixel--;
			ptSrcPixel--;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt1616.cxx ===
#include "precomp.hxx"



void Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel,
			*pwEndDstScanLine;

	// set up pointer to next dst scanline beyond last
	pwEndDstScanLine = pwDstScanLine + iNumDstRows * iDstScanStride;

	while (pwDstScanLine != pwEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = *pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanStride;
		pwDstScanLine += iDstScanStride;
	}
}

void Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = *pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
			*pwDstPixel = *pwSrcPixel;

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									WORD wTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}
			pwSrcPixel++;
			pwDstPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_NoBlend_Trans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    WORD wTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#ifndef DDRAW
void Blt16to16_Blend_NoTrans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
                                    int iSrcScanStride,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
								uiAlpha,uiAlphaComp);
			pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_Blend_NoTrans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
 			*pwDstPixel = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
 										uiAlpha,uiAlphaComp);

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_Blend_Trans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
                                    int iSrcScanStride,
								    int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    WORD wTransparentColor,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
											uiAlpha,uiAlphaComp);
			}
			pwSrcPixel++;
			pwDstPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_Blend_Trans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    WORD wTransparentColor,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
											uiAlpha,uiAlphaComp);
			}

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#endif
// 
// The following blits are included with the 16bpp blits because they are
// entensions of them.  The only difference between these blits and the
// regular 16bpp blits is that these blits only use an 8bpp palette index
// for the transparent color.  The rest of the blit is exactly the same.
//
void Blt08Ato08A_NoBlend_Trans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									BYTE bTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if ((BYTE)*pwSrcPixel != bTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}
			pwSrcPixel++;
			pwDstPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}


void Blt08Ato08A_NoBlend_Trans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    BYTE bTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if ((BYTE)*pwSrcPixel != bTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}


///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_LeftToRight_BottomToTop_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from left to right and bottom to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_LeftToRight_BottomToTop_SRCCOPY(WORD* pwSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pwDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = *pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine -= iSrcScanStride;
		pwDstScanLine -= iDstScanStride;
	}
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_RightToLeft_TopToBottom_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from right to left and top to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_RightToLeft_TopToBottom_SRCCOPY(WORD* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	WORD	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++)
			*pDstPixel-- = *pSrcPixel--;

		// advance to next scanline
		pSrcScanLine += iSrcScanStride;
		pDstScanLine += iDstScanStride;

	}	
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_LeftToRight_BottomToTop_Trans_SRCCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_LeftToRight_BottomToTop_Trans_SRCCOPY(WORD* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              WORD wTransparentIndex)
{
	WORD	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != wTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel++;
			pDstPixel++;
		}

		// advance to next scanline
		pSrcScanLine -= iSrcScanStride;
		pDstScanLine -= iDstScanStride;

	}	
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_RightToLeft_TopToBottom_Trans_SRCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_RightToLeft_TopToBottom_Trans_SRCCOPY(WORD* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              WORD wTransparentIndex)
{
	WORD	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != wTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel--;
			pDstPixel--;
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanStride;
		pDstScanLine += iDstScanStride;

	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bltos.h ===
/********************************************************
* bltos.h                               
*                                         
* os specific functionality for blitlib
*                                         
* history                                 
*       7/7/95   created it                     myronth
*
*  Copyright (c) Microsoft Corporation 1994-1995                                                                         
*                                        
*********************************************************/

// Currently, DDraw is the only Win95 app linking with BlitLib
// and it uses local memory allocation.

// The following #define enables all other NT BlitLib applications to
// link with it and get global memory allocation.

#if WIN95 | MMOSA 

#include "memalloc.h"
#define osMemAlloc MemAlloc
#define osMemFree MemFree
#define osMemReAlloc MemReAlloc

#else

#define osMemAlloc(size) LocalAlloc(LPTR,size)
#define osMemFree LocalFree
#define osMemReAlloc(ptr,size) LocalReAlloc((HLOCAL)ptr,size,LPTR)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\gfxtypes.h ===
typedef DWORD ALPHAREF;
typedef ALPHAREF *LPALPHAREF;

#define ALPHA_INVALID 0xffffffff
typedef BYTE *PDIBBITS;
typedef LPBITMAPINFO PDIBINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\sources.inc ===
TARGETNAME = blitlib
TARGETPATH = obj
TARGETTYPE = LIBRARY

SOURCES = \
    ..\bitblt.cxx   \
    ..\blt1616.cxx  \
    ..\blt2424.cxx  \
    ..\blt0101.cxx  \
    ..\bt24p24p.cxx \
    ..\blt0808.cxx

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\precomp.hxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\util4d.h ===
#ifndef _UTIL4D_H_
#define _UTIL4D_H_

#define	ULONG_MAX	0xffffffff

#ifdef _4DEXPORTING
#define	DLLDECL	dllexport
#else
#define	DLLDECL	dllimport
#endif

#define	STD4DDLL		__declspec(DLLDECL) __stdcall
#define	STD4DDLL_(type)	__declspec(DLLDECL) type __stdcall

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\dibfx.h ===
/*-----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       	|
|									       										|
|   History:                                                                    |
|       06/23/89 toddla     Created 											|
|		04/25/94 michaele	Using in sprite library, removed all dib.c funcs	|
|							only using the MACRO stuff.                        	|
|                                                                              	|
\*-----------------------------------------------------------------------------*/

#ifndef _INC_DIB_
#define _INC_DIB_

#ifdef __cplusplus
extern "C" {
#endif

typedef     LPBITMAPINFOHEADER 	PDIB;
typedef     HANDLE             	HDIB;

#ifdef WIN32
#define 	HFILE   			HANDLE
#endif

PDIB        DibOpenFile(LPTSTR szFile);
BOOL        DibWriteFile(PDIB pdib, LPTSTR szFile);
PDIB        DibReadBitmapInfo(HFILE fh);
HPALETTE    DibCreatePalette(PDIB pdib);
BOOL        DibSetUsage(PDIB pdib, HPALETTE hpal,UINT wUsage);
BOOL        DibDraw(HDC hdc, int x, int y, int dx, int dy, PDIB pdib,
				int x0, int y0,	int dx0, int dy0, LONG rop, UINT wUsage);
PDIB        DibCreate(int bits, int dx, int dy);
PDIB        DibCopy(PDIB pdib);
void        DibMapToPalette(PDIB pdib, HPALETTE hpal);
PDIB 	    DibConvert(PDIB pdib, int BitCount, DWORD biCompression);
PDIB		DibHalftoneDIB(PDIB pdib);

PDIB        DibFromBitmap(HBITMAP hbm, DWORD biStyle, UINT biBits,
							HPALETTE hpal, UINT wUsage);
HBITMAP     BitmapFromDib(PDIB pdib, HPALETTE hpal, UINT wUsage);

void        MakeIdentityPalette(HPALETTE hpal);
HPALETTE    CopyPalette(HPALETTE hpal);

/****************************************************************************
 DIB macros.
 ***************************************************************************/

#ifdef  WIN32
    #define HandleFromDib(lpbi) GlobalHandle(lpbi)
#else
    #define HandleFromDib(lpbi) (HANDLE)GlobalHandle(SELECTOROF(lpbi))
#endif

#define DibFromHandle(h)        (PDIB)GlobalLock(h)

#define DibFree(pdib)           GlobalFreePtr(pdib)

#define WIDTHBYTES(i)	((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

#define DibWidth(lpbi)			(UINT)(((LPBITMAPINFOHEADER)(lpbi))->biWidth)
#define DibHeight(lpbi)         (((LPBITMAPINFOHEADER)(lpbi))->biHeight)
#define DibBitCount(lpbi)       (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biBitCount)
#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)

#define DibWidthBytesN(lpbi, n) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(n))
#define DibWidthBytes(lpbi)     DibWidthBytesN(((LPBITMAPINFOHEADER)lpbi), \
								((LPBITMAPINFOHEADER)lpbi)->biBitCount)

#define DibSizeImage(lpbi)		((lpbi)->biSizeImage == 0 \
	                            ? ((DWORD)(UINT)DibWidthBytes(lpbi) * \
	                            (DWORD)(UINT)(lpbi)->biHeight) \
	                            : (lpbi)->biSizeImage)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + \
								(int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))

#define DibFlipY(lpbi, y)       ((int)(lpbi)->biHeight-1-(y))

//HACK for NT BI_BITFIELDS DIBs
#ifdef WIN32
    #define DibPtr(lpbi)		((lpbi)->biCompression == BI_BITFIELDS \
                               	? (LPVOID)(DibColors(lpbi) + 3) \
                               	: (LPVOID)(DibColors(lpbi) + \
                               	(UINT)(lpbi)->biClrUsed))
#else
    #define DibPtr(lpbi)        (LPVOID)(DibColors(lpbi) + \
    							(UINT)(lpbi)->biClrUsed)
#endif

#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + \
								(int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && \
								(lpbi)->biBitCount <= 8 \
                                ? (int)(1 << (int)(lpbi)->biBitCount) \
                                : (int)(lpbi)->biClrUsed)

#define DibXYN(lpbi,pb,x,y,n)   (LPVOID)( \
                                (BYTE *)(pb) + \
                                (UINT)((UINT)(x) * (UINT)(n) / 8u) + \
                                ((DWORD)DibWidthBytesN(lpbi,n) * \
                                (DWORD)(UINT)(y)))

#define DibXY(lpbi,x,y)		DibXYN(lpbi,DibPtr(lpbi),x,y,(lpbi)->biBitCount)

#define FixBitmapInfo(lpbi)     if ((lpbi)->biSizeImage == 0)                 \
                                    (lpbi)->biSizeImage = DibSizeImage(lpbi); \
                                if ((lpbi)->biClrUsed == 0)                   \
                                    (lpbi)->biClrUsed = DibNumColors(lpbi);   \
                                if ((lpbi)->biCompression == BI_BITFIELDS &&  \
                                	(lpbi)->biClrUsed == 0) \
                                    ; // (lpbi)->biClrUsed = 3;

#define DibInfo(pDIB)			((BITMAPINFO FAR *)(pDIB))

/****************************************************************************
 ***************************************************************************/

#ifndef BI_BITFIELDS
	#define BI_BITFIELDS 3
#endif

#ifndef HALFTONE
	#define HALFTONE COLORONCOLOR
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DIB_

/*************************************************************************
	dibfx.h

	Header file for various DIB-to-DIB effects

	02/08/94	Compiled by Jonbl
*/

#ifndef _INC_DIBFX_
#define _INC_DIBFX_

#ifdef WIN95
	#ifndef _INC_WINDOWS
	#include <windows.h>
	#include <windowsx.h>
	#endif
#endif //WIN95

#ifdef __cplusplus
extern "C" {
#endif

/*************************************************************************
	Many of the DIBFX functions use fixed point calculations internally.

	These functions are defined in fixed32.asm
*/

typedef long Fixed;

Fixed __stdcall FixedMultiply( Fixed Multiplicand, Fixed Multiplier );

Fixed __stdcall FixedDivide( Fixed Dividend, Fixed Divisor );

#define IntToFixed(i) (Fixed)( ((long)(i)) << 16 )
#define FixedToShort(f) (short)( ((long)f) >> 16 )

/*
 *	DibClear
 *	Fills a DIB's memory with a given value, effectively clearing
 *	an 8-bit, 4-bit or 1-bit DIB.
 *
 *	Does not do what you would expect on 16, 24, or 32-bit DIBs,
 *	but it will work.
 *
 *	Source is in clear.c and clear32.asm
 */

BOOL FAR PASCAL DibClear(LPBITMAPINFO lpbiDst, LPVOID lpDst, BYTE value);



#ifdef __cplusplus
}
#endif

#endif // _INC_DIBFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\ddhelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhelp.c
 *  Content: 	helper app to cleanup after dead processes
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-mar-95	craige	initial implementation
 *   09-may-95	craige	call fn in dll
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   29-nov-95  angusm  added DDHELPREQ_CREATEDSFOCUSTHREAD
 *   18-jul-96	andyco	added dplayhelp_xxx functions to allow > 1 dplay app to
 *			host a game on a single machine.
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *			it in dphelps receive thread before forwarding requests
 *   05-oct-96  colinmc fixed build breaker with CRITICAL SECTION stuff
 *   12-oct-96  colinmc new service to load the DirectX VXD into DDHELP
 *                      (necessary for the Win16 lock stuff)
 *   18-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#ifndef __DDHELP_INCLUDED__
#define __DDHELP_INCLUDED__

/*
 * globals
 */
#ifndef NO_D3D
extern CRITICAL_SECTION    	cs; 	// the crit section we take in winmain
					// this is a global so dphelp can take it before
					// forwarding enum requests that come in on its
					// receive thread (manbugs 3907)
#endif

/*
 * named objects
 */
#define DDHELP_EVENT_NAME		"__DDHelpEvent__"
#define DDHELP_ACK_EVENT_NAME		"__DDHelpAckEvent__"
#define DDHELP_STARTUP_EVENT_NAME	"__DDHelpStartupEvent__"
#define DDHELP_SHARED_NAME		"__DDHelpShared__"
#define DDHELP_MUTEX_NAME		"__DDHelpMutex__"
#define DDHELP_MODESET_EVENT_NAME	"__DDHelpModeSetEvent%d__"
#define DDHELP_DOSBOX_EVENT_NAME	"__DDHelpDOSBoxSetEvent%d__"
#define DDHELP_APMSUSPEND_EVENT_NAME    "__DDHelpApmSuspendEvent__"
#define DDHELP_APMRESUME_EVENT_NAME     "__DDHelpApmResumeEvent__"

/*
 * requests
 */
#define DDHELPREQ_NEWPID		1
#define DDHELPREQ_NEWDC			2
#define DDHELPREQ_FREEDCLIST		3
#define DDHELPREQ_RETURNHELPERPID	4
#define DDHELPREQ_LOADDLL		5
#define DDHELPREQ_FREEDLL		6
#define DDHELPREQ_SUICIDE		7
#define DDHELPREQ_KILLATTACHED		8
#define DDHELPREQ_WAVEOPEN		9
#define DDHELPREQ_WAVECLOSE		10
#define DDHELPREQ_CREATETIMER		11
#define DDHELPREQ_KILLTIMER		12
#define DDHELPREQ_CREATEHELPERTHREAD	13
#define DDHELPREQ_CREATEMODESETTHREAD	14
#define DDHELPREQ_KILLMODESETTHREAD	15
#define DDHELPREQ_CREATEDSMIXERTHREAD	16
#define DDHELPREQ_CALLDSCLEANUP         17
#define DDHELPREQ_CREATEDSFOCUSTHREAD	18
#define DDHELPREQ_DPLAYADDSERVER	19
#define DDHELPREQ_DPLAYDELETESERVER	20
#ifdef WIN95
    #define DDHELPREQ_GETDSVXDHANDLE        21
#endif /* WIN95 */
#define DDHELPREQ_NOTIFYONDISPLAYCHANGE	22
#ifdef WIN95
    #define DDHELPREQ_CREATEDOSBOXTHREAD    23
    #define DDHELPREQ_KILLDOSBOXTHREAD      24
#endif /* WIN95 */
#define DDHELPREQ_LOADLIBRARY           25
#define DDHELPREQ_FREELIBRARY           26
#define DDHELPREQ_STOPWATCHPID          27
#define DDHELPREQ_ADDDEVICECHANGENOTIFY 28
#define DDHELPREQ_DELDEVICECHANGENOTIFY 29
#ifdef WIN95
    #define DDHELPREQ_GETDDVXDHANDLE        30
#endif /* WIN95 */

/*
 * callback routine
 */
typedef BOOL	(FAR PASCAL *LPHELPNOTIFYPROC)(struct DDHELPDATA *);
typedef BOOL	(FAR PASCAL *LPHELPMODESETNOTIFYPROC)( LPVOID lpDD );
typedef void    (FAR PASCAL *LPDSCLEANUP)(LPVOID pds);
typedef BOOL    (FAR PASCAL *LPDEVICECHANGENOTIFYPROC)(UINT, DWORD);

/*
 * communication data
 */
typedef struct DDHELPDATA
{
    int			req;
    HANDLE		req_id;
    DWORD		pid;
    BOOL		isdisp;
    union
    {
	LPHELPNOTIFYPROC	lpNotify;
	LPHELPMODESETNOTIFYPROC	lpModeSetNotify;
    };
    DWORD		context;
    char		fname[260];
    char		func[64];
    ULONG_PTR	        dwData1;
    ULONG_PTR	        dwData2;
    LPVOID		pData1;
    LPVOID		pData2;
    ULONG_PTR	        dwReturn;
} DDHELPDATA, *LPDDHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\blitlib\ntblt.h ===
#include <stddef.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#ifdef NT_KERNEL
    #include <ntos.h>
    #include <zwapi.h>
    #include <wingdip.h>
#endif
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>

#ifndef NT_KERNEL
    #include <winnt.h>
    #include <winbase.h>
    #include <winuser.h>
#endif
typedef ULONG SCODE;
typedef long HRESULT;

//#include "ntkmode.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\ddhelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhelp.c
 *  Content: 	helper app to cleanup after dead processes
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-mar-95	craige	initial implementation
 *   05-apr-95	craige	re-worked
 *   11-apr-95	craige	fixed messed up freeing of DC list
 *   12-apr-95	craige	only allocate each DC once
 *   09-may-95	craige	call fn in dll
 *   24-jun-95	craige	track pids; slay all attached if asked
 *   19-jul-95	craige	free DC list at DDRAW request
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset;
 *			memory allocation bugs
 *   15-aug-95	craige	bug 538: 1 thread/process being watched
 *   02-sep-95	craige	bug 795: prevent callbacks at WM_ENDSESSION
 *   16-sep-95	craige	bug 1117: don't leave view of file mapped always
 *   16-sep-95	craige	bug 1117: also close thread handles when done!
 *   20-sep-95	craige	bug 1172: turn off callbacks instead of killing self
 *   22-sep-95	craige	bug 1117: also don't alloc dll structs unboundedly
 *   29-nov-95  angusm  added case for creating a sound focus thread
 *   12-jul-96	kylej	Change ExitProcess to TerminateProcess on exception
 *   18-jul-96	andyco	added dplayhelp_xxx functions to allow > 1 dplay app to
 *			host a game on a single machine.
 *   25-jul-96  andyco	watchnewpid - broke code out of winmain so dplayhelp_addserver
 *			could call it.
 *   2-oct-96	andyco	propagated from \orange\ddhelp.2 to \mustard\ddhelp
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *			it in dphelps receive thread before forwarding requests
 *   12-oct-96  colinmc new service to load the DirectX VXD into DDHELP
 *                      (necessary for the Win16 lock stuff)
 *   15-oct-96  toddla  multimonitor support (call CreateDC with device name)
 *   22-jan-97  kipo	return an error code from DPlayHelp_AddServer
 *   23-jan-97  dereks  added APM notification events
 *   27-jan-97  colinmc vxd handling stuff is no longer Win16 specific
 *   29-jan-97  colinmc 
 *   24-feb-97	ketand	Add a callback for WM_DISPLAYCHANGE
 *   19-mar-97  twillie Exorcized the DPlay Demon from DDHelp
 *
 ***************************************************************************/

#include "pch.c"

#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN

#ifdef WIN95
#ifdef _WIN32
#define WINMMDEVICECHANGEMSGSTRINGA "winmm_devicechange"
#define WINMMDEVICECHANGEMSGSTRINGW L"winmm_devicechange"
#ifdef UNICODE
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGW
#else
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGA
#endif
#else
#define WINMMDEVICECHANGEMSGSTRING "winmm_devicechange"
#endif

#define FILE_FLAG_GLOBAL_HANDLE	0x00800000
WINBASEAPI
DWORD
WINAPI
RegisterServiceProcess(
    DWORD dwProcessId,
    DWORD dwServiceType
    );

#define RSP_UNREGISTER_SERVICE  0x00000000
#define RSP_SIMPLE_SERVICE      0x00000001
#endif

#ifndef WIN95
    #ifdef DBG
        #undef DEBUG
        #define DEBUG
    #endif
#endif

//#include <windows.h>
//#include <mmsystem.h>
#include <mmreg.h>
#undef PBT_APMRESUMEAUTOMATIC
#include <pbt.h>
#include <dbt.h>

//#include "ddhelp.h"
#include "ddrawi.h"
#include "dpf.h"
#define  NOSHARED
#include "memalloc.h"

#ifdef NEED_WIN16LOCK
    extern void _stdcall	GetpWin16Lock( LPVOID FAR *);
    extern void _stdcall	_EnterSysLevel( LPVOID );
    extern void _stdcall	_LeaveSysLevel( LPVOID );
    LPVOID			lpWin16Lock;
#endif

HANDLE 			hInstApp;
extern BOOL		bIsActive;
BOOL			bHasModeSetThread;
BOOL			bNoCallbacks;
extern void 		HelperThreadProc( LPVOID *pdata );
CRITICAL_SECTION    	cs; 	// the crit section we take in winmain
				// this is a global so dphelp can take it before
				// forwarding enum requests that come in on its
				// receive thread (manbugs 3907)
HANDLE                  hApmSuspendEvent;   // Event set when we enter an APM suspension state
HANDLE                  hApmResumeEvent;    // Event set when we leave the above state

#ifdef WIN95
    UINT                    gumsgWinmmDeviceChange = 0; // window message for
                                                        // winmm device changes

    /*
     * Handle to the DirectSound VXD. DDHELP needs its own handle as, on mode
     * switches and cleanups DDHELP can invoked DDRAW code that needs to talk
     * to the VXD. The VXD is opened on the first request from a client (currently
     * only DDRAW) and closed only when DDHELP shuts down.
     */
    HANDLE		    hDSVxd = INVALID_HANDLE_VALUE;
    HANDLE                  hDDVxd = INVALID_HANDLE_VALUE;

    typedef struct _DEVICECHANGENOTIFYLIST
    {
        struct _DEVICECHANGENOTIFYLIST *link;
        LPDEVICECHANGENOTIFYPROC        lpNotify;
    } DEVICECHANGENOTIFYLIST, *LPDEVICECHANGENOTIFYLIST;

    LPDEVICECHANGENOTIFYLIST lpDeviceChangeNotifyList;
#endif /* WIN95 */

typedef struct HDCLIST
{
    struct HDCLIST	*link;
    HDC			hdc;
    HANDLE		req_id;
    char		isdisp;
    char		fname[1];
} HDCLIST, *LPHDCLIST;

static LPHDCLIST	lpHDCList;

typedef struct HDLLLIST
{
    struct HDLLLIST	*link;
    HANDLE		hdll;
    DWORD		dwRefCnt;
    char		fname[1];
} HDLLLIST, *LPHDLLLIST;

static LPHDLLLIST	lpHDLLList;

/*
 * 8 callbacks: we can use up to 3 currently: ddraw, dsound
 */
#define MAX_CALLBACKS	8

typedef struct _PROCESSDATA
{
    struct _PROCESSDATA		*link;
    DWORD			pid;
    struct
    {
	LPHELPNOTIFYPROC	lpNotify;
	HANDLE			req_id;
    } pdata[MAX_CALLBACKS];
} PROCESSDATA, *LPPROCESSDATA;

LPPROCESSDATA		lpProcessList;
CRITICAL_SECTION	pdCSect;


typedef struct THREADLIST
{
    struct THREADLIST	*link;
    ULONG_PTR	        hInstance;
    HANDLE		hEvent;
} THREADLIST, *LPTHREADLIST;

typedef struct
{
    LPVOID			lpDD;
    LPHELPMODESETNOTIFYPROC	lpProc;
    HANDLE			hEvent;
} MODESETTHREADDATA, *LPMODESETTHREADDATA;

LPTHREADLIST	lpThreadList;
THREADLIST	DOSBoxThread;

// Who to call when a display change message is sent to the
// DDHELPER's window. This variable is reserved by DDraw.
// This works because DDraw itself is loaded into DDHelper's
// process and so the function will remain valid.
VOID (*g_pfnOnDisplayChange)(void) = NULL;

/*
 * freeDCList
 *
 * Free all DC's that an requestor allocated.
 */
void freeDCList( HANDLE req_id )
{
    LPHDCLIST	pdcl;
    LPHDCLIST	last;
    LPHDCLIST	next;

    DPF( 4, "Freeing DCList" );
    pdcl = lpHDCList;
    last = NULL;
    while( pdcl != NULL )
    {
	next = pdcl->link;
	if( (pdcl->req_id == req_id) || req_id == (HANDLE) -1 )
	{
	    if( last == NULL )
	    {
		lpHDCList = lpHDCList->link;
	    }
	    else
	    {
		last->link = pdcl->link;
	    }
	    if( pdcl->isdisp )
	    {
		DPF( 5, "    ReleaseDC( NULL, %08lx)", pdcl->hdc );
//		ReleaseDC( NULL, pdcl->hdc );
		DeleteDC( pdcl->hdc );
		DPF( 5, "    Back from Release" );
	    }
	    else
	    {
		DPF( 5, "    DeleteDC( %08lx)", pdcl->hdc );
		DeleteDC( pdcl->hdc );
		DPF( 5, "    Back from DeleteDC" );
	    }
	    MemFree( pdcl );
	}
	else
	{
	    last = pdcl;
	}
	pdcl = next;
    }
    if ( req_id == (HANDLE) -1 )
    {
        DDASSERT (lpHDCList == NULL);
    }
    DPF( 4, "DCList FREE" );

} /* freeDCList */

/*
 * addDC
 */
void addDC( char *fname, BOOL isdisp, HANDLE req_id )
{
    LPHDCLIST	pdcl;
    HDC		hdc;
    UINT	u;

    pdcl = lpHDCList;
    while( pdcl != NULL )
    {
	if( !_stricmp( fname, pdcl->fname ) )
	{
	    DPF( 4, "DC for %s already obtained (%08lx)", fname, pdcl->hdc );
	    return;
	}
	pdcl = pdcl->link;
    }

    if( isdisp )
    {
	hdc = CreateDC( "display", NULL, NULL, NULL);
	DPF( 4, "CreateDC( \"display\" ) = %08lx", hdc );
    }
    else
    {
	DPF( 4, "About to CreateDC( \"%s\" )", fname );
        //
        //  if fname is a device name of the form "\\.\XXXXXX"
        //  we need to call CreateDC differently
        //
        u = SetErrorMode( SEM_NOOPENFILEERRORBOX );
        if (fname && fname[0] == '\\' && fname[1] == '\\' && fname[2] == '.')
            hdc = CreateDC( NULL, fname, NULL, NULL);
        else
            hdc = CreateDC( fname, NULL, NULL, NULL);
	SetErrorMode( u );
    }

    pdcl = MemAlloc( sizeof( HDCLIST ) + lstrlen( fname ) );
    if( pdcl != NULL )
    {
	pdcl->hdc = hdc;
	pdcl->link = lpHDCList;
	pdcl->isdisp = (CHAR)isdisp;
	pdcl->req_id = req_id;
	lstrcpy( pdcl->fname, fname );
	lpHDCList = pdcl;
    }

} /* addDC */

/*
 * loadDLL
 */
DWORD loadDLL( LPSTR fname, LPSTR func, DWORD context )
{
    HANDLE	hdll;
    LPHDLLLIST  pdll;
    DWORD       rc = 0;

    /*
     * load the dll
     */
    hdll = LoadLibrary( fname );
    DPF( 5, "%s: hdll = %08lx", fname, hdll );
    if( hdll == NULL )
    {
	DPF( 1, "Could not load library %s",fname );
	return 0;
    }

    /*
     * invoke specified function
     */

    if( func[0] != 0 )
    {
	LPDD32BITDRIVERINIT	pfunc;
	pfunc = (LPVOID) GetProcAddress( hdll, func );
	if( pfunc != NULL )
	{
            rc = pfunc( context );
	}
	else
	{
            DPF( 1, "Could not find procedure %s", func );
	}
    }
    else
    {
        rc = 1;
    }

    /*
     * see if we have recorded this DLL loading already
     */
    pdll = lpHDLLList;
    while( pdll != NULL )
    {
	if( !lstrcmpi( pdll->fname, fname ) )
	{
	    DPF( 3, "DLL '%s' already loaded", fname );
	    break;
	}
	pdll = pdll->link;
    }
    if( pdll == NULL )
    {
	pdll = MemAlloc( sizeof( HDLLLIST ) + lstrlen( fname ) );
	if( pdll != NULL )
	{
	    pdll->hdll = hdll;
	    pdll->link = lpHDLLList;
	    lstrcpy( pdll->fname, fname );
	    lpHDLLList = pdll;
	}
    }
    if( pdll != NULL )
    {
	pdll->dwRefCnt++;
    }
    return rc;

} /* loadDLL */

/*
 * freeDLL
 */
HANDLE freeDLL( LPSTR fname )
{
    LPHDLLLIST	pdll;
    LPHDLLLIST	last;
    HANDLE	hdll;

    pdll = lpHDLLList;
    last = NULL;
    while( pdll != NULL )
    {
	if( !lstrcmpi( pdll->fname, fname ) )
	{
	    DPF( 4, "Want to free DLL %s (%08lx)", fname, pdll->hdll );
	    hdll = pdll->hdll;
	    if( last == NULL )
	    {
		lpHDLLList = lpHDLLList->link;
	    }
	    else
	    {
		last->link = pdll->link;
	    }
	    MemFree( pdll );
	    return hdll;
	}
	last = pdll;
	pdll = pdll->link;
    }
    return NULL;

} /* freeDLL */

#ifdef WIN95
    /*
     * return a handle to the DirectSound VXD
     */
    DWORD getDSVxdHandle( void )
    {
        if( INVALID_HANDLE_VALUE == hDSVxd )
	{
	    hDSVxd = CreateFile( "\\\\.\\DSOUND.VXD",
				 GENERIC_WRITE,
				 FILE_SHARE_WRITE,
				 NULL,
				 OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
				 NULL );
	    #ifdef DEBUG
		if( INVALID_HANDLE_VALUE == hDSVxd )
		    DPF( 0, "Could not load the DirectSound VXD" );
	    #endif /* DEBUG */
	}
	return (DWORD) hDSVxd;
    } /* getDSVxdHandle */

    /*
     * return a handle to the DirectDraw VXD
     */
    DWORD getDDVxdHandle( void )
    {
        if( INVALID_HANDLE_VALUE == hDDVxd )
	{
            hDDVxd = CreateFile( "\\\\.\\DDRAW.VXD",
				 GENERIC_WRITE,
				 FILE_SHARE_WRITE,
				 NULL,
				 OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
				 NULL );
	    #ifdef DEBUG
                if( INVALID_HANDLE_VALUE == hDDVxd )
                    DPF( 0, "Could not load the DirectDraw VXD" );
	    #endif /* DEBUG */
	}
        return (DWORD) hDDVxd;
    } /* getDDVxdHandle */

/*
 * addDeviceChangeNotify
 */
void addDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    LPDEVICECHANGENOTIFYLIST    pNode;

    pNode = (LPDEVICECHANGENOTIFYLIST)MemAlloc(sizeof(DEVICECHANGENOTIFYLIST));

    if(pNode)
    {
        pNode->link = lpDeviceChangeNotifyList;
        pNode->lpNotify = lpNotify;

        lpDeviceChangeNotifyList = pNode;
    }

} /* addDeviceChangeNotify */

/*
 * delDeviceChangeNotify
 */
void delDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    LPDEVICECHANGENOTIFYLIST    pNode;
    LPDEVICECHANGENOTIFYLIST    pPrev;

    for(pNode = lpDeviceChangeNotifyList, pPrev = NULL; pNode; pPrev = pNode, pNode = pNode->link)
    {
        if(lpNotify == pNode->lpNotify)
        {
            break;
        }
    }

    if(pNode)
    {
        if(pPrev)
        {
            pPrev->link = pNode->link;
        }

        MemFree(pNode);
    }

} /* delDeviceChangeNotify */

/*
 * onDeviceChangeNotify
 */
BOOL onDeviceChangeNotify(UINT Event, DWORD Data)
{
    BOOL                        fAllow  = TRUE;
    LPDEVICECHANGENOTIFYLIST    pNode;

    __try
    {
        for(pNode = lpDeviceChangeNotifyList; pNode; pNode = pNode->link)
        {
            if(TRUE != pNode->lpNotify(Event, Data))
            {
                fAllow = BROADCAST_QUERY_DENY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF(0, "*********************************************************");
        DPF(0, "******** exception during device change notify **********");
        DPF(0, "*********************************************************");
    }

    return fAllow;

} /* delDeviceChangeNotify */

/*
 * freeDeviceChangeNotifyList
 */
void freeDeviceChangeNotifyList(void)
{
    LPDEVICECHANGENOTIFYLIST    pNext;
    
    while(lpDeviceChangeNotifyList)
    {
        pNext = lpDeviceChangeNotifyList->link;
        MemFree(lpDeviceChangeNotifyList);
        lpDeviceChangeNotifyList = pNext;
    }

} /* freeDeviceChangeNotifyList */
#endif /* WIN95 */

/*
 * freeAllResources
 */
void freeAllResources( void )
{
    LPHDLLLIST	pdll;
    LPHDLLLIST	next;

    freeDCList( (HANDLE) -1 );
    pdll = lpHDLLList;
    while( pdll != NULL )
    {
	while( pdll->dwRefCnt >  0 )
	{
	    FreeLibrary( pdll->hdll );
	    pdll->dwRefCnt--;
	}
	next = pdll->link;
	MemFree( pdll );
	pdll = next;
    }

#ifdef WIN95
    freeDeviceChangeNotifyList();
#endif
} /* freeAllResources */

/*
 * ThreadProc
 *
 * Open a process and wait for it to terminate
 */
VOID ThreadProc( LPVOID *pdata )
{
    HANDLE		hproc;
    DWORD		rc;
    LPPROCESSDATA	ppd;
    LPPROCESSDATA	curr;
    LPPROCESSDATA	prev;
    DDHELPDATA		hd;
    int			i;
    PROCESSDATA		pd;

    ppd = (LPPROCESSDATA) pdata;

    /*
     * get a handle to the process that attached to DDRAW
     */
    DPF( 3, "Watchdog thread started for pid %08lx", ppd->pid );

    hproc = OpenProcess( PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
			    FALSE, ppd->pid );
    if( hproc == NULL )
    {
	DPF( 1, "OpenProcess for %08lx failed!", ppd->pid );
	ExitThread( 0 );
    }

    /*
     * wait for process to die
     */
    rc = WaitForSingleObject( hproc, INFINITE );
    if( rc == WAIT_FAILED )
    {
	DPF( 1, "Wait for process %08lx failed", ppd->pid );
	CloseHandle( hproc );
	ExitThread( 0 );
    }

    /*
     * remove process from the list of watched processes
     */
    EnterCriticalSection( &pdCSect );
    pd = *ppd;
    curr = lpProcessList;
    prev = NULL;
    while( curr != NULL )
    {
	if( curr == ppd )
	{
	    if( prev == NULL )
	    {
		lpProcessList = curr->link;
	    }
	    else
	    {
		prev->link = curr->link;
	    }
	    DPF( 4, "PID %08lx removed from list", ppd->pid );
	    MemFree( curr );
	    break;
	}
	prev = curr;
	curr = curr->link;
    }

    if( bNoCallbacks )
    {
	DPF( 1, "No callbacks allowed: leaving thread early" );
	LeaveCriticalSection( &pdCSect );
	CloseHandle( hproc );
	ExitThread( 0 );
    }

    LeaveCriticalSection( &pdCSect );

    /*
     * tell original caller that process is dead
     *
     * Make a copy to of the process data, and then use that copy.
     * We do this because we will deadlock if we just try to hold it while
     * we call the various apps.
     */
    for( i=0;i<MAX_CALLBACKS;i++ )
    {
	if( pd.pdata[i].lpNotify != NULL )
	{
	    DPF( 3, "Notifying %08lx about process %08lx terminating",
				pd.pdata[i].lpNotify, pd.pid );
            hd.pid = pd.pid;

            try
            {
                rc = pd.pdata[i].lpNotify( &hd );
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                DPF(0, "*********************************************");
                DPF(0, "******** exception during shutdown **********");
                DPF(0, "******** DDHELP is going to exit   **********");
                DPF(0, "*********************************************");
                TerminateProcess(GetCurrentProcess(), 5);
            }

	    /*
	     * did it ask us to free our DC list?
	     */
	    if( rc )
	    {
		freeDCList( pd.pdata[i].req_id );
	    }
	}
    }
    CloseHandle( hproc );

    ExitThread( 0 );

} /* ThreadProc */

static BOOL	bKillNow;
static BOOL	bKillDOSBoxNow;

/*
 * ModeSetThreadProc
 */
void ModeSetThreadProc( LPVOID pdata )
{
    DWORD			rc;
    MODESETTHREADDATA		mstd;

#ifdef WIN95
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL );
#endif

    mstd = *((LPMODESETTHREADDATA)pdata);

    DPF( 5, "Modeset thread started, proc=%08lx, pdrv=%08lx, hEvent=%08lx",
    			mstd.lpProc, mstd.lpDD, mstd.hEvent );
    DPF( 5, "ModeSetThreadProc: hevent = %08lx", mstd.hEvent );

    /*
     * wait for process to die
     */
    while( 1 )
    {
	rc = WaitForSingleObject( mstd.hEvent, INFINITE );
	if( rc == WAIT_FAILED )
	{
	    DPF( 2, "WAIT_FAILED, Modeset thread terminated" );
	    ExitThread( 0 );
	}
	if( bKillNow )
	{
	    bKillNow = 0;
	    CloseHandle( mstd.hEvent );
	    DPF( 4, "Modeset thread now terminated" );
	    ExitThread( 0 );
	}
	DPF( 3, "Notifying DirectDraw of modeset!" );
	mstd.lpProc( mstd.lpDD );
    }

} /* ModeSetThreadProc */

/*
 * DOSBoxThreadProc
 */
void DOSBoxThreadProc( LPVOID pdata )
{
    DWORD			rc;
    MODESETTHREADDATA		mstd;

    mstd = *((LPMODESETTHREADDATA)pdata);

    DPF( 5, "DOS box thread started, proc=%08lx, pdrv=%08lx, hEvent=%08lx",
    			mstd.lpProc, mstd.lpDD, mstd.hEvent );
    DPF( 5, "DOSBoxThreadProc: hevent = %08lx", mstd.hEvent );

    /*
     * wait for process to die
     */
    while( 1 )
    {
	rc = WaitForSingleObject( mstd.hEvent, INFINITE );
	if( rc == WAIT_FAILED )
	{
	    DPF( 2, "WAIT_FAILED, DOS Box thread terminated" );
	    ExitThread( 0 );
	}
	if( bKillDOSBoxNow )
	{
	    bKillDOSBoxNow = 0;
	    CloseHandle( mstd.hEvent );
	    DPF( 4, "DOS box thread now terminated" );
	    ExitThread( 0 );
	}
	DPF( 3, "Notifying DirectDraw of DOS box!" );
	mstd.lpProc( mstd.lpDD );
    }

} /* DOSBoxThreadProc */

/*
 * MainWndProc
 */
LRESULT __stdcall MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
#ifdef WIN95
    BOOL                    f;

    // If we got a message for a WinMM device change, let's convert it
    // into a WM_DEVICECHANGE message with DBT_DEVNODES_CHANGED
    if (message == gumsgWinmmDeviceChange) {
        message = WM_DEVICECHANGE;
        wParam = DBT_DEVNODES_CHANGED;
    }
#endif
    
    switch(message)
    {
        case WM_ENDSESSION:
            /*
             * shoot ourselves in the head
             */
	    if( lParam == FALSE )
	    {
	        DPF( 4, "WM_ENDSESSION" );
	        EnterCriticalSection( &pdCSect );
	        DPF( 4, "Setting NO CALLBACKS" );
	        bNoCallbacks = TRUE;
	        LeaveCriticalSection( &pdCSect );
	    }
	    else
	    {
	        DPF( 4, "User logging off" );
	    }

            break;

        case WM_POWERBROADCAST:
            switch(wParam)
            {
                case PBT_APMSUSPEND:
                    DPF(3, "Entering APM suspend mode...");
                    SetEvent(hApmSuspendEvent);
                    ResetEvent(hApmResumeEvent);
                    break;

                case PBT_APMRESUMESUSPEND:
                case PBT_APMRESUMEAUTOMATIC:
                case PBT_APMRESUMECRITICAL:
                    DPF(3, "Leaving APM suspend mode...");
                    SetEvent(hApmResumeEvent);
                    ResetEvent(hApmSuspendEvent);
                    break;
            }

            break;

	case WM_DISPLAYCHANGE:
	    DPF( 4, "WM_DISPLAYCHANGE" );
	    if( g_pfnOnDisplayChange )
		(*g_pfnOnDisplayChange)();
	    break;

#ifdef WIN95
    case WM_DEVICECHANGE:
        DPF(4, "WM_DEVICECHANGE");

        EnterCriticalSection(&cs);
        f = onDeviceChangeNotify(wParam, lParam);
        LeaveCriticalSection(&cs);

        if (f != TRUE)
        {
            return f;
        }

        break;
#endif
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
} /* MainWndProc */

/*
 * WindowThreadProc
 */
void WindowThreadProc( LPVOID pdata )
{
    static char szClassName[] = "DDHelpWndClass";
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;

    /*
     * turn down the heat a little
     */
#ifdef WIN95
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );

    if (!gumsgWinmmDeviceChange) {
        gumsgWinmmDeviceChange = RegisterWindowMessage(WINMMDEVICECHANGEMSGSTRING);
    }
#endif
    
    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = (WNDPROC)MainWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !RegisterClass( &cls ) )
    {
	DPF( 1, "RegisterClass FAILED!" );
	ExitThread( 0 );
    }

    hwnd = CreateWindow( szClassName, szClassName,
	    WS_POPUP, 0, 0, 0, 0, NULL, NULL, hInstApp, NULL);

    if( hwnd == NULL )
    {
	DPF( 1, "No monitor window!" );
	ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
	TranslateMessage( &msg );
	DispatchMessage( &msg );
    }
    DPF( 4, "Exiting WindowThreadProc" );
    ExitThread( 1 );

} /* WindowThreadProc */

//
// called by WinMain in response to a DDHELPREQ_NEWPID request.
//
void WatchNewPid(LPDDHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    int			i;
    DWORD		tid;

    DPF( 4, "DDHELPREQ_NEWPID" );

    EnterCriticalSection( &pdCSect );
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
	if( ppd->pid == phd->pid )
	{
	    DPF( 4, "Have thread for process %08lx already", phd->pid );
	    /*
	     * look if we already have this callback for this process
	     */
	    for( i=0;i<MAX_CALLBACKS;i++ )
	    {
		if( ppd->pdata[i].lpNotify == phd->lpNotify )
		{
		    DPF( 5, "Notification rtn %08lx already set for pid %08lx",
		    			phd->lpNotify, phd->pid );
		    found = TRUE;
		    break;
		}
	    }
	    if( found )
	    {
		break;
	    }

	    /*
	     * we have a new callback for this process
	     */
	    for( i=0;i<MAX_CALLBACKS;i++ )
	    {
		if( ppd->pdata[i].lpNotify == NULL )
		{
		    DPF( 5, "Setting notification rtn %08lx for pid %08lx",
		    			phd->lpNotify, phd->pid );
	    	    ppd->pdata[i].lpNotify = phd->lpNotify;
		    ppd->pdata[i].req_id = phd->req_id;
		    found = TRUE;
		    break;
		}
	    }
	    if( !found )
	    {
		#ifdef DEBUG
		    /*
		     * this should not happen!
		     */
		    DPF( 0, "OUT OF NOTIFICATION ROOM!" );
		    DebugBreak(); //_asm int 3;
		#endif
	    }
	    break;
	}
	ppd = ppd->link;
    }

    /*
     * couldn't find anyone waiting on this process, so create
     * a brand spanking new thread
     */
    if( !found )
    {
	DPF( 3, "Allocating new thread for process %08lx" );
	ppd = MemAlloc( sizeof( PROCESSDATA ) );
	if( ppd != NULL )
	{
	    HANDLE	h;

	    ppd->link = lpProcessList;
	    lpProcessList = ppd;
	    ppd->pid = phd->pid;
	    ppd->pdata[0].lpNotify = phd->lpNotify;
	    ppd->pdata[0].req_id = phd->req_id;
	    h = CreateThread(NULL,
			 0,
			 (LPTHREAD_START_ROUTINE) ThreadProc,
			 (LPVOID)ppd,
			 0,
			 (LPDWORD)&tid);
	    if( h != NULL )
	    {
		DPF( 5, "Thread %08lx created, initial callback=%08lx",
			    tid, phd->lpNotify );
		CloseHandle( h );
	    }
	    else
	    {
		#ifdef DEBUG
		    DPF( 0, "COULD NOT CREATE HELPER THREAD FOR PID %08lx", phd->pid );
		#endif
	    }
	}
	else
	{
	    #ifdef DEBUG
		DPF( 0, "OUT OF MEMORY CREATING HELPER THREAD FOR PID %08lx", phd->pid );
	    #endif
	}
    }
    LeaveCriticalSection( &pdCSect );
} // WatchNewPid

//
// called by WinMain in response to a DDHELPREQ_STOPWATCHPID request.
//
void StopWatchPid(LPDDHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    int			i;

    DPF( 4, "DDHELPREQ_STOPWATCHPID" );

    EnterCriticalSection( &pdCSect );
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
	if( ppd->pid == phd->pid )
	{
	    /*
	     * look if we already have this callback for this process
	     */
	    for( i=0;i<MAX_CALLBACKS;i++ )
	    {
		if( ppd->pdata[i].lpNotify == phd->lpNotify )
		{
		    DPF( 5, "Remove notification rtn %08lx for pid %08lx", phd->lpNotify, phd->pid );
                    ppd->pdata[i].lpNotify = NULL;
		    found = TRUE;
		    break;
		}
	    }
	    if( found )
	    {
		break;
	    }
	}
	ppd = ppd->link;
    }

    LeaveCriticalSection( &pdCSect );
} // StopWatchPid

/*
 * WinMain
 */
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			LPSTR lpCmdLine, int nCmdShow)
{
    DWORD		tid;
    DWORD		rc;
    HANDLE		hstartevent;
    HANDLE		hstartupevent;
    HANDLE		hmutex;
    HANDLE		hackevent;
    LPDDHELPDATA	phd;
    HANDLE		hsharedmem;
    HANDLE		h;
    char		szSystemDir[1024];

    /*
     * Set our working directory to the system directory.
     * This prevents us from holding network connections open
     * forever if the first DirectDraw app that we run is across
     * a network connection.
     */
    GetSystemDirectory(szSystemDir, sizeof(szSystemDir));
    SetCurrentDirectory(szSystemDir);

    /*
     * when we gotta run, we gotta run baby
     */
#ifdef WIN95
    SetPriorityClass( GetCurrentProcess(), REALTIME_PRIORITY_CLASS );
#endif

#ifdef WIN95
    /*
     * when we gotta run, we gotta and not let the user see us in
     * the task list.
     */
    RegisterServiceProcess( 0, RSP_SIMPLE_SERVICE );
#else
    /*
     * We must guarantee that ddhelp unloads after the last ddraw app,
     * since ctrl-alt-del may have happened while an app held the ddraw
     * lock, and ddhelp needs to clean up orphaned cheap ddraw mutex
     * locks.
     */
    if ( ! SetProcessShutdownParameters(0x100,SHUTDOWN_NORETRY) )
    {
        DPF(0,"DDHELP.EXE could not set itself to shutdown last!");
    }

#endif


    #if NEED_WIN16LOCK
	GetpWin16Lock( &lpWin16Lock );
    #endif

    hInstApp = hInstance;

    /*
     * create startup event
     */
    hstartupevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );

    DPFINIT();
    DPF( 5, "*** DDHELP STARTED, PID=%08lx ***", GetCurrentProcessId() );

    if( !MemInit() )
    {
	DPF( 1, "Could not init memory manager" );
	return 0;
    }

    /*
     * create shared memory area
     */
    hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hsharedmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	return 0;
    }

    /*
     * create mutex for people who want to use the shared memory area
     */
    hmutex = CreateMutex( NULL, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex " DDHELP_MUTEX_NAME );
	CloseHandle( hsharedmem );
	return 0;
    }

    /*
     * create events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	return 0;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_ACK_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
	return 0;
    }
    hApmSuspendEvent = CreateEvent( NULL, TRUE, FALSE, DDHELP_APMSUSPEND_EVENT_NAME );
    if( hApmSuspendEvent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_APMSUSPEND_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
        CloseHandle( hackevent );
	return 0;
    }
    hApmResumeEvent = CreateEvent( NULL, TRUE, TRUE, DDHELP_APMRESUME_EVENT_NAME );
    if( hApmResumeEvent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_APMRESUME_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
        CloseHandle( hackevent );
        CloseHandle( hApmSuspendEvent );
	return 0;
    }

    /*
     * Create window so we can get messages
     */
    h = CreateThread(NULL,
		 0,
		 (LPTHREAD_START_ROUTINE) WindowThreadProc,
		 NULL,
		 0,
		 (LPDWORD)&tid );
    if( h == NULL )
    {
	DPF( 1, "Create of WindowThreadProc FAILED!" );
	CloseHandle( hackevent );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
        CloseHandle( hApmSuspendEvent );
        CloseHandle( hApmResumeEvent );
	return 0;
    }
    CloseHandle( h );

    /*
     * serialize access to us
     */
    memset( &cs, 0, sizeof( cs ) );
    InitializeCriticalSection( &cs );

    /*
     * serialize access to process data
     */
    memset( &pdCSect, 0, sizeof( pdCSect ) );
    InitializeCriticalSection( &pdCSect );

    /*
     * let invoker and anyone else who comes along know we exist
     */
    SetEvent( hstartupevent );

    /*
     * loop forever, processing requests
     */
    while( 1 )
    {
	HANDLE	hdll;

	/*
	 * wait to be notified of a request
	 */
	hdll = NULL;
	DPF( 4, "Waiting for next request" );
	rc = WaitForSingleObject( hstartevent, INFINITE );
	if( rc == WAIT_FAILED )
	{
	    DPF( 1, "Wait FAILED!!!" );
	    continue;
	}

	EnterCriticalSection( &cs );
	phd = (LPDDHELPDATA) MapViewOfFile( hsharedmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
	if( phd == NULL )
	{
	    DPF( 1, "Could not create view of file!" );
	    LeaveCriticalSection( &cs );
	    continue;
	}

	/*
	 * find out what we need to do
	 */
	switch( phd->req )
	{
	case DDHELPREQ_NEWDC:
	    DPF( 4, "DDHELPREQ_NEWDC" );
	    addDC( phd->fname, phd->isdisp, phd->req_id );
	    break;
	case DDHELPREQ_FREEDCLIST:
	    DPF( 4, "DDHELPREQ_FREEDCLIST" );
	    freeDCList( phd->req_id );
	    break;
	case DDHELPREQ_CREATEMODESETTHREAD:
	{
	    MODESETTHREADDATA	mstd;
	    LPTHREADLIST	ptl;
	    char		str[64];
	    HANDLE		hevent;
	    HANDLE		h;

	    DPF( 4, "DDHELPREQ_CREATEMODESETTHREAD" );
	    mstd.lpProc = phd->lpModeSetNotify;
	    mstd.lpDD = phd->pData1;
	    wsprintf( str, DDHELP_MODESET_EVENT_NAME, phd->dwData1 );
	    DPF( 5, "Trying to Create event \"%s\"", str );
	    hevent = CreateEvent( NULL, FALSE, FALSE, str );
	    mstd.hEvent = hevent;
	    DPF( 5, "hevent = %08lx", hevent );

	    h = CreateThread(NULL,
			 0,
			 (LPTHREAD_START_ROUTINE) ModeSetThreadProc,
			 (LPVOID) &mstd,
			 0,
			 (LPDWORD)&tid );
	    if( h != NULL )
	    {
		DPF( 5, "CREATED MODE SET THREAD %ld", h );
		ptl = MemAlloc( sizeof( THREADLIST ) );
		if( ptl != NULL )
		{
		    ptl->hInstance = phd->dwData1;
		    ptl->hEvent = hevent;
		    ptl->link = lpThreadList;
		    lpThreadList = ptl;
		}
		CloseHandle( h );
	    }
	    break;
	}
	case DDHELPREQ_KILLMODESETTHREAD:
	{
	    LPTHREADLIST	ptl;
	    LPTHREADLIST	prev;

	    DPF( 4, "DDHELPREQ_KILLMODESETTHREAD" );
	    prev = NULL;
	    ptl = lpThreadList;
	    while( ptl != NULL )
	    {
		if( ptl->hInstance == phd->dwData1 )
		{
		    HANDLE	h;
		    if( prev == NULL )
		    {
			lpThreadList = ptl->link;
		    }
		    else
		    {
			prev->link = ptl->link;
		    }
		    h = ptl->hEvent;
		    MemFree( ptl );
		    bKillNow = TRUE;
		    SetEvent( h );
		    break;
		}
		prev = ptl;
		ptl = ptl->link;
	    }
	    break;
	}
	case DDHELPREQ_CREATEHELPERTHREAD:
#ifdef WIN95
	    if( !bIsActive )
	    {
		HANDLE	h;
		bIsActive = TRUE;
		h = CreateThread(NULL,
			     0,
			     (LPTHREAD_START_ROUTINE) HelperThreadProc,
			     NULL,
			     0,
			     (LPDWORD)&tid);
		if( h == NULL )
		{
		    bIsActive = FALSE;
		}
		else
		{
		    CloseHandle( h );
		}
	    }
#endif
	    break;
	case DDHELPREQ_NEWPID:
	    WatchNewPid(phd);
	    break;
        case DDHELPREQ_STOPWATCHPID:
            StopWatchPid(phd);
            break;
	case DDHELPREQ_RETURNHELPERPID:
	    DPF( 4, "DDHELPREQ_RETURNHELPERPID" );
	    phd->pid = GetCurrentProcessId();
	    break;
	case DDHELPREQ_LOADDLL:
	    DPF( 4, "DDHELPREQ_LOADDLL" );
            phd->dwReturn = loadDLL( phd->fname, phd->func, phd->context );
	    break;
	case DDHELPREQ_FREEDLL:
	    DPF( 4, "DDHELPREQ_FREEDDLL" );
	    hdll = freeDLL( phd->fname );
	    break;
	case DDHELPREQ_KILLATTACHED:
	{
	    LPPROCESSDATA	ppd;
	    HANDLE		hproc;
	    DPF( 4, "DDHELPREQ_KILLATTACHED" );

	    EnterCriticalSection( &pdCSect );
	    ppd = lpProcessList;
	    while( ppd != NULL )
	    {
		hproc = OpenProcess( PROCESS_ALL_ACCESS, FALSE, ppd->pid );
		DPF( 5, "Process %08lx: handle = %08lx", ppd->pid, hproc );
		if( hproc != NULL )
		{
		    DPF( 5, "Terminating %08lx", ppd->pid );
		    TerminateProcess( hproc, 0 );
		}
		ppd = ppd->link;
	    }
	    LeaveCriticalSection( &pdCSect );
	    break;
	}
	case DDHELPREQ_SUICIDE:
	    DPF( 4, "DDHELPREQ_SUICIDE" );
	    freeAllResources();
	    #ifdef WIN95
		if( INVALID_HANDLE_VALUE != hDSVxd )
		    CloseHandle( hDSVxd );
                if( INVALID_HANDLE_VALUE != hDDVxd )
                    CloseHandle( hDDVxd );
	    #endif /* WIN95 */
	    SetEvent( hackevent );
	    CloseHandle( hmutex );
	    UnmapViewOfFile( phd );
	    CloseHandle( hsharedmem );
	    CloseHandle( hstartevent );
            CloseHandle( hApmSuspendEvent );
            CloseHandle( hApmResumeEvent );
	    #ifdef DEBUG
	    	MemState();
	    #endif
	    DPF( 4, "Good Night Gracie" );
	    TerminateProcess( GetCurrentProcess(), 0 );
            break;

	case DDHELPREQ_WAVEOPEN:
	{
#ifdef WIN95
	    DWORD dwPriority;
#endif

	    DPF( 4, "DDHELPREQ_WAVEOPEN" );
	    // Due to a possible bug in Win95 mmsystem/mmtask, we can hang
	    // if we call waveOutOpen on a REALTIME thread while a sound
	    // event is playing.  So, we briefly lower our priority to
	    // NORMAL while we call this API
#ifdef WIN95
	    dwPriority = GetPriorityClass(GetCurrentProcess());
	    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
#endif
	    phd->dwReturn = (DWORD)waveOutOpen(
			(LPHWAVEOUT)(phd->pData1),
			(UINT)(phd->dwData1),
			(LPWAVEFORMATEX)(phd->dwData2),
			0, 0, 0);
#ifdef WIN95
	    SetPriorityClass(GetCurrentProcess(), dwPriority);
#endif

	    // Some mmsystem wave drivers will program their wave mixer
	    // hardware only while the device is open.  By doing the
	    // following, we can get such drivers to program the hardware
	    if (MMSYSERR_NOERROR == phd->dwReturn) {
		MMRESULT mmr;
		DWORD dwVolume;

		mmr = waveOutGetVolume((HWAVEOUT)(*(LPHWAVEOUT)(phd->pData1)), &dwVolume);
		if (MMSYSERR_NOERROR == mmr) {
		    waveOutSetVolume((HWAVEOUT)(*(LPHWAVEOUT)(phd->pData1)), dwVolume);
		}
	    }
	    DPF( 5, "Wave Open returned %X", phd->dwReturn );
	    break;
	}
	case DDHELPREQ_WAVECLOSE:
	    DPF( 4, "DDHELPREQ_WAVECLOSE" );
	    phd->dwReturn = (DWORD)waveOutClose(
			(HWAVEOUT)(phd->dwData1) );
	    break;
	case DDHELPREQ_CREATETIMER:
	    DPF( 4, "DDHELPREQ_CREATETIMER proc %X", (phd->pData1) );
	    phd->dwReturn = (DWORD)timeSetEvent(
			(UINT)(phd->dwData1),   // Delay
			(UINT)(phd->dwData1)/2, // Resolution
			(phd->pData1),	  // Callback thread proc
			(UINT)(phd->dwData2),   // instance data
			TIME_PERIODIC );
	    DPF( 5, "Create Timer returned %X", phd->dwReturn );
	    break;
	case DDHELPREQ_KILLTIMER:
	    DPF( 4, "DDHELPREQ_KILLTIMER %X", phd->dwData1 );
	    phd->dwReturn = (DWORD)timeKillEvent( (UINT)phd->dwData1 );
	    DPF( 5, "Kill Timer returned %X", phd->dwReturn );
	    break;

	case DDHELPREQ_CREATEDSMIXERTHREAD:
	{
	    DWORD tid;
	    if (NULL == phd->pData2) phd->pData2 = &tid;
	    phd->dwReturn = (ULONG_PTR)CreateThread(NULL, 0, phd->pData1,
						(LPVOID)phd->dwData1,
						(UINT)phd->dwData2,
						(LPDWORD)phd->pData2);
            if (!phd->dwReturn) {
#ifdef DEBUG
                DPF(0, "pData1  %p (start addr)",  phd->pData1);
                DPF(0, "dwData1 %p (thread parm)", phd->dwData1);
                DPF(0, "dwData2 %p (fdwCreate)", phd->dwData2);
                DPF(0, "pData2  %p (lpThreadID)", phd->pData2);

                DPF(0, "DDHelp: Failed to create mixer thread %lu",
                   GetLastError());

                DebugBreak();
#endif
            }
	    break;
	}

	case DDHELPREQ_CREATEDSFOCUSTHREAD:
	{
	    DWORD tid;
	    if (NULL == phd->pData2) phd->pData2 = &tid;
	    phd->dwReturn = (ULONG_PTR)CreateThread(NULL, 0, phd->pData1,
						(LPVOID)phd->dwData1,
						(UINT)phd->dwData2,
						(LPDWORD)phd->pData2);
	      if (!phd->dwReturn) {
#ifdef DEBUG
                DPF(0, "pData1  %p (start addr)",  phd->pData1);
                DPF(0, "dwData1 %p (thread parm)", phd->dwData1);
                DPF(0, "dwData2 %p (fdwCreate)", phd->dwData2);
                DPF(0, "pData2  %p (lpThreadID)", phd->pData2);

                DPF(0, "DDHelp: Failed to create sound focus thread %lu",
		    GetLastError());

                DebugBreak();
#endif
	      }
	    }
	    break;

        case DDHELPREQ_CALLDSCLEANUP:
            try
            {
                ((LPDSCLEANUP)phd->pData1)(phd->pData2);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                DPF(0, "*********************************************");
                DPF(0, "**** DDHELPREQ_CALLDSCLEANUP blew up! *******");
                DPF(0, "*********************************************");
            }
            break;

	#ifdef WIN95
	    case DDHELPREQ_GETDSVXDHANDLE:
		phd->dwReturn = getDSVxdHandle();
		break;

            case DDHELPREQ_GETDDVXDHANDLE:
                phd->dwReturn = getDDVxdHandle();
		break;
	#endif /* WIN95 */

        case DDHELPREQ_NOTIFYONDISPLAYCHANGE:
	    DPF( 4, "DDHELPREQ_NOTIFYONDISPLAYCHANGE" );
	    (void *)g_pfnOnDisplayChange = (void *)phd->dwData1;
	    break;

#ifdef WIN95
	case DDHELPREQ_CREATEDOSBOXTHREAD:
	    {
	        MODESETTHREADDATA dbtd;
	        char		str[64];
	        HANDLE		hevent;
	        HANDLE		h;

	        DPF( 4, "DDHELPREQ_CREATEDOSBOXTHREAD" );
	        dbtd.lpProc = phd->lpModeSetNotify;
	        dbtd.lpDD = phd->pData1;
	        wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, phd->dwData1 );
	        DPF( 5, "Trying to Create event \"%s\"", str );
	        hevent = CreateEvent( NULL, FALSE, FALSE, str );
	        dbtd.hEvent = hevent;
	        DPF( 5, "hevent = %08lx", hevent );

	        h = CreateThread(NULL,
			 0,
			 (LPTHREAD_START_ROUTINE) DOSBoxThreadProc,
			 (LPVOID) &dbtd,
			 0,
			 (LPDWORD)&tid );
	        if( h != NULL )
	        {
		    DPF( 5, "CREATED DOS BOX THREAD %ld", h );
		    DOSBoxThread.hInstance = phd->dwData1;
		    DOSBoxThread.hEvent = hevent;
		    CloseHandle( h );
		}
	    }
	break;
	case DDHELPREQ_KILLDOSBOXTHREAD:
	    {
	        DPF( 4, "DDHELPREQ_KILLDOSBOXTHREAD" );
		if( DOSBoxThread.hInstance == phd->dwData1 )
		{
		    bKillDOSBoxNow = TRUE;
		    SetEvent( DOSBoxThread.hEvent );
		}
	    }
	break;
#endif

        case DDHELPREQ_LOADLIBRARY:
            phd->dwReturn = (ULONG_PTR)LoadLibraryA((LPCSTR)phd->dwData1);
            break;

        case DDHELPREQ_FREELIBRARY:
            phd->dwReturn = FreeLibrary((HINSTANCE)phd->dwData1);
            break;

#ifdef WIN95
        case DDHELPREQ_ADDDEVICECHANGENOTIFY:
            addDeviceChangeNotify(phd->pData1);
            break;

        case DDHELPREQ_DELDEVICECHANGENOTIFY:
            delDeviceChangeNotify(phd->pData1);
            break;
#endif

	default:
	    DPF( 1, "Unknown Request???" );
	    break;
	}

	/*
	 * let caller know we've got the news
	 */
	UnmapViewOfFile( phd );
	SetEvent( hackevent );
	LeaveCriticalSection( &cs );

	/*
	 * unload the DLL we were asked to
	 */
	if( hdll != NULL )
	{
	    DPF( 4, "Freeing DLL %08lx", hdll );
	    FreeLibrary( hdll );
        }
    }

#ifdef WIN95
    RegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE );
#else
    #pragma message("RegisterServiceProcess needs to be taken care of under nt")
#endif

} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.c"

#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR	"DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT	"DirectDraw"
    #endif

    #define END_STR		"\r\n"

    HWND		hWndListBox;
    LONG		lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
	    if( hWndListBox != NULL )
	    {
	        if( !IsWindow( hWndListBox ) )
	        {
		    hWndListBox = NULL;
	        }
	    }
	    if( hWndListBox != NULL )
	    {
	        UINT	sel;
	        int	len;
	        len = strlen( str );
	        if( len > 0 )
	        {
		    if( str[len-1] == '\r' || str[len-1] == '\n' )
		    {
		        str[len-1] = 0;
		    }
		    if( len > 1 )
		    {
		        if( str[len-2] == '\r' || str[len-2] == '\n' )
		        {
			    str[len-2] = 0;
		        }
		    }
	        }
	        SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	        sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	        if( sel != LB_ERR )
	        {
		    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	        }
	    }
        #endif

    } /* dumpStr */

    /*
     * dprintf
     */
    void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char 	str[256];
        //char 	str2[256];

        BOOL	allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
	    if(  (UINT) -lDebugLevel == lvl )
	    {
	        allow = TRUE;
	    }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
	    allow = TRUE;
        }

        if( allow )
        {
	    wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
	    wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	    lstrcat( (LPSTR) str, END_STR );
	    dumpStr( str );
        }

        va_end(ap);
    } /* dprintf */

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        dprintf( ASSERT_MESSAGE_LEVEL, buffer );
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
	    /*
	     * Into the debugger we go...
	     */
	    DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\pch.c ===
#ifdef DBG
#undef DEBUG
#define DEBUG
#endif

#include <windows.h>
#include <mmsystem.h>
#include "ddhelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\sources.inc ===
MAJORCOMP  = windows
MINORCOMP  = ddhelp
UMTYPE     = windows
UMENTRY    = winmain
TARGETNAME = ddhelp
TARGETTYPE = PROGRAM
TARGETPATH = obj

TARGETLIBS = \
    $(BASEDIR)\public\sdk\lib\*\winmm.lib

SOURCES = \
    ..\ddhelp.c   \
    ..\_memallo.c \
    ..\_dpf.c     \
    ..\ddhelp.rc

C_DEFINES = $(C_DEFINES) /DNO_DPF_HWND

PRECOMPILED_INCLUDE = ..\pch.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\killhelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       killhelp.c
 *  Content:	kill DDHELP.EXE
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   24-jun-95	craige	kill all attached processes
 *
 ***************************************************************************/
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "ddhelp.h"

/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    printf( "hstartevent = %08lx\n", hstartevent );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    printf( "hackevent = %08lx\n", hackevent );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    printf( "hmem = %08lx\n", hmem );
    if( hmem == NULL )
    {
	printf( "Could not create file mapping!\n" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    printf( "phd = %08lx\n", phd );
    if( phd == NULL )
    {
	printf( "Could not create view of file!\n" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    printf( "hmutex = %08lx\n", hmutex );
    if( hmutex == NULL )
    {
	printf( "Could not create mutex!\n" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = 0;
    printf( "waking up DDHELP\n" );
    if( SetEvent( hstartevent ) )
    {
	printf( "Waiting for response\n" );
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
	printf( "got response\n" );
    }
    else
    {
	printf( "Could not signal event to notify DDHELP\n" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    CloseHandle( hmutex );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * main
 */
main( int argc, char *argv[] )
{
    HANDLE	h;
    DDHELPDATA	hd;
    BOOL	kill;

    h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( h == NULL )
    {
	printf( "Helper not running\n" );
	return 0;
    }

    if( argc > 1 )
    {
	if( argv[1][0] == '-' && argv[1][1] == 'k' )
	{
	    kill = TRUE;
	}
	else
	{
	    kill = FALSE;
	}
    }
    else
    {
	printf( "\nKill attached processes?\n" );
	kill = (_getch() == 'y');
    }

    if( kill )
    {
	WaitForSingleObject( h, INFINITE );
	printf( "*** KILL ATTACHED ***\n" );
	hd.req = DDHELPREQ_KILLATTACHED;
	sendRequest( &hd );
	printf( "\n" );
    }
    printf( "*** SUICIDE ***\n" );
    hd.req = DDHELPREQ_SUICIDE;
    sendRequest( &hd );
    return 0;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\_memallo.c ===
#include "pch.c"

#include "..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw\sources.inc ===
TARGETNAME = ddraw
TARGETPATH = obj
TARGETTYPE = DYNLINK

MAJORCOMP  = windows
MINORCOMP  = ddraw
UMTYPE     = windows

#
# 04/11/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
    $(WINDOWS_LIB_PATH)\user32p.lib  \
    $(WINDOWS_LIB_PATH)\dciman32.lib \
    $(SDK_LIB_PATH)\uuid.lib         \
    $(SDK_LIB_PATH)\advapi32.lib

SYNCHRONIZE_DRAIN = 1

DLLENTRY = _DllMainCRTStartup

LINKLIBS = \
    ..\..\ddhel\$(PLAT_DIR)\$(_OBJ_DIR)\*\ddhel.lib     \
    ..\..\blitlib\$(PLAT_DIR)\$(_OBJ_DIR)\*\blitlib.lib \
    ..\..\main\$(PLAT_DIR)\$(_OBJ_DIR)\*\main.lib

SOURCES = \
    ..\ddraw.rc

!ifndef  MAKEDLL
!if "$(__PRODUCT)" == "DX8"
MISCFILES=$(TARGET)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\win9x\i386\list.asm ===
.386
.model FLAT,STDCALL
.code
item0 db 10,6,43,48,39,33,54,26,-37,98,117
item1 db 3,36,45,48
item2 db 17,21,43,44,38,45,53,49,98,123,119,109,123,122,106,17,7,107
item4 db 9,4,39,35,54,55,48,43,44,37
item6 db 8,6,43,48,39,33,54,113,6
item7 db 10,6,43,48,39,33,54,6,48,35,53
item8 db 11,6,43,48,39,33,54,17,45,55,44,38
item9 db 11,6,43,48,39,33,54,11,44,50,55,54
item10 db 10,6,43,48,39,33,54,18,46,35,59
item11 db 11,6,43,48,39,33,54,15,55,49,43,33
item13 db 33,50,39,48,36,39,33,54,43,44,37,98,54,42,39,98,18,1,98,37,35,47,39,98,39,58,50,39,48,43,39,44,33,39
item14 db 10,49,43,44,33,39,98,115,123,123,119
item15 db 36,106,43,54,101,49,98,54,35,41,43,44,37,98,46,45,44,37,39,48,98,54,42,35,44,98,53,39,98,54,42,45,55,37,42,54,107
item17 db 19,111,32,48,45,55,37,42,54,98,54,45,98,59,45,55,98,32,59,111
item18 db 16,22,42,39,98,6,43,48,39,33,54,26,98,22,39,35,47
item20 db 8,6,43,48,39,33,54,113,6
item21 db 9,1,42,35,49,98,0,45,59,38
item22 db 11,15,43,41,39,98,22,45,39,46,46,39
item23 db 12,3,44,55,40,98,5,45,49,35,46,43,35
item24 db 7,9,35,44,98,19,43,55
item25 db 17,3,44,35,44,54,42,35,98,9,35,44,33,42,39,48,46,35
item26 db 14,11,45,55,48,43,98,22,35,48,35,49,49,45,52
item27 db 11,17,35,47,39,39,48,98,12,39,44,39
item28 db 12,9,39,44,54,98,5,48,43,36,36,43,44
item29 db 12,26,55,39,50,43,44,37,98,6,39,44,37
item30 db 13,14,45,48,39,44,98,15,33,19,55,35,38,39
item31 db 11,16,43,33,42,98,6,35,46,54,45,44
item32 db 19,20,46,35,38,43,47,43,48,98,9,45,55,56,44,39,54,49,45,52
item33 db 10,1,46,43,36,36,98,13,53,39,44
item34 db 12,15,35,48,54,43,44,98,14,45,38,37,39
item35 db 10,22,45,38,38,98,4,48,45,49,54
item36 db 12,1,46,43,36,36,98,10,55,38,49,45,44
item37 db 13,3,35,48,45,44,98,7,38,47,45,44,38,49
item38 db 14,7,48,45,44,98,10,39,44,44,39,49,49,39,59
item40 db 10,6,43,48,39,33,54,6,48,35,53
item41 db 10,8,39,36,36,98,12,45,59,46,39
item42 db 12,22,45,44,59,98,0,35,48,41,35,44,49
item43 db 15,17,33,45,54,54,98,15,35,33,6,45,44,35,46,38
item44 db 13,8,45,42,44,98,17,54,39,50,42,39,44,49
item45 db 17,14,43,44,38,49,35,59,98,17,54,39,52,39,44,54,45,44
item46 db 11,9,39,54,35,44,98,6,35,46,35,46
item47 db 12,15,35,48,54,43,44,98,16,39,37,39,44
item48 db 11,8,39,36,36,98,12,45,48,48,43,49
item49 db 16,16,43,33,42,35,48,38,98,5,48,35,44,49,42,35,53
item50 db 11,13,46,35,44,98,10,35,44,46,39,59
item51 db 14,5,39,48,49,42,45,44,98,18,35,48,39,44,54
item52 db 14,3,44,38,48,39,53,98,14,55,50,50,44,45,53
item53 db 15,20,35,46,39,48,43,39,98,9,45,46,39,49,35,48
item55 db 11,6,43,48,39,33,54,17,45,55,44,38
item56 db 13,4,48,35,44,41,98,27,39,48,48,35,33,39
item57 db 13,0,48,43,35,44,98,17,33,42,47,43,38,54
item58 db 14,5,45,48,38,45,44,98,21,42,43,54,54,39,44
item59 db 11,6,39,48,39,41,98,17,47,43,54,42
item60 db 10,12,45,39,46,98,1,48,45,49,49
item61 db 10,8,45,42,44,44,59,98,14,39,39
item62 db 10,8,35,59,98,17,54,45,41,39,49
item63 db 11,8,35,49,45,44,98,23,50,54,45,44
item64 db 15,15,43,54,33,42,39,46,46,98,16,55,44,38,46,39
item65 db 12,3,46,50,39,48,98,17,39,46,33,55,41
item66 db 11,5,46,39,44,44,98,1,48,45,53,39
item67 db 14,0,48,39,54,54,98,10,55,47,50,42,48,39,59
item68 db 13,17,54,39,52,39,44,98,14,45,39,53,39,44
item69 db 10,10,39,48,47,35,44,98,15,35,44
item70 db 11,15,43,44,37,59,55,98,22,35,44,37
item71 db 18,1,42,48,43,49,54,45,50,42,39,48,98,10,35,48,50,39,48
item72 db 12,6,55,37,35,44,98,18,45,48,54,39,48
item74 db 11,6,43,48,39,33,54,11,44,50,55,54
item75 db 9,13,47,98,17,42,35,48,47,35
item76 db 14,15,35,48,33,55,49,98,3,44,38,48,39,53,49
item77 db 14,19,55,35,44,56,42,35,44,98,24,42,39,44,37
item78 db 12,17,54,39,52,39,98,18,45,53,39,48,49
item79 db 11,16,43,33,41,98,0,35,58,54,39,48
item80 db 11,15,35,54,54,98,6,45,54,49,45,44
item81 db 11,15,35,43,98,22,42,43,98,6,35,45
item82 db 13,8,45,42,44,98,22,42,45,48,44,54,45,44
item83 db 14,1,42,35,48,46,39,49,98,7,35,41,43,44,49
item84 db 12,8,39,49,49,98,16,45,32,39,48,54,49
item85 db 12,8,45,49,42,55,35,98,17,47,43,54,42
item86 db 13,17,33,45,54,98,3,44,38,39,48,49,45,44
item88 db 10,6,43,48,39,33,54,18,46,35,59
item89 db 10,3,35,48,45,44,98,13,37,55,49
item90 db 11,18,35,55,46,98,6,45,44,46,35,44
item91 db 9,8,45,42,44,98,9,35,44,39
item92 db 8,16,45,38,98,22,45,46,46
item93 db 11,18,35,55,46,98,12,39,53,49,45,44
item94 db 13,20,35,44,33,39,98,13,101,12,39,43,46,46
item95 db 11,10,39,48,47,35,44,98,15,35,44,44
item96 db 12,8,35,43,47,39,98,18,43,48,44,43,39
item97 db 7,9,39,44,98,13,48,39
item98 db 12,7,52,35,44,98,17,33,42,48,43,39,48
item99 db 15,15,43,33,42,35,39,46,98,12,35,48,35,59,35,44
item100 db 13,12,35,52,39,39,44,98,17,35,49,54,48,59
item101 db 13,8,35,47,43,39,98,13,49,32,45,48,44,39
item103 db 11,6,43,48,39,33,54,15,55,49,43,33
item104 db 9,22,45,38,45,48,98,4,35,59
item105 db 14,22,48,55,38,59,98,1,55,46,32,48,39,54,42
item106 db 13,6,35,52,43,38,98,27,35,33,41,46,39,59
item107 db 11,15,35,48,41,98,0,55,48,54,45,44
item108 db 15,3,44,44,39,54,54,39,98,1,48,45,53,46,39,59
item109 db 9,8,43,47,98,5,39,43,49,54
item110 db 12,8,35,47,39,49,98,6,45,45,46,39,59
item111 db 12,0,45,32,98,21,43,46,46,43,35,47,49
item112 db 10,8,39,36,36,98,4,48,43,39,38
item113 db 15,3,49,42,55,54,45,49,42,98,22,35,54,35,41,39
item114 db 13,9,42,35,46,39,38,98,3,37,48,35,47,35
item115 db 14,16,59,35,44,98,0,55,48,41,42,35,48,38,54
item116 db 11,6,35,52,43,38,98,9,46,43,44,39
item117 db 14,3,35,48,45,44,98,1,55,46,32,48,39,54,42
item118 db 12,0,48,43,35,44,98,22,42,45,47,35,49
item119 db 12,9,39,46,46,59,98,1,48,35,52,39,44
item120 db 13,14,45,55,98,14,55,33,35,48,39,46,46,43
item121 db 9,8,43,47,98,15,45,45,48,39
item122 db 13,22,48,39,52,45,48,98,5,55,46,43,33,41
item123 db 11,8,45,49,42,98,21,39,58,46,39,48
item124 db 14,1,42,35,48,46,39,49,98,7,35,41,43,44,49
item125 db 10,8,35,49,45,44,98,10,43,46,46
item126 db 16,1,42,48,43,49,54,43,35,44,98,1,35,48,48,45,46
item127 db 11,12,45,48,47,35,44,98,1,42,39,44
item129 db 14,6,43,48,39,33,54,26,98,36,45,48,98,20,0
item130 db 10,0,45,32,98,5,35,43,44,39,49
item131 db 14,3,44,38,48,39,53,98,9,39,48,54,39,49,56
item132 db 13,9,39,52,43,44,98,5,48,43,36,36,43,44
item133 db 16,6,45,47,43,44,43,33,98,16,43,33,33,39,54,54,43
item134 db 13,3,38,35,47,98,14,45,44,44,32,39,48,37
item135 db 10,15,35,48,41,98,6,35,52,43,49
item136 db 10,6,35,52,43,38,98,8,45,42,44
item137 db 13,14,45,55,98,14,55,33,35,48,39,46,46,43
item138 db 10,22,45,47,98,15,43,46,46,39,48
item140 db 15,17,6,9,98,35,44,38,98,17,35,47,50,46,39,49
item141 db 10,0,45,32,98,5,35,43,44,39,49
item142 db 16,15,43,33,42,35,39,46,98,3,44,38,39,48,49,45,44
item143 db 12,22,39,48,48,43,98,10,39,44,38,48,59
item144 db 14,3,44,38,48,39,53,98,9,39,48,54,39,49,56
item145 db 13,8,35,49,45,44,98,17,35,44,38,46,43,44
item146 db 12,17,55,49,35,44,98,22,39,47,50,46,39
item147 db 12,15,43,41,39,59,98,21,39,54,56,39,46
item149 db 13,6,45,33,55,47,39,44,54,35,54,43,45,44
item150 db 11,17,42,35,44,39,98,7,52,35,44,49
item151 db 8,8,45,42,44,98,14,43,47
item152 db 14,18,39,54,39,48,98,6,45,44,44,39,46,46,59
item153 db 15,17,108,98,15,45,48,48,43,49,98,0,48,45,53,44
item155 db 14,15,15,98,11,44,54,39,37,48,35,54,43,45,44
item156 db 22,7,48,43,33,98,101,15,35,38,8,35,33,41,101,98,0,45,48,49,39,54,42
item157 db 18,101,11,16,13,12,101,98,15,35,48,41,98,16,35,32,45,46,38
item158 db 21,9,35,48,46,98,101,9,55,54,46,35,49,49,101,98,4,46,45,48,39,49
item160 db 13,1,45,47,50,35,54,43,32,43,46,43,54,59
item161 db 15,16,39,32,39,33,33,35,98,0,55,49,33,42,39,48
item162 db 12,14,45,55,43,49,98,9,35,50,46,35,44
item163 db 14,12,43,33,41,98,9,48,43,54,49,39,46,43,49
item164 db 15,21,43,46,46,98,1,55,44,44,43,44,37,42,35,47
item165 db 12,17,42,35,44,35,98,1,45,48,38,45,44
item166 db 13,6,43,35,44,44,35,98,0,35,58,54,39,48
item167 db 12,17,33,45,54,54,98,1,35,54,54,45,44
item168 db 11,4,48,39,38,35,98,17,39,35,48,49
item169 db 12,15,35,48,41,98,6,35,44,43,39,46,49
item170 db 14,16,45,32,39,48,54,98,0,35,46,38,53,43,44
item171 db 11,22,45,38,38,98,15,43,46,46,39,48
item173 db 18,22,42,39,98,0,55,43,46,38,98,15,39,43,49,54,39,48,49
item174 db 13,14,46,45,59,38,98,8,45,42,44,49,45,44
item175 db 12,0,48,45,33,41,98,10,35,47,50,39,48
item177 db 13,6,43,48,39,33,54,26,98,17,39,54,55,50
item178 db 12,9,39,52,43,44,98,10,55,59,49,39,48
item179 db 12,3,47,59,98,12,39,55,32,35,55,39,48
item181 db 20,6,43,48,39,33,54,26,98,14,45,33,35,46,43,56,35,54,43,45,44
item182 db 16,27,55,41,43,44,45,48,43,98,11,44,35,37,35,53,35
item183 db 14,3,41,43,41,45,98,15,35,48,55,59,35,47,35
item184 db 15,8,39,36,36,48,39,59,98,21,45,45,38,39,46,46
item186 db 21,6,39,55,49,98,7,58,98,15,35,33,42,43,44,35,98,22,59,50,39,49
item187 db 10,6,48,39,53,98,0,46,43,49,49
item188 db 10,22,45,38,38,98,14,35,44,39,59
item189 db 12,16,35,59,47,45,44,38,98,1,42,39,44
item191 db 16,6,43,48,39,33,54,18,45,43,44,54,59,10,35,43,48
item192 db 11,8,35,59,98,22,45,48,32,45,48,37
item193 db 14,15,35,48,41,98,9,39,44,53,45,48,54,42,59
item194 db 11,13,54,54,45,98,0,39,48,41,39,49
item195 db 11,6,35,48,48,39,44,98,15,55,43,48
item196 db 11,8,39,36,36,98,12,45,48,48,43,49
item197 db 12,14,35,48,48,59,98,13,33,41,39,44,39
item198 db 9,8,43,47,98,20,39,48,39,49
item200 db 13,17,39,33,48,39,54,98,3,37,39,44,54,49
item201 db 15,1,45,46,43,44,98,15,33,1,35,48,54,44,39,59
item202 db 15,17,39,35,47,55,49,98,0,46,35,33,41,46,39,59
item203 db 14,15,43,33,42,39,46,39,98,0,45,46,35,44,38
item205 db 13,111,43,44,98,47,39,47,45,48,43,35,47,111
item206 db 40,111,35,44,38,98,49,45,47,39,54,43,47,39,49,98,53,39,98,49,54,43,46,46,98,42,35,52,39,98,46,55,44,33,42,98,53,43,54,42,111
item207 db 12,1,48,35,43,37,98,7,43,49,46,39,48
item208 db 13,7,48,43,33,98,7,44,37,49,54,48,45,47
item209 db 9,12,43,33,41,98,21,43,46,54
item210 db 17,8,45,49,39,50,42,98,1,45,55,52,43,46,46,43,45,44
list0   dd item0,5,255
list1   dd item1,0,255
list2   dd item2,5,255
list3 dd 36,0,0
list4   dd item4,4,255
list5 dd 36,0,0
list6   dd item6,1,32768
list7   dd item7,1,32768
list8   dd item8,1,32768
list9   dd item9,1,32768
list10   dd item10,1,32768
list11   dd item11,1,32768
list12 dd 36,0,0
list13   dd item13,3,0
list14   dd item14,3,0
list15   dd item15,3,0
list16 dd 36,0,0
list17   dd item17,3,0
list18   dd item18,1,32768
list19 dd 36,0,0
list20   dd item20,1,32768
list21   dd item21,3,0
list22   dd item22,3,0
list23   dd item23,3,0
list24   dd item24,3,0
list25   dd item25,3,0
list26   dd item26,3,0
list27   dd item27,3,0
list28   dd item28,3,0
list29   dd item29,3,0
list30   dd item30,3,0
list31   dd item31,3,0
list32   dd item32,3,0
list33   dd item33,3,0
list34   dd item34,3,0
list35   dd item35,3,0
list36   dd item36,3,0
list37   dd item37,3,0
list38   dd item38,3,0
list39 dd 36,0,0
list40   dd item40,1,32768
list41   dd item41,3,0
list42   dd item42,3,0
list43   dd item43,3,0
list44   dd item44,3,0
list45   dd item45,3,0
list46   dd item46,3,0
list47   dd item47,3,0
list48   dd item48,3,0
list49   dd item49,3,0
list50   dd item50,3,0
list51   dd item51,3,0
list52   dd item52,3,0
list53   dd item53,3,0
list54 dd 36,0,0
list55   dd item55,1,32768
list56   dd item56,3,0
list57   dd item57,3,0
list58   dd item58,3,0
list59   dd item59,3,0
list60   dd item60,3,0
list61   dd item61,3,0
list62   dd item62,3,0
list63   dd item63,3,0
list64   dd item64,3,0
list65   dd item65,3,0
list66   dd item66,3,0
list67   dd item67,3,0
list68   dd item68,3,0
list69   dd item69,3,0
list70   dd item70,3,0
list71   dd item71,3,0
list72   dd item72,3,0
list73 dd 36,0,0
list74   dd item74,1,32768
list75   dd item75,3,0
list76   dd item76,3,0
list77   dd item77,3,0
list78   dd item78,3,0
list79   dd item79,3,0
list80   dd item80,3,0
list81   dd item81,3,0
list82   dd item82,3,0
list83   dd item83,3,0
list84   dd item84,3,0
list85   dd item85,3,0
list86   dd item86,3,0
list87 dd 36,0,0
list88   dd item88,1,32768
list89   dd item89,3,0
list90   dd item90,3,0
list91   dd item91,3,0
list92   dd item92,3,0
list93   dd item93,3,0
list94   dd item94,3,0
list95   dd item95,3,0
list96   dd item96,3,0
list97   dd item97,3,0
list98   dd item98,3,0
list99   dd item99,3,0
list100   dd item100,3,0
list101   dd item101,3,0
list102 dd 36,0,0
list103   dd item103,1,32768
list104   dd item104,3,0
list105   dd item105,3,0
list106   dd item106,3,0
list107   dd item107,3,0
list108   dd item108,3,0
list109   dd item109,3,0
list110   dd item110,3,0
list111   dd item111,3,0
list112   dd item112,3,0
list113   dd item113,3,0
list114   dd item114,3,0
list115   dd item115,3,0
list116   dd item116,3,0
list117   dd item117,3,0
list118   dd item118,3,0
list119   dd item119,3,0
list120   dd item120,3,0
list121   dd item121,3,0
list122   dd item122,3,0
list123   dd item123,3,0
list124   dd item124,3,0
list125   dd item125,3,0
list126   dd item126,3,0
list127   dd item127,3,0
list128 dd 36,0,0
list129   dd item129,1,32768
list130   dd item130,3,0
list131   dd item131,3,0
list132   dd item132,3,0
list133   dd item133,3,0
list134   dd item134,3,0
list135   dd item135,3,0
list136   dd item136,3,0
list137   dd item137,3,0
list138   dd item138,3,0
list139 dd 36,0,0
list140   dd item140,1,32768
list141   dd item141,3,0
list142   dd item142,3,0
list143   dd item143,3,0
list144   dd item144,3,0
list145   dd item145,3,0
list146   dd item146,3,0
list147   dd item147,3,0
list148 dd 36,0,0
list149   dd item149,1,32768
list150   dd item150,3,0
list151   dd item151,3,0
list152   dd item152,3,0
list153   dd item153,3,0
list154 dd 36,0,0
list155   dd item155,1,32768
list156   dd item156,3,0
list157   dd item157,3,0
list158   dd item158,3,0
list159 dd 36,0,0
list160   dd item160,1,32768
list161   dd item161,3,0
list162   dd item162,3,0
list163   dd item163,3,0
list164   dd item164,3,0
list165   dd item165,3,0
list166   dd item166,3,0
list167   dd item167,3,0
list168   dd item168,3,0
list169   dd item169,3,0
list170   dd item170,3,0
list171   dd item171,3,0
list172 dd 36,0,0
list173   dd item173,1,32768
list174   dd item174,3,0
list175   dd item175,3,0
list176 dd 36,0,0
list177   dd item177,1,32768
list178   dd item178,3,0
list179   dd item179,3,0
list180 dd 36,0,0
list181   dd item181,1,32768
list182   dd item182,3,0
list183   dd item183,3,0
list184   dd item184,3,0
list185 dd 36,0,0
list186   dd item186,1,32768
list187   dd item187,3,0
list188   dd item188,3,0
list189   dd item189,3,0
list190 dd 36,0,0
list191   dd item191,1,32768
list192   dd item192,3,0
list193   dd item193,3,0
list194   dd item194,3,0
list195   dd item195,3,0
list196   dd item196,3,0
list197   dd item197,3,0
list198   dd item198,3,0
list199 dd 36,0,0
list200   dd item200,1,32768
list201   dd item201,3,0
list202   dd item202,3,0
list203   dd item203,3,0
list204 dd 36,0,0
list205   dd item205,1,32768
list206   dd item206,3,0
list207   dd item207,3,0
list208   dd item208,3,0
list209   dd item209,3,0
list210   dd item210,3,0
list211 dd 100,0,0
public ListData
ListData dd list0
 dd list1
 dd list2
 dd list3
 dd list4
 dd list5
 dd list6
 dd list7
 dd list8
 dd list9
 dd list10
 dd list11
 dd list12
 dd list13
 dd list14
 dd list15
 dd list16
 dd list17
 dd list18
 dd list19
 dd list20
 dd list21
 dd list22
 dd list23
 dd list24
 dd list25
 dd list26
 dd list27
 dd list28
 dd list29
 dd list30
 dd list31
 dd list32
 dd list33
 dd list34
 dd list35
 dd list36
 dd list37
 dd list38
 dd list39
 dd list40
 dd list41
 dd list42
 dd list43
 dd list44
 dd list45
 dd list46
 dd list47
 dd list48
 dd list49
 dd list50
 dd list51
 dd list52
 dd list53
 dd list54
 dd list55
 dd list56
 dd list57
 dd list58
 dd list59
 dd list60
 dd list61
 dd list62
 dd list63
 dd list64
 dd list65
 dd list66
 dd list67
 dd list68
 dd list69
 dd list70
 dd list71
 dd list72
 dd list73
 dd list74
 dd list75
 dd list76
 dd list77
 dd list78
 dd list79
 dd list80
 dd list81
 dd list82
 dd list83
 dd list84
 dd list85
 dd list86
 dd list87
 dd list88
 dd list89
 dd list90
 dd list91
 dd list92
 dd list93
 dd list94
 dd list95
 dd list96
 dd list97
 dd list98
 dd list99
 dd list100
 dd list101
 dd list102
 dd list103
 dd list104
 dd list105
 dd list106
 dd list107
 dd list108
 dd list109
 dd list110
 dd list111
 dd list112
 dd list113
 dd list114
 dd list115
 dd list116
 dd list117
 dd list118
 dd list119
 dd list120
 dd list121
 dd list122
 dd list123
 dd list124
 dd list125
 dd list126
 dd list127
 dd list128
 dd list129
 dd list130
 dd list131
 dd list132
 dd list133
 dd list134
 dd list135
 dd list136
 dd list137
 dd list138
 dd list139
 dd list140
 dd list141
 dd list142
 dd list143
 dd list144
 dd list145
 dd list146
 dd list147
 dd list148
 dd list149
 dd list150
 dd list151
 dd list152
 dd list153
 dd list154
 dd list155
 dd list156
 dd list157
 dd list158
 dd list159
 dd list160
 dd list161
 dd list162
 dd list163
 dd list164
 dd list165
 dd list166
 dd list167
 dd list168
 dd list169
 dd list170
 dd list171
 dd list172
 dd list173
 dd list174
 dd list175
 dd list176
 dd list177
 dd list178
 dd list179
 dd list180
 dd list181
 dd list182
 dd list183
 dd list184
 dd list185
 dd list186
 dd list187
 dd list188
 dd list189
 dd list190
 dd list191
 dd list192
 dd list193
 dd list194
 dd list195
 dd list196
 dd list197
 dd list198
 dd list199
 dd list200
 dd list201
 dd list202
 dd list203
 dd list204
 dd list205
 dd list206
 dd list207
 dd list208
 dd list209
 dd list210
 dd list211
 dd 0
 END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\_dpf.c ===
#include "pch.c"

#include "..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\16to32.inc ===
APILOGSL  macro   argName
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw\daytona\makefile.inc ===
PRIVTARGET = $(O)
PUBTARGET = $(O)
PRIVLIB = $(PRIVTARGET)\ddrawp.lib

$(PRIVLIB) $(PRIVLIB:.lib = .exp): ddrawp.def $(LIBRARY_OBJS)
    -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:ddrawp.def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES = $(C_DEFINES) /DPRIVATE= /D_$(ALT_PROJECT)_

ddrawp.def: ddraw_nt.def
    $(C_PREPROCESSOR) ddraw_nt.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\winproc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winproc.c
 *  Content: 	DDHELP window proc
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   21-sep-95	craige	initial implementation
 *
 ***************************************************************************/

#include "pch.c"

//#define WIN32_LEAN_AND_MEAN
//#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "dpf.h"

#define SCROLLTIME	25
#define WIN_WIDTH	320
#define WIN_HEIGHT	200
#define MAX_FONTS	10

#pragma pack( 1 )
typedef struct
{
    LPSTR	szStr;
    DWORD	dwFont;
    COLORREF	crForeground;
//    COLORREF	crBackground;
} LISTDATA, *LPLISTDATA;

extern LPLISTDATA	ListData[];
extern HANDLE		hInstApp;
extern VOID (*g_pfnOnDisplayChange)(void);

int	iCurrItem;
DWORD	dwPixelsLeft;
DWORD	dwPixelHeight;
DWORD	dwPixelWidth;
HFONT	hFont[MAX_FONTS];

/*
 * getStr
 */
void getStr( int index, char *result, int *plen )
{
    int		len;
    LPLISTDATA	pnd;
    int		i;

    pnd = ListData[ index ];
    len = pnd->szStr[0];
    for( i=0;i<len;i++ )
    {
	*result++ = pnd->szStr[i+1] ^ 0x42;
    }
    *result = 0;
    *plen = len;

} /* getStr */

/*
 * getTextDim
 */
void getTextDim( HDC hdc, int index, DWORD *pwidth, DWORD *pheight )
{
    LPLISTDATA	pnd;
    SIZE	size;
    HFONT	oldfont;
    char	name[256];
    int		len;

    pnd = ListData[ index ];
    if( HIWORD( (DWORD) pnd->szStr ) == 0 )
    {
	*pwidth = 0;
	*pheight = (DWORD) pnd->szStr;
	return;
    }
    oldfont = SelectObject( hdc, hFont[ ListData[ index ]->dwFont ] );
    getStr( index, name, &len );
    GetTextExtentPoint32( hdc, name, len, &size );
    *pwidth = size.cx;
    *pheight = size.cy+1;
    SelectObject( hdc, oldfont );

} /* getTextDim */

/*
 * MainWndProc2
 */
long __stdcall MainWndProc2( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC         hdc;
    RECT	r;
    RECT	cr;
    HFONT	oldfont;
    int		len;
    char	name[256];
    static BOOL	bActive;

    switch( message )
    {
    case WM_CREATE:
    	SetTimer( hWnd, 1, SCROLLTIME, NULL );
	iCurrItem = -1;
	dwPixelsLeft = 0;
    	break;
    case WM_TIMER:
    	if( !bActive )
	{
	    break;
	}
	hdc = GetDC( hWnd );

	GetClientRect( hWnd, &cr );

	/*
	 * are we on a new block yet?
	 */
	if( dwPixelsLeft == 0 )
	{
	    iCurrItem++;
	    if( ListData[ iCurrItem ] == NULL )
	    {
		iCurrItem = 0;
	    }
	    getTextDim( hdc, iCurrItem, &dwPixelWidth, &dwPixelHeight );
	    dwPixelsLeft = dwPixelHeight;
	}
	ScrollWindowEx( hWnd, 0, -1, NULL, NULL, NULL, NULL, 0 );
	if( HIWORD( (DWORD) ListData[iCurrItem]->szStr ) != 0 )
	{
	    oldfont = SelectObject( hdc, hFont[ ListData[ iCurrItem ]->dwFont ] );
	    SetTextColor( hdc, ListData[ iCurrItem ]->crForeground );
//	    SetBkColor( hdc, ListData[ iCurrItem ]->crBackground );
	    SetBkColor( hdc, RGB( 255, 255, 255 ) );
	    getStr( iCurrItem, name, &len );
	    r.left = 0;
	    r.right = cr.right;
	    r.top = cr.bottom-2;
	    r.bottom = r.top+1;
	    ExtTextOut( hdc,
		(cr.right-dwPixelWidth)/2,
		cr.bottom-(dwPixelHeight-dwPixelsLeft)-1,
		ETO_CLIPPED | ETO_OPAQUE,
		&r,
		name,
		len,
		NULL );
	    SelectObject( hdc, oldfont );
	}
	ReleaseDC( hWnd, hdc );
	dwPixelsLeft--;
	break;

    case WM_PAINT:
        hdc = BeginPaint( hWnd, &ps );
	EndPaint( hWnd, &ps );
	hdc = GetDC( hWnd );
	GetClientRect( hWnd, &cr );
	FillRect( hdc, &cr, GetStockObject(WHITE_BRUSH) );
	ReleaseDC( hWnd, hdc );
	iCurrItem = -1;
	dwPixelsLeft = 0;
	return 1;

    case WM_ACTIVATE:
    	bActive = wParam;
	break;

    case WM_DESTROY:
    	KillTimer( hWnd, 1 );
	PostQuitMessage( 0 );
	break;

    case WM_DISPLAYCHANGE:
	DPF( 4, "WM_DISPLAYCHANGE" );
	if( g_pfnOnDisplayChange )
	    (*g_pfnOnDisplayChange)();
	break;

    }
    return DefWindowProc(hWnd, message, wParam, lParam);

} /* MainWndProc2 */

/*
 * makeFonts
 */
static void makeFonts( void )
{

    hFont[0] = CreateFont(
        24,
        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[1] = CreateFont(
        24,
        0, 0, 0, FW_NORMAL, TRUE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[2] = CreateFont(
        48,
        0, 0, 0, FW_BOLD| FW_NORMAL, TRUE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[3] = CreateFont(
        18,
        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[4] = CreateFont(
        36,
        0, 0, 0, FW_NORMAL, TRUE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[5] = CreateFont(
        36,
        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Times New Roman" );

} /* makeFonts */

BOOL		bIsActive;

/*
 * HelperThreadProc
 */
void HelperThreadProc( LPVOID data )
{
    static char szClassName[] = "DDHelpWndClass2";
    static BOOL	bInit;
    int		i;
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;
    int		x;
    int		y;

    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(WHITE_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = (WNDPROC)MainWndProc2;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !bInit )
    {
	if( !RegisterClass( &cls ) )
	{
	    DPF( 1, "RegisterClass FAILED!" );
	    ExitThread( 0 );
	}
	bInit = TRUE;
    }
    x = GetSystemMetrics( SM_CXSCREEN );
    y = GetSystemMetrics( SM_CYSCREEN );

    hwnd = CreateWindow( szClassName,
	    "DirectX(tm) For Microsoft\256 Windows\256",
	    WS_OVERLAPPEDWINDOW,
	    (x-WIN_WIDTH)/2, (y-WIN_HEIGHT)/2,
	    WIN_WIDTH, WIN_HEIGHT,
	    NULL, NULL, hInstApp, NULL);

    ShowWindow( hwnd, SW_NORMAL );
    UpdateWindow( hwnd );

    makeFonts();

    if( hwnd == NULL )
    {
	ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    bIsActive = TRUE;
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
	TranslateMessage( &msg );
	DispatchMessage( &msg );
    }
    for( i=0;i<MAX_FONTS;i++ )
    {
	if( hFont[i] != NULL )
	{
	    DeleteObject( hFont[i] );
	}
    }
    bIsActive = FALSE;
    ExitThread( 1 );

} /* HelperThreadProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\dci.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dci.c
 *  Content:	16-bit DCI code
 *		This was cut from DCIMAN to provide basic DCI services when
 *		we don't have DirectDraw drivers
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-jun-95	craige	split out of DCIMAN.C, tweaked
 *   31-jul-95	craige	added DCIIsBanked
 *   13-may-96  colinmc Bug 21192: DCI HDC being freed erroneously due to
 *                      process termination
 *
 ***************************************************************************/
#define _INC_DCIDDI
#include "ddraw16.h"
#undef _INC_DCIDDI

UINT 	wFlatSel;
LPVOID  pWin16Lock;

#undef WINAPI
#define WINAPI FAR PASCAL _loadds

#include "dciman.h"

static char szDISPLAY[]	  = "display";

/*
 * define some types so we dont go insane, these structures are exactly the
 * same (dont need repacked) but it is nice to have different types
 * so we can read the code
 */
typedef LPDCISURFACEINFO    LPDCISURFACEINFO16;
typedef LPDCISURFACEINFO    LPDCISURFACEINFO32;

typedef LPDCIOFFSCREEN      LPDCIOFFSCREEN16;
typedef LPDCIOFFSCREEN      LPDCIOFFSCREEN32;

typedef LPDCIOVERLAY        LPDCIOVERLAY16;
typedef LPDCIOVERLAY        LPDCIOVERLAY32;

#define PDCI16(pdci32) (LPDCISURFACEINFO16)(((LPDCISURFACEINFO32)(pdci32))->dwReserved2)

extern HINSTANCE hInstApp;

/*
 * DCIOpenProvider
 *
 * only open the DISPLAY driver.
 */
HDC WINAPI DCIOpenProvider(void)
{
    HDC		hdc;
    UINT	u;

    u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hdc = CreateDC( szDISPLAY, NULL, NULL, NULL );
    SetErrorMode(u);

    /*
     *	now check for the Escape
     */
    if (hdc)
    {
        u = DCICOMMAND;
        if( Escape(hdc, QUERYESCSUPPORT,sizeof(u),(LPCSTR)&u,NULL) == 0 )
        {
            /*
             * driver does not do escape, punt it.
             */
            DeleteDC(hdc);
            hdc = NULL;
        }
    }

    if (hdc)
    {
	/*
	 * Reparent it to prevent it going away when the app. dies.
	 */
        SetObjectOwner(hdc, hInstApp);
    }

    return hdc;

} /* DCIOpenProvider */

/*
 * DCICloseProvider
 */
void WINAPI DCICloseProvider(HDC hdc)
{
    if( hdc )
    {
	DeleteDC(hdc);
    }

} /* DCICloseProvider */

/*
 * dciSendCommand
 */
static int dciSendCommand(
		HDC hdc,
		VOID FAR *pcmd,
		int nSize,
		VOID FAR * FAR * lplpOut )
{
    if( lplpOut )
    {
	*lplpOut = NULL;
    }

    return Escape( hdc, DCICOMMAND, nSize, (LPCSTR)pcmd, lplpOut );

} /* dciSendCommand */

/*
 * DCICreatePrimary
 */
int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface)
{
    DCICREATEINPUT	ci;
    DCIRVAL 		err;
    HDC 		hdcScreen;

    ci.cmd.dwCommand	= (DWORD)DCICREATEPRIMARYSURFACE;
    ci.cmd.dwParam1	= 0;
    ci.cmd.dwParam2	= 0;
    ci.cmd.dwVersion	= (DWORD)DCI_VERSION;
    ci.cmd.dwReserved	= 0;
    ci.dwDCICaps	= DCI_PRIMARY | DCI_VISIBLE;

    DPF( 4, "DCICreatePrimary" );

    /*
     * for the primary surface we always use the display driver over
     * a external provider.
     */
    hdcScreen = GetDC( NULL );
    err = dciSendCommand(hdcScreen, &ci, sizeof(DCICREATEINPUT), lplpSurface);
    ReleaseDC( NULL, hdcScreen );

    if( err != DCI_OK || *lplpSurface == NULL )
    {
	err = dciSendCommand(hdc, &ci, sizeof(DCICREATEINPUT), lplpSurface);
    }

    return err;

} /* DCICreatePrimary */

/*
 * DCIDestroy
 */
void WINAPI DCIDestroy(LPDCISURFACEINFO pdci)
{
    if( (DWORD)pdci->DestroySurface == 0xFFFFFFFF )
    {
        pdci = PDCI16(pdci);
    }

    if( pdci->DestroySurface != NULL )
    {
        pdci->DestroySurface(pdci);
    }

} /* DCIDestroy */

/*
 * DCIEndAccess
 */
void WINAPI DCIEndAccess( LPDCISURFACEINFO pdci )
{
    if( (DWORD)pdci->DestroySurface == 0xFFFFFFFF)
    {
        pdci = PDCI16( pdci );
    }

    if( pdci->EndAccess != NULL )
    {
        pdci->EndAccess( pdci );
    }

    LeaveSysLevel( pWin16Lock );

} /* DCIEndAccess */

/*
 * dciSurface16to32
 *
 * convert a DCI16 bit structure to a 32bit structure
 */
static int dciSurface16to32(
		LPDCISURFACEINFO16 pdci16,
		LPDCISURFACEINFO32 pdci32 )
{
    DPF( 4, "dciSurface16to32" );
    if( pdci16 == NULL )
    {
	DPF( 1, "pdci16=NULL" );
        return DCI_FAIL_GENERIC;
    }

    if( pdci32 == NULL )
    {
	DPF( 1, "pdci32=NULL" );
        return DCI_FAIL_GENERIC;
    }

    if (pdci16->dwSize < sizeof(DCISURFACEINFO))
    {
        //
        // invalid DCISURCACEINFO.
        //
        pdci16->dwSize = sizeof(DCISURFACEINFO);
    }

    if (pdci16->dwSize > sizeof(DCIOFFSCREEN))
    {
        //
        // invalid DCISURCACEINFO.
        //
        return DCI_FAIL_GENERIC;
    }

    _fmemcpy(pdci32, pdci16, (UINT) pdci32->dwSize);     // copy the info.

    pdci32->dwReserved2 = (DWORD)(LPVOID)pdci16;

    if (pdci16->BeginAccess != NULL)
    {
        (DWORD)pdci32->BeginAccess = 0xFFFFFFFF;   // you cant call these, but they
        (DWORD)pdci32->EndAccess   = 0xFFFFFFFF;   // must be non-zero
    }

    (DWORD)pdci32->DestroySurface = 0xFFFFFFFF;   // must be non-zero

    /*
     *  now we need to convert the pointer to a 0:32 (ie flat pointer)
     *  we can only do this if the provider has *not* set the 1632_ACCESS bit.
     *
     *  if the 1632_ACCESS bit is set, call VFlatD to see if we can
     *  enable linear access mode.
     */
    if( pdci16->wSelSurface != 0 )
    {
        if( pdci16->dwDCICaps & DCI_1632_ACCESS )
        {
            if( pdci16->wSelSurface == VFDQuerySel())
            {
                if( (wFlatSel == 0) && VFDBeginLinearAccess() )
                {
                    wFlatSel = AllocSelector(SELECTOROF((LPVOID)&pdci16));
                    SetSelectorBase(wFlatSel, 0);
                    SetSelLimit(wFlatSel, 0xFFFFFFFF);
                }

                if (wFlatSel != 0)
                {
                    pdci32->dwOffSurface += VFDQueryBase();
                    pdci32->wSelSurface = wFlatSel; // 0;
                    pdci32->dwDCICaps &= ~DCI_1632_ACCESS;
                }
            }
        }
        else
        {
	    /*
	     *	convert the 16:32 pointer to a flat pointer.
	     */
            pdci32->dwOffSurface += GetSelectorBase(pdci16->wSelSurface);
	    pdci32->wSelSurface = 0;
	    pdci32->wReserved = 0;
        }
    }
    else
    {
        // selector is zero so the address is flat already
        // clear DCI_1632_ACCESS for broken providers?

	pdci32->dwDCICaps &= ~DCI_1632_ACCESS;	    // !!!needed?
    }

    return DCI_OK;

} /* dciSurface16to32 */

/*
 * DCIBeginAccess
 */
DCIRVAL WINAPI DCIBeginAccess(
		LPDCISURFACEINFO pdci,
		int x,
		int y,
		int dx,
		int dy )
{
    int		err;
    RECT	rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x+dx;
    rc.bottom = y+dy;

    if( (DWORD)pdci->DestroySurface == 0xFFFFFFFF )
    {
	LPDCISURFACEINFO16 pdci16 = PDCI16(pdci);

	if( pdci16->BeginAccess != NULL )
	{
	    err = pdci16->BeginAccess( pdci16, &rc );
	}
	else
	{
	    err = DCI_OK;
	}

	if( err > 0 )
	{
	    err = dciSurface16to32(pdci16, pdci);
	}
    }
    else
    {
	if( pdci->BeginAccess != NULL )
	{
	    err = pdci->BeginAccess(pdci, &rc);
	}
	else
	{
	    err = DCI_OK;
	}
    }

    if( err >= 0 )
    {
        EnterSysLevel( pWin16Lock );
    }
    return err;

} /* DCIBeginAccess */

/*
 * DCICreatePrimary
 */
int WINAPI DCICreatePrimary32(HDC hdc, LPDCISURFACEINFO32 pdci32)
{
    LPDCISURFACEINFO	pdci16;
    int			rc;

    DPF( 4, "DCICreatePrimary32" );

    rc = DCICreatePrimary(hdc, &pdci16);

    if( rc == DCI_OK )
    {
        rc = dciSurface16to32( pdci16, pdci32 );
    }

    return rc;

} /* DCICreatePrimary */

/*
 * DCIIsBanked
 */
BOOL DDAPI DCIIsBanked( HDC hdc )
{
    LPDCISURFACEINFO	pdci16;
    int			rc;

    rc = DCICreatePrimary(hdc, &pdci16);
    if( rc == DCI_OK )
    {
	if( !IsBadReadPtr( pdci16, sizeof( *pdci16 ) ) )
	{
	    if( pdci16->dwDCICaps & DCI_1632_ACCESS )
	    {
		rc = TRUE;
	    }
	    else
	    {
		rc = FALSE;
	    }
	    DCIDestroy( pdci16 );
	}
	else
	{
	    rc = FALSE;
	}
	return rc;
    }
    return FALSE;

} /* DCIIsBanked */

#pragma optimize("", off)
void SetSelLimit(UINT sel, DWORD limit)
{
    if( limit >= 1024*1024l )
    {
        limit = ((limit+4096) & ~4095) - 1;
    }

    _asm
    {
        mov     ax,0008h            ; DPMI set limit
        mov     bx,sel
        mov     dx,word ptr limit[0]
        mov     cx,word ptr limit[2]
        int     31h
    }
} /* SetSelLimit */
#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\ddraw16.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw16.c
 *  Content:	16-bit DirectDraw entry points
 *		This is only used for 16-bit display drivers on Win95
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   13-feb-95	craige	allow 32-bit callbacks
 *   14-may-95	craige	removed obsolete junk
 *   19-jun-95	craige	more cleanup; added DDHAL_StreamingNotify
 *   02-jul-95	craige	comment out streaming notify stuff
 *   07-jul-95	craige	validate pdevice
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   05-sep-95	craige	bug 814: added DD16_IsWin95MiniDriver
 *   02-mar-96  colinmc Repulsive hack to keep interim drivers working
 *   16-apr-96  colinmc Bug 17921: remove interim driver support
 *   06-oct-96  colinmc Bug 4207: Invalid LocalFree in video port stuff
 *   15-oct-96  colinmc Bug 4353: Failure to initialize VideoPort fields
 *                      in convert
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

typedef struct DRIVERINFO
{
    struct DRIVERINFO		  FAR *link;
    DDHALINFO			  ddHalInfo;
    DDHAL_DDCALLBACKS		  tmpDDCallbacks;
    DDHAL_DDSURFACECALLBACKS	  tmpDDSurfaceCallbacks;
    DDHAL_DDPALETTECALLBACKS	  tmpDDPaletteCallbacks;
    DDHAL_DDVIDEOPORTCALLBACKS	  tmpDDVideoPortCallbacks;
    DDHAL_DDCOLORCONTROLCALLBACKS tmpDDColorControlCallbacks;
    DWORD			  dwEvent;
} DRIVERINFO, FAR *LPDRIVERINFO;

extern __cdecl SetWin32Event( DWORD );
void convertV1DDHALINFO( LPDDHALINFO_V1 lpddOld, LPDDHALINFO lpddNew );

BOOL		bInOurSetMode;
LPDRIVERINFO	lpDriverInfo;


/*
 * freeDriverInfo
 */
void freeDriverInfo( LPDRIVERINFO pgi )
{
    if( pgi->ddHalInfo.lpdwFourCC != NULL )
    {
	LocalFreeSecondary( OFFSETOF(pgi->ddHalInfo.lpdwFourCC ) );
	pgi->ddHalInfo.lpdwFourCC = NULL;
    }
    if( pgi->ddHalInfo.lpModeInfo != NULL )
    {
	LocalFreeSecondary( OFFSETOF( pgi->ddHalInfo.lpModeInfo ) );
	pgi->ddHalInfo.lpModeInfo = NULL;
    }
    if( pgi->ddHalInfo.vmiData.pvmList != NULL )
    {
	LocalFreeSecondary( OFFSETOF( pgi->ddHalInfo.vmiData.pvmList ) );
	pgi->ddHalInfo.vmiData.pvmList = NULL;
    }
} /* freeDriverInfo */

/*
 * DDHAL_SetInfo
 *
 * Create a Driver object.   Called by the display driver
 */
BOOL DDAPI DDHAL_SetInfo(
	LPDDHALINFO lpDrvDDHALInfo,
	BOOL reset )
{
    LPDDHAL_DDCALLBACKS		drvcb;
    LPDDHAL_DDSURFACECALLBACKS	surfcb;
    LPDDHAL_DDPALETTECALLBACKS	palcb;
    DWORD			bit;
    LPVOID			cbrtn;
    LPVOID			ptr;
    int				numcb;
    int				i;
    UINT			size;
    LPDRIVERINFO		pgi;
    static char			szPath[ MAX_PATH ];
    LPDDHALINFO			lpDDHALInfo;
    DDHALINFO			ddNew;

    if( !VALIDEX_DDHALINFO_PTR( lpDrvDDHALInfo ) )
    {
	#ifdef DEBUG
	    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid DDHALINFO provided" );
	    DPF( 0, "lpDDHalInfo = %08lx", lpDrvDDHALInfo );
	    if( !IsBadWritePtr( lpDrvDDHALInfo, 1 ) )
	    {
                DPF( 0, "lpDDHalInfo->dwSize = %ld (%ld expected)",
                                lpDrvDDHALInfo->dwSize, (DWORD)sizeof( DDHALINFO ) );
	    }
	#endif
	return FALSE;
    }

    DPF(5, "lpDrvDDHALInfo->dwSize = %ld", lpDrvDDHALInfo->dwSize);
    /*
     * Check to see if the driver gave us an old DDHALINFO
     */
    if( lpDrvDDHALInfo->dwSize == DDHALINFOSIZE_V1 )
    {
	/*
	 * We actually changed the ordering of some fields from V1
	 * to V2 so we need to do some conversion to get it into
	 * shape.
	 */
	convertV1DDHALINFO((LPDDHALINFO_V1)lpDrvDDHALInfo, &ddNew);
	// use the reformatted ddhalinfo
	lpDDHALInfo = &ddNew;
    }
    else if( lpDrvDDHALInfo->dwSize < sizeof(DDHALINFO) )
    {
	/*
	 * Its a newer version than V1 but not as new as this
	 * version of DirectDraw. No ordering changes have taken
	 * place but the HAL info is too small. We need to ensure
	 * that the all the new fields are zeroed.
	 *
	 * NOTE: Validation above should have taken care of the
	 * error case where the size is less than the size of the
	 * V1 HAL info.
	 */
	_fmemset(&ddNew, 0, sizeof(ddNew));
	_fmemcpy(&ddNew, lpDrvDDHALInfo, (size_t)lpDrvDDHALInfo->dwSize);
	lpDDHALInfo = &ddNew;
    }
    else
    {
	// the driver gave us a current ddhalinfo, use it.
	lpDDHALInfo = lpDrvDDHALInfo;
    }

    /*
     * check for hInstance
     */
    if( lpDDHALInfo->hInstance == 0 )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:lpDDHalInfo->hInstance is NULL " );
	return FALSE;
    }

    /*
     * validate 16-bit driver callbacks
     */
    drvcb = lpDDHALInfo->lpDDCallbacks;
    if( !VALIDEX_PTR_PTR( drvcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid driver callback ptr" );
	return FALSE;
    }
    DPF(5, "lpDDCallbacks->dwSize = %ld", drvcb->dwSize);
    if( !VALIDEX_DDCALLBACKSSIZE( drvcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid size field in lpDDCallbacks" );
	return FALSE;
    }
    numcb =(int) (drvcb->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID );
    bit = 1;
    for( i=0;i<numcb;i++ )
    {
	if( !(drvcb->dwFlags & bit) )
	{
	    cbrtn = (LPVOID) ((DWORD FAR *) &drvcb->DestroyDriver)[i];
	    if( cbrtn != NULL )
	    {
		if( !VALIDEX_CODE_PTR( cbrtn ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid 16-bit callback in lpDDCallbacks" );
		    return FALSE;
		}
	    }
	}
	bit <<= 1;
    }

    /*
     * validate 16-bit surface callbacks
     */
    surfcb = lpDDHALInfo->lpDDSurfaceCallbacks;
    if( !VALIDEX_PTR_PTR( surfcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid surface callback ptr" );
	return FALSE;
    }
    DPF(5, "lpDDSurfaceCallbacks->dwSize = %ld", surfcb->dwSize);
    if( !VALIDEX_DDSURFACECALLBACKSSIZE( surfcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid size field in lpDDSurfaceCallbacks" );
	return FALSE;
    }
    numcb =(int)(surfcb->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID );
    bit = 1;
    for( i=0;i<numcb;i++ )
    {
	if( !(surfcb->dwFlags & bit) )
	{
	    cbrtn = (LPVOID) ((DWORD FAR *) &surfcb->DestroySurface)[i];
	    if( cbrtn != NULL )
	    {
		if( !VALIDEX_CODE_PTR( cbrtn ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid 16-bit callback in lpSurfaceCallbacks" );
		    return FALSE;
		}
	    }
	}
	bit <<= 1;
    }

    /*
     * validate 16-bit palette callbacks
     */
    palcb = lpDDHALInfo->lpDDPaletteCallbacks;
    if( !VALIDEX_PTR_PTR( palcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid palette callback ptr" );
	return FALSE;
    }
    DPF(5, "lpDDPaletteCallbacks->dwSize = %ld", palcb->dwSize);
    if( !VALIDEX_DDPALETTECALLBACKSSIZE( palcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid size field in lpPaletteCallbacks" );
	return FALSE;
    }
    numcb =(int)(palcb->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID );
    bit = 1;
    for( i=0;i<numcb;i++ )
    {
	if( !(palcb->dwFlags & bit) )
	{
	    cbrtn = (LPVOID) ((DWORD FAR *) &palcb->DestroyPalette)[i];
	    if( cbrtn != NULL )
	    {
		if( !VALIDEX_CODE_PTR( cbrtn ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid 16-bit callback in lpPaletteCallbacks" );
		    return FALSE;
		}
	    }
	}
	bit <<= 1;
    }
    /*
     * check pdevice
     */
    if( lpDDHALInfo->lpPDevice != NULL )
    {
	if( !VALIDEX_PTR( lpDDHALInfo->lpPDevice, sizeof( DIBENGINE ) ) )
	{
	    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid PDEVICE ptr" );
	    return FALSE;
	}
    }

    /*
     * see if we have a driver info struct already
     */
    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == lpDDHALInfo->hInstance )
	{
	    break;
	}
	pgi = pgi->link;
    }

    if( pgi == NULL )
    {
	pgi = (LPVOID) (void NEAR *)LocalAlloc( LPTR, sizeof( DRIVERINFO ) );
	if( OFFSETOF( pgi ) == NULL )
	{
	    DPF( 0, "Out of memory!" );
	    return FALSE;
	}
	pgi->link = lpDriverInfo;
	lpDriverInfo = pgi;
    }

    DPF( 5, "hInstance = %08lx (%08lx)", pgi->ddHalInfo.hInstance, lpDDHALInfo->hInstance );

    /*
     * duplicate the hal info
     */
    freeDriverInfo( pgi );

    _fmemcpy( &pgi->ddHalInfo, lpDDHALInfo, sizeof( DDHALINFO ) );
    if( lpDDHALInfo->lpDDCallbacks != NULL )
    {
	_fmemcpy( &pgi->tmpDDCallbacks, lpDDHALInfo->lpDDCallbacks, sizeof( pgi->tmpDDCallbacks ) );
	pgi->ddHalInfo.lpDDCallbacks = &pgi->tmpDDCallbacks;
    }
    if( lpDDHALInfo->lpDDSurfaceCallbacks != NULL )
    {
	_fmemcpy( &pgi->tmpDDSurfaceCallbacks, lpDDHALInfo->lpDDSurfaceCallbacks, sizeof( pgi->tmpDDSurfaceCallbacks ) );
	pgi->ddHalInfo.lpDDSurfaceCallbacks = &pgi->tmpDDSurfaceCallbacks;
    }
    if( lpDDHALInfo->lpDDPaletteCallbacks != NULL )
    {
	_fmemcpy( &pgi->tmpDDPaletteCallbacks, lpDDHALInfo->lpDDPaletteCallbacks, sizeof( pgi->tmpDDPaletteCallbacks ) );
	pgi->ddHalInfo.lpDDPaletteCallbacks = &pgi->tmpDDPaletteCallbacks;
    }
    if( lpDDHALInfo->lpdwFourCC != NULL )
    {
	size = (UINT) lpDDHALInfo->ddCaps.dwNumFourCCCodes * sizeof( DWORD );
	if( size != 0 )
	{
	    ptr = (LPVOID) LocalAllocSecondary( LPTR, size );
	}
	else
	{
	    ptr = NULL;
	}
	pgi->ddHalInfo.lpdwFourCC = ptr;
	if( ptr != NULL )
	{
	    _fmemcpy( pgi->ddHalInfo.lpdwFourCC, lpDDHALInfo->lpdwFourCC, size );
	}
    }
    if( lpDDHALInfo->lpModeInfo != NULL )
    {
	size = (UINT) lpDDHALInfo->dwNumModes * sizeof( DDHALMODEINFO );
	if( size != 0 )
	{
	    ptr = (LPVOID) LocalAllocSecondary( LPTR, size );
	}
	else
	{
	    ptr = NULL;
	}
	pgi->ddHalInfo.lpModeInfo = ptr;
	if( ptr != NULL )
	{
	    _fmemcpy( pgi->ddHalInfo.lpModeInfo, lpDDHALInfo->lpModeInfo, size );
	}
    }
    if( lpDDHALInfo->vmiData.pvmList != NULL )
    {
	size = (UINT) lpDDHALInfo->vmiData.dwNumHeaps * sizeof( VIDMEM );
	if( size != 0 )
	{
	    ptr = (LPVOID) LocalAllocSecondary( LPTR, size );
	}
	else
	{
	    ptr = NULL;
	}
	pgi->ddHalInfo.vmiData.pvmList = ptr;
	if( ptr != NULL )
	{
	    _fmemcpy( pgi->ddHalInfo.vmiData.pvmList, lpDDHALInfo->vmiData.pvmList, size );
	}
    }

    /*
     * get the driver version info
     */
    pgi->ddHalInfo.ddCaps.dwReserved1 = 0;
    pgi->ddHalInfo.ddCaps.dwReserved2 = 0;
    if( GetModuleFileName( (HINSTANCE) lpDDHALInfo->hInstance, szPath, sizeof( szPath ) ) )
    {
	int	size;
	DWORD	dumbdword;
	size = (int) GetFileVersionInfoSize( szPath, (LPDWORD) &dumbdword );
	if( size != 0 )
	{
	    LPVOID	vinfo;

	    vinfo = (LPVOID) (void NEAR *) LocalAlloc( LPTR, size );
	    if( OFFSETOF( vinfo ) != NULL )
	    {
		if( GetFileVersionInfo( szPath, 0, size, vinfo ) )
		{
		    VS_FIXEDFILEINFO 	FAR *ver=NULL;
		    int			cb;

		    if( VerQueryValue(vinfo, "\\", &(LPVOID)ver, &cb) )
		    {
			if( ver != NULL )
			{
			    pgi->ddHalInfo.ddCaps.dwReserved1 = ver->dwFileVersionLS;
			    pgi->ddHalInfo.ddCaps.dwReserved2 = ver->dwFileVersionMS;
			}
		    }
		}
		LocalFree( OFFSETOF( vinfo ) );
	    }
	}
    }

    if( !bInOurSetMode && reset )
    {
	DPF( 4, "************************* EXTERNAL MODE SET ************************" );
	if( pgi->dwEvent != NULL )
	{
	    SetWin32Event( pgi->dwEvent );
	}
    }

    return TRUE;

} /* DDHAL_SetInfo */

/*
 * DDHAL_VidMemAlloc
 */
FLATPTR DDAPI DDHAL_VidMemAlloc(
		LPDDRAWI_DIRECTDRAW_GBL lpDD,
		int heap,
		DWORD dwWidth,
		DWORD dwHeight )
{
    extern FLATPTR DDAPI DDHAL32_VidMemAlloc( LPDDRAWI_DIRECTDRAW_GBL this, int heap, DWORD dwWidth, DWORD dwHeight );

    if( lpDD != NULL )
    {
	return DDHAL32_VidMemAlloc( lpDD, heap, dwWidth,dwHeight );
    }
    else
    {
	return 0;
    }

} /* DDHAL_VidMemAlloc */

/*
 * DDHAL_VidMemFree
 */
void DDAPI DDHAL_VidMemFree(
		LPDDRAWI_DIRECTDRAW_GBL lpDD,
		int heap,
		FLATPTR fpMem )
{
    extern void DDAPI DDHAL32_VidMemFree( LPDDRAWI_DIRECTDRAW_GBL this, int heap, FLATPTR ptr );
    if( lpDD != NULL )
    {
	DDHAL32_VidMemFree( lpDD, heap, fpMem );
    }

} /* DDHAL_VidMemFree */

/*
 * DD16_GetDriverFns
 */
void DDAPI DD16_GetDriverFns( LPDDHALDDRAWFNS pfns )
{
    pfns->dwSize = sizeof( DDHALDDRAWFNS );
    pfns->lpSetInfo = DDHAL_SetInfo;
    pfns->lpVidMemAlloc = DDHAL_VidMemAlloc;
    pfns->lpVidMemFree = DDHAL_VidMemFree;

} /* DD16_GetDriverFns */

/*
 * DD16_GetHALInfo
 */
void DDAPI DD16_GetHALInfo( LPDDHALINFO pddhi )
{
    LPDRIVERINFO		pgi;

    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == pddhi->hInstance )
	{
	    break;
	}
	pgi = pgi->link;
    }
    if( pgi == NULL )
    {
	return;
    }
    DPF( 4, "GetHalInfo: lpHalInfo->GetDriverInfo = %lx", pgi->ddHalInfo.GetDriverInfo);

    DPF( 5, "GetHalInfo: lpHalInfo=%08lx", &pgi->ddHalInfo );
    DPF( 5, "GetHalInfo: pddhi=%08lx", pddhi );

    _fmemcpy( pddhi, &pgi->ddHalInfo, sizeof( DDHALINFO ) );

} /* DD16_GetHALInfo */

/*
 * DD16_DoneDriver
 */
void DDAPI DD16_DoneDriver( DWORD hInstance )
{
    LPDRIVERINFO	pgi;
    LPDRIVERINFO	prev;

    prev = NULL;
    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == hInstance )
	{
	    break;
	}
        prev = pgi;
	pgi = pgi->link;
    }
    if( pgi == NULL )
    {
	DPF( 0, "COULD NOT FIND HINSTANCE=%08lx", hInstance );
	return;
    }
    if( prev == NULL )
    {
	lpDriverInfo = pgi->link;
    }
    else
    {
	prev->link = pgi->link;
    }
    DPF( 5, "Freeing %08lx, hInstance=%08lx", pgi, hInstance );
    freeDriverInfo( pgi );
    LocalFree( OFFSETOF( pgi ) );

} /* DD16_DoneDriver */

/*
 * DD16_SetEventHandle
 */
void DDAPI DD16_SetEventHandle( DWORD hInstance, DWORD dwEvent )
{
    LPDRIVERINFO	pgi;

    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == hInstance )
	{
	    break;
	}
	pgi = pgi->link;
    }
    if( pgi == NULL )
    {
	DPF( 0, "COULD NOT FIND HINSTANCE=%08lx", hInstance );
	return;
    }
    pgi->dwEvent = dwEvent;
    DPF( 5, "Got event handle: %08lx\n", dwEvent );

} /* DD16_SetEventHandle */

/*
 * DD16_IsWin95MiniDriver
 */
BOOL DDAPI DD16_IsWin95MiniDriver( void )
{
    DIBENGINE 		FAR *pde;
    HDC			hdc;
    UINT		rc;

    hdc = GetDC(NULL);
    rc = GetDeviceCaps(hdc, CAPS1);
    pde = GetPDevice(hdc);
    ReleaseDC(NULL, hdc);

    if( !(rc & C1_DIBENGINE) || IsBadReadPtr(pde, 2) ||
    	pde->deType != 0x5250 )
    {
	#ifdef DEBUG
	    if( !(rc & C1_DIBENGINE) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver is not a DibEngine driver" );
	    }
	    if( IsBadReadPtr(pde, 2) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not obtain pdevice!" );
	    }
	    else if( pde->deType != 0x5250 )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Pdevice signature invalid" );
	    }
	#endif
	return FALSE;
    }
    return TRUE;

} /* DD16_IsWin95MiniDriver */

#ifdef STREAMING
/*
 * DDHAL_StreamingNotify
 */
void DDAPI DDHAL_StreamingNotify( DWORD dw )
{
    extern void DDAPI DD32_StreamingNotify( DWORD dw );
    DD32_StreamingNotify( dw );

} /* DDHAL_StreamingNotify */
#endif

/*
 * convertV1DDHALINFO
 *
 * Convert an obsolete DDHALINFO structure to the latest and greatest structure.
 */
void convertV1DDHALINFO( LPDDHALINFO_V1 lpddOld, LPDDHALINFO lpddNew )
{
    int		i;

    lpddNew->dwSize = sizeof( DDHALINFO );
    lpddNew->lpDDCallbacks = lpddOld->lpDDCallbacks;
    lpddNew->lpDDSurfaceCallbacks = lpddOld->lpDDSurfaceCallbacks;
    lpddNew->lpDDPaletteCallbacks = lpddOld->lpDDPaletteCallbacks;
    lpddNew->vmiData = lpddOld->vmiData;

    // ddCaps
    lpddNew->ddCaps.dwSize = lpddOld->ddCaps.dwSize;
    lpddNew->ddCaps.dwCaps = lpddOld->ddCaps.dwCaps;
    lpddNew->ddCaps.dwCaps2 = lpddOld->ddCaps.dwCaps2;
    lpddNew->ddCaps.dwCKeyCaps = lpddOld->ddCaps.dwCKeyCaps;
    lpddNew->ddCaps.dwFXCaps = lpddOld->ddCaps.dwFXCaps;
    lpddNew->ddCaps.dwFXAlphaCaps = lpddOld->ddCaps.dwFXAlphaCaps;
    lpddNew->ddCaps.dwPalCaps = lpddOld->ddCaps.dwPalCaps;
    lpddNew->ddCaps.dwSVCaps = lpddOld->ddCaps.dwSVCaps;
    lpddNew->ddCaps.dwAlphaBltConstBitDepths = lpddOld->ddCaps.dwAlphaBltConstBitDepths;
    lpddNew->ddCaps.dwAlphaBltPixelBitDepths = lpddOld->ddCaps.dwAlphaBltPixelBitDepths;
    lpddNew->ddCaps.dwAlphaBltSurfaceBitDepths = lpddOld->ddCaps.dwAlphaBltSurfaceBitDepths;
    lpddNew->ddCaps.dwAlphaOverlayConstBitDepths = lpddOld->ddCaps.dwAlphaOverlayConstBitDepths;
    lpddNew->ddCaps.dwAlphaOverlayPixelBitDepths = lpddOld->ddCaps.dwAlphaOverlayPixelBitDepths;
    lpddNew->ddCaps.dwAlphaOverlaySurfaceBitDepths = lpddOld->ddCaps.dwAlphaOverlaySurfaceBitDepths;
    lpddNew->ddCaps.dwZBufferBitDepths = lpddOld->ddCaps.dwZBufferBitDepths;
    lpddNew->ddCaps.dwVidMemTotal = lpddOld->ddCaps.dwVidMemTotal;
    lpddNew->ddCaps.dwVidMemFree = lpddOld->ddCaps.dwVidMemFree;
    lpddNew->ddCaps.dwMaxVisibleOverlays = lpddOld->ddCaps.dwMaxVisibleOverlays;
    lpddNew->ddCaps.dwCurrVisibleOverlays = lpddOld->ddCaps.dwCurrVisibleOverlays;
    lpddNew->ddCaps.dwNumFourCCCodes = lpddOld->ddCaps.dwNumFourCCCodes;
    lpddNew->ddCaps.dwAlignBoundarySrc = lpddOld->ddCaps.dwAlignBoundarySrc;
    lpddNew->ddCaps.dwAlignSizeSrc = lpddOld->ddCaps.dwAlignSizeSrc;
    lpddNew->ddCaps.dwAlignBoundaryDest = lpddOld->ddCaps.dwAlignBoundaryDest;
    lpddNew->ddCaps.dwAlignSizeDest = lpddOld->ddCaps.dwAlignSizeDest;
    lpddNew->ddCaps.dwAlignStrideAlign = lpddOld->ddCaps.dwAlignStrideAlign;
    lpddNew->ddCaps.ddsCaps = lpddOld->ddCaps.ddsCaps;
    lpddNew->ddCaps.dwMinOverlayStretch = lpddOld->ddCaps.dwMinOverlayStretch;
    lpddNew->ddCaps.dwMaxOverlayStretch = lpddOld->ddCaps.dwMaxOverlayStretch;
    lpddNew->ddCaps.dwMinLiveVideoStretch = lpddOld->ddCaps.dwMinLiveVideoStretch;
    lpddNew->ddCaps.dwMaxLiveVideoStretch = lpddOld->ddCaps.dwMaxLiveVideoStretch;
    lpddNew->ddCaps.dwMinHwCodecStretch = lpddOld->ddCaps.dwMinHwCodecStretch;
    lpddNew->ddCaps.dwMaxHwCodecStretch = lpddOld->ddCaps.dwMaxHwCodecStretch;
    lpddNew->ddCaps.dwSVBCaps = 0;
    lpddNew->ddCaps.dwSVBCKeyCaps = 0;
    lpddNew->ddCaps.dwSVBFXCaps = 0;
    lpddNew->ddCaps.dwVSBCaps = 0;
    lpddNew->ddCaps.dwVSBCKeyCaps = 0;
    lpddNew->ddCaps.dwVSBFXCaps = 0;
    lpddNew->ddCaps.dwSSBCaps = 0;
    lpddNew->ddCaps.dwSSBCKeyCaps = 0;
    lpddNew->ddCaps.dwSSBFXCaps = 0;
    lpddNew->ddCaps.dwReserved1 = lpddOld->ddCaps.dwReserved1;
    lpddNew->ddCaps.dwReserved2 = lpddOld->ddCaps.dwReserved2;
    lpddNew->ddCaps.dwReserved3 = lpddOld->ddCaps.dwReserved3;
    lpddNew->ddCaps.dwMaxVideoPorts = 0;
    lpddNew->ddCaps.dwCurrVideoPorts = 0;
    lpddNew->ddCaps.dwSVBCaps2 = 0;
    for(i=0; i<DD_ROP_SPACE; i++)
    {
	lpddNew->ddCaps.dwRops[i] = lpddOld->ddCaps.dwRops[i];
	lpddNew->ddCaps.dwSVBRops[i] = 0;
	lpddNew->ddCaps.dwVSBRops[i] = 0;
	lpddNew->ddCaps.dwSSBRops[i] = 0;
    }

    lpddNew->dwMonitorFrequency = lpddOld->dwMonitorFrequency;
    lpddNew->GetDriverInfo = NULL; // was unused hWndListBox in v1
    lpddNew->dwModeIndex = lpddOld->dwModeIndex;
    lpddNew->lpdwFourCC = lpddOld->lpdwFourCC;
    lpddNew->dwNumModes = lpddOld->dwNumModes;
    lpddNew->lpModeInfo = lpddOld->lpModeInfo;
    lpddNew->dwFlags = lpddOld->dwFlags;
    lpddNew->lpPDevice = lpddOld->lpPDevice;
    lpddNew->hInstance = lpddOld->hInstance;

    lpddNew->lpD3DGlobalDriverData = 0;
    lpddNew->lpD3DHALCallbacks = 0;
    lpddNew->lpDDExeBufCallbacks = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\ddhal.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhal.c
 *  Content:	16-bit DirectDraw HAL
 *		These routines redirect the callbacks from the 32-bit
 *		side to the driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   03-feb-95	craige	performance tuning, ongoing work
 *   03-mar-95	craige	added WaitForVerticalBlank
 *   11-mar-95	craige	palette stuff
 *   16-mar-95	craige	added DD16_SelectPalette
 *   24-mar-95	craige	added DD16_GetTimeSel
 *   04-apr-95	craige	call display driver for get/set palette
 *   14-may-95	craige	added DD16_EnableReboot; cleaned up obsolete junk
 *   23-may-95	craige	removed DD16_GetTimeSel; cleaned up more obsolete junk
 *   28-may-95	craige	cleaned up HAL: added DDThunk16_GetBltStatus;
 *			DDThunk16_GetFlipStatus; DDThunk16_GetScanLine
 *   13-jul-95  toddla  remove _export from thunk functions
 *   13-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   01-oct-96	ketand	added GetAvailDriverMemory
 *   21-jan-97	ketand	Fix SetEntries for multimon.
 *   27-jan-97	ketand	Remove unused DD16_GetPaletteEntries; it didn't work for multi-mon
 *			and wasn't worth fixing.
 *   03-feb-97	ketand	Fix DC leak w.r.t. MakeObjectPrivate.
 *
 ***************************************************************************/
#include "ddraw16.h"

#define DPF_MODNAME "DDRAW16"

/****************************************************************************
 *
 * DRIVER CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * DDThunk16_CreatePalette
 */
DWORD DDAPI DDThunk16_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData )
{
    return lpCreatePaletteData->CreatePalette( lpCreatePaletteData );

} /* DDThunk16_CreateSurface */

/*
 * DDThunk16_CreateSurface
 */
DWORD DDAPI DDThunk16_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData )
{
    return lpCreateSurfaceData->CreateSurface( lpCreateSurfaceData );

} /* DDThunk16_CreateSurface */

/*
 * DDThunk16_CanCreateSurface
 */
DWORD DDAPI DDThunk16_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData )
{
    return lpCanCreateSurfaceData->CanCreateSurface( lpCanCreateSurfaceData );

} /* DDThunk16_CanCreateSurface */

/*
 * DDThunk16_WaitForVerticalBlank
 */
DWORD DDAPI DDThunk16_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData )
{
    return lpWaitForVerticalBlankData->WaitForVerticalBlank( lpWaitForVerticalBlankData );

} /* DDThunk16_WaitForVerticalBlank */

/*
 * DDThunk16_DestroyDriver
 */
DWORD DDAPI DDThunk16_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData )
{

    return lpDestroyDriverData->DestroyDriver( lpDestroyDriverData );

} /* DDThunk16_DestroyDriver */

/*
 * DDThunk16_SetMode
 */
DWORD DDAPI DDThunk16_SetMode( LPDDHAL_SETMODEDATA lpSetModeData )
{

    return lpSetModeData->SetMode( lpSetModeData );

} /* DDThunk16_SetMode */

/*
 * DDThunk16_GetScanLine
 */
DWORD DDAPI DDThunk16_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData )
{

    return lpGetScanLineData->GetScanLine( lpGetScanLineData );

} /* DDThunk16_GetScanLine */

/*
 * DDThunk16_SetExclusiveMode
 */
DWORD DDAPI DDThunk16_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData )
{

    return lpSetExclusiveModeData->SetExclusiveMode( lpSetExclusiveModeData );

} /* DDThunk16_SetExclusiveMode */

/*
 * DDThunk16_FlipToGDISurface
 */
DWORD DDAPI DDThunk16_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData )
{

    return lpFlipToGDISurfaceData->FlipToGDISurface( lpFlipToGDISurfaceData );

} /* DDThunk16_FlipToGDISurface */

/*
 * DDThunk16_GetAvailDriverMemory
 */
DWORD DDAPI DDThunk16_GetAvailDriverMemory( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData )
{

    return lpGetAvailDriverMemoryData->GetAvailDriverMemory( lpGetAvailDriverMemoryData );

} /* DDThunk16_GetAvailDriverMemory */

/*
 * DDThunk16_UpdateNonLocalHeap
 */
DWORD DDAPI DDThunk16_UpdateNonLocalHeap( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData )
{

    return lpUpdateNonLocalHeapData->UpdateNonLocalHeap( lpUpdateNonLocalHeapData );

} /* DDThunk16_UpdateNonLocalHeap */

/****************************************************************************
 *
 * SURFACE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * DDThunk16_DestroySurface
 */
DWORD DDAPI DDThunk16_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData )
{

    return lpDestroySurfaceData->DestroySurface( lpDestroySurfaceData );

} /* DDThunk16_DestroySurface */

/*
 * DDThunk16_Flip
 */
DWORD DDAPI DDThunk16_Flip( LPDDHAL_FLIPDATA lpFlipData )
{
    return lpFlipData->Flip( lpFlipData );

} /* DDThunk16_Flip */

/*
 * DDThunk16_Blt
 */
DWORD DDAPI DDThunk16_Blt( LPDDHAL_BLTDATA lpBltData )
{
    return lpBltData->Blt( lpBltData );

} /* DDThunk16_Blt */

/*
 * DDThunk16_Lock
 */
DWORD DDAPI DDThunk16_Lock( LPDDHAL_LOCKDATA lpLockData )
{
    return lpLockData->Lock( lpLockData );

} /* DDThunk16_Lock */

/*
 * DDThunk16_Unlock
 */
DWORD DDAPI DDThunk16_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData )
{
    return lpUnlockData->Unlock( lpUnlockData );

} /* DDThunk16_Unlock */

/*
 * DDThunk16_AddAttachedSurface
 */
DWORD DDAPI DDThunk16_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData )
{
    return lpAddAttachedSurfaceData->AddAttachedSurface( lpAddAttachedSurfaceData );

} /* DDThunk16_AddAttachedSurface */

/*
 * DDThunk16_SetColorKey
 */
DWORD DDAPI DDThunk16_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData )
{
    return lpSetColorKeyData->SetColorKey( lpSetColorKeyData );

} /* DDThunk16_SetColorKey */

/*
 * DDThunk16_SetClipList
 */
DWORD DDAPI DDThunk16_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData )
{
    return lpSetClipListData->SetClipList( lpSetClipListData );

} /* DDThunk16_ClipList */

/*
 * DDThunk16_UpdateOverlay
 */
DWORD DDAPI DDThunk16_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData )
{
    return lpUpdateOverlayData->UpdateOverlay( lpUpdateOverlayData );

} /* DDThunk16_UpdateOverlay */

/*
 * DDThunk16_SetOverlayPosition
 */
DWORD DDAPI DDThunk16_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData )
{
    return lpSetOverlayPositionData->SetOverlayPosition( lpSetOverlayPositionData );

} /* DDThunk16_SetOverlayPosition */

/*
 * DDThunk16_SetPalette
 */
DWORD DDAPI DDThunk16_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData )
{
    return lpSetPaletteData->SetPalette( lpSetPaletteData );

} /* DDThunk16_SetPalette */

/*
 * DDThunk16_GetBltStatus
 */
DWORD DDAPI DDThunk16_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData )
{
    return lpGetBltStatusData->GetBltStatus( lpGetBltStatusData );

} /* DDThunk16_GetBltStatus */

/*
 * DDThunk16_GetFlipStatus
 */
DWORD DDAPI DDThunk16_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData )
{
    return lpGetFlipStatusData->GetFlipStatus( lpGetFlipStatusData );

} /* DDThunk16_GetFlipStatus */

/****************************************************************************
 *
 * PALETTE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * DDThunk16_DestroyPalette
 */
DWORD DDAPI DDThunk16_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA lpDestroyPaletteData )
{
    return lpDestroyPaletteData->DestroyPalette( lpDestroyPaletteData );

} /* DDThunk16_CreateSurface */

/*
 * DDThunk16_SetEntries
 */
DWORD DDAPI DDThunk16_SetEntries( LPDDHAL_SETENTRIESDATA lpSetEntriesData )
{
    return lpSetEntriesData->SetEntries( lpSetEntriesData );

} /* DDThunk16_CreateSurface */


/****************************************************************************
 *
 * PRIVATE HELPER FNS TO CALL PRIVATE 16-BIT SERVICES
 *
 ***************************************************************************/

/*
 * DD16_SelectPalette
 */
void DDAPI DD16_SelectPalette( HDC hdc, HPALETTE hpal, BOOL f )
{
    extern HANDLE FAR PASCAL GDISelectPalette(HDC,HANDLE,BOOL);
    extern DWORD FAR PASCAL GDIRealizePalette(HDC);

    GDISelectPalette( hdc, hpal, f );
    GDIRealizePalette( hdc );

} /* DD16_SelectPalette */

BOOL (FAR PASCAL *OEMSetPalette)( WORD wStartIndex, WORD wNumEntries, LPPALETTEENTRY lpPalette );

// Special hooks so we can do the right thing on Multi-mon systems
// And also so we can get the PDevice from the Dc.
#define SD_GETPDEV      0x000F      // this constant lives in testing.h!
extern DWORD PASCAL GDISeeGDIDo(WORD wMsg, WORD wParam, LONG lParam);
#define GethModuleFromDC(hdc) (HMODULE)HIWORD(GDISeeGDIDo(SD_GETPDEV, (WORD)hdc, 0))
#define GetPDeviceFromDC(hdc)    (UINT)LOWORD(GDISeeGDIDo(SD_GETPDEV, (WORD)hdc, 0))

/*
 * DD16_SetPaletteEntries
 */
BOOL DDAPI DD16_SetPaletteEntries(
		HDC hdc,
		DWORD dwBase,
		DWORD dwNumEntries,
		LPPALETTEENTRY lpColorTable,
		BOOL fPrimary )
{
    HMODULE     hmod;
    #ifdef DEBUG
	UINT        rc;

	rc = GetDeviceCaps( hdc, RASTERCAPS );

	if( !(rc & RC_PALETTE) )
	{
	    DPF_ERR( "DD16_SetPaletteEntries: not a paletized mode" );
            _asm int 3
	    return FALSE;
	}
	if( lpColorTable == NULL )
	{
	    DPF_ERR( "DD16_SetPaletteEntries: lpColorTable == NULL" );
            _asm int 3
	    return FALSE;
	}
	if( dwBase >= 256 || dwBase + dwNumEntries > 256 || dwNumEntries == 0 )
	{
            DPF_ERR( "DD16_SetPaletteEntries: bad params passed" );
            _asm int 3
	    return FALSE;
	}

    #endif

    if( fPrimary )
    {
	DWORD pDevice = 0;
	if( OEMSetPalette == NULL )
	{
	    hmod = GetModuleHandle( "DISPLAY" );
	    if( hmod == NULL )
	    {
		return FALSE;
	    }
	    OEMSetPalette = (LPVOID) GetProcAddress( hmod, MAKEINTATOM(22) );
	    if( OEMSetPalette == NULL )
	    {
		return FALSE;
	    }
	}

	// WARNING: Don't change anything from here to the end of the function without
	// checking the assembly!

	// ToddLa says that we need to put the pdevice into EDX before
	// making this call. It will matter for advanced video hardware
	// that supports multiple different external ports.
	pDevice = (DWORD) GetPDevice(hdc);
	_asm
	{
	    ;; The following line of code is actually
	    ;; mov edx, dword ptr pDevice
	    ;; The 16-bit compiler we have can't deal with such complexities
	    _emit 66h _asm mov dx, word ptr pDevice        ;edx = pDevice
	}
	return OEMSetPalette( (WORD) dwBase, (WORD) dwNumEntries, lpColorTable );
    }
    else
    {
	BOOL (FAR PASCAL *OEMSetPaletteTmp)( WORD wStartIndex, WORD wNumEntries, LPPALETTEENTRY lpPalette );
	DWORD pDevice = 0;
	DWORD dwGDI;
	BOOL wasPrivate;
	extern BOOL WINAPI MakeObjectPrivate(HANDLE hObj, BOOL bPrivate);

	// Not the primary? Then we need to get the module handle
	// by asking GDI. (This doesn't work in Win95 however, so this should
	// only be happening on Multi-mon systems.)

	DPF( 4, "About to set the palette for non-primary device." );

	wasPrivate = MakeObjectPrivate( hdc, TRUE );

	dwGDI = GDISeeGDIDo(SD_GETPDEV, (WORD)hdc, 0);

	MakeObjectPrivate( hdc, wasPrivate );

	if( dwGDI == -1 )
	{
	    DPF_ERR( "GDIGetModuleHandle failed!. Couldn't set palette" );
	    return FALSE;
	}

	hmod = (HMODULE)HIWORD(dwGDI);

	// Got the module?
	if( hmod == NULL )
	{
	    DPF_ERR( "GDIGetModuleHandle failed!. Couldn't set palette" );
	    return FALSE;
	}

	// Now go get the entrypoint:
	OEMSetPaletteTmp = (LPVOID) GetProcAddress( hmod, MAKEINTATOM(22) );
	if( OEMSetPaletteTmp == NULL )
	{
	    DPF_ERR( "GetProcAddress failed!. Couldn't set palette" );
	    return FALSE;
	}

	// WARNING: Don't change anything from here to the end of the function without
	// checking the assembly!

	// ToddLa says that we need to put the pdevice into EDX before
	// making this call. It will matter for advanced video hardware
	// that supports multiple different external ports.
        pDevice = (DWORD)(UINT)LOWORD(dwGDI) << 16;
	_asm
	{
	    ;; The following line of code is actually
	    ;; mov edx, dword ptr pDevice
	    ;; The 16-bit compiler we have can't deal with such complexities
	    _emit 66h _asm mov dx, word ptr pDevice        ;edx = pDevice
	}
	return OEMSetPaletteTmp( (WORD) dwBase, (WORD) dwNumEntries, lpColorTable );
    }


} /* DD16_SetPaletteEntries */

#define REBOOT_DEVICE_ID    9
#define REBOOT_DISABLE      0x0101
#define REBOOT_ENABLE       0x0102

/*
 * doEnableReboot
 */
static void PASCAL doEnableReboot( UINT EnableDisableFlag )
{
    _asm
    {
        xor     di,di
        mov     es,di
        mov     ax,1684h
        mov     bx,REBOOT_DEVICE_ID
        int     2fh
        mov     ax,es
        or      ax,di
        jz      exit
        push    cs
        push    offset exit
        push    es
        push    di
        mov     ax, EnableDisableFlag
        retf
exit:
    }

} /* doEnableReboot */

/*
 * DD16_EnableReboot
 */
void DDAPI DD16_EnableReboot( BOOL enable )
{
    if( enable )
    {
	doEnableReboot( REBOOT_ENABLE );
    }
    else
    {
	doEnableReboot( REBOOT_DISABLE );
    }

} /* DD16_EnableReboot */

/*
 * DD16_InquireVisRgn
 */
HRGN DDAPI DD16_InquireVisRgn( HDC hdc )
{
    extern HRGN WINAPI InquireVisRgn(HDC hdc);

    return InquireVisRgn( hdc );

} /* DD16_InquireVisRgn */

/*
 * DDThunk16_ColorControl
 */
DWORD DDAPI DDThunk16_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData )
{
    return lpColorData->ColorControl( lpColorData );

} /* DDThunk16_ColorControl */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\dibpatch.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dibpatch.c
 *  Content:	Code to patch the DIB engine to correct problems with using
 *              the VRAM bit to disable the video card's accelerator.
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   13-Sep-96	colinmc	initial implementation
 *   31-jan-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

extern UINT FAR PASCAL AllocCStoDSAlias(UINT);

#define DIBENGMODULE          "DIBENG"
#define EXTTEXTOUTENTRYPOINT  "DIB_EXTTEXTOUTEXT"
#define EXTTEXTOUTPATCHOFFSET 136

char szExtTextOutMagic[] = "\x74\x0a\xf7\x86\x60\xff\x00\x80";
char szExtTextOutPatch[] = "\x90\x90\x90\x90\x90\x90\x90\x90";

LPVOID GetModifiableCodeAddress(LPCSTR lpszModuleName, LPCSTR lpszEntryPointName)
{
    HMODULE hModule;
    FARPROC fpEntryPoint;
    LPVOID  lpCodeAddress;

    hModule = GetModuleHandle(lpszModuleName);
    if (NULL == hModule)
    {
        DPF(0, "DIB Engine not loaded");
        return NULL;
    }

    fpEntryPoint = GetProcAddress(hModule, lpszEntryPointName);
    if (NULL == fpEntryPoint)
    {
        DPF(0, "Could not locate DIB engine's ExtTextOut entry point");
        return FALSE;
    }

    lpCodeAddress = (LPVOID)MAKELP(AllocCStoDSAlias(SELECTOROF(fpEntryPoint)), OFFSETOF(fpEntryPoint));
    if (NULL == lpCodeAddress)
    {
        DPF(0, "Could not allocate data segment alias for code segment");
        return FALSE;
    }

    return lpCodeAddress;
}

#define FREEMODIFIABLECODEADDRESS(lpCodeAddress) FreeSelector(SELECTOROF(lpCodeAddress))

BOOL ValidateDIBEngine(void)
{
    LPBYTE lpCodeAddress;
    LPBYTE lpMagicAddress;
    BOOL   fDIBEngineOK;

    /*
     * Get a pointer to the ExtTextOut code.
     */
    lpCodeAddress = (LPBYTE)GetModifiableCodeAddress(DIBENGMODULE, EXTTEXTOUTENTRYPOINT);
    if (NULL == lpCodeAddress)
        return FALSE;

    /*
     * Move to the patch address.
     */
    lpMagicAddress = lpCodeAddress + EXTTEXTOUTPATCHOFFSET;

    /*
     * Verify that the data at the patch address is the stuff we want to replace.
     */
    fDIBEngineOK = (!_fmemcmp(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1));
    if (!fDIBEngineOK)
    {
	/*
	 * Couldn't find the signature bytes we are looking for. This might be because we
	 * already patched it. So check for the no-ops.
	 */
	fDIBEngineOK = (!_fmemcmp(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1));
    }

    #ifdef DEBUG
        if (!fDIBEngineOK)
            DPF(2, "DIB Engine does not match magic or patch - different version?");
    #endif

    FREEMODIFIABLECODEADDRESS(lpMagicAddress);

    return fDIBEngineOK;
}

BOOL PatchDIBEngineExtTextOut(BOOL fPatch)
{
    LPBYTE lpCodeAddress;
    LPBYTE lpMagicAddress;

    /*
     * Get a pointer to the ExtTextOut code.
     */
    lpCodeAddress = (LPBYTE)GetModifiableCodeAddress(DIBENGMODULE, EXTTEXTOUTENTRYPOINT);
    if (NULL == lpCodeAddress)
        return FALSE;

    /*
     * Move to the patch address.
     */
    lpMagicAddress = lpCodeAddress + EXTTEXTOUTPATCHOFFSET;

    if (fPatch)
    {
	/*
	 * Don't do anything if its already patched.
	 */
	if (_fmemcmp(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1))
	{
	    /*
	     * Be very sure we know we are dealing with a DIB engine we can handle.
	     */
	    if (_fmemcmp(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1))
	    {
		DPF(1, "Unknown DIB Engine. not fixing up");
		FREEMODIFIABLECODEADDRESS(lpMagicAddress);
		return FALSE;
	    }

	    /*
	     * Replace the offending code with NOPs.
	     */
	    _fmemcpy(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1);
	}
    }
    else
    {
	/*
	 * Don't do anything if its already unpatched.
	 */
	if (!_fmemcmp(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1))
	{
	    /*
	     * Be very sure we know we are dealing with a DIB engine we can handle.
	     */
	    if (_fmemcmp(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1))
	    {
		DPF(1, "Unknown DIB Engine. not fixing up");
		FREEMODIFIABLECODEADDRESS(lpMagicAddress);
		return FALSE;
	    }

	    /*
	     * Put the original code back.
	     */
	    _fmemcpy(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1);
	}
    }

    FREEMODIFIABLECODEADDRESS(lpMagicAddress);

    return TRUE;
}

BOOL DDAPI DD16_FixupDIBEngine(void)
{
    /*
     * Is this Win 4.1 (or higher)
     */
    OSVERSIONINFO ver = {sizeof(OSVERSIONINFO)};
    GetVersionEx(&ver);

    if (ver.dwMajorVersion > 4 ||
        (ver.dwMajorVersion == 4 && ver.dwMinorVersion >= 10))
    {
        return TRUE;
    }

    /*
     * Is this a DIB engine version we can work with?
     */
    if( !ValidateDIBEngine() )
	return FALSE;

    /*
     * It is the correct version. So fix it up. Currently all this
     * involves is patching the ExtTextOut routine.
     */
    return PatchDIBEngineExtTextOut(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\ddraw16.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw16.h
 *  Content:	DirectDraw for Win95 16-bit header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   19-jun-95	craige	tweaks for DCI support
 *   03-jul-95	craige	stuff for bpp change
 *
 ***************************************************************************/

#ifndef __DDRAW16_INCLUDED__
#define __DDRAW16_INCLUDED__

#include <windows.h>
#include <print.h>
#include <toolhelp.h>
#include <string.h>
#include <stdlib.h>
#include "gdihelp.h"
#include "dibeng.inc"
#include "ver.h"

extern UINT 	wFlatSel;
extern LPVOID	pWin16Lock;

void SetSelLimit(UINT sel, DWORD limit);

extern LPVOID WINAPI GetWin16Lock(void);
extern void   WINAPI EnterSysLevel(LPVOID);
extern void   WINAPI LeaveSysLevel(LPVOID);

extern DWORD FAR PASCAL VFDQueryVersion( void );
extern  WORD FAR PASCAL VFDQuerySel( void );
extern DWORD FAR PASCAL VFDQuerySize( void );
extern DWORD FAR PASCAL VFDQueryBase( void );
extern DWORD FAR PASCAL VFDBeginLinearAccess( void );
extern DWORD FAR PASCAL VFDEndLinearAccess( void );
extern  void FAR PASCAL VFDReset( void );

extern LPVOID FAR PASCAL LocalAllocSecondary( WORD, WORD );
extern void FAR PASCAL LocalFreeSecondary( WORD );

#pragma warning( disable: 4704)

#define WIN95

typedef BOOL FAR *LPBOOL;
typedef struct _LARGE_INTEGER
{
    DWORD LowPart;
    LONG HighPart;
} LARGE_INTEGER;
typedef struct _ULARGE_INTEGER
{
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER;

#define NO_D3D
#define NO_DDHELP
#include "ddrawpr.h"
#include "modex.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\edid.h ===
//
// This include file contains the format of the VESA EDID data structure as
// described in the VESA Display Data Channel (DDC) Specification.  It should
// be included in any assembly language program that requires knowledge of the
// EDID data structure.
//
typedef struct VESA_EDID {
        BYTE    veHeader[8];        // 0,FFH,FFH,FFH,FFH,FFH,FFH,0
        BYTE    veManufactID[2];    // in compressed format - see spec
        BYTE    veProductCode[2];   // vendor assigned code
        DWORD   veSerialNbr;        // 32 bit serial nbr (LSB first)
        BYTE    veWeekMade;         // week of manufacture (0-53)
        BYTE    veYearMade;         // year of manufacture - 1990
        BYTE    veEDIDVersion;      // version number of EDID
        BYTE    veEDIDRevision;     // revision number of EDID
        BYTE    veVidInputDef;      // video input definition
        BYTE    veMaxHorizSize;     // horizontal image size in cm
        BYTE    veMaxVertSize;      // vertical image size in cm
        BYTE    veGammaXFER;        // (gamma * 100) - 100 (1.00-3.55)
        BYTE    veDPMSFeatures;     // DPMS feature support
        BYTE    veRedGreenLow;      // Rx1Rx0Ry1Ry0Gx1Gx0Gy1Gy0
        BYTE    veBlueWhiteLow;     // Bx1Bx0By1By0Wx1Wx0Wy1Wy0
        BYTE    veRedx;             // red X bit 9 - 2
        BYTE    veRedy;             // red Y bit 9 - 2
        BYTE    veGreenx;           // green X bit 9 - 2
        BYTE    veGreeny;           // green Y bit 9 - 2
        BYTE    veBluex;            // blue X bit 9 - 2
        BYTE    veBluey;            // blue Y bit 9 - 2
        BYTE    veWhitex;           // white X bit 9 - 2
        BYTE    veWhitey;           // white Y bit 9 - 2
        BYTE    veEstTime1;         // established timings I
        BYTE    veEstTime2;         // established timings II
        BYTE    veEstTime3;         // established timings II
        WORD    veStdTimeID1;       //
        WORD    veStdTimeID2;       //
        WORD    veStdTimeID3;       //
        WORD    veStdTimeID4;       //
        WORD    veStdTimeID5;       //
        WORD    veStdTimeID6;       //
        WORD    veStdTimeID7;       //
        WORD    veStdTimeID8;       //
        BYTE    veDetailTime1[18];  //
        BYTE    veDetailTime2[18];  //
        BYTE    veDetailTime3[18];  //
        BYTE    veDetailTime4[18];  //
        BYTE    veExtensionFlag;    // nbr of 128 EDID extensions
        BYTE    veChecksum;         // sum of all bytes == 0
}       VESA_EDID;

/*ASM
.errnz  size VESA_EDID - 128                    ;must be 128 bytes long!
*/

//
// bit definitions for the veEstTime1 field
//
#define veEstTime1_720x400x70Hz     0x80   // 720x400x70Hz  VGA,IBM
#define veEstTime1_720x400x88Hz     0x40   // 720x400x88Hz  XGA2,IBM
#define veEstTime1_640x480x60Hz     0x20   // 640x480x60Hz  VGA,IBM
#define veEstTime1_640x480x67Hz     0x10   // 640x480x67Hz  MacII,Apple
#define veEstTime1_640x480x72Hz     0x08   // 640x480x72Hz  VESA
#define veEstTime1_640x480x75Hz     0x04   // 640x480x75Hz  VESA
#define veEstTime1_800x600x56Hz     0x02   // 800x600x56Hz  VESA
#define veEstTime1_800x600x60Hz     0x01   // 800x600x60Hz  VESA

//
// bit definitions for the veEstTime2 field
//
#define veEstTime2_800x600x72Hz     0x80   // 800x600x72Hz   VESA
#define veEstTime2_800x600x75Hz     0x40   // 800x600x75Hz   VESA
#define veEstTime2_832x624x75Hz     0x20   // 832x624x75Hz   MacII,Apple
#define veEstTime2_1024x768x87Hz    0x10   // 1024x768x87Hz  IBM
#define veEstTime2_1024x768x60Hz    0x08   // 1024x768x60Hz  VESA
#define veEstTime2_1024x768x70Hz    0x04   // 1024x768x70Hz  VESA
#define veEstTime2_1024x768x75Hz    0x02   // 1024x768x75Hz  VESA
#define veEstTime2_1280x1024x75Hz   0x01   // 1280x1024x75Hz VESA

//
// bit definitions for the veEstTime3 field (was veManTimes in DDC 1)
//
#define veEstTime3_1152x870x75Hz    0x80   // 800x600x72Hz   MacII,Apple
#define veEstTime3_640x480x85Hz     0x40   // 640x480x85Hz   VESA
#define veEstTime3_800x600x85Hz     0x20   // 800x600x85Hz   VESA
#define veEstTime3_1280x1024x85Hz   0x10   // 1280x1024x85Hz VESA
#define veEstTime3_1024x768x85Hz    0x08   // 1024x768x85Hz  VESA
#define veEstTime3_1600x1200x75Hz   0x04   // 1600x1200x75Hz VESA
#define veEstTime3_1600x1200x85Hz   0x02   // 1600x1200x85Hz VESA
#define veEstTime3_ManReservedTime  0x01   // manufacturer's reserved timings

//
// bit definitions for the veStdTime field
//
#define veStdTime_HorzResMask       0x00FF    // HorzRes = (X + 31) * 8
#define veStdTime_RefreshRateMask   0x1F00    // RefreshRate = X + 60Hz
#define veStdTime_AspectRatioMask   0xC000    //
#define veStdTime_AspectRatio1to1   0x0000    // 1:1
#define veStdTime_AspectRatio4to3   0x4000    // 4:3
#define veStdTime_AspectRatio5to4   0x8000    // 5:4
#define veStdTime_AspectRatio16to9  0xC000    // 16:9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\dynares.c ===
/*
 * DynaRes
 *
 * replacment for ChangeDisplaySettings EnumDisplaySettings to allow
 * changing the bitdepth on the fly
 *
 * ToddLa
 *
 */
#ifdef IS_16
#define DIRECT_DRAW
#endif

#ifdef DIRECT_DRAW
#include "ddraw16.h"
#else
#include <windows.h>
#include <print.h>
#include "gdihelp.h"
#include "dibeng.inc"
#endif

#define BABYSIT     // if this is defined, work around bugs in the display driver
#define O95_HACK    // enable the Office95 (any app bar) hack to prevent icons from being squished
#define SPI_HACK    // enable the SPI_SETWORKAREA hack, when a app bar is up.

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
#undef Assert
#undef DPF
#ifdef DEBUG
static void CDECL DPF(char *sz, ...)
{
    char ach[128];
    lstrcpy(ach, "QuickRes: ");
    wvsprintf(ach+10, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(2, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}
static void NEAR PASCAL __Assert(char *exp, char *file, int line)
{
    DPF("Assert(%s) failed at %s line %d.", (LPSTR)exp, (LPSTR)file, line);
    DebugBreak();
}
#define Assert(exp)  ( (exp) ? (void)0 : __Assert(#exp,__FILE__,__LINE__) )
#else
#define Assert(f)
#define DPF ; / ## /
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

extern void FAR PASCAL SetMagicColors(HDC, DWORD, WORD);
extern UINT FAR PASCAL AllocCStoDSAlias(UINT);
extern void FAR PASCAL Death(HDC);
extern void FAR PASCAL Resurrection(HDC,LONG,LONG,LONG);

static char szClassName[] = "DynaResFullscreenWindow";
static char szDIBENG[]  = "DIBENG";
static char szDISPLAY[] = "DISPLAY";
static char szUSER[]    = "USER";
extern LONG FAR PASCAL DIBENG_Control(LPVOID,UINT,LPVOID,LPVOID);

extern HINSTANCE hInstApp;

#ifdef DIRECT_DRAW
extern bInOurSetMode;
#else
BOOL bInOurSetMode;
#endif

BOOL fNewDibEng;
BOOL fDirectDrawDriver;

BOOL InitDynaRes(void);
void PreStartMenuHack(DEVMODE FAR *);
void StartMenuHack(DEVMODE FAR *);
BOOL ForceSoftwareCursor(BOOL);
BOOL IsMatrox(void);

void PatchDisplay(int oem, BOOL patch);
void PatchControl(BOOL patch);
LONG FAR PASCAL _loadds Control(LPVOID lpDevice,UINT function,LPVOID lp_in_data,LPVOID lp_out_data);

#undef ChangeDisplaySettings

LONG WINAPI RealChangeDisplaySettings(LPDEVMODE pdm, DWORD flags)
{
    return ChangeDisplaySettings(pdm, flags & ~CDS_EXCLUSIVE);
}

#ifdef DIRECT_DRAW
LONG DDAPI DD16_ChangeDisplaySettings(LPDEVMODE pdm, DWORD flags)
#else
LONG WINAPI DynaChangeDisplaySettings(LPDEVMODE pdm, DWORD flags)
#endif
{
    LONG err;
    HDC hdc;
    int rc,bpp,w,h;
    int new_rc,new_bpp;
    HWND hwnd=NULL;

    bInOurSetMode = TRUE;

    flags &= ~CDS_EXCLUSIVE;

    if (!InitDynaRes())
    {
        err = ChangeDisplaySettings(pdm, flags);
        bInOurSetMode = FALSE;
        return err;
    }

    if (flags & CDS_TEST)
    {
        err = ChangeDisplaySettings(pdm, flags | CDS_EXCLUSIVE);
        bInOurSetMode = FALSE;
        return err;
    }

    if (flags & CDS_FULLSCREEN)
        PreStartMenuHack(pdm);

    //
    // try changing the mode normaly first
    // if it works, we are done.
    //
#ifdef BABYSIT
    bInOurSetMode = (BOOL)2;
    PatchControl(TRUE);
    err = ChangeDisplaySettings(pdm, flags);
    PatchControl(FALSE);
    bInOurSetMode = TRUE;
#else
    err = ChangeDisplaySettings(pdm, flags);
#endif

    if (err == DISP_CHANGE_SUCCESSFUL)
    {
        if (flags & CDS_FULLSCREEN)
            StartMenuHack(pdm);
        bInOurSetMode = FALSE;
        return err;
    }

    //
    // if the mode is not valid dont even try.
    //
    err = ChangeDisplaySettings(pdm, CDS_EXCLUSIVE | CDS_TEST);

    if (err != DISP_CHANGE_SUCCESSFUL)
    {
        bInOurSetMode = FALSE;
        return err;
    }

    //
    // get the current settings
    //
    hdc = GetDC(NULL);
    rc  = GetDeviceCaps(hdc, RASTERCAPS);
    bpp = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    w   = GetDeviceCaps(hdc, HORZRES);
    h   = GetDeviceCaps(hdc, VERTRES);
    ReleaseDC(NULL, hdc);

    //
    // dont try to do a invalid change
    //
    if (pdm && (pdm->dmFields & DM_BITSPERPEL))
    {
        if ((int)pdm->dmBitsPerPel == bpp)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_FAILED;
        }

        if (bpp <= 4 && (int)pdm->dmBitsPerPel != bpp)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_RESTART;
        }

        if (bpp > 4 && (int)pdm->dmBitsPerPel <= 4)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_RESTART;
        }
    }

#ifndef NOCREATEWINDOW
    //
    //  bring up a "cover" window to hide all the activity of the mode
    //  change from the user.  and brings up a wait cursor
    //
    //  NOTE this does a little more than just hide the mode change
    //  from the user, it also makes sure to set a MONO hourglass cursor
    //  some display drivers dont like a software cursor being active
    //  durring a mode set, so we give them a mono one.
    //
    if (TRUE || !(flags & CDS_FULLSCREEN))
    {
        #define OCR_WAIT_DEFAULT 102

        WNDCLASS cls;

        cls.lpszClassName  = szClassName;
        cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
        cls.hInstance      = hInstApp;
        cls.hIcon          = NULL;
        cls.hCursor        = (HCURSOR)LoadImage(NULL,MAKEINTRESOURCE(OCR_WAIT_DEFAULT),IMAGE_CURSOR,0,0,0);
        cls.lpszMenuName   = NULL;
        cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        cls.lpfnWndProc    = (WNDPROC)DefWindowProc;
        cls.cbWndExtra     = 0;
        cls.cbClsExtra     = 0;

        RegisterClass(&cls);

        hwnd = CreateWindowEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW,
            szClassName, szClassName,
            WS_POPUP|WS_VISIBLE, 0, 0, 10000, 10000,
            NULL, NULL, hInstApp, NULL);

        if (hwnd == NULL)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_FAILED;
        }

        SetForegroundWindow(hwnd);  // we want cursor focus
        SetCursor(cls.hCursor);     // set wait cursor.
    }
#endif

    //
    // no one gets to draw until we are done.
    //
    LockWindowUpdate(GetDesktopWindow());

    DPF("Begin mode change from %dx%dx%d....", w,h,bpp);

    //
    // first thing we have to do is convert all DDBs and Pattern brushs
    // to DIBSections so they will still work after the mode has changed.
    //
    ConvertObjects();

    //
    // convert all icons so they can be drawn correctly.
    //
    if (!fNewDibEng && !(flags & CDS_FULLSCREEN))
    {
        //ConvertIcons();
    }

#ifdef BABYSIT
    //
    // the matrox driver is broken
    // it has a global variable for bPaletized mode, and it only
    // reads it if the mode is 8bpp.
    //
    if (!fDirectDrawDriver && bpp == 8 && IsMatrox())
    {
        static char szSystemIni[] = "system.ini";
        static char szPalettized[] = "palettized";
        static char szZero[] = "0";
        static DEVMODE dm;
        dm.dmSize             = sizeof(DEVMODE);
        dm.dmFields           = DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT;
        dm.dmBitsPerPel       = 8;
        dm.dmPelsWidth        = 640;
        dm.dmPelsHeight       = 480;

        DPF("**BABYSIT** Fixing the broken Matrox driver....");
        WritePrivateProfileString(szDISPLAY,szPalettized,szZero,szSystemIni);
        err = ChangeDisplaySettings(&dm, CDS_RESET | CDS_FULLSCREEN);
        WritePrivateProfileString(szDISPLAY,szPalettized,NULL,szSystemIni);
    }
#endif

    //
    //  some drivers are total broken and we need to
    //  route some of its entry points to the DIBENG
    //
    //  WARNING this can break some remote control programs!
    //
#ifdef BABYSIT
    if (!fDirectDrawDriver)
    {
        DPF("**BABYSIT** turning off OEMOutput....");
        PatchDisplay(8, TRUE);      // route OEMOutput to the DIBENG

        DPF("**BABYSIT** turning off OEMDibBlt....");
        PatchDisplay(19, TRUE);     // route OEMDibBlt to the DIBENG
    }
#endif

    //
    // change the display settings.
    //
    PatchControl(TRUE);

    DPF("Calling ChangeDisplaySettings....");
    //
    // NOTE USER will Yield unless CDS_FULLSCREEN is specifed
    //
    err = ChangeDisplaySettings(pdm, flags | CDS_EXCLUSIVE);
    DPF("....ChangeDisplaySettings returns %d", err);

    // get the new settings
    //
    hdc = GetDC(NULL);
    new_rc  = GetDeviceCaps(hdc, RASTERCAPS);
    new_bpp = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL, hdc);

    //
    // make sure the driver has not messed up its rastercaps!
    // for example the QVision driver does not get this right.
    //
    if ((new_rc & RC_PALETTE) && new_bpp != 8)
    {
        DPF("**BABYSIT** drivers RC_PALETTE bit is messed up.");
        err = DISP_CHANGE_RESTART; // err = DISP_CHANGE_FAILED;
    }

    //
    // if the driver failed the mode set things could be real messed up
    // reset the current mode, to try to recover.
    //
#ifdef BABYSIT
    if (err != DISP_CHANGE_SUCCESSFUL)
    {
        static DEVMODE dm;
        dm.dmSize             = sizeof(DEVMODE);
        dm.dmFields           = DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT|DM_DISPLAYFLAGS;
        dm.dmBitsPerPel       = bpp;
        dm.dmPelsWidth        = w;
        dm.dmPelsHeight       = h;
        dm.dmDisplayFlags     = 0;

        DPF("**BABYSIT** mode set failed, going back to old mode.");
        ChangeDisplaySettings(&dm, CDS_RESET | CDS_EXCLUSIVE | CDS_FULLSCREEN);
    }
#endif

    PatchControl(FALSE);

    //
    // call Death/Resurection this will kick drivers in the head
    // about the mode change
    //
    if (!fDirectDrawDriver && err == 0 &&
        (pdm == NULL || (flags & CDS_UPDATEREGISTRY)))
    {
        hdc = GetDC(NULL);
        DPF("Calling Death/Resurection....");
        SetCursor(NULL);
        Death(hdc);
        Resurrection(hdc,NULL,NULL,NULL);
        ReleaseDC(NULL, hdc);
    }

    //
    // force a SW cursor, most drivers are broken and dont disable
    // the HW cursor when changing modes.
    //
#ifdef BABYSIT
    if (!fDirectDrawDriver)
    {
        if (pdm == NULL && (flags & CDS_FULLSCREEN))
        {
            DPF("**BABYSIT** restoring HW cursor (return from fullscreen mode)");
            ForceSoftwareCursor(FALSE);
        }
        else if (err == 0 && (new_bpp > 8 || GetSystemMetrics(SM_CXSCREEN) < 640))
        {
            DPF("**BABYSIT** Forcing a software cursor");
            ForceSoftwareCursor(TRUE);
        }
        else
        {
            DPF("**BABYSIT** restoring HW cursor");
            ForceSoftwareCursor(FALSE);
        }
    }
#endif

#if 0 /// moved to Control patch
    //
    // we should now convert any DIBSections that used to be DDBs back to DDBs
    // our code to find the right palette for a DDB is not too hot
    // so a lot of DDBs will have wrong colors.
    //
#if 1
    ConvertBitmapsBack(FALSE);
#else
    ConvertBitmapsBack(!(flags & CDS_FULLSCREEN));
#endif
#endif

    //
    // let other apps draw.
    //
    LockWindowUpdate(NULL);

    //
    // remove our "cover" window
    //
    if (hwnd)
    {
        DestroyWindow(hwnd);
        UnregisterClass(szClassName, hInstApp);
    }

    //
    // should we reload the wallpaper, because it got converted to
    // a DDB by ConvertBitmapsBack
    //
    if (!(flags & CDS_FULLSCREEN))
    {
        DPF("Reloading wallpaper...");
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, NULL, 0);
    }

    //
    //  have all the apps deal with a color change
    //
    if (!(flags & CDS_FULLSCREEN))
    {
        //
        //
        //
        // if we just post the WM_SYSCOLORCHANGE message to all apps
        // a hidden office window will go back and forth Invalidating
        // other office apps and re-sending the WM_SYSCOLORCHANGE message
        // you either stack overflow, hang or XL just flashes for a few
        // minutes.
        //
        // the "fix" is to not post the WM_SYSCOLORCHANGE message to
        // this hidden window, we also have to make sure not to call
        // SystemParametersInfo(SPI_SETDESKPATTERN) later in the code.
        //

        HWND hwnd;
        HWND hwndX;

        if (hwndX = FindWindow("File Open Message Window", "File Open Message Window"))
        {

            for (hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
                hwnd;
                hwnd = GetWindow(hwnd, GW_HWNDNEXT))
            {
                if (hwnd != hwndX)
                    PostMessage(hwnd, WM_SYSCOLORCHANGE, 0, 0);
            }

            // dont reload desktop pattern.
            flags |= CDS_FULLSCREEN;
        }
        else
        {
            PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);
        }
    }

    //
    // reload the desktop pattern
    //
    if (!(flags & CDS_FULLSCREEN) || pdm == NULL)
    {
        DPF("Reloading wallpaper pattern...");
        SystemParametersInfo(SPI_SETDESKPATTERN, (UINT)-1, NULL, 0);
    }

    //
    // we dont want the StartMenu to rebuild when we change modes
    //
    if (err == DISP_CHANGE_SUCCESSFUL)
    {
        if (flags & CDS_FULLSCREEN)
            StartMenuHack(pdm);
    }

    bInOurSetMode = FALSE;
    DPF("Done...");
    return err;
}

#ifndef DCICOMMAND
#define DCICOMMAND		3075		// escape value
#endif

BOOL InitDynaRes()
{
    int v;
    HDC hdc;
    HBRUSH hbr1, hbr2;
    BOOL f=TRUE;
    OSVERSIONINFO ver = {sizeof(OSVERSIONINFO)};
    GetVersionEx(&ver);

    // must be Windows95 build 950 or higher

    if (LOWORD(GetVersion()) != 0x5F03)
    {
        DPF("Init: Windows version not 3.95.");
        f = FALSE;
    }

    if (ver.dwMajorVersion != 4 ||
        ver.dwMinorVersion != 0 ||
        LOWORD(ver.dwBuildNumber) < 950)
    {
        DPF("Init: Windows version less than 4.0.950");
        f = FALSE;
    }

    //
    // we assume create/delete/create will get the same handle
    //
    hbr1 = CreateSolidBrush(RGB(1,1,1));
    DeleteObject(hbr1);
    hbr2 = CreateSolidBrush(RGB(2,2,2));
    DeleteObject(hbr2);

    if (hbr1 != hbr2)
    {
        DPF("Init: cant use Destroy/Create brush trick");
        f = FALSE;
    }

    if (GetModuleHandle(szDIBENG) == 0)
    {
        DPF("Init: DIBENG not loaded");
        f = FALSE;
    }

    hdc = GetDC(NULL);

    // check the DIBENG version
    v = 0x5250;
    v = Escape(hdc, QUERYESCSUPPORT, sizeof(int), (LPVOID)&v, NULL);

    if (v == 0)
    {
        DPF("Init: we dont have a new DIBENG");
        fNewDibEng = FALSE;
    }
    else
    {
        DPF("Init: DIBENG version: %04X", v);
        fNewDibEng = TRUE;
    }

    //
    // see if the display supports DirectDraw
    //
    v = DCICOMMAND;
    v = Escape(hdc, QUERYESCSUPPORT, sizeof(int), (LPVOID)&v, NULL);

    if (v == 0 || v == 0x5250)
    {
        DPF("Init: display driver does not support DirectDraw");
        fDirectDrawDriver = FALSE;
    }
    else
    {
        if (LOBYTE(v) == 0xFF)
            v++;

        DPF("Init: display driver supports DirectDraw: %04X", v);
        fDirectDrawDriver = TRUE;
    }

    //
    // must be a windows 4.0 mini driver.
    //
    if (GetDeviceCaps(hdc, DRIVERVERSION) < 0x0400)
    {
        DPF("Init: not a 4.0 display driver");
        f = FALSE;
    }
    if (!(GetDeviceCaps(hdc, CAPS1) & C1_DIBENGINE))
    {
        DPF("Init: not a DIBENG display driver");
        f = FALSE;
    }
    if (!(GetDeviceCaps(hdc, CAPS1) & C1_REINIT_ABLE))
    {
        DPF("Init: does not support C1_REINIT_ABLE");
        f = FALSE;
    }
    ReleaseDC(NULL, hdc);

    return f;
}

//
// we hook the OEMControl entry point in the display driver while a
// mode change is happening.  GDI will issue a QUERYDIBSUPPORT escape
// right after the mode change happens so this is the first thing
// called after the mode changed worked.  USER also issues a
// MOUSETRAILS escape.
//
// we need this hook for two reasons...
//
// 1.   some display drivers are broken and dont set deFlags right
//      we fix up the deFlags, we fix up the flags for them.
//
// 2.   we rerealize all the gdi objects in this routine when
//      USER calls us, this way all the pen/brushs/text colors
//      are correct when user goes and rebuilds its bitmaps...
//
LONG FAR PASCAL _loadds Control(LPVOID lpDevice,UINT function,LPVOID lp_in_data,LPVOID lp_out_data)
{
    DIBENGINE FAR *pde = (DIBENGINE FAR *)lpDevice;
    LONG ret;

    Assert(bInOurSetMode);

#ifdef BABYSIT
    if (pde->deType == 0x5250)
    {
        if ((pde->deFlags & FIVE6FIVE) && pde->deBitsPixel != 16)
        {
            DPF("**BABYSIT** fixing FIVE6FIVE bit");
            pde->deFlags &= ~FIVE6FIVE;
        }

        if ((pde->deFlags & PALETTIZED) && pde->deBitsPixel != 8)
        {
            DPF("**BABYSIT** fixing PALETTIZED bit");
            pde->deFlags &= ~PALETTIZED;
        }

        if ((pde->deFlags & PALETTE_XLAT) && pde->deBitsPixel != 8)
        {
            DPF("**BABYSIT** fixing PALETTE_XLAT bit");
            pde->deFlags &= ~PALETTE_XLAT;
        }
    }
#endif

    //
    // this is USER calling from LW_OEMDependentInit()
    // force all GDI objects to be rerealized
    //
    if (function == MOUSETRAILS && bInOurSetMode != (BOOL)2)
    {
        //
        // fix up the magic colors before we rerealize the brushes
        // the "right" way to do this is to reset the UI colors
        // by calling SetSysColors() but we dont want to send
        // a sync WM_SYSCOLORCHANGE from here.
        //
        HDC hdc = GetDC(NULL);
        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            SetSystemPaletteUse(hdc, SYSPAL_STATIC);
            SetMagicColors(hdc, GetSysColor(COLOR_3DSHADOW) , 8);
            SetMagicColors(hdc, GetSysColor(COLOR_3DFACE)   , 9);
            SetMagicColors(hdc, GetSysColor(COLOR_3DHILIGHT), 246);
        }
        ReleaseDC(NULL, hdc);

        //
        //  re-realize all GDI objects for the new mode.
        //
        ReRealizeObjects();

        //
        // we should now convert any DIBSections that used to be DDBs back to DDBs
        // our code to find the right palette for a DDB is not too hot
        // so a lot of DDBs will have wrong colors.
        //
        ConvertBitmapsBack(FALSE);
    }

    PatchControl(FALSE);
    ret = DIBENG_Control(lpDevice,function,lp_in_data,lp_out_data);
    PatchControl(TRUE);

    return ret;
}

//
//  patch
//
void Patch(LPCSTR szMod, LPCSTR szProc, FARPROC PatchFunc, LPDWORD PatchSave, BOOL fPatch)
{
    LPDWORD pdw;
    FARPROC x;

    //
    //  ATM 2.5 has GetProcAddress patched to return some sort of
    //  thunk, that ends up totaly confusing us and we dont end up
    //  patching the DIBENG, we patch ATM's thunk.
    //
    //  so when we want to patch DIBENG!OEMControl we use the value we
    //  *linked* to, not the value GetProcAddress returns.
    //
    if (lstrcmpi(szMod, szDIBENG) == 0 && szProc == MAKEINTATOM(3))
        x = (FARPROC)DIBENG_Control;
    else
        x = GetProcAddress(GetModuleHandle(szMod), szProc);

    if (x == NULL || PatchFunc == NULL)
        return;

    GlobalReAlloc((HGLOBAL)SELECTOROF(x), 0, GMEM_MODIFY|GMEM_MOVEABLE);

    pdw = (LPDWORD)MAKELP(AllocCStoDSAlias(SELECTOROF(x)), OFFSETOF(x));

    if (fPatch)
    {
        DPF("Patching %s!%d %04X:%04X", szMod, OFFSETOF(szProc), SELECTOROF(x), OFFSETOF(x));
        if (PatchSave[0] == 0)
        {
            PatchSave[0] = pdw[0];
            PatchSave[1] = pdw[1];
        }
        *((LPBYTE)pdw)++ = 0xEA;   // JMP
        *pdw = (DWORD)PatchFunc;
    }
    else
    {
        DPF("UnPatching %s!%d %04X:%04X", szMod, OFFSETOF(szProc), SELECTOROF(x), OFFSETOF(x));
        if (PatchSave[0] != 0)
        {
            pdw[0] = PatchSave[0];
            pdw[1] = PatchSave[1];
            PatchSave[0] = 0;
            PatchSave[1] = 0;
        }
    }

    FreeSelector(SELECTOROF(pdw));
}

//
//  hook the DIBENGs OEMControl() entry point, to jump to our own code
//
void PatchControl(BOOL patch)
{
    static DWORD SaveBytes[2];
    Patch(szDIBENG, MAKEINTATOM(3), (FARPROC)Control, SaveBytes, patch);
}

//
//  patch a entry in the display driver to jump directly to the DIBENG
//
void PatchDisplay(int oem, BOOL patch)
{
    FARPROC p;

    #define MAX_DDI 35
    static DWORD PatchBytes[MAX_DDI*2];

    if (oem >= MAX_DDI)
        return;

    p = GetProcAddress(GetModuleHandle(szDIBENG), MAKEINTATOM(oem));

    Patch(szDISPLAY, MAKEINTATOM(oem), p, &PatchBytes[oem*2], patch);
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

#ifdef O95_HACK

static BOOL fOffice95Hack;
static char szDisplaySettings[] = "Display\\Settings";
static char szResolution[]      = "Resolution";
static char szDD[]              = "%d,%d";

//
// put back the right resolution into the registy key HKCC\Display\Settings
//
void Office95Hack()
{
    if (fOffice95Hack)
    {
        HKEY hkey;
        char ach[20];
        int  len;

        DPF("Office95 hack: restoring registry");

        if (RegOpenKey(HKEY_CURRENT_CONFIG, szDisplaySettings, &hkey) == 0)
        {
            len = wsprintf(ach, szDD, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
            RegSetValueEx(hkey, szResolution, NULL, REG_SZ, ach, len);
            RegCloseKey(hkey);
        }

        fOffice95Hack = FALSE;
    }
}

#endif

#ifdef SPI_HACK

BOOL FAR PASCAL _loadds SPI(UINT spi, UINT wParam, LPVOID lParam, UINT flags);

//
//  patch USERs SystemParametersInfo function
//
void PatchSPI(BOOL patch)
{
    static DWORD SaveBytes[2];
    Patch(szUSER, MAKEINTATOM(483), (FARPROC)SPI, SaveBytes, patch);
}

BOOL FAR PASCAL _loadds SPI(UINT spi, UINT wParam, LPVOID lParam, UINT flags)
{
    BOOL f;

    if (spi == SPI_SETWORKAREA)
    {
        if (lParam)
            DPF("Ignoring a SPI_SETWORKAREA [%d,%d,%d,%d] call", ((LPRECT)lParam)->left, ((LPRECT)lParam)->top, ((LPRECT)lParam)->right - ((LPRECT)lParam)->left, ((LPRECT)lParam)->bottom - ((LPRECT)lParam)->top);
        else
            DPF("Ignoring a SPI_SETWORKAREA lParam=NULL call");
        return 0;
    }

    PatchSPI(FALSE);
    f = SystemParametersInfo(spi, wParam, lParam, flags);
    PatchSPI(TRUE);
    return f;
}
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

//
// make the start menu not update in the background.
//
#define IDT_FAVOURITE  4
#define WNDCLASS_TRAYNOTIFY     "Shell_TrayWnd"

LRESULT CALLBACK _loadds TrayWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef SPI_HACK
    PatchSPI(FALSE);
#endif
#ifdef O95_HACK
    Office95Hack();
#endif
    DPF("StartMenu hack: killing timer to refresh start menu");
    KillTimer(hwnd, IDT_FAVOURITE);
    return 0;
}

#ifdef SPI_HACK
RECT rcScreen;
RECT rcWork;
#endif

void PreStartMenuHack(DEVMODE FAR *pdm)
{
#ifdef SPI_HACK
    SetRect(&rcScreen, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&rcWork, 0);
#endif

#ifdef O95_HACK
    // make sure registry is put back
    Office95Hack();
#endif
}

void StartMenuHack(DEVMODE FAR *pdm)
{
    HWND hwndTray;
    BOOL fAppBar=FALSE;

    hwndTray = FindWindow(WNDCLASS_TRAYNOTIFY, NULL);

    if (hwndTray == NULL)
    {
        DPF("Cant find tray window");
        return;
    }

    // hack to get into the shells context, so we can clean up these hacks
    PostMessage(hwndTray, WM_TIMER, 0, (LONG)TrayWndProc);

#ifdef SPI_HACK
    {
        RECT rc;
        RECT rcTray;

        //
        //  see if there are any other app bars around.
        //
        GetWindowRect(hwndTray, &rcTray);
        SubtractRect(&rc, &rcScreen, &rcTray);

        DPF("rcScreen [%d,%d,%d,%d]", rcScreen.left, rcScreen.top, rcScreen.right-rcScreen.left,rcScreen.bottom-rcScreen.top);
        DPF("rcTray   [%d,%d,%d,%d]", rcTray.left, rcTray.top, rcTray.right-rcTray.left,rcTray.bottom-rcTray.top);
        DPF("rc       [%d,%d,%d,%d]", rc.left, rc.top, rc.right-rc.left,rc.bottom-rc.top);
        DPF("rcWork   [%d,%d,%d,%d]", rcWork.left, rcWork.top, rcWork.right-rcWork.left,rcWork.bottom-rcWork.top);

        if (!EqualRect(&rcScreen, &rcWork) && !EqualRect(&rc, &rcWork))
        {
            DPF("StartMenuHack: !!!!!there is a APP bar!!!!!!");
            fAppBar = TRUE;

            //
            // Patch the USER!SystemParameterInto function, so when the
            // shell does a SPI_SETWORKAREA call it will ignored
            // this prevents windows from being "sqished" to fit inside
            // the work area.
            //
            PatchSPI(TRUE);
        }
    }
#endif

#ifdef O95_HACK
    //
    //  the shell does the following...
    //
    //  read the HKEY_CURRENT_CONFIG\Display\Settings "Resloluton" key
    //  if this is LESS THAN the current display size, dont repark
    //  all the icons on the desktop because this is just a temporary
    //  mode set.
    //
    //  this sound right, except the bug happens when we are returning
    //  to the "normal" mode, the shell will repark the icons because
    //  it checks for LESS THEN, not LESS THAN OR EQUAL, normaly this
    //  is fine because the re-park does nothing.  when a app bar
    //  like Office95 is running it has not moved before the shell
    //  re-re-parks icons.
    //
    //  what this hack does it set the size stored in the registry
    //  to be real large so the shell does not park icons.
    //  later we will but the right values back.  we only need to
    //  do this if we are returning to the "normal" mode (ie pdm==NULL)
    //
    if (fAppBar && pdm == NULL)
    {
        HKEY hkey;
        char ach[20];
        int  len;

        fOffice95Hack = TRUE;

        if (RegOpenKey(HKEY_CURRENT_CONFIG, szDisplaySettings, &hkey) == 0)
        {
            len = wsprintf(ach, szDD, 30000, 30000);
            RegSetValueEx(hkey, szResolution, NULL, REG_SZ, ach, len);
            RegCloseKey(hkey);
        }
    }
    else
    {
        fOffice95Hack = FALSE;
    }
#endif
}

#ifdef BABYSIT

//
// force (or trick) the display driver into using a software cursor.
//
BOOL ForceSoftwareCursor(BOOL f)
{
    int n=0;

    //
    // get the mouse trails setting from USER
    //
    SystemParametersInfo(SPI_GETMOUSETRAILS, 0, (LPVOID)&n, 0);

    if (f)
    {
        //
        // enable mouse trails, this will cause the display driver to
        // turn off its hardware cursor
        //
        SystemParametersInfo(SPI_SETMOUSETRAILS, 2, NULL, 0);

        //
        // now tell the DIBENG to turn off mouse trails, the display driver
        // will think they are still on...
        //
        PatchDisplay(3, TRUE);          // route to DIBENG
        SystemParametersInfo(SPI_SETMOUSETRAILS, n, NULL, 0);
        PatchDisplay(3, FALSE);         // back to DISPLAY
    }
    else
    {
        SystemParametersInfo(SPI_SETMOUSETRAILS, n, NULL, 0);
    }

    return TRUE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL IsMatrox()
{
    char ach[80];
    int len;

    GetModuleFileName(GetModuleHandle(szDISPLAY), ach, sizeof(ach));
    len = lstrlen(ach);
    return len >= 7 && lstrcmpi(ach+len-7, "mga.drv") == 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\gdihelp.h ===
////////////////////////////////////////////////////////////////////////
//
// GDIHELP.H  - GDI TOOLHELP FUNCTIONS
//
// a bunch of GDI utility functions that are usefull for walking
// all GDI objects and dinking with them.
//
// ToddLa
//
////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

////////////////////////////////////////////////////////////////////////
//
// object enumeration functions
//
////////////////////////////////////////////////////////////////////////

#define OBJ_PEN          1
#define OBJ_BRUSH        2
#define OBJ_FONT         3
#define OBJ_PALETTE      4
#define OBJ_BITMAP       5
#define OBJ_RGN          6
#define OBJ_DC           7
#define OBJ_DISABLED_DC  8
#define OBJ_METADC       9
#define OBJ_METAFILE     10
#define OBJ_SAVEDC       42
#define OBJ_MAX          OBJ_SAVEDC

BOOL        BeginGdiSnapshot(void);
void        EndGdiSnapshot(void);

typedef     void (*EnumGdiObjectsCallback)(HGDIOBJ, LPARAM lParam);
void        EnumGdiObjects(UINT type, EnumGdiObjectsCallback callback, LPARAM lParam);

////////////////////////////////////////////////////////////////////////
//
// query information functions
//
////////////////////////////////////////////////////////////////////////

HBITMAP     StockBitmap(void);
BOOL        IsMemoryDC(HDC hdc);
BOOL        IsScreenDC(HDC hdc);
BOOL        IsObjectPrivate(HGDIOBJ h);
BOOL        IsObjectStock(HGDIOBJ h);

HANDLE      GetObjectOwner(HGDIOBJ h);
LPCSTR      GetObjectOwnerName(HGDIOBJ h);

HBITMAP     CurrentBitmap(HDC hdc);
HBRUSH      CurrentBrush(HDC hdc);
HPEN        CurrentPen(HDC hdc);
HPALETTE    CurrentPalette(HDC hdc);

HDC         GetBitmapDC(HBITMAP hbm);
HPALETTE    GetBitmapPalette(HBITMAP hbm);

////////////////////////////////////////////////////////////////////////
//
// conversion functions.
//
////////////////////////////////////////////////////////////////////////

HBITMAP     ConvertDDBtoDS(HBITMAP hbm);
HBITMAP     ConvertDStoDDB(HBITMAP hbm, BOOL fForceConvert);
HBRUSH      ConvertPatternBrush(HBRUSH hbr);
void        ConvertIcon(HICON hIcon);

void        ConvertObjects(void);
void        ConvertObjectsBack(void);
void        ConvertBitmapsBack(BOOL fForceConvert);

void        ReRealizeObjects(void);

LPVOID      GetPDevice(HDC hdc);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\libinit.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
;
;   File:       libinit.asm
;   Content:    DLL entry point - used to avoid dragging in CLIB
;   History:
;    Date	By	Reason
;    ====	==	======
;    29-mar-95	craige	initial implementation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        .286p

        .xlist
        include cmacros.inc
        .list

?PLM=1  ; Pascal calling convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   segmentation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   external functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP LocalInit           ; in KERNEL
        externFP LibMain             ; C code to do DLL init

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin Data

        assumes ds, Data

; stuff needed to avoid the C runtime coming in, and init the Windows
; reserved parameter block at the base of DGROUP

        org 0               ; base of DATA segment!

        dd  0               ; so null pointers get 0

maxRsrvPtrs = 5
        dw  maxRsrvPtrs

usedRsrvPtrs = 0
labelDP <PUBLIC, rsrvptrs>

DefRsrvPtr  macro   name
        globalW     name, 0
        usedRsrvPtrs = usedRsrvPtrs + 1
endm

DefRsrvPtr  pLocalHeap          ; local heap pointer
DefRsrvPtr  pAtomTable          ; atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
        dw maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
        __acrtused = 1

sEnd Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin CodeSeg

        assumes cs, CodeSeg

public LibEntry
LibEntry PROC FAR

        ; push frame for LibMain (hModule, cbHeap, lpszCmdLine)

        push di
        push cx
        push es
        push si

        ; init the local heap (if one is declared in the .def file)

        jcxz no_heap

        cCall LocalInit, <0, 0, cx>

no_heap:
        cCall LibMain
	
	ret

LibEntry ENDP

sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\gdihelp.c ===
/*----------------------------------------------------------------------------*\
 *  GDIHELP.C  - GDI TOOLHELP
 *
 *  a bunch of GDI utility functions that are usefull for walking
 *  all GDI objects and dinking with them.
 *
 *  ToddLa
 *
\*----------------------------------------------------------------------------*/

#ifdef IS_16
#define DIRECT_DRAW
#endif

#ifdef DIRECT_DRAW
#include "ddraw16.h"
#else
#include <windows.h>
#include "gdihelp.h"
#include "dibeng.inc"
#ifdef DEBUG
#include <toolhelp.h>
#endif
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
#undef DPF
#ifdef DEBUG
static void CDECL DPF(char *sz, ...)
{
    char ach[128];
    lstrcpy(ach,"QuickRes: ");
    wvsprintf(ach+10, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(2, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}
static void NEAR PASCAL __Assert(char *exp, char *file, int line)
{
    DPF("Assert(%s) failed at %s line %d.", (LPSTR)exp, (LPSTR)file, line);
    DebugBreak();
}
#define Assert(exp)  ( (exp) ? (void)0 : __Assert(#exp,__FILE__,__LINE__) )

#else
#define Assert(f)
#define DPF ; / ## /
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

extern     HMODULE WINAPI GetExePtr(HANDLE h);
extern     HANDLE  WINAPI SetObjectOwner(HGDIOBJ, HANDLE);
extern     BOOL    WINAPI MakeObjectPrivate(HANDLE hObj, BOOL bPrivate);
extern     int     WINAPI GDISelectPalette(HDC, HPALETTE, BOOL);

#define PresDC(hdc) GetSystemPaletteUse(hdc)

void SaveDCFix(HGDIOBJ h, LPARAM lParam);
void SaveDCReSelectObjects(HGDIOBJ h, LPARAM lParam);
void ReRealizeObject(HGDIOBJ h, LPARAM lParam);
void ReSelectObjects(HGDIOBJ h, LPARAM lParam);

typedef struct {
    BITMAPINFOHEADER bi;
    DWORD            ct[16];
}   DIB4;

typedef struct {
    BITMAPINFOHEADER bi;
    DWORD            ct[256];
}   DIB8;

typedef struct {
    HGDIOBJ h;
    UINT    type;
}   GDIOBJECT, NEAR *GDIOBJECTLIST;

GDIOBJECTLIST GdiObjectList;

WORD GetW(HGDIOBJ h, UINT off);
WORD SetW(HGDIOBJ h, UINT off, WORD w);

/*----------------------------------------------------------------------------*\
 * StockBitmap
 * return the stock 1x1x1 bitmap, windows should have a GetStockObject for
 * this but it does not.
\*----------------------------------------------------------------------------*/

HBITMAP StockBitmap()
{
    HBITMAP hbm = CreateBitmap(0,0,1,1,NULL);
    SetObjectOwner(hbm, 0);
    return hbm;
}

/*----------------------------------------------------------------------------*\
 * SafeSelectObject
 *
 * call SelectObject, but make sure USER does not RIP because we are using
 * a DC without calling GetDC.
\*----------------------------------------------------------------------------*/

HGDIOBJ SafeSelectObject(HDC hdc, HGDIOBJ h)
{
    UINT hf;

    // this prevents USER from RIPing because we are using
    // DCs in the cache without calling GetDC()
    hf = SetHookFlags(hdc, DCHF_VALIDATEVISRGN);
    h = SelectObject(hdc, h);
    SetHookFlags(hdc, hf);

    return h;
}

/*----------------------------------------------------------------------------*\
 * IsMemoryDC
 *
 * return TRUE if the passed DC is a memory DC.  we do this seeing if we
 * can select the stock bitmap into it.
\*----------------------------------------------------------------------------*/

BOOL IsMemoryDC(HDC hdc)
{
    HBITMAP hbm;

    if (hbm = (HBITMAP)SafeSelectObject(hdc, StockBitmap()))
        SafeSelectObject(hdc, hbm);

    return hbm != NULL;
}

/*----------------------------------------------------------------------------*\
 * IsScreenDC
 *
 * return TRUE for a non-memory DC
\*----------------------------------------------------------------------------*/

BOOL IsScreenDC(HDC hdc)
{
    return (!IsMemoryDC(hdc) && GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY);
}

/*----------------------------------------------------------------------------*\
 * GetObjectOwner
 * return the owner of a GDI object
\*----------------------------------------------------------------------------*/

HANDLE GetObjectOwner(HGDIOBJ h)
{
    HANDLE owner;
    owner = SetObjectOwner(h, 0);
    SetObjectOwner(h, owner);
    return owner;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL IsObjectPrivate(HGDIOBJ h)
{
    BOOL IsPrivate;
    IsPrivate = MakeObjectPrivate(h, 0);
    MakeObjectPrivate(h, IsPrivate);
    return IsPrivate;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL IsObjectStock(HGDIOBJ h)
{
    int n;

    for (n=0; n<=17; n++)
        if (GetStockObject(n) == h)
            return TRUE;

    if (StockBitmap() == h)
        return TRUE;

    return FALSE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
#pragma optimize("", off)
UINT GetGdiDS()
{
    UINT result;

    IsGDIObject((HGDIOBJ)1);
    _asm mov ax,es
    _asm mov result,ax
#ifdef DEBUG
    {
    SYSHEAPINFO shi = {sizeof(shi)};
    SystemHeapInfo(&shi);
    Assert((UINT)shi.hGDISegment == result);
    }
#endif
    return result;
}
#pragma optimize("", on)

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

GDIOBJECTLIST BuildGdiObjectList(void)
{
    int i;
    int count;
    GDIOBJECTLIST list;
    UINT type;
    UINT hgdi = GetGdiDS();

#ifdef DEBUG
    UINT ObjHist[OBJ_MAX+1];
    for (i=0; i<=OBJ_MAX; i++) ObjHist[i] = 0;
#endif

    DPF("BEGIN BuildGdiObjectList...");

    i=0;
    count=0;
    list=NULL;
again:
    {
        WORD FAR *pw;
        UINT cnt;
        HANDLE h;

        // get pointer to local heap info (stored at offset 6 in DGROUP)
        pw  = MAKELP(hgdi, 6);
        pw  = MAKELP(hgdi, *pw);

        // get pointer to first handle table (stored at offset 0x14 in HeapInfo)
        pw  = MAKELP(hgdi, pw[0x14/2]);

        //
        // a handle table starts with a WORD count of entries, followed
        // by the entries (each is a DWORD) last WORD is a pointer to
        // the next handle table or 0.
        //
        // each handle entry is a WORD ptr, followed by flags (WORD)
        // the HIBYTE of the flags is realy the lock count.
        // if the flags are 0xFFFF the handle is free.
        // for the GDI heap if 0x10 is set in the flags the
        // handle is a GDI object handle.
        //
        while (OFFSETOF(pw) != 0)
        {
            cnt = *pw++;        // get handle table count

            while (cnt-- > 0)
            {
                h = (HANDLE)OFFSETOF(pw);

                // is the handle free? yes skip
                if (pw[1] != 0xFFFF)
                {
                    // is the handle a GDI object?
                    if (pw[1] & 0x0010)
                    {
                        type = (UINT)IsGDIObject(h);

                        if (type)
                        {
                            if (list)
                            {
                                Assert(i >= 0 && i < count);
                                list[i].h    = (HGDIOBJ)h;
                                list[i].type = type;
                                i++;
                            }
                            else
                            {
                                count++;
#ifdef DEBUG
                                Assert(type > 0 && type <= OBJ_MAX);
                                ObjHist[type]++;
#endif
                            }
                        }
                    }
                    // not a gdi object, might be a SaveDC
                    else
                    {
                        if ((UINT)IsGDIObject(h) == OBJ_DC)
                        {
                            if (list)
                            {
                                Assert(i >= 0 && i < count);
                                list[i].h    = (HGDIOBJ)h;
                                list[i].type = OBJ_SAVEDC;
                                i++;
                            }
                            else
                            {
                                count++;
#ifdef DEBUG
                                ObjHist[OBJ_SAVEDC]++;
#endif
                            }
                        }
                    }
                }

                pw += 2;    // next handle
            }

            // get next handle table.
            pw = MAKELP(hgdi,*pw);
        }
    }

    if (list == NULL)
    {
        list = (GDIOBJECTLIST)LocalAlloc(LPTR, sizeof(GDIOBJECT) * (count+1));

        if (list == NULL)
        {
            Assert(0);
            return NULL;
        }

        goto again;
    }

    Assert(i == count);
    list[i].h    = NULL;   // NULL terminate list
    list[i].type = 0;      // NULL terminate list

    DPF("END BuildGdiObjectList %d objects.", count);
    DPF("    DC:     %d", ObjHist[OBJ_DC]);
    DPF("    SaveDC: %d", ObjHist[OBJ_SAVEDC]);
    DPF("    Bitmap: %d", ObjHist[OBJ_BITMAP]);
    DPF("    Pen:    %d", ObjHist[OBJ_PEN]);
    DPF("    Palette:%d", ObjHist[OBJ_PALETTE]);
    DPF("    Brush:  %d", ObjHist[OBJ_BRUSH]);
    DPF("    Total:  %d", count);

    return list;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL BeginGdiSnapshot(void)
{
    if (GdiObjectList != NULL)
        return TRUE;

    GdiObjectList = BuildGdiObjectList();

    return GdiObjectList != NULL;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

void EndGdiSnapshot(void)
{
    if (GdiObjectList != NULL)
    {
        LocalFree((HLOCAL)GdiObjectList);
        GdiObjectList = NULL;
    }
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

void EnumGdiObjects(UINT type, EnumGdiObjectsCallback callback, LPARAM lParam)
{
    int i;

    Assert(GdiObjectList != NULL);

    if (GdiObjectList == NULL)
        return;

    for (i=0; GdiObjectList[i].h; i++)
    {
        if (GdiObjectList[i].type == type)
        {
            (*callback)(GdiObjectList[i].h, lParam);
        }
    }
}

#ifdef DEBUG
/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

LPCSTR GetObjectOwnerName(HGDIOBJ hgdi)
{
    int i;
    HMODULE hModule;
    HANDLE h = GetObjectOwner(hgdi);
    static char ach[80];

    if (h == 0)
        return "System";
    else if (h == (HANDLE)1)
        return "Orphan";
    else if (hModule = (HMODULE)GetExePtr(h))
    {
        GetModuleFileName(hModule, ach, sizeof(ach));
        for (i=lstrlen(ach); i>0 && ach[i-1]!='\\'; i--)
            ;
        return ach+i;
    }
    else
    {
        wsprintf(ach, "#%04X", h);
        return ach;
    }
}
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HBITMAP CurrentBitmap(HDC hdc)
{
    HBITMAP hbm;
    if (hbm = SafeSelectObject(hdc, StockBitmap()))
        SafeSelectObject(hdc, hbm);
    return hbm;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HBRUSH CurrentBrush(HDC hdc)
{
    HBRUSH hbr;
    if (hbr = SafeSelectObject(hdc, GetStockObject(BLACK_BRUSH)))
        SafeSelectObject(hdc, hbr);
    return hbr;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HPEN CurrentPen(HDC hdc)
{
    HPEN pen;
    if (pen = SafeSelectObject(hdc, GetStockObject(BLACK_PEN)))
        SafeSelectObject(hdc, pen);
    return pen;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HPALETTE CurrentPalette(HDC hdc)
{
    HPALETTE hpal;
    if (hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE))
        SelectPalette(hdc, hpal, FALSE);
    return hpal;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HDC GetBitmapDC(HBITMAP hbm)
{
    int i;
    HDC hdc;
    HBITMAP hbmT;

    Assert(GdiObjectList != NULL);

    hdc = CreateCompatibleDC(NULL);
    hbmT = SelectObject(hdc, hbm);
    DeleteDC(hdc);

    //
    // if we can select this bitmap into a memDC, it is not selected.
    // into any other DC
    //
    if (hbmT != NULL)
        return NULL;

    if (GdiObjectList == NULL)
        return NULL;

    for (i=0; GdiObjectList[i].h; i++)
    {
        if (GdiObjectList[i].type == OBJ_DC)
        {
            if (CurrentBitmap((HDC)GdiObjectList[i].h) == hbm)
                return GdiObjectList[i].h;
        }
    }

    return NULL;
}

/*----------------------------------------------------------------------------*\
 * GetObjectPalette
\*----------------------------------------------------------------------------*/

HPALETTE GetObjectPalette(HGDIOBJ h)
{
    HANDLE owner = GetObjectOwner(h);
    HPALETTE hpal;
    HPALETTE hpal20=NULL;
    HPALETTE hpal256=NULL;
    HPALETTE hpalDef = GetStockObject(DEFAULT_PALETTE);
    int i;
    int count20;
    int count256;

    Assert(GdiObjectList != NULL);

    //
    // look at all the palettes owned by the app
    // mabey if we are lucky there will only be one.
    //
    for (i=count20=count256=0; GdiObjectList[i].h; i++)
    {
        if (GdiObjectList[i].type == OBJ_PALETTE)
        {
            hpal=(HPALETTE)GdiObjectList[i].h;

            if (hpal == hpalDef)
                continue;

            if (GetObjectOwner(hpal) == owner)
            {
                int n = 0;
                GetObject(hpal, sizeof(n), &n);

                if (n > 20)
                {
                    count256++;
                    hpal256 = hpal;
                }
                else
                {
                    count20++;
                    hpal20 = hpal;
                }
            }
        }
    }

    if (count256 == 1)
    {
        DPF("got palette (%04X) because app (%s) only has one palette", hpal256, GetObjectOwnerName(h));
        return hpal256;
    }

    if (count256 == 2 && count20 == 0)
    {
        DPF("got palette (%04X) because app (%s) only has two palettes", hpal256, GetObjectOwnerName(h));
        return hpal256;
    }

    if (count20 == 1 && count256 == 0)
    {
        DPF("got palette (%04X) because app (%s) only has one palette", hpal20, GetObjectOwnerName(h));
        return hpal20;
    }

    if (count20 == 0 && count256 == 0)
    {
        DPF("no palette for (%04X) because app (%s) has none.", h, GetObjectOwnerName(h));
        return GetStockObject(DEFAULT_PALETTE);
    }

    DPF("**** cant find palette for (%04X) ****", h);
    return NULL;
}

/*----------------------------------------------------------------------------*\
 * GetBitmapPalette
 *
 * try to find out the palette that the given DDB uses, this is done be a series
 * of hacks and it only works some of the time.
 *
\*----------------------------------------------------------------------------*/

HPALETTE GetBitmapPalette(HBITMAP hbm)
{
    BITMAP      bm;
    DWORD       dw;
    HDC         hdc;
    HPALETTE    hpal;
    HPALETTE    hpalClip=NULL;
    HBITMAP     hbmClip=NULL;

    Assert(GdiObjectList != NULL);

    //
    // get the bitmap info, if it is not a bitmap palette is NULL
    //
    if (GetObject(hbm, sizeof(bm), &bm) == 0)
        return NULL;

    //
    // DIBSections dont have or need palettes
    //
    if (bm.bmBits != NULL)
        return NULL;

    //
    // 8 bit DDBs are the only bitmaps that care about palettes
    //
    if (bm.bmBitsPixel != 8 || bm.bmPlanes != 1)
        return NULL;

    //
    //  with a new DIBENG it will give us the palette
    //  in the bitmap dimension, what a hack
    //
    dw = GetBitmapDimension(hbm);

    if (dw && IsGDIObject((HGDIOBJ)HIWORD(dw)) == OBJ_PALETTE &&
        HIWORD(dw) != (UINT)GetStockObject(DEFAULT_PALETTE))
    {
        DPF("got palette (%04X) from the DIBENG", HIWORD(dw), hbm);
        return (HPALETTE)HIWORD(dw);
    }

    //
    // if the bitmap is on the clipboard we know what palette to use
    //
    if (IsClipboardFormatAvailable(CF_PALETTE))
    {
        if (OpenClipboard(NULL))
        {
            hpalClip = GetClipboardData(CF_PALETTE);
            hbmClip = GetClipboardData(CF_BITMAP);
            CloseClipboard();
	}

        if (hbm == hbmClip)
        {
            DPF("got palette (%04X) from the clipboard", hpalClip);
            return hpalClip;
        }
    }

    //
    // try to find a palette by looking at palettes owned by the app.
    //
    hpal = GetObjectPalette(hbm);

    //
    // we can figure out the palette of the app, return it
    //
    if (hpal)
    {
        if (hpal == GetStockObject(DEFAULT_PALETTE))
            return NULL;
        else
            return hpal;
    }

    //
    // if the bitmap is selected into a memoryDC check to see if
    // the memoryDC has a palette.
    //
    if ((hdc = GetBitmapDC(hbm)) && (hpal = CurrentPalette(hdc)))
    {
        if (hpal != GetStockObject(DEFAULT_PALETTE))
        {
            DPF("got palette (%04X) from memDC (%04X)", hpal, hdc);
            return hpal;
        }
    }

    DPF("**** cant find palette for bitmap (%04X) ****", hbm);
    return NULL;
}

/*----------------------------------------------------------------------------*\
 * ConvertDDBtoDS
 *
 * converts a DDB to a DIBSection
 * the conversion is done in place so the handle does not change.
\*----------------------------------------------------------------------------*/

HBITMAP ConvertDDBtoDS(HBITMAP hbm)
{
    BITMAP bm;
    HBITMAP hbmT;
    HDC hdc;
    HDC hdcSel;
    HPALETTE hpal;
    LPVOID lpBits;
    HANDLE owner;
    BOOL IsPrivate;
    int i;
    DWORD size;
    DIB8 dib;
    UINT SelCount;
    DWORD dw;

    if (GetObject(hbm, sizeof(bm), &bm) == 0)
        return NULL;

    if (bm.bmBits)
        return NULL;

    if (bm.bmPlanes == 1 && bm.bmBitsPixel == 1)
        return NULL;

    dw = GetBitmapDimension(hbm);

    owner = GetObjectOwner(hbm);

//  if (owner == 0)
//      return NULL;

    hpal = GetBitmapPalette(hbm);

    hdc = GetDC(NULL);

    if (hpal)
    {
        SelectPalette(hdc, hpal, TRUE);
        RealizePalette(hdc);
    }

    dib.bi.biSize = sizeof(BITMAPINFOHEADER);
    dib.bi.biBitCount = 0;
    GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS);
    GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS);

    dib.bi.biXPelsPerMeter = 0x42424242;    // special flag marking a DDB
    dib.bi.biHeight = -bm.bmHeight;         // top-down DIB

    if (hpal)
        SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);

    // we dont have a palette, best guess is the system palette
    if (hpal == NULL && (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        DPF("Converting DDB(%04X) to DS for %s (using syspal)", hbm, GetObjectOwnerName(hbm));
        GetSystemPaletteEntries(hdc, 0, 256, (LPPALETTEENTRY)dib.ct);
        for (i=0; i<256; i++)
            dib.ct[i] = RGB(GetBValue(dib.ct[i]), GetGValue(dib.ct[i]), GetRValue(dib.ct[i]));
    }
    else if (hpal)
    {
        DPF("Converting DDB(%04X) to DS for %s, using palette (%04X)", hbm, GetObjectOwnerName(hbm), hpal);
    }
    else
    {
        DPF("Converting DDB(%04X) to DS for %s", hbm, GetObjectOwnerName(hbm));
    }

    ReleaseDC(NULL, hdc);

    size = (DWORD)bm.bmWidthBytes * bm.bmHeight;
    lpBits = GlobalAllocPtr(GHND, size);
    Assert(lpBits != NULL);

    if (lpBits == NULL)
        return NULL;

    GetBitmapBits(hbm, size, lpBits);

    IsPrivate = MakeObjectPrivate(hbm, FALSE);

    hdcSel = GetBitmapDC(hbm);

    if (hdcSel)
        SelectObject(hdcSel, StockBitmap());

    SelCount = GetW(hbm, 16);

    if (SelCount != 0)
    {
        DPF("***** bitmap %04X select count is %d, must be in a SaveDC block!", hbm, SelCount);
        SetW(hbm, 16, 0);
    }

    DeleteBitmap(hbm);

    if (IsGDIObject(hbm))
    {
        DPF("***** UNABLE TO DELETE bitmap %04X *****", hbm);
        Assert(0);
    }
    else
    {
        hbmT = CreateDIBSection(NULL, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS, NULL, NULL, 0);
        Assert(hbmT == hbm);
        SetBitmapBits(hbm, size, lpBits);
    }
    GlobalFreePtr(lpBits);

    if (SelCount)
        SetW(hbm, 16, SelCount);

    SetObjectOwner(hbm, owner);
    MakeObjectPrivate(hbm, IsPrivate);

    if (hdcSel)
        SelectObject(hdcSel, hbm);

    SetBitmapDimension(hbm, LOWORD(dw), HIWORD(dw));

    return hbm;
}

/*----------------------------------------------------------------------------*\
 * Convert DStoDDB
 *
 * convert a DIBSection back to a DDB, we only do this if the DIBSection
 * came from a DDB (ConvertDDBtoDS puts a magic value in biXPelsPerMeter)
 * the conversion is done in place so the handle does not change.
\*----------------------------------------------------------------------------*/

HBITMAP ConvertDStoDDB(HBITMAP hbm, BOOL fForceConvert)
{
    struct {
        BITMAP bm;
        BITMAPINFOHEADER bi;
        DWORD ct[256];
    }   ds;
    HDC hdcSel;
    HDC hdc;
    HBITMAP hbmT;
    HANDLE owner;
    BOOL IsPrivate;
    LPVOID lpBits;
    DWORD size;
    int planes,bpp,rc;
    UINT SelCount;
    DWORD dw;

    hdc = GetDC(NULL);
    bpp = GetDeviceCaps(hdc, BITSPIXEL);
    planes = GetDeviceCaps(hdc, PLANES);
    rc = GetDeviceCaps(hdc, RASTERCAPS);
    ReleaseDC(NULL, hdc);

    if (GetObject(hbm, sizeof(ds), &ds) == 0)
        return NULL;

    if (ds.bm.bmBits == NULL)
        return NULL;

    if (ds.bm.bmBitsPixel == 1)
	return NULL;

    if (ds.bi.biXPelsPerMeter != 0x42424242)
        return NULL;

    if (ds.bi.biHeight >= 0)
        return NULL;

    //
    //	HACK we want to convert bitmaps that are exactly 8x8
    //	back to DDBs always. Win95 GDI does not support
    //	Creating a pattern brush from a DIBSection so
    //	we must do this.
    //
    if (ds.bm.bmWidth == 8 && ds.bm.bmHeight == 8)
    {
	DPF("Converting 8x8 DS(%04X) back to DDB for %s", hbm, GetObjectOwnerName(hbm));
	fForceConvert = TRUE;
    }

    //
    // unless force convert is TRUE we only want to be here in 8bpp mode.
    //
    if (!fForceConvert && !(rc & RC_PALETTE))
	return NULL;

    if (!fForceConvert && (ds.bm.bmPlanes != planes || ds.bm.bmBitsPixel != bpp))
	return NULL;

    dw = GetBitmapDimension(hbm);

    owner = GetObjectOwner(hbm);

//  if (owner == 0)
//      return NULL;

    DPF("Converting DS(%04X) %dx%dx%d to DDB for %s", hbm, ds.bm.bmWidth, ds.bm.bmHeight, ds.bm.bmBitsPixel, GetObjectOwnerName(hbm));

    hdcSel = GetBitmapDC(hbm);

    size = (DWORD)ds.bm.bmWidthBytes * ds.bm.bmHeight;
    lpBits = GlobalAllocPtr(GHND, size);
    Assert(lpBits != NULL);

    if (lpBits == NULL)
        return NULL;

    IsPrivate = MakeObjectPrivate(hbm, FALSE);

    if (hdcSel)
        SelectObject(hdcSel, StockBitmap());

    hdc = GetDC(NULL);

    if (ds.bm.bmPlanes == planes && ds.bm.bmBitsPixel == bpp)
        GetBitmapBits(hbm, size, lpBits);
    else
        GetDIBits(hdc, hbm, 0, ds.bm.bmHeight, lpBits, (LPBITMAPINFO)&ds.bi, DIB_RGB_COLORS);

    SelCount = GetW(hbm, 16);

    if (SelCount != 0)
    {
        DPF("bitmap %04X select count is %d, must be in a SaveDC block!", hbm, SelCount);
        SetW(hbm, 16, 0);
    }

    DeleteBitmap(hbm);
    if (IsGDIObject(hbm))
    {
        DPF("***** UNABLE TO DELETE bitmap %04X *****", hbm);
        Assert(0);
    }
    else
    {
        hbmT = CreateCompatibleBitmap(hdc,ds.bm.bmWidth,ds.bm.bmHeight);
        Assert(hbmT == hbm);

        if (ds.bm.bmPlanes == planes && ds.bm.bmBitsPixel == bpp)
            SetBitmapBits(hbm, size, lpBits);
        else
            SetDIBits(hdc, hbm, 0, ds.bm.bmHeight, lpBits, (LPBITMAPINFO)&ds.bi, DIB_RGB_COLORS);
    }
    ReleaseDC(NULL, hdc);

    GlobalFreePtr(lpBits);

    if (SelCount)
        SetW(hbm, 16, SelCount);

    SetObjectOwner(hbm, owner);
    MakeObjectPrivate(hbm, IsPrivate);

    if (hdcSel)
        SelectObject(hdcSel, hbm);

    SetBitmapDimension(hbm, LOWORD(dw), HIWORD(dw));

    return hbm;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void FlushGdiXlatCache()
{
    DIB8    dib;
    HDC     hdc;
    HBITMAP hbm;

    if (hbm = CreateBitmap(1,1,1,1,NULL))
    {
        if (hdc = CreateCompatibleDC(NULL))
        {
            SelectBitmap(hdc, hbm);

            dib.bi.biSize           = sizeof(BITMAPINFOHEADER);
            dib.bi.biWidth          = 1;
            dib.bi.biHeight         = 1;
            dib.bi.biPlanes         = 1;
            dib.bi.biCompression    = 0;
            dib.bi.biSizeImage      = 0;
            dib.bi.biXPelsPerMeter  = 0;
            dib.bi.biYPelsPerMeter  = 0;
            dib.bi.biClrUsed        = 2;
            dib.bi.biClrImportant   = 0;
            dib.ct[0]               = RGB(1,1,1);
            dib.ct[2]               = RGB(2,2,2);

            for (dib.bi.biBitCount  = 1;
                 dib.bi.biBitCount <= 8;
                 dib.bi.biBitCount  = (dib.bi.biBitCount + 4) & ~1)
            {
                SetDIBits(hdc, hbm, 0, 1, (LPVOID)&dib.bi,
                    (LPBITMAPINFO)&dib.bi, DIB_PAL_COLORS);
            }

            DeleteDC(hdc);
        }

        DeleteBitmap(hbm);
    }
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void ReSelectObjects(HGDIOBJ h, LPARAM lParam)
{
    COLORREF rgb;
    UINT hf;
    HDC hdc = (HDC)h;

////DPF("ReSelecting objects for DC %04X", h);

    // this prevents USER from RIPing because we are using
    // DCs in the cache without calling GetDC()
    hf = SetHookFlags(hdc, DCHF_VALIDATEVISRGN);

    SelectObject(hdc, SelectObject(hdc, GetStockObject(BLACK_BRUSH)));
    SelectObject(hdc, SelectObject(hdc, GetStockObject(BLACK_PEN)));
    GDISelectPalette(hdc, GDISelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE), TRUE);

    rgb = GetTextColor(hdc);
    SetTextColor(hdc, rgb ^ 0xFFFFFF);
    SetTextColor(hdc, rgb);

    rgb = GetBkColor(hdc);
    SetBkColor(hdc, rgb ^ 0xFFFFFF);
    SetBkColor(hdc, rgb);

    SetHookFlags(hdc, hf);
}

/////////////////////////////////////////////////////////////////////////////
//
// ReRealizeObjects
//
// calls ReRealizeObject for every pen/brush in the system, this makes sure
// all pens/brushs will be rerealized next time they are used.
//
// call ReSelectObjects() to make sure the current pen/brush/text colors
// are correct in all DCs
//
/////////////////////////////////////////////////////////////////////////////

void ReRealizeObjects()
{
    BeginGdiSnapshot();

    FlushGdiXlatCache();

    EnumGdiObjects(OBJ_BRUSH, ReRealizeObject, 0);
    EnumGdiObjects(OBJ_PEN,   ReRealizeObject, 0);
    EnumGdiObjects(OBJ_DC,    ReSelectObjects, 0);

    EnumGdiObjects(OBJ_SAVEDC,SaveDCFix, 0);
    EnumGdiObjects(OBJ_SAVEDC,SaveDCReSelectObjects, 0);

    EndGdiSnapshot();
}

/////////////////////////////////////////////////////////////////////////////
//
// ConvertObjects
//
// convert all DDBs to DIBSections
// convert all color pattern brush's to DIBPattern brushs
// convert all 8bpp icons to 4bpp icons.
//
/////////////////////////////////////////////////////////////////////////////

void ConvertBitmapCB(HGDIOBJ h, LPARAM lParam)
{
    ConvertDDBtoDS(h);
}

void ConvertBrushCB(HGDIOBJ h, LPARAM lParam)
{
    ConvertPatternBrush(h);
}

void ConvertObjects()
{
    BeginGdiSnapshot();
    EnumGdiObjects(OBJ_BITMAP, ConvertBitmapCB, 0);
    EnumGdiObjects(OBJ_BRUSH,  ConvertBrushCB, 0);
    EndGdiSnapshot();
}

/////////////////////////////////////////////////////////////////////////////
//
// ConvertBitmapsBack
//
// convert all DIBSections to DDBs
//
/////////////////////////////////////////////////////////////////////////////

void ConvertBitmapBackCB(HGDIOBJ h, LPARAM lParam)
{
    ConvertDStoDDB(h, (BOOL)lParam);
}

void ConvertBitmapsBack(BOOL fForceConvert)
{
    BeginGdiSnapshot();
    EnumGdiObjects(OBJ_BITMAP, ConvertBitmapBackCB, fForceConvert);
    EndGdiSnapshot();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// BEGIN EVIL
//
// the next few functions mess directly with GDI code/data
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

LPWORD LockObj(HGDIOBJ h, UINT off)
{
    WORD FAR *pw;
    UINT hGDI = GetGdiDS();

    pw = MAKELP(hGDI, h);

    if (IsBadReadPtr(pw, 2))
        return NULL;

    pw = MAKELP(hGDI, *pw + off);

    if (IsBadReadPtr(pw, 2))
        return NULL;

    return pw;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

WORD GetW(HGDIOBJ h, UINT off)
{
    WORD FAR *pw;

    if (pw = LockObj(h, off))
        return *pw;
    else
        return 0;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

WORD SetW(HGDIOBJ h, UINT off, WORD w)
{
    WORD FAR *pw;
    WORD ret = 0;

    if (pw = LockObj(h, off))
    {
        ret = *pw;
        *pw = w;
    }
    return ret;
}

/*----------------------------------------------------------------------------*\
 * ReRealizeObject
 *
 * delete all physical objects associated with the given GDI object
 * this will guarentee the next time the brush/pen is selected we will
 * have the device driver rerealize the object.
 *
 * there are a few ways to do this....
 *
 * method #1
 *     call SetSolidBrush()
 *     this only works for private/solid(not stock) brushes, not pens
 *     we need to save/restore the stock object bit.
 *     we need to save/restore the private bit.
 *
 * method #2
 *     delete the object and recreate it getting the same handle
 *     we need to patch the SelCount because we cant delete a selected obj
 *     we need to save/restore the stock object bit.
 *     we need to save/restore the private bit.
 *     we need to save/restore the owner.
 *
 * method #3
 *     create a temp object, move the physchain from the given object
 *     to the new object, delete the temp object.
 *     we need to patch phys chain of the objects.
 *
 * after deleting all the physical objects ReSelectObjects() should be
 * called to clean up all the objects currently selected in all DCs
 *
 * SaveDCs are a pain in the neck, ReSelectObjects() does not deal with
 * the SaveDC blocks floating around GDIs heap. we need to fix this
 * in the general case, the system savedc's just have the white_brush
 * and black_pen.
 *
 * currently using method #3
 *
\*----------------------------------------------------------------------------*/

void ReRealizeObject(HGDIOBJ h, LPARAM lParam)
{
    HGDIOBJ hTemp;
    UINT type;

    type = IsGDIObject(h);

    //
    // if the object does not have a physchain we have no work to do!
    //
    if (GetW(h, 0) == 0)
        return;

    //
    // create a temp pen/brush so we can delete it and trick
    // GDI into disposing all the phys objects.
    //

    if (type == OBJ_BRUSH)
        hTemp = CreateSolidBrush(RGB(1,1,1));
    else if (type == OBJ_PEN)
        hTemp = CreatePen(PS_SOLID, 0, RGB(1,1,1));
    else
        return;

    Assert(hTemp != NULL);
    Assert(GetW(hTemp, 0) == 0);

    if (type == OBJ_BRUSH)
        DPF("ReRealize Brush %04X for %s", h, GetObjectOwnerName(h));
    else
        DPF("ReRealize Pen %04X for %s", h, GetObjectOwnerName(h));

    //
    // copy the phys chain from the passed in object to the
    // temp object then call DeleteObject to free them.
    //
    SetW(hTemp, 0, GetW(h, 0));
    SetW(h, 0, 0);

    DeleteObject(hTemp);
    return;
}

/*----------------------------------------------------------------------------*\
 * ConvertPatternBrush
 *
 * convert a BS_PATTERN brush to a BS_DIBPATTERN brush.
 * we only convert non-mono pattern brushes
\*----------------------------------------------------------------------------*/

HBRUSH ConvertPatternBrush(HBRUSH hbr)
{
    LOGBRUSH lb;
    HBITMAP hbm;
    COLORREF c0, c1;
    HDC hdc;

    if (GetObject(hbr, sizeof(lb), &lb) == 0)
        return NULL;

    if (lb.lbStyle != BS_PATTERN)
        return NULL;

    hdc = GetDC(NULL);
    hbm = CreateCompatibleBitmap(hdc, 8, 8);
    ReleaseDC(NULL, hdc);

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);
    SelectObject(hdc, hbr);

    SetTextColor(hdc, 0x000000);
    SetBkColor(hdc, 0x000000);
    PatBlt(hdc, 0, 0, 8, 8, PATCOPY);
    c0 = GetPixel(hdc, 0, 0);

    SetTextColor(hdc, 0xFFFFFF);
    SetBkColor(hdc, 0xFFFFFF);
    PatBlt(hdc, 0, 0, 8, 8, PATCOPY);
    c1 = GetPixel(hdc, 0, 0);

    //
    // if the brush is a mono pattern brush dont convert it
    //
    if (c0 == c1)
    {
        HANDLE h;
        LPBITMAPINFOHEADER lpbi;
        HBRUSH hbrT;
        HANDLE owner;
        BOOL IsPrivate;
        WORD Flags;
        HPALETTE hpal=NULL;

        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            hpal = GetObjectPalette(hbr);

            if (hpal == GetStockObject(DEFAULT_PALETTE))
                hpal = NULL;
        }

        if (hpal)
        {
            SelectPalette(hdc, hpal, TRUE);
            RealizePalette(hdc);
            PatBlt(hdc, 0, 0, 8, 8, PATCOPY);

            DPF("Converting pattern brush %04X for %s (using hpal=%04X)", hbr, GetObjectOwnerName(hbr), hpal);
        }
        else
        {
            DPF("Converting pattern brush %04X for %s", hbr, GetObjectOwnerName(hbr));
        }

        h = GlobalAlloc(GHND, sizeof(BITMAPINFOHEADER) + 256*4 + 8*8*4);

        Assert(h != NULL);
        if (h == NULL)
            return hbr;

        lpbi = (LPBITMAPINFOHEADER)GlobalLock(h);

        lpbi->biSize = sizeof(BITMAPINFOHEADER);
        lpbi->biBitCount = 0;
        GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

        if (lpbi->biClrUsed == 0 && lpbi->biCompression == BI_BITFIELDS)
            lpbi->biClrUsed = 3;

        if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
            lpbi->biClrUsed = (1 << lpbi->biBitCount);

        GetDIBits(hdc, hbm, 0, (int)lpbi->biHeight,
            (LPBYTE)lpbi + lpbi->biSize + lpbi->biClrUsed*sizeof(RGBQUAD),
            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

        owner = SetObjectOwner(hbr, 0);
        IsPrivate = MakeObjectPrivate(hbr, FALSE);
        Flags = SetW(hbr, 10, 0);

        DeleteObject(hbr);

        if (IsGDIObject(hbr))
        {
            DPF("***** UNABLE TO DELETE brush %04X *****", hbr);
            Assert(0);
        }
        else
        {
            hbrT = CreateDIBPatternBrush(h, DIB_RGB_COLORS);
            Assert(hbrT == hbr);
        }

        GlobalFree(h);

        SetW(hbr, 10, Flags);
        MakeObjectPrivate(hbr, IsPrivate);
        SetObjectOwner(hbr, owner);

        if (hpal)
        {
            SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);
        }
    }

    DeleteDC(hdc);
    DeleteObject(hbm);
    return hbr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPVOID GetPDevice(HDC hdc)
{
    DWORD FAR *pdw;

    Assert(IsGDIObject(hdc) == OBJ_DC);

    if (IsGDIObject(hdc) != OBJ_DC)
        return NULL;

    PresDC(hdc);

    if (pdw = (DWORD FAR *)LockObj(hdc, 0x30))
        return (LPVOID)*pdw;
    else
        return NULL;

////return MAKELP(GetW(hdc, 0x32), GetW(hdc, 0x30));
}

/*----------------------------------------------------------------------------*\
 *
 * get the "internal" version of a GDI api
 * we need to do this so we can call GDI APIs like SelectObject and
 * SetTextColor on SaveDC blocks.
 *
 * we only need to do this on SaveDC blocks, not every DC
 *
 * the code must look like this or we fail:
 *
 * RealProc:
 *     .....
 *     JMP  ####   <== Internal version of RealProc
 *     mov  dh,80  (optinal)
 *     RETF NumParams
 * NextProc:
 *
\*----------------------------------------------------------------------------*/

FARPROC GetInternalProc(FARPROC RealProc, FARPROC NextProc, UINT NumParams)
{
    LPBYTE pb = (LPBYTE)NextProc;

    if ((DWORD)NextProc == 0 ||
        (DWORD)RealProc == 0 ||
        LOWORD(RealProc) <= 6 ||
        (DWORD)NextProc <= (DWORD)RealProc ||
        ((DWORD)NextProc - (DWORD)RealProc) > 80)
    {
        Assert(0);
        return RealProc;
    }

    if (pb[-6] == 0xE9 && pb[-3] == 0xCA && pb[-2] == NumParams && pb[-1] == 0x00)
    {
        return (FARPROC)MAKELP(SELECTOROF(pb), OFFSETOF(pb)-3+*(WORD FAR *)(pb-5));
    }

    if (pb[-8] == 0xE9 && pb[-5] == 0xB6 && pb[-4] == 0x80 &&
        pb[-3] == 0xCA && pb[-2] == NumParams && pb[-1] == 0x00)
    {
        return (FARPROC)MAKELP(SELECTOROF(pb), OFFSETOF(pb)-5+*(WORD FAR *)(pb-7));
    }

    Assert(0);
    return RealProc;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

#define DCisMem         0x01    // DC is to a memory bitmap
#define DCisDisplay     0x02    // DC is to the screen device
#define DC_DIB          0x80
#define BITMAP_DIB      0x04
#define ChkDispPal      0x0200

BOOL IsValidSaveDC(HGDIOBJ h)
{
    HBITMAP         hbm;
    DIBENGINE FAR * pde;
    UINT            dcFlags;

    if (IsGDIObject(h) != OBJ_DC)
    {
        DPF("*** invalid SaveDC (%04X)", h);
        return FALSE;
    }

    dcFlags = GetW(h, 0x0E);

    if (!(dcFlags & DCisDisplay))
    {
        DPF("*** SaveDC (%04X) not a display DC", h);
        return FALSE;
    }

    hbm = (HBITMAP)GetW(h, 0x1E);

    if (IsGDIObject(hbm) != OBJ_BITMAP)
    {
        DPF("*** SaveDC (%04X) has invalid bitmap (%04X)", h, hbm);
        return FALSE;
    }

    pde = (DIBENGINE FAR *)MAKELP(GetW(h, 0x32), GetW(h, 0x30));

    if (IsBadReadPtr(pde, sizeof(DIBENGINE)))
    {
        DPF("*** SaveDC (%04X) has bad lpPDevice (%04X:%04X)", h, HIWORD(pde), LOWORD(pde));
        return FALSE;
    }

    if (pde->deType != TYPE_DIBENG)
    {
        DPF("*** SaveDC (%04X) not a DIBENG PDevice (%04X:%04X)", h, HIWORD(pde), LOWORD(pde));
        return FALSE;
    }

    return TRUE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void SaveDCReSelectObjects(HGDIOBJ h, LPARAM lParam)
{
    COLORREF rgb;
    HDC hdc = (HDC)h;

    static HGDIOBJ  (WINAPI *ISelectObject)(HDC hdc, HGDIOBJ h);
    static COLORREF (WINAPI *ISetTextColor)(HDC hdc, COLORREF rgb);
    static COLORREF (WINAPI *ISetBkColor)(HDC hdc, COLORREF rgb);

    if (ISelectObject == NULL)
    {
        (FARPROC)ISelectObject = GetInternalProc((FARPROC)SelectObject, (FARPROC)SetTextColor, 4);
        (FARPROC)ISetTextColor = GetInternalProc((FARPROC)SetTextColor, (FARPROC)SetBkColor, 6);
        (FARPROC)ISetBkColor   = GetInternalProc((FARPROC)SetBkColor,   (FARPROC)SetBkMode, 6);
    }

    if (IsValidSaveDC(h))
    {
        DPF("ReSelecting objects for SaveDC %04X", h);

        ISelectObject(hdc, ISelectObject(hdc, GetStockObject(BLACK_BRUSH)));
        ISelectObject(hdc, ISelectObject(hdc, GetStockObject(BLACK_PEN)));

        rgb = ISetTextColor(hdc, 0x000000);
        ISetTextColor(hdc, 0xFFFFFF);
        ISetTextColor(hdc, rgb);

        rgb = ISetBkColor(hdc, 0x000000);
        ISetBkColor(hdc, 0xFFFFFF);
        ISetBkColor(hdc, rgb);
    }
}

/*----------------------------------------------------------------------------*\
 *
 *  SaveDCFix
 *
 *  make sure the dcPlanes and dcBitsPixel are patched right in SaveDC blocks.
 *
\*----------------------------------------------------------------------------*/

void SaveDCFix(HGDIOBJ h, LPARAM lParam)
{
    HBITMAP         hbm;
    DIBENGINE FAR * pde;
    UINT            dcFlags;
    UINT            dcPlanesBitsPixel;
    UINT            dePlanesBitsPixel;

    if (!IsValidSaveDC(h))
    {
        return;
    }

    dcPlanesBitsPixel = GetW(h, 0x9C);
    dcFlags = GetW(h, 0x0E);

    if (dcPlanesBitsPixel == 0x0101)
    {
        DPF("not Patching dcBitsPixel for SaveDC %04X (mono)", h);
        return;
    }

    if (LOBYTE(dcPlanesBitsPixel) != 1)
    {
        DPF("not Patching dcBitsPixel for SaveDC %04X (planes!=1)", h);
        Assert(0);
        return;
    }

    if (dcFlags & ChkDispPal)
    {
        DPF("clearing ChkDispPal flag for SaveDC %04X", h);
        SetW(h, 0x0E, dcFlags & ~ChkDispPal);
    }

    if ((dcFlags & DCisMem) && (hbm = (HBITMAP)GetW(h, 0x1E)) != StockBitmap())
    {
        HDC  hdcSel;
        HDC  hdc;

        hdcSel = GetBitmapDC(hbm);

        if (hdcSel)
        {
            DPF("*******************************************");
            DPF("*** SaveDC (%04X) has non-stock bitmap. ***", h);
            DPF("*******************************************");
            hdc = hdcSel;
        }
        else
        {
            DPF("**********************************************");
            DPF("*** SaveDC (%04X) has non-selected bitmap. ***", h);
            DPF("*** restoring bitmap to STOCK bitmap.      ***");
            DPF("**********************************************");
            hdc = CreateCompatibleDC(NULL);
        }

        //
        //  copy over the important stuff from the RealDC to the SaveDC
        //
        if (hdc)
        {
            PresDC(hdc);

            SetW(h, 0x0F, GetW(hdc, 0x0F));      // DCFlags2

            SetW(h, 0x26, GetW(hdc, 0x26));      // hPDeviceBlock
            SetW(h, 0x38, GetW(hdc, 0x38));      // pPDeviceBlock

            SetW(h, 0x22, GetW(hdc, 0x22));      // hLDevice
            SetW(h, 0x34, GetW(hdc, 0x34));      // pLDevice

            SetW(h, 0x16, GetW(hdc, 0x16));      // hPDevice
            SetW(h, 0x30, GetW(hdc, 0x30));      // lpPDevice.off
            SetW(h, 0x32, GetW(hdc, 0x32));      // lpPDevice.sel
            SetW(h, 0x36, GetW(hdc, 0x36));      // hBitBits

            SetW(h, 0x9C, GetW(hdc, 0x9C));      // dcPlanes + dcBitsPixel
        }

        if (hdc && hdcSel == NULL)
        {
            DeleteDC(hdc);
        }

        return;

#if 0 // broken code
        SetW(h, 0x30, 0);                       // lpPDevice.off
        SetW(h, 0x32, GetW(hbm, 0x0E));         // lpPDevice.sel
        SetW(h, 0x36, GetW(hbm, 0x0E));         // hBitBits

        w = GetW(h, 0x0F);                      // DCFlags2

        if (GetW(hbm, 0x1E) & BITMAP_DIB)       // bmFlags
            w |= DC_DIB;
        else
            w &= ~DC_DIB;

        SetW(h, 0x0F, w);                       // DCFlags2
#endif
    }

    pde = (DIBENGINE FAR *)MAKELP(GetW(h, 0x32), GetW(h, 0x30));
    Assert(!IsBadReadPtr(pde, sizeof(DIBENGINE)) && pde->deType == TYPE_DIBENG);

    dePlanesBitsPixel = *(WORD FAR *)&pde->dePlanes;

    if (dePlanesBitsPixel != dcPlanesBitsPixel)
    {
        DPF("Patching dcBitsPixel for SaveDC %04X %04X=>%04X", h, dcPlanesBitsPixel, dePlanesBitsPixel);
        SetW(h,0x9C,dePlanesBitsPixel);
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// END EVIL
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifdef DIRECT_DRAW
#undef DPF
#ifdef DEBUG
#define DPF DPF2

static void CDECL DPF2(char *sz, ...)
{
    char ach[128];
    wvsprintf(ach, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(2, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}

static void CDECL DPF5(char *sz, ...)
{
    char ach[128];
    wvsprintf(ach, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(5, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}

static void CDECL DPF7(char *sz, ...)
{
    char ach[128];
    wvsprintf(ach, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(7, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}

#else
#define DPF ; / ## /
#define DPF5 ; / ## /
#define DPF7 ; / ## /
#endif

// Utility for dumping information about ColorTables
#ifdef DEBUG_PAL
void DPF_PALETTE( BITMAPINFO *pbmi )
{
    DWORD i;
    DWORD *prgb = (DWORD *)(((BYTE *)pbmi)+pbmi->bmiHeader.biSize);
    DWORD cEntries = pbmi->bmiHeader.biClrUsed;

    if (pbmi->bmiHeader.biBitCount > 8)
	return;
    if (cEntries == 0)
	cEntries = 1 << (pbmi->bmiHeader.biBitCount);

    DPF7("Dumping Color table (0xFFRRGGBB) with %d entries", cEntries);
    for (i = 0; i < cEntries; i++)
    {
	DPF7("0x%lx", prgb[i]);
    }
}
#else
#define DPF_PALETTE(x)
#endif

// Utility for Dumping information about Bitmap Infos
#ifdef DEBUG_BMI
void DPF_PBMI( BITMAPINFO * pbmi )
{
    char *szT;
    DPF5("Dumping a BitmapInfo struct");
    DPF5("\t\tdeBitmapInfo->bmiHeader.biSize = %ld",pbmi->bmiHeader.biSize);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biWidth = %ld",pbmi->bmiHeader.biWidth);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biHeight = %ld",pbmi->bmiHeader.biHeight);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biPlanes = %d",pbmi->bmiHeader.biPlanes);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biBitCount = %d",pbmi->bmiHeader.biBitCount);
    szT = ((pbmi->bmiHeader.biCompression == BI_RGB) ? "BI_RGB" : "**UNKNOWN**");
    DPF5("\t\tdeBitmapInfo->bmiHeader.biCompression = 0x%lx(%s)",pbmi->bmiHeader.biCompression, szT);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biSizeImage = %ld",pbmi->bmiHeader.biSizeImage);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biXPelsPerMeter = 0x%lx",pbmi->bmiHeader.biXPelsPerMeter);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biYPelsPerMeter = 0x%lx",pbmi->bmiHeader.biYPelsPerMeter);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biClrUsed = %ld",pbmi->bmiHeader.biClrUsed);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biClrImportant = %ld",pbmi->bmiHeader.biClrImportant);
    DPF_PALETTE(pbmi);
}
#else
#define DPF_PBMI(x)
#endif

// Utility for Dumping information about PDEs
#ifdef DEBUG_PDE
void DPF_PDE( DIBENGINE *pde )
{
    DPF5("Dumping a DIBENGINE struct.");
    DPF5("\tdeType = 0x%x(%s)",pde->deType,(pde->deType == TYPE_DIBENG ? "TYPE_DIBENG" : "**UNKNOWN**"));
    DPF5("\tdeWidth = %d",pde->deWidth);
    DPF5("\tdeHeight = %d",pde->deHeight);
    DPF5("\tdeWidthBytes = %d",pde->deWidthBytes);
    DPF5("\tdePlanes = %d",pde->dePlanes);
    DPF5("\tdeBitsPixel = %d",pde->deBitsPixel);
    DPF5("\tdeReserved1 = 0x%lx",pde->deReserved1);
    DPF5("\tdeDeltaScan = %ld",pde->deDeltaScan);
    DPF5("\tdelpPDevice = 0x%x",pde->delpPDevice);
    DPF5("\tdeBitsOffset = 0x%lx",pde->deBitsOffset);
    DPF5("\tdeBitsSelector = 0x%x",pde->deBitsSelector);
    DPF5("\tdeFlags = 0x%x(%s)",pde->deFlags,(pde->deFlags == SELECTEDDIB ? "SELECTEDDIB" : "**UNKNOWN**"));
    DPF5("\tdeVersion = %d(%s)",pde->deVersion,(pde->deVersion == VER_DIBENG ? "VER_DIBENG" : "**UNKNOWN**"));
    DPF5("\tdeBeginAccess = 0x%x",pde->deBeginAccess);
    DPF5("\tdeEndAccess = 0x%x",pde->deEndAccess);
    DPF5("\tdeDriverReserved = 0x%lx",pde->deDriverReserved);

    DPF_PBMI(pde->deBitmapInfo);
}
#else
#define DPF_PDE(x)
#endif



/////////////////////////////////////////////////////////////////////////////
//
//  DC stuff
//
/////////////////////////////////////////////////////////////////////////////
       DIBENGINE FAR *pdeDisplay;
       UINT FlatSel;
static HRGN hVisRgn;
static HDC hdcCache;
static BOOL bCache565;
static int in_use;
static int save_level;
static DWORD cacheBPP;

extern HINSTANCE hInstApp;

extern void FAR PASCAL SelectVisRgn(HDC, HRGN);
extern HDC  FAR PASCAL GetDCState(HDC);
extern void FAR PASCAL SetDCState(HDC,HDC);

BOOL DPMISetSelectorLimit(UINT selector, DWORD dwLimit);
extern DWORD PASCAL MapLS( LPVOID );	// flat -> 16:16
extern void PASCAL UnMapLS( DWORD ); // unmap 16:16

/////////////////////////////////////////////////////////////////////////////
//
//  SetDC
//	NOTE: all calls to SetDC must be matched with SetDC(hdc,0,0,0);
//
/////////////////////////////////////////////////////////////////////////////

BOOL NEAR PASCAL SetDC(HDC hdc, HDC hdcDevice, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette)
{
    DIBENGINE FAR *pde;
    int  width;
    int  height;
    int  bpp;
    UINT flags;
    DWORD p16Surface;

    pde = GetPDevice(hdc);

    if (pde == NULL)
        return FALSE;

    Assert(pde->deType == 0x5250);
    Assert(pdeDisplay && pdeDisplay->deType == 0x5250);

    if (pddsd == 0)
    {
        pde->deFlags       |= BUSY;
        pde->deBitsOffset   = 0;
        pde->deBitsSelector = 0;


	if( pde->deBitmapInfo->bmiHeader.biXPelsPerMeter == 0 )
	{
	    DPF("SetDC NULL called on a DC that was never cooked by DDraw.");
	    Assert(0);
	    return TRUE;
	}

	// This code "should be done" but it causes
	// us to SelectVisRgn more often then necessary (and more
	// often than we did in DX1-4). This is safer.
	// pde->deBitmapInfo->bmiHeader.biWidth = 1;
	// pde->deBitmapInfo->bmiHeader.biHeight = -1;
	// pde->deBitmapInfo->bmiHeader.biSizeImage = 4;

	// We need to unmap the selector we allocated below
	Assert(pde->deReserved1 != 0);
	UnMapLS(pde->deReserved1);

	// Basically, we just want to restore the flags
	// to what they were when we got DC originally
	DPF5("Restore pde->deReserved1 to 0x%lx", pde->deBitmapInfo->bmiHeader.biXPelsPerMeter);
	pde->deReserved1 = pde->deBitmapInfo->bmiHeader.biXPelsPerMeter;
	pde->deBitmapInfo->bmiHeader.biXPelsPerMeter = 0;

	Assert(pde->deReserved1 != 0);
	pde->deBitsSelector = (WORD)((DWORD)pde->deReserved1 >> 16);

        return TRUE;
    }

    // Allocate a selector
    p16Surface = MapLS(pddsd->lpSurface);
    if( !p16Surface )
    {
	DPF("Couldn't allocate selector; Out of selectors.");
	return FALSE;
    }
    if( (WORD)p16Surface != 0 )
    {
	DPF("MapLS didn't return a 16:0 pointer!");
	Assert(0);
	return FALSE;
    }

    // Set the selector limit for this chunk of memory
    Assert(pddsd->dwHeight > 0);
    Assert(pddsd->lPitch > 0);
    if( !DPMISetSelectorLimit( (UINT)(p16Surface>>16), (pddsd->dwHeight*pddsd->lPitch) - 1 ) )
    {
	DPF("Couldn't update selector; Out of selectors.");
	UnMapLS(p16Surface);
	return FALSE;
    }

    DPF5("SetDC: Details of PDE from initial hdc.");
    DPF_PDE(pde);

    width =  (int)pddsd->dwWidth,
    height = (int)pddsd->dwHeight,
    bpp =    (int)pddsd->ddpfPixelFormat.dwRGBBitCount,
    flags =  (UINT)pddsd->ddpfPixelFormat.dwRBitMask == 0xf800 ? FIVE6FIVE : 0;

    pde->deFlags       &= ~BUSY;
    // Also, make sure we set all if any banked bits are set in the driver
    // to encourage the DIBENG to avoid screen to screen blts (which are apparently buggy).
    // Only do this for BankSwitched VRAM surfaces.
    // ATTENTION: MULTIMON pdeDisplay is the primary; we should check
    // the hdcDevice instead
    if ((pddsd->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
	(pdeDisplay->deFlags & (NON64KBANK|BANKEDVRAM|BANKEDSCAN)))
    {
	pde->deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }
    else
    {
	pde->deFlags &= ~(NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }


    pde->deDeltaScan	= (DWORD)pddsd->lPitch;
    pde->deWidthBytes	= (WORD)pddsd->lPitch;

    // We use the selector we just allocated instead of the
    // flatsel + offset because it is a little safer if
    // something bad happens and someone goes off the end.
    pde->deBitsOffset	= 0;
    pde->deBitsSelector = (WORD)(p16Surface >> 16);

    pde->deBitmapInfo->bmiHeader.biXPelsPerMeter = pde->deReserved1;
    pde->deReserved1	= (DWORD)p16Surface;

    //
    // for a 8bit surface we want to color table to be the same as the
    // display (so it acts like a DDB not a DIB)
    //
    // For non-8bit surfaces; we don't need to do anything w.r.t. color table.
    //
    if (bpp == 8)
    {
        DWORD FAR *pdw;
	int i;
	RGBQUAD rgbT = {0,0,0,0};

	// Use our palette if it is explicitly set on the surface
	if (lpPalette)
	{
	    DPF( "Need a DC for an 8 bit surface with palette" );

	    Assert(pde->deBitmapInfo->bmiHeader.biBitCount == (DWORD)bpp);

	    // We use Pitch instead of Width because the "pitch" of
	    // dibsection is assumed to be the width rounded up to the next
	    // DWORD
            pde->deBitmapInfo->bmiHeader.biWidth = (DWORD)pddsd->lPitch;
	    pde->deBitmapInfo->bmiHeader.biHeight = -height; // negative height for top-down DIB
	    pde->deBitmapInfo->bmiHeader.biSizeImage = 0;
	    pde->deBitmapInfo->bmiHeader.biClrImportant = 256;

	    // We call this because it sets a magic number which
	    // has the effect of resetting any cached color translation
	    // tables that GDI may have set up for us.
	    SetDIBColorTable(hdc, 0, 1, &rgbT);

	    pdw = (DWORD FAR *)pde->deBitmapInfo;
	    pdw = (DWORD FAR *)((BYTE FAR *)pdw + pdw[0]);     // + biSize

	    for (i=0; i<256; i++)
		pdw[i] = RGB(lpPalette[i].peBlue,lpPalette[i].peGreen,lpPalette[i].peRed);
	}
	else
	{
	    DWORD FAR *pdwSrc;
	    DIBENGINE FAR *pdeDevice;
	    if (hdcDevice)
		pdeDevice = GetPDevice(hdcDevice);
	    else
		pdeDevice = pdeDisplay;

	    // This needs to be checked sooner.
	    Assert(pdeDevice && pdeDevice->deType == 0x5250);
	    Assert(pdeDevice->deBitsPixel == 8);
	    // In DX5, we will just modify our own bitmap info
	    // by copying the colors from the primary. In DX3, we
	    // pointed out bitmap info to the primary's; but that
	    // relies on the potentially bad assumption that our bitmap
	    // info will have a shorter life span to the primary's mode.
	    //
	    // It also doesn't work because the biWidth/biHeight fields
	    // of the device's primary don't match our own width/height
	    //

	    pdwSrc = (DWORD FAR *)(pdeDevice->deBitmapInfo);
	    pdwSrc = (DWORD FAR *)((BYTE FAR *)pdwSrc + pdwSrc[0]);	   // + biSize

	    pdw = (DWORD FAR *)pde->deBitmapInfo;
	    pdw = (DWORD FAR *)((BYTE FAR *)pdw + pdw[0]);	   // + biSize

	    // We call this because it sets a magic number which
	    // has the effect of resetting any cached color translation
	    // tables that GDI may have set up for us.
	    SetDIBColorTable(hdc, 0, 1, &rgbT);

	    // Copy all the colors to our color table
	    // We also clear all the special flags in our copy
	    for (i=0; i<256; i++)
		pdw[i] = (pdwSrc[i] & 0x00FFFFFF);

	    // Fixup the rest of the bitmapinfo

	    // We use Pitch instead of Width because the "pitch" of
	    // dibsection is assumed to be the width rounded up to the next
	    // DWORD
            pde->deBitmapInfo->bmiHeader.biWidth = (DWORD)pddsd->lPitch;
	    pde->deBitmapInfo->bmiHeader.biHeight = -height; // negative height for top-down DIB
	    pde->deBitmapInfo->bmiHeader.biSizeImage = 0;
	    pde->deBitmapInfo->bmiHeader.biClrImportant = 256;
	}
    }
    else
    {
	// We need to convert Pitch into the number of whole
	// pixels per scanline. There may be round-down errors
	// however, since GDI assumes that Pitches must be multiples
	// of 4; they round-up.
        DWORD pitch = (DWORD)pddsd->lPitch;
        if (bpp == 16)
            pitch = pitch / 2;
        else if (bpp == 24)
            pitch = pitch / 3;
        else if (bpp == 32)
            pitch = pitch / 4;
        else if (bpp == 4)
            pitch = pitch * 2;
        else if (bpp == 2)
            pitch = pitch * 4;
        else if (bpp == 1)
            pitch = pitch * 8;
        else
            Assert(0); // unexpected bpp

        pde->deBitmapInfo->bmiHeader.biWidth = pitch;
	pde->deBitmapInfo->bmiHeader.biHeight = -height; // negative height for top-down DIB
	pde->deBitmapInfo->bmiHeader.biSizeImage = 0;

	Assert(pde->deBitmapInfo->bmiHeader.biBitCount == (DWORD)bpp);
    }

    //
    // if the width/height of the dc has changed we need to set
    // a new vis region
    //
    if (width != (int)pde->deWidth || height != (int)pde->deHeight)
    {
        pde->deWidth  = width;
        pde->deHeight = height;

        SetRectRgn(hVisRgn, 0, 0, width, height);
        SelectVisRgn(hdc, hVisRgn);
    }

    //
    // when the bpp changes dont forget to fix up the deFlags
    // and ReSelect all the objects so they match the new bitdepth
    //
    if (pde->deBitsPixel != bpp || ((pde->deFlags ^ flags) & FIVE6FIVE))
    {
        if (flags & FIVE6FIVE)
            pde->deFlags |= FIVE6FIVE;
        else
            pde->deFlags &= ~FIVE6FIVE;

        pde->deBitsPixel = bpp;
        ReSelectObjects(hdc, 0);
    }

    DPF5("SetDC: Details of PDE returned.");
    DPF_PDE(pde);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  AllocFlatSel
//
/////////////////////////////////////////////////////////////////////////////

#pragma optimize("", off)
UINT NEAR PASCAL AllocFlatSel()
{
    if (FlatSel != 0)
        return FlatSel;

    FlatSel = AllocSelector(SELECTOROF((LPVOID)&FlatSel));

    if (FlatSel == 0)
        return 0;

    SetSelectorBase(FlatSel, 0);

    // SetSelectorLimit(FlatSel, -1);
    _asm    mov     ax,0008h            ; DPMI set limit
    _asm    mov     bx,FlatSel
    _asm    mov     dx,-1
    _asm    mov     cx,-1
    _asm    int     31h

    return FlatSel;
}

BOOL DPMISetSelectorLimit(UINT selector, DWORD dwLimit)
{
    BOOL bRetVal=TRUE;

    // If the limit is >= 1MB, we need to make the limit a mulitple
    // of the page size or DPMISetSelectorLimit will fail.
    if( dwLimit >= 0x100000 )
        dwLimit |= 0x0FFF;

    __asm
    {
	mov  ax, 0008h
	mov  bx, selector
	mov  cx, word ptr [dwLimit+2]
	mov  dx, word ptr [dwLimit]
	int  31h
	jnc  success
	mov  bRetVal, FALSE
    success:
    }
    return bRetVal;
}
#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
//
//  InitDC
//
/////////////////////////////////////////////////////////////////////////////

BOOL NEAR PASCAL InitDC(void)
{
    HDC hdc;
    UINT rc;
    DIBENGINE FAR *pde;

    if (pdeDisplay != NULL)
    {
        return TRUE;
    }

    //
    // get the PDevice of the display we are going to need to copy
    // some info
    //
    if (pdeDisplay == NULL)
    {
        hdc = GetDC(NULL);
        rc = GetDeviceCaps(hdc, CAPS1);
        pde = GetPDevice(hdc);
        ReleaseDC(NULL, hdc);

        if (!(rc & C1_DIBENGINE) ||
            IsBadReadPtr(pde, 2) || pde->deType != 0x5250 ||
            GetProfileInt("DirectDraw", "DisableGetDC", 0))
        {
	    DPF("DD16_GetDC: GetDC is disabled");
            return FALSE;
        }

        pdeDisplay = pde;
    }

    if (FlatSel == 0)
    {
        AllocFlatSel();
    }

    if (hVisRgn == NULL)
    {
        hVisRgn = CreateRectRgn(0,0,0,0);
        SetObjectOwner(hVisRgn, hInstApp);
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  MakeDC
//
/////////////////////////////////////////////////////////////////////////////

HDC NEAR PASCAL MakeDC(DWORD bpp, BOOL f565)
{
    HDC hdc;
    HBITMAP hbm;
    DIBENGINE FAR *pde;
    DIB8 BitmapInfo = {sizeof(BITMAPINFOHEADER), 1, -1, 1, 8, BI_RGB, 0, 0, 0, 0, 0};

    if (pdeDisplay == NULL)
	return NULL;

    hdc = GetDC(NULL);

    if (bpp == 8)
    {
	BitmapInfo.ct[0] = RGB(0,0,0);
	BitmapInfo.ct[255] = RGB(255, 255, 255);
    }
    else if (bpp == 16)
    {
        if (f565)
        {
            BitmapInfo.bi.biCompression = BI_BITFIELDS;
            BitmapInfo.ct[0] = 0xf800;
            BitmapInfo.ct[1] = 0x07e0;
            BitmapInfo.ct[2] = 0x001f;
        }
    }

    BitmapInfo.bi.biBitCount = (UINT)bpp;
    hbm = CreateDIBSection(hdc, (BITMAPINFO FAR *)&BitmapInfo, DIB_RGB_COLORS, NULL, NULL, 0);

    ReleaseDC(NULL, hdc);

    if (hbm == NULL)
        return NULL;

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);

    pde = GetPDevice(hdc);

    if (IsBadReadPtr(pde, 2) || pde->deType != 0x5250)
    {
        DeleteDC(hdc);
        DeleteObject(hbm);
        return NULL;
    }

    //
    //  ok we have the following:
    //
    //      pde        --> DIBSECTION (DIBENGINE)
    //      pdeDisplay --> DISPLAY PDevice (DIBENGINE)
    //
    //  make the  DIBSECTION be compatible with the display
    //  set the following fields from the DISPLAY PDevice:
    //
    //      deBitsPixel
    //      deFlags (FIVE6FIVE, PALETTIZED, MINIDRIVER, ...)
    //      deBitmapInfo
    //

    pde->deBeginAccess      = 0;
    pde->deEndAccess        = 0;
    // deDriverReserved has three states
    // 0 - Do Not Cache a translation table
    // 1 - Translation table is same as Screen
    // >1 - Unique ID indicating state of palette (to indicate when cached translation table is out of date)
    //
    // For 24 and 32bpp, it never makes sense to cache a translation table
    // because no translation table is built for our surface as the destination.
    // Win95 Gold DIBEngine has a bug which screws up when doing 8-to-24/32 blts
    // because it incorrectly tries to cache the table. So we set deDriverReserved
    // to 0 for 24/32 bpp.
    //
    // We have been setting deDriverReserved to 1; but we probably should not
    // be doing this anymore; we should be leaving it alone which means
    // that it gets the unique number given to each dibsection.
    //
    if (bpp == 16 || bpp == 24 || bpp == 32)
	pde->deDriverReserved = 0;
    else
	pde->deDriverReserved = 1; // ID for the screen
    pde->deBitsPixel        = 0; // set SetDC will see it has changed

//  pde->deFlags  = pdeDisplay->deFlags;
//  pde->deFlags &= ~(VRAM|NOT_FRAMEBUFFER|NON64KBANK|BANKEDVRAM|BANKEDSCAN|PALETTE_XLAT);
//  pde->deFlags |= OFFSCREEN;
//  pde->deFlags |= MINIDRIVER; need to clear SELECTEDDIB

    // if the main display is banked, make the DCs banked because they
    //may be used for video memory
    //
    // ATTENTION we should only do this for video memory
    // surfaces not memory surfaces. move this code to SetDC
    // Also, make sure we set all if any banked bits are set in the driver
    // to encourage the DIBENG to avoid screen to screen blts (which are apparently buggy).
    //
    if(pdeDisplay->deFlags & (NON64KBANK|BANKEDVRAM|BANKEDSCAN))
    {
	pde->deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }

    // This bit should only ever be used in conjunction with VRAM
    // setting it can confuses drivers (such as the 765) into thinking that
    // the surface is in VRAM when it is not.
    //    pde->deFlags |= OFFSCREEN;
    pde->deFlags |= BUSY;

    SetObjectOwner(hdc, hInstApp);
    SetObjectOwner(hbm, hInstApp);

    return hdc;
}

/////////////////////////////////////////////////////////////////////////////
//
//  FreeDC
//
/////////////////////////////////////////////////////////////////////////////

BOOL NEAR PASCAL FreeDC(HDC hdc)
{
    if (hdc)
    {
        HBITMAP hbm;
        hbm = SelectObject(hdc, StockBitmap());
        DeleteDC(hdc);
        DeleteObject(hbm);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_MakeObjectPrivate
//	This function makes sure that no DC that we need is
//  freed until we want it to be freed.
//
/////////////////////////////////////////////////////////////////////////////

WORD DDAPI DD16_MakeObjectPrivate(HDC hdc, BOOL fPrivate)
{
    BOOL fState;

    // Assert that parameter is good
    Assert(IsGDIObject(hdc) == OBJ_DC);

    fState = MakeObjectPrivate(hdc, fPrivate);

    if (fState)
    {
	return 1;
    }
    else
    {
	return 0;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_GetDC
//
/////////////////////////////////////////////////////////////////////////////

HDC DDAPI DD16_GetDC(HDC hdcDevice, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette)
{
    HDC hdc;
    BOOL f565;
    // Assert that parameter is good
    Assert(IsGDIObject(hdcDevice) == OBJ_DC);

    // must be a RGB format surface!
    //
    if (!(pddsd->ddpfPixelFormat.dwFlags & DDPF_RGB))
    {
        DPF("DD16_GetDC: must be a RGB surface");
        return NULL;
    }

    //
    // if the surface is 8bpp the display must also be 8bpp because we
    // share the color table. (Multi-mon: make sure we check the right display.)
    //
    // If a palette is explicitly passed in, then we won't need
    // the device's pde.
    //
    if( pddsd->ddpfPixelFormat.dwRGBBitCount == 8 && lpPalette == NULL )
    {
	DIBENGINE FAR *pdeDevice;
	if( hdcDevice )
	    pdeDevice = GetPDevice( hdcDevice );
	else
	    pdeDevice = pdeDisplay;

	// 3DFx isn't a real device DC
	if (pdeDevice->deType != 0x5250)
	{
	    DPF("Can't get DC on an 8bpp surface without a palette for this device");
	    return NULL;
	}

	if (pdeDevice->deBitsPixel != 8 )
	{
	    DPF("Can't get DC on an 8bpp surface without a palette when primary is not at 8bpp");
	    return NULL;
	}

    }

#ifdef DEBUG
    //
    // we assume the pixel format is not wacky
    //
    if (pddsd->ddpfPixelFormat.dwRGBBitCount == 8 )
    {
        /*
         * The Permedia driver actually reports bit masks for their 8bit palettized mode, so
         * we shouldn't assert here (as we used to) if any masks are non-zero.
         */
        if ( ( pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) ==0 )
        {
            DPF("Getting a DC on a non-palettized 8bit surface!");
            Assert(0);
        }
    }
    else if (   pddsd->ddpfPixelFormat.dwRGBBitCount == 4 ||
                pddsd->ddpfPixelFormat.dwRGBBitCount == 1)
    {
        /*
         * Assume these are OK
         */
    }
    else if (pddsd->ddpfPixelFormat.dwRGBBitCount == 16)
    {
        if (pddsd->ddpfPixelFormat.dwRBitMask == 0xf800 &&
            pddsd->ddpfPixelFormat.dwGBitMask == 0x07e0 &&
            pddsd->ddpfPixelFormat.dwBBitMask == 0x001f)
        {
            // 565
        }
        else if (
            pddsd->ddpfPixelFormat.dwRBitMask == 0x7c00 &&
            pddsd->ddpfPixelFormat.dwGBitMask == 0x03e0 &&
            pddsd->ddpfPixelFormat.dwBBitMask == 0x001f)
        {
            // 555
        }
        else
        {
            DPF("DD16_GetDC: not 555 or 565");
            Assert(0);
        }
    }
    else if (pddsd->ddpfPixelFormat.dwRGBBitCount == 24 )
    {
        if (pddsd->ddpfPixelFormat.dwBBitMask == 0x0000FF &&
            pddsd->ddpfPixelFormat.dwGBitMask == 0x00FF00 &&
            pddsd->ddpfPixelFormat.dwRBitMask == 0xFF0000)
        {
            // 888 BGR
        }
        else
        {
            DPF("DD16_GetDC: invalid bit masks");
            Assert(0);
        }
    }
    else if(pddsd->ddpfPixelFormat.dwRGBBitCount == 32)
    {
	if (pddsd->ddpfPixelFormat.dwRBitMask == 0xFF0000 &&
		 pddsd->ddpfPixelFormat.dwGBitMask == 0x00FF00 &&
		 pddsd->ddpfPixelFormat.dwBBitMask == 0x0000FF)

        {
	    // 888 RGB -- standard 32-bit format
	}
        else
        {
            DPF("DD16_GetDC: invalid bit masks");
            Assert(0);
        }
    }
    else
    {
        DPF("DD16_GetDC: invalid bit depth");
        Assert(0);

    }
#endif

    // is this a 565?
    f565 = FALSE;
    if (pddsd->ddpfPixelFormat.dwRGBBitCount == 16 &&
            pddsd->ddpfPixelFormat.dwRBitMask == 0xf800)
        f565 = TRUE;

    //
    // use the cacheDC if it is free, else make a new one.
    //

    if( in_use || ( pddsd->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
    {
        hdc = MakeDC( pddsd->ddpfPixelFormat.dwRGBBitCount, f565 );
    }
    else
    {
        if (cacheBPP != pddsd->ddpfPixelFormat.dwRGBBitCount || bCache565 != f565 )
	{
	    FreeDC(hdcCache);
            hdcCache = MakeDC(pddsd->ddpfPixelFormat.dwRGBBitCount, f565);
	    cacheBPP = pddsd->ddpfPixelFormat.dwRGBBitCount;
            bCache565 = f565;
	}

        hdc = hdcCache;
        in_use++;
    }

    //
    // now set the right bits pointer.
    //
    if (hdc)
    {
	BOOL fSuccess;
	// Set the DC with the right information based
	// on the surface. If a palette is passed in
	// then set that palette into the DC.
	fSuccess = SetDC(hdc, hdcDevice, pddsd, lpPalette);

	if( !fSuccess )
	{
	    DPF("SetDC Failed");

	    // We need to clean up; but we
	    // can't call ReleaseDC because our dc is only
	    // half-cooked.
	    if (hdc == hdcCache)
	    {
		Assert(in_use == 1);
		in_use = 0;
	    }
	    else
	    {
		FreeDC(hdc);
	    }
	    return NULL;
	}
    }

    if (hdc && hdc == hdcCache)
    {
        save_level = SaveDC(hdc);
    }

    return hdc;
}

/////////////////////////////////////////////////////////////////////////////
//
// DD16_ReleaseDC
//
/////////////////////////////////////////////////////////////////////////////

void DDAPI DD16_ReleaseDC(HDC hdc)
{
    if (hdc == NULL)
        return;

    if (hdc == hdcCache)
    {
        RestoreDC(hdc, save_level);
	SetDC(hdc, NULL, NULL, NULL);
        Assert(in_use == 1);
        in_use = 0;
    }
    else
    {
	SetDC(hdc, NULL, NULL, NULL);
        FreeDC(hdc);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_SafeMode
//
//  dynamic safe mode
//
/////////////////////////////////////////////////////////////////////////////

BOOL DDAPI DD16_SafeMode(HDC hdc, BOOL fSafeMode)
{
    extern void PatchDisplay(int oem, BOOL patch);   // dynares.c

    int i;

    for (i=0; i<35; i++)
    {
        PatchDisplay(i, fSafeMode);
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_Exclude
//  DD16_Unexclude
//
//  call the exclude or unexclude callbacks in the display driver
//
/////////////////////////////////////////////////////////////////////////////

typedef void (FAR PASCAL *BEGINACCESSPROC)(LPVOID lpPDevice, int left, int top, int right, int bottom, WORD flags);
typedef void (FAR PASCAL *ENDACCESSPROC)(LPVOID lpPDevice, WORD flags);

void DDAPI DD16_Exclude(DWORD dwPDevice, RECTL FAR *prcl)
{
    DIBENGINE FAR *pde = (DIBENGINE FAR *)dwPDevice;

    Assert(pde && pde->deType == 0x5250);
    Assert(prcl != NULL);
    Assert(pde->deFlags & BUSY);

    if (pde->deBeginAccess)
    {
        BEGINACCESSPROC OEMBeginAccess = (BEGINACCESSPROC)pde->deBeginAccess;

        //
        //  when DirectDraw calls us it has already taken the BUSY bit
        //  but BUSY needs to be clear for the cursor to be excluded.
        //  so release the BUSY bit while we call the driver, this is
        //  a ok thing to do because we have the Win16Lock.
        //
        pde->deFlags &= ~BUSY;
        OEMBeginAccess(pde, (int)prcl->left, (int)prcl->top,
            (int)prcl->right, (int)prcl->bottom, CURSOREXCLUDE);
        pde->deFlags |= BUSY;
    }
}

void DDAPI DD16_Unexclude(DWORD dwPDevice)
{
    DIBENGINE FAR *pde = (DIBENGINE FAR *)dwPDevice;

    Assert(pde && pde->deType == 0x5250);

    if (pde->deEndAccess)
    {
        ENDACCESSPROC OEMEndAccess = (ENDACCESSPROC)pde->deEndAccess;
        OEMEndAccess(pde, CURSOREXCLUDE);
    }
}

/*
 * DD16_AttemptGamma
 *
 * Total HACK!  The GetDeviceGammaRamp call can attempt to call a NULL
 * entry.  Since we can't fix Win95, instead we look at the entry that
 * it will call and suggest that they don't call it if it's NULL.
 */
BOOL DDAPI DD16_AttemptGamma( HDC hdc )
{
    WORD wLDevice;
    WORD FAR *pw;
    UINT hGDI = GetGdiDS();

    wLDevice = GetW(hdc, 0x34);
    if( wLDevice != 0 )
    {
        pw = MAKELP(hGDI, wLDevice);
        if (!IsBadReadPtr(pw, 0x80))
        {
            pw = MAKELP(hGDI, wLDevice + 0x7C);
            if (*pw != NULL)
            {
                return TRUE;
            }
        }
    }
    return FALSE;

} /* DD16_AttemptGamma */

/*
 * DD16_IsDeviceBusy
 *
 * Determines if the device represented by the HDC is
 * busy or not.
 */
BOOL DDAPI DD16_IsDeviceBusy( HDC hdc )
{
    DIBENGINE FAR *pde;

    pde = GetPDevice(hdc);
    if(pde == NULL)
        return FALSE;

    Assert(pde->deType==0x5250);
    return pde->deFlags & BUSY;
} /* DD16_IsDeviceBusy */

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_Stretch
//
//  call the DIBENG to do a stretch.
//
/////////////////////////////////////////////////////////////////////////////

extern int FAR PASCAL DIB_Stretch(
    DIBENGINE FAR *dst, int, int, int, int,
    DIBENGINE FAR *src, int, int, int, int,
    DWORD Rop, LPVOID lpPBrush, LPVOID lpDrawMode, LPRECT lpClip);

extern int FAR PASCAL DIB_BitBlt(
    DIBENGINE FAR *dst, int xD, int yD,
    DIBENGINE FAR *src, int xS, int yS, int w, int h,
    DWORD Rop, LPVOID lpPBrush, LPVOID lpDrawMode);

typedef struct {
    short int	  Rop2;
    short int	  bkMode;
    unsigned long int bkColor;
    unsigned long int TextColor;
    short int	  TBreakExtra;
    short int	  BreakExtra;
    short int	  BreakErr;
    short int	  BreakRem;
    short int	  BreakCount;
    short int	  CharExtra;

    unsigned long int LbkColor;
    unsigned long int LTextColor;
    DWORD		  ICMCXform;
    short		  StretchBltMode;
    DWORD		  eMiterLimit;
} DRAWMODE;

int DDAPI DD16_Stretch(DWORD DstPtr, int DstPitch, UINT DstBPP, int DstX, int DstY, int DstDX, int DstDY,
                       DWORD SrcPtr, int SrcPitch, UINT SrcBPP, int SrcX, int SrcY, int SrcDX, int SrcDY)//, long Rop3)

{
    DIBENGINE   src;
    DIBENGINE	dst;
    DRAWMODE    dm;
    RECT        rc;
    static DIB8	bmiStretch = {sizeof(BITMAPINFOHEADER), 1, -1, 1, 8, BI_RGB, 0, 0, 0, 0, 0};

    //
    //	make sure we have a flat sel
    //
    if (FlatSel == 0)
        return -1;

    // Set the bitdepth on the bitmapinfo
    Assert( DstBPP == SrcBPP );
    bmiStretch.bi.biBitCount = DstBPP;

    //
    //	setup source DIBENG
    //
    if (SrcPtr)
    {
        src.deType          = TYPE_DIBENG;
        src.deWidth         = 10000;
        src.deHeight        = 10000;
        src.deWidthBytes    = SrcPitch;
        src.dePlanes        = 1;
        src.deBitsPixel     = SrcBPP;
        src.deReserved1     = 0;
        src.deDeltaScan     = SrcPitch;
        src.delpPDevice     = NULL;
        src.deBitsOffset    = SrcPtr;
        src.deBitsSelector  = FlatSel;
        src.deFlags         = SELECTEDDIB;
        src.deVersion       = VER_DIBENG;
        src.deBitmapInfo    = (BITMAPINFO *)&bmiStretch;
        src.deBeginAccess   = 0;
        src.deEndAccess     = 0;
        src.deDriverReserved= 0;
    }

    //
    //	setup dest DIBENG
    //
    dst.deType		 = TYPE_DIBENG;
    dst.deWidth          = 10000;
    dst.deHeight         = 10000;
    dst.deWidthBytes	 = DstPitch;
    dst.dePlanes	 = 1;
    dst.deBitsPixel	 = DstBPP;
    dst.deReserved1	 = 0;
    dst.deDeltaScan	 = DstPitch;
    dst.delpPDevice	 = NULL;
    dst.deBitsOffset	 = DstPtr;
    dst.deBitsSelector	 = FlatSel;
    dst.deFlags 	 = SELECTEDDIB;
    dst.deVersion	 = VER_DIBENG;
    dst.deBitmapInfo     = (BITMAPINFO *)&bmiStretch;
    dst.deBeginAccess	 = 0;
    dst.deEndAccess	 = 0;
    dst.deDriverReserved = 0;


    //
    //  this memory *might* be in VRAM so setup things to
    //  work right.
    //
    //  ATTENTION we should only do this for video memory
    //  surfaces not memory surfaces.
    //  If any are set, set all the bits to force the DIBENG to
    //  not do a screen to screen blit (which apparently has a bug).
    //
    if (pdeDisplay && (pdeDisplay->deFlags & (NON64KBANK|BANKEDVRAM|BANKEDSCAN)))
    {
        dst.deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
        src.deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }

    //
    //	now call the DIBENG
    //

    if(SrcPtr == (DWORD)NULL)
    {
        DPF("Blitting from Primary with HDC unsupported!");
        return FALSE;
    }
    else if ((DstDX == SrcDX) && (DstDY == SrcDY))
    {
	    //DPF("Calling DIB_BitBlt");
	    // NOTE: If the source and destination video memory pointers
	    // are the same then we simply pass the destination
	    // DIBENG for the source as this is how the blt code spots
	    // the fact that the source and destination surfaces are
	    // the same and so takes the necessary action to handle
	    // overlapping surfaces
	    #ifdef DEBUG
	    	if( DstPtr == SrcPtr)
		{
		    Assert(DstPitch == SrcPitch);
		    Assert(DstBPP   == SrcBPP);
		}
	    #endif
	    return DIB_BitBlt(&dst, DstX, DstY,
			      (DstPtr == SrcPtr) ? &dst : &src,
			      SrcX, SrcY, SrcDX, SrcDY, SRCCOPY, // Rop3,
			      NULL, &dm);
    }
    else
    {
        rc.left = DstX;
	    rc.top = DstY;
	    rc.right = DstX + DstDX;
	    rc.bottom = DstY + DstDY;

	    dm.StretchBltMode = STRETCH_DELETESCANS;

/*        DPF("Calling DIB_StretchBlt with:");
        DPF("\tdst.deType = 0x%x(%s)",dst.deType,(dst.deType == TYPE_DIBENG ? "TYPE_DIBENG" : "**UNKNOWN**"));
        DPF("\tdst.deWidth = %d",dst.deWidth);
        DPF("\tdst.deHeight = %d",dst.deHeight);
        DPF("\tdst.deWidthBytes = %d",dst.deWidthBytes);
        DPF("\tdst.dePlanes = %d",dst.dePlanes);
        DPF("\tdst.deBitsPixel = %d",dst.deBitsPixel);
        DPF("\tdst.deReserved1 = %ld",dst.deReserved1);
        DPF("\tdst.deDeltaScan = %ld",dst.deDeltaScan);
        DPF("\tdst.delpPDevice = 0x%x",dst.delpPDevice);
        DPF("\tdst.deBitsOffset = 0x%x",dst.deBitsOffset);
        DPF("\tdst.deBitsSelector = 0x%x",dst.deBitsSelector);
        DPF("\tdst.deFlags = 0x%x(%s)",dst.deFlags,(dst.deFlags == SELECTEDDIB ? "SELECTEDDIB" : "**UNKNOWN**"));
        DPF("\tdst.deVersion = %d(%s)",dst.deVersion,(dst.deVersion == VER_DIBENG ? "VER_DIBENG" : "**UNKNOWN**"));

        DPF("\t\tdst.deBitmapInfo->bmiHeader.biSize = %ld",dst.deBitmapInfo->bmiHeader.biSize);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biWidth = %ld",dst.deBitmapInfo->bmiHeader.biWidth);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biHeight = %ld",dst.deBitmapInfo->bmiHeader.biHeight);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biPlanes = %d",dst.deBitmapInfo->bmiHeader.biPlanes);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biBitCount = %d",dst.deBitmapInfo->bmiHeader.biBitCount);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biCompression = 0x%x(%s)",dst.deBitmapInfo->bmiHeader.biCompression,((dst.deBitmapInfo->bmiHeader.biCompression == BI_RGB) ? "BI_RGB" : "**UNKNOWN**"));
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biSizeImage = %ld",dst.deBitmapInfo->bmiHeader.biSizeImage);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biXPelsPerMeter = %ld",dst.deBitmapInfo->bmiHeader.biXPelsPerMeter);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biYPelsPerMeter = %ld",dst.deBitmapInfo->bmiHeader.biYPelsPerMeter);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biClrUsed = %ld",dst.deBitmapInfo->bmiHeader.biClrUsed);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biClrImportant = %ld",dst.deBitmapInfo->bmiHeader.biClrImportant);

        DPF("\tdst.deBeginAccess = 0x%x",dst.deBeginAccess);
        DPF("\tdst.deEndAccess = 0x%x",dst.deEndAccess);
        DPF("\tdst.deDriverReserved = 0x%x",dst.deDriverReserved);

        DPF("");
        DPF("\tDstX  = %d",DstX);
        DPF("\tDstY  = %d",DstY);
        DPF("\tDstDX = %d",DstDX);
        DPF("\tDstDY = %d",DstDY);

        DPF("");

        DPF("\tsrc.deType = 0x%x(%s)",src.deType,(src.deType == TYPE_DIBENG ? "TYPE_DIBENG" : "**UNKNOWN**"));
        DPF("\tsrc.deWidth = %d",src.deWidth);
        DPF("\tsrc.deHeight = %d",src.deHeight);
        DPF("\tsrc.deWidthBytes = %d",src.deWidthBytes);
        DPF("\tsrc.dePlanes = %d",src.dePlanes);
        DPF("\tsrc.deBitsPixel = %d",src.deBitsPixel);
        DPF("\tsrc.deReserved1 = %ld",src.deReserved1);
        DPF("\tsrc.deDeltaScan = %ld",src.deDeltaScan);
        DPF("\tsrc.delpPDevice = 0x%x",src.delpPDevice);
        DPF("\tsrc.deBitsOffset = 0x%x",src.deBitsOffset);
        DPF("\tsrc.deBitsSelector = 0x%x",src.deBitsSelector);
        DPF("\tsrc.deFlags = 0x%x(%s)",src.deFlags,(src.deFlags == SELECTEDDIB ? "SELECTEDDIB" : "**UNKNOWN**"));
        DPF("\tsrc.deVersion = %d(%s)",src.deVersion,(src.deVersion == VER_DIBENG ? "VER_DIBENG" : "**UNKNOWN**"));

        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biSize = %ld",src.deBitmapInfo->bmiHeader.biSize);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biWidth = %ld",src.deBitmapInfo->bmiHeader.biWidth);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biHeight = %ld",src.deBitmapInfo->bmiHeader.biHeight);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biPlanes = %d",src.deBitmapInfo->bmiHeader.biPlanes);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biBitCount = %d",src.deBitmapInfo->bmiHeader.biBitCount);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biCompression = 0x%x(%s)",src.deBitmapInfo->bmiHeader.biCompression,((src.deBitmapInfo->bmiHeader.biCompression == BI_RGB) ? "BI_RGB" : "**UNKNOWN**"));
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biSizeImage = %ld",src.deBitmapInfo->bmiHeader.biSizeImage);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biXPelsPerMeter = %ld",src.deBitmapInfo->bmiHeader.biXPelsPerMeter);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biYPelsPerMeter = %ld",src.deBitmapInfo->bmiHeader.biYPelsPerMeter);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biClrUsed = %ld",src.deBitmapInfo->bmiHeader.biClrUsed);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biClrImportant = %ld",src.deBitmapInfo->bmiHeader.biClrImportant);

        DPF("\tsrc.deBeginAccess = 0x%x",src.deBeginAccess);
        DPF("\tsrc.deEndAccess = 0x%x",src.deEndAccess);
        DPF("\tsrc.deDriverReserved = 0x%x",src.deDriverReserved);

        DPF("");
        DPF("\tSrcX  = %d",SrcX);
        DPF("\tSrcY  = %d",SrcY);
        DPF("\tSrcDX = %d",SrcDX);
        DPF("\tSrcDY = %d",SrcDY);

        DPF("");

        DPF("\tdm.StretchBltMode = STRETCH_DELETESCANS");

        DPF("");

        DPF("\trc.left  = %d",rc.left);
        DPF("\trc.top  = %d",rc.top);
        DPF("\trc.right = %d",rc.right);
        DPF("\trc.bottom = %d",rc.bottom);

        DPF("");
*/

        return DIB_Stretch(&dst, DstX, DstY, DstDX, DstDY,
						    &src, SrcX, SrcY, SrcDX, SrcDY, SRCCOPY, // Rop3,
						    NULL, &dm, &rc);
    }
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void GdiHelpCleanUp()
{
    if (FlatSel)
    {
        SetSelectorLimit(FlatSel, 0);
        FreeSelector(FlatSel);
        FlatSel = 0;
    }

    if (hdcCache)
    {
        FreeDC(hdcCache);
        hdcCache = NULL;
    }

    if (hVisRgn)
    {
        DeleteObject(hVisRgn);
        hVisRgn = NULL;
    }

    if (pdeDisplay)
    {
        pdeDisplay = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL GdiHelpInit()
{
    InitDC();
    return FlatSel!=NULL && pdeDisplay!=NULL;
}

#endif // DirectDraw
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\libmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       libmain.c
 *  Content:	entry points in the DLL
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   03-jul-95	craige	export instance handle
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

// in gdihelp.c
extern void GdiHelpCleanUp(void);
extern BOOL GdiHelpInit(void);

// in modex.c
extern UINT ModeX_Width;

extern WORD hselSecondary;

HINSTANCE	hInstApp;
HGLOBAL         hAlloc = 0;

int FAR PASCAL LibMain(HINSTANCE hInst, WORD wHeapSize, LPCSTR lpCmdLine)
{
    hInstApp = hInst;
    pWin16Lock = GetWin16Lock();
    GdiHelpInit();
    DPFINIT();
    hAlloc = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 65536); 
    hselSecondary = (WORD) hAlloc;
    if( hselSecondary )
    {
        LocalInit(hselSecondary, 16, 65536-4);  // Keep DWORD aligned
    }

    return 1;
}

BOOL FAR PASCAL _loadds WEP( WORD wParm )
{
    DPF( 1, "WEP" );

    //
    // clean up DCI
    //
    if( wFlatSel )
    {
        VFDEndLinearAccess();
        SetSelLimit( wFlatSel, 0 );
        FreeSelector( wFlatSel );
        wFlatSel = 0;
    }

    if( hAlloc )
    {
        GlobalFree( hAlloc );
    }

    //
    // let gdihelp.c cleaup global objects
    //
    GdiHelpCleanUp();

    //
    // if we are still in ModeX, leave now
    //
    if( ModeX_Width )
    {
        ModeX_RestoreMode();
    }

    return 1;
}

extern BOOL FAR PASCAL thk3216_ThunkConnect16( LPSTR pszDll16, LPSTR pszDll32, WORD  hInst, DWORD dwReason);
extern BOOL FAR PASCAL thk1632_ThunkConnect16( LPSTR pszDll16, LPSTR pszDll32, WORD  hInst, DWORD dwReason);

#define DLL_PROCESS_ATTACH 1    
#define DLL_THREAD_ATTACH  2    
#define DLL_THREAD_DETACH  3    
#define DLL_PROCESS_DETACH 0

static char __based(__segname("LIBMAIN_TEXT"))  szDll16[] = DDHAL_DRIVER_DLLNAME;
static char __based(__segname("LIBMAIN_TEXT"))  szDll32[] = DDHAL_APP_DLLNAME;

BOOL FAR PASCAL __export DllEntryPoint(
		DWORD dwReason,
		WORD  hInst,
		WORD  wDS,
		WORD  wHeapSize,
		DWORD dwReserved1,
		WORD  wReserved2)
{
    DPF( 1, "DllEntryPoint: dwReason=%ld, hInst=%04x, dwReserved1=%08lx, wReserved2=%04x",
                dwReason, hInst, wDS, dwReserved1, wReserved2 );

    if( !thk3216_ThunkConnect16( szDll16, szDll32, hInst, dwReason))
    {
        return FALSE;
    }
    if( !thk1632_ThunkConnect16( szDll16, szDll32, hInst, dwReason))
    {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\makefile.inc ===
BuildType=retail
!if defined(NTDEBUG) && "$(NTDEBUG)" != "ntsdnodebug"
BuildType=debug
!endif


$(O)\$(TARGETNAME).dll: 
!ifdef LINKONLY
    @echo LINKONLY does nothing
!else
	@nmake -nologo -f DEFAULT.MK  DEBUG="$(BuildType)" PBIN=$(O)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:	allocates memory; uses global blocks and sub-allocates
 *		out of those using LocalAlloc
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-dec-94	craige	initial implementation
 *   12-jan-95	craige	use clib as an option
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

#if 0
#define USE_CLIB

#ifdef USE_CLIB
#include <malloc.h>
#else
#define GLOBAL_BLOCK_SIZE	32768

typedef struct _HEAPLIST
{
    struct _HEAPLIST	FAR *lpLink;
    WORD		wSel;
    GLOBALHANDLE	hMem;
} HEAPLIST, FAR *LPHEAPLIST;

static LPHEAPLIST	lphlHeap;

/*
 * tryAlloc - try to allocate from a heap
 */
static LPVOID tryAlloc( WORD sel, WORD size )
{
    void	NEAR *ptr;

    _asm push ds
    _asm mov ax, sel
    _asm mov ds, ax
    ptr = (void NEAR *) LocalAlloc( LPTR, size );
    _asm pop ds
    if( ptr == (void NEAR *) NULL )
    {
	return (void FAR *) NULL;
    }
    return MAKELP( sel, ptr );

} /* tryAlloc */
#endif

#ifdef DEBUG
LONG	lAllocCount;
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID MemAlloc( UINT size )
{
    LPVOID		lptr;
    #ifndef USE_CLIB
	LPHEAPLIST	curr;
	GLOBALHANDLE	gh;
	LPVOID		lpnew;
	WORD		sel;
    #endif

    #ifdef DEBUG
    	lAllocCount++;
    #endif

    #ifdef USE_CLIB
	lptr = _fmalloc( size );
	if( lptr != NULL )
	{
	    _fmemset( lptr, 0, size );
	}
	else
	{
	    DPF( 1, "Alloc of size %u FAILED!", size );
	}
	return lptr;
    #else
    
	/*
	 * run our current list of GlobalAlloc'ed chunks
	 */
	curr = lphlHeap;
	while( curr != NULL )
	{
	    lptr = tryAlloc( curr->wSel, size );
	    if( lptr != (LPVOID) NULL )
	    {
		return lptr;
	    }
	    curr = curr->lpLink;
	}
    
	/*
	 * no luck, allocate a new global chunk
	 */
	gh = GlobalAlloc( GMEM_SHARE | GMEM_MOVEABLE, GLOBAL_BLOCK_SIZE );
	if( gh == NULL )
	{
	    return NULL;
	}
	lpnew = GlobalLock( gh );
	if( lpnew == NULL )
	{
	    GlobalFree( gh );
	    return NULL;
	}
    
	/*
	 * set up a local heap in this new global chunk
	 */
	sel = SELECTOROF( lpnew );
	if( !LocalInit( sel, 0, GLOBAL_BLOCK_SIZE-1 ) )
	{
	    GlobalUnlock( gh );
	    GlobalFree( gh );
	    return NULL;
	}
	/*
	 * chain this new heap into our list
	 */
	curr = tryAlloc( sel, sizeof( HEAPLIST ) );
	if( curr == NULL )
	{
	    return NULL;
	}
	curr->wSel = sel;
	curr->hMem = gh;
	curr->lpLink = lphlHeap;
	lphlHeap = curr;
    
	/*
	 * go allocate the original request
	 */
	return tryAlloc( sel, size );
    #endif

} /* MemAlloc */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    #ifdef USE_CLIB
	_ffree( lptr );
    #else
	WORD	sel;
    
	if( lptr != (LPVOID) NULL )
	{
	    sel = SELECTOROF( lptr );
	    _asm push ds
	    _asm mov ax,sel
	    _asm mov ds,ax
	    LocalFree( OFFSETOF( lptr ) );
	    _asm pop ds
	}
    #endif
    #ifdef DEBUG
    	if( lptr != NULL )
	{
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
    #endif

} /* MemFree */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    #ifndef USE_CLIB
	lphlHeap = NULL;
    #endif
    #ifdef DEBUG
    	lAllocCount = 0;
    #endif
    return TRUE;

} /* MemInit */

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    #ifdef DEBUG
    	if( lAllocCount != 0 )
	{
	    DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	}
    #endif
    #ifndef USE_CLIB
	LPHEAPLIST		curr;
	LPHEAPLIST		last;
	GLOBALHANDLE	gh;
    
	curr = lphlHeap;
	while( curr != NULL )
	{
	    gh = curr->hMem;
	    last = curr->lpLink;
    //	    GlobalUnfix( gh );
	    GlobalUnlock( gh );
	    GlobalFree( gh );
	    curr = last;
	}
	lphlHeap = NULL;
    #endif
} /* MemFini */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\modenot.c ===
//=============================================================================
//
//  Copyright (C) 1997 Microsoft Corporation. All rights reserved.
//
//     File:  modenot.c
//  Content:  16-bit display mode change notification handling
//
//  Date        By        Reason
//  ----------  --------  -----------------------------------------------------
//  08/27/1997  johnstep  Initial implementation
//
//=============================================================================

#include "ddraw16.h"

#define MODECHANGE_BEGIN    1
#define MODECHANGE_END      2
#define MODECHANGE_ENABLE   3
#define MODECHANGE_DISABLE  4

//=============================================================================
//
//  Function: ModeChangeNotify
//
//  This exported function is called by name by User for display mode changes,
//  including enabling and disabling the display.
//
//  Parameters:
//
//      UINT code [IN] - one of the following values:
//          MODECHANGE_BEGIN
//          MODECHANGE_END
//          MODECHANGE_ENABLE
//          MODECHANGE_DISABLE
//
//      LPDEVMODE pdm [IN] - includes the name of the display device
//
//      DWORD flags [IN] - CDS flags
//
//  Return:
//
//      FALSE to prevent display settings to change
//
//=============================================================================

BOOL WINAPI _loadds ModeChangeNotify(UINT code, LPDEVMODE pdm, DWORD flags)
{
    extern BOOL DDAPI DD32_HandleExternalModeChange(LPDEVMODE pdm);

    DPF(9, "ModeChangeNotify: %d (Device: %s)", code, pdm->dmDeviceName);
    
    switch (code)
    {
    case MODECHANGE_BEGIN:
    case MODECHANGE_DISABLE:
        return DD32_HandleExternalModeChange(pdm);
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\mvgaxx.h ===
//
// Stuff from MVGAXX.asm
//

#define MODE_320x200x8          0
#define MODE_320x400x8          1
#define MODE_360x480x8          2
#define MODE_320x480x8          3
#define MODE_320x240x8          4
#define MODE_160x120x8          5
#define MODE_320x240x16         6

extern short pascal ScreenSel;

extern DWORD NEAR PASCAL SetMode(int mode);
extern void  NEAR PASCAL RestoreMode(void);
extern void  NEAR PASCAL FlipPage(void);
extern BOOL  NEAR PASCAL SetZoom(int);

extern void  NEAR PASCAL RleBlt(int x, int y, char far *pBits);
extern void  NEAR PASCAL PixBlt(int x, int y, int xExt, int yExt,char far *pBits, long offset, int WidthBytes);

extern void  NEAR PASCAL SetPalette(int start, int count, void far *pPal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\modex.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	modex.c
 *  Content:	16-bit DirectDraw HAL
 *		These routines redirect the callbacks from the 32-bit
 *		side to the driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-aug-95	craige	initial implementation (from dispdib)
 *   10-sep-95  toddla  set/clear the BUSY bit for poor drivers
 *   21-sep-95	craige	bug 1215: use Death/Resurrection for uncertified
 *			drivers only
 *   15-dec-96  jeffno  added more modex modes
 *
 ***************************************************************************/

#include "ddraw16.h"

// in gdihelp.c
extern BOOL bInOurSetMode;
extern UINT FlatSel;
extern DIBENGINE FAR *pdeDisplay;

// in DIBENG
extern void FAR PASCAL DIB_SetPaletteExt(UINT, UINT, LPVOID, DIBENGINE FAR *);

UINT ModeX_Width;
UINT ModeX_Height;

/*
 * IsVGA
 */
BOOL IsVGA()
{
    BOOL f = FALSE;

    _asm
    {
        mov     ax,1A00h                ; Read display combination code
        int     10h
        cmp     al,1Ah                  ; Is function supported?
        jne     NoDisplaySupport

    ; BL should contain active display code, however, on some VGA cards this
    ; call will return the active display in BH.  If BL is zero, BH is assumed to
    ; contain the active display.  This assumes that the only display attached is
    ; then the active display.

        or      bl,bl                   ; Is there an active display?
        jnz     CheckActiveDisplay      ; Yes, then continue on normaly.
        mov     bl,bh                   ; No, then move bh to bl.
        or      bl,bl                   ; Is anything supported?
        jz      NoDisplaySupport

    CheckActiveDisplay:
        cmp     bl,07h                  ; VGA with monochrome display
        je      SetMCGAPresent
        cmp     bl,08h                  ; VGA with color display
        je      SetMCGAPresent
        cmp     bl,0Bh                  ; MCGA with monochrome display
        je      SetMCGAPresent
        cmp     bl,0Ch                  ; MCGA with color display
        jne     NoDisplaySupport

    SetMCGAPresent:
        inc     f                       ; _bMCGAPresent = TRUE

    NoDisplaySupport:

    }

    return f;
}

/*
 * ModeX_Flip
 */
extern WORD ScreenDisplay;
LONG DDAPI ModeX_Flip( DWORD lpBackBuffer )
{
    if( ModeX_Width == 0 )
    {
        DPF(1, "ModeX_Flip: called while not in ModeX!");
        DEBUG_BREAK();
        return DDERR_GENERIC;
    }

    /* PixBlt requires:
     *  -start aligned on DWORD
     *  -width a multiple of 32 OR mutliple of 32 with 8 remaining (i.e. 360x)
     */
    DDASSERT( (ModeX_Width & 0x3)==0 );
    DDASSERT( ((ModeX_Width & 0x1f)==0) || ((ModeX_Width & 0x1f)==8) );
    PixBlt(ModeX_Width,ModeX_Height,MAKELP(FlatSel, 0),lpBackBuffer,ModeX_Width);
    /*
     * We only do the multiple buffering if two buffers will fit in the VGA frame
     * buffer. If not, then it's blt to the visible primary on every Flip.
     * We implement this by not calling FlipPage so our internal idea of which
     * physical page is the back buffer remains the same (i.e. pointing to the
     * front buffer).
     * FlipPage is actually very clever and will refuse to flip if two pages
     * exceed 64k. Since this is setdisplaymode, something of an essential OS
     * service, I'm going to be extra paranoid and do the check here as well.
     * We are working with words, so group operations to avoid overflow.
     * Note that FlipPage is smart enough to do triple buffering if a page is less
     * than 64k/3 (as it is in the x175 nodes(. If we ever implement a scheme 
     * whereby the app can specify dirty subrects to copy (either on flip or by blt) 
     * we'll have to let them know the difference between single-, double- and 
     * triple-buffering or else their idea of what's on the primary could get out of
     * sync.
     */
    if ( (ModeX_Width/4)*ModeX_Height < 32768 ) /* i.e two pages would be < 64k */
    {
        DPF(5,"ModeX_Flip called, display offset is %08x",ScreenDisplay);
        FlipPage();
    }

    return DD_OK;

} /* ModeX_Blt */

#define MODEX_HACK_ENTRY		"AlternateLowResInit"

static BOOL	bCertified;

/*
 * useDeathResurrection
 */
static BOOL useDeathResurrection( void )
{
    int	rc;
    /*
     * is a value specified? if not, use certified bit
     */
    rc =  GetProfileInt( "DirectDraw", MODEX_HACK_ENTRY, -99 );
    if( rc == -99 )
    {
	DPF( 3, "useDeathResurrection = %d", !bCertified );
	return !bCertified;
    }

    /*
     * use ini file entry
     */
    DPF( 3, "OVERRIDE: useDeathResurrection = %d", rc );
    return rc;

} /* useDeathResurrection */


/*
 * patchReg
 */
static WORD patchReg( WORD bpp )
{
    HKEY	 hkey;

    DPF( 3, "patching HKEY_CURRENT_CONFIG\\Display\\Settings\\BitsPerPixel" );

    if( !RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &hkey) )
    {
	char	str[20];
	DWORD	cb;
	
       	if( bpp == 0 )
	{
	    str[0] = 0;
	    cb = sizeof( str );
	    if( !RegQueryValueEx( hkey, "BitsPerPixel", NULL, NULL, str, &cb ) )
	    {
		bpp = atoi( str );
		DPF( 3, "BitsPerPixel of display is \"%s\" (%d)", str, bpp );
		strcpy( str, "8" );
	    }
	}
	else
	{
	    _itoa( bpp, str, 10 );
	}
	if( bpp != 0 )
	{
	    DPF( 3, "Setting BitsPerPixel of display to \"%s\"", str );
	    RegSetValueEx( hkey, "BitsPerPixel", 0, REG_SZ,
	    			(CONST LPBYTE)str, strlen( str ) );
	}
	RegCloseKey( hkey );
    }
    else
    {
	bpp = 0;
    }
    return bpp;

} /* patchReg */


/*
 * DD16_SetCertified
 */
void DDAPI DD16_SetCertified( BOOL iscert )
{
    bCertified = (BOOL) iscert;

} /* DD16_SetCertified */

/*
 * ModeX_SetMode
 */
LONG DDAPI ModeX_SetMode( UINT wWidth, UINT wHeight, UINT wStandardVGAFlag )
{
    LONG lResult = DD_OK;

    if ( (wWidth != 320) && (wWidth != 360) )
    {
        DPF(1, "ModeX_SetMode: %dx%d is an invalid mode!",wWidth,wHeight);
        return DDERR_INVALIDMODE;
    }
    if ( (wHeight != 175) && (wHeight != 200) && (wHeight != 240) &&
         (wHeight != 350) && (wHeight != 400) && (wHeight != 480) )
    {
        DPF(1, "ModeX_SetMode: %dx%d is an invalid mode!",wWidth,wHeight);
        return DDERR_INVALIDMODE;
    }

    if (!IsVGA())
    {
        DPF(1, "not a VGA");
        return DDERR_INVALIDMODE;
    }

    ModeX_Width  = wWidth;
    ModeX_Height = wHeight;

    bInOurSetMode = TRUE;

    _asm
    {
        mov     ax, 4001h
        int     2fh         ; notify background switch
    }

    if( useDeathResurrection() )
    {
	extern FAR PASCAL Death( HDC );
        HDC hdc = GetDC( NULL );
	DPF( 4, "Calling driver Disable" );

        _asm _emit 0x66 _asm _emit 0x60 ; pushad
        Death( hdc );
        _asm _emit 0x66 _asm _emit 0x61 ; popad

	ReleaseDC( NULL, hdc );
    }

    //
    //  after calling disable the BUSY bit better be set
    //  some display driver people thew out our sample code
    //  and rewrote it, and made it "better"
    //
    if (pdeDisplay && !(pdeDisplay->deFlags & BUSY))
    {
        DPF(1, "*** GIVE ME A GUN, NOW!, I WANT TO SHOOT SOMEONE ***");
        pdeDisplay->deFlags |= BUSY;
    }

    DPF( 5, "ModeX_SetMode(%d,%d, VGAFlag:%d)", wWidth, wHeight, wStandardVGAFlag);

    /*
    if (wHeight == 200)
        SetMode320x200x8();
    else if (wHeight == 240)
        SetMode320x240x8();
    else
        SetMode320x400x8();
        */
    if ( wStandardVGAFlag )
    {
        /*
         * Call BIOS to do set mode 013h. Assume successful.
         */
        _asm 
        {
            mov     ax,12h
            int     10h                     ; have BIOS clear memory

            mov     ax,13h                  ; set display mode 320x200x8
            int     10h
        }
    }
    else
    {
        lResult = SetVGAForModeX( wWidth, wHeight );
    }

    bInOurSetMode = FALSE;

    return lResult;

} /* ModeX_Enter */

/*
 * ModeX_Leave
 */
LONG DDAPI ModeX_RestoreMode( void )
{
    if (ModeX_Width == 0)
    {
        DPF(1, "ModeX_RestoreMode: not in ModeX!");
        return DDERR_GENERIC;
    }

    DPF( 4, "Leaving ModeX" );

    ModeX_Width = 0;
    ModeX_Height = 0;

    bInOurSetMode = TRUE;

    _asm
    {
        mov     ax, 0003h   ; text mode
        int     10h
    }

    if( useDeathResurrection() )
    {
	WORD	bpp;
	HDC	hdc;
	extern void FAR PASCAL Resurrection(HDC, LONG, LONG, LONG);
	bpp = patchReg( 0 );
        hdc = GetDC( NULL );
	DPF( 4, "Calling driver Enable" );

        _asm _emit 0x66 _asm _emit 0x60 ; pushad
        Resurrection( hdc, 0, 0, 0 );
        _asm _emit 0x66 _asm _emit 0x61 ; popad

	ReleaseDC( NULL, hdc );
	patchReg( bpp );
    }

    _asm
    {
        mov     ax, 4002h   ; notify foreground
        int     2fh
    }

    //
    //  after calling enable the BUSY bit better be clear
    //  some display driver people thew out our sample code
    //  and rewrote it, and made it "better"
    //
    if (pdeDisplay && (pdeDisplay->deFlags & BUSY))
    {
        DPF(1, "*** GIVE ME A GUN, NOW!, I WANT TO SHOOT SOMEONE ***");
        pdeDisplay->deFlags &= ~BUSY;
    }

    bInOurSetMode = FALSE;

} /* ModeX_Leave */

/*
 * ModeX_SetPaletteEntries
 */
LONG DDAPI ModeX_SetPaletteEntries(UINT wBase, UINT wNumEntries, LPPALETTEENTRY lpColorTable)
{
#ifdef DEBUG
    if (ModeX_Width == 0)
    {
        DPF(0, "ModeX_SetPaletteEntries: not in ModeX!!!");
        DEBUG_BREAK();
        return DDERR_GENERIC;
    }
#endif

    //
    // call the DIBENG so it can update the color table is uses for
    // colr matching.
    //
    if (pdeDisplay)
    {
       DIB_SetPaletteExt(wBase, wNumEntries, lpColorTable, pdeDisplay);
    }

    //
    // now program the hardware DACs
    //
    SetPalette(wBase, wNumEntries, lpColorTable);

    return DD_OK;

} /* ModeX_SetPaletteEntries */

/*============================================================================*
  New ModeX mode-set code.

  This code can manage horizontal resolutions of 320 or 360, with vertical
  resolutions of 175, 200, 240, 350, 400 and 480.

  This chart shows the operations necessary to set each of these modes, and
  the order in which these operations are done.
  Read the chart from top to bottom for a given vertical resolution, doing
  what's appropriate at each operation for the chosen horizontal resolution.

Vertical Res:| 175     200     240     350     400     480   Horizontal
             |                                               Resolution
Operation    |
-------------+-----------------------------------------------------------------
             |
Call int 10h |  ....................... ALL ...........................
             |
Reset CRT and|
put this in  |  a3      No      e3      a3      No      e3      320
MISC_OUTPUT  |  a7      67      e7      a7      67      e7      360
             |
Disable Chain|  ....................... ALL ...........................
             |
CRT_INDEX    |  ....................... ALL ...........................
"tweak"      |
             |
Set 360      |  ........................ NO ..............      320  DUHH!!!!
             |  ........................ YES .............      360
             |
Set Vertical |
             |
Which table? |  350*    None    480*    350     None    480     Both horz. res's.
             |

  * There are two tables defining how registers are to be munged to set a new
  vertical mode; one for 350 and one for 480. To set half this vertical resolution,
  skip the first entry in the table (which sets CRT_INDEX 9 to 0x40
 *============================================================================*/

#define SC_INDEX    0x3c4
#define CRT_INDEX   0x3d4
#define MISC_OUTPUT 0x3c2

/*
 * These def's are to make port to NT painless...
 */
#define WRITE_PORT_USHORT(port,value) {\
 DPF(5,"out %04x,%04x",port,value);_outpw(port,value);\
 _asm push ax         \
 _asm pop  ax         \
 _asm push ax         \
 _asm pop  ax         \
}

#define WRITE_PORT_UCHAR(port,value) {\
 DPF(5,"out %04x,%02x",port,value);_outp(port,value);\
 _asm push ax         \
 _asm pop  ax         \
 _asm push ax         \
 _asm pop  ax         \
}

static WORD wCRT_Tweak[] = {
    0x0014,         /* Turn off DWORD mode                  */
    0xe317          /* Turn on BYTE mode                    */
};
#define NUM_CRT_Tweak (sizeof(wCRT_Tweak)/sizeof(wCRT_Tweak[0]))

static WORD wCRT_Set360Columns[] = {
    0x6b00,         /* Horizontal total         107 */
    0x5901,         /* Horizontal display end   89  */
    0x5a02,         /* Start horizontal blank   90  */
    0x8e03,         /* End horizontal blank         */
    0x5e04,         /* Start horizontal retrace 94  */
    0x8a05,         /* End horizontal retrace       */
    0x2d13          /* Offset register          90  */
};
#define NUM_CRT_Set360Columns (sizeof(wCRT_Set360Columns)/sizeof(wCRT_Set360Columns[0]))

static WORD wCRT_Set175Lines[] = {
    0x1f07,         /* Overflow register            */
    0xbf06,         /* Vertical total           447 */
    0x8310,         /* Vertical retrace start   387 */
    0x8511,         /* Vertical retrace end         */
    0x6315,         /* Start vertical blanking  355 */
    0xba16,         /* End vertical blanking        */
    0x5d12          /* Vertical display end     349 */
};
#define NUM_CRT_Set175Lines (sizeof(wCRT_Set175Lines)/sizeof(wCRT_Set175Lines[0]))


static WORD wCRT_Set240Lines[] = {
    0x0d06,         /* Vertical total           523 */
    0x3e07,         /* Overflow register            */
    0xea10,         /* Vertical retrace start   490 */
    0xac11,         /* Vertical retrace end         */
    0xdf12,         /* Vertical display end     479 */
    0xe715,         /* Start vertical blanking  487 */
    0x0616         /* End vertical blanking        */
};
#define NUM_CRT_Set240Lines (sizeof(wCRT_Set240Lines)/sizeof(wCRT_Set240Lines[0]))

void BatchSetVGARegister(UINT iRegister, LPWORD pWordArray, int iCount)
{
    int i;
    for (i = 0; i< iCount; i++)
    {
        WRITE_PORT_USHORT(iRegister,pWordArray[i]);
    }
}

/*
 * The routines in mvgaxx.asm expect these two initialised.
 * These externs MUST stay in sync with what's in mvgaxx.asm.
 */
extern WORD ScreenOffset;
extern WORD cdwScreenWidthInDWORDS;
/*
 * This must be a multiple of 256
 */
extern WORD cbScreenPageSize;

LONG SetVGAForModeX(UINT wWidth, UINT wHeight)
{
    BOOL    bIsXHundredMode = FALSE;
    BOOL    bIsStretchedMode = FALSE;
    LPWORD  pwVerticalTable;
    UINT    cwVerticalCount;
    
    /*
     * These three are required by routines in mvgaxx.asm
     */
    ScreenOffset = 0;
    ScreenDisplay = 0;
    cdwScreenWidthInDWORDS = wWidth/4;

    /*
     * Page size must be a multiple of 256 as required by
     * FlipPage in vgaxx.asm
     */
    cbScreenPageSize = (wWidth/4 * wHeight + 0xff) & (~0xff) ;
    DDASSERT( (cbScreenPageSize & 0xff) == 0);

    DPF(5,"SetVGAForModeX called (%d,%d)",wWidth,wHeight);

    /*
     * First validate requested resolution
     */
    if ( (wWidth != 320) && (wWidth != 360) )
    {
        return DDERR_UNSUPPORTEDMODE;
    }
    if (
        (wHeight != 175) &&
        (wHeight != 200) &&
        (wHeight != 240) &&
        (wHeight != 350) &&
        (wHeight != 400) &&
        (wHeight != 480) )
    {
        return DDERR_UNSUPPORTEDMODE;
    }

    /*
     * Setup some useful booleans
     */
    if ( (wHeight==200) || (wHeight==400) )
    {
        bIsXHundredMode = TRUE;
    }

    if ( (wHeight == 350) || (wHeight == 400) || (wHeight == 480) )
    {
        bIsStretchedMode = TRUE;
    }


    /*
     * The first step for any mode set is calling BIOS to do set mode 013h
     */
    _asm 
    {
        mov     ax,12h
        int     10h                     ; have BIOS clear memory

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h
    }

    _asm
    {
        mov     dx,CRT_INDEX ;reprogram the CRT Controller
        mov     al,11h  ;VSync End reg contains register write
        out     dx,al   ; protect bit
        inc     dx      ;CRT Controller Data register
        in      al,dx   ;get current VSync End register setting
        and     al,7fh  ;remove write protect on various
        out     dx,al   ; CRTC registers
        dec     dx      ;CRT Controller Index
    }

    BatchSetVGARegister(CRT_INDEX, (LPWORD) wCRT_Tweak, NUM_CRT_Tweak);

    /*
     * Every ModeX mode needs Chain4 turned off etc.
     */
    DPF(5,"Set unchained");
    WRITE_PORT_USHORT(SC_INDEX,0x604);

    /*
     * For everything but 320x200 and 320x400 we need to reset the CRT and
     * reprogram the MISC_OUTPUT register
     */
    if ( ! ((wWidth == 320 ) && (bIsXHundredMode)) )
    {
        WORD wMISC;
        if ( (wHeight == 175) || (wHeight == 350) )
        {
            wMISC = 0xa3;
        }
        else if ( bIsXHundredMode )
        {
            wMISC = 0x63;
        }
        else
        {
            wMISC = 0xe3;
        }

        if ( wWidth == 360 )
        {
            wMISC |= 0x4;
        }

        /*
         * Set the dot clock...
         */
        DPF(5,"Setting dot clock");

        _asm cli;
        WRITE_PORT_USHORT(SC_INDEX,0x100);
        WRITE_PORT_UCHAR(MISC_OUTPUT,wMISC);
        WRITE_PORT_USHORT(SC_INDEX,0x300);
        _asm sti;
    } /* if required reset */

    /*
     * And now the magic scan stretch for 360x modes
     */
    if (wWidth == 360)
    {
        BatchSetVGARegister(CRT_INDEX, (LPWORD) wCRT_Set360Columns, NUM_CRT_Set360Columns);
    }

    /*
     * Now set the vertical resolution....
     * There are two tables, one for 240 and one for 175. We can set double these
     * heights by a single write of 0x40 to sequencer register 9. This trick
     * also works to stretch x200 into x400.
     */
    if (wHeight == 200)
    {
        /*
         * All done for 200 lines
         */
        return DD_OK;
    }

    if (bIsStretchedMode)
    {
        /*
         * Double the cell height for 350, 400 or 480 lines...
         */
        DDASSERT( wHeight == 350 || wHeight == 400 || wHeight == 480 );
        WRITE_PORT_USHORT(CRT_INDEX,0x4009); /* 0x40 into register 9 */
    }
    else
    {
        /*
         * Double the cell height for 350, 400 or 480 lines...
         */
        DDASSERT( wHeight == 175 || wHeight == 200 || wHeight == 240 );
        WRITE_PORT_USHORT(CRT_INDEX,0x4109); /* 0x41 into register 9 */
    }

    if (wHeight == 400)
    {
        /*
         * 400 is simply stretched 200, so we're done
         */
        return DD_OK;
    }

    if ( (wHeight == 175) || (wHeight == 350) )
    {
        pwVerticalTable = wCRT_Set175Lines;
        cwVerticalCount = NUM_CRT_Set175Lines;
    }
    else if ( (wHeight == 240) || (wHeight == 480) )
    {
        pwVerticalTable = wCRT_Set240Lines;
        cwVerticalCount = NUM_CRT_Set240Lines;
    }
#ifdef DEBUG
    else
    {
        DPF_ERR("Flow logic in SetVGAForModeX is wrong!!!");
        DDASSERT(FALSE);
        return DDERR_UNSUPPORTEDMODE;
    }
#endif

    /*
     *Just write the vertical info, and we're done
     */
    BatchSetVGARegister(CRT_INDEX, (LPWORD) pwVerticalTable, cwVerticalCount);

    return DD_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\modex.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       modex.h
 *  Content:    DirectDraw modex support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-aug-95  craige  created
 *   22-aug-95  toddla  added this nifty comment block
 *   14-dec-96  jeffno  Added prototypes for new ModeX modeset code in modex.c
 *
 ***************************************************************************/

LONG DDAPI ModeX_SetMode(UINT wWidth, UINT wHeight, UINT wStandardVGAFlag );
LONG DDAPI ModeX_RestoreMode(void);
LONG DDAPI ModeX_SetPaletteEntries(UINT wBase, UINT wNumEntries, LPPALETTEENTRY lpColorTable);
LONG DDAPI ModeX_Flip(DWORD lpBackBuffer);

LONG SetVGAForModeX(UINT wWidth, UINT wHeight);

extern void NEAR PASCAL SetMode320x200x8(void);
extern void NEAR PASCAL SetMode320x240x8(void);
extern void NEAR PASCAL SetMode320x400x8(void);
extern void NEAR PASCAL SetPalette(int start, int count, void far *pPal);
extern void NEAR PASCAL PixBlt(int xExt, int yExt,char far *pBits, long offset, int WidthBytes);
extern void NEAR PASCAL FlipPage(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\mvgaxx.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  MVGAXX.ASM
;
;   This module contains functions for dealing with the following VGA
;   256 color (modex) modes.
;
;       320x200x8
;       320x400x8
;       320x240x8
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
; 
; 15-Dec-96 jeffno  Made ScreenOffset and ScreenDisplay public so modex.c's
;                   new mode-set code can get at them. Also added cdwScreenWidthInDWORDS
;                   to enable PixBlt to operate correctly with 360x modes.
;
; Copyright (c) 1984-1995 Microsoft Corporation
;
;-----------------------------------------------------------------------;

?PLM = 1
?WIN = 0
.386
	.xlist
	include cmacros.inc
        include mvgaxx.inc
        .list

        externA         __A000h

; size for one 320x240x8 page (in mode X)
;-------------
; This is no longer accurate for x350 etc modex...
; turn it into a WORD and make it public so modex.c can
; set it properly.
;ScreenPageSize          equ  ((80 * 240 + 255) and (not 255))

sBegin  Data

ScreenSel         dw __A000h

;-------------------------------- Public Data ----------------------------------------
;
; The following three WORDS (ScreenOffset, ScreenDisplay and cdwScreenWidthInDWORDS
; and ScreenPageSize) MUST remain in sync with the extern declarations in modex.c
;

_ScreenOffset label word
ScreenOffset      dw 0

_ScreenDisplay label word
ScreenDisplay     dw 0

_cdwScreenWidthInDWORDS label word
cdwScreenWidthInDWORDS     dw 0

_cbScreenPageSize label word
cbScreenPageSize          dw ((80 * 240 + 255) and (not 255))


;expose these so modex.c can set 'em
public  _ScreenOffset
public  _ScreenDisplay
public  _cdwScreenWidthInDWORDS
public  _cbScreenPageSize

;
;
;-------------------------------------------------------------------------------------
sEnd    Data

ifndef SEGNAME
    SEGNAME equ <MODEX_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

; Manually perform "push" dword register instruction to remove warning
PUSHD macro reg
	db	66h
	push	reg
endm

; Manually perform "pop" dword register instruction to remove warning
POPD macro reg
	db	66h
	pop	reg
endm

;---------------------------Public-Routine------------------------------;
; FlipPage
;
;   display the current draw page and select another draw page
;
; Entry:
;
; Returns:
;       none
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       none
; History:
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   FlipPage, <NEAR, PUBLIC>, <>
cBegin
        ; we only program the high byte of the offset.
        ; so the page size must be a multiple of 256
        ; *** This compile-time assert can't be used anymore since cbScreenPageSize
        ; *** is now a static word. There are corresponding asserts in modex.c
        ; *** at the top of SetVGAForModeX().
        ;errnz   <cbScreenPageSize and 255>

        mov     ax,ScreenOffset
        mov     ScreenDisplay,ax
        mov     al,0Ch
        mov     dx,CRT_INDEX
        out     dx,ax

; NOTE. This routine will actually do triple buffering if a page is less
; than 64k/3. We might want to revisit this if we allow apps to specify a 
; dirty subrect to be copied on a flip: if they don't know the difference
; double and triple-buffered they'll get all out of sync.

        mov     ax,cbScreenPageSize
        add     ScreenOffset,ax
        neg     ax
        cmp     ScreenOffset,ax
        jbe     FlipPage13XExit

        mov     ScreenOffset,0

FlipPage13XExit:

cEnd

;---------------------------Public-Routine------------------------------;
; SetPalette
;
;   setup the palette
;
; Entry:
;       start       - first palette index to set
;       count       - count of palette index's
;       pPal        - points to array of RGBQUADs containg colors
;
; Returns:
;       None
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       setramdac
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc  SetPalette, <NEAR, PUBLIC>, <ds,si,di>
        parmW  start
        parmW  count
        parmD  pPal
        localV pal, %(3 * 256)
cBegin
        lds     si,pPal

        mov     bx,start            ; get start pal index
        mov     cx,count            ; get count
        mov     ax,bx
        add     ax,cx
        sub     ax,256              ; see if the count goes beyond the end
        jle     @f                  ;   No, valid range
        sub     cx,ax               ;   Yes, clip it
        mov     count,cx
@@:

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   convert the palette from a array of RGBQUADs (B,G,R,X) to a array of
;   VGA RGBs (R>>2,G>>2,B>>2)
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
        lea     di,pal              ; ES:DI --> pal array on stack
        mov     ax,ss
        mov     es,ax

convert_pal_loop:
        lodsw                       ; al=blue, ah=green
        mov     dx,ax               ; dl=blue, dh=green
        lodsw                       ; al=red
        shr     al,2                ; map from 0-255 into 0-63
        shr     dl,2
        shr     dh,2
	xchg	al,dl
        stosb                       ; write red
        xchg    dl,dh               ; switch blue,green
        mov     ax,dx
        stosw                       ; write green,blue

        loop    convert_pal_loop

        lea     si,pal              ; DS:SI --> converted RGBs
        mov     ax,ss
        mov     ds,ax
        mov     cx,count            ; re-load count

        call    setramdac           ; set the physical palette
cEnd

;---------------------------------------------------------------------------
; setramdac  - initialize the ramdac to the values stored in
;	       a color table composed of double words
;
; entry:
;	bx  - index to 1st palette entry
;	cx  - count of indices to program
;    ds:si -> array of RGBs
;
; exit:
;   palette has been loaded
;
; Registers destroyed:
;   al,cx,dx,si
;
;---------------------------------------------------------------------------
        assumes ds,nothing
        assumes es,nothing

	public	setramdac
setramdac   proc near
	mov	ax,bx

	mov	dx,3c8h 		;Color palette write mode index reg.
	out	dx,al

        mov     dx,3c9h                 ;Color palette data reg.

        mov     bx,cx                   ;CX *= 3
        add     cx,cx                   ;
        add     cx,bx                   ;
if 0
        rep     outsb                   ;Set the palette all at once!
else
@@:     lodsb
        out     dx,al
        pause
        loop    @b
endif
	ret
setramdac  endp

;---------------------------Public-Routine------------------------------;
; PixBlt
;
;   copy a bitmap to the screen
;
; Entry:
;       x           - (x,y) pos of lower left of rect
;       y
;       xExt        - width and height of rect
;       yExt
;       pBits       - pointer to bits
;       BitsOffset  - pointer offset to start at.
;       WidthBytes  - width of a bitmap scan
;
; IMPORTANT: SEE WIDTH RESTRICTIONS AS DOCUMENTED WITHIN ROUTINE
; Note reference to cdwScreenWidthInDWORDS.
;
; Returns:
;       none
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;   15-Dec-96   jeffno  Allowed pitch other than 320, extended inner loop
;                       to handle multiples of 320 with remainder 8 pixels 
;                       (for 360x modes)
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc	PixBlt, <NEAR, PUBLIC>, <ds>
        ParmW   xExt        ;14
        ParmW   yExt        ;12
        ParmD   pBits       ;8 10
        ParmD   BitsOffset  ;4 6
        ParmW   WidthBytes  ;2
                            ;0
        localW  next_dst_scan
        localD  next_src_scan
cBegin
        .386
        PUSHD   si	; push esi
        PUSHD   di	; push edi

        xor     esi,esi
        xor     edi,edi
        xor     ebx,ebx

        ; this routine only handles images in multiles of 32 pixels
        ; and they must start 4 pixel aligned
        ; But JeffNo added an extra loop to extend to either a multiple
        ; of 32 (320x) or a multiple of 32 plus 8 extra pixels (360x).
        ; An assert has been added in modex.c to ensure one of these cases.

;        and     xExt,not 31
;;      and     x,not 3

        mov     es,ScreenSel

	mov	ax,cdwScreenWidthInDWORDS
	mov	next_dst_scan,ax

        mov     ax,WidthBytes
        sub     ax,4
        movsx   eax,ax
        mov     next_src_scan,eax

        mov     di,ScreenOffset     ; es:di -> top-left screen

        lds     si,pBits
        add     esi,BitsOffset
        assumes ds,nothing

        mov     al,SC_MAP_MASK
        mov     dx,SC_INDEX
        out     dx,al
align 4
PixBltXLoop:
;-----------------------------------------------------------------;
;   ax      - free
;   bx      - index into dest es:[edi+ebx]  index into source [esi+ebx*4]
;   cx      - loop count
;   dl      - mask
;   dh      - free
;   si      - source pointer (does not change)
;   di      - dest pointer (does not change)

        mov     cx,xExt
        shr     cx,2
        and     cx,0fff8h               ; a left over would give an extra loop at 360x
        mov     dl,11h                  ; dh = mask
align 4
PixBltXPhaseLoop:
        mov     bx,dx                   ; set the mask
        mov     al,dl
        mov     dx,SC_INDEX+1
        out     dx,al
        mov     dx,bx

        xor     bx,bx                   ; start at zero
align 4
PixBltXPixelLoop:
        mov     al,[esi+ebx*4]
        mov     ah,[esi+ebx*4+4]
        mov     es:[di+bx],ax

        mov     al,[esi+ebx*4+8]
        mov     ah,[esi+ebx*4+12]
        mov     es:[di+bx+2],ax

        mov     al,[esi+ebx*4+16]
        mov     ah,[esi+ebx*4+20]
        mov     es:[di+bx+4],ax

        mov     al,[esi+ebx*4+24]
        mov     ah,[esi+ebx*4+28]
        mov     es:[di+bx+6],ax

        add     bx,8
        cmp     bx,cx
        jl      short PixBltXPixelLoop

PixBltXNext:
        inc     esi
        shl     dl,1
        jnc     short PixBltXPhaseLoop

;-----------------------------------------------------------------;
; extra stuff to tack on the extra 2 chains to go from 352 to 360
; Note this little chunk relies on the xExt being a multiple of
; 8 pixels. If xExt is 320, we'll skip this part, and if it's
; 360, we'll do it
;
        test    xExt,08h
        je      short NoExtras      ;branch taken implies width is 320, else 360
        mov     dx,SC_INDEX+1
        mov     al,011h             ;the plane bits
        out     dx,al               ;select plane.

        mov     bx,xExt             ; point to the last 8 columns
        sub     bx,8                
        shr     bx,2

        mov     cl,[esi+ebx*4-4]    ; -4 because esi is 4 greater than start of row
        mov     ch,[esi+ebx*4]
        mov     es:[di+bx],cx

        shl     al,1
        out     dx,al               ;select plane.

        mov     cl,[esi+ebx*4-3]
        mov     ch,[esi+ebx*4+1]
        mov     es:[di+bx],cx

        shl     al,1
        out     dx,al               ;select plane.

        mov     cl,[esi+ebx*4-2]
        mov     ch,[esi+ebx*4+2]
        mov     es:[di+bx],cx

        shl     al,1
        out     dx,al               ;select plane.

        mov     cl,[esi+ebx*4-1]
        mov     ch,[esi+ebx*4+3]
        mov     es:[di+bx],cx

        
NoExtras:
;-----------------------------------------------------------------;

        add     di,next_dst_scan    ;no changes to these to support 360x, since this
        add     esi,next_src_scan   ;assume looped over multiple of 320, and the extra
                                    ;loop didn't change di and esi.

        dec     yExt
        jnz     PixBltXLoop         ;not a short by just 3 bytes!

PixBltXExit:
        POPD    di	; pop edi
        POPD    si	; pop esi
cEnd

;---------------------------Private-Routine------------------------------;
; SetMode320x200x8
;
;   VGA 320x200x8 graphics mode is entered (plain ol' MODE 13h)
;
; Entry:
;
; Returns:
;       360x200x8 graphics mode is entered
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   SetMode320x200x8, <NEAR, PUBLIC>, <ds,si,di>
cBegin
        mov     ScreenOffset,0          ; make sure this is zero
	mov	ScreenDisplay,0 	; make sure this is zero too.

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h
	
        mov     dx,SC_INDEX     ; alter sequencer registers
        mov     ax,0604h
        out     dx,ax           ;disable chain4 mode
	
        mov	dx,CRT_INDEX
	mov	ax,0E317h
	out	dx, ax
	
	mov	ax, 014h
	out	dx, ax
	
cEnd

;---------------------------Private-Macro--------------------------------;
; SLAM port, regs
;
;   Sets a range of VGA registers
;
; Entry:
;   port    port index register
;   regs    table of register values
;
; History:
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

SLAM    macro   port, regs
	local	slam_loop
	local	slam_exit
        mov     cx,(&regs&_end - regs) / 2
	mov	dx,port
	mov	si,offset regs
	jcxz	slam_exit
slam_loop:
        lodsw
        out     dx,ax
        pause
	loop	slam_loop
slam_exit:
        endm

;---------------------------Private-Routine------------------------------;
; SetMode320x400x8
;
;   VGA 320x400x8 graphics mode is entered
;
; Entry:
;
; Returns:
;       320x400x8 graphics mode is entered
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

seq_320x400:
        ;dw      00801h   ; Dot Clock * 2
        dw      00604h    ; Disable chain 4
seq_320x400_end:

crt_320x400:
        dw      04009h  ; cell height
        dw      00014h  ; turn off dword mode
        dw      0e317h  ; turn on byte mode
crt_320x400_end:

	assumes ds,Data
	assumes es,nothing

cProc   SetMode320x400x8, <NEAR, PUBLIC>, <ds,si,di>
cBegin
        mov     ScreenOffset,0          ; make sure this is zero
	mov	ScreenDisplay,0 	; make sure this is zero too.

        mov     ax,12h
        int     10h                     ; have BIOS clear memory

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h

        mov     ax,cs                   ; get segment for data
        mov     ds,ax

        ;
        ;   Set the CRT regs
	;
        SLAM CRT_INDEX, crt_320x400

        ;
        ;   Set the SEQ regs
	;
        SLAM SC_INDEX, seq_320x400
cEnd

;---------------------------Private-Routine------------------------------;
; SetMode320x240x8
;
;   VGA 320x240x8 graphics mode is entered
;
; Entry:
;
; Returns:
;       320x240x8 graphics mode is entered
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,Data
        assumes es,nothing

seq_320x240:
        dw      00604h    ; Disable chain 4
seq_320x240_end:

crt_320x240:
;       dw      00611h  ; un-protect cr0-cr7

        dw      00d06h  ;vertical total
        dw      03e07h  ;overflow (bit 8 of vertical counts)
        dw      04109h  ;cell height (2 to double-scan)
        dw      0ea10h  ;v sync start
        dw      0ac11h  ;v sync end and protect cr0-cr7
        dw      0df12h  ;vertical displayed
        dw      00014h  ;turn off dword mode
        dw      0e715h  ;v blank start
        dw      00616h  ;v blank end
        dw      0e317h  ;turn on byte mode
crt_320x240_end:

cProc   SetMode320x240x8, <NEAR, PUBLIC>, <ds,si,di>
cBegin
        mov     ScreenOffset,0          ; make sure this is zero
	mov	ScreenDisplay,0 	; make sure this is zero too.

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h

        mov     ax,cs                   ; get segment for data
        mov     ds,ax
        assumes ds,Code

        mov     dx,CRT_INDEX ;reprogram the CRT Controller
        mov     al,11h  ;VSync End reg contains register write
        out     dx,al   ; protect bit
        inc     dx      ;CRT Controller Data register
        in      al,dx   ;get current VSync End register setting
        and     al,7fh  ;remove write protect on various
        out     dx,al   ; CRTC registers
        dec     dx      ;CRT Controller Index

        ;
        ;   Set the CRT regs
	;
        SLAM CRT_INDEX, crt_320x240

        mov     dx,SC_INDEX     ; alter sequencer registers
        mov     ax,0604h
        out     dx,ax           ;disable chain4 mode

        ;
        ;   Select a 25 mHz crystal
        ;
        cli
;       mov     dx,SC_INDEX     ; alter sequencer registers
	mov	ax,0100h	; synchronous reset
        out     dx,ax           ; asserted
        pause

        mov     dx,MISC_OUTPUT  ; misc output
        mov     al,0e3h         ; use 25 mHz dot clock
        out     dx,al           ; select it
        pause

        mov     dx,SC_INDEX     ; sequencer again
        mov     ax,0300h        ; restart sequencer
        out     dx,ax           ; running again
        pause
        sti

        ;
        ; now clear the memory.
        ;
        mov     ax,DataBASE
        mov     ds,ax
        assumes ds,Data

        mov     ax,ScreenSel
        mov     es,ax
        xor     di,di

        mov     ax,SC_MAP_MASK + 0F00h
        mov     dx,SC_INDEX
        out     dx,ax

        xor     ax,ax
        mov     cx,8000h
        rep     stosw
cEnd

sEnd    CodeSeg
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\mvgaxx.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  MVGAXX.INC
;
; This file contains the definitions of the EGA/VGA registers used by
; MVGAXX.ASM
;
;-----------------------------------------------------------------------;

SC_INDEX        equ     03C4h           ; Sequence Controller Index register
SC_MAP_MASK     equ     0002H
SC_MEMORY_MODE  equ     0004H

GC_INDEX        equ     03CEh           ; Graphics Controller Index register
GC_FUNCTION     equ     0003H
GC_READ_MAP     equ     0004H
GC_MODE         equ     0005h
GC_MISC         equ     0006H
GC_BITMASK      equ     0008H

CRT_INDEX       equ     03D4h           ; CRT index


MISC_OUTPUT     equ     03C2h           ; Miscellaneous Output register
MISC_INPUT      equ     03CCh           ; Miscellaneous Output register read

GRAF_ADDR	equ	0CEh		;Graphics Controller Address Register
GRAF_DATA	equ	0CFh		;Graphics Controller Data    Register

GRAF_SET_RESET	equ	00h		;  Set/Reset Plane Color
GRAF_ENAB_SR	equ	01h		;  Set/Reset Enable
GRAF_COL_COMP	equ	02h		;  Color Compare Register

GRAF_DATA_ROT	equ	03h		;  Data Rotate Register
DR_ROT_CNT	equ	00000111b	;    Data Rotate Count
DR_SET		equ	00000000b	;    Data Unmodified
DR_AND		equ	00001000b	;    Data ANDed with latches
DR_OR		equ	00010000b	;    Data ORed	with latches
DR_XOR		equ	00011000b	;    Data XORed with latches

GRAF_READ_MAP	equ	04h		;  Read Map Select Register
RM_C0		equ	00000000b	;    Read C0 plane
RM_C1		equ	00000001b	;    Read C1 plane
RM_C2		equ	00000010b	;    Read C2 plane
RM_C3		equ	00000011b	;    Read C3 plane

GRAF_MODE	equ	05h		;  Mode Register
M_PROC_WRITE	equ	00000000b	;    Write processor data rotated
M_LATCH_WRITE	equ	00000001b	;    Write latched data
M_COLOR_WRITE	equ	00000010b	;    Write processor data as color
M_AND_WRITE	equ	00000011b	;    Write (procdata AND bitmask)
M_DATA_READ	equ	00000000b	;    Read selected plane
M_COLOR_READ	equ	00001000b	;    Read color compare

GRAF_CDC	equ	07h		;  Color Don't Care Register
GRAF_BIT_MASK	equ	08h		;  Bit Mask Register

SET_WRITE_MAP macro plane_num
        pushem  ax,dx,cx
        mov     cl,plane_num
        and     cl,0011b
        mov     ax,SC_MAP_MASK + 0100h
        mov     dx,SC_INDEX
        shl     ah,cl
        out     dx,ax
        popem   ax,dx,cx
        endm

SET_READ_MAP macro plane_num
        pushem  ax,dx
        mov     ah,plane_num
        mov     al,GC_READ_MAP
        mov     dx,GC_INDEX
        out     dx,ax
        popem   ax,dx
        endm

SET_WRITE_MASK macro plane_mask
        pushem  ax,dx
        mov     al,SC_MAP_MASK
        mov     ah,plane_mask
        mov     dx,SC_INDEX
        out     dx,ax
        popem   ax,dx
        endm

pause   macro
        jmp     $+2
        endm

;----------------------------Private-Macro------------------------------;
; pushem
; popem
;
; Allows giving a list of registers to push/pop on a single line.
; Also allows easy verificaton that pushes and pops are balanced
; because arguements are given in the same order:
;
;	pushem	ax,bx,cx   goes with
;	popem	ax,bx,cx
;
; Arguments:
;	registers to push/pop
; Returns:
;	nothing
; Alters:
;	nothing
; Calls:
;	nothing
; History:
;
;  Mon Mar 09, 1987 06:12:32p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


pushem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12>
	ifnb	<x>
	push	x
	endif
	endm
	endm

popem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r12,r11,r10,rF,rE,rD,rC,rB,rA,r9,r8,r7,r6,r5,r4,r3,r2,r1>
	ifnb	<x>
	pop	x
	endif
	endm
        endm

;-------------------------Macro-----------------------------------------;
; REPSTOSB Dst
;
; store <cx> copies of al at Dst, aliging destination on WORD writes
;
;   Dst         destination, must be of the form SEL:[di] (default is es:[di])
;
; Entry:
;   Dst         -> points to dest buffer
;   al          byte to write
;   cx          count bytes
;
; Alters:
;   AX,BX,CX,DI
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; Returns:
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;
;-----------------------------------------------------------------------;

?REPSTOSB macro Dst
        local   l1
if 0
        mov     ah,al               ; make sure ah == al
        mov     bx,cx               ; save cx for later
        mov     cx,di
        and     cx,0001h
        sub     bx,cx
        rep     stos    byte ptr Dst
        mov     cx,bx
        shr     cx,1
        rep     stos word ptr Dst
        adc     cl,cl
        rep     stos byte ptr Dst
else
        mov     ah,al               ; make sure ah == al
        test    di,1
        jz      l1
        stos    byte ptr Dst
        dec     cx
l1:     shr     cx,1
        rep     stos word ptr Dst
        adc     cl,cl
        rep     stos byte ptr Dst
endif

        endm

REPSTOSB macro Dst
ifb <Dst>
        ?REPSTOSB es:[di]
else
        ?REPSTOSB Dst
endif
        endm

;-------------------------Macro-----------------------------------------;
; REPMOVSB Dst, Src, alignR
;
; copy <cx> bytes from Src to Dst, aliging destination or source
; on WORD writes
;
;   Dst         destination, must be of the form SEL:[di] (default is es:[di])
;   Src         source,      must be of the form SEL:[si] (default is ds:[si])
;   alignR      register to align   si or di (default is di)
;
; Entry:
;   Src         -> points to source buffer
;   Dst         -> points to dest buffer
;   cx          count bytes
;
; Alters:
;   BX,CX,DI,SI
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; Returns:
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;
;-----------------------------------------------------------------------;

?REPMOVSB  macro Dst, Src, alignR
        local   l1
if 0
        mov     bx,cx
        mov     cx,alignR
        and     cx,0001h
        sub     bx,cx
        rep     movs    byte ptr Dst, byte ptr Src
        mov     cx,bx
        shr     cx,1
        rep     movs    word ptr Dst, word ptr Src
        adc     cl,cl
        rep     movs    byte ptr Dst, byte ptr Src
else
        test    alignR,1
        jz      l1
        movs    byte ptr Dst, byte ptr Src
        dec     cx
l1:     shr     cx,1
        rep     movs    word ptr Dst, word ptr Src
        adc     cl,cl
        rep     movs    byte ptr Dst, byte ptr Src
endif
        endm

REPMOVSB  macro Dst, Src, alignR

ifb <Dst>
        ?REPMOVSB es:[di],ds:[si],di
        exitm
endif

ifb <Src>
        ?REPMOVSB Dst,ds:[si],di
        exitm
endif

ifb <alignR>
        ?REPMOVSB Dst,Src,di
        exitm
endif
        ?REPMOVSB Dst,Src,alignR

        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\vfd.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  VFD.ASM
;
;   interface code to VFlatD
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1994 Microsoft Corporation
;
; Restrictions:
;
;-----------------------------------------------------------------------;

?PLM = 1
?WIN = 0
	.xlist
	include cmacros.inc
	include VflatD.inc
        .list

sBegin  Data
	globalD VflatD_Proc, 0
	globalW _hselSecondary, 0
sEnd

sBegin  Code
	.386p
	assumes cs,Code
	assumes ds,nothing
	assumes es,nothing

;---------------------------Public-Routine------------------------------;
; VFDCall - return the version of VFlatD
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;       Created.
;-----------------------------------------------------------------------;
	assumes ds,Data
	assumes es,nothing

cProc   VFDCall, <NEAR>, <>
cBegin
	push    esi
	push    edi
	push    es
	pushad

	xor     di,di
	mov     es,di
	mov     ax,1684h
        mov     bx,VflatD_Chicago_ID
	int     2fh                         ;returns with es:di-->VFlatD Entry point
	mov     word ptr [VflatD_Proc][0],di
	mov     word ptr [VflatD_Proc][2],es
	mov     ax,es
	or      ax,di
	jne     short call_vfd

	xor     di,di
	mov     es,di
	mov     ax,1684h
        mov     bx,VflatD_Windows_ID
	int     2fh                         ;returns with es:di-->VFlatD Entry point
	mov     word ptr [VflatD_Proc][0],di
	mov     word ptr [VflatD_Proc][2],es
	mov     ax,es
	or      ax,di
        jnz     short call_vfd

	popad
	pop     es
call_vfd_err:
	xor     eax,eax
	xor     ebx,ebx
	xor     ecx,ecx
	xor     edx,edx
	jmp     call_vfd_exit

call_vfd:
	popad
	pop     es
	call    [VflatD_Proc]
	jc      call_vfd_err

call_vfd_exit:
	pop     edi
	pop     esi
cEnd

;---------------------------Public-Routine------------------------------;
; VFDQuery - return the version of VFlatD
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;       Created.
;-----------------------------------------------------------------------;
	assumes ds,Data
	assumes es,nothing

cProc   VFDQueryVersion, <FAR, PUBLIC, PASCAL>, <>
cBegin
	xor     eax,eax
	mov     edx,VFlatD_Query
	call    VFDCall
	shld    edx,eax,16
cEnd

cProc   VFDQuerySel, <FAR, PUBLIC, PASCAL>, <>
cBegin
	mov     edx,VFlatD_Query
	call	VFDCall
	and	ebx,0000FFFFh
	mov     eax,ebx
	shld    edx,eax,16
cEnd

cProc   VFDQuerySize, <FAR, PUBLIC, PASCAL>, <>
cBegin
	mov     edx,VFlatD_Query
	call    VFDCall
        mov     eax,ecx
	shld    edx,eax,16
cEnd

cProc   VFDQueryBase, <FAR, PUBLIC, PASCAL>, <>
cBegin
	mov     edx,VFlatD_Query
        call    VFDCall
        mov     eax,edx
	shld    edx,eax,16
cEnd

cProc   VFDReset, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     edx,VFlatD_ResetBank
	call	VFDCall
cEnd

cProc   VFDBeginLinearAccess, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     edx,VFlatD_Begin_Linear_Access
        mov     dh,1        ;; set flag to allow 4k bank to work.
        call    VFDCall
	shld    edx,eax,16
cEnd

cProc   VFDEndLinearAccess, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     edx,VFlatD_End_Linear_Access
	call    VFDCall
	shld    edx,eax,16
cEnd


extrn LocalFree: FAR
extrn LocalAlloc: FAR

cProc   LocalAllocSecondary, <FAR, PUBLIC, PASCAL>, <>
        parmW  flags
        parmW  allocsize
cBegin
	mov     ax, _hselSecondary
	test    ax, ax
	jz      AllocError
	push    ds
	mov     ds, ax
	push    flags
	push    allocsize
	call    LocalAlloc
	mov     dx, ds	; assume success
	pop     ds
	test    ax, ax
	jnz     okay
AllocError:
	xor     dx, dx	; nope failed
okay:
cEnd


cProc   LocalFreeSecondary, <FAR, PUBLIC, PASCAL>, <>
        parmW  lp
cBegin
	push    ds
	mov     ax, _hselSecondary
	test    ax, ax
	jz      FreeError
	mov     ds, ax
	push    lp
	call    LocalFree
FreeError:
	pop     ds
cEnd


sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\moninfo.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       moninfo.c
 *  Content:	Code to query monitor specifications
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-mar-96	kylej	initial implementation (code from Toddla)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <minivdd.h>
#include "edid.h"

#pragma optimize("gle", off)
#define Not_VxD
#include <vmm.h>
#include <configmg.h>
#pragma optimize("", on)

#include "ddraw16.h"

/***************************************************************************
 * just incase these are not defined, define them localy.
 ***************************************************************************/

#ifndef VDD_OPEN
#define VDD_OPEN            (13 + MINIVDD_SVC_BASE_OFFSET)
#endif

#ifndef VDD_OPEN_TEST
#define VDD_OPEN_TEST       0x00000001
#endif

/***************************************************************************
 ***************************************************************************/
static int myatoi(LPSTR sz)
{
    int i=0;
    int sign=+1;

    if (*sz=='-')
    {
        sign=-1;
        sz++;
    }

    while (*sz && *sz >= '0' && *sz <= '9')
        i = i*10 + (*sz++-'0');

    return i*sign;
}

/***************************************************************************
 VDDCall - make a service call into the VDD
 ***************************************************************************/

#pragma optimize("gle", off)
DWORD VDDCall(DWORD dev, DWORD function, DWORD flags, LPVOID buffer, DWORD buffer_size)
{
    static DWORD   VDDEntryPoint=0;
    DWORD   result=0xFFFFFFFF;

    if (VDDEntryPoint == 0)
    {
        _asm
        {
            xor     di,di           ;set these to zero before calling
            mov     es,di           ;
            mov     ax,1684h        ;INT 2FH: Get VxD API Entry Point
            mov     bx,0ah          ;this is device code for VDD
            int     2fh             ;call the multiplex interrupt
            mov     word ptr VDDEntryPoint[0],di    ;
            mov     word ptr VDDEntryPoint[2],es    ;save the returned data
        }

        if (VDDEntryPoint == 0)
            return result;
    }

    _asm
    {
        _emit 66h _asm push si  ; push esi
        _emit 66h _asm push di  ; push edi
        _emit 66h _asm mov ax,word ptr function     ;eax = function
        _emit 66h _asm mov bx,word ptr dev          ;ebx = device
        _emit 66h _asm mov cx,word ptr buffer_size  ;ecx = buffer_size
        _emit 66h _asm mov dx,word ptr flags        ;edx = flags
        _emit 66h _asm xor di,di                    ; HIWORD(edi)=0
        les     di,buffer
        mov     si,di                               ;si
        call    dword ptr VDDEntryPoint             ;call the VDD's PM API
        cmp     ax,word ptr function
        je      fail
        _emit 66h _asm mov word ptr result,ax
fail:   _emit 66h _asm pop di   ; pop edi
        _emit 66h _asm pop si   ; pop esi
    }

    return result;
}
#pragma optimize("", on)

/***************************************************************************
 * GetDisplayInfo - call the VDD to get the DISPLAYINFO for a device
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 * output
 *      DISPLAYINFO filled in
 *
 ***************************************************************************/
DWORD NEAR GetDisplayInfo(LPSTR szDevice, DISPLAYINFO FAR *pdi)
{
    DWORD dev;

    if (szDevice && lstrcmpi(szDevice, "DISPLAY") != 0)
        dev = VDDCall(0, VDD_OPEN, VDD_OPEN_TEST, (LPVOID)szDevice, 0);
    else
        dev = 1;

    if (dev == 0 || dev == 0xFFFFFFFF)
        return 0;

    pdi->diHdrSize = sizeof(DISPLAYINFO);
    pdi->diDevNodeHandle = 0;
    pdi->diMonitorDevNodeHandle = 0;

    VDDCall(dev, VDD_GET_DISPLAY_CONFIG, 0, (LPVOID)pdi, sizeof(DISPLAYINFO));

    if (pdi->diDevNodeHandle == 0)
        return 0;
    else
        return dev;
}

/***************************************************************************
 * GetMonitorMaxSize - returns the max xresolution the monitor supports
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 * output
 *      max xresolution of the monitor, or zero if the monitor
 *      is unknown.
 *
 ***************************************************************************/
int DDAPI DD16_GetMonitorMaxSize(LPSTR szDevice)
{
    DISPLAYINFO di;
    char ach[40];
    DWORD cb;

    GetDisplayInfo(szDevice, &di);

    if (di.diMonitorDevNodeHandle == 0)
        return 0;

    //
    // we have the devnode handle for the monitor, read the max
    // size from the registry, first try the HW key then the SW
    // key, this way PnP monitors will be supported.
    //
    ach[0] = 0;
    cb = sizeof(ach);
    CM_Read_Registry_Value(di.diMonitorDevNodeHandle, NULL, "MaxResolution",
        REG_SZ, ach, &cb, CM_REGISTRY_HARDWARE);

    if (ach[0] == 0)
    {
        cb = sizeof(ach);
        CM_Read_Registry_Value(di.diMonitorDevNodeHandle, NULL, "MaxResolution",
            REG_SZ, ach, &cb, CM_REGISTRY_SOFTWARE);
    }

    //
    // ach now contains the maxres, ie "1024,768" convert the xres to a
    // integer and return it.
    //
    return myatoi(ach);
}

/***************************************************************************
 * GetMonitorRefreshRateRanges
 *
 * returns the min/max refresh rate ranges for a given mode
 *
 * input
 *      szDevice    - device name, use NULL (or "DISPLAY") for the primary device.
 *      xres        - xres of the mode to query refresh ranges for
 *      yres        - yres of the mode to query refresh ranges for
 *      pmin        - place to put min refresh
 *      pmax        - place to put max refresh
 *
 * output
 *      true if success
 *      is unknown.
 *
 ***************************************************************************/
BOOL DDAPI DD16_GetMonitorRefreshRateRanges(LPSTR szDevice, int xres, int yres, int FAR *pmin, int FAR *pmax)
{
    DISPLAYINFO di;
    char ach[40];
    DWORD cb;
    HKEY hkey;
    char SaveRes[40];
    char SaveRate[40];
    DWORD dev;

    //
    // set these to zero in case we fail
    //
    *pmin = 0;
    *pmax = 0;

    //
    //  get the devnode handle for the display
    //
    dev = GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    //
    // open the settings key for the device, if no custom key exists
    // use HKCC/Display/Settings
    //
    hkey = NULL;
    VDDCall(dev, VDD_OPEN_KEY, 0, &hkey, sizeof(hkey));

    if (hkey == NULL)
        RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &hkey);

    if (hkey == NULL)
        return 0;

    //
    // save the current values of RefreshRate, and Resolution
    //
    SaveRate[0] = 0;
    SaveRes[0] = 0;
    cb = sizeof(SaveRes);
    RegQueryValueEx(hkey, "Resolution", NULL, NULL, SaveRes, &cb);

    cb = sizeof(SaveRate);
    CM_Read_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate",
        REG_SZ, SaveRate, &cb, CM_REGISTRY_SOFTWARE);

    //
    // set our new values, the VDD uses the resoluton in the
    // registry when computing the refresh rate ranges so we need
    // to update the registry to contain the mode we want to test.
    // we also need to write RefreshRate=-1 to enable automatic
    // refresh rate calcultion.
    //
    cb = wsprintf(ach, "%d,%d", xres, yres);
    RegSetValueEx(hkey, "Resolution", NULL, REG_SZ, ach, cb);

    CM_Write_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate",
        REG_SZ, "-1", 2, CM_REGISTRY_SOFTWARE);

    //
    // now call the VDD to get the refresh rate info.
    //
    di.diHdrSize = sizeof(DISPLAYINFO);
    di.diRefreshRateMin = 0;
    di.diRefreshRateMax = 0;
    VDDCall(dev, VDD_GET_DISPLAY_CONFIG, 0, (LPVOID)&di, sizeof(DISPLAYINFO));

    *pmin = di.diRefreshRateMin;
    *pmax = di.diRefreshRateMax;

    //
    // restore the saved values back to the registry
    //
    CM_Write_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate",
        REG_SZ, SaveRate, lstrlen(SaveRate), CM_REGISTRY_SOFTWARE);
    RegSetValueEx(hkey, "Resolution", NULL, REG_SZ, SaveRes, lstrlen(SaveRes));

    RegCloseKey(hkey);
    return TRUE;
}

/***************************************************************************
 * GetDeviceConfig
 *
 * get the device resource config
 *
 * input
 *      szDevice    - device name, use NULL (or "DISPLAY") for the primary device.
 *      lpConfig    - points to a CMCONFIG struct (or NULL)
 *      cbConfig    - size of lpConfig buffer
 *
 * output
 *      return the devnode handle, or 0 if failure
 *
 ***************************************************************************/
DWORD DDAPI DD16_GetDeviceConfig(LPSTR szDevice, LPVOID lpConfig, DWORD cbConfig)
{
    DISPLAYINFO di;

    //
    //  get the devnode handle for the display
    //
    GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    //
    // call CONFIGMG to get the config
    //
    if (lpConfig)
    {
        if (cbConfig < sizeof(CMCONFIG))
            return 0;

        CM_Get_Alloc_Log_Conf((CMCONFIG FAR *)lpConfig, di.diDevNodeHandle, 0);
    }

    //
    // return the DEVNODE handle
    //
    return di.diDevNodeHandle;
}

/***************************************************************************
 * GetMonitorEDIDData
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 * output
 *      lpEdidData  - EDID data.
 *
 ***************************************************************************/
int DDAPI DD16_GetMonitorEDIDData(LPSTR szDevice, LPVOID lpEdidData)
{
    DISPLAYINFO di;
    DWORD cb;

    GetDisplayInfo(szDevice, &di);

    if (di.diMonitorDevNodeHandle == 0)
        return 0;

    cb = sizeof( VESA_EDID );
    if (CM_Read_Registry_Value(di.diMonitorDevNodeHandle, NULL, "EDID", REG_BINARY, lpEdidData, &cb, CM_REGISTRY_HARDWARE) == CR_SUCCESS)
    {
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************
 * GetRateFromRegistry
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 ***************************************************************************/
DWORD DDAPI DD16_GetRateFromRegistry(LPSTR szDevice)
{
    DISPLAYINFO di;
    DWORD cb;
    BYTE szTemp[20];

    //
    //  get the devnode handle for the display
    //
    GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    cb = sizeof( szTemp );
    if (CM_Read_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate", REG_SZ, szTemp, &cb, CM_REGISTRY_SOFTWARE) == CR_SUCCESS)
    {
        return atoi( szTemp );
    }

    return 0;
}


/***************************************************************************
 * SetRateInRegistry
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *      dwRate      - Rate to set in the registry
 *
 ***************************************************************************/
int DDAPI DD16_SetRateInRegistry(LPSTR szDevice, DWORD dwRate)
{
    DISPLAYINFO di;
    DWORD cb;
    BYTE szTemp[20];

    //
    //  get the devnode handle for the display
    //
    GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    wsprintf( szTemp, "%d", (int)dwRate );
    cb = lstrlen( szTemp ) ;
    CM_Write_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate", REG_SZ, szTemp, cb, CM_REGISTRY_SOFTWARE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\w32event.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
;
;   File:       w32event.asm
;   Content:    signal a win32 event
;   History:
;    Date	By	Reason
;    ====	==	======
;    19-jul-95	craige	initial implementation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        .386p
	
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID          equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_API_SetEvent           equ 4                   ;Internal

_TEXT segment para public 'CODE' use16

        assume cs:_TEXT
	
extrn AllocCSToDSAlias: FAR
extrn FreeSelector: FAR 

	MMDEVLDR_Entry	dd	?	; the api entry point for mmdevldr
	

public _SetWin32Event
_SetWin32Event PROC FAR
        mov    dx, MMDEVLDR_API_SetEvent
	mov	ecx, [MMDEVLDR_Entry]
	jecxz	short mmdevldr_load
	jmp	[MMDEVLDR_Entry]
mmdevldr_load:
	push	dx			; save MMDEVLDR command ID
	push	di
	push	si
	push	cs
	call	AllocCStoDSAlias
	mov	si, ax
	xor	di, di			; zero ES:DI before call
	mov	es, di
	mov	ax, 1684h		; get device API entry point
	mov	bx, MMDEVLDR_Device_ID	; virtual device ID
	int	2Fh			; call WIN/386 INT 2F API
	mov	ax, es
	mov	es, si
	mov	word ptr es:MMDEVLDR_Entry, di
	mov	word ptr es:MMDEVLDR_Entry+2, ax
	push	ax
	push	si
	call	FreeSelector
	pop	ax
	or	ax, di
	pop	si
	pop	di
	pop	dx
	jz	short mmdevldr_fail
	jmp	[MMDEVLDR_Entry]
mmdevldr_fail:
	mov	ax, 1;
	retf
_SetWin32Event ENDP

_TEXT	ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\dxapi\vxd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   vxd.c

Abstract:

   This is the WDM DX mapper driver.

Author:

    smac

Environment:

   Kernel mode only


Revision History:

--*/

#include <windows.h>
#include <vmm.h>
#include "..\ddvxd\dddriver.h"


ULONG DXCheckDDrawVersion( VOID )
{
    ULONG ulRet;

    VxDCall( _DDRAW_GetVersion );
    _asm mov ulRet, eax
    return ulRet;
}


ULONG DXIssueIoctl( ULONG dwFunctionNum, VOID *lpvInBuff, ULONG cbInBuff,
                    VOID *lpvOutBuff, ULONG cbOutBuff )
{
    ULONG ulRet;

    _asm pushad
    _asm push cbOutBuff
    _asm push lpvOutBuff
    _asm push cbInBuff
    _asm push lpvInBuff
    _asm push dwFunctionNum
    VxDCall( _DDRAW_DXAPI_IOCTL );
    _asm mov ulRet, eax
    _asm pop eax
    _asm pop eax
    _asm pop eax
    _asm pop eax
    _asm pop eax
    _asm popad
    return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\dxapi\wdm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   wdm.c

Abstract:

   This is the WDM DX mapper driver.

Author:

    billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "wdm.h"
#include "dxapi.h"
#include "dxmapper.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#endif

BOOLEAN DsoundOk = FALSE;


NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Entry point for explicitely loaded stream class.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - unused.

Return Value:

   STATUS_SUCCESS

--*/
{

    UNREFERENCED_PARAMETER(DriverObject);
    return STATUS_SUCCESS;
}


ULONG
DxApiGetVersion(
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    return (DXCheckDDrawVersion());
}


ULONG
DxApi(
            IN ULONG	dwFunctionNum,
            IN PVOID	lpvInBuffer,
            IN ULONG	cbInBuffer,
            IN PVOID	lpvOutBuffer,
            IN ULONG	cbOutBuffer
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    //
    // if we haven't checked if DSOUND is present and the right version,
    // (or if we've checked before and failed) check and return error if not
    // loaded or correct version.
    //

    if (!DsoundOk) {

        if (DXCheckDDrawVersion() < DXVERSION) {

             return 0;

        } else {

             DsoundOk = TRUE;
        }
    }

    return DXIssueIoctl( dwFunctionNum, lpvInBuffer, cbInBuffer,
    	lpvOutBuffer, cbOutBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\dxapi\dxmapper.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dxmapper.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the DXMAP class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

#define DEBUG_BREAKPOINT() DbgBreakPoint()
#define DXVERSION 4

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
);


ULONG
DXCheckDDrawVersion(
);


ULONG
DXIssueIoctl(IN ULONG	dwFunctionNum,
             IN VOID*   lpvInBuffer,
             IN ULONG	cbInBuffer,
             IN VOID*   lpvOutBuffer,
             IN ULONG	cbOutBuffer
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\inc\ddd3dapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddd3dapi.h
 *  Content:	Interface between DirectDraw and Direct3D.
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id$
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02/17/96   colinmc Created this file from the obsolete d3dapi.h
 *   03/23/96   colinmc Added process termination cleanup code
 *   04/17/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   04/25/96	stevela Bug 16803: Name of Direct3D DLL changed.
 *   04/29/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _DDD3DAPI_H_
#define _DDD3DAPI_H_

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// copied from direct3d\rast\d3dif\d3dif.hpp, see note there for explanation

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

/*
 * File name of the Direct3D DLL.
 */
#define D3D_DLLNAME               "D3DIM.DLL"
#define D3DDX7_DLLNAME            "D3DIM700.DLL"

/*
 * Entry points exported by the Direct3D DLL.
 */
#define D3DCREATE_PROCNAME        "Direct3DCreate"
#define D3DCREATEDEVICE_PROCNAME  "Direct3DCreateDevice"
#define D3DCREATETEXTURE_PROCNAME "Direct3DCreateTexture"
#define D3DHALCLEANUP_PROCNAME    "Direct3D_HALCleanUp"

#ifdef USE_D3D_CSECT
    typedef HRESULT (WINAPI * D3DCreateProc)(LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#else  /* USE_D3D_CSECT */
    typedef HRESULT (WINAPI * D3DCreateProc)(LPCRITICAL_SECTION lpDDCSect,
					     LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#endif /* USE_D3D_CSECT */

typedef HRESULT (WINAPI * D3DCreateTextProc)(REFCLSID            riid,
                                             LPDIRECTDRAWSURFACE lpDDS,
					     LPUNKNOWN*          lplpD3DText,
					     IUnknown*           pUnkOuter);
typedef HRESULT (WINAPI * D3DCreateDeviceProc)(REFCLSID            riid,
                                               LPUNKNOWN           lpDirect3D,
                                               LPDIRECTDRAWSURFACE lpDDS,
                                               LPUNKNOWN*          lplpD3DDevice,
                                               IUnknown*           pUnkOuter,
                                               DWORD               dwVersion);

typedef DWORD (WINAPI * D3DGetSWRastPixFmtsProc)(DDPIXELFORMAT **ppDDPF);

typedef HRESULT (WINAPI * D3DHALCleanUpProc)(LPD3DHAL_CALLBACKS lpHALTable, DWORD dwPID);

#endif /* _DDD3DAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\winwatch.c ===
/*=========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winwatch.c
 *  Content:	16-bit window watch code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jun-95	craige	split out of DCIMAN WINWATCH.C, tweaked
 *   22-jun-95	craige	re-worked for clipper stuff
 *   02-jul-95	craige	comment out clipper notify stuff
 *
 ***************************************************************************/
#define _INC_DCIDDI
#include "ddraw16.h"
#undef _INC_DCIDDI

#ifdef CLIPPER_NOTIFY
static LPWINWATCH	lpWWList;
static HHOOK 		hNextCallWndProc;
static BOOL		bUnHook;

long FAR PASCAL _loadds CallWndProcHook(int hc, WPARAM wParam, LPARAM lParam);

extern HRGN FAR PASCAL InquireVisRgn(HDC hdc);
extern DWORD FAR PASCAL GetRegionData(HRGN hrgn, DWORD count, LPRGNDATA prd);

/*
 * doNotify
 */
void doNotify(LPWINWATCH pww, DWORD code)
{
    if( pww->lpCallback )
    {
	extern void DDAPI DD32_ClippingNotify( LPVOID, DWORD );
	DD32_ClippingNotify( pww->self32, code );
    }

} /* doNotify */

/*
 * DD16_WWOpen
 */
void DDAPI DD16_WWOpen( LPWINWATCH ptr )
{
    if( lpWWList == NULL )
    {
	DPF( 2, "Setting Windows Hook" );
	hNextCallWndProc = (HHOOK) SetWindowsHook( WH_CALLWNDPROC,
					(HOOKPROC) CallWndProcHook );
    }
    lpWWList = ptr;

} /* DD16_WWOpen */

/*
 * DD16_WWClose
 */
void DDAPI DD16_WWClose( LPWINWATCH pww, LPWINWATCH newlist )
{
    if( pww->prd16 != NULL )
    {
	LocalFree( (HLOCAL) pww->prd16 );
	pww->prd16 = NULL;
    }
    if( newlist == NULL )
    {
	DPF( 3, "Flagging to Unhook" );
	bUnHook = TRUE;
    }
    lpWWList = newlist;

} /* DD16_WWClose */

/*
 * DD16_WWNotifyInit
 */
void DDAPI DD16_WWNotifyInit(
		LPWINWATCH pww,
		LPCLIPPERCALLBACK lpcallback,
		LPVOID param )
{
    doNotify( pww, WINWATCHNOTIFY_STOP );

    pww->lpCallback = lpcallback;
    pww->lpContext = param;

    doNotify( pww, WINWATCHNOTIFY_START );
    doNotify( pww, WINWATCHNOTIFY_CHANGED );
    pww->fNotify = FALSE;

} /* DD16_WWNotifyInit */

/*
 * getWindowRegionData
 */
static DWORD getWindowRegionData( HWND hwnd, DWORD size, RGNDATA NEAR * prd )
{
    HDC 	hdc;
    DWORD	dw;

    hdc = GetDCEx( hwnd, NULL, DCX_USESTYLE | DCX_CACHE );
    dw = GetRegionData( InquireVisRgn( hdc ), size, prd );
    ReleaseDC( hwnd, hdc );
    return dw;

} /* getWindowRegionData */

/*
 * DD16_WWGetClipList
 */
DWORD DDAPI DD16_WWGetClipList(
		LPWINWATCH pww,
		LPRECT prect,
		DWORD rdsize,
		LPRGNDATA prd )
{   
    DWORD 	dw;
    DWORD    	size;

    /*
     *	we have to see if the intersect rect has changed.
     */
    if( prect )
    {
	if( !EqualRect(prect, &pww->rect) )
	{
	    pww->fDirty = TRUE;
	}
    }
    else
    {
	if( !IsRectEmpty( &pww->rect ) )
	{
	    pww->fDirty = TRUE;
	}
    }

    /*
     * if we are not dirty just return the saved RGNDATA
     */
    if( !pww->fDirty && pww->prd16 )
    {
	size = sizeof( *prd ) + (WORD) pww->prd16->rdh.nRgnSize;
	if( prd == NULL )
	{
	    return size;
	}
	if( rdsize < size )
	{
	    size = rdsize;
	}
	_fmemcpy( prd, pww->prd16, (UINT) size );
	return size;
    }

    /*
     * get the RGNDATA, growing the memory if we have to
     */
    dw = getWindowRegionData( (HWND) pww->hWnd, pww->dwRDSize, pww->prd16 );

    if( dw > pww->dwRDSize )
    {
	DPF( 2, "GetClipList: growing RGNDATA memory from %ld to %ld",pww->dwRDSize, dw);

	if( pww->prd16 != NULL )
	{
	    LocalFree((HLOCAL)pww->prd16);
	}

	/*
	 * allocate new space plus some slop
	 */
	pww->dwRDSize = dw + 8*sizeof(RECTL);
	pww->prd16 = (RGNDATA NEAR *) LocalAlloc(LPTR, (UINT)pww->dwRDSize);

	if( pww->prd16 == NULL )
	{
	    goto error;
	}

	dw = getWindowRegionData( (HWND) pww->hWnd, pww->dwRDSize, pww->prd16 );

	if( dw > pww->dwRDSize )
	{
	    goto error;
	}
    }

    /*
     *	now intersect the region with the passed rect
     */
    if( prect )
    {
	pww->rect = *prect;

	DPF( 2, "GetClipList: intersect with [%d %d %d %d]", *prect);
	ClipRgnToRect( (HWND) pww->hWnd, prect, pww->prd16 );
    }
    else
    {
	SetRectEmpty( &pww->rect );
    }

    pww->fDirty = FALSE;

    size = sizeof( *prd ) + (WORD) pww->prd16->rdh.nRgnSize;
    if( prd == NULL )
    {
	return size;
    }
    if( rdsize < size )
    {
	size = rdsize;
    }
    _fmemcpy( prd, pww->prd16, (UINT) size );
    return size;

error:
    pww->dwRDSize = 0;
    return 0;

} /* DD16_WWGetClipList */

/****************************************************************************
 *                                                                          *
 * ROUTINES TO HANDLE NOTIFICATION MESSAGES FOLLOW                          *
 *                                                                          *
 ****************************************************************************/

/*
 * handleWindowDestroyed
 */
static void handleWindowDestroy( HWND hwnd )
{
    LPWINWATCH	pww;

    DPF( 2, "*** handleWindowDestroy: hwnd=%08lx", hwnd );

again:
    for( pww=lpWWList; pww; pww=pww->next16 )
    {
	if( (hwnd == NULL) || ((HWND)pww->hWnd == hwnd) )
	{
	    extern void DDAPI DD32_WWClose( DWORD );

	    doNotify( pww, WINWATCHNOTIFY_DESTROY );
	    DD32_WWClose( (DWORD) pww->self32 );
	    goto again;
	}
    }

} /* handleWindowDestroy */

/*
 * handleWindowPosChanged
 */
static void handleWindowPosChanged( HWND hwnd )
{
    LPWINWATCH	pww;
    LPWINWATCH	next;
    RECT 	rect;
    RECT	rectT;

    DPF( 20, "*** handleWindowPosChanged: hwnd=%08lx", hwnd );

    /*
     * get the screen rect that changed
     */
    GetWindowRect( hwnd, &rect );

    /*
     * send message to each notify routine
     */
    pww = lpWWList;
    while( pww != NULL )
    {
        next = pww->next16;

	GetWindowRect((HWND)pww->hWnd, &rectT);

	if( IntersectRect( &rectT, &rectT, &rect ) )
	{
	    pww->fNotify = TRUE;
	    pww->fDirty = TRUE;
	}

	if( pww->fNotify && pww->lpCallback )
	{
	    DPF( 20, "clip changed %04X [%d %d %d %d]", (HWND)pww->hWnd, rectT);
	    doNotify( pww, WINWATCHNOTIFY_CHANGED );
	    pww->fNotify = FALSE;
	}
	pww = next;
    }

} /* handleWindowPosChanged */

/*
 * sendChanging
 */
static void sendChanging( LPRECT prect )
{
    LPWINWATCH	pww;
    LPWINWATCH	next;
    RECT 	rectT;

    pww = lpWWList;
    while( pww != NULL )
    {
        next = pww->next16;

        GetWindowRect( (HWND)pww->hWnd, &rectT );

        if( IntersectRect(&rectT, &rectT, prect) )
        {
            pww->fDirty = TRUE;

            if( pww->lpCallback )
            {
                DPF( 20, "clip changing %04X [%d %d %d %d]", (HWND)pww->hWnd, rectT);
                doNotify( pww, WINWATCHNOTIFY_CHANGING );
                pww->fNotify = TRUE;
                pww->fDirty = TRUE;
            }
        }

	pww = next;
    }

} /* sendChanging */

/*
 * handleWindowPosChanging
 */
static void handleWindowPosChanging( HWND hwnd, LPWINDOWPOS pwinpos )
{
    RECT	rect;
    RECT	rect_win;
    int		cx;
    int		cy;

    /*
     *  get the current screen rect.
     */
    DPF( 20, "*** handleWindowPosChanging: hwnd=%08lx", hwnd );
    GetWindowRect( hwnd, &rect_win);
    rect = rect_win;

    if( pwinpos == NULL )
    {
        sendChanging( &rect );
        return;
    }

    /*
     * compute the new rect
     */
    if( pwinpos->flags & SWP_NOSIZE )
    {
        cx = rect.right - rect.left;
        cy = rect.bottom - rect.top;
    }
    else
    {
        cx = pwinpos->cx;
        cy = pwinpos->cy;
    }

    if( !(pwinpos->flags & SWP_NOMOVE) )
    {
        rect.left = pwinpos->x;
        rect.top  = pwinpos->y;

        if( GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD )
        {
            ClientToScreen(GetParent(hwnd), (LPPOINT)&rect);
        }
    }

    rect.right = rect.left + cx;
    rect.bottom = rect.top + cy;

    /*
     * only send changing if we are really changing... if the new
     * rect is the same as the old rect, then check if something else
     * interesting is happening...
     */
    if( EqualRect( &rect, &rect_win ) )
    {
        if( !(pwinpos->flags & SWP_NOZORDER) )
	{
            sendChanging(&rect);
	}

        if( pwinpos->flags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW) )
	{
            sendChanging(&rect);
	}
    }
    else
    {
        sendChanging( &rect_win );
        sendChanging( &rect );
    }

} /* handleWindowPosChanging */

/*
 * checkScreenLock
 */
static void checkScreenLock( void )
{
    static BOOL bScreenLocked;
    BOOL 	is_locked;
    HDC		hdc;
    RECT 	rect;

    hdc = GetDC(NULL);
    is_locked = (GetClipBox(hdc, &rect) == NULLREGION);
    ReleaseDC(NULL, hdc);

    if( is_locked != bScreenLocked )
    {
	/*
	 * pretend the desktop window has moved, this will cause
	 * all WINWATCH handles to be set to dirty, and also be notified.
	 */
	handleWindowPosChanging( GetDesktopWindow(), NULL );
        handleWindowPosChanged( GetDesktopWindow() );
	bScreenLocked = is_locked;
    }

} /* checkScreenLock */

/*
 * CallWndProcHook
 */
long FAR PASCAL _loadds CallWndProcHook( int hc, WPARAM wParam, LPARAM lParam )
{
    /* reversed MSG minus time and pt */
    typedef struct
    {
	LONG	lParam;
	WORD	wParam;
	WORD	message;
	HWND	hwnd;
    } MSGR, FAR *LPMSGR;

    LPMSGR	lpmsg;
    LPWINDOWPOS	lpwinpos;
    long	rc;

    if( hc == HC_ACTION )
    {
	lpmsg = (MSGR FAR *)lParam;

	switch( lpmsg->message )
	{
	case WM_DESTROY:
	    handleWindowDestroy( lpmsg->hwnd );
	    break;

	case WM_WINDOWPOSCHANGING:
	    lpwinpos = (LPWINDOWPOS) lpmsg->lParam;
	    handleWindowPosChanging( lpwinpos->hwnd, lpwinpos );
	    break;

	case WM_WINDOWPOSCHANGED:
	    lpwinpos = (LPWINDOWPOS) lpmsg->lParam;
	    handleWindowPosChanged( lpwinpos->hwnd );
	    break;

	case WM_EXITSIZEMOVE:
	    checkScreenLock();
	    break;
	case WM_ENTERSIZEMOVE:
	    checkScreenLock();
	    break;
	}
    }

    rc = DefHookProc(hc, wParam, lParam, &(HOOKPROC)hNextCallWndProc);
    if( bUnHook )
    {
	DPF( 2, "Unhooking WindowsHook" );
	UnhookWindowsHook( WH_CALLWNDPROC, (HOOKPROC)CallWndProcHook );
	bUnHook = FALSE;
    }
    return rc;

} /* CallWndProcHook */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\inc\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(E,"Driv&er information")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

//
// level    meaning
//  0       Fatal error, user visible
//  1       Warning, user visible
//  2       Info, user visible
//  3       non-user visible errors/warnings
//  4       program flow
//  5       values

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * NOTE: Debug topic A is reserved and always means "API Usage"
 */

/*
 * Note for backward compatibility you can define PROF_SECT here
 * to pick up old-style DPF control from win.ini's [PROF_SECT] debug=
 * setting
 */
/* #define PROF_SECT "MyOldWININISection"*/


#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DDraw"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DDrawDebug"

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */

 /*
  * Note: At run-time, you can set
  *     [DirectX]
  *     <DPF_CONTROL_LINE>=?
  * to get a dump of DPF control string parameters, including all defined topics.
  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\inc\ids.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ids.h
 *  Content:    DirectDraw resource ids
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-sep-95  toddla  created
 *   20-sep-95	craige	add IDS_PRIMARYDISPLAY
 *
 ***************************************************************************/

// icon ids
#define ID_ICON             42

// string ids
#define IDS_TITLE           100     // dialog box title
#define IDS_DONTWORK_BPP    101     // you must be in 256 color mode or higher.
#define IDS_DONTWORK_DRV    102     // 
#define IDS_PRIMARYDISPLAY  103     // primary display ident. string
#define IDS_TIME_BOMB		104		// time bomb message string
#define IDS_TIME_BOMB_TITLE	105		// time bomb title string
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\apphack.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       apphack.h
 *  Content:	app compatiblity hacking code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-sep-96	jeffno	initial implementation after CraigE
 *
 ***************************************************************************/
typedef struct APPHACKS
{
    struct APPHACKS	*lpNext;
    LPSTR		szName;
    DWORD		dwAppId;
    DWORD		dwFlags;
} APPHACKS, *LPAPPHACKS;

extern BOOL		bReloadReg;
extern BOOL		bHaveReadReg;
extern LPAPPHACKS	lpAppList;
extern LPAPPHACKS	*lpAppArray;
extern DWORD		dwAppArraySize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\classfac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.c
 *  Content:	direct draw class factory code
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-dec-95	craige	initial implementation
 *   05-jan-96	kylej	added interface structures
 *   14-mar-96  colinmc added a class factory for clippers
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   22-oct-97  jeffno  Merge class factories, add classfac for CLSID_DirectDrawFactory2
 *
 ***************************************************************************/
#include "ddrawpr.h"

static IClassFactoryVtbl	directDrawClassFactoryVtbl;

typedef struct DDRAWCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD			dwRefCnt;
   CLSID                        TargetCLSID;
} DDRAWCLASSFACTORY, *LPDDRAWCLASSFACTORY;

#define VALIDEX_DIRECTDRAWCF_PTR( ptr ) \
	( !IsBadWritePtr( ptr, sizeof( DDRAWCLASSFACTORY )) && \
	(ptr->lpVtbl == &directDrawClassFactoryVtbl) )

/************************************************************
 *
 * DirectDraw Driver Class Factory Member Functions.
 *
 ************************************************************/

#define DPF_MODNAME "DirectDrawClassFactory::QueryInterface"

/*
 * DirectDrawClassFactory_QueryInterface
 */
STDMETHODIMP DirectDrawClassFactory_QueryInterface(
		LPCLASSFACTORY this,
		REFIID riid,
		LPVOID *ppvObj )
{
    LPDDRAWCLASSFACTORY	pcf;

    DPF( 2, A, "ClassFactory::QueryInterface" );
    ENTER_DDRAW();
    TRY
    {
	pcf = (LPDDRAWCLASSFACTORY)this;
	if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
	{
	    DPF_ERR(  "Invalid this ptr" );
	    LEAVE_DDRAW();
	    return E_FAIL;
	}

	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid object ptr" );
	    LEAVE_DDRAW();
	    return E_INVALIDARG;
	}
	*ppvObj = NULL;

	if( !VALID_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid iid ptr" );
	    LEAVE_DDRAW();
	    return E_INVALIDARG;
	}

	if( IsEqualIID(riid, &IID_IClassFactory) ||
			IsEqualIID(riid, &IID_IUnknown))
	{
	    pcf->dwRefCnt++; 
	    *ppvObj = this;
	    LEAVE_DDRAW();
	    return S_OK;
	}
	else
	{ 
	    DPF( 0, "E_NOINTERFACE" );
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

} /* DirectDrawClassFactory_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::AddRef"

/*
 * DirectDrawClassFactory_AddRef
 */
STDMETHODIMP_(ULONG) DirectDrawClassFactory_AddRef( LPCLASSFACTORY this )
{
    LPDDRAWCLASSFACTORY pcf;

    ENTER_DDRAW();
    TRY
    {
	pcf = (LPDDRAWCLASSFACTORY)this;
	if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
	{
	    DPF_ERR(  "Invalid this ptr" );
	    LEAVE_DDRAW();
	    return (ULONG)E_FAIL;
	}
	pcf->dwRefCnt++;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return (ULONG)E_INVALIDARG;
    }

    DPF( 5, "ClassFactory::AddRef, dwRefCnt=%ld", pcf->dwRefCnt );
    LEAVE_DDRAW();
    return pcf->dwRefCnt;

} /* DirectDrawClassFactory_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::Release"

/*
 * DirectDrawClassFactory_Release
 */
STDMETHODIMP_(ULONG) DirectDrawClassFactory_Release( LPCLASSFACTORY this )
{
    LPDDRAWCLASSFACTORY	pcf;

    ENTER_DDRAW();
    TRY
    {
	pcf = (LPDDRAWCLASSFACTORY)this;
	if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
	{
	    DPF_ERR(  "Invalid this ptr" );
	    LEAVE_DDRAW();
	    return (ULONG)E_FAIL;
	}
	pcf->dwRefCnt--;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return (ULONG)E_INVALIDARG;
    }
    DPF( 5, "ClassFactory::Release, dwRefCnt=%ld", pcf->dwRefCnt );

    if( pcf->dwRefCnt != 0 )
    {
	LEAVE_DDRAW();
	return pcf->dwRefCnt;
    }
    MemFree( pcf );
    LEAVE_DDRAW();
    return 0;

} /* DirectDrawClassFactory_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::CreateInstance"

/*
 * DirectDrawClassFactory_CreateInstance
 *
 * Creates an instance of a DirectDraw object
 */
STDMETHODIMP DirectDrawClassFactory_CreateInstance(
		LPCLASSFACTORY this,
		LPUNKNOWN pUnkOuter,
		REFIID riid,
		LPVOID *ppvObj
)
{
    HRESULT			hr = DD_OK;
    LPDDRAWI_DIRECTDRAW_INT	pdrv_int = NULL;
    LPDDRAWCLASSFACTORY		pcf;
    LPDIRECTDRAWCLIPPER               pclipper;

    DPF( 2, A, "ClassFactory::CreateInstance" );

    pcf = (LPDDRAWCLASSFACTORY) this;
    if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
    {
	DPF_ERR( "Invalid this ptr" );
	return E_INVALIDARG;
    }

    if( !VALIDEX_IID_PTR( riid ) )
    {
	DPF_ERR( "Invalid iid ptr" );
	return E_INVALIDARG;
    }

    if( !VALIDEX_PTR_PTR( ppvObj ) )
    {
	DPF_ERR( "Invalid object ptr" );
	return E_INVALIDARG;
    }

#ifdef POSTPONED
    if (pUnkOuter && !IsEqualIID(riid,&IID_IUnknown))
    {
        DPF_ERR("Can't aggregate with a punkouter != IUnknown");
        return CLASS_E_NOAGGREGATION;
    }
#else
    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }
#endif

    /*
     * is DirectDraw supported on this system?
     */
    if( !DirectDrawSupported( TRUE ) )
    {
	DPF_ERR( "DirectDraw not supported!" );
	return E_FAIL;
    }

    /*
     * go build an DirectDraw interface
     *
     * NOTE: We provide the "uninitialized callback table
     * to prevent the use of this object for anything other
     * than AddRef(), Release() or Initialized().
     */
    ENTER_DDRAW();
    if ( IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDraw ) ||
         IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDraw7 ) )
    {
        if ( IsEqualIID(riid, &IID_IUnknown) )
        {
            /*
             * If we're aggregated, then we don't need to worry about the IUnknown being
             * the runtime identity (we are hidden inside the outer, since it's the one
             * that will field the QI for IUnknown).
             * This means we can point an aggregated interface at the nondelegating
             * unknowns
             */
            if (pUnkOuter)
            {
#ifdef POSTPONED
                pdrv_int = NewDriverInterface( NULL, &ddUninitNonDelegatingUnknownCallbacks );
#else
                pdrv_int = NewDriverInterface( NULL, &ddUninitCallbacks );
#endif
            }
            else
            {
                /*
                 * Not aggregated, so the IUnknown has to have the same pointer value
                 * as the IDirectDraw interfaces, since QI always simply returns the
                 * this ptr when asked for IUnknown
                 * (Note this actually doesn't work right now because Initalize will swap
                 * vtbls).
                 */
                pdrv_int = NewDriverInterface( NULL, &ddUninitCallbacks );
            }
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw) )
        {
            pdrv_int = NewDriverInterface( NULL, &ddUninitCallbacks );
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw2) )
        {
            pdrv_int = NewDriverInterface( NULL, &dd2UninitCallbacks );
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw4) )
        {
            pdrv_int = NewDriverInterface( NULL, &dd4UninitCallbacks );
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw7) )
        {
            pdrv_int = NewDriverInterface( NULL, &dd7UninitCallbacks );
        }


        if( NULL == pdrv_int )
        {
	    DPF( 0, "Call to NewDriverInterface failed" );
	    hr = E_OUTOFMEMORY;
        }

#ifdef POSTPONED
        /*
         * 
         */
        if (pUnkOuter)
        {
            pdrv_int->lpLcl->pUnkOuter = pUnkOuter;
        }
        else
        {
            pdrv_int->lpLcl->pUnkOuter = (IUnknown*) &UninitNonDelegatingIUnknownInterface;
        }
#endif

        pdrv_int->dwIntRefCnt--;
        pdrv_int->lpLcl->dwLocalRefCnt--;

        /*
         * NOTE: We call DD_QueryInterface() explicitly rather than
         * going through the vtable as the "uninitialized" interface
         * we are using here has QueryInterface() disabled.
         */
        if (SUCCEEDED(hr))
        {
            hr = DD_QueryInterface( (LPDIRECTDRAW) pdrv_int, riid, ppvObj );
            if( FAILED( hr ) )
            {
                DPF( 0, "Could not get interface id, hr=%08lx", hr );
                RemoveLocalFromList( pdrv_int->lpLcl );
                RemoveDriverFromList( pdrv_int, FALSE );
	        MemFree( pdrv_int->lpLcl );
                MemFree( pdrv_int );
            }
            else
            {
                DPF( 5, "New Interface=%08lx", *ppvObj );
            }
        }
    }
    else
    if ( IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDrawClipper ) )
    {
        /*
         * Build a new clipper.
         *
         * Unlike the DirectDraw driver objects, clippers create via
         * CoCreateInstance() are born pretty much initialized. The only
         * thing initialization might actually do is to reparent the
         * clipper to a given driver object. Otherwise all Initialize()
         * does is set a flag.
         */
        hr = InternalCreateClipper( NULL, 0UL, &pclipper, NULL, FALSE, NULL, NULL );
        if( FAILED( hr ) )
        {
	    DPF_ERR( "Failed to create the new clipper interface" );
        }

        /*
         * NOTE: Bizarre code fragment below works as follows:
         *
         * 1) InternalCreateClipper() returns a clipper with a reference count
         *    of 1 for each of the interface, local and global objects.
         * 2) QueryInterface() can do one of two things. It can either just return
         *    the same interface in which case the interface, local and global
         *    objects all get a reference count of 2 or it can return a different
         *    interface in which case both interfaces have a reference count of
         *    1 and the local and global objects have a reference count of 2.
         * 3) The immediate Release() following the QueryInterface() will in either
         *    case decrement the reference counts of the local and global objects
         *    to 1 (as required). If the same interface was returned by
         *    QueryInterface() then its reference count is decremented to 1 (as
         *    required). If a different interface was returned then the old
         *    interface is decremented to zero and it is released (as required).
         *    Also, if QueryInterface() fails, the Release() will decrement all
         *    the reference counts to 0 and the object will be freed.
         *
         * So it all makes perfect sense - really! (CMcC)
         *
         * ALSO NOTE: We call DD_Clipper_QueryInterface() explicitly rather than
         * going through the vtable as the "uninitialized" interface we are using
         * here has QueryInterface() disabled.
         */
        hr = DD_Clipper_QueryInterface( pclipper, riid, ppvObj );
        DD_Clipper_Release( pclipper );
        if( FAILED( hr ) )
        {
            DPF( 0, "Could not get interface id, hr=%08lx", hr );
        }
        else
        {
            DPF( 5, "New Interface=%08lx", *ppvObj );
        }
    }
#ifdef POSTPONED
    else if ( IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDrawFactory2) )
    {
        LPDDFACTORY2 lpDDFac = NULL;
        /*
         * Build a new DirectDrawFactory2
         * This returns an object, with refcnt=0. The QI then bumps that to 1.
         */
        hr = InternalCreateDDFactory2( &lpDDFac, pUnkOuter );
        if( SUCCEEDED( hr ) )
        {
            /*
             * The QI should catch that the vtable is the ddrawfactory2 vtable,
             * and simply bump the addref on the passed-in pointer. This means we
             * won't orphan the pointer created by InternalCreateDDFactory2.
             */
            hr = ((IUnknown*)lpDDFac)->lpVtbl->QueryInterface( (IUnknown*)lpDDFac, riid, ppvObj );
            if( SUCCEEDED( hr ) )
            {
                DPF( 5, "New DDFactory2 Interface=%08lx", *ppvObj );
            }
            else
            {
                MemFree(lpDDFac);
                DPF( 0, "Could not get DDFactory2 interface id, hr=%08lx", hr );
            }
        }
        else
        {
	    DPF_ERR( "Failed to create the new dd factory2 interface" );
        }
    }
#endif
    LEAVE_DDRAW();
    return hr;

} /* DirectDrawClassFactory_CreateInstance */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::LockServer"

/*
 * DirectDrawClassFactory_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP DirectDrawClassFactory_LockServer(
                LPCLASSFACTORY this,
                BOOL fLock
)
{
    HRESULT		hr;
    HANDLE		hdll;
    LPDDRAWCLASSFACTORY	pcf;

    pcf = (LPDDRAWCLASSFACTORY) this;
    if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
    {
	DPF_ERR( "Invalid this ptr" );
	return E_INVALIDARG;
    }

    /*
     * call CoLockObjectExternal
     */
    DPF( 2, A, "ClassFactory::LockServer" );
    hr = E_UNEXPECTED;
    hdll = LoadLibrary( "OLE32.DLL" );
    if( hdll != NULL )
    {
	HRESULT (WINAPI * lpCoLockObjectExternal)(LPUNKNOWN, BOOL, BOOL );
	lpCoLockObjectExternal = (LPVOID) GetProcAddress( hdll, "CoLockObjectExternal" );
	if( lpCoLockObjectExternal != NULL )
	{
	    hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
	}
	else
	{
	    DPF_ERR( "Error! Could not get procaddr for CoLockObjectExternal" );
	}
    }
    else
    {
	DPF_ERR( "Error! Could not load OLE32.DLL" );
    }

    /*
     * track the number of server locks total
     */
    if( SUCCEEDED( hr ) )
    {
	ENTER_DDRAW();
	if( fLock )
	{
	    dwLockCount++;
	}
	else
	{
	    #ifdef DEBUG
		if( (int) dwLockCount <= 0 )
		{
		    DPF( 0, "Invalid LockCount in LockServer! (%d)", dwLockCount );
		    DEBUG_BREAK();
		}
	    #endif
	    dwLockCount--;
	}
	DPF( 5, "LockServer:dwLockCount =%ld", dwLockCount );
	LEAVE_DDRAW();
    }
    return hr;

} /* DirectDrawClassFactory_LockServer */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::CreateInstance"


static IClassFactoryVtbl directDrawClassFactoryVtbl =
{
        DirectDrawClassFactory_QueryInterface,
        DirectDrawClassFactory_AddRef,
        DirectDrawClassFactory_Release,
        DirectDrawClassFactory_CreateInstance,
        DirectDrawClassFactory_LockServer
};

#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
HRESULT WINAPI DllGetClassObject(
		REFCLSID rclsid,
		REFIID riid,
		LPVOID *ppvObj )
{
    LPDDRAWCLASSFACTORY	pcf;
    HRESULT		hr;

    /*
     * validate parms
     */
    if( !VALIDEX_PTR_PTR( ppvObj ) )
    {
	DPF_ERR( "Invalid object ptr" );
	return E_INVALIDARG;
    }
    *ppvObj = NULL;
    if( !VALIDEX_IID_PTR( rclsid ) )
    {
	DPF_ERR( "Invalid clsid ptr" );
	return E_INVALIDARG;
    }
    if( !VALIDEX_IID_PTR( riid ) )
    {
	DPF_ERR( "Invalid iid ptr" );
	return E_INVALIDARG;
    }

    /*
     * is this one our class ids?
     */
    if( IsEqualCLSID( rclsid, &CLSID_DirectDraw ) ||
        IsEqualCLSID( rclsid, &CLSID_DirectDraw7 ) ||
        IsEqualCLSID( rclsid, &CLSID_DirectDrawClipper ) ||
        IsEqualCLSID( rclsid, &CLSID_DirectDrawFactory2 ))
    {
	/*
	 * It's the DirectDraw driver class ID.
	 */

	/*
	 * only allow IUnknown and IClassFactory
	 */
	if( !IsEqualIID( riid, &IID_IUnknown ) &&
    	    !IsEqualIID( riid, &IID_IClassFactory ) )
	{
	    return E_NOINTERFACE;
	}

	/*
	 * create a class factory object
	 */
	ENTER_DDRAW();
	pcf = MemAlloc( sizeof( DDRAWCLASSFACTORY ) );
	if( pcf == NULL )
	{
	    LEAVE_DDRAW();
	    return E_OUTOFMEMORY;
	}

	pcf->lpVtbl = &directDrawClassFactoryVtbl;
	pcf->dwRefCnt = 0;
        memcpy(&pcf->TargetCLSID,rclsid,sizeof(*rclsid));
	#pragma message( REMIND( "Do we need to have a refcnt of 0 after DllGetClassObject?" ))
	hr = DirectDrawClassFactory_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
	if( FAILED( hr ) )
	{
	    MemFree( pcf );
	    *ppvObj = NULL;
	    DPF( 0, "QueryInterface failed, rc=%08lx", hr );
	}
	else
	{
	    DPF( 5, "DllGetClassObject succeeded, pcf=%08lx", pcf );
	}
	LEAVE_DDRAW();
	return hr;
    }
    else
    {
        return E_FAIL;
    }

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
HRESULT WINAPI DllCanUnloadNow( void )
{
    HRESULT	hr;

    DPF( 2, A, "DllCanUnloadNow called" );
    hr = S_FALSE;
    ENTER_DDRAW();

    /*
     * Only unload if there are no driver objects and no global
     * clipper objects (there won't be any local clipper objects
     * as they are destroyed by their driver so the check on driver
     * object handles them).
     */
    if( ( lpDriverObjectList  == NULL ) &&
        ( lpDriverLocalList == NULL ) &&
	( lpGlobalClipperList == NULL ) )
    {
	if( dwLockCount == 0 )
	{
	    DPF( 3, "It is OK to unload" );
	    hr = S_OK;
	}
    }
    LEAVE_DDRAW();
    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\cliprgn.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cliprgn.c
 *  Content:	Clip a region to a rectangle
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   23-jun-95	craige	initial implementation
 *   05-jul-95	kylej	change ClipRgnToRect to assume that the clipping
 *			rect is in screen space coordinates instead of 
 *                      window coordinates.
 *   05-feb-97	ketand	Remove the previous optimization that assumed that
 *			GetVisRgn was smaller than or equal to the ClientRect
 *			Replace with a different faster optimization.
 *
 ***************************************************************************/
#include "ddrawpr.h"

/*
 * ClipRgnToRect
 */
void ClipRgnToRect( LPRECT prect, LPRGNDATA prd )
{
    RECT	rect;
    int 	i;
    int		n;
    LPRECTL	prectlD;
    LPRECTL	prectlS;


    if( prect == NULL || prd == NULL )
    {
	return;
    }

    // If the bounding rect of the region is exactly equal to
    // or inside of the Restricting rect then we know
    // we don't have to do any more work.
    //
    // In the common case, the rcBound will be the client
    // area of a window and so will the restricting rect.
    if( prect->top    <= prd->rdh.rcBound.top &&
	prect->bottom >= prd->rdh.rcBound.bottom &&
	prect->left   <= prd->rdh.rcBound.left &&
	prect->right  >= prd->rdh.rcBound.right)
    {
	return;
    }
    
    // If the bounding rect doesn't equal the prect then
    // we might have to do some clipping.
    rect = *prect;

    prectlD = (LPRECTL) prd->Buffer;
    prectlS = (LPRECTL) prd->Buffer;
    n = (int)prd->rdh.nCount;

    for( i=0; i<n; i++ )
    {
	prectlD->left  = max(prectlS->left, rect.left);
	prectlD->right = min(prectlS->right, rect.right);
	prectlD->top   = max(prectlS->top, rect.top);
	prectlD->bottom= min(prectlS->bottom, rect.bottom);

	prectlS++;

	if( (prectlD->bottom - prectlD->top <= 0) ||
	    (prectlD->right - prectlD->left <= 0) )
	{
	    prd->rdh.nCount--;	// dont count empty rect.
	}
	else
	{
	    prectlD++;
	}
    }

    return;

} /* ClipRgnToRect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddagp.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#define PAGE_COUNT(Bytes) (((Bytes) + (PAGE_SIZE - 1)) / PAGE_SIZE)
#define PAGE_ROUND(Bytes) (((Bytes) + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1))

//
// AGP memory policy parameters.
//

// Maximum amount of AGP memory to use.  Currently 32MB.
// Recomputed when the DirectDraw interface is created.
DWORD dwAGPPolicyMaxBytes = 32 * 1024 * 1024;

// Amount of memory to commit when a commit is needed.
// Reset when the DirectDraw interface is created.
DWORD dwAGPPolicyCommitDelta = DEFAULT_AGP_COMMIT_DELTA;

#if DBG
// Internal tracking of current AGP memory size.
DWORD dwAGPPolicyCurrentBytes = 0;
#endif

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  PVOID *ppvReservation )
{
    DWORD dwNumPages;
    
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != pfpLinStart );
    DDASSERT( NULL                 != pliDevStart );
    DDASSERT( NULL                 != ppvReservation );

    /*
     * The first thing to do is make sure our AGP policy is respected.
     * The easy way to do that is to limit how much we reserve...
     */
    dwSize = min(dwSize, dwAGPPolicyMaxBytes);

    /*
     * DDraw will attempt to reserve space for the heap, but if that fails,
     * we'll ratchet down the reservation by 4 megs at a time until it works.
     * This is a defensive move that should prevent a few problems for AGP
     * aware drivers on memphis: they cannot know how large an aperture to
     * claim (cuz of weird OS restraints like the fact that
     * half the ap is reserved for UC and the other half WC etc, plus
     * random BIOS limitations.
     * We arbitrarily decide that 4 megs is the legal minimum.
     */
    while (dwSize >= 0x400000 )
    {
        dwNumPages = PAGE_COUNT(dwSize);
        if ( OsAGPReserve( hdev, dwNumPages, fIsUC, fIsWC,
                           pfpLinStart, pliDevStart, ppvReservation ) )
        {
            return dwSize;
        }

        /*
         * If the driver asked for WC but the processor doesn't support WC,
         * then OsAGPReserve will have failed. The best thing to do is try
         * again with UC...
         * If the aperture size is the problem, then this will still fail
         * and we'll back off and try again WC.
         */
        if (fIsWC)
        {
            if ( OsAGPReserve( hdev, dwNumPages, TRUE, FALSE,
                               pfpLinStart, pliDevStart, ppvReservation ) )
            {
                return dwSize;
            }
        }

        /*
         * Subtract 4 megs and try again
         */
        dwSize -= 0x400000;
    }

    return 0;
} /* AGPReserve */

BOOL AGPCommit( HANDLE hdev, PVOID pvReservation,
                DWORD dwOffset, DWORD dwSize )
{
    DWORD         dwFirstPage;
    DWORD         dwLastPage;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( NULL                 != pvReservation );
    DDASSERT( 0UL                  != dwSize );

#if DBG
    if( (dwAGPPolicyCurrentBytes + dwSize ) > dwAGPPolicyMaxBytes )
    {
        VDPF(( 0, V, "Maximum number of AGP bytes exceeded. Failing commit" ));
        return FALSE;
    }
#endif

    /*
     * If the start lies in the middle of a page then we assume that the
     * page it lies in has already been committed.
     */
    dwFirstPage = PAGE_COUNT(dwOffset);
    
    /*
     * We assume that if the end lies in the middle of the page then that
     * page has not already been committed.
     */
    dwLastPage = PAGE_COUNT(dwOffset + dwSize);
    
    if( ( dwLastPage == dwFirstPage) ||
        OsAGPCommit( hdev, pvReservation,
                     dwFirstPage, dwLastPage - dwFirstPage ) )
    {
#if DBG
        dwAGPPolicyCurrentBytes += dwSize;
#endif
	return TRUE;
    }
    else
    {
	return FALSE;
    }
} /* AGPCommit */

BOOL AGPDecommitAll( HANDLE hdev, PVOID pvReservation, DWORD dwSize )
{
    DWORD dwNumPages;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );
    DDASSERT( 0UL                  != dwSize );

#if DBG
    /*
     * Can't do much if this baby fails so just decrement the page
     * count.
     */
    DDASSERT( dwAGPPolicyCurrentBytes >= dwSize );
    dwAGPPolicyCurrentBytes -= dwSize;
#endif

    return OsAGPDecommitAll( hdev, pvReservation, PAGE_COUNT(dwSize) );
} /* AGPDecommitAll */

BOOL AGPFree( HANDLE hdev, PVOID pvReservation )
{
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );

    return OsAGPFree( hdev, pvReservation );
} /* AGPFree */

#ifndef __NTDDKCOMP__

#define OSR2_POINT_0_BUILD_NUMBER           1111
#define OSR2_BUILD_NUMBER_A                 1212
#define OSR2_BUILD_NUMBER_B                 1214

/*
 * Does this operating system understand AGP?
 *
 * NOTE: There may be a better way of determining this but for now I will
 * assumed that Memphis and NT 5.0 class operating systems are AGP aware.
 *
 * NOTE: The VXD handle is (obviously) only important on Win95. On NT
 * NULL should be passed.
 */
BOOL OSIsAGPAware( HANDLE hvxd )
{
    OSVERSIONINFO osvi;
    BOOL          success;
    BOOL          fIsVMMAGPAware;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    success = GetVersionEx(&osvi);
    DDASSERT( success );

    if( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {
	DPF( 5, "Major version = %d", osvi.dwMajorVersion );
	DPF( 5, "Minor version = %d", osvi.dwMinorVersion );
	DPF( 5, "Build number  = %d", LOWORD(osvi.dwBuildNumber) );

	if( ( osvi.dwMajorVersion > 4UL ) ||
	    ( ( osvi.dwMajorVersion == 4UL ) &&
	      ( osvi.dwMinorVersion >= 10UL ) &&
	      ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
	{
	    /*
	     * Memphis or greater version of Win95. AGP support assumed.
	     */
	    DPF( 2, "AGP aware Windows95 detected. Enabling AGP" );
	    return TRUE;
	}
	else if( ( osvi.dwMajorVersion == 4UL ) &&
	         ( osvi.dwMinorVersion == 0UL ) &&
		 ( ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_A ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_B ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_POINT_0_BUILD_NUMBER ) ) )
	{
	    DPF( 3, "Win95 OSR 2.1 detected. Checking VMM for AGP services" );

	    fIsVMMAGPAware = FALSE;
	    #ifdef    WIN95
		DDASSERT( INVALID_HANDLE_VALUE != hvxd );
		fIsVMMAGPAware = vxdIsVMMAGPAware( hvxd );
	    #else  /* WIN95 */
		/*
		 * Should never occur as this would mean we are running an NT
		 * binary on a 95 system.
		 */
		DDASSERT(FALSE);
	    #endif /* WIN95 */

	    if( fIsVMMAGPAware )
	    {
		/*
		 * AGP services are present in the VMM. Enable AGP.
		 */
		DPF( 2, "OSR 2.1 VMM has AGP services. Enabled AGP" );
		return TRUE;
	    }
	    else
	    {
		/*
		 * No AGP services. Disable AGP.
		 */
		DPF( 2, "OSR 2.1 VMM has no AGP services. AGP not available" );
		return FALSE;
	    }
	}
	else
	{
	    DPF( 2, "Win95 Gold, OSR 1.0 or OSR 2.0 detected. No AGP support available" );
	    return FALSE;
	}

    }
    else if( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        /*
         * AGP support assumed in NT 5.0 and above.
         */
        if( osvi.dwMajorVersion >= 5UL )
        {
            DPF( 2, "AGP aware WindowsNT detected. Enabling AGP" );
            return TRUE;
        }
    }

    /*
     * If we got to here we failed the AGP aware test.
     */
    DPF( 1, "Operating system is not AGP aware. Disabling AGP" );
    return FALSE;
} /* OSIsAGPAware */

#endif // __NTDDKCOMP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddagp9x.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp9x.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw on Win9x
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifdef WIN95

/*
 * We define the page lock IOCTLs here so that we don't have to include ddvxd.h.
 * These must match the corresponding entries in ddvxd.h
 */
#define DDVXD_IOCTL_GARTRESERVE             57
#define DDVXD_IOCTL_GARTCOMMIT              58
#define DDVXD_IOCTL_GARTUNCOMMIT            59
#define DDVXD_IOCTL_GARTFREE                60
#define DDVXD_IOCTL_GARTMEMATTRIBUTES       61
#define DDVXD_IOCTL_ISVMMAGPAWARE           68

#define PAGE_SIZE 4096
#define PAGE_COUNT(Bytes) (((Bytes) + (PAGE_SIZE - 1)) / PAGE_SIZE)
#define PAGE_ROUND(Bytes) (((Bytes) + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1))

#undef DPF_MODNAME
#define DPF_MODNAME	"OsAGPReserve"

/*
 * OsAGPReserve
 *
 * Reserve a portion of the address space for use as an AGP aperature.
 */
BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                    FLATPTR *lpfpGARTLin, LARGE_INTEGER *pliGARTDev,
                   PVOID *ppvReservation )
{
    DWORD  cbReturned;
    BOOL   rc;
    struct GRInput
    {
	DWORD  dwNumPages; /* Number of bytes of address space to reserve */
	DWORD  dwAlign;    /* Alignment of start of address space         */
	DWORD  fIsUC;      /* Address range should be uncachable          */
	DWORD  fIsWC;      /* Address range should be write combining     */
    } grInput;
    struct GROutput
    {
	FLATPTR fpGARTLin; /* Linear address of reserved space            */
	FLATPTR fpGARTDev; /* High physical address of reserved space     */
    } grOutput;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != dwNumPages );
    DDASSERT( NULL                 != lpfpGARTLin );
    DDASSERT( NULL                 != pliGARTDev );

    *lpfpGARTLin = 0UL;
    pliGARTDev->QuadPart = 0UL;

    grInput.dwNumPages = dwNumPages;
    grInput.dwAlign    = 0;      /* Hard code alignment of 4K for now       */
    grInput.fIsUC      = fIsUC;
    grInput.fIsWC      = fIsWC;

    DPF( 5, "OsGARTReserve" );
    DPF( 5, "Number of pages to reserve = 0x%08x", grInput.dwNumPages );
    DPF( 5, "Uncachable                 = 0x%08x", fIsUC );
    DPF( 5, "Write combining            = 0x%08x", fIsWC );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTRESERVE,
			  &grInput,
			  sizeof( grInput ),
			  &grOutput,
			  sizeof( grOutput ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(grOutput) );

	if( 0UL == grOutput.fpGARTLin )
	{
	    DPF(2, "Linear address of GART range is NULL. Call failed, reducing size by 4 Meg" );
	    rc = FALSE;
	}
	else
	{
	    *lpfpGARTLin = grOutput.fpGARTLin;
	    *ppvReservation = (LPVOID)grOutput.fpGARTLin;
	    pliGARTDev->QuadPart = grOutput.fpGARTDev;
            DPF( 5,"returned GARTLin: %08x",*lpfpGARTLin);
            DPF( 5,"returned GARTDev: %08x",pliGARTDev->QuadPart);
	}
    }
    else
    {
	DPF( 0, "Could not reserve 0x%08x pages of GART space", grInput.dwNumPages );
    }

    return rc;
} /* OsAGPReserve */

#undef DPF_MODNAME
#define DPF_MODNAME	"OsAGPCommit"

/*
 * OsAGPCommit
 *
 * Commit memory to the given portion of a previously reserved GART
 * range
 */
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages )
{
    DWORD  cbReturned;
    BOOL   rc;
    struct GCInput
    {
	FLATPTR fpGARTLin;    /* Start of GART range reserved previously                      */
	DWORD   dwPageOffset; /* Offset from start of GART range of first page to be commited */
	DWORD   dwNumPages;   /* Number of pages to be commited                               */
	DWORD   dwFlags;      /* Flags (zero init)                                            */
    } gcInput;
    struct GCOutput
    {
	BOOL    fSuccess;  /* Result of GARTCommit                                     */
	FLATPTR fpGARTDev; /* Device address of memory commited                        */
    } gcOutput;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );

    gcInput.fpGARTLin    = (FLATPTR) pvReservation;
    gcInput.dwFlags      = 0;

    /*
     * If the start lies in the middle of a page then we assume that the
     * page it lies in has already been commited.
     */
    gcInput.dwPageOffset = dwPageOffset;

    /*
     * We assume that if the end lies in the middle of the page then that
     * page has not already been commited.
     */
    gcInput.dwNumPages = dwNumPages;
    if( 0UL == gcInput.dwNumPages )
    {
	DPF( 0, "All necessary GART pages already commited. Done." );
	return TRUE;
    }

    DPF( 5, "OsGARTCommit" );
    DPF( 5, "GART linear start address                   = 0x%08x", pvReservation );
    DPF( 5, "Offset from start of reserved address space = 0x%08x", gcInput.dwPageOffset );
    DPF( 5, "Number of pages to commit                   = 0x%08x", gcInput.dwNumPages );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTCOMMIT,
			  &gcInput,
			  sizeof( gcInput ),
			  &gcOutput,
			  sizeof( gcOutput ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(gcOutput) );

	if( !gcOutput.fSuccess )
	{
	    DPF_ERR( "Attempt to commit GART memory failed. Insufficient memory" );
	    rc = FALSE;
	}
	else
	{
	    DDASSERT( 0UL != gcOutput.fpGARTDev );
	}
    }
    else
    {
	DPF( 0, "Could not commit 0x%08x pages of GART space", gcInput.dwNumPages );
    }

    return rc;
} /* OsAGPCommit */

#undef DPF_MODNAME
#define DPF_MODNAME	"OsAGPDecommitAll"

/*
 * OsAGPDecommitAll
 *
 * Decommit a range of GART space previously commited with GARTCommit
 */
BOOL OsAGPDecommitAll( HANDLE hdev, PVOID pvReservation, DWORD dwNumPages )
{
    DWORD  dwDummy;
    DWORD  cbReturned;
    BOOL   rc;
    struct GUInput
    {
	FLATPTR fpGARTLin;    /* Start of GART range reserved previously                    */
	DWORD   dwPageOffset; /* Offset from start of GART range of first page to decommit  */
	DWORD   dwNumPages;   /* Number of pages to decommit                                */
    } guInput;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );
    DDASSERT( 0UL                  != dwNumPages );

    guInput.fpGARTLin    = (FLATPTR) pvReservation;
    guInput.dwPageOffset = 0;
    guInput.dwNumPages   = dwNumPages;

    DPF( 5, "OsGARTUnCommit" );
    DPF( 5, "GART linear start address                   = 0x%08x", pvReservation );
    DPF( 5, "Offset from start of reserved address space = 0x%08x", guInput.dwPageOffset );
    DPF( 5, "Number of pages to decommit                 = 0x%08x", guInput.dwNumPages );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTUNCOMMIT,
			  &guInput,
			  sizeof( guInput ),
			  &dwDummy,
			  sizeof( dwDummy ),
			  &cbReturned,
			  NULL );

    #ifdef DEBUG
	if( rc )
	{
	    DDASSERT( cbReturned == sizeof(dwDummy) );
	}
	else
	{
	    DPF( 0, "Could not decommit 0x%08x pages of GART space", guInput.dwNumPages );
	}
    #endif /* DEBUG */

    return rc;
} /* OsAGPDecommitAll */

#undef DPF_MODNAME
#define DPF_MODNAME	"OsGARTFree"

/*
 * OsAGPFree
 *
 * Free a GART range previously reserved with GARTReserve
 */
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation )
{
    DWORD  dwDummy;
    DWORD  cbReturned;
    BOOL   rc;
    LPVOID fpGARTLin = pvReservation;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != fpGARTLin );

    DPF( 5, "OsGARTFree" );
    DPF( 5, "GART linear start address = 0x%08x", fpGARTLin );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTFREE,
			  &fpGARTLin,
			  sizeof( fpGARTLin ),
			  &dwDummy,
			  sizeof( dwDummy ),
			  &cbReturned,
			  NULL );

    #ifdef DEBUG
	if( rc )
	{
	    DDASSERT( cbReturned == sizeof(dwDummy) );
	}
	else
	{
	    DPF( 0, "Could not free GART space at 0x%08x", fpGARTLin );
	}
    #endif /* DEBUG */

    return rc;
} /* OsAGPFree */

// Not currently used.
#if 0

#undef DPF_MODNAME
#define DPF_MODNAME	"OsGARTMemAttributes"

/*
 * OsGARTMemAttributes
 *
 * Get the memory attributes of a GART memory range previously allocated
 * with GARTReserve
 */
BOOL OsGARTMemAttributes( HANDLE hdev, FLATPTR fpGARTLin, LPDWORD lpdwAttribs )
{
    DWORD  cbReturned;
    BOOL   rc;
    DWORD  dwAttribs;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != fpGARTLin );
    DDASSERT( NULL                 != lpdwAttribs );

    *lpdwAttribs = 0UL;

    DPF( 5, "OsGARTMemAttributes" );
    DPF( 5, "GART linear start address = 0x%08x", fpGARTLin );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTMEMATTRIBUTES,
			  &fpGARTLin,
			  sizeof( fpGARTLin ),
			  &dwAttribs,
			  sizeof( dwAttribs ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(dwAttribs) );

	*lpdwAttribs = dwAttribs;
    }
    else
    {
	DPF( 0, "Could not get the memory attributes of GART space at 0x%08x", fpGARTLin );
    }

    return rc;
} /* OsGARTMemAttributes */

#endif // Unused code.

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdVMMIsAGPAware"

/*
 * vxdIsVMMAGPAware
 *
 * Does the VMM we are running on export the AGP services?
 */
BOOL vxdIsVMMAGPAware( HANDLE hdev )
{
    DWORD  cbReturned;
    BOOL   rc;
    BOOL   fIsAGPAware;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );

    DPF( 4, "vxdIsVMMAGPAware" );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_ISVMMAGPAWARE,
			  NULL,
			  0UL,
			  &fIsAGPAware,
			  sizeof( fIsAGPAware ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(fIsAGPAware) );
	return fIsAGPAware;
    }
    else
    {
	DPF_ERR( "Could not determine if OS is AGP aware. Assuming it's not" );
	return FALSE;
    }
} /* vxdIsVMMAGPAware */

#endif // WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\apphack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       apphack.c
 *  Content:	app compatiblity hacking code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-may-96	craige	initial implementation
 *   28-sep-96	craige	allow binary data in registry (f*cking .inf
 *			can't put in dword into the registry)
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "apphack.h"

#define STRCMP	lstrcmpi


static int sortRtn( LPAPPHACKS *p1, LPAPPHACKS *p2 )
{
    return STRCMP( (*p1)->szName, (*p2)->szName );
}

static int searchRtn( LPSTR key, LPAPPHACKS *p2 )
{
    return STRCMP( key, (*p2)->szName );
}

__inline static BOOL fileRead( HANDLE hfile, void *data, int len )
{
    DWORD	len_read;

    if( !ReadFile( hfile,  data, (DWORD) len, &len_read, NULL ) ||
    	len_read != (DWORD) len )
    {
	return FALSE;
    }
    return TRUE;

} /* fileRead */

__inline static BOOL fileSeek( HANDLE hfile, DWORD offset )
{
    if( SetFilePointer( hfile, offset, NULL, FILE_BEGIN ) != offset )
    {
	return FALSE;
    }
    return TRUE;

} /* fileSeek */


void FreeAppHackData(void)
{
    LPAPPHACKS	next;
    LPAPPHACKS	lphack = lpAppList;

    while( lphack != NULL )
    {
	next = lphack->lpNext;
	MemFree( lphack );
	lphack = next;
    }
    if( lpAppArray != NULL )
    {
	MemFree( lpAppArray );
    }
    lpAppArray = NULL;
    lpAppList = NULL;
    dwAppArraySize = 0;
    bHaveReadReg = FALSE;
}

/*
 * HackMeBaby
 *
 * And we'll have fun fun fun 'til your daddy takes your app hacks away...
 */
DWORD HackMeBaby( void )
{
    char	        fname[_MAX_PATH];
    char	        name[_MAX_PATH];
    HANDLE	        hfile;
    int		        i;
    LPAPPHACKS	        lphack;
    LPAPPHACKS	        *lplphack;
    DWORD               dwScreenSaver;
    IMAGE_NT_HEADERS	nth;
    IMAGE_DOS_HEADER	dh;
    DWORD               appid;
    HKEY                hkey;

    /*
     * bail on the existing info if requested
     */
    if( bReloadReg )
    {

	DPF( 3, "Reloading the compatibility info from the registry" );

	if( lpAppList != NULL )
	{
	    DPF( 4, "Freeing existing compatiblity list" );
	}

        FreeAppHackData();
    }

    /*
     * read the registry for any app hacks
     */
    if( !bHaveReadReg )
    {
	int	index;
	int	count;

	bHaveReadReg = TRUE;
	if( !RegOpenKey( HKEY_LOCAL_MACHINE,
			 REGSTR_PATH_DDRAW "\\" REGSTR_KEY_APPCOMPAT, &hkey ) )
	{
	    index = 0;
	    count = 0;

	    DPF( 4, "Reading App Compatiblity Information" );
	    /*
	     * run through all keys
	     */
	    while( !RegEnumKey( hkey, index, name, sizeof( name ) ) )
	    {
		HKEY	hsubkey;
		DPF( 5, "  Found info for %s", name );

		/*
		 * get info for this specific app
		 */
		if( !RegOpenKey( hkey, name, &hsubkey ) )
		{
		    DWORD	type;
		    DWORD	cb;
		    DWORD	id;
		    DWORD	flags;

		    cb = sizeof( name );
		    if( !RegQueryValueEx( hsubkey, REGSTR_VAL_DDRAW_NAME,
		    			NULL, &type, name, &cb ) )
		    {
			if( type == REG_SZ )
			{
			    cb = sizeof( flags );
			    if( !RegQueryValueEx( hsubkey, REGSTR_VAL_DDRAW_FLAGS,
			    		NULL, &type, (LPSTR) &flags, &cb ) )
			    {
				if( (type == REG_DWORD) ||
				    (type == REG_BINARY && cb == sizeof( flags )) )
				{
				    if( !(flags & ~DDRAW_APPCOMPAT_VALID) )
				    {
					cb = 4;
					if( !RegQueryValueEx( hsubkey, REGSTR_VAL_DDRAW_APPID,
						    NULL, &type, (LPSTR) &id, &cb ) )
					{
					    if( (type == REG_DWORD) ||
						(type == REG_BINARY && cb == sizeof( flags )) )
					    {
						/*
						 * finally!  we have all the data.   save it
						 */
						lphack = MemAlloc( sizeof( *lphack ) + strlen( name ) + 1 );
						if( lphack != NULL )
						{
						    lphack->dwAppId = id;
						    lphack->dwFlags = flags;
						    lphack->szName = &((LPSTR)lphack)[sizeof( *lphack )];
						    lphack->lpNext = lpAppList;
						    lpAppList = lphack;
						    strcpy( lphack->szName, name );
						    count++;
						    DPF( 5, "    Name  = %s", lphack->szName );
						    DPF( 5, "    Flags = 0x%08lx", lphack->dwFlags );
						    DPF( 5, "    AppId = 0x%08lx", lphack->dwAppId );
						}
						else
						{
						    DPF( 0, "    Out of memory!!!" );
						}
					    }
					    else
					    {
						DPF( 0, "    AppID not a DWORD for app %s", name );
					    }
					}
				    }
				    else
				    {
					DPF( 0, "    Invalid flags %08lx for app %s", flags, name );
				    }
				}
				else
				{
				    DPF( 0, "    Flags not a DWORD for app %s", name );
				}
			    }
			    else
			    {
				DPF( 0, "    No flags found for app %s", name );
			    }
			}
			else
			{
			    DPF( 0, "    Executable name not a string!!!" );
			}
		    }
		    else
		    {
			DPF( 0, "    Executable name not found!!!" );
		    }
                    RegCloseKey( hsubkey );
		}
		else
		{
		    DPF( 0, "  RegOpenKey for %ld FAILED!" );
		}

		/*
		 * next reg entry...
		 */
		index++;
	    }
	    DPF( 5, "Enumerated %ld keys, found %ld valid ones", index, count );

	    /*
	     * go make an array we can sort and use later...
	     */
	    if( count > 0 )
	    {
		lpAppArray = MemAlloc( (count+1) * sizeof( LPAPPHACKS ) );
		if( lpAppArray != NULL )
		{
		    LPAPPHACKS	lphack;

		    dwAppArraySize = 0;
		    lphack = lpAppList;
		    while( lphack != NULL )
		    {
			lpAppArray[ dwAppArraySize ] = lphack;
			lphack = lphack->lpNext;
			dwAppArraySize++;
		    }

		    qsort( lpAppArray, count, sizeof( LPAPPHACKS ),
		    			(LPVOID) sortRtn );
		}
		for( count = 0; count< (int) dwAppArraySize; count++ )
		{
		    DPF( 5, "  %s", lpAppArray[count]->szName );
		}
	    }

            RegCloseKey( hkey );
	}
	else
	{
#ifdef WIN95	    
            DPF( 0, "Failed to find registry root" );
#endif
	}

        /*
         * The first time through, we will also check to see if a gamma
         * calibrator is registered.  All we'll do here is read the registry
         * key and if it's non-NULL, we'll assume that one exists.
         */
	if( !RegOpenKey( HKEY_LOCAL_MACHINE,
                         REGSTR_PATH_DDRAW "\\" REGSTR_KEY_GAMMA_CALIBRATOR, &hkey ) )
	{
            DWORD       type;
            DWORD       cb;

            cb = sizeof( szGammaCalibrator );
            if( !RegQueryValueEx( hkey, REGSTR_VAL_GAMMA_CALIBRATOR,
                        NULL, &type, szGammaCalibrator, &cb ) )
            {
                if( ( type == REG_SZ ) &&
                    ( szGammaCalibrator[0] != '\0' ) )
                {
                    bGammaCalibratorExists = TRUE;
                }
            }
            RegCloseKey( hkey );
        }
    }
    else
    {
	DPF( 3, "Registry already scanned, not doing it again" );
    }

    /*
     * find out what process we are dealing with
     */
    hfile =  GetModuleHandle( NULL );
    GetModuleFileName( hfile, fname, sizeof( fname ) );
    DPF( 5, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
	i--;
    }
    i++;
    strcpy( name, &fname[i] );
    DPF( 5, "name       = %s", name );
    lplphack = bsearch( name, lpAppArray, dwAppArraySize, sizeof( LPAPPHACKS ),
    		(LPVOID) searchRtn );

    /*
     * If it has an .SCR extension, assume it's a screensaver.
     */
    dwScreenSaver = 0;
    #ifdef WIN95
        if( ( strlen(name) > 4 ) && !STRCMP( &name[ strlen(name) - 4 ], ".SCR" ) )
        {
            dwScreenSaver = DDRAW_APPCOMPAT_SCREENSAVER;
        }
    #endif

    /*
     * go find the timestamp in the file
     */
    appid = 0;
    do
    {
        hfile = CreateFile( fname, GENERIC_READ, FILE_SHARE_READ,
	        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hfile == INVALID_HANDLE_VALUE )
        {
	    DPF( 0, "Could not open file %s", fname );
	    break;
        }
        if( !fileRead( hfile, &dh, sizeof( dh ) ) )
        {
	    DPF( 0, "Could not read DOS header for file %s", fname );
	    break;
        }
        if( dh.e_magic != IMAGE_DOS_SIGNATURE )
        {
	    DPF( 0, "Invalid DOS header for file %s", fname );
	    break;
        }
        if( !fileSeek( hfile, dh.e_lfanew ) )
        {
	    DPF( 0, "Could not seek to PE header in file %s", fname );
	    break;
        }
        if( !fileRead( hfile, &nth, sizeof( nth ) ) )
        {
	    DPF( 0, "Could not read PE header for file %s", fname );
	    break;
        }
        if( nth.Signature != IMAGE_NT_SIGNATURE )
        {
	    DPF( 0, "Bogus PE header for file %s", fname );
	    break;
        }
        appid = nth.FileHeader.TimeDateStamp;
        if( appid == 0 )
        {
	    DPF( 0, "TimeDataStap is 0 for file %s", fname );
	    break;
        }
        DPF( 5, "Obtained appid: 0x%08lx", appid );
        CloseHandle( hfile );
        hfile = NULL;
    } while(0); //fake try-except

    // Now write the values into some known place
    if (appid)
    {
        DWORD dw;

	if( !RegCreateKey( HKEY_LOCAL_MACHINE,
			 REGSTR_PATH_DDRAW "\\" REGSTR_KEY_LASTAPP, &hkey ) )
        {
            RegSetValueEx(hkey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
            RegSetValueEx(hkey, REGSTR_VAL_DDRAW_APPID, 0, REG_DWORD, (LPBYTE)&appid, sizeof(appid));
            RegCloseKey(hkey);
        }

    }


    if( lplphack != NULL && appid )
    {
	HANDLE	hfile;

	/*
	 * back up to the first match with this name
	 */
	lphack = *lplphack;
	while( lplphack != lpAppArray )
	{
	    lplphack--;
	    if( STRCMP( (*lplphack)->szName, name ) )
	    {
		lplphack++;
		break;
	    }
	    lphack = *lplphack;
	}

	/*
	 * now run through all matches we found
	 */
	hfile = NULL;
	while( 1 )
	{
	    /*
	     * is this one of the ones that matches the calling process?
	     */
	    if( *lplphack == NULL )
	    {
		break;
	    }
	    lphack = *lplphack;
	    if( STRCMP( lphack->szName, name ) )
	    {
		break;
	    }

	    /*
	     * validate timestamp in registry against the one in the file
	     */
	    if( lphack->dwAppId == appid )
	    {
		DPF( 5, "****** Compatiblity data 0x%08lx found for %s",
				lphack->dwFlags, name );
                return lphack->dwFlags | dwScreenSaver;
	    }
	    lplphack++;
	}
	if( hfile != NULL )
	{
	    CloseHandle( hfile );
	}
    }
    return dwScreenSaver;

} /* HackMeBaby */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\alphablt.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	alphablt.c
 *  Content:	DirectDraw Surface support for alpha-blended blt
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  30-sep-97 jvanaken	Original version adapted from ddsblt.c
 *
 ***************************************************************************/
#include "ddrawpr.h"


// function from ddraw module ddclip.c
extern HRESULT InternalGetClipList(LPDIRECTDRAWCLIPPER,
				   LPRECT,
				   LPRGNDATA,
				   LPDWORD,
				   LPDDRAWI_DIRECTDRAW_GBL);

#ifndef WINNT
    #define DONE_BUSY()          \
        (*pdflags) &= ~BUSY;
    #define LEAVE_BOTH_NOBUSY()  \
        { if(pdflags)            \
            (*pdflags) &= ~BUSY; \
        }                        \
        LEAVE_BOTH();
#else
    #define DONE_BUSY()
    #define LEAVE_BOTH_NOBUSY()  \
        LEAVE_BOTH();
#endif

#define DONE_LOCKS() \
    if (dest_lock_taken) \
    { \
	InternalUnlock(surf_dest_lcl,NULL,NULL,0); \
	dest_lock_taken = FALSE; \
    } \
    if (src_lock_taken && surf_src_lcl) \
    { \
	InternalUnlock(surf_src_lcl,NULL,NULL,0); \
	src_lock_taken = FALSE; \
    }

#if defined(WIN95)
    #define DONE_EXCLUDE() \
        if (surf_dest_lcl->lpDDClipper != NULL) \
        { \
            if ((pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice && \
                !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR)) \
	    { \
	        DD16_Unexclude(pdrv->dwPDevice); \
	    } \
        }
#elif defined(WINNT)
    #define DONE_EXCLUDE() ;
#endif


/*
 * Stretch-blit info
 */
typedef struct
{
    DWORD	src_height;
    DWORD	src_width;
    DWORD	dest_height;
    DWORD	dest_width;
    BOOL	halonly;    // HEL can't do this alpha-blit
    BOOL	helonly;    // hardware driver can't do this alpha-blit
} STRETCH_BLT_INFO, FAR *LPSTRETCH_BLT_INFO;


/*
 * Alpha-blitting capability bits
 */
typedef struct
{
    // caps for hardware driver
    DWORD	dwCaps;
    DWORD	dwCKeyCaps;
    DWORD	dwFXCaps;
    DWORD	dwAlphaCaps;
    DWORD	dwFilterCaps;

    // caps for HEL
    DWORD	dwHELCaps;
    DWORD	dwHELCKeyCaps;
    DWORD	dwHELFXCaps;
    DWORD	dwHELAlphaCaps;
    DWORD	dwHELFilterCaps;

    // caps common to hardware driver and HEL
    DWORD	dwBothCaps;
    DWORD	dwBothCKeyCaps;
    DWORD	dwBothFXCaps;
    DWORD	dwBothAlphaCaps;
    DWORD	dwBothFilterCaps;

    BOOL	bHALSeesSysmem;
} ALPHA_BLT_CAPS, *LPALPHA_BLT_CAPS;


/*
 * Return a pointer to the DDPIXELFORMAT structure that
 * describes the specified surface's pixel format.
 */
static LPDDPIXELFORMAT getPixelFormatPtr(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPDDPIXELFORMAT pDDPF;

    if (surf_lcl == NULL)
    {
    	return NULL;
    }

    if (surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
	// surface contains explicitly defined pixel format
	pDDPF = &surf_lcl->lpGbl->ddpfSurface;
    }
    else
    {
	// surface's pixel format is implicit -- same as primary's
	pDDPF = &surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay;
    }
    return pDDPF;

}  /* getPixelFormatPtr */


/*
 * Initialize ALPHA_BLT_CAPS structure according to whether source and
 * dest surfaces are in system or video (local or nonlocal) memory.
 */
static void initAlphaBltCaps(DWORD dwDstCaps,
			     DWORD dwSrcCaps,
			     LPDDRAWI_DIRECTDRAW_GBL pdrv,
			     LPALPHA_BLT_CAPS pcaps,
			     LPBOOL helonly)
{
    DDASSERT(pcaps != NULL);

    memset(pcaps, 0, sizeof(ALPHA_BLT_CAPS));

    if ((dwSrcCaps | dwDstCaps) & DDSCAPS_NONLOCALVIDMEM  &&
	  pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
	/*
	 * At least one of the surfaces is nonlocal video memory.  The device
	 * exports different capabilities for local and nonlocal video memory.
	 * If this is a nonlocal-to-local transfer then check the appropriate
	 * caps.  Otherwise, force software emulation of the blit.
	 */
	if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM && dwDstCaps & DDSCAPS_LOCALVIDMEM)
	{
	    /*
	     * Non-local to local video memory transfer.
	     */
	    DDASSERT(NULL != pdrv->lpddNLVCaps);
	    DDASSERT(NULL != pdrv->lpddNLVHELCaps);
	    DDASSERT(NULL != pdrv->lpddNLVBothCaps);

	    /*
	     * We have specific caps for nonlocal video memory.  Use them.
	     */
	    pcaps->dwCaps =	  pdrv->lpddNLVCaps->dwNLVBCaps;
	    pcaps->dwCKeyCaps =   pdrv->lpddNLVCaps->dwNLVBCKeyCaps;
	    pcaps->dwFXCaps =	  pdrv->lpddNLVCaps->dwNLVBFXCaps;
	    if (pdrv->lpddMoreCaps)
	    {
		if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
		{
		    pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwAlphaCaps;
		}
		if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
		{
		    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwFilterCaps;
		}
	    }
	
	    pcaps->dwHELCaps =	      pdrv->lpddNLVHELCaps->dwNLVBCaps;
	    pcaps->dwHELCKeyCaps =    pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps;
	    pcaps->dwHELFXCaps =      pdrv->lpddNLVHELCaps->dwNLVBFXCaps;
	    if (pdrv->lpddHELMoreCaps)
	    {
		if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
		{
		    pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwAlphaCaps;
		}
		if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
		{
		    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwFilterCaps;
		}
	    }
	
	    pcaps->dwBothCaps =       pdrv->lpddNLVBothCaps->dwNLVBCaps;
	    pcaps->dwBothCKeyCaps =   pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps;
	    pcaps->dwBothFXCaps =     pdrv->lpddNLVBothCaps->dwNLVBFXCaps;
	    if (pdrv->lpddBothMoreCaps)
	    {
		if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
		{
		    pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwAlphaCaps;
		}
		if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
		{
		    pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwFilterCaps;
		}
	    }
	    /*
	     * A driver that cannot filter is trivially capable of disabling filtering.
	     * By similar logic, a driver than cannot filter does not fail to respect
	     * the DDABLT_FILTERTRANSPBORDER flag unless filtering is explicitly enabled.
	     */
	    if (!(pcaps->dwFXCaps & DDFXCAPS_BLTFILTER))
	    {
		pcaps->dwFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
                pcaps->dwFXCaps |= DDFXCAPS_BLTFILTER;
	    }
            if (!(pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER))
	    {
		pcaps->dwHELFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
                pcaps->dwHELFXCaps |= DDFXCAPS_BLTFILTER;
	    }
            if (!(pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER))
	    {
		pcaps->dwBothFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
                pcaps->dwBothFXCaps |= DDFXCAPS_BLTFILTER;
	    }

	    pcaps->bHALSeesSysmem =  FALSE;

	    return;
	}

	/*
	 * Nonlocal-to-nonlocal or local-to-nonlocal transfer. Force emulation.
	 */
	*helonly = TRUE;
    }

    if (!(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM))
    {
	if ((dwSrcCaps | dwDstCaps) & DDSCAPS_SYSTEMMEMORY)
	{
            *helonly = TRUE;
	}
    }

    if (dwSrcCaps & dwDstCaps & DDSCAPS_VIDEOMEMORY)
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwFXCaps;
        if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = FALSE;
    }
    else if ((dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY))
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwSVBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSVBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSVBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwSVBAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSVBFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwSVBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSVBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSVBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwSVBCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwSVBCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwSVBFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
                pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwSVBAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwSVBFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = TRUE;
    }
    else if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY))
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwVSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwVSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwVSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwVSBAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwVSBFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwVSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwVSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwVSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwVSBCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwVSBCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwVSBFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwVSBAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwVSBFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = TRUE;
    }
    else if (dwSrcCaps & dwDstCaps & DDSCAPS_SYSTEMMEMORY)
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwSSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwSSBAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSSBFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwSSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSSBFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwSSBCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwSSBCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwSSBFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwBothAlphaCaps  = pdrv->lpddBothMoreCaps->dwSSBAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwSSBFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = TRUE;
    }

    /*
     * A driver that cannot filter is trivially capable of disabling filtering.
     * By similar logic, a driver than cannot filter does not fail to respect
     * the DDABLT_FILTERTRANSPBORDER flag unless filtering is explicitly enabled.
     */
    if (!(pcaps->dwFXCaps & DDFXCAPS_BLTFILTER))
    {
	pcaps->dwFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
	pcaps->dwFXCaps |= DDFXCAPS_BLTFILTER;
    }
    if (!(pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER))
    {
	pcaps->dwHELFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
	pcaps->dwHELFXCaps |= DDFXCAPS_BLTFILTER;
    }
    if (!(pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER))
    {
	pcaps->dwBothFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
	pcaps->dwBothFXCaps |= DDFXCAPS_BLTFILTER;
    }

}  /* initAlphaBltCaps */


/*
 * Verify that driver can perform requested stretching for blit.
 */
static HRESULT validateStretching(LPALPHA_BLT_CAPS pcaps,
				  LPSTRETCH_BLT_INFO psbi)
{
    DWORD caps;
    BOOL fail = FALSE;

    /*
     * Can we even stretch at all?
     */
    if (!(pcaps->dwBothCaps & DDCAPS_BLTSTRETCH))
    {
	GETFAILCODEBLT(pcaps->dwCaps,
		       pcaps->dwHELCaps,
		       psbi->halonly,
		       psbi->helonly,
		       DDCAPS_BLTSTRETCH);
	if (fail)
	{
	    return DDERR_NOSTRETCHHW;
	}
    }

    if (psbi->helonly)
	caps = pcaps->dwHELFXCaps;
    else
	caps = pcaps->dwFXCaps;

    /*
     * verify height
     */
    if (psbi->src_height != psbi->dest_height)
    {
	if (psbi->src_height > psbi->dest_height)
	{
	    /*
	     * can we shrink Y arbitrarily?
	     */
	    if (!(caps & (DDFXCAPS_BLTSHRINKY)))
	    {
		/*
		 * see if this is a non-integer shrink
		 */
		if ((psbi->src_height % psbi->dest_height) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKY);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		/*
		 * see if we can integer shrink
		 */
		}
		else if (!(caps & DDFXCAPS_BLTSHRINKYN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKYN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
	else
	{
	    if (!(caps & DDFXCAPS_BLTSTRETCHY))
	    {
		/*
		 * see if this is a non-integer stretch
		 */
		if ((psbi->dest_height % psbi->src_height) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHY);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		/*
		 * see if we can integer stretch
		 */
		}
		else if (!(caps & DDFXCAPS_BLTSTRETCHYN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHYN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
    }

    /*
     * verify width
     */
    if (psbi->src_width != psbi->dest_width)
    {
	if (psbi->src_width > psbi->dest_width)
	{
	    if (!(caps & DDFXCAPS_BLTSHRINKX))
	    {
		/*
		 * Are we stretching by a non-integer factor?
		 */
		if ((psbi->src_width % psbi->dest_width) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKX);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		/*
		 * see if we can integer shrink
		 */
		}
		else if (!(caps & DDFXCAPS_BLTSHRINKXN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKXN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
	else
	{
	    if (!(caps & DDFXCAPS_BLTSTRETCHX))
	    {
		/*
		 * Are we stretching by a non-integer factor?
		 */
		if ((psbi->dest_width % psbi->src_width) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHX);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
		if (!(caps & DDFXCAPS_BLTSTRETCHXN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHXN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
    }
    return DD_OK;

}  /* validateStretching */



#undef DPF_MODNAME
#define DPF_MODNAME	"AlphaBlt"


/*
 * Wait for pending hardware operation on specified surface to finish.
 *
 * This function waits for the hardware driver to report that it has finished
 * operating on the given surface. We should only call this function if the
 * surface was a system memory surface involved in a DMA/busmastering transfer.
 * Note this function clears the DDRAWISURFGBL_HARDWAREOPSTARTED flag.
 */
static void WaitForHardwareOp(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl,
				LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    HRESULT hr;
#ifdef DEBUG
    BOOL bSentMessage = FALSE;
    DWORD dwStart = GetTickCount();
#endif

    DDASSERT(surf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
    DPF(5, B, "Waiting for driver to finish with %08x", surf_lcl->lpGbl);
    do
    {
        hr = InternalGetBltStatus(pdrv_lcl, surf_lcl, DDGBS_ISBLTDONE);
#ifdef DEBUG
        if (GetTickCount() - dwStart >= 10000 && !bSentMessage)
	{
	    bSentMessage = TRUE;
	    DPF_ERR("Driver error: Hardware op still pending on surface after 5 sec!");
        }
#endif
    } while (hr == DDERR_WASSTILLDRAWING);

    DDASSERT(hr == DD_OK);
    DPF(5, B, "Driver finished with that surface");
    surf_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;

}  /* WaitForHardwareOp */


/*
 * DD_Surface_AlphaBlt
 *
 * BitBLT from one surface to another with alpha blending.
 */
HRESULT DDAPI DD_Surface_AlphaBlt(
		LPDIRECTDRAWSURFACE lpDDDestSurface,
		LPRECT lpDestRect,
		LPDIRECTDRAWSURFACE lpDDSrcSurface,
		LPRECT lpSrcRect,
		DWORD dwFlags,
		LPDDALPHABLTFX lpDDAlphaBltFX)
{
    struct
    {
        RGNDATAHEADER rdh;
        RECT clipRect[8];
    } myRgnBuffer;

    DWORD           rc;
    LPDDRAWI_DDRAWSURFACE_INT   surf_src_int;
    LPDDRAWI_DDRAWSURFACE_LCL   surf_src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   surf_src;
    LPDDRAWI_DDRAWSURFACE_INT   surf_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL   surf_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   surf_dest;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDHAL_ALPHABLT        bltfn;
    DDHAL_BLTDATA           bd;
    STRETCH_BLT_INFO        sbi;
    BOOL            fail;
    BOOL            dest_lock_taken=FALSE;
    BOOL            src_lock_taken=FALSE;
    LPVOID          dest_bits;
    LPVOID          src_bits;
    HRESULT         ddrval;
    RECT            rect;
    ALPHA_BLT_CAPS  caps;
    LPWORD          pdflags=0;
    LPRGNDATA       pRgn;
    DDARGB          ddargbScaleFactors;
    DWORD           dwFillValue;
    DWORD           dwDDPFDestFlags;
    DWORD           dwDDPFSrcFlags;

    DDASSERT(sizeof(DDARGB)==sizeof(DWORD));  // we rely on this

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_AlphaBlt");
	
    TRY
    {
	ZeroMemory(&bd, sizeof(bd));   // initialize to zero

	/*
         * Validate surface pointers.
         */
        surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
        surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
        if (!VALID_DIRECTDRAWSURFACE_PTR(surf_dest_int))
        {
            DPF_ERR("Invalid dest surface") ;
            LEAVE_BOTH();
            return DDERR_INVALIDOBJECT;
        }
        surf_dest_lcl = surf_dest_int->lpLcl;
        surf_dest = surf_dest_lcl->lpGbl;
        if (SURFACE_LOST(surf_dest_lcl))
        {
            DPF_ERR("Dest surface lost") ;
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }
        if (surf_src_int != NULL)
        {
            if (!VALID_DIRECTDRAWSURFACE_PTR(surf_src_int))
            {
                DPF_ERR("Invalid source surface");
                LEAVE_BOTH();
                return DDERR_INVALIDOBJECT;
            }
            surf_src_lcl = surf_src_int->lpLcl;
            surf_src = surf_src_lcl->lpGbl;
            if (SURFACE_LOST(surf_src_lcl))
            {
                DPF_ERR("Src surface lost") ;
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
        }
        else
        {
            surf_src_lcl = NULL;
            surf_src = NULL;
        }

        if (dwFlags & ~DDABLT_VALID)
        {
            DPF_ERR("Invalid flags") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

	// Is the DONOTWAIT flag set?
	if (dwFlags & DDABLT_DONOTWAIT)
	{
    	    if (dwFlags & DDABLT_WAIT)
	    {
		DPF_ERR("WAIT and DONOTWAIT flags are mutually exclusive");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    // Unless the DONOTWAIT flag is explicitly set, use the default (WAIT).
	    dwFlags |= DDABLT_WAIT;
	}

	/*
         * Set ARGB scaling factors and fill value to their default values.
	 * Note that setting ddargbScaleFactors to all ones effectively
	 * disables ARGB scaling, and a fill value of zero represents black.
	 */
        *(LPDWORD)&ddargbScaleFactors = ~0UL;
        dwFillValue = 0;

	/*
	 * Read parameters pointed to by lpDDAlphaBltFX argument.
	 */
	if (lpDDAlphaBltFX != 0)
	{
	    if (IsBadWritePtr((LPVOID)lpDDAlphaBltFX, sizeof(DDALPHABLTFX)))
	    {
                DPF_ERR("Argument lpDDAlphaBltFX is a bad pointer") ;
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
	    }
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
    		dwFillValue = lpDDAlphaBltFX->dwFillValue;
	    }
	    else
	    {
    		ddargbScaleFactors = lpDDAlphaBltFX->ddargbScaleFactors;
	    }
	}
		
	// Is this a color-fill operation that uses dwFillValue?
	if (dwFlags & DDABLT_USEFILLVALUE && surf_src_lcl == NULL)
	{
	    // Could this possibly be an alpha-blended fill?
	    if (!(dwFlags & DDABLT_NOBLEND))
	    {
		HRESULT hres;

		// If the fill value is less than 100% opaque, we need to
		// do an alpha fill rather than just a simple color fill.
		// Convert physcolor to DDARGB value and test its opacity.
		hres = ConvertFromPhysColor(
					    surf_dest_lcl,
					    &dwFillValue,
					    &ddargbScaleFactors);

		if ((hres == DD_OK) && (ddargbScaleFactors.alpha != 255))
		{
		    // The fill value is not 100% opaque, so do an alpha fill.
		    dwFlags &= ~DDABLT_USEFILLVALUE;
		}
	    }
	    // Make sure DEGRADEARGBSCALING flag is not set.
	    if (dwFlags & DDABLT_DEGRADEARGBSCALING)
	    {
		DPF_ERR("DEGRADEARGBSCALING and USEFILLVALUE flags are incompatible");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}

        /*
         * We do not allow blitting to or from an optimized surface.
         */
        if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED ||
            surf_src && surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR("Can't blt optimized surfaces") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        pdrv = surf_dest->lpDD;
        pdrv_lcl = surf_dest_lcl->lpSurfMore->lpDD_lcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    pdrv->hDD = pdrv_lcl->hDD;
	#endif

	/*
	 * Default behavior is to automatically fail-over to software
	 * emulation if hardware driver cannot handle the specified
	 * blit.  The DDABLT_HARDWAREONLY flag overrides this default.
	 */
	sbi.halonly = dwFlags & DDABLT_HARDWAREONLY;
	sbi.helonly = dwFlags & DDABLT_SOFTWAREONLY;

        /*
	 * Only the HEL can blit between two surfaces created by two
	 * different drivers.
         */
        if (surf_src && surf_src->lpDD != pdrv &&
            surf_src->lpDD->dwFlags & DDRAWI_DISPLAYDRV &&
            pdrv->dwFlags & DDRAWI_DISPLAYDRV)
        {
            sbi.helonly = TRUE;
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered validating parameters");
        LEAVE_BOTH();
        return DDERR_INVALIDPARAMS;
    }

    #ifdef USE_ALIAS
    if ((pdrv_lcl->lpDDCB->HALDDMiscellaneous2.AlphaBlt == NULL) &&
	(pdrv->dwBusyDueToAliasedLock > 0))
    {
        /*
         * Aliased locks (the ones that don't take the Win16 lock) don't
         * set the busy bit either (it can't or USER gets very confused).
         * However, we must prevent blits happening via DirectDraw as
         * otherwise we get into the old host talking to VRAM while
         * blitter does at the same time.  Bad.  So fail if there is an
         * outstanding aliased lock just as if the BUSY bit had been set.
         */
        DPF_ERR("Graphics adapter is busy (due to a DirectDraw lock)");
        LEAVE_BOTH();
        return DDERR_SURFACEBUSY;
    }
    #endif /* USE_ALIAS */

    if(surf_src_lcl)
        FlushD3DStates(surf_src_lcl); // Need to flush src because it could be a rendertarget
    FlushD3DStates(surf_dest_lcl);

    /*
     * Test and set the busy bit.  If it was already set, bail.
     */
    #ifdef WIN95
    {
        BOOL isbusy = 0;

	pdflags = pdrv->lpwPDeviceFlags;
	_asm
	{
	    mov eax, pdflags
	    bts word ptr [eax], BUSY_BIT
	    adc byte ptr isbusy,0
	}
	if (isbusy)
	{
	    DPF(3, "BUSY - AlphaBlt");
	    LEAVE_BOTH();
	    return DDERR_SURFACEBUSY;
	}
    }
    #endif

    /*
     * The following code was added to keep all of the HALs from
     * changing their Blt() code when they add video port support.
     * If the video port was using this surface but was recently
     * flipped, we will make sure that the flip actually occurred
     * before allowing access.  This allows double buffered capture
     * w/o tearing.
     */
    if ((surf_src_lcl != NULL) &&
	    (surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))
    {
	LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
	LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

	// Look at all video ports to see if any of them recently
	// flipped from this surface.
	lpVideoPort = pdrv->dvpList;
	while(NULL != lpVideoPort)
	{
	    lpVideoPort_lcl = lpVideoPort->lpLcl;
	    if (lpVideoPort_lcl->fpLastFlip == surf_src->fpVidMem)
	    {
		// This can potentially tear - check the flip status
		LPDDHALVPORTCB_GETFLIPSTATUS pfn;
		DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
		LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
	
		pdrv_lcl = surf_src_lcl->lpSurfMore->lpDD_lcl;
		pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
		if (pfn != NULL)  // Will simply tear if function not supported
		{
		    GetFlipData.lpDD = pdrv_lcl;
		    GetFlipData.fpSurface = surf_src->fpVidMem;
	
		KeepTrying:
		    rc = DDHAL_DRIVER_NOTHANDLED;
		    DOHALCALL(GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0);
		    if ((DDHAL_DRIVER_HANDLED == rc) &&
		    (DDERR_WASSTILLDRAWING == GetFlipData.ddRVal))
		    {
			if (dwFlags & DDABLT_WAIT)
			{
			    goto KeepTrying;
			}
			LEAVE_BOTH_NOBUSY();
			return DDERR_WASSTILLDRAWING;
		    }
		}
	    }
	    lpVideoPort = lpVideoPort->lpLink;
	}
    }


    TRY
    {
	/*
	 *  Remove any cached run-length-encoded data for the source surface.
	 */
	if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	{
	    extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL);  //in fasthel.c

	    FreeRleData(surf_dest_lcl);
	}

	/*
	 * Is either surface locked?
	 */
	if (surf_dest->dwUsageCount > 0 ||
	    surf_src != NULL && surf_src->dwUsageCount > 0)
	{
	    DPF_ERR("Surface is locked");
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_SURFACEBUSY;
	}

	BUMP_SURFACE_STAMP(surf_dest);

	/*
	 * It is possible this function could be called in the middle
	 * of a mode change, in which case we could trash the frame buffer.
	 * To avoid regression, we will simply succeed the call without
	 * actually doing anything.
	 */
	if (pdrv->dwFlags & DDRAWI_CHANGINGMODE &&
	    !(surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
	{
	    LEAVE_BOTH_NOBUSY()
		return DD_OK;
	}

	/*
	 * Some parameters are valid only if a source surface is specified.
	 */
	if (surf_src == NULL)
	{
	    /*
	     * No source surface is specified, so this must be a fill operation.
	     */
	    if (dwFlags & (DDABLT_MIRRORLEFTRIGHT | DDABLT_MIRRORUPDOWN |
			   DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE |
			   DDABLT_FILTERTRANSPBORDER | DDABLT_KEYSRC))
	    {
		DPF_ERR("Specified flag requires source surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    if (lpSrcRect != NULL)
	    {
		DPF_ERR("Source rectangle specified without source surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    /*
	     * A source surface is specified, so this must be a two-operand blit.
	     */
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
		DPF_ERR("USEFILLVALUE flag incompatible with use of source surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Get capability bits for source/dest memory combination.
	 */
	if (surf_src != NULL)
	{
	    // initialize the blit caps according to the surface types
	    initAlphaBltCaps(surf_dest_lcl->ddsCaps.dwCaps,
			     surf_src_lcl->ddsCaps.dwCaps,
			     pdrv,
			     &caps,
			     &sbi.helonly);
	}
	else
	{
	    /*
	     * No source surface.  Use caps for vram-to-vram blits and choose
	     * hal or hel based on whether dest surface is in system memory.
	     * If the dest surface is in nonlocal video memory, we also force
	     * emulation as we don't currently support accelerated operation
	     * with nonlocal video memory as a target.
	     */
	    initAlphaBltCaps(DDSCAPS_VIDEOMEMORY,
			     DDSCAPS_VIDEOMEMORY,
			     pdrv,
			     &caps,
			     &sbi.helonly);

	    if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ||
		surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
	    {
		caps.bHALSeesSysmem = FALSE;
		sbi.helonly = TRUE;
	    }
	}

	/*
	 * Can we really blit?      -- Test DDCAPS_BLTCOLORFILL if src surf is null?
	 */
	if (!(caps.dwBothCaps & DDCAPS_BLT))
	{
	    /*
	     * Unable to blit with both HEL and hardware driver.
	     * Can either of them do the blit?
	     */
	    if (caps.dwCaps & DDCAPS_BLT)
	    {
		sbi.halonly = TRUE;   // hardware driver only
	    }
	    else if (caps.dwHELCaps & DDCAPS_BLT)
	    {
		caps.bHALSeesSysmem = FALSE;
		sbi.helonly = TRUE;    // HEL only
	    }
	    else
	    {
		DPF_ERR("Driver does not support blitting");
		LEAVE_BOTH_NOBUSY();
		return DDERR_NOBLTHW;
	    }
	}

	/*
	 * Validate height and width of destination rectangle.
	 */
	if (lpDestRect != NULL)
	{
	    if (!VALID_RECT_PTR(lpDestRect))
	    {
		DPF_ERR("Invalid dest rect specified");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDRECT;
	    }
	    bd.rDest = *(LPRECTL)lpDestRect;
	}
	else
	{
	    MAKE_SURF_RECT(surf_dest, surf_dest_lcl, bd.rDest);
	}

	sbi.dest_height = bd.rDest.bottom - bd.rDest.top;
	sbi.dest_width  = bd.rDest.right  - bd.rDest.left;

	if (((int)sbi.dest_height <= 0) || ((int)sbi.dest_width <= 0))
	{
	    DPF_ERR("Bad dest width or height -- must be positive and nonzero");
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_INVALIDRECT;
	}

	/*
	 * Validate height and width of source rectangle.
	 */
	if (surf_src != NULL)
	{
	    /*
	     * Get source rectangle.
	     */
	    if (lpSrcRect != NULL)
	    {
		if (!VALID_RECT_PTR(lpSrcRect))
		{
		    DPF_ERR("Invalid src rect specified");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDRECT;
		}
		bd.rSrc = *(LPRECTL)lpSrcRect;
	    }
	    else
	    {
		MAKE_SURF_RECT(surf_src, surf_src_lcl, bd.rSrc);
	    }

	    sbi.src_height = bd.rSrc.bottom - bd.rSrc.top;
	    sbi.src_width  = bd.rSrc.right  - bd.rSrc.left;

	    if (((int)sbi.src_height <= 0) || ((int)sbi.src_width <= 0))
	    {
		DPF_ERR("Bad source width or height -- must be positive and nonzero");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDRECT;
	    }
	    /*
	     * Multi-mon: Is this the primary for the desktop?  This is the
	     * only case where the upper-left coord of the surface is not (0,0).
	     */
	    if ((surf_src->lpDD->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
		(surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
	    {
		if ((bd.rSrc.left   < surf_src->lpDD->rectDevice.left) ||
		    (bd.rSrc.top    < surf_src->lpDD->rectDevice.top)  ||
		    (bd.rSrc.right  > surf_src->lpDD->rectDevice.right)||
		    (bd.rSrc.bottom > surf_src->lpDD->rectDevice.bottom))
		{
		    DPF_ERR("Source rect doesn't fit on Desktop");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDRECT;
		}
	    }
	    else
	    {
		if ((int)bd.rSrc.left < 0 ||
		    (int)bd.rSrc.top  < 0 ||
		    (DWORD)bd.rSrc.bottom > (DWORD)surf_src->wHeight ||
		    (DWORD)bd.rSrc.right  > (DWORD)surf_src->wWidth)
		{
		    DPF_ERR("Invalid source rect specified");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDRECT;
		}
	    }

	    /*
	     * Verify stretching...
	     */
	    if (sbi.src_height != sbi.dest_height || sbi.src_width != sbi.dest_width)
	    {
		HRESULT ddrval = validateStretching(&caps, &sbi);

		if (ddrval != DD_OK)
		{
		    DPF_ERR("Can't perform specified stretching");
		    LEAVE_BOTH_NOBUSY();
		    return ddrval;
		}
                /*
		 * Do source and dest rectangles lie on the same surface and overlap?
		 */
		if (surf_src_lcl == surf_dest_lcl &&
			IntersectRect(&rect, (LPRECT)&bd.rSrc, (LPRECT)&bd.rDest))
		{
		    DPF_ERR("Can't stretch if source/dest rectangles overlap");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_OVERLAPPINGRECTS;
		}
	    }
	}

	/*
	 * Get pixel-format flags for source and destination surfaces.
	 */
	dwDDPFDestFlags = getPixelFormatPtr(surf_dest_lcl)->dwFlags;
	if (surf_src_lcl != NULL)
	{
	    dwDDPFSrcFlags = getPixelFormatPtr(surf_src_lcl)->dwFlags;
	}
	else
	{
    	    dwDDPFSrcFlags = 0;
	}

	/*
	 * Special Restrictions on Pixel Formats:
	 * -- If the surfaces have pixel formats that either are FOURCCs
	 *    or are understood by the AlphaBlt HEL, no restrictions are
	 *    imposed on the range of AlphaBlt features available for
	 *    blit and fill operations.  All formats that are understood
	 *    by the HEL are listed in the PFTable array in ablthel.c.
	 * -- If either surface has a non-FOURCC pixel format that is not
	 *    understood by AlphaBlt HEL, only a copy blit is permitted.
	 *    For a copy blit, the source and dest formats are identical,
	 *    and features such as stretching, mirroring, filtering, color
	 *    keying, alpha blending, and ARGB scaling are not used.
	 */
	if ((!(dwDDPFDestFlags & DDPF_FOURCC) &&
	    (GetSurfPFIndex(surf_dest_lcl) == PFINDEX_UNSUPPORTED)) ||
	    ((surf_src_lcl != NULL) && !(dwDDPFDestFlags & DDPF_FOURCC) &&
	    (GetSurfPFIndex(surf_src_lcl) == PFINDEX_UNSUPPORTED)))
	{
            LPDDPIXELFORMAT pDDPFDest = getPixelFormatPtr(surf_dest_lcl);
	    LPDDPIXELFORMAT pDDPFSrc  = getPixelFormatPtr(surf_src_lcl);
            /*
	     * This blit involves a non-FOURCC format that is unknown to the
	     * AlphaBlt HEL.  In this case, we accept the blit operation only
	     * if it is a simple copy blit.  It's okay if the rects overlap.
	     */
	    if ((surf_src_lcl == NULL) || !doPixelFormatsMatch(pDDPFDest, pDDPFSrc))
	    {
		DPF_ERR("Only copy blits are available with specified pixel format");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    // Is the DDABLT_NOBLEND flag specified?
	    if (!(dwFlags & DDABLT_NOBLEND))
	    {		
		DPF_ERR("NOBLEND flag is required to blit with specified pixel format");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    // Are any inappropriate DDABLT flags set?

	    if (dwFlags & (DDABLT_MIRRORUPDOWN | DDABLT_MIRRORLEFTRIGHT |
			   DDABLT_KEYSRC | DDABLT_DEGRADEARGBSCALING |
			   DDABLT_FILTERENABLE | DDABLT_FILTERTRANSPBORDER))
	    {
		DPF_ERR("Specified DDABLT flag is incompatible with pixel format");
                LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
            // Is stretching required for this blit?
            if (sbi.src_height != sbi.dest_height || sbi.src_width != sbi.dest_width)
	    {
		DPF_ERR("Stretching is not permitted with specified pixel format");
                LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    // Are the ARGB-scaling factors disabled (i.e., set to all ones)?
	    if (*(LPDWORD)&ddargbScaleFactors != ~0UL)
	    {
		DPF_ERR("ARGB scaling must be disabled with specified pixel format");
                LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Do source and dest rectangles lie on the same surface and overlap?
	 */
	if (surf_src_lcl == surf_dest_lcl &&
		IntersectRect(&rect, (LPRECT)&bd.rSrc, (LPRECT)&bd.rDest))
	{
	    /*
	     * Yes, enforce restrictions on blits with overlapping rectangles.
	     */
	    if (!(dwFlags & DDABLT_NOBLEND))
	    {
	        DPF_ERR("Can't blit between overlapping rects unless NOBLEND flag is set");
		LEAVE_BOTH_NOBUSY();
		return DDERR_OVERLAPPINGRECTS;
	    }
	    if (dwFlags & (DDABLT_MIRRORUPDOWN | DDABLT_MIRRORLEFTRIGHT |
			   DDABLT_KEYSRC | DDABLT_DEGRADEARGBSCALING |
			   DDABLT_FILTERENABLE | DDABLT_FILTERTRANSPBORDER))
	    {
	        DPF_ERR("Specified flag is illegal if source/dest rectangles overlap");
		LEAVE_BOTH_NOBUSY();
		return DDERR_OVERLAPPINGRECTS;
	    }
	    if (dwDDPFDestFlags & DDPF_FOURCC)
	    {
		DPF_ERR("Overlapping source/dest rectangles illegal with FOURCC surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_OVERLAPPINGRECTS;
	    }
	}

	/*
         * Does the destination surface have a FOURCC pixel format?
	 */
	if (dwDDPFDestFlags & DDPF_FOURCC)
	{
	    // The DDABLT_USEFILLVALUE flag is illegal with a FOURCC dest surface.
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
		DPF_ERR("Can't use USEFILLVALUE flag with FOURCC dest surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}

	fail = FALSE;   // initialize before using GETFAILCODEBLT macro

	/*
	 * Validate source color key.
	 */
	if (dwFlags & DDABLT_KEYSRC)
	{
            DDASSERT(surf_src != NULL);
	    // make sure we can do this
	    if (!(caps.dwBothCKeyCaps & DDCKEYCAPS_SRCBLT))
	    {
		GETFAILCODEBLT(caps.dwCKeyCaps,
			       caps.dwHELCKeyCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDCKEYCAPS_SRCBLT);
		if (fail)
		{
		    DPF_ERR("KEYSRC specified, not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	    if (!(surf_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) ||
		(dwDDPFSrcFlags & (DDPF_FOURCC | DDPF_ALPHAPIXELS)))
	    {
		/*
		 * If the src color-key flag is set but the source surface has
		 * no associated src color key, just clear the flag instead of
		 * treating this as an error.
		 */
		dwFlags &= ~DDABLT_KEYSRC;
	    }
	}

	/*
	 * Validate up/down mirroring
	 */
	if (dwFlags & DDABLT_MIRRORUPDOWN)
	{
	    DDASSERT(surf_src != NULL);
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTMIRRORUPDOWN))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTMIRRORUPDOWN);
		if (fail)
		{
		    DPF_ERR("Mirror up/down specified, not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOMIRRORHW;
		}
	    }
	}

	/*
	 * Validate left/right mirroring
	 */
	if (dwFlags & DDABLT_MIRRORLEFTRIGHT)
	{
	    DDASSERT(surf_src != NULL);
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTMIRRORLEFTRIGHT))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTMIRRORLEFTRIGHT);
		if (fail)
		{
		    DPF_ERR("Mirror left/right specified, not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOMIRRORHW;
		}
	    }
	}

	/*
	 * Does destination surface have a palette-indexed pixel format?
	 */
	if (dwDDPFDestFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
			       DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8))
	{
	    /*
	     * Is this a blit or a color-fill operation?
	     */
	    if (surf_src_lcl == NULL)
	    {
		/*
		 * Color-Fill: Palette-indexed dest is illegal without USEFILLVALUE flag.
		 */
		if (!(dwFlags & DDABLT_USEFILLVALUE))
		{
    		    DPF_ERR("USEFILLVALUE flag required to fill palette-indexed dest surface");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
	    }
	    else
	    {
		/*
		 * Blit: Destination surface is palette-indexed, so we require source
		 * surface to have same pixel format as destination.  (Note that this
		 * also makes color fills illegal to palette-indexed dest surfaces.)
		 */
		if (dwDDPFSrcFlags != dwDDPFDestFlags)
		{
		    DPF_ERR("If dest is palette-indexed, source must have same pixel format");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		if (dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERTRANSPBORDER))
		{
		    DPF_ERR("Illegal to specify filtering with palette-indexed destination");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		if (*(LPDWORD)&ddargbScaleFactors != ~0UL)
		{
		    DPF_ERR("Illegal to enable ARGB scaling with palette-indexed destination");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		/*
		 * If source and dest surfaces both have attached palettes, we require that
		 * they reference the same palette object.  In a later release, we may relax
		 * this requirement in order to support color-table conversion or dithering.
		 */
		if ((surf_src_lcl->lpDDPalette != NULL) &&
		    (surf_dest_lcl->lpDDPalette != NULL) &&
		    (surf_src_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable !=
		     surf_dest_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable))
		{
		    DPF_ERR("If source and dest surfaces both have palettes, must be same palette");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
	    }
	}
	else if (dwDDPFSrcFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
				   DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8) &&
		    (surf_src_lcl->lpDDPalette == NULL ||
		     surf_src_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable == NULL))
	{
	    /*
	     * Conversion of source pixels to destination pixel format is
	     * impossible because source surface has no attached palette.
	     */
	    DPF_ERR( "No palette associated with palette-indexed source surface" );
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_NOPALETTEATTACHED;
	}

	/*
	 * We do no ARGB scaling if NOBLEND flag is set.
	 */
	if (dwFlags & DDABLT_NOBLEND)
	{
	    if (dwFlags & DDABLT_DEGRADEARGBSCALING)
	    {
		DPF_ERR("NOBLEND and DEGRADEARGBSCALING flags are incompatible");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	    if (surf_src != NULL && *(LPDWORD)&ddargbScaleFactors != ~0UL)
	    {
		DPF_ERR("ARGB scaling of source surface illegal if NOBLEND flag is set");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else if ((dwDDPFSrcFlags | dwDDPFDestFlags) & DDPF_ALPHAPIXELS)
	{
	    /*
	     * We've been asked to perform a blit or fill that requires blending
	     * with the alpha-channel information in the pixel formats for one
	     * or both surfaces.  Verify that the driver supports this.
	     */
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTALPHA))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTALPHA);
		if (fail)
		{
		    DPF_ERR("Alpha-blended blit requested, but not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    /*
	     * Verify that the driver supports surfaces whose pixel
	     * formats contain an alpha-channel component.
	     */
	    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAPIXELS))
	    {
		GETFAILCODEBLT(caps.dwAlphaCaps,
			       caps.dwHELAlphaCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDALPHACAPS_BLTALPHAPIXELS);
		if (fail)
		{
		    DPF_ERR("Alpha pixel format specified, but not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }

	    /*
	     * Does dest surface have alpha channel?
	     */
	    if (dwDDPFDestFlags & DDPF_ALPHAPIXELS)
	    {
		/*
		 * Verify that destination surface has a premultiplied-
		 * alpha pixel format.  Non-premultiplied alpha won't do.
		 */
		if (!(dwDDPFDestFlags & DDPF_ALPHAPREMULT))
		{
		    DPF_ERR("Illegal to blend with non-premultiplied alpha in dest surface");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		/*
		 * Verify that driver can handle premultiplied-alpha pixel format.
		 * (Dest surface is not allowed to be non-premultiplied alpha.)
		 */
		if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTPREMULT))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   DDALPHACAPS_BLTPREMULT);
		    if (fail)
		    {
			DPF_ERR("No driver support for premultiplied alpha");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
	    }

	    /*
	     * Does source surface have alpha channel?
	     */
	    if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS)
	    {
                /*
		 * Are we asking the driver to handle both ARGB scaling and a
		 * source alpha channel when it can't do both at the same time?
		 */
		if (*(LPDWORD)&ddargbScaleFactors != ~0 &&
		    !(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAANDARGBSCALING) &&
                    !(dwFlags & DDABLT_DEGRADEARGBSCALING))
		{
                    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAANDARGBSCALING))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTALPHAANDARGBSCALING);
			if (fail)
			{
			    DPF_ERR("No driver support for alpha channel and ARGB scaling in same blit");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
		/*
		 * Are color components in pixel format premultiplied by the
		 * alpha component or not?  In either case, verify that the
		 * driver supports the specified alpha format.
		 */
		if (dwDDPFSrcFlags & DDPF_ALPHAPREMULT)
		{
		    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTPREMULT))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTPREMULT);
			if (fail)
			{
			    DPF_ERR("No driver support for premultiplied alpha");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
		else
		{
		    DWORD val = 0x01010101UL*ddargbScaleFactors.alpha;

		    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTNONPREMULT))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTNONPREMULT);
			if (fail)
			{
			    DPF_ERR("No driver support for non-premultiplied alpha");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }

		    /*
		     * We allow only one-factor ARGB scaling with a source
		     * surface that has a non-premultiplied alpha pixel format.
		     * The following code enforces this rule.
		     */
		    if (*(LPDWORD)&ddargbScaleFactors != val)
		    {
			if (dwFlags & DDABLT_DEGRADEARGBSCALING)
			{
			    *(LPDWORD)&ddargbScaleFactors = val;
			}
			else
			{
			    DPF_ERR("Can't do 2 or 4-mult ARG