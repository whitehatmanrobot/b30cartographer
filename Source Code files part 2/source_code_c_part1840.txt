thPoints(),
            xpath->GetPointDimension(),
            TotalCount,
            FALSE   // Don't copy data.
            );
        Types = xpath->GetPathTypes();
    }

    // Check if this path is valid.

    if(
        XPoints.Data
        && XPoints.Dimension > 0
        && XPoints.Count > 0
        && Types
        && TotalCount > 0
        )
    {
        SetValid(TRUE);
    }
}

VOID
GpXPathIterator::Initialize()
{
//    XPath = NULL;
    Types = NULL;
    TotalCount = 0;
    Index = 0;
    SubpathStartIndex = 0;
    SubpathEndIndex = 0;
    TypeStartIndex = 0;
    TypeEndIndex = 0;
    SetValid(FALSE);
}


INT
GpXPathIterator::Enumerate(GpXPoints* xpoints, BYTE* types)
{
    if(!IsValid())
        return 0;

    ASSERT(xpoints && types);
    if(xpoints == NULL || types == NULL)
        return 0;

    INT inputSize = xpoints->Dimension*xpoints->Count;

    ASSERT(xpoints->Data && inputSize > 0);
    if(xpoints->Data == NULL || inputSize <= 0)
        return 0;

    if(Index >= TotalCount)
        return 0;

    // Make sure the resultant dimension is the same as
    // the internal dimension.

    INT dimension = XPoints.Dimension;
    if(xpoints->Dimension != dimension)
    {
        xpoints->Dimension = dimension;
        xpoints->Count = inputSize/dimension;
    }

    INT number = min(TotalCount - Index, xpoints->Count);
    GpMemcpy(
        xpoints->Data,
        XPoints.Data + Index*dimension,
        number*dimension*sizeof(REALD));
    GpMemcpy(types, Types + Index, number*sizeof(BYTE));

    Index += number;
    
    return number;
}

INT
GpXPathIterator::NextSubpath(INT* startIndex, INT* endIndex, BOOL *isClosed)
{
    if(!IsValid())
        return 0;
    
    INT count = TotalCount;

    if(SubpathEndIndex >= count - 1)
        return 0;

    const BYTE* types = Types;

    INT i;

    // Set the starting index of the current subpath.

    if(SubpathEndIndex == 0)
    {
        SubpathStartIndex = 0;
        i = 1;
    }
    else
    {
        SubpathStartIndex = SubpathEndIndex + 1;
        SubpathEndIndex = SubpathStartIndex;
        i = SubpathStartIndex + 1;
    }

    BOOL hasData = FALSE;
    INT segmentCount = 0;

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            segmentCount++;
            if(hasData)
            {
                break;
            }
            else
            {
                SubpathStartIndex = i;
                SubpathEndIndex = SubpathStartIndex;
                i++;
            }
        }
        if(segmentCount > 0 && hasData)
        {
            SubpathEndIndex = i - 1;
            break;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;
        BYTE nextType = types[i] & PathPointTypePathTypeMask;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == nextType)
        {
            i++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            hasData = TRUE;
        }
    }

    *startIndex = SubpathStartIndex;
    if(i >= count)
        SubpathEndIndex = count - 1;    // The last subpath.
    *endIndex = SubpathEndIndex;
    segmentCount = SubpathEndIndex - SubpathStartIndex + 1;
    if(segmentCount <= 1)   // Start and end point is the same.
        segmentCount = 0;

    if(segmentCount > 1)
    {
        // If there is the close flag or the start and end points match,
        // this subpath is closed.

        if(
            (types[SubpathEndIndex] & PathPointTypeCloseSubpath)
            || XPoints.AreEqualPoints(SubpathStartIndex, SubpathEndIndex)
        )
        {
            *isClosed = TRUE;
        }
        else
            *isClosed = FALSE;
    }
    else
        *isClosed = FALSE;
    
    // Set the current index to the starting index of the current subpath.

    Index = SubpathStartIndex;

    // Set the start and end index of type to be the starting index of
    // the current subpath.  NextPathType() will start from the
    // beginning of the current subpath.

    TypeStartIndex = TypeEndIndex = SubpathStartIndex;

    return segmentCount;
}


INT
GpXPathIterator::EnumerateSubpath(
    GpXPoints* xpoints,
    BYTE* types
    )
{
    if(!IsValid())
        return 0;

    ASSERT(xpoints && types);
    if(xpoints == NULL || types == NULL)
        return 0;
    
    INT inputSize = xpoints->Dimension*xpoints->Count;

    ASSERT(xpoints->Data && inputSize > 0);
    if(xpoints->Data == NULL || inputSize <= 0)
        return 0;

    if(Index > SubpathEndIndex)
        return 0;

    // Make sure the resultant dimension is the same as
    // the internal dimension.

    INT dimension = XPoints.Dimension;
    if(xpoints->Dimension != dimension)
    {
        xpoints->Dimension = dimension;
        xpoints->Count = inputSize/dimension;
    }

    INT number = min(SubpathEndIndex - Index + 1, xpoints->Count);

    GpMemcpy(
        xpoints->Data,
        XPoints.Data + Index*dimension,
        number*dimension*sizeof(REALD));
    GpMemcpy(types, Types + Index, number*sizeof(BYTE));

    Index += number;
    
    return number;
}


INT
GpXPathIterator::NextPathType(
    BYTE* pathType,
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid())
        return 0;
    
    if(TypeEndIndex >= SubpathEndIndex)
        return 0;   // There is no more segment in the current subpath.

    INT count = SubpathEndIndex + 1;    // Limit for the ending index.
    const BYTE* types = Types;

    TypeStartIndex = TypeEndIndex;
    INT i = TypeStartIndex;
    INT segmentCount = 0;

    i++;    // Go to the next point.

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            // Move the start and end index.

            TypeStartIndex = i;
            TypeEndIndex = TypeStartIndex;
            i++;
            segmentCount++;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;
        BYTE nextType = types[i] & PathPointTypePathTypeMask;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == nextType)
        {
            i++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            TypeEndIndex = TypeStartIndex + segmentCount;
            *pathType = nextType;
            break;
        }
    }

    *startIndex = TypeStartIndex;
    *endIndex = TypeEndIndex;
    segmentCount = TypeEndIndex - TypeStartIndex + 1;
    if(segmentCount <= 1)
    {
        // Start and End type index is the same.  This means there is
        // no more segment left.

        segmentCount = 0;
    }

    // Set the current index to the starting index of the current subpath.

    Index = TypeStartIndex;

    return segmentCount;   
}


INT
GpXPathIterator::EnumeratePathType(
    GpXPoints* xpoints,
    BYTE* types
    )
{
    if(!IsValid())
        return 0;

    ASSERT(xpoints && types);
    if(xpoints == NULL || types == NULL)
        return 0;
    
    INT inputSize = xpoints->Dimension*xpoints->Count;

    ASSERT(xpoints->Data && inputSize > 0);
    if(xpoints->Data == NULL || inputSize <= 0)
        return 0;

    if(Index > TypeEndIndex)
        return 0;

    // Make sure the resultant dimension is the same as
    // the internal dimension.

    INT dimension = XPoints.Dimension;
    if(xpoints->Dimension != dimension)
    {
        xpoints->Dimension = dimension;
        xpoints->Count = inputSize/dimension;
    }

    INT number = min(TypeEndIndex - Index + 1, xpoints->Count);

    GpMemcpy(
        xpoints->Data,
        XPoints.Data + Index*dimension,
        number*dimension*sizeof(REALD));
    GpMemcpy(types, Types + Index, number*sizeof(BYTE));

    Index += number;
    
    return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\xpath.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   XPath.hpp
*
* Abstract:
*
*   Interface of GpXPath and its iterator classes
*
* Revision History:
*
*   11/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _XPATH_HPP
#define _XPATH_HPP

enum XPathFlags
{
    HasBezierFlag   = 1,
    IsRationalFlag  = 2
};

class GpXPath
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagXPath : ObjectTagInvalid;
    }

protected:
    INT Flags;
    BYTE* Types;
    GpXPoints XPoints;
    GpFillMode FillMode;
    INT SubpathCount;       // number of subpaths

public:
    GpXPath(const GpPath* path);
	GpXPath(
		const GpPath* path,
		const GpRectF& rect,
		const GpPointF* points,
		INT count,
		WarpMode warpMode
		);

    ~GpXPath()
    {
        if(Types)
            GpFree(Types);

        SetValid(FALSE);    // so we don't use a deleted object
    }

    INT GetPointCount()
    {
        return XPoints.Count;
    }

    INT GetPointDimension()
    {
        return XPoints.Dimension;
    }

    REALD* GetPathPoints()
    {
        return XPoints.Data;
    }

    BYTE* GetPathTypes()
    {
        return Types;
    }

    VOID SetFillMode(GpFillMode fillMode)
    {
        FillMode = fillMode;
    }

    GpFillMode GetFillMode()
    {
        return FillMode;
    }

    VOID SetBezierFlag()
    {
        Flags |= HasBezierFlag;
    }

    BOOL HasBezier()
    {
        if(Flags & HasBezierFlag)
            return TRUE;
        else
            return FALSE;
    }

    VOID SetRationalFlag()
    {
        Flags |= IsRationalFlag;
    }

    BOOL IsRational()
    {
        if(Flags & IsRationalFlag)
            return TRUE;
        else
            return FALSE;
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagXPath) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid XPath");
        }
    #endif

        return (Tag == ObjectTagXPath);
    }

    GpStatus
    Flatten(
        DynByteArray* flattenTypes,
        DynPointFArray* flattenPoints,
        const GpMatrix *matrix
        );

protected:

    VOID InitDefaultState()
    {
        SetValid(FALSE);
        Flags = 0;
        Types = NULL;
        FillMode = FillModeAlternate;
        SubpathCount = 0;
    }

    GpStatus
    ConvertToPerspectivePath(
        const GpPath* path,
        const GpRectF& rect,
        const GpPointF* points,
        INT count
        );

    GpStatus
    ConvertToBilinearPath(
        const GpPath* path,
        const GpRectF& rect,
        const GpPointF* points,
        INT count
        );

};


class GpXPathIterator
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagXPathIterator : ObjectTagInvalid;
    }

public:
    GpXPathIterator(GpXPath* xpath);
    ~GpXPathIterator()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    INT Enumerate(GpXPoints* xpoints, BYTE* types);
    INT NextSubpath(INT* startIndex, INT* endIndex, BOOL* isClosed);
    INT EnumerateSubpath(GpXPoints* xpoints, BYTE* types);
    INT NextPathType(BYTE* pathType, INT* startIndex, INT* endIndex);
    INT EnumeratePathType(GpXPoints* xpoints, BYTE* types);

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagXPathIterator) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid XPathIterator");
        }
    #endif

        return (Tag == ObjectTagXPathIterator);
    }

private:
    VOID Initialize();

private:
    const BYTE* Types;
    GpXPoints XPoints;
    INT TotalCount;
    INT Index;
    INT SubpathStartIndex;
    INT SubpathEndIndex;
    INT TypeStartIndex;
    INT TypeEndIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\flatapi.inc ===
MONITOR(GdipDisplayPaletteWindowNotify),
MONITOR(GdipCreatePath),
MONITOR(GdipCreatePath2),
MONITOR(GdipCreatePath2I),
MONITOR(GdipClonePath),
MONITOR(GdipDeletePath),
MONITOR(GdipResetPath),
MONITOR(GdipGetPointCount),
MONITOR(GdipGetPathTypes),
MONITOR(GdipGetPathPoints),
MONITOR(GdipGetPathPointsI),
MONITOR(GdipGetPathFillMode),
MONITOR(GdipSetPathFillMode),
MONITOR(GdipSetPathData),
MONITOR(GdipGetPathData),
MONITOR(GdipStartPathFigure),
MONITOR(GdipClosePathFigure),
MONITOR(GdipClosePathFigures),
MONITOR(GdipSetPathMarker),
MONITOR(GdipClearPathMarkers),
MONITOR(GdipReversePath),
MONITOR(GdipGetPathLastPoint),
MONITOR(GdipAddPathLine),
MONITOR(GdipAddPathLineI),
MONITOR(GdipAddPathLine2),
MONITOR(GdipAddPathLine2I),
MONITOR(GdipAddPathArc),
MONITOR(GdipAddPathArcI),
MONITOR(GdipAddPathBezier),
MONITOR(GdipAddPathBezierI),
MONITOR(GdipAddPathBeziers),
MONITOR(GdipAddPathBeziersI),
MONITOR(GdipAddPathCurve),
MONITOR(GdipAddPathCurveI),
MONITOR(GdipAddPathCurve2),
MONITOR(GdipAddPathCurve2I),
MONITOR(GdipAddPathCurve3),
MONITOR(GdipAddPathCurve3I),
MONITOR(GdipAddPathClosedCurve),
MONITOR(GdipAddPathClosedCurveI),
MONITOR(GdipAddPathClosedCurve2),
MONITOR(GdipAddPathClosedCurve2I),
MONITOR(GdipAddPathRectangle),
MONITOR(GdipAddPathRectangleI),
MONITOR(GdipAddPathRectangles),
MONITOR(GdipAddPathRectanglesI),
MONITOR(GdipAddPathEllipse),
MONITOR(GdipAddPathEllipseI),
MONITOR(GdipAddPathPie),
MONITOR(GdipAddPathPieI),
MONITOR(GdipAddPathPolygon),
MONITOR(GdipAddPathPolygonI),
MONITOR(GdipAddPathPath),
MONITOR(GdipAddPathString),
MONITOR(GdipAddPathStringI),
MONITOR(GdipFlattenPath),
MONITOR(GdipWidenPath),
MONITOR(GdipWidenPathWithMinimumResolutions),
MONITOR(GdipWindingModeOutline),
MONITOR(GdipWarpPath),
MONITOR(GdipTransformPath),
MONITOR(GdipGetPathWorldBounds),
MONITOR(GdipGetPathWorldBoundsI),
MONITOR(GdipIsVisiblePathPoint),
MONITOR(GdipIsVisiblePathPointI),
MONITOR(GdipIsOutlineVisiblePathPoint),
MONITOR(GdipIsOutlineVisiblePathPointI),
MONITOR(GdipCreatePathIter),
MONITOR(GdipDeletePathIter),
MONITOR(GdipPathIterNextSubpath),
MONITOR(GdipPathIterNextSubpathPath),
MONITOR(GdipPathIterNextPathType),
MONITOR(GdipPathIterNextMarker),
MONITOR(GdipPathIterNextMarkerPath),
MONITOR(GdipPathIterGetCount),
MONITOR(GdipPathIterGetSubpathCount),
MONITOR(GdipPathIterIsValid),
MONITOR(GdipPathIterHasCurve),
MONITOR(GdipPathIterRewind),
MONITOR(GdipPathIterEnumerate),
MONITOR(GdipPathIterCopyData),
MONITOR(GdipCreateMatrix),
MONITOR(GdipCreateMatrix2),
MONITOR(GdipCreateMatrix3),
MONITOR(GdipCreateMatrix3I),
MONITOR(GdipCloneMatrix),
MONITOR(GdipDeleteMatrix),
MONITOR(GdipSetMatrixElements),
MONITOR(GdipMultiplyMatrix),
MONITOR(GdipTranslateMatrix),
MONITOR(GdipScaleMatrix),
MONITOR(GdipRotateMatrix),
MONITOR(GdipShearMatrix),
MONITOR(GdipInvertMatrix),
MONITOR(GdipTransformMatrixPoints),
MONITOR(GdipTransformMatrixPointsI),
MONITOR(GdipVectorTransformMatrixPoints),
MONITOR(GdipVectorTransformMatrixPointsI),
MONITOR(GdipGetMatrixElements),
MONITOR(GdipIsMatrixInvertible),
MONITOR(GdipIsMatrixIdentity),
MONITOR(GdipIsMatrixEqual),
MONITOR(GdipCreateRegion),
MONITOR(GdipCreateRegionRect),
MONITOR(GdipCreateRegionRectI),
MONITOR(GdipCreateRegionPath),
MONITOR(GdipCreateRegionRgnData),
MONITOR(GdipCreateRegionHrgn),
MONITOR(GdipCloneRegion),
MONITOR(GdipDeleteRegion),
MONITOR(GdipSetInfinite),
MONITOR(GdipSetEmpty),
MONITOR(GdipCombineRegionRect),
MONITOR(GdipCombineRegionRectI),
MONITOR(GdipCombineRegionPath),
MONITOR(GdipCombineRegionRegion),
MONITOR(GdipTranslateRegion),
MONITOR(GdipTranslateRegionI),
MONITOR(GdipTransformRegion),
MONITOR(GdipGetRegionBounds),
MONITOR(GdipGetRegionBoundsI),
MONITOR(GdipGetRegionHRgn),
MONITOR(GdipIsEmptyRegion),
MONITOR(GdipIsInfiniteRegion),
MONITOR(GdipIsEqualRegion),
MONITOR(GdipGetRegionDataSize),
MONITOR(GdipGetRegionData),
MONITOR(GdipIsVisibleRegionPoint),
MONITOR(GdipIsVisibleRegionPointI),
MONITOR(GdipIsVisibleRegionRect),
MONITOR(GdipIsVisibleRegionRectI),
MONITOR(GdipGetRegionScansCount),
MONITOR(GdipGetRegionScans),
MONITOR(GdipGetRegionScansI),
MONITOR(GdipCloneBrush),
MONITOR(GdipDeleteBrush),
MONITOR(GdipGetBrushType),
MONITOR(GdipCreateHatchBrush),
MONITOR(GdipGetHatchStyle),
MONITOR(GdipGetHatchForegroundColor),
MONITOR(GdipGetHatchBackgroundColor),
MONITOR(GdipCreateTexture),
MONITOR(GdipCreateTexture2),
MONITOR(GdipCreateTextureIA),
MONITOR(GdipCreateTexture2I),
MONITOR(GdipSetTextureTransform),
MONITOR(GdipGetTextureTransform),
MONITOR(GdipResetTextureTransform),
MONITOR(GdipMultiplyTextureTransform),
MONITOR(GdipTranslateTextureTransform),
MONITOR(GdipScaleTextureTransform),
MONITOR(GdipRotateTextureTransform),
MONITOR(GdipSetTextureWrapMode),
MONITOR(GdipGetTextureWrapMode),
MONITOR(GdipGetTextureImage),
MONITOR(GdipCreateSolidFill),
MONITOR(GdipSetSolidFillColor),
MONITOR(GdipGetSolidFillColor),
MONITOR(GdipCreateLineBrush),
MONITOR(GdipCreateLineBrushI),
MONITOR(GdipCreateLineBrushFromRect),
MONITOR(GdipCreateLineBrushFromRectI),
MONITOR(GdipCreateLineBrushFromRectWithAngle),
MONITOR(GdipCreateLineBrushFromRectWithAngleI),
MONITOR(GdipSetLineColors),
MONITOR(GdipGetLineColors),
MONITOR(GdipGetLineRect),
MONITOR(GdipGetLineRectI),
MONITOR(GdipSetLineGammaCorrection),
MONITOR(GdipGetLineGammaCorrection),
MONITOR(GdipGetLineBlendCount),
MONITOR(GdipGetLineBlend),
MONITOR(GdipSetLineBlend),
MONITOR(GdipGetLinePresetBlendCount),
MONITOR(GdipGetLinePresetBlend),
MONITOR(GdipSetLinePresetBlend),
MONITOR(GdipSetLineSigmaBlend),
MONITOR(GdipSetLineLinearBlend),
MONITOR(GdipSetLineWrapMode),
MONITOR(GdipGetLineWrapMode),
MONITOR(GdipSetLineTransform),
MONITOR(GdipGetLineTransform),
MONITOR(GdipResetLineTransform),
MONITOR(GdipMultiplyLineTransform),
MONITOR(GdipTranslateLineTransform),
MONITOR(GdipScaleLineTransform),
MONITOR(GdipRotateLineTransform),
MONITOR(GdipCreatePathGradient),
MONITOR(GdipCreatePathGradientI),
MONITOR(GdipCreatePathGradientFromPath),
MONITOR(GdipGetPathGradientCenterColor),
MONITOR(GdipSetPathGradientCenterColor),
MONITOR(GdipGetPathGradientSurroundColorsWithCount),
MONITOR(GdipSetPathGradientSurroundColorsWithCount),
MONITOR(GdipGetPathGradientPath),
MONITOR(GdipSetPathGradientPath),
MONITOR(GdipGetPathGradientCenterPoint),
MONITOR(GdipGetPathGradientCenterPointI),
MONITOR(GdipSetPathGradientCenterPoint),
MONITOR(GdipSetPathGradientCenterPointI),
MONITOR(GdipGetPathGradientPointCount),
MONITOR(GdipGetPathGradientSurroundColorCount),
MONITOR(GdipGetPathGradientRect),
MONITOR(GdipGetPathGradientRectI),
MONITOR(GdipSetPathGradientGammaCorrection),
MONITOR(GdipGetPathGradientGammaCorrection),
MONITOR(GdipGetPathGradientBlendCount),
MONITOR(GdipGetPathGradientBlend),
MONITOR(GdipSetPathGradientBlend),
MONITOR(GdipGetPathGradientPresetBlendCount),
MONITOR(GdipGetPathGradientPresetBlend),
MONITOR(GdipSetPathGradientPresetBlend),
MONITOR(GdipSetPathGradientSigmaBlend),
MONITOR(GdipSetPathGradientLinearBlend),
MONITOR(GdipGetPathGradientWrapMode),
MONITOR(GdipSetPathGradientWrapMode),
MONITOR(GdipGetPathGradientTransform),
MONITOR(GdipSetPathGradientTransform),
MONITOR(GdipResetPathGradientTransform),
MONITOR(GdipMultiplyPathGradientTransform),
MONITOR(GdipTranslatePathGradientTransform),
MONITOR(GdipScalePathGradientTransform),
MONITOR(GdipRotatePathGradientTransform),
MONITOR(GdipGetPathGradientFocusScales),
MONITOR(GdipSetPathGradientFocusScales),
MONITOR(GdipCreatePen1),
MONITOR(GdipCreatePen2),
MONITOR(GdipClonePen),
MONITOR(GdipDeletePen),
MONITOR(GdipSetPenWidth),
MONITOR(GdipGetPenWidth),
MONITOR(GdipSetPenUnit),
MONITOR(GdipGetPenUnit),
MONITOR(GdipSetPenLineCap197819),
MONITOR(GdipSetPenStartCap),
MONITOR(GdipSetPenEndCap),
MONITOR(GdipSetPenDashCap197819),
MONITOR(GdipGetPenStartCap),
MONITOR(GdipGetPenEndCap),
MONITOR(GdipGetPenDashCap197819),
MONITOR(GdipSetPenLineJoin),
MONITOR(GdipGetPenLineJoin),
MONITOR(GdipSetPenCustomStartCap),
MONITOR(GdipGetPenCustomStartCap),
MONITOR(GdipSetPenCustomEndCap),
MONITOR(GdipGetPenCustomEndCap),
MONITOR(GdipSetPenMiterLimit),
MONITOR(GdipGetPenMiterLimit),
MONITOR(GdipSetPenMode),
MONITOR(GdipGetPenMode),
MONITOR(GdipSetPenTransform),
MONITOR(GdipGetPenTransform),
MONITOR(GdipResetPenTransform),
MONITOR(GdipMultiplyPenTransform),
MONITOR(GdipTranslatePenTransform),
MONITOR(GdipScalePenTransform),
MONITOR(GdipRotatePenTransform),
MONITOR(GdipSetPenColor),
MONITOR(GdipGetPenColor),
MONITOR(GdipSetPenBrushFill),
MONITOR(GdipGetPenBrushFill),
MONITOR(GdipGetPenFillType),
MONITOR(GdipGetPenDashStyle),
MONITOR(GdipSetPenDashStyle),
MONITOR(GdipGetPenDashOffset),
MONITOR(GdipSetPenDashOffset),
MONITOR(GdipGetPenDashCount),
MONITOR(GdipSetPenDashArray),
MONITOR(GdipGetPenDashArray),
MONITOR(GdipGetPenCompoundCount),
MONITOR(GdipSetPenCompoundArray),
MONITOR(GdipGetPenCompoundArray),
MONITOR(GdipCreateCustomLineCap),
MONITOR(GdipCloneCustomLineCap),
MONITOR(GdipGetCustomLineCapType),
MONITOR(GdipDeleteCustomLineCap),
MONITOR(GdipSetCustomLineCapStrokeCaps),
MONITOR(GdipGetCustomLineCapStrokeCaps),
MONITOR(GdipSetCustomLineCapStrokeJoin),
MONITOR(GdipGetCustomLineCapStrokeJoin),
MONITOR(GdipSetCustomLineCapBaseCap),
MONITOR(GdipGetCustomLineCapBaseCap),
MONITOR(GdipSetCustomLineCapBaseInset),
MONITOR(GdipGetCustomLineCapBaseInset),
MONITOR(GdipSetCustomLineCapWidthScale),
MONITOR(GdipGetCustomLineCapWidthScale),
MONITOR(GdipCreateAdjustableArrowCap),
MONITOR(GdipSetAdjustableArrowCapHeight),
MONITOR(GdipGetAdjustableArrowCapHeight),
MONITOR(GdipSetAdjustableArrowCapWidth),
MONITOR(GdipGetAdjustableArrowCapWidth),
MONITOR(GdipSetAdjustableArrowCapMiddleInset),
MONITOR(GdipGetAdjustableArrowCapMiddleInset),
MONITOR(GdipSetAdjustableArrowCapFillState),
MONITOR(GdipGetAdjustableArrowCapFillState),
MONITOR(GdipLoadImageFromStream),
MONITOR(GdipLoadImageFromFile),
MONITOR(GdipLoadImageFromStreamICM),
MONITOR(GdipLoadImageFromFileICM),
MONITOR(GdipGetEncoderParameterListSize),
MONITOR(GdipGetEncoderParameterList),
MONITOR(GdipSaveImageToStream),
MONITOR(GdipSaveImageToFile),
MONITOR(GdipSaveAdd),
MONITOR(GdipSaveAddImage),
MONITOR(GdipImageGetFrameDimensionsCount),
MONITOR(GdipImageGetFrameDimensionsList),
MONITOR(GdipImageGetFrameCount),
MONITOR(GdipImageSelectActiveFrame),
MONITOR(GdipImageRotateFlip),
MONITOR(GdipGetPropertyCount),
MONITOR(GdipGetPropertyIdList),
MONITOR(GdipGetPropertyItemSize),
MONITOR(GdipGetPropertyItem),
MONITOR(GdipGetPropertySize),
MONITOR(GdipGetAllPropertyItems),
MONITOR(GdipRemovePropertyItem),
MONITOR(GdipSetPropertyItem),
MONITOR(GdipCloneImage),
MONITOR(GdipDisposeImage),
MONITOR(GdipGetImageGraphicsContext),
MONITOR(GdipGetImageBounds),
MONITOR(GdipGetImageDimension),
MONITOR(GdipGetImageWidth),
MONITOR(GdipGetImageHeight),
MONITOR(GdipGetImageHorizontalResolution),
MONITOR(GdipGetImageVerticalResolution),
MONITOR(GdipGetImageFlags),
MONITOR(GdipGetImageRawFormat),
MONITOR(GdipGetImagePixelFormat),
MONITOR(GdipGetImagePalette),
MONITOR(GdipSetImagePalette),
MONITOR(GdipGetImagePaletteSize),
MONITOR(GdipGetImageType),
MONITOR(GdipGetImageThumbnail),
MONITOR(GdipImageForceValidation),
MONITOR(GdipCreateBitmapFromStream),
MONITOR(GdipCreateBitmapFromFile),
MONITOR(GdipCreateBitmapFromStreamICM),
MONITOR(GdipCreateBitmapFromFileICM),
MONITOR(GdipCreateBitmapFromScan0),
MONITOR(GdipCreateBitmapFromGraphics),
MONITOR(GdipCreateBitmapFromDirectDrawSurface),
MONITOR(GdipCreateBitmapFromGdiDib),
MONITOR(GdipCreateBitmapFromHBITMAP),
MONITOR(GdipCreateHBITMAPFromBitmap),
MONITOR(GdipCreateBitmapFromHICON),
MONITOR(GdipCreateBitmapFromResource),
MONITOR(GdipCreateHICONFromBitmap),
MONITOR(GdipCloneBitmapArea),
MONITOR(GdipCloneBitmapAreaI),
MONITOR(GdipBitmapLockBits),
MONITOR(GdipBitmapUnlockBits),
MONITOR(GdipBitmapGetPixel),
MONITOR(GdipBitmapSetPixel),
MONITOR(GdipBitmapSetResolution),
MONITOR(GdipCreateImageAttributes),
MONITOR(GdipCloneImageAttributes),
MONITOR(GdipDisposeImageAttributes),
MONITOR(GdipSetImageAttributesToIdentity),
MONITOR(GdipResetImageAttributes),
MONITOR(GdipSetImageAttributesColorMatrix),
MONITOR(GdipSetImageAttributesThreshold),
MONITOR(GdipSetImageAttributesGamma),
MONITOR(GdipSetImageAttributesNoOp),
MONITOR(GdipSetImageAttributesColorKeys),
MONITOR(GdipSetImageAttributesOutputChannel),
MONITOR(GdipSetImageAttributesOutputChannelColorProfile),
MONITOR(GdipSetImageAttributesRemapTable),
MONITOR(GdipSetImageAttributesCachedBackground),
MONITOR(GdipSetImageAttributesWrapMode),
MONITOR(GdipSetImageAttributesICMMode),
MONITOR(GdipGetImageAttributesAdjustedPalette),
MONITOR(GdipCreateFromHDC),
MONITOR(GdipCreateFromHDC2),
MONITOR(GdipCreateFromHWND),
MONITOR(GdipCreateFromHWNDICM),
MONITOR(GdipDeleteGraphics),
MONITOR(GdipFlush),
MONITOR(GdipSetRenderingOrigin),
MONITOR(GdipGetRenderingOrigin),
MONITOR(GdipSetCompositingMode),
MONITOR(GdipGetCompositingMode),
MONITOR(GdipSetCompositingQuality),
MONITOR(GdipGetCompositingQuality),
MONITOR(GdipSetSmoothingMode),
MONITOR(GdipGetSmoothingMode),
MONITOR(GdipSetPixelOffsetMode),
MONITOR(GdipGetPixelOffsetMode),
MONITOR(GdipSetTextRenderingHint),
MONITOR(GdipSetTextGammaValue),
MONITOR(GdipGetTextGammaValue),
MONITOR(GdipSetTextContrast),
MONITOR(GdipGetTextContrast),
MONITOR(GdipGetTextRenderingHint),
MONITOR(GdipSetInterpolationMode),
MONITOR(GdipGetInterpolationMode),
MONITOR(GdipSetWorldTransform),
MONITOR(GdipResetWorldTransform),
MONITOR(GdipMultiplyWorldTransform),
MONITOR(GdipTranslateWorldTransform),
MONITOR(GdipScaleWorldTransform),
MONITOR(GdipRotateWorldTransform),
MONITOR(GdipGetWorldTransform),
MONITOR(GdipResetPageTransform),
MONITOR(GdipGetPageUnit),
MONITOR(GdipSetPageUnit),
MONITOR(GdipGetPageScale),
MONITOR(GdipSetPageScale),
MONITOR(GdipGetDpiX),
MONITOR(GdipGetDpiY),
MONITOR(GdipTransformPoints),
MONITOR(GdipTransformPointsI),
MONITOR(GdipGetNearestColor),
MONITOR(GdipDrawLine),
MONITOR(GdipDrawLineI),
MONITOR(GdipDrawLines),
MONITOR(GdipDrawLinesI),
MONITOR(GdipDrawArc),
MONITOR(GdipDrawArcI),
MONITOR(GdipDrawBezier),
MONITOR(GdipDrawBezierI),
MONITOR(GdipDrawBeziers),
MONITOR(GdipDrawBeziersI),
MONITOR(GdipDrawRectangle),
MONITOR(GdipDrawRectangleI),
MONITOR(GdipDrawRectangles),
MONITOR(GdipDrawRectanglesI),
MONITOR(GdipDrawEllipse),
MONITOR(GdipDrawEllipseI),
MONITOR(GdipDrawPie),
MONITOR(GdipDrawPieI),
MONITOR(GdipDrawPolygon),
MONITOR(GdipDrawPolygonI),
MONITOR(GdipDrawPath),
MONITOR(GdipDrawCurve),
MONITOR(GdipDrawCurveI),
MONITOR(GdipDrawCurve2),
MONITOR(GdipDrawCurve2I),
MONITOR(GdipDrawCurve3),
MONITOR(GdipDrawCurve3I),
MONITOR(GdipDrawClosedCurve),
MONITOR(GdipDrawClosedCurveI),
MONITOR(GdipDrawClosedCurve2),
MONITOR(GdipDrawClosedCurve2I),
MONITOR(GdipGraphicsClear),
MONITOR(GdipFillRectangle),
MONITOR(GdipFillRectangleI),
MONITOR(GdipFillRectangles),
MONITOR(GdipFillRectanglesI),
MONITOR(GdipFillPolygon),
MONITOR(GdipFillPolygonI),
MONITOR(GdipFillPolygon2),
MONITOR(GdipFillPolygon2I),
MONITOR(GdipFillEllipse),
MONITOR(GdipFillEllipseI),
MONITOR(GdipFillPie),
MONITOR(GdipFillPieI),
MONITOR(GdipFillPath),
MONITOR(GdipFillClosedCurve),
MONITOR(GdipFillClosedCurveI),
MONITOR(GdipFillClosedCurve2),
MONITOR(GdipFillClosedCurve2I),
MONITOR(GdipFillRegion),
MONITOR(GdipDrawString),
MONITOR(GdipMeasureString),
MONITOR(GdipMeasureCharacterRanges),
MONITOR(GdipDrawDriverString),
MONITOR(GdipMeasureDriverString),
MONITOR(GdipGetFamilyName),
MONITOR(GdipDrawImage),
MONITOR(GdipDrawImageI),
MONITOR(GdipDrawImageRect),
MONITOR(GdipDrawImageRectI),
MONITOR(GdipDrawImagePoints),
MONITOR(GdipDrawImagePointsI),
MONITOR(GdipDrawImagePointRect),
MONITOR(GdipDrawImagePointRectI),
MONITOR(GdipDrawImageRectRect),
MONITOR(GdipDrawImageRectRectI),
MONITOR(GdipDrawImagePointsRect),
MONITOR(GdipDrawImagePointsRectI),
MONITOR(GdipEnumerateMetafileDestPoint),
MONITOR(GdipEnumerateMetafileDestPointI),
MONITOR(GdipEnumerateMetafileDestRect),
MONITOR(GdipEnumerateMetafileDestRectI),
MONITOR(GdipEnumerateMetafileDestPoints),
MONITOR(GdipEnumerateMetafileDestPointsI),
MONITOR(GdipEnumerateMetafileSrcRectDestPoint),
MONITOR(GdipEnumerateMetafileSrcRectDestPointI),
MONITOR(GdipEnumerateMetafileSrcRectDestRect),
MONITOR(GdipEnumerateMetafileSrcRectDestRectI),
MONITOR(GdipEnumerateMetafileSrcRectDestPoints),
MONITOR(GdipEnumerateMetafileSrcRectDestPointsI),
MONITOR(GdipPlayMetafileRecord),
MONITOR(GdipSetClipGraphics),
MONITOR(GdipSetClipRect),
MONITOR(GdipSetClipRectI),
MONITOR(GdipSetClipPath),
MONITOR(GdipSetClipRegion),
MONITOR(GdipSetClipHrgn),
MONITOR(GdipResetClip),
MONITOR(GdipTranslateClip),
MONITOR(GdipTranslateClipI),
MONITOR(GdipGetClip),
MONITOR(GdipGetClipBounds),
MONITOR(GdipGetClipBoundsI),
MONITOR(GdipIsClipEmpty),
MONITOR(GdipGetVisibleClipBounds),
MONITOR(GdipGetVisibleClipBoundsI),
MONITOR(GdipIsVisibleClipEmpty),
MONITOR(GdipIsVisiblePoint),
MONITOR(GdipIsVisiblePointI),
MONITOR(GdipIsVisibleRect),
MONITOR(GdipIsVisibleRectI),
MONITOR(GdipSaveGraphics),
MONITOR(GdipRestoreGraphics),
MONITOR(GdipBeginContainer),
MONITOR(GdipBeginContainer2),
MONITOR(GdipBeginContainerI),
MONITOR(GdipEndContainer),
MONITOR(GdipGetMetafileHeaderFromWmf),
MONITOR(GdipGetMetafileHeaderFromEmf),
MONITOR(GdipGetMetafileHeaderFromFile),
MONITOR(GdipGetMetafileHeaderFromStream),
MONITOR(GdipGetMetafileHeaderFromMetafile),
MONITOR(GdipGetHemfFromMetafile),
MONITOR(GdipCreateStreamOnFile),
MONITOR(GdipCreateMetafileFromWmf),
MONITOR(GdipCreateMetafileFromEmf),
MONITOR(GdipCreateMetafileFromFile),
MONITOR(GdipCreateMetafileFromWmfFile),
MONITOR(GdipCreateMetafileFromStream),
MONITOR(GdipRecordMetafile),
MONITOR(GdipRecordMetafileI),
MONITOR(GdipRecordMetafileFileName),
MONITOR(GdipRecordMetafileFileNameI),
MONITOR(GdipRecordMetafileStream),
MONITOR(GdipRecordMetafileStreamI),
MONITOR(GdipSetMetafileDownLevelRasterizationLimit),
MONITOR(GdipGetMetafileDownLevelRasterizationLimit),
MONITOR(GdipGetImageDecodersSize),
MONITOR(GdipGetImageDecoders),
MONITOR(GdipGetImageEncodersSize),
MONITOR(GdipGetImageEncoders),
MONITOR(GdipAlloc),
MONITOR(GdipFree),
MONITOR(GdipCreateFontFamilyFromName),
MONITOR(GdipGetGenericFontFamilySansSerif),
MONITOR(GdipGetGenericFontFamilySerif),
MONITOR(GdipGetGenericFontFamilyMonospace),
MONITOR(GdipCreateFont),
MONITOR(GdipDeleteFontFamily),
MONITOR(GdipCloneFontFamily),
MONITOR(GdipGetFamily),
MONITOR(GdipGetFontStyle),
MONITOR(GdipGetLogFontA),
MONITOR(GdipGetLogFontW),
MONITOR(GdipGetFontSize),
MONITOR(GdipGetFontUnit),
MONITOR(GdipGetFontHeight),
MONITOR(GdipGetFontHeightGivenDPI),
MONITOR(GdipCloneFont),
MONITOR(GdipDeleteFont),
MONITOR(GdipGetGraphicsPixel),
MONITOR(GdipGetDC),
MONITOR(GdipReleaseDC),
MONITOR(GdipComment),
MONITOR(GdipIsStyleAvailable),
MONITOR(GdipGetEmHeight),
MONITOR(GdipGetCellAscent),
MONITOR(GdipGetCellDescent),
MONITOR(GdipGetLineSpacing),
MONITOR(GdipCreateFontFromDC),
MONITOR(GdipCreateFontFromLogfontA),
MONITOR(GdipCreateFontFromLogfontW),
MONITOR(GdipNewInstalledFontCollection),
MONITOR(GdipNewPrivateFontCollection),
MONITOR(GdipDeletePrivateFontCollection),
MONITOR(GdipGetFontCollectionFamilyCount),
MONITOR(GdipGetFontCollectionFamilyList),
MONITOR(GdipPrivateAddFontFile),
MONITOR(GdipPrivateAddMemoryFont),
MONITOR(GdipSetFontSize),
MONITOR(GdipCreateStringFormat),
MONITOR(GdipStringFormatGetGenericDefault),
MONITOR(GdipStringFormatGetGenericTypographic),
MONITOR(GdipCloneStringFormat),
MONITOR(GdipDeleteStringFormat),
MONITOR(GdipSetStringFormatFlags),
MONITOR(GdipGetStringFormatFlags),
MONITOR(GdipSetStringFormatLineSpacing),
MONITOR(GdipGetStringFormatLineSpacingAmount),
MONITOR(GdipGetStringFormatLineSpacingMethod),
MONITOR(GdipSetStringFormatAlign),
MONITOR(GdipGetStringFormatAlign),
MONITOR(GdipSetStringFormatLineAlign),
MONITOR(GdipGetStringFormatLineAlign),
MONITOR(GdipSetStringFormatHotkeyPrefix),
MONITOR(GdipGetStringFormatHotkeyPrefix),
MONITOR(GdipSetStringFormatTabStops),
MONITOR(GdipGetStringFormatTabStopCount),
MONITOR(GdipGetStringFormatTabStops),
MONITOR(GdipSetStringFormatMeasurableCharacterRanges),
MONITOR(GdipGetStringFormatMeasurableCharacterRangeCount),
MONITOR(GdipSetStringFormatDigitSubstitution),
MONITOR(GdipGetStringFormatDigitSubstitution),
MONITOR(GdipSetStringFormatTrimming),
MONITOR(GdipGetStringFormatTrimming),
MONITOR(GdipCreateCachedBitmap),
MONITOR(GdipDeleteCachedBitmap),
MONITOR(GdipDrawCachedBitmap),
MONITOR(GdipMonitorControl),
MONITOR(GdipTestControl),
MONITOR(GdiplusStartup),
MONITOR(GdiplusShutdown),
MONITOR(GdipCreateHalftonePalette),
MONITOR(GdiplusNotificationHook),
MONITOR(GdiplusNotificationUnhook),
MONITOR(GdipEmfToWmfBits),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\flatddi.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   flatddi.cpp
*
* Abstract:
*
*   Flat GDI+ DDI API wrappers
*
* Revision History:
*
*   1/14/2k ericvan
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

DpPath*
WINGDIPAPI
DpcCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen, 
    DpContext* context,
    BOOL outline
    )
{
    ASSERT(path && pen);
    
    // context can be NULL
    return GpPath::DriverCreateWidenedPath(
        path, 
        pen, 
        context,
        outline
    );
}

VOID
WINGDIPAPI
DpcDeletePath(
    DpPath* path
    )
{
    ASSERT(path);
    
    GpPath::DriverDeletePath(path);
}

DpPath*
WINGDIPAPI
DpcClonePath(
    DpPath* path
    )
{
    ASSERT(path);

    return GpPath::DriverClonePath(path);
}

VOID
WINGDIPAPI
DpcTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    ASSERT(path);   // matrix can be NULL.

    GpPath::DriverTransformPath(path, matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\precomp.hpp ===
#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"

#include "..\..\privinc\imaging.h"
#include "codecmgr.hpp"
#include "imgutils.hpp"
//#include "..\..\sdkinc\GdiplusFontFamily.h"

#include "..\..\ddkinc\ddiplus.hpp"

// Hack
#include "..\Render\scan.hpp"
#include "..\Render\scandib.hpp"
// EndHack

#include "initialize.hpp"
#include "Object.hpp"
#include "DpRegion.hpp"
#include "region.hpp"
#include "intmap.hpp"
#include "..\fondrv\tt\ttfd\fontddi.h"
#include "fontFace.hpp"
#include "family.hpp"
#include "font.hpp"
#include "stringFormat.hpp"
#include "fontable.hpp"
#include "fontlinking.hpp"
#include "..\fondrv\tt\ttfd\mapfile.h"
#include "fontfile.hpp"
#include "fontcollection.hpp"
#include "path.hpp"
#include "ImageAttr.hpp"
#include "gpbitmap.hpp"
#include "brush.hpp"
#include "CustomLineCap.hpp"
#include "pen.hpp"
#include "Metafile.hpp"
#include "DrawGlyphData.hpp"

#include "device.hpp"
#include "graphics.hpp"
#include "QuadTransforms.hpp"
#include "CachedBitmap.hpp"
#include "..\common\monitors.hpp"
#include "..\common\testcontrol.hpp"
#include "..\render\httables.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\gpverp.h ===
/****************************************************************************
 *                                                                          *
 *      gpverp.h      -- Version information for internal builds            *
 *                       Shamelessly swiped from NT sdkinc                  *
 *                                                                          *
 *      This file is only modified by the official builder to update        *
 *      VER_PRODUCTBUILD, and sometimes                                     *
 *      VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR or VER_PRODUCTBUILD_QFE. *
 *                                                                          *
 ****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntverp.h>

#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_DW
#undef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD_QFE
#undef VER_BPAD

/*--------------------------------------------------------------*/
/* The following values should be modified by the official      */
/* builder for each build.                                      */
/* Usually only GPVER_PRODUCTBUILD needs to be changed.         */
/*--------------------------------------------------------------*/

// PRODUCTBUILD can only have an integer number. Use QFE for dot builds.
#define VER_PRODUCTBUILD            3101
#define VER_PRODUCTBUILD_QFE        0
#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_DW       (0x05010000 | VER_PRODUCTBUILD)

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\sources.inc ===
#****************************** File Header ******************************\
# File Name: Sources.Inc
#
# Copyright (c) 1999, Microsoft Corporation
#
# Project specific SOURCES file.
#
#***************************************************************************/

!ifndef GDIPROOT
GDIPROOT=$(ADVCORE_PATH)\gdiplus
!endif

!include $(GDIPROOT)\sources.inc

MAJORCOMP=windows
MINORCOMP=gdiplus
TARGETPATH=$(_OBJ_DIR)

## SubSystem must be 4.00 to load on Win95

SUBSYSTEM_VERSION=4.00
USE_MAPSYM=1

C_DEFINES=$(C_DEFINES) -DWINVER=0x0500
INCLUDES=..;..\..;..\..\..\sdkinc;..\..\..\ddkinc;..\..\Entry
INCLUDES=$(INCLUDES);$(GDIPIMG)\api

SYNCHRONIZE_DRAIN=1

SOURCES=\
        ..\FlatApi.cpp \
        ..\FlatDdi.cpp \
        ..\gdiplus.rc

COMBINELIBS=                                              \
        ..\..\render\$(O)\Render.lib                      \
        ..\..\PDrivers\$(O)\PDrivers.lib                  \
        ..\..\Common\$(O)\Common.lib                      \
        ..\..\Entry\$(O)\Entry.lib                        \
        ..\..\ddi\$(O)\ddi.lib                            \
        ..\..\fondrv\tt\scaler\$(O)\fscaler.lib           \
        ..\..\fondrv\tt\ttfd\$(O)\ttfd.lib                \
        ..\..\gpmf3216\$(O)\gpmf3216.lib                  \
        ..\..\Text\lib\$(O)\gpotls.lib                    \
        ..\..\Text\lib\$(O)\unilib.lib                    \
        ..\..\Text\lib\$(O)\shaping.lib                   \
        ..\..\Text\lib\$(O)\TextImager.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\flatapi.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   flatapi.cpp
*
* Abstract:
*
*   Flat GDI+ API wrappers
*
* Revision History:
*
*   12/13/1998 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "GdiplusFlat.h"
#include "gpverp.h"

#if DBG
#include <mmsystem.h>
#endif

extern "C" {


//--------------------------------------------------------------------------
//  CheckParameter(p)
//
//     If p evaluates to FALSE, then we currently assert.  In future,
//     we can simply return an invalid parameter status which throws
//     an exception.
//
//  CheckObjectBusy(p)
//
//     Not implemented.  Bails out if object is currently being used.
//
//--------------------------------------------------------------------------
//
// !!!: Only include NULL & IsValid checks in checked builds?
//
// !!!: Instead of deleting object, call a Dispose() method, so far
//       only Bitmap supports this.
//
// !!!: Lock Matrix objects, what about color?
//
// !! Better error checking.  For 'I' APIs which convert from Point to PointI,
//    etc.  Verify count & point are valid first.
//
// !! Change ObjectLock to mutable memory and GetObjectLock() to a const member.
//

#define CheckParameter(cond) \
            if (! (cond)) \
                return InvalidParameter;

#define CheckParameterValid(obj) \
            if (!(obj) || !((obj)->IsValid())) \
                return InvalidParameter;

#define CheckOptionalParameterValid(obj) \
            if ((obj) && (!(obj)->IsValid())) \
                return InvalidParameter;

#define CheckObjectBusy(obj) \
      GpLock lock##obj(obj->GetObjectLock()); \
      if (!(lock##obj).IsValid()) \
            return ObjectBusy;

#define CheckOptionalObjectBusy(obj) \
      GpLock lock##obj(obj ? obj->GetObjectLock() : NULL); \
      if (obj && (!(lock##obj).IsValid())) \
            return ObjectBusy;

// We should put an assert in here so that we stop in the debugger if anyone
// does this.

#define CheckObjectBusyForDelete(obj) \
      GpLock lock##obj(obj->GetObjectLock()); \
      if (!(lock##obj).IsValid())             \
      {                                       \
            WARNING(("Silent memory leak deleting object %p.", obj)); \
            WARNING(("Object lock held by another thread."));\
            WARNING(("Incorrect synchronization by the calling application."));\
            return ObjectBusy;                \
      }                                       \
      lock##obj.MakePermanentLock();

#define CheckColorParameter(color) \
            ;


#define LazilyInitializeGdiplus

#define CheckGdiplusInitialized \
    { GdiplusStartupCriticalSection critsec; \
      if (Globals::LibraryInitRefCount <= 0) \
          return GdiplusNotInitialized; \
    }

#define CheckGdiplusInitialized_ReturnNULL \
    { GdiplusStartupCriticalSection critsec; \
      if (Globals::LibraryInitRefCount <= 0) \
          return NULL; \
    }

#if DBG

// This class asserts that GDI+ is in an initialized state, to be used in
// our entry-point functions in a debug build.
//
// We assert both at the start and the end of the call, and we make sure that
// we don't hold the critical section for the duration of the API (else this
// would serialize all our calls on debug builds.)

class InitAsserter
{
public:
    InitAsserter() {
        GdiplusStartupCriticalSection critsec;
        ASSERTMSG(Globals::LibraryInitRefCount > 0, ("GDI+ API called before GdiplusStartup/after GdiplusShutdown."));
    }
    ~InitAsserter() {
        GdiplusStartupCriticalSection critsec;
        ASSERTMSG(Globals::LibraryInitRefCount > 0, ("GDI+ API called before GdiplusStartup/after GdiplusShutdown."));
    }
};
#endif

#ifdef GP_ENABLE_MONITORS
#ifdef GP_RELEASE_BUILD
    #define DEFINE_MONITOR(a)
#else
    #define DEFINE_MONITOR(a) GpBlockMonitor blockMonitor(MONITOR(a));
#endif
#else
    #define DEFINE_MONITOR(a)
#endif    

// Define this to do something on each API entry point.
// This is a debugging aid for complex instruction streams (e.g. Office)
// [agodfrey] Well, it just became more than a mere debugging aid...
// [asecchia] Now it's definitely more than a debugging aid...
//            FPUStateSaver was being forgotten on many of our APIs so
//            it's now in here and therefore will be included in all of
//            our APIs (except Startup and Shutdown).

#if DBG
    #define API_ENTRY(a) \
        DEFINE_MONITOR(a) \
        LazilyInitializeGdiplus; \
        VERBOSE(("GDI+ API " #a)); \
        InitAsserter __initAsserter; \
        FPUStateSaver fps;

    #define API_ENTRY_NO_INITCHECK(a) \
        DEFINE_MONITOR(a) \
        VERBOSE(("GDI+ API ", #a));
#else

    #define API_ENTRY(a) \
        DEFINE_MONITOR(a) \
        LazilyInitializeGdiplus;\
        FPUStateSaver fps;

    #define API_ENTRY_NO_INITCHECK(a) \
        DEFINE_MONITOR(a)
#endif

GdiplusStartupOutput gStartupOutput = {
    NotificationStartup,
    NotificationShutdown
};

GpStatus WINAPI
GdiplusStartup(
    OUT ULONG_PTR *token,
    const GdiplusStartupInput *input,
    OUT GdiplusStartupOutput *output)
{
    API_ENTRY_NO_INITCHECK(GdiplusStartup);

    if (   (!token)
        || (!input)
        || (input->SuppressBackgroundThread && !output))
    {
        return InvalidParameter;
    }

    if (input->GdiplusVersion != 1)
    {
        return UnsupportedGdiplusVersion;
    }

    GdiplusStartupCriticalSection critsec;

    // Should never happen, because GdiplusShutdown won't decrement below zero.

    if (Globals::LibraryInitRefCount == 0)
    {
        // Note: We can't allocate anything before this point

        GpStatus ret = InternalGdiplusStartup(input);

        if (ret != Ok) return ret;

        Globals::LibraryInitToken = GenerateInitToken();
    }

    ASSERT(Globals::LibraryInitRefCount >= 0);

    *token = Globals::LibraryInitToken + Globals::LibraryInitRefCount;
    Globals::LibraryInitRefCount++;

    if (input->SuppressBackgroundThread)
    {
        *output = gStartupOutput;
    }
    return Ok;
}

VOID WINAPI
GdiplusShutdown(
    ULONG_PTR token)
{
    API_ENTRY_NO_INITCHECK(GdiplusShutdown);

    GdiplusStartupCriticalSection critsec;

    // Should never happen, because we won't decrement below zero.

    ASSERT(Globals::LibraryInitRefCount >= 0);

    if (Globals::LibraryInitRefCount == 0)
    {
        // Return - i.e. ignore the extra shutdown call

        RIP(("Too many calls to GdiplusShutdown"));
        return;
    }

    if (Globals::LibraryInitRefCount == 1)
    {
        // Shut down for real

        Globals::LibraryInitToken = 0;

        InternalGdiplusShutdown();

        // No allocation/deallocation can happen after this point
    }
    else if (token == Globals::LibraryInitToken)
    {
        // The first client to initialize is shutting down; we must clean up
        // after this one since it defines certain global behavior.

        Globals::UserDebugEventProc = NULL;
    }

    Globals::LibraryInitRefCount--;
}

GpStatus WINAPI
GdiplusNotificationHook(
    OUT ULONG_PTR *token)
{
    API_ENTRY(GdiplusNotificationHook);

    {
        GdiplusStartupCriticalSection critsec;

        // It's illegal to call this API if you're using a background thread.

        if (Globals::ThreadNotify)
        {
            return GenericError;
        }
    }

    return NotificationStartup(token);
}

VOID WINAPI
GdiplusNotificationUnhook(
    ULONG_PTR token)
{
    API_ENTRY(GdiplusNotificationUnhook);

    {
        GdiplusStartupCriticalSection critsec;

        // It's illegal to call this API if you're using a background thread.

        if (Globals::ThreadNotify)
        {
            return;
        }
    }

    NotificationShutdown(token);
}

GpStatus
WINGDIPAPI
GdipCreatePath(GpFillMode fillMode, GpPath **outPath)
{
    API_ENTRY(GdipCreatePath);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(outPath);

    GpPath * path;

    path = (GpPath *) InterlockedExchangePointer((PVOID *) &Globals::PathLookAside, NULL);

    if(path  != NULL)
    {
        path->GetObjectLock()->Reset();
        path->Reset(fillMode);
    }
    else
    {
        path = new (GpPathTag, TRUE) GpPath(fillMode);
    }


    if (CheckValid(path))
    {
        *outPath = path;
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePath2(
    GDIPCONST GpPointF* points,
    GDIPCONST BYTE* types,
    INT count,
    GpFillMode fillMode,
    GpPath **path
    )
{
    API_ENTRY(GdipCreatePath2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(path && points && types);

    *path = new (GpPathTag, TRUE) GpPath(points, types, count, fillMode);

    if (CheckValid(*path))
    {
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePath2I(
    GDIPCONST GpPoint* points,
    GDIPCONST BYTE* types,
    INT count,
    GpFillMode fillMode,
    GpPath **path
    )
{
    API_ENTRY(GdipCreatePath2I);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(path && points && types);

    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    *path = new (GpPathTag, TRUE) GpPath(pointsF, types, count, fillMode);

    if (CheckValid(*path))
    {
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipClonePath(
    GpPath* path,
    GpPath** clonepath
    )
{
    API_ENTRY(GdipClonePath);
    CheckParameter(clonepath);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *clonepath = path->Clone();

    if (*clonepath)
    {
        // Make sure we tag this allocation as an API allocation
        GpTagMalloc(*clonepath, GpPathTag, TRUE);
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeletePath(
    GpPath* path
    )
{
    API_ENTRY(GdipDeletePath);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.

    CheckParameter(path);
    CheckObjectBusyForDelete(path);

    path = (GpPath *) InterlockedExchangePointer((PVOID *) &Globals::PathLookAside, path);

    if(path != NULL)
    {
        delete path;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipResetPath(
    GpPath* path
    )
{
    API_ENTRY(GdipResetPath);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->Reset();
}

GpStatus
WINGDIPAPI
GdipGetPointCount(
    GpPath* path,
    INT *count
    )
{
    API_ENTRY(GdipGetPointCount);
    CheckParameter(count);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *count = path->GetPointCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathTypes(
    GpPath* path,
    BYTE* types,
    INT count
    )
{
    API_ENTRY(GdipGetPathTypes);
    CheckParameter(types && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    INT pathCount;

    pathCount = path->GetPointCount();

    if (pathCount > count)
        return InsufficientBuffer;

    if (pathCount < 0)
        return GenericError;

    GpMemcpy(types, path->GetPathTypes(), pathCount);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathPoints(
    GpPath* path,
    GpPointF* points,
    INT count
    )
{
    API_ENTRY(GdipGetPathPoints);
    // NOTE: Race condition between GetPointCount() & GetPathPoints()
    //       we need a manually invokable lock here.

    CheckParameter(points && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    INT pathCount;

    pathCount = path->GetPointCount();

    if (pathCount > count)
        return InsufficientBuffer;

    if (pathCount < 0)
        return GenericError;

    GpMemcpy(points, path->GetPathPoints(), pathCount*sizeof(GpPointF));

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathPointsI(
    GpPath* path,
    GpPoint* points,
    INT count
    )
{
    API_ENTRY(GdipGetPathPointsI);
    // NOTE: Race condition between GetPointCount() & GetPathPoints()
    //       we need a manually invokable lock here.

    CheckParameter(points && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    INT pathCount;

    pathCount = path->GetPointCount();

    if (pathCount > count)
        return InsufficientBuffer;

    if (pathCount < 0)
        return GenericError;


    GDIPCONST GpPointF *pointsF = path->GetPathPoints();

    for (INT i=0; i<count; i++)
    {
        points[i].X = GpRound(pointsF[i].X);
        points[i].Y = GpRound(pointsF[i].Y);
    }

    return Ok;
}


GpStatus
WINGDIPAPI
GdipGetPathFillMode(
    GpPath *path,
    GpFillMode *fillmode
    )
{
    API_ENTRY(GdipGetPathFillMode);
    CheckParameter(fillmode);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *fillmode = (GpFillMode)path->GetFillMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathFillMode(
    GpPath *path,
    GpFillMode fillmode
    )
{
    API_ENTRY(GdipSetPathFillMode);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    path->SetFillMode(fillmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathData(
    GpPath *path,
    GpPathData* pathData
    )
{
    API_ENTRY(GdipSetPathData);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->SetPathData(pathData);
}

GpStatus
WINGDIPAPI
GdipGetPathData(
    GpPath *path,
    GpPathData* pathData
    )
{
    API_ENTRY(GdipGetPathData);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->GetPathData(pathData);
}

GpStatus
WINGDIPAPI
GdipStartPathFigure(
    GpPath *path
    )
{
    API_ENTRY(GdipStartPathFigure);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    path->StartFigure();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipClosePathFigure(
    GpPath *path
    )
{
    API_ENTRY(GdipClosePathFigure);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->CloseFigure();
}

GpStatus
WINGDIPAPI
GdipClosePathFigures(
    GpPath *path
    )
{
    API_ENTRY(GdipClosePathFigures);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->CloseFigures();
}

GpStatus
WINGDIPAPI
GdipSetPathMarker(
    GpPath *path
    )
{
    API_ENTRY(GdipSetPathMarker);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->SetMarker();
}

GpStatus
WINGDIPAPI
GdipClearPathMarkers(
    GpPath *path
    )
{
    API_ENTRY(GdipClearPathMarkers);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->ClearMarkers();
}

GpStatus
WINGDIPAPI
GdipReversePath(
    GpPath* path
    )
{
    API_ENTRY(GdipReversePath);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->Reverse();
}

GpStatus
WINGDIPAPI
GdipGetPathLastPoint(
    GpPath* path,
    GpPointF* lastPoint
    )
{
    API_ENTRY(GdipGetPathLastPoint);
    CheckParameter(lastPoint);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->GetLastPoint(lastPoint);
}

GpStatus
WINGDIPAPI
GdipAddPathLine(
    GpPath *path,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2
    )
{
    API_ENTRY(GdipAddPathLine);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->AddLine(x1, y1, x2, y2);
}

GpStatus
WINGDIPAPI
GdipAddPathLineI(
    GpPath *path,
    INT x1,
    INT y1,
    INT x2,
    INT y2
    )
{
    API_ENTRY(GdipAddPathLineI);
    return GdipAddPathLine(path, TOREAL(x1), TOREAL(y1), TOREAL(x2), TOREAL(y2));
}

GpStatus
WINGDIPAPI
GdipAddPathLine2(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count)
{
    API_ENTRY(GdipAddPathLine2);
    CheckParameter(points && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->AddLines(points, count);
}

GpStatus
WINGDIPAPI
GdipAddPathLine2I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count)
{
    API_ENTRY(GdipAddPathLine2I);
    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipAddPathLine2(path, pointsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipAddPathArc(
    GpPath *path,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathArc);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->AddArc(
        x,
        y,
        width,
        height,
        startAngle,
        sweepAngle
    );
}

GpStatus
WINGDIPAPI
GdipAddPathArcI(
    GpPath *path,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathArcI);
   return GdipAddPathArc(path,
                         TOREAL(x),
                         TOREAL(y),
                         TOREAL(width),
                         TOREAL(height),
                         startAngle,
                         sweepAngle);
}

GpStatus
WINGDIPAPI
GdipAddPathBezier(
    GpPath *path,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2,
    REAL x3,
    REAL y3,
    REAL x4,
    REAL y4
    )
{
    API_ENTRY(GdipAddPathBezier);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddBezier(x1,
                          y1,
                          x2,
                          y2,
                          x3,
                          y3,
                          x4,
                          y4);
}

GpStatus
WINGDIPAPI
GdipAddPathBezierI(
    GpPath *path,
    INT x1,
    INT y1,
    INT x2,
    INT y2,
    INT x3,
    INT y3,
    INT x4,
    INT y4
    )
{
    API_ENTRY(GdipAddPathBezierI);
   return GdipAddPathBezier(path,
                            TOREAL(x1),
                            TOREAL(y1),
                            TOREAL(x2),
                            TOREAL(y2),
                            TOREAL(x3),
                            TOREAL(y3),
                            TOREAL(x4),
                            TOREAL(y4));
}

GpStatus
WINGDIPAPI
GdipAddPathBeziers(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathBeziers);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddBeziers(points, count);
}


GpStatus
WINGDIPAPI
GdipAddPathBeziersI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathBeziersI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathBeziers(path, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathCurve(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddCurve(points, count);
}


GpStatus
WINGDIPAPI
GdipAddPathCurveI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathCurveI);
   CheckParameter(points && count > 0);

   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathCurve(path, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathCurve2(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   INT offset = 0;
   INT numOfSegments = count - 1;

   return path->AddCurve(points, count, tension, offset, numOfSegments);
}

GpStatus
WINGDIPAPI
GdipAddPathCurve2I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve2I);
   CheckParameter(points && count > 0);

   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathCurve2(path, pointsF, count, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathCurve3(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve3);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddCurve(points, count, tension, offset, numberOfSegments);
}

GpStatus
WINGDIPAPI
GdipAddPathCurve3I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve3I);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathCurve3(path, pointsF, count, offset, numberOfSegments, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurve(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathClosedCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddClosedCurve(points, count);
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurveI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathClosedCurveI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathClosedCurve(path, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurve2(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathClosedCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddClosedCurve(points, count, tension);
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurve2I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathClosedCurve2I);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathClosedCurve2(path, pointsF, count, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathRectangle(
    GpPath *path,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipAddPathRectangle);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   GpRectF rect(x, y, width, height);

   return path->AddRect(rect);
}

GpStatus
WINGDIPAPI
GdipAddPathRectangleI(
    GpPath *path,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipAddPathRectangleI);
   return GdipAddPathRectangle(path, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipAddPathRectangles(
    GpPath *path,
    GDIPCONST GpRectF *rects,
    INT count
    )
{
    API_ENTRY(GdipAddPathRectangles);
   CheckParameter(rects && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddRects(rects, count);
}

GpStatus
WINGDIPAPI
GdipAddPathRectanglesI(
    GpPath *path,
    GDIPCONST GpRect *rects,
    INT count
    )
{
    API_ENTRY(GdipAddPathRectanglesI);
   StackBuffer buffer;

   GpRectF *rectsF = (GpRectF*) buffer.GetBuffer(count*sizeof(GpRectF));

   if(!rectsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       rectsF[i].X = TOREAL(rects[i].X);
       rectsF[i].Y = TOREAL(rects[i].Y);
       rectsF[i].Width = TOREAL(rects[i].Width);
       rectsF[i].Height = TOREAL(rects[i].Height);
   }

   GpStatus status = GdipAddPathRectangles(path, rectsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathEllipse(
    GpPath* path,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipAddPathEllipse);
    // Idea: What about just putting "GpRectF rect" as the parameter,
    //       no copying, the stack image should match the structure
    //       avoiding an additional copy.

    CheckParameterValid(path);
    CheckObjectBusy(path);

    GpRectF rect(x, y, width, height);

    return path->AddEllipse(rect);
}

GpStatus
WINGDIPAPI
GdipAddPathEllipseI(
    GpPath* path,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipAddPathEllipseI);
    return GdipAddPathEllipse(path, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipAddPathPie(
    GpPath *path,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathPie);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddPie(x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipAddPathPieI(
    GpPath *path,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathPieI);
   return GdipAddPathPie(path,
                         TOREAL(x),
                         TOREAL(y),
                         TOREAL(width),
                         TOREAL(height),
                         startAngle,
                         sweepAngle);
}

GpStatus
WINGDIPAPI
GdipAddPathPolygon(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathPolygon);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddPolygon(points, count);
}

GpStatus
WINGDIPAPI
GdipAddPathPolygonI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathPolygonI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathPolygon(path, pointsF, count);

   return status;
}


GpStatus
WINGDIPAPI
GdipAddPathPath(
    GpPath *path,
    GDIPCONST GpPath* addingPath,
    BOOL connect
    )
{
    API_ENTRY(GdipAddPathPath);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddPath(addingPath, connect);
}

static inline
EmptyString(const WCHAR * string, INT length)
{
    return (length == 0 || length == -1 && string[0] == 0);
}

static inline
void SetEmptyRectF(RectF * boundingBox)
{
    boundingBox->X = boundingBox->Y = boundingBox->Width = boundingBox->Height = 0.0;
}

// anonymous namespace to prevent name collisions
namespace
{

// an instance of this class should be constructed in all Text+ calls
// to protect our global structures and cache
class GlobalTextLock
{
public:
    GlobalTextLock()
    {
        ::EnterCriticalSection(&Globals::TextCriticalSection);
    }
    ~GlobalTextLock()
    {
        ::LeaveCriticalSection(&Globals::TextCriticalSection);
    }
}; // GlobalTextLock

} // namespace

GpStatus
WINGDIPAPI
GdipAddPathString(
    GpPath                   *path,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFontFamily   *family,
    INT                       style,
    REAL                      emSize,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *format
)
{
    API_ENTRY(GdipAddPathString);

    CheckParameter(string && layoutRect);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    if (EmptyString(string, length))
    {
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(family);
    CheckOptionalParameterValid(format);

    return path->AddString(
        string,
        length,
        family,
        style,
        emSize,
        layoutRect,
        format
    );
}

GpStatus
WINGDIPAPI
GdipAddPathStringI(
    GpPath                   *path,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFontFamily   *family,
    INT                       style,
    REAL                      emSize,
    GDIPCONST Rect           *layoutRect,
    GDIPCONST GpStringFormat *format
)
{
    API_ENTRY(GdipAddPathStringI);
    CheckParameter(layoutRect);

    // Not necessary to check all paramaters - they are validated
    // in the called function.

    GpRectF rectf(TOREAL(layoutRect->X), TOREAL(layoutRect->Y),
                  TOREAL(layoutRect->Width), TOREAL(layoutRect->Height));

    return GdipAddPathString(path, string, length, family, style, emSize,
                             &rectf, format);
}


GpStatus
WINGDIPAPI
GdipFlattenPath(
    GpPath *path,
    GpMatrix* matrix,
    REAL flatness
    )
{
    API_ENTRY(GdipFlattenPath);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);


    return path->Flatten(matrix, flatness);
}

GpStatus WINGDIPAPI
GdipWindingModeOutline(
    GpPath *path,
    GpMatrix *matrix,
    REAL flatness
)
{
    API_ENTRY(GdipWindingModeOutline);


    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    return path->ComputeWindingModeOutline(matrix, flatness);
}


GpStatus
WINGDIPAPI
GdipWidenPath(
    GpPath *path,
    GpPen *pen,
    GpMatrix *matrix,
    REAL flatness
)
{
    API_ENTRY(GdipWidenPath);


    CheckParameterValid(path);
    CheckParameterValid(pen);
    CheckObjectBusy(path);
    CheckObjectBusy(pen);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    return path->Widen(pen, matrix, flatness);
}



GpStatus
WINGDIPAPI
GdipWarpPath(
    GpPath *path,
    GpMatrix* matrix,
    GDIPCONST GpPointF *points,
    INT count,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    WarpMode warpMode,
    REAL flatness
    )
{
    API_ENTRY(GdipWarpPath);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(points && count > 0);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    GpRectF srcRect(srcx, srcy, srcwidth, srcheight);


   // The flatness parameter is not implemented yet.

    return path->WarpAndFlattenSelf(matrix, points, count, srcRect, warpMode);
}

GpStatus
WINGDIPAPI
GdipTransformPath(
    GpPath *path,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipTransformPath);
    if(matrix == NULL)
        return Ok;  // No need to transform.

    CheckParameterValid(path);
    CheckParameterValid(matrix);
    CheckObjectBusy(path);
    CheckObjectBusy(matrix);

    path->Transform(matrix);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathWorldBounds(
    GpPath* path,
    GpRectF* bounds,
    GDIPCONST GpMatrix *matrix,
    GDIPCONST GpPen *pen
    )
{
    API_ENTRY(GdipGetPathWorldBounds);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(bounds);
    CheckOptionalParameterValid(pen);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(pen);
    CheckOptionalObjectBusy(matrix);


    // matrix and pen can be NULL.
    // So don't use CheckParameter for matrix and pen.

    GpStatus status = Ok;

    if(pen == NULL)
        status = path->GetBounds(bounds, const_cast<GpMatrix*>(matrix));
    else
        status = path->GetBounds(bounds,
                                 const_cast<GpMatrix*>(matrix),
                                 const_cast<GpPen*>(pen)->GetDevicePen());

    return status;
}

GpStatus
WINGDIPAPI
GdipGetPathWorldBoundsI(
    GpPath* path,
    GpRect* bounds,
    GDIPCONST GpMatrix *matrix,
    GDIPCONST GpPen *pen)
{
    API_ENTRY(GdipGetPathWorldBoundsI);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(bounds);
    CheckOptionalParameterValid(pen);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(pen);
    CheckOptionalObjectBusy(matrix);

    // matrix and pen can be NULL.
    // So don't use CheckParameter for matrix and pen.

    GpStatus status = Ok;

    if(pen == NULL)
        status = path->GetBounds(bounds, const_cast<GpMatrix*>(matrix));
    else
        status = path->GetBounds(bounds,
                                 const_cast<GpMatrix*>(matrix),
                                 const_cast<GpPen*>(pen)->GetDevicePen());
    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePathPoint(
    GpPath* path,
    REAL x,
    REAL y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePathPoint);
    CheckParameter(result);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    GpPointF pt(x, y);
    GpMatrix worldToDevice;


    Status status = Ok;

    if(graphics)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);

        status = path->IsVisible(&pt, result, &worldToDevice);
    }
    else
        status = path->IsVisible(&pt, result);  // Use the default.

    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePathPointI(
    GpPath* path,
    INT x,
    INT y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePathPointI);
    return GdipIsVisiblePathPoint(path,
                                  TOREAL(x),
                                  TOREAL(y),
                                  graphics,
                                  result);
}

GpStatus
WINGDIPAPI
GdipIsOutlineVisiblePathPoint(
    GpPath* path,
    REAL x,
    REAL y,
    GpPen *pen,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsOutlineVisiblePathPoint);
    CheckParameter(result);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    GpPointF pt(x, y);
    GpMatrix worldToDevice;


    Status status = Ok;

    if(graphics)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);

        REAL dpiX = graphics->GetDpiX();
        REAL dpiY = graphics->GetDpiY();

        status = path->IsOutlineVisible(&pt, result, pen,
                &worldToDevice, dpiX, dpiY);
    }
    else
        status = path->IsOutlineVisible(&pt, result, pen);  // Use the default.

    return status;
}

GpStatus
WINGDIPAPI
GdipIsOutlineVisiblePathPointI(
    GpPath* path,
    INT x,
    INT y,
    GpPen *pen,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsOutlineVisiblePathPointI);
    return GdipIsOutlineVisiblePathPoint(path,
                                         TOREAL(x),
                                         TOREAL(y),
                                         pen,
                                         graphics,
                                         result);
}

GpStatus WINGDIPAPI
GdipCreatePathIter(
    GpPathIterator **iterator,
    GpPath* path
    )
{
    API_ENTRY(GdipCreatePathIter);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(iterator);

    *iterator = new GpPathIterator(path);

    if (CheckValid(*iterator))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeletePathIter(
    GpPathIterator *iterator
    )
{
    API_ENTRY(GdipDeletePathIter);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(iterator);
    CheckObjectBusyForDelete(iterator);

    delete iterator;

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextSubpath(
    GpPathIterator* iterator,
    INT* resultCount,
    INT* startIndex,
    INT* endIndex,
    BOOL* isClosed)
{
    API_ENTRY(GdipPathIterNextSubpath);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(startIndex);
    CheckParameter(endIndex);
    CheckParameter(isClosed);

    *resultCount = iterator->NextSubpath(startIndex, endIndex, isClosed);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextSubpathPath(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPath* path,
    BOOL* isClosed)
{
    API_ENTRY(GdipPathIterNextSubpathPath);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(isClosed);

    *resultCount = iterator->NextSubpath(path, isClosed);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextPathType(
    GpPathIterator* iterator,
    INT* resultCount,
    BYTE* pathType,
    INT* startIndex,
    INT* endIndex
    )
{
    API_ENTRY(GdipPathIterNextPathType);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(pathType);
    CheckParameter(startIndex);
    CheckParameter(endIndex);

    *resultCount = iterator->NextPathType(pathType, startIndex, endIndex);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextMarker(
    GpPathIterator* iterator,
    INT* resultCount,
    INT* startIndex,
    INT* endIndex)
{
    API_ENTRY(GdipPathIterNextMarker);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(startIndex);
    CheckParameter(endIndex);

    *resultCount = iterator->NextMarker(startIndex, endIndex);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextMarkerPath(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPath* path)
{
    API_ENTRY(GdipPathIterNextMarkerPath);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);

    *resultCount = iterator->NextMarker(path);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterGetCount(
    GpPathIterator* iterator,
    INT* count
    )
{
    API_ENTRY(GdipPathIterGetCount);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(count);

    *count = iterator->GetCount();

     return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterGetSubpathCount(
    GpPathIterator* iterator,
    INT* count
    )
{
    API_ENTRY(GdipPathIterGetSubpathCount);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(count);

    *count = iterator->GetSubpathCount();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterIsValid(
    GpPathIterator* iterator,
    BOOL* valid
    )
{
    API_ENTRY(GdipPathIterIsValid);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(valid);

    *valid = iterator->IsValid();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterHasCurve(
    GpPathIterator* iterator,
    BOOL* hasCurve
    )
{
    API_ENTRY(GdipPathIterHasCurve);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(hasCurve);

    *hasCurve = iterator->HasCurve();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterRewind(
    GpPathIterator* iterator
    )
{
    API_ENTRY(GdipPathIterRewind);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);

    iterator->Rewind();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterEnumerate(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPointF *points,
    BYTE *types,
    INT count)
{
    API_ENTRY(GdipPathIterEnumerate);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(points);
    CheckParameter(types);

    *resultCount = iterator->Enumerate(points, types, count);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterCopyData(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPointF* points,
    BYTE* types,
    INT startIndex,
    INT endIndex)
{
    API_ENTRY(GdipPathIterCopyData);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(points);
    CheckParameter(types);

    *resultCount = iterator->CopyData(points, types, startIndex, endIndex);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateMatrix(GpMatrix **matrix)
{
    API_ENTRY(GdipCreateMatrix);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(matrix);

    *matrix = new GpMatrix();

    if (CheckValid(*matrix))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateMatrix2(
    REAL m11,
    REAL m12,
    REAL m21,
    REAL m22,
    REAL dx,
    REAL dy,
    GpMatrix ** outMatrix
    )
{
    API_ENTRY(GdipCreateMatrix2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(outMatrix);

    GpMatrix * matrix;

    matrix = (GpMatrix *) InterlockedExchangePointer((PVOID *) &Globals::MatrixLookAside, NULL);

    if(matrix == NULL)
    {
        matrix = new GpMatrix(m11, m12, m21, m22, dx, dy);
    }
    else
    {
        matrix->GetObjectLock()->Reset();
        matrix->SetMatrix(m11, m12, m21, m22, dx, dy);
    }

    if (CheckValid(matrix))
    {
        *outMatrix = matrix;
        return Ok;
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateMatrix3(
    GDIPCONST GpRectF *rect,
    GDIPCONST GpPointF *dstplg,
    GpMatrix **matrix
    )
{
    API_ENTRY(GdipCreateMatrix3);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(matrix && rect && dstplg);

    *matrix = new GpMatrix(dstplg, *rect);

    if (CheckValid(*matrix))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateMatrix3I(
    GDIPCONST GpRect *rect,
    GDIPCONST GpPoint *dstplg,
    GpMatrix **matrix
    )
{
    API_ENTRY(GdipCreateMatrix3I);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpRectF rectf(TOREAL(rect->X), TOREAL(rect->Y), TOREAL(rect->Width), TOREAL(rect->Height));
    GpPointF dstplgf[3] = { GpPointF(TOREAL(dstplg[0].X), TOREAL(dstplg[0].Y)),
                            GpPointF(TOREAL(dstplg[1].X), TOREAL(dstplg[1].Y)),
                            GpPointF(TOREAL(dstplg[2].X), TOREAL(dstplg[2].Y)) };

    return GdipCreateMatrix3(&rectf, dstplgf, matrix);
}

GpStatus
WINGDIPAPI
GdipCloneMatrix(
    GpMatrix *matrix,
    GpMatrix **clonematrix
    )
{
    API_ENTRY(GdipCloneMatrix);
    CheckParameter(clonematrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    *clonematrix = matrix->Clone();

    if (CheckValid(*clonematrix))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteMatrix(
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipDeleteMatrix);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(matrix);
    CheckObjectBusyForDelete(matrix);

    if(matrix != NULL)
    {

        matrix = (GpMatrix *) InterlockedExchangePointer((PVOID *) &Globals::MatrixLookAside, (PVOID) matrix);

        if(matrix != NULL)
        {
            delete matrix;
        }
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetMatrixElements(
    GpMatrix *matrix,
    REAL m11,
    REAL m12,
    REAL m21,
    REAL m22,
    REAL dx,
    REAL dy
    )
{
    API_ENTRY(GdipSetMatrixElements);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   REAL m[6] = { m11, m12, m21, m22, dx, dy };

   matrix->SetMatrix((REAL*) &m);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipMultiplyMatrix(
    GpMatrix *matrix,
    GpMatrix *matrix2,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipMultiplyMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameterValid(matrix2);
    CheckObjectBusy(matrix2);
    CheckParameter(MatrixOrderIsValid(order));
    
    if (order == MatrixOrderPrepend)
        matrix->Prepend(*matrix2);
    else
        matrix->Append(*matrix2);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipTranslateMatrix(
    GpMatrix *matrix,
    REAL offsetX,
    REAL offsetY,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Translate(offsetX, offsetY, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipScaleMatrix(
    GpMatrix *matrix,
    REAL scaleX,
    REAL scaleY,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Scale(scaleX, scaleY, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipRotateMatrix(
    GpMatrix *matrix,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Rotate(angle, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipShearMatrix(
    GpMatrix *matrix,
    REAL shearX,
    REAL shearY,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipShearMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Shear(shearX, shearY, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipInvertMatrix(GpMatrix *matrix)
{
    API_ENTRY(GdipInvertMatrix);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   return matrix->Invert();
}

GpStatus
WINGDIPAPI
GdipTransformMatrixPoints(
    GpMatrix *matrix,
    GpPointF *pts,
    INT count
    )
{
    API_ENTRY(GdipTransformMatrixPoints);
   CheckParameter(pts && count > 0);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   matrix->Transform(pts, count);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipTransformMatrixPointsI(
    GpMatrix *matrix,
    GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipTransformMatrixPointsI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipTransformMatrixPoints(matrix, pointsF, count);

   // convert back, rounding is a problem...

   if (status == Ok)
   {
       for (INT i=0; i<count; i++)
       {
           points[i].X = GpRound(pointsF[i].X);
           points[i].Y = GpRound(pointsF[i].Y);
       }
   }

   return status;
}

GpStatus
WINGDIPAPI
GdipVectorTransformMatrixPoints(
    GpMatrix *matrix,
    GpPointF *pointsF,
    INT count
    )
{
    API_ENTRY(GdipVectorTransformMatrixPoints);
   CheckParameter(pointsF && count > 0);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   matrix->VectorTransform(pointsF, count);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipVectorTransformMatrixPointsI(
    GpMatrix *matrix,
    GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipVectorTransformMatrixPointsI);
   CheckParameter(points && count > 0);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   matrix->VectorTransform(pointsF, count);

   // convert back, rounding is a problem...


   for (i=0; i<count; i++)
   {
        points[i].X = GpRound(pointsF[i].X);
        points[i].Y = GpRound(pointsF[i].Y);
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetMatrixElements(
    GDIPCONST GpMatrix *matrix,
    REAL *m
   )
{
    API_ENTRY(GdipGetMatrixElements);
   CheckParameter(m);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   matrix->GetMatrix(m);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipIsMatrixInvertible(
    GDIPCONST GpMatrix *matrix,
    BOOL *result
    )
{
    API_ENTRY(GdipIsMatrixInvertible);
   CheckParameter(result);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   *result = matrix->IsInvertible();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipIsMatrixIdentity(
    GDIPCONST GpMatrix *matrix,
    BOOL *result
    )
{
    API_ENTRY(GdipIsMatrixIdentity);
   CheckParameter(result);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   *result = matrix->IsIdentity();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipIsMatrixEqual(
    GDIPCONST GpMatrix *matrix,
    GDIPCONST GpMatrix *matrix2,
    BOOL *result
    )
{
    API_ENTRY(GdipIsMatrixEqual);
    CheckParameter(result);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    if (matrix != matrix2)
    {
        CheckParameterValid(matrix2);
        CheckObjectBusy(matrix2);

        *result = matrix->IsEqual(matrix2);
    }
    else
    {
        *result = TRUE;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateRegion(
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegion);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region);

    *region = new GpRegion();

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRegionRect(
    GDIPCONST GpRectF *rect,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionRect);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region && rect);

    *region = new GpRegion(rect);

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRegionRectI(
    GDIPCONST GpRect *rect,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionRectI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpRectF rectf(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCreateRegionRect(&rectf, region);
}

GpStatus
WINGDIPAPI
GdipCreateRegionPath(
    GpPath *path,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionPath);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *region = new GpRegion(path);

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRegionRgnData(
    GDIPCONST BYTE *regionData,
    INT size,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionRgnData);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(regionData);
    CheckParameter(region);

    *region = new GpRegion(regionData, size);

    if (CheckValid(*region))
        return Ok;
    else
        return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateRegionHrgn(
    HRGN hRgn,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionHrgn);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region && hRgn && (GetObjectTypeInternal(hRgn) == OBJ_REGION));

    *region = new GpRegion(hRgn);

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCloneRegion(
    GpRegion *region,
    GpRegion **cloneregion
    )
{
    API_ENTRY(GdipCloneRegion);
    CheckParameter(cloneregion);
    CheckParameterValid(region);
    CheckObjectBusy(region);

    *cloneregion = new GpRegion(region);

    if (CheckValid(*cloneregion))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteRegion(
    GpRegion *region
    )
{
    API_ENTRY(GdipDeleteRegion);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(region);
    CheckObjectBusyForDelete(region);

    delete region;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetInfinite(
    GpRegion *region
)
{
    API_ENTRY(GdipSetInfinite);
    CheckParameterValid(region);
    CheckObjectBusy(region);

    region->SetInfinite();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetEmpty(
    GpRegion *region
)
{
    API_ENTRY(GdipSetEmpty);
    CheckParameterValid(region);
    CheckObjectBusy(region);

    region->SetEmpty();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipCombineRegionRect(
    GpRegion *                region,
    GDIPCONST GpRectF *       rect,
    CombineMode               combineMode
    )
{
    API_ENTRY(GdipCombineRegionRect);
    CheckParameter(rect);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(CombineModeIsValid(combineMode));

    return region->Combine(rect, combineMode);
}

GpStatus
WINGDIPAPI
GdipCombineRegionRectI(
    GpRegion *                region,
    GDIPCONST GpRect *        rect,
    CombineMode               combineMode
    )
{
    API_ENTRY(GdipCombineRegionRectI);
    GpRectF rectf(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCombineRegionRect(region, &rectf, combineMode);
}

GpStatus
WINGDIPAPI
GdipCombineRegionPath(
    GpRegion *      region,
    GpPath *        path,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipCombineRegionPath);
    CheckParameterValid(region);
    CheckParameterValid(path);
    CheckObjectBusy(region);
    CheckObjectBusy(path);
    CheckParameter(CombineModeIsValid(combineMode));

    return region->Combine(path, combineMode);
}

GpStatus
WINGDIPAPI
GdipCombineRegionRegion(
    GpRegion *      region,
    GpRegion *      region2,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipCombineRegionRegion);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(region2);
    CheckObjectBusy(region2);
    CheckParameter(CombineModeIsValid(combineMode));

    return region->Combine(region2, combineMode);
}

GpStatus
WINGDIPAPI
GdipTranslateRegion(
    GpRegion *region,
    REAL dx,
    REAL dy
    )
{
    API_ENTRY(GdipTranslateRegion);
   CheckParameter(region);
   CheckParameterValid(region);

   region->Offset(dx, dy);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipTranslateRegionI(
    GpRegion *region,
    INT dx,
    INT dy
    )
{
    API_ENTRY(GdipTranslateRegionI);
   return GdipTranslateRegion(region, TOREAL(dx), TOREAL(dy));
}

GpStatus
WINGDIPAPI
GdipTransformRegion(
    GpRegion *region,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipTransformRegion);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);
   CheckParameterValid(region);
   CheckObjectBusy(region);

   return region->Transform(matrix);
}

GpStatus
WINGDIPAPI
GdipGetRegionBounds(
    GpRegion *region,
    GpGraphics *graphics,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetRegionBounds);
    CheckParameter(rect);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    return region->GetBounds(graphics, rect);
}

GpStatus
WINGDIPAPI
GdipGetRegionBoundsI(
    GpRegion *region,
    GpGraphics *graphics,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetRegionBoundsI);
    CheckParameter(rect);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    GpRectF     rectF;
    GpStatus    status = region->GetBounds(graphics, &rectF);

    if (status == Ok)
    {
        rect->X      = GpRound(rectF.X);
        rect->Y      = GpRound(rectF.Y);
        rect->Width  = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }
    return status;
}

GpStatus
WINGDIPAPI
GdipGetRegionHRgn(
    GpRegion *region,
    GpGraphics *graphics,   // can be NULL
    HRGN *hRgn
    )
{
    API_ENTRY(GdipGetRegionHRgn);
    CheckParameter(hRgn);
    CheckParameterValid(region);
    CheckObjectBusy(region);


    if (graphics != NULL)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);
        return region->GetHRgn(graphics, hRgn);
    }
    return region->GetHRgn((GpGraphics*)NULL, hRgn);
}

GpStatus
WINGDIPAPI
GdipIsEmptyRegion(
    GpRegion *region,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsEmptyRegion);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpMatrix worldToDevice;

    Status status;

    graphics->GetWorldToDeviceTransform(&worldToDevice);

    status = region->IsEmpty(&worldToDevice, result);

    return status;
}

GpStatus
WINGDIPAPI
GdipIsInfiniteRegion(
    GpRegion *region,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsInfiniteRegion);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpMatrix worldToDevice;

    Status status;

    graphics->GetWorldToDeviceTransform(&worldToDevice);

    status = region->IsInfinite(&worldToDevice, result);

    return status;
}

GpStatus
WINGDIPAPI
GdipIsEqualRegion(
    GpRegion *region,
    GpRegion *region2,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsEqualRegion);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    Status status;

    if (region != region2)
    {
        CheckParameterValid(region2);
        CheckObjectBusy(region2);


        GpMatrix worldToDevice;

        graphics->GetWorldToDeviceTransform(&worldToDevice);

        status = region->IsEqual(region2, &worldToDevice, result);
    }
    else
    {
        *result = TRUE;
        status = Ok;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetRegionDataSize(
    GpRegion *  region,
    UINT *       bufferSize
    )
{
    API_ENTRY(GdipGetRegionDataSize);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(bufferSize);


    if ((*bufferSize = region->GetExternalDataSize()) > 0)
    {
        return Ok;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipGetRegionData(
    GpRegion *  region,
    BYTE *      buffer,
    UINT         bufferSize,
    UINT *       sizeFilled
    )
{
    API_ENTRY(GdipGetRegionData);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(buffer);
    CheckParameter(bufferSize > 0);


    UINT    filled = bufferSize;

    GpStatus status = region->GetExternalData(buffer, filled);

    ASSERT((INT)filled <= bufferSize);
    if (sizeFilled != NULL)
    {
        *sizeFilled = filled;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisibleRegionPoint(
    GpRegion *region,
    REAL x,
    REAL y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionPoint);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);


    Status status;

    GpPointF pt(x, y);
    GpMatrix worldToDevice;

    if (graphics != NULL)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);
    }

    status = region->IsVisible(&pt, &worldToDevice, result);

    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisibleRegionPointI(
    GpRegion *region,
    INT x,
    INT y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionPointI);
    return GdipIsVisibleRegionPoint(region, TOREAL(x), TOREAL(y), graphics, result);
}

GpStatus
WINGDIPAPI
GdipIsVisibleRegionRect(
    GpRegion *region,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionRect);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);


    Status status;

    GpRectF rect(x, y, width, height);
    GpMatrix worldToDevice;

    if (graphics != NULL)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);
    }

    status = region->IsVisible(&rect, &worldToDevice, result);

    return status;
}


GpStatus
WINGDIPAPI
GdipIsVisibleRegionRectI(
    GpRegion *region,
    INT x,
    INT y,
    INT width,
    INT height,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionRectI);
    return GdipIsVisibleRegionRect(region,
                                   TOREAL(x),
                                   TOREAL(y),
                                   TOREAL(width),
                                   TOREAL(height),
                                   graphics,
                                   result);
}

GpStatus
WINGDIPAPI
GdipGetRegionScansCount(
    GpRegion *region,
    UINT *count,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetRegionScansCount);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(count);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);


    // !! Rewrite this API to be more efficient
    return region->GetRegionScans((GpRect*)NULL,
                                  (INT*)count,
                                  matrix);
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
GpStatus
WINGDIPAPI
GdipGetRegionScans(
    GpRegion *region,
    GpRectF *rects,     // NULL to just get the count
    INT *count,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetRegionScans);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(count);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);


    // !! Rewrite this API to verify IN count is sufficient
    return region->GetRegionScans(rects, count, matrix);
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
GpStatus
WINGDIPAPI
GdipGetRegionScansI(
    GpRegion *region,
    GpRect *rects,      // NULL to just get the count
    INT *count,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetRegionScansI);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(count);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);


    return region->GetRegionScans(rects, count, matrix);
}

GpStatus
WINGDIPAPI
GdipCloneBrush(
    GpBrush *brush,
    GpBrush **clonebrush
    )
{
    API_ENTRY(GdipCloneBrush);
    CheckParameter(clonebrush);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *clonebrush = brush->Clone();

    if (CheckValid(*clonebrush))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteBrush(
    GpBrush *brush
    )
{
    API_ENTRY(GdipDeleteBrush);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(brush);
    CheckObjectBusyForDelete(brush);

    delete brush;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetBrushType(
    GpBrush *brush,
    GpBrushType *type
    )
{
    API_ENTRY(GdipGetBrushType);
    CheckParameter(type);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *type = brush->GetBrushType();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateHatchBrush(
    GpHatchStyle hatchstyle,
    ARGB forecol,
    ARGB backcol,
    GpHatch **hatch
    )
{
    API_ENTRY(GdipCreateHatchBrush);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter((hatchstyle >= HatchStyleMin) && (hatchstyle <= HatchStyleMax));
    CheckParameter(hatch);
    CheckColorParameter(forecol);
    CheckColorParameter(backcol);

    GpColor fore(forecol);
    GpColor back(backcol);

    *hatch = new GpHatch(hatchstyle, fore, back);

    if (CheckValid(*hatch))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipGetHatchStyle(
    GpHatch *brush,
    GpHatchStyle *hatchStyle
    )
{
    API_ENTRY(GdipGetHatchStyle);
    CheckParameter(hatchStyle);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *hatchStyle = brush->GetHatchStyle();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetHatchForegroundColor(
    GpHatch *brush,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetHatchForegroundColor);
    CheckParameter(argb);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor foreColor;

    GpStatus status = brush->GetForegroundColor((GpColor*)&foreColor);

    *argb = foreColor.GetValue();

    return status;
}

GpStatus
WINGDIPAPI
GdipGetHatchBackgroundColor(
    GpHatch *brush,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetHatchBackgroundColor);
    CheckParameter(argb);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor backColor;

    GpStatus status = brush->GetBackgroundColor((GpColor*)&backColor);

    *argb = backColor.GetValue();

    return status;
}

GpStatus
WINGDIPAPI
GdipCreateTexture(
    GpImage *image,
    GpWrapMode wrapmode,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTexture);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(texture);
    CheckParameterValid(image);
    CheckObjectBusy(image);


    *texture = new GpTexture(image, wrapmode);

    if (CheckValid(*texture))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateTexture2(
    GpImage *image,
    GpWrapMode wrapmode,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTexture2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(texture);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    GpRectF rect(x, y, width, height);


    *texture = new GpTexture(image, wrapmode, rect);

    if (CheckValid(*texture))
        return Ok;
    else
        return OutOfMemory;
}
GpStatus
WINGDIPAPI
GdipCreateTextureIA(
    GpImage *image,
    GDIPCONST GpImageAttributes *imageAttributes,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTextureIA);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(texture);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);

    GpRectF rect(x, y, width, height);


    *texture = new GpTexture(image, rect, imageAttributes);

    if (CheckValid(*texture))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateTexture2I(
    GpImage *image,
    GpWrapMode wrapmode,
    INT x,
    INT y,
    INT width,
    INT height,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTexture2I);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   return GdipCreateTexture2(image,
                             wrapmode,
                             TOREAL(x),
                             TOREAL(y),
                             TOREAL(width),
                             TOREAL(height),
                             texture);
}

GpStatus
WINGDIPAPI
GdipCreateTextureIAI(
    GpImage *image,
    GDIPCONST GpImageAttributes *imageAttributes,
    INT x,
    INT y,
    INT width,
    INT height,
    GpTexture **texture
    )
{

    return GdipCreateTextureIA(image,
                               imageAttributes,
                               TOREAL(x),
                               TOREAL(y),
                               TOREAL(width),
                               TOREAL(height),
                               texture);
}

GpStatus
WINGDIPAPI
GdipSetTextureTransform(
    GpTexture *brush,
    GDIPCONST GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipGetTextureTransform(
    GpTexture *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipResetTextureTransform(
    GpTexture* brush)
{
    API_ENTRY(GdipResetTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyTextureTransform(
    GpTexture* brush,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyTextureTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslateTextureTransform(
    GpTexture* brush,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScaleTextureTransform(
    GpTexture* brush,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotateTextureTransform(
    GpTexture* brush,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipSetTextureWrapMode(
    GpTexture *brush,
    GpWrapMode wrapmode
    )
{
    API_ENTRY(GdipSetTextureWrapMode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetTextureWrapMode(
    GpTexture *brush,
    GpWrapMode *wrapmode
    )
{
    API_ENTRY(GdipGetTextureWrapMode);
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetTextureImage(
    GpTexture *brush,
    GpImage **image
    )
{
    API_ENTRY(GdipGetTextureImage);
    // GetImage returns a pointer to the internal GpImage structure. Because
    // we have to create a new Image wrapper around it and give it to the caller
    // at the API level, we return a clone so they can throw it away without
    // destroying our internal brush structure.
    GpImage *imgtmp;
    imgtmp = brush->GetImage();
    *image = imgtmp->Clone();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateSolidFill(
    ARGB color,
    GpSolidFill **solidfill
    )
{
    API_ENTRY(GdipCreateSolidFill);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(solidfill);
    CheckColorParameter(color);

    *solidfill = new GpSolidFill(GpColor(color));

    if (CheckValid(*solidfill))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetSolidFillColor(
    GpSolidFill *brush,
    ARGB color
    )
{
    API_ENTRY(GdipSetSolidFillColor);
    CheckColorParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetColor(GpColor(color));

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetSolidFillColor(
    GpSolidFill *brush,
    ARGB *color
    )
{
    API_ENTRY(GdipGetSolidFillColor);
    CheckParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *color = (brush->GetColor()).GetValue();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrush(
    GDIPCONST GpPointF* point1,
    GDIPCONST GpPointF* point2,
    ARGB color1,
    ARGB color2,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad
    )
{
    API_ENTRY(GdipCreateLineBrush);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(linegrad && point1 && point2);
    CheckColorParameter(color1);
    CheckColorParameter(color2);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpColor c1(color1);
    GpColor c2(color2);

    *linegrad = new GpLineGradient(*point1, *point2, c1, c2, wrapmode);

    if (CheckValid(*linegrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushI(
    GDIPCONST GpPoint* point1,
    GDIPCONST GpPoint* point2,
    ARGB color1,
    ARGB color2,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad
    )
{
    API_ENTRY(GdipCreateLineBrushI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(point1 && point2);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpPointF point1F(TOREAL(point1->X), TOREAL(point1->Y));
    GpPointF point2F(TOREAL(point2->X), TOREAL(point2->Y));

    return GdipCreateLineBrush(&point1F,
                               &point2F,
                               color1,
                               color2,
                               wrapmode,
                               linegrad);
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRect(
    GDIPCONST GpRectF* rect,
    ARGB color1,
    ARGB color2,
    LinearGradientMode mode,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRect);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(linegrad && rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpColor c1(color1);
    GpColor c2(color2);

    *linegrad = new GpLineGradient(*rect, c1, c2, mode, wrapmode);

    if (CheckValid(*linegrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRectI(
    GDIPCONST GpRect* rect,
    ARGB color1,
    ARGB color2,
    LinearGradientMode mode,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRectI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpRectF rectF(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCreateLineBrushFromRect(&rectF,
                                       color1,
                                       color2,
                                       mode,
                                       wrapmode,
                                       linegrad);
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRectWithAngle(
    GDIPCONST GpRectF* rect,
    ARGB color1,
    ARGB color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRectWithAngle);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(linegrad && rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpColor c1(color1);
    GpColor c2(color2);

    *linegrad = new GpLineGradient(*rect, c1, c2, angle,
                        isAngleScalable, wrapmode);

    if (CheckValid(*linegrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRectWithAngleI(
    GDIPCONST GpRect* rect,
    ARGB color1,
    ARGB color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRectWithAngleI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpRectF rectF(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCreateLineBrushFromRectWithAngle(&rectF,
                                       color1,
                                       color2,
                                       angle,
                                       isAngleScalable,
                                       wrapmode,
                                       linegrad);
}

GpStatus
WINGDIPAPI
GdipSetLineColors(
    GpLineGradient *brush,
    ARGB argb1,
    ARGB argb2
    )
{
    API_ENTRY(GdipSetLineColors);
    CheckColorParameter(argb1);
    CheckColorParameter(argb2);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor c1(argb1);
    GpColor c2(argb2);

    brush->SetLineColors(c1, c2);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineColors(
    GpLineGradient *brush,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetLineColors);
   CheckParameter(argb);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor colors[2];
   brush->GetLineColors(&colors[0]);

   argb[0] = colors[0].GetValue();
   argb[1] = colors[1].GetValue();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineRect(
    GpLineGradient *brush,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetLineRect);
   CheckParameter(rect);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   brush->GetRect(*rect);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineRectI(
    GpLineGradient *brush,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetLineRectI);
    CheckParameter(rect);

    GpRectF rectF;

    GpStatus status = GdipGetLineRect(brush, &rectF);

    if (status == Ok)
    {

        rect->X = GpRound(rectF.X);
        rect->Y = GpRound(rectF.Y);
        rect->Width = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipSetLineGammaCorrection(
    GpLineGradient *brush,
    BOOL useGammaCorrection
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetGammaCorrection(useGammaCorrection);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineGammaCorrection(
    GpLineGradient *brush,
    BOOL *useGammaCorrection)
{
    CheckParameter(useGammaCorrection);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *useGammaCorrection = brush->GetGammaCorrection();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineBlendCount(
    GpLineGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetLineBlendCount);
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineBlend(
    GpLineGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipGetLineBlend);
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->GetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetLineBlend(
    GpLineGradient *brush,
    GDIPCONST REAL *blend,
    GDIPCONST REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipSetLineBlend);
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->SetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetLinePresetBlendCount(
    GpLineGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetLinePresetBlendCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetPresetBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLinePresetBlend(
    GpLineGradient *brush,
    ARGB *blend,
    REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipGetLinePresetBlend);
    CheckParameter(blend);
    CheckParameter(blendPositions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    if (count <= 0)
    {
        return InvalidParameter;
    }

    if (count < brush->GetPresetBlendCount())
    {
        return InsufficientBuffer;
    }

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if (gpcolors)
    {
        GpStatus status = brush->GetPresetBlend(gpcolors, blendPositions, count);

        for(INT i = 0; i < count; i++)
        {
            blend[i] = gpcolors[i].GetValue();
        }

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetLinePresetBlend(
    GpLineGradient *brush,
    GDIPCONST ARGB *blend,
    GDIPCONST REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipSetLinePresetBlend);
    CheckParameter(blend);
    CheckParameter(blendPositions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    CheckParameter(count > 0)

    // blend positions must start at 0.0 and end at 1.0
    if (REALABS(blendPositions[0]) > REAL_EPSILON ||
        REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
    {
        return InvalidParameter;
    }

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if(gpcolors)
    {
        for(INT i = 0; i < count; i++)
        {
            gpcolors[i].SetColor(blend[i]);
        }

        GpStatus status = brush->SetPresetBlend(gpcolors, blendPositions, count);

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetLineSigmaBlend(
    GpLineGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetLineSigmaBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetSigmaBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetLineLinearBlend(
    GpLineGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetLineLinearBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetLinearBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetLineWrapMode(
    GpLineGradient *brush,
    GpWrapMode wrapmode
    )
{
    API_ENTRY(GdipSetLineWrapMode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    GpStatus status = Ok;

    if(wrapmode != WrapModeClamp)
        brush->SetWrapMode(wrapmode);
    else
        status = InvalidParameter;

    return status;
}

GpStatus
WINGDIPAPI
GdipGetLineWrapMode(
    GpLineGradient *brush,
    GpWrapMode *wrapmode
    )
{
    API_ENTRY(GdipGetLineWrapMode);
   CheckParameter(wrapmode);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *wrapmode = (GpWrapMode)brush->GetWrapMode();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetLineTransform(
    GpLineGradient *brush,
    GDIPCONST GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetLineTransform);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   return brush->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipGetLineTransform(
    GpLineGradient *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipResetLineTransform(
    GpLineGradient* brush)
{
    API_ENTRY(GdipResetLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyLineTransform(
    GpLineGradient* brush,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyLineTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslateLineTransform(
    GpLineGradient* brush,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScaleLineTransform(
    GpLineGradient* brush,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotateLineTransform(
    GpLineGradient* brush,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipCreatePathGradient(
    GDIPCONST GpPointF* points,
    INT count,
    GpWrapMode wrapMode,
    GpPathGradient **brush
    )
{
    API_ENTRY(GdipCreatePathGradient);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(brush);

    *brush = new GpPathGradient(points, count, wrapMode);

    if (CheckValid(*brush))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePathGradientI(
    GDIPCONST GpPoint* points,
    INT count,
    GpWrapMode wrapMode,
    GpPathGradient **brush
    )
{
    API_ENTRY(GdipCreatePathGradientI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(points);

    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
         pointsF[i].X = TOREAL(points[i].X);
         pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipCreatePathGradient(pointsF, count, wrapMode, brush);

    return status;
}

GpStatus
WINGDIPAPI
GdipCreatePathGradientFromPath(
    GDIPCONST GpPath* path,
    GpPathGradient **brush
    )
{
    API_ENTRY(GdipCreatePathGradientFromPath);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(brush);

    *brush = new GpPathGradient(path);

    if (CheckValid(*brush))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientCenterColor(
    GpPathGradient *brush,
    ARGB* color
    )
{
    API_ENTRY(GdipGetPathGradientCenterColor);
    CheckParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor center;
    brush->GetCenterColor(&center);
    *color = center.GetValue();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientCenterColor(
    GpPathGradient *brush,
    ARGB color
    )
{
    API_ENTRY(GdipSetPathGradientCenterColor);
    CheckColorParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor center(color);
    brush->SetCenterColor(center);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientSurroundColorsWithCount(
    GpPathGradient *brush,
    ARGB* colors,
    INT* count
    )
{
    API_ENTRY(GdipGetPathGradientSurroundColorsWithCount);
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    INT count1 = brush->GetNumberOfPoints();

    if(*count < count1 || count1 <= 0)
        return InvalidParameter;

    count1 = min(*count, count1);

    ARGB lastValue, nextValue;

    INT n = 1;

    for(INT i = 0; i < count1; i++)
    {
        GpColor color;

        brush->GetSurroundColor(&color, i);
        nextValue = color.GetValue();
        colors[i] = nextValue;

        if(i > 0)
        {
            if(nextValue != lastValue)
                n = i + 1;
        }
        lastValue = nextValue;
    }

    *count = n;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientSurroundColorsWithCount(
    GpPathGradient *brush,
    GDIPCONST ARGB* colors,
    INT* count
    )
{
    API_ENTRY(GdipSetPathGradientSurroundColorsWithCount);
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    INT count1 = brush->GetNumberOfPoints();

    INT minCount = min(*count, count1);

    if(*count > count1 || minCount < 1)
    {
        return InvalidParameter;
    }

    GpColor *gpColors = new GpColor[count1];

    if(NULL == gpColors)
    {
        return OutOfMemory;
    }

    INT i;
    for(i = 0; i < minCount; i++)
    {
        gpColors[i].SetColor(colors[i]);
    }

    if(minCount < count1)
    {
        for(i = minCount; i < count1; i++)
        {
            gpColors[i].SetColor(colors[minCount - 1]);
        }
    }

    *count = minCount;
    GpStatus status = brush->SetSurroundColors(gpColors);

    delete[] gpColors;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPath(
    GpPathGradient *brush,
    GpPath *path
    )
{
    API_ENTRY(GdipGetPathGradientPath);
    return NotImplemented;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientPath(
    GpPathGradient *brush,
    GDIPCONST GpPath *path
    )
{
    API_ENTRY(GdipSetPathGradientPath);
    return NotImplemented;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientCenterPoint(
    GpPathGradient *brush,
    GpPointF* point
    )
{
    API_ENTRY(GdipGetPathGradientCenterPoint);
    CheckParameter(point);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetCenterPoint(point);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientCenterPointI(
    GpPathGradient *brush,
    GpPoint* point
    )
{
    API_ENTRY(GdipGetPathGradientCenterPointI);
    CheckParameter(point);

    GpPointF pointF;

    GpStatus status = GdipGetPathGradientCenterPoint(brush, &pointF);

    if (status == Ok)
    {

         point->X = GpRound(pointF.X);
         point->Y = GpRound(pointF.Y);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientCenterPoint(
    GpPathGradient *brush,
    GDIPCONST GpPointF* point
    )
{
    API_ENTRY(GdipSetPathGradientCenterPoint);
    CheckParameter(point);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetCenterPoint(*point);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientCenterPointI(
    GpPathGradient *brush,
    GDIPCONST GpPoint* point
    )
{
    API_ENTRY(GdipSetPathGradientCenterPointI);
    CheckParameter(point);

    GpPointF pointF(TOREAL(point->X), TOREAL(point->Y));

    return GdipSetPathGradientCenterPoint(brush, &pointF);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPointCount(
    GpPathGradient *brush,
    INT* count)
{
    API_ENTRY(GdipGetPathGradientPointCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetNumberOfPoints();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientSurroundColorCount(
    GpPathGradient *brush,
    INT* count)
{
    API_ENTRY(GdipGetPathGradientSurroundColorCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetNumberOfColors();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientRect(
    GpPathGradient *brush,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetPathGradientRect);
    CheckParameter(rect);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetRect(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientRectI(
    GpPathGradient *brush,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetPathGradientRectI);
    CheckParameter(rect);

    GpRectF rectF;

    GpStatus status = GdipGetPathGradientRect(brush, &rectF);

    if (status == Ok)
    {

        rect->X = GpRound(rectF.X);
        rect->Y = GpRound(rectF.Y);
        rect->Width = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientGammaCorrection(
    GpPathGradient *brush,
    BOOL useGammaCorrection
    )
{
    API_ENTRY(GdipSetPathGradientGammaCorrection);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetGammaCorrection(useGammaCorrection);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientGammaCorrection(
    GpPathGradient *brush,
    BOOL *useGammaCorrection)
{
    API_ENTRY(GdipGetPathGradientGammaCorrection);
    CheckParameter(useGammaCorrection);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *useGammaCorrection = brush->GetGammaCorrection();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientBlendCount(
    GpPathGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetPathGradientBlendCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientBlend(
    GpPathGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipGetPathGradientBlend);
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientBlend(
    GpPathGradient *brush,
    GDIPCONST REAL *blend,
    GDIPCONST REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipSetPathGradientBlend);
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPresetBlendCount(
    GpPathGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetPathGradientPresetBlendCount);
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetPresetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPresetBlend(
    GpPathGradient *brush,
    ARGB *blend,
    REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipGetPathGradientPresetBlend);
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if (gpcolors)
    {
        GpStatus status = brush->GetPresetBlend(gpcolors, blendPositions, count);

        for(INT i = 0; i < count; i++)
        {
            blend[i] = gpcolors[i].GetValue();
        }

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientPresetBlend(
    GpPathGradient *brush,
    GDIPCONST ARGB *blend,
    GDIPCONST REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipSetPathGradientPresetBlend);
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    CheckParameter(count > 0);

    // blend positions must start at 0.0 and end at 1.0
    if (REALABS(blendPositions[0]) > REAL_EPSILON ||
        REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
    {
        return InvalidParameter;
    }

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if(gpcolors)
    {
        for(INT i = 0; i < count; i++)
        {
            gpcolors[i].SetColor(blend[i]);
        }

        GpStatus status = brush->SetPresetBlend(gpcolors, blendPositions, count);

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientSigmaBlend(
    GpPathGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetPathGradientSigmaBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetSigmaBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientLinearBlend(
    GpPathGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetPathGradientLinearBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetLinearBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientWrapMode(
    GpPathGradient *brush,
    GpWrapMode *wrapmode
    )
{
    API_ENTRY(GdipGetPathGradientWrapMode);
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientWrapMode(
    GpPathGradient *brush,
    GpWrapMode wrapmode
    )
{
    API_ENTRY(GdipSetPathGradientWrapMode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientTransform(
    GpPathGradient *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetPathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientTransform(
    GpPathGradient *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetPathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipResetPathGradientTransform(
    GpPathGradient* brush)
{
    API_ENTRY(GdipResetPathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyPathGradientTransform(
    GpPathGradient* brush,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyPathGradientTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslatePathGradientTransform(
    GpPathGradient* brush,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslatePathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScalePathGradientTransform(
    GpPathGradient* brush,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScalePathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotatePathGradientTransform(
    GpPathGradient* brush,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotatePathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientFocusScales(
    GpPathGradient *brush,
    REAL* xScale,
    REAL* yScale
    )
{
    API_ENTRY(GdipGetPathGradientFocusScales);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(xScale);
    CheckParameter(yScale);

    return brush->GetFocusScales(xScale, yScale);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientFocusScales(
    GpPathGradient *brush,
    REAL xScale,
    REAL yScale
    )
{
    API_ENTRY(GdipSetPathGradientFocusScales);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetFocusScales(xScale, yScale);
}

GpStatus
WINGDIPAPI
GdipCreatePen1(
    ARGB color,
    REAL width,
    GpUnit unit,
    GpPen ** outPen
    )
{
    API_ENTRY(GdipCreatePen1);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color);
    CheckParameter(outPen);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    CheckParameter((unit >= UnitWorld) && (unit <= UnitMillimeter) && (unit != UnitDisplay));

    GpPen * pen;

    pen = (GpPen *) InterlockedExchangePointer((PVOID *) &Globals::PenLookAside, NULL);

    if(pen == NULL)
    {
        pen = new GpPen(GpColor(color), width, unit);
    }
    else
    {
        pen->GetObjectLock()->Reset();
        pen->Set(GpColor(color), width, unit);
    }

    if (CheckValid(pen))
    {
        *outPen = pen;
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePen2(
    GpBrush *brush,
    REAL width,
    GpUnit unit,
    GpPen **pen
    )
{
    API_ENTRY(GdipCreatePen2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(pen);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    CheckParameter(
        (unit >= UnitWorld) &&
        (unit <= UnitMillimeter) &&
        (unit != UnitDisplay)
    );

    *pen = new GpPen(brush, width, unit);

    if (CheckValid(*pen))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipClonePen(
    GpPen *pen,
    GpPen **clonepen
    )
{
    API_ENTRY(GdipClonePen);
    CheckParameter(clonepen);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *clonepen = pen->Clone();

    if (CheckValid(*clonepen))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeletePen(
    GpPen *pen
    )
{
    API_ENTRY(GdipDeletePen);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(pen);
    CheckObjectBusyForDelete(pen);

    // !!! [asecchia] only use the pen lookaside for solid pens.
    // it turns out that if we use pens containing TextureBrushes, we require
    // the stream to remain valid for the lifetime of the pen object in the
    // lookaside.

    if(pen->IsSolid())
    {
        pen = (GpPen *) InterlockedExchangePointer((PVOID *) &Globals::PenLookAside, pen);
    }

    if(pen != NULL)
    {
        delete pen;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenWidth(
    GpPen *pen,
    REAL width
    )
{
    API_ENTRY(GdipSetPenWidth);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetWidth(width);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenWidth(
    GpPen *pen,
    REAL *width
    )
{
    API_ENTRY(GdipGetPenWidth);
   CheckParameter(width);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *width = pen->GetWidth();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenUnit(
    GpPen *pen,
    GpUnit unit
    )
{
    API_ENTRY(GdipSetPenUnit);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    CheckParameter((unit >= UnitWorld) && (unit <= UnitMillimeter) && (unit != UnitDisplay));

    pen->SetUnit(unit);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenUnit(
    GpPen *pen,
    GpUnit* unit
    )
{
    API_ENTRY(GdipGetPenUnit);
   CheckParameter(unit);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *unit = pen->GetUnit();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenLineCap197819(
    GpPen *pen,
    GpLineCap startCap,
    GpLineCap endCap,
    GpDashCap dashCap
    )
{
    API_ENTRY(GdipSetPenLineCap197819);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    pen->SetLineCap(startCap, endCap, dashCap);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenStartCap(
    GpPen *pen,
    GpLineCap startCap
    )
{
    API_ENTRY(GdipSetPenStartCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetStartCap(startCap);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenEndCap(
    GpPen *pen,
    GpLineCap endCap
    )
{
    API_ENTRY(GdipSetPenEndCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetEndCap(endCap);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashCap197819(
    GpPen *pen,
    GpDashCap dashCap
    )
{
    API_ENTRY(GdipSetPenDashCap197819);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetDashCap(dashCap);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenStartCap(
    GpPen *pen,
    GpLineCap *startCap
    )
{
    API_ENTRY(GdipGetPenStartCap);
   CheckParameter(startCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *startCap = pen->GetStartCap();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenEndCap(
    GpPen *pen,
    GpLineCap *endCap
    )
{
    API_ENTRY(GdipGetPenEndCap);
   CheckParameter(endCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *endCap = pen->GetEndCap();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashCap197819(
    GpPen *pen,
    GpDashCap *dashCap
    )
{
   API_ENTRY(GdipGetPenDashCap197819);
   CheckParameter(dashCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *dashCap = pen->GetDashCap();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenLineJoin(
    GpPen *pen,
    GpLineJoin lineJoin
    )
{
    API_ENTRY(GdipSetPenLineJoin);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetLineJoin(lineJoin);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenLineJoin(
    GpPen *pen,
    GpLineJoin *lineJoin
    )
{
    API_ENTRY(GdipGetPenLineJoin);
   CheckParameter(lineJoin);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *lineJoin = pen->GetLineJoin();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenCustomStartCap(
    GpPen *pen,
    GpCustomLineCap* customCap
    )
{
    API_ENTRY(GdipSetPenCustomStartCap);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->SetCustomStartCap(customCap);
}

GpStatus
WINGDIPAPI
GdipGetPenCustomStartCap(
    GpPen *pen,
    GpCustomLineCap** customCap
    )
{
    API_ENTRY(GdipGetPenCustomStartCap);
   CheckParameter(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->GetCustomStartCap(customCap);
}

GpStatus
WINGDIPAPI
GdipSetPenCustomEndCap(
    GpPen *pen,
    GpCustomLineCap* customCap
    )
{
    API_ENTRY(GdipSetPenCustomEndCap);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->SetCustomEndCap(customCap);
}

GpStatus
WINGDIPAPI
GdipGetPenCustomEndCap(
    GpPen *pen,
    GpCustomLineCap** customCap
    )
{
    API_ENTRY(GdipGetPenCustomEndCap);
   CheckParameter(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->GetCustomEndCap(customCap);
}

GpStatus
WINGDIPAPI
GdipSetPenMiterLimit(
    GpPen *pen,
    REAL miterLimit
    )
{
    API_ENTRY(GdipSetPenMiterLimit);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetMiterLimit(miterLimit);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenMiterLimit(
    GpPen *pen,
    REAL *miterLimit
    )
{
    API_ENTRY(GdipGetPenMiterLimit);
   CheckParameter(miterLimit);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *miterLimit = pen->GetMiterLimit();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenMode(
    GpPen *pen,
    GpPenAlignment penMode
    )
{
    API_ENTRY(GdipSetPenMode);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->SetPenAlignment(penMode);
}

GpStatus
WINGDIPAPI
GdipGetPenMode(
    GpPen *pen,
    GpPenAlignment *penMode
    )
{
    API_ENTRY(GdipGetPenMode);
   CheckParameter(penMode);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *penMode = pen->GetPenAlignment();

   return Ok;
}


GpStatus
WINGDIPAPI
GdipSetPenTransform(
    GpPen *pen,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetPenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    
    return pen->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipGetPenTransform(
    GpPen *pen,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetPenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return pen->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipResetPenTransform(
    GpPen *pen)
{
    API_ENTRY(GdipResetPenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyPenTransform(
    GpPen *pen,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyPenTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return pen->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslatePenTransform(
    GpPen* pen,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslatePenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameter(MatrixOrderIsValid(order));

    return pen->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScalePenTransform(
    GpPen* pen,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScalePenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameter(MatrixOrderIsValid(order));

    return pen->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotatePenTransform(
    GpPen* pen,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotatePenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameter(MatrixOrderIsValid(order));

    return pen->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipSetPenColor(
    GpPen *pen,
    ARGB argb
    )
{
    API_ENTRY(GdipSetPenColor);
    CheckColorParameter(argb);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    GpColor color(argb);

    return pen->SetColor(&color);
}

GpStatus
WINGDIPAPI
GdipGetPenColor(
    GpPen *pen,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetPenColor);
   CheckParameter(argb);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   ARGB temp;
   Status status = pen->GetColor(&temp);
   *argb = temp;

   return status;
}

GpStatus
WINGDIPAPI
GdipSetPenBrushFill(
    GpPen *pen,
    GpBrush *brush
    )
{
    API_ENTRY(GdipSetPenBrushFill);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return pen->SetBrush(brush);
}

GpStatus
WINGDIPAPI
GdipGetPenBrushFill(
    GpPen *pen,
    GpBrush **brush
    )
{
    API_ENTRY(GdipGetPenBrushFill);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);
   CheckParameter(brush);

   *brush = pen->GetClonedBrush();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenFillType(
    GpPen *pen,
    GpPenType* type
    )
{
    API_ENTRY(GdipGetPenFillType);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);
   CheckParameter(type);

   *type = pen->GetPenType();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashStyle(
    GpPen *pen,
    GpDashStyle *dashstyle
    )
{
    API_ENTRY(GdipGetPenDashStyle);
   CheckParameter(dashstyle);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *dashstyle = (GpDashStyle)pen->GetDashStyle();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashStyle(
    GpPen *pen,
    GpDashStyle dashstyle
    )
{
    API_ENTRY(GdipSetPenDashStyle);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetDashStyle(dashstyle);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashOffset(
    GpPen *pen,
    REAL *offset
    )
{
    API_ENTRY(GdipGetPenDashOffset);
    CheckParameter(offset);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *offset = pen->GetDashOffset();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashOffset(
    GpPen *pen,
    REAL offset
    )
{
    API_ENTRY(GdipSetPenDashOffset);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    pen->SetDashOffset(offset);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashCount(
    GpPen *pen,
    INT *count
    )
{
    API_ENTRY(GdipGetPenDashCount);
    CheckParameter(count);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *count = pen->GetDashCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashArray(
    GpPen *pen,
    GDIPCONST REAL *dash,
    INT count
    )
{
    API_ENTRY(GdipSetPenDashArray);
    CheckParameter(dash);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->SetDashArray(dash, count);
}

GpStatus
WINGDIPAPI
GdipGetPenDashArray(
    GpPen *pen,
    REAL *dash,
    INT count
    )
{
    API_ENTRY(GdipGetPenDashArray);
    CheckParameter(dash);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->GetDashArray(dash, count);
}


GpStatus
WINGDIPAPI
GdipGetPenCompoundCount(
    GpPen *pen,
    INT *count
    )
{
    API_ENTRY(GdipGetPenCompoundCount);
    CheckParameter(count);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *count = pen->GetCompoundCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenCompoundArray(
    GpPen *pen,
    GDIPCONST REAL *compoundArray,
    INT count
    )
{
    API_ENTRY(GdipSetPenCompoundArray);
    CheckParameter(compoundArray);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->SetCompoundArray(compoundArray, count);
}

GpStatus
WINGDIPAPI
GdipGetPenCompoundArray(
    GpPen *pen,
    REAL *compoundArray,
    INT count
    )
{
    API_ENTRY(GdipGetPenCompoundArray);
    CheckParameter(compoundArray);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->GetCompoundArray(compoundArray, count);
}

GpStatus
WINGDIPAPI
GdipCreateCustomLineCap(
    GpPath* fillPath,
    GpPath* strokePath,
    GpLineCap baseCap,
    REAL baseInset,
    GpCustomLineCap **customCap
    )
{
    API_ENTRY(GdipCreateCustomLineCap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    // fillPath or strokePath can be NULL.

    CheckParameter(customCap);
    CheckParameter((fillPath != NULL) || (strokePath != NULL));
    CheckOptionalParameterValid(fillPath);
    CheckOptionalObjectBusy(fillPath);
    CheckOptionalParameterValid(strokePath);
    CheckOptionalObjectBusy(strokePath);

    *customCap = new GpCustomLineCap(fillPath, strokePath, baseCap, baseInset);

    if (*customCap)
    {
        if((*customCap)->IsValid())
        {
            return Ok;
        }
        
        // This failed to create correctly. Retrieve the failure code.
        
        GpStatus status = (*customCap)->GetCreationStatus();
        delete *customCap;
        *customCap = NULL;
        return status;
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCloneCustomLineCap(
    GpCustomLineCap *customCap,
    GpCustomLineCap **newCustomCap
    )
{
    API_ENTRY(GdipCloneCustomLineCap);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);

   *newCustomCap = customCap->Clone();

    if (*newCustomCap)
    {
        if((*newCustomCap)->IsValid())
        {
            return Ok;
        }
        
        // This failed to create correctly. Retrieve the failure code.
        
        GpStatus status = (*newCustomCap)->GetCreationStatus();
        delete *newCustomCap;
        *newCustomCap = NULL;
        return status;
    }
    else
    {
        return OutOfMemory;
    }
}


GpStatus
WINGDIPAPI
GdipGetCustomLineCapType(
    GpCustomLineCap* customCap,
    CustomLineCapType* type
    )
{
    API_ENTRY(GdipGetCustomLineCapType);
   CheckParameter(type);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);

   *type = customCap->GetType();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipDeleteCustomLineCap(
    GpCustomLineCap* customCap
    )
{
    API_ENTRY(GdipDeleteCustomLineCap);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(customCap);
    CheckObjectBusyForDelete(customCap);

    delete customCap;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapStrokeCaps(
    GpCustomLineCap* customCap,
    GpLineCap startCap,
    GpLineCap endCap)
{
    API_ENTRY(GdipSetCustomLineCapStrokeCaps);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetStrokeCaps(startCap, endCap);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapStrokeCaps(
    GpCustomLineCap* customCap,
    GpLineCap* startCap,
    GpLineCap* endCap
    )
{
    API_ENTRY(GdipGetCustomLineCapStrokeCaps);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(startCap);
    CheckParameter(endCap);

    return customCap->GetStrokeCaps(startCap, endCap);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapStrokeJoin(
    GpCustomLineCap* customCap,
    GpLineJoin lineJoin
    )
{
    API_ENTRY(GdipSetCustomLineCapStrokeJoin);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetStrokeJoin(lineJoin);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapStrokeJoin(
    GpCustomLineCap* customCap,
    GpLineJoin* lineJoin
    )
{
    API_ENTRY(GdipGetCustomLineCapStrokeJoin);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(lineJoin);

    return customCap->GetStrokeJoin(lineJoin);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapBaseCap(
    GpCustomLineCap* customCap,
    GpLineCap baseCap
    )
{
    API_ENTRY(GdipSetCustomLineCapBaseCap);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetBaseCap(baseCap);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapBaseCap(
    GpCustomLineCap* customCap,
    GpLineCap* baseCap
    )
{
    API_ENTRY(GdipGetCustomLineCapBaseCap);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(baseCap);

    return customCap->GetBaseCap(baseCap);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapBaseInset(
    GpCustomLineCap* customCap,
    REAL inset
    )
{
    API_ENTRY(GdipSetCustomLineCapBaseInset);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetBaseInset(inset);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapBaseInset(
    GpCustomLineCap* customCap,
    REAL* inset
    )
{
    API_ENTRY(GdipGetCustomLineCapBaseInset);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(inset);

    return customCap->GetBaseInset(inset);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapWidthScale(
    GpCustomLineCap* customCap,
    REAL widthScale
    )
{
    API_ENTRY(GdipSetCustomLineCapWidthScale);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetWidthScale(widthScale);
}

GpStatus WINGDIPAPI
GdipGetCustomLineCapWidthScale(
    GpCustomLineCap* customCap,
    REAL* widthScale
    )
{
    API_ENTRY(GdipGetCustomLineCapWidthScale);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(widthScale);

    return customCap->GetWidthScale(widthScale);
}

GpStatus
WINGDIPAPI
GdipCreateAdjustableArrowCap(
    REAL height,
    REAL width,
    BOOL isFilled,
    GpAdjustableArrowCap **cap)
{
    API_ENTRY(GdipCreateAdjustableArrowCap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(cap);

    *cap = new GpAdjustableArrowCap(height, width, isFilled);

    if(*cap)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapHeight(
    GpAdjustableArrowCap* cap,
    REAL height
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapHeight);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetHeight(height);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapHeight(
    GpAdjustableArrowCap* cap,
    REAL* height
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapHeight);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(height);

    *height = cap->GetHeight();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapWidth(
    GpAdjustableArrowCap* cap,
    REAL width
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapWidth);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetWidth(width);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapWidth(
    GpAdjustableArrowCap* cap,
    REAL* width
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapWidth);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(width);

    *width = cap->GetWidth();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapMiddleInset(
    GpAdjustableArrowCap* cap,
    REAL middleInset
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapMiddleInset);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetMiddleInset(middleInset);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapMiddleInset(
    GpAdjustableArrowCap* cap,
    REAL* middleInset
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapMiddleInset);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(middleInset);

    *middleInset = cap->GetMiddleInset();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapFillState(
    GpAdjustableArrowCap* cap,
    BOOL fillState
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapFillState);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetFillState(fillState);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapFillState(
    GpAdjustableArrowCap* cap,
    BOOL* fillState
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapFillState);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(fillState);

    *fillState = cap->IsFilled();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromStream(
    IStream* stream,
    GpImage **image
    )
{
    API_ENTRY(GdipLoadImageFromStream);
    CheckParameter(image && stream);


    *image = GpImage::LoadImage(stream);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(FALSE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromFile(
    GDIPCONST WCHAR* filename,
    GpImage** image
    )
{
    API_ENTRY(GdipLoadImageFromFile);
    CheckParameter(image && filename);


    *image = GpImage::LoadImage(filename);

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(FALSE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromStreamICM(
    IStream* stream,
    GpImage **image
    )
{
    API_ENTRY(GdipLoadImageFromStreamICM);
    CheckParameter(image && stream);


    *image = GpImage::LoadImage(stream);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(TRUE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromFileICM(
    GDIPCONST WCHAR* filename,
    GpImage** image
    )
{
    API_ENTRY(GdipLoadImageFromFileICM);
    CheckParameter(image && filename);


    *image = GpImage::LoadImage(filename);

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(TRUE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}


GpStatus
WINGDIPAPI
GdipGetEncoderParameterListSize(
    GpImage         *image,
    GDIPCONST CLSID *clsidEncoder,
    UINT            *size
    )
{
    API_ENTRY(GdipGetEncoderParameterListSize);
    CheckParameter(image && clsidEncoder);
    CheckObjectBusy(image);

    return image->GetEncoderParameterListSize(const_cast<CLSID*>(clsidEncoder), size);
}

GpStatus
WINGDIPAPI
GdipGetEncoderParameterList(
    GpImage           *image,
    GDIPCONST CLSID   *clsidEncoder,
    UINT               size,
    EncoderParameters *buffer
    )
{
    API_ENTRY(GdipGetEncoderParameterList);
    CheckParameter(image && clsidEncoder);
    CheckObjectBusy(image);

    return image->GetEncoderParameterList(const_cast<CLSID*>(clsidEncoder), size, buffer);
}

GpStatus
WINGDIPAPI
GdipSaveImageToStream(
    GpImage *image,
    IStream* stream,
    GDIPCONST CLSID* clsidEncoder,
    GDIPCONST EncoderParameters* encoderParams
    )
{
    API_ENTRY(GdipSaveImageToStream);
    CheckParameter(image && stream && clsidEncoder);
    CheckObjectBusy(image);

    return image->SaveToStream(stream,
                               const_cast<CLSID*>(clsidEncoder),
                               const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipSaveImageToFile(
    GpImage *image,
    GDIPCONST WCHAR* filename,
    GDIPCONST CLSID* clsidEncoder,
    GDIPCONST EncoderParameters* encoderParams
    )
{
    API_ENTRY(GdipSaveImageToFile);
    CheckParameter(image && filename && clsidEncoder);
    CheckObjectBusy(image);

    return image->SaveToFile(filename,
                             const_cast<CLSID*>(clsidEncoder),
                             const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipSaveAdd(
    GpImage *image,
    GDIPCONST EncoderParameters* encoderParams
    )
{
    API_ENTRY(GdipSaveAdd);
    CheckParameter(image && encoderParams);
    CheckObjectBusy(image);

    return image->SaveAdd(const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipSaveAddImage(
    GpImage*            image,
    GpImage*            newImage,
    GDIPCONST EncoderParameters*  encoderParams
    )
{
    API_ENTRY(GdipSaveAddImage);
    CheckParameter(image && newImage && encoderParams);
    CheckObjectBusy(image);

    return image->SaveAdd(newImage, const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipImageGetFrameDimensionsCount(
    GpImage*    image,
    UINT*       count
    )
{
    API_ENTRY(GdipImageGetFrameDimensionsCount);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetFrameDimensionsCount(count);
}

GpStatus
WINGDIPAPI
GdipImageGetFrameDimensionsList(
    GpImage*    image,
    GUID*       dimensionIDs,
    UINT        count
    )
{
    API_ENTRY(GdipImageGetFrameDimensionsList);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetFrameDimensionsList(dimensionIDs, count);
}

GpStatus
WINGDIPAPI
GdipImageGetFrameCount(
    GpImage*    image,
    GDIPCONST GUID* dimensionID,
    UINT*       count
    )
{
    API_ENTRY(GdipImageGetFrameCount);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetFrameCount(dimensionID, count);
}

GpStatus
WINGDIPAPI
GdipImageSelectActiveFrame(
    GpImage*    image,
    GDIPCONST GUID* dimensionID,
    UINT        frameIndex
    )
{
    API_ENTRY(GdipImageSelectActiveFrame);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->SelectActiveFrame(dimensionID, frameIndex);
}

GpStatus
WINGDIPAPI
GdipImageRotateFlip(
    GpImage*        image,
    RotateFlipType  rfType
    )
{
    API_ENTRY(GdipImageRotateFlip);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->RotateFlip(rfType);
}

GpStatus
WINGDIPAPI
GdipGetPropertyCount(
    GpImage*    image,
    UINT* numOfProperty
    )
{
    API_ENTRY(GdipGetPropertyCount);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyCount(numOfProperty);
}

GpStatus
WINGDIPAPI
GdipGetPropertyIdList(
    GpImage*    image,
    UINT        numOfProperty,
    PROPID*     list
    )
{
    API_ENTRY(GdipGetPropertyIdList);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyIdList(numOfProperty, list);
}

GpStatus
WINGDIPAPI
GdipGetPropertyItemSize(
    GpImage*    image,
    PROPID      propId,
    UINT*       size
    )
{
    API_ENTRY(GdipGetPropertyItemSize);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyItemSize(propId, size);
}

GpStatus
WINGDIPAPI
GdipGetPropertyItem(
    GpImage*        image,
    PROPID          propId,
    UINT            propSize,
    PropertyItem*   buffer
    )
{
    API_ENTRY(GdipGetPropertyItem);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyItem(propId, propSize, buffer);
}

GpStatus
WINGDIPAPI
GdipGetPropertySize(
    GpImage*    image,
    UINT*       totalBufferSize,
    UINT*       numProperties
    )
{
    API_ENTRY(GdipGetPropertySize);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertySize(totalBufferSize, numProperties);
}

GpStatus
WINGDIPAPI
GdipGetAllPropertyItems(
    GpImage*    image,
    UINT        totalBufferSize,
    UINT        numProperties,
    PropertyItem* allItems
    )
{
    API_ENTRY(GdipGetAllPropertyItems);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetAllPropertyItems(totalBufferSize, numProperties, allItems);
}

GpStatus
WINGDIPAPI
GdipRemovePropertyItem(
    GpImage*    image,
    PROPID      propId
    )
{
    API_ENTRY(GdipRemovePropertyItem);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->RemovePropertyItem(propId);
}

GpStatus
WINGDIPAPI
GdipSetPropertyItem(
    GpImage*                   image,
    GDIPCONST PropertyItem*    item
    )
{
    API_ENTRY(GdipSetPropertyItem);
    CheckParameter(image && item);
    CheckObjectBusy(image);
    return image->SetPropertyItem(const_cast<PropertyItem*>(item));
}

GpStatus
WINGDIPAPI
GdipCloneImage(
    GpImage* image,
    GpImage** cloneimage
    )
{
    API_ENTRY(GdipCloneImage);
   CheckParameter(cloneimage);
   CheckParameterValid(image);
   CheckObjectBusy(image);

   *cloneimage = image->Clone();

   if (*cloneimage)
       return Ok;
   else
       return OutOfMemory;

   // !!!: There is no destructor to invoke.  Leave it to Clone to
   //       verify correct creation.
}

GpStatus
WINGDIPAPI
GdipDisposeImage(
    GpImage *image
    )
{
    API_ENTRY(GdipDisposeImage);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(image);

    if (image->GetImageType() == ImageTypeMetafile)
    {
        // If the user still has the graphics associated with the metafile,
        // then we have to lock it, to prevent them from using it while
        // we're busy deleting the metafile object.  The metafile dispose
        // method will set the graphics to invalid, so the only thing
        // they can do with the graphics is to delete it after this call.

        GpMetafile *    metafile = (GpMetafile *)image;
        GpGraphics *    g = metafile->PrivateAPIForGettingMetafileGraphicsContext();
        CheckOptionalObjectBusy(g);
        CheckObjectBusyForDelete(metafile);
        metafile->Dispose();
        return Ok;
    }

    CheckObjectBusyForDelete(image);

    image->Dispose();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetImageGraphicsContext(
    GpImage *image,
    GpGraphics **graphics
    )
{
    API_ENTRY(GdipGetImageGraphicsContext);
   CheckParameter(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);

   *graphics = image->GetGraphicsContext();

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipGetImageBounds(
    GpImage *image,
    GpRectF *srcRect,
    GpPageUnit *srcUnit
    )
{
    API_ENTRY(GdipGetImageBounds);
    CheckParameter(srcRect && srcUnit);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->GetBounds(srcRect, srcUnit);
}


GpStatus
WINGDIPAPI
GdipGetImageDimension(
    GpImage *image,
    REAL *width,
    REAL *height
    )
{
    API_ENTRY(GdipGetImageDimension);
    CheckParameter(width && height);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->GetPhysicalDimension(width, height);
}

GpStatus
WINGDIPAPI
GdipGetImageWidth(
    GpImage *image,
    UINT *width
    )
{
    API_ENTRY(GdipGetImageWidth);
    CheckParameter(width);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *width = imageinfo.Width;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetImageHeight(
    GpImage *image,
    UINT *height
    )
{
    API_ENTRY(GdipGetImageHeight);
    CheckParameter(height);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *height = imageinfo.Height;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetImageHorizontalResolution(
    GpImage *image,
    REAL *resolution
    )
{
    API_ENTRY(GdipGetImageHorizontalResolution);
    CheckParameter(resolution);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *resolution = (REAL) imageinfo.Xdpi;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImageVerticalResolution(
    GpImage *image,
    REAL *resolution
    )
{
    API_ENTRY(GdipGetImageVerticalResolution);
    CheckParameter(resolution);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *resolution = (REAL) imageinfo.Ydpi;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImageFlags(
    GpImage *image,
    UINT *flags
    )
{
    API_ENTRY(GdipGetImageFlags);
    CheckParameter(flags);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *flags = imageinfo.Flags;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImageRawFormat(
    GpImage *image,
    GUID *format
    )
{
    API_ENTRY(GdipGetImageRawFormat);
    CheckParameter(format);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *format = imageinfo.RawDataFormat;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImagePixelFormat(
    GpImage *image,
    PixelFormat *format
    )
{
    API_ENTRY(GdipGetImagePixelFormat);
    CheckParameter(format);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        //!!!need conversion to PixelFormat
        *format = (PixelFormat) imageinfo.PixelFormat;
    }

    return status;
}

GpStatus WINGDIPAPI
GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size)
{
    API_ENTRY(GdipGetImagePalette);
    CheckParameter(palette);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->GetPalette(palette, size);
}

GpStatus WINGDIPAPI
GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette)
{
    API_ENTRY(GdipSetImagePalette);
    CheckParameter(palette);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->SetPalette(const_cast<ColorPalette*>(palette));
}

GpStatus WINGDIPAPI
GdipGetImagePaletteSize(GpImage *image, INT *size)
{
    API_ENTRY(GdipGetImagePaletteSize);

  CheckParameter(size);
  CheckParameterValid(image);
  CheckObjectBusy(image);

  *size = image->GetPaletteSize();

  // Note: image->GetPaletteSize() will return zero if and only if there is
  // something wrong in the whole pipeline, like a bad image, out of memory etc.

  if (*size == 0)
  {
      return GenericError;
  }
  else
  {
    return Ok;
  }
}




GpStatus
WINGDIPAPI
GdipGetImageType(
    GpImage* image,
    ImageType* type
    )
{
    API_ENTRY(GdipGetImageType);
    CheckParameter(type);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    *type = (ImageType)image->GetImageType();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetImageThumbnail(
    GpImage* image,
    UINT thumbWidth,
    UINT thumbHeight,
    GpImage** thumbImage,
    GetThumbnailImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipGetImageThumbnail);
    CheckParameter(thumbImage);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    *thumbImage = image->GetThumbnail(thumbWidth, thumbHeight, callback, callbackData);

    if (*thumbImage)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipImageForceValidation(GpImage* image)
{
    API_ENTRY(GdipImageForceValidation);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    // Metafiles don't need a force decode

    if (image->GetImageType() == ImageTypeBitmap)
        return (static_cast<GpBitmap*>(image))->ForceValidation();
    else
        return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromStream(
    IStream* stream,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromStream);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && stream);

    *bitmap = NULL;

    // See if the stream is a metafile


    GpMetafile* metafile = new GpMetafile(stream);

    if (metafile != NULL)
    {
        if (metafile->IsValid())
        {
            // If it is a {EMF, WMF} file, then we get a raster version of it
            // Note: GetBitmap() might return NULL if there is anything wrong
            // with the Metafile

            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    if ( NULL == *bitmap )
    {
        // it's not a valid metafile -- it must be a bitmap

        *bitmap = new GpBitmap(stream);
    }

SkipRasterImage:
    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(FALSE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromFile(
    GDIPCONST WCHAR* filename,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && filename);

    *bitmap = NULL;


    // Try a metafile first always
    GpMetafile* metafile;
    metafile = new GpMetafile(filename);

    if (metafile)
    {
        if (metafile->IsValid())
        {
            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    // If it is not a metafile, then check if this is a raster image

    if ( NULL == *bitmap )
    {
        *bitmap = new GpBitmap(filename);
    }

    // !!! Can't use CheckValid() since destructor is protected.
SkipRasterImage:

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(FALSE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromStreamICM(
    IStream* stream,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromStreamICM);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && stream);

    *bitmap = NULL;

    // See if the stream is a metafile


    GpMetafile* metafile = new GpMetafile(stream);

    if (metafile != NULL)
    {
        if (metafile->IsValid())
        {
            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    if ( NULL == *bitmap )
    {
        // it's not a valid metafile -- it must be a bitmap
        *bitmap = new GpBitmap(stream);
    }

    // !!! Can't use CheckValid() since destructor is protected.
SkipRasterImage:

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(TRUE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromFileICM(
    GDIPCONST WCHAR* filename,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromFileICM);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && filename);

    // copied from GpImage::LoadImage

    *bitmap = NULL;


    // Try a metafile first always
    GpMetafile* metafile;
    metafile = new GpMetafile(filename);

    if (metafile)
    {
        if (metafile->IsValid())
        {
            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    // If it is not a metafile, then check if this is a raster image

    if ( NULL == *bitmap )
    {
        *bitmap = new GpBitmap(filename);
    }

    // !!! Can't use CheckValid() since destructor is protected.

SkipRasterImage:
    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(TRUE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}


GpStatus
WINGDIPAPI
GdipCreateBitmapFromScan0(
    INT width,
    INT height,
    INT stride,
    PixelFormatID format,
    BYTE* scan0,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromScan0);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);

    if (scan0 == NULL)
    {
        *bitmap = new GpBitmap(width, height, format);
    }
    else
    {
        CheckParameter(stride);
        *bitmap = new GpBitmap(width, height, stride, format, scan0);
    }

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromGraphics(
    INT width,
    INT height,
    GpGraphics* graphics,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromGraphics);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    //!!!TODO: temp use 32bpp argb

    #ifdef NO_PREMULTIPLIED_ALPHA
    *bitmap = new GpBitmap(width, height, PIXFMT_32BPP_ARGB, graphics);
    #else
    *bitmap = new GpBitmap(width, height, PIXFMT_32BPP_PARGB, graphics);
    #endif

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromDirectDrawSurface(
    IDirectDrawSurface7 * surface,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromDirectDrawSurface);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);
    CheckParameter(surface);

    *bitmap = new GpBitmap(surface);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;

            return InvalidParameter;
        }
    }

    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromGdiDib(
    GDIPCONST BITMAPINFO* gdiBitmapInfo,
    VOID* gdiBitmapData,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromGdiDib);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);
    CheckParameter(gdiBitmapInfo);
    CheckParameter(gdiBitmapData);

    *bitmap = new GpBitmap(const_cast<BITMAPINFO*>(gdiBitmapInfo),
                           gdiBitmapData,
                           FALSE);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromHBITMAP(
    HBITMAP hbm,
    HPALETTE hpal,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromHBITMAP);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);

    return GpBitmap::CreateFromHBITMAP(hbm, hpal, bitmap);
}

GpStatus
WINGDIPAPI
GdipCreateHBITMAPFromBitmap(
    GpBitmap* bitmap,
    HBITMAP* hbmReturn,
    ARGB background
    )
{
    API_ENTRY(GdipCreateHBITMAPFromBitmap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(background);
    CheckParameter(hbmReturn);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->CreateHBITMAP(hbmReturn, background);
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromHICON(
    HICON hicon,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromHICON);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);

    return GpBitmap::CreateFromHICON(hicon, bitmap);
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromResource(HINSTANCE hInstance,
                             GDIPCONST WCHAR* lpBitmapName,
                             GpBitmap** bitmap)
{
    API_ENTRY(GdipCreateBitmapFromResource);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);

    return GpBitmap::CreateFromResource(hInstance, const_cast<WCHAR*>(lpBitmapName), bitmap);
}

GpStatus
WINGDIPAPI
GdipCreateHICONFromBitmap(
    GpBitmap* bitmap,
    HICON* hiconReturn)
{
    API_ENTRY(GdipCreateHICONFromBitmap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(hiconReturn);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->CreateHICON(hiconReturn);
}

GpStatus
WINGDIPAPI
GdipCloneBitmapArea(
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    PixelFormatID format,
    GpBitmap *srcBitmap,
    GpBitmap **dstBitmap
    )
{
    API_ENTRY(GdipCloneBitmapArea);

   return GdipCloneBitmapAreaI(GpRound(x), GpRound(y),
                               GpRound(width), GpRound(height),
                               format, srcBitmap, dstBitmap);
}

GpStatus
WINGDIPAPI
GdipCloneBitmapAreaI(
    INT x,
    INT y,
    INT width,
    INT height,
    PixelFormatID format,
    GpBitmap *srcBitmap,
    GpBitmap **dstBitmap
    )
{
    API_ENTRY(GdipCloneBitmapAreaI);
   CheckParameter(dstBitmap);
   CheckParameterValid(srcBitmap);
   CheckObjectBusy(srcBitmap);

   GpRect rect(x, y, width, height);

   *dstBitmap = srcBitmap->Clone(&rect, format);

   if (*dstBitmap)
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipBitmapLockBits(
    GpBitmap* bitmap,
    GDIPCONST GpRect* rect,   // can be NULL
    UINT flags,
    PixelFormatID format,
    BitmapData* lockedBitmapData
)
{
    API_ENTRY(GdipBitmapLockBits);
    CheckParameter(lockedBitmapData);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->LockBits(rect, flags, format, lockedBitmapData);
}

GpStatus
WINGDIPAPI
GdipBitmapUnlockBits(
    GpBitmap* bitmap,
    BitmapData* lockedBitmapData
)
{
    API_ENTRY(GdipBitmapUnlockBits);
    CheckParameter(lockedBitmapData);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->UnlockBits(lockedBitmapData);
}

GpStatus
WINGDIPAPI
GdipBitmapGetPixel(
    GpBitmap* bitmap,
    INT x,
    INT y,
    ARGB *color
)
{
    API_ENTRY(GdipBitmapGetPixel);
    CheckParameter(color);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    ARGB temp;
    Status status = bitmap->GetPixel(x, y, &temp);
    *color = temp;

    return status;
}

GpStatus
WINGDIPAPI
GdipBitmapSetPixel(
    GpBitmap* bitmap,
    INT x,
    INT y,
    ARGB color
)
{
    API_ENTRY(GdipBitmapSetPixel);
    CheckColorParameter(color);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->SetPixel(x, y, color);
}

GpStatus
WINGDIPAPI
GdipBitmapSetResolution(
    GpBitmap* bitmap,
    REAL xdpi,
    REAL ydpi
)
{
    API_ENTRY(GdipBitmapSetResolution);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->SetResolution(xdpi, ydpi);
}

GpStatus
WINGDIPAPI
GdipCreateImageAttributes(GpImageAttributes **imageattr)
{
    API_ENTRY(GdipCreateImageAttributes);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(imageattr);

    *imageattr = new GpImageAttributes();

    if (*imageattr)
    {
        if ((*imageattr)->IsValid())
        {
            return Ok;
        }
        else
        {
            (*imageattr)->Dispose();
            *imageattr = NULL;
            return OutOfMemory;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCloneImageAttributes(
    GDIPCONST GpImageAttributes *imageattr,
    GpImageAttributes **cloneImageAttr
)
{
    API_ENTRY(GdipCloneImageAttributes);
    CheckParameter(cloneImageAttr);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);

    *cloneImageAttr = imageattr->Clone();

    if (*cloneImageAttr)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDisposeImageAttributes(
    GpImageAttributes *imageattr
)
{
    API_ENTRY(GdipDisposeImageAttributes);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(imageattr);
    CheckObjectBusyForDelete(imageattr);

    imageattr->Dispose();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesToIdentity(
    GpImageAttributes *imageattr,
    ColorAdjustType type
)
{
    API_ENTRY(GdipSetImageAttributesToIdentity);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetToIdentity(type);
}

GpStatus
WINGDIPAPI
GdipResetImageAttributes(
    GpImageAttributes *imageattr,
    ColorAdjustType type
)
{
    API_ENTRY(GdipResetImageAttributes);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->Reset(type);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesColorMatrix(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    GDIPCONST ColorMatrix* colorMatrix,
    GDIPCONST ColorMatrix* grayMatrix,
    ColorMatrixFlags flags
)
{
    API_ENTRY(GdipSetImageAttributesColorMatrix);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    // Note: GpImageAttributes::SetColorMatrix will validate
    //       colorMatrix since it may be valid to pass NULL
    //       (such as when enableFlag is FALSE).

    return imageattr->SetColorMatrix(type,
                                     enableFlag,
                                     const_cast<ColorMatrix*>(colorMatrix),
                                     const_cast<ColorMatrix*>(grayMatrix), flags);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesThreshold(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    REAL threshold
)
{
    API_ENTRY(GdipSetImageAttributesThreshold);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetThreshold(type, enableFlag, threshold);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesGamma(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    REAL gamma
)
{
    API_ENTRY(GdipSetImageAttributesGamma);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetGamma(type, enableFlag, gamma);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesNoOp(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag
)
{
    API_ENTRY(GdipSetImageAttributesNoOp);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetNoOp(type, enableFlag);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesColorKeys(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    ARGB argbLow,
    ARGB argbHigh
)
{
    API_ENTRY(GdipSetImageAttributesColorKeys);
    CheckColorParameter(argbLow);
    CheckColorParameter(argbHigh);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    Color colorLow(argbLow);
    Color colorHigh(argbHigh);

    return imageattr->SetColorKeys(type, enableFlag, &colorLow, &colorHigh);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesOutputChannel(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    ColorChannelFlags channelFlags
)
{
    API_ENTRY(GdipSetImageAttributesOutputChannel);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetOutputChannel(type, enableFlag, channelFlags);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesOutputChannelColorProfile(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    GDIPCONST WCHAR *colorProfileFilename)
{
    API_ENTRY(GdipSetImageAttributesOutputChannelColorProfile);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    // Note: GpImageAttributes::SetOutputChannelProfile will validate
    //       colorProfileFilename since it may be valid to pass NULL
    //       (such as when enableFlag is FALSE).

    return imageattr->SetOutputChannelProfile(type, enableFlag,
                                              const_cast<WCHAR*>(colorProfileFilename));
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesRemapTable(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    UINT mapSize,
    GDIPCONST ColorMap *map
)
{
    API_ENTRY(GdipSetImageAttributesRemapTable);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetRemapTable(type, enableFlag, mapSize, const_cast<ColorMap*>(map));
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesCachedBackground(
    GpImageAttributes *imageattr,
    BOOL enableFlag
)
{
    API_ENTRY(GdipSetImageAttributesCachedBackground);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);

    return imageattr->SetCachedBackground(enableFlag);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesWrapMode(
    GpImageAttributes *imageAttr,
    WrapMode wrap,
    ARGB argb,
    BOOL clamp
)
{
    API_ENTRY(GdipSetImageAttributesWrapMode);
    CheckColorParameter(argb);
    CheckParameterValid(imageAttr);
    CheckObjectBusy(imageAttr);

    return imageAttr->SetWrapMode(wrap, argb, clamp);
}

GpStatus WINGDIPAPI
GdipGetImageAttributesAdjustedPalette(
    GpImageAttributes *imageAttr,
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
    )
{
    API_ENTRY(GdipGetImageAttributesAdjustedPalette);
    CheckParameterValid(imageAttr);
    CheckObjectBusy(imageAttr);
    CheckParameter((colorPalette != NULL) && (colorPalette->Count > 0));
    CheckParameter((colorAdjustType >= ColorAdjustTypeBitmap) &&
                   (colorAdjustType < ColorAdjustTypeCount));

    imageAttr->GetAdjustedPalette(colorPalette, colorAdjustType);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateFromHDC(
    HDC hdc,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHDC);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);


   *graphics = GpGraphics::GetFromHdc(hdc);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateFromHDC2(
    HDC hdc,
    HANDLE hdevice,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHDC2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);


   *graphics = GpGraphics::GetFromHdc(hdc, hdevice);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateFromHWND(
    HWND hwnd,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHWND);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);

   *graphics = GpGraphics::GetFromHwnd(hwnd);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateFromHWNDICM(
    HWND hwnd,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHWNDICM);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);

   *graphics = GpGraphics::GetFromHwnd(hwnd, IcmModeOn);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteGraphics(
    GpGraphics* graphics
    )
{
    API_ENTRY(GdipDeleteGraphics);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(graphics);
    CheckObjectBusyForDelete(graphics);


    delete graphics;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipFlush(
    GpGraphics* graphics,
    GpFlushIntention intention
    )
{
    API_ENTRY(GdipFlush);
    CheckParameter(graphics);
    CheckObjectBusy(graphics);


    graphics->Flush(intention);

    return Ok;
}


GpStatus
WINGDIPAPI
GdipSetRenderingOrigin(
    GpGraphics* graphics,
    INT x,
    INT y
    )
{
    API_ENTRY(GdipSetRenderingOrigin);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->SetRenderingOrigin(x, y);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRenderingOrigin(
    GpGraphics *graphics,
    INT *x,
    INT *y
    )
{
    API_ENTRY(GdipGetRenderingOrigin);
    CheckParameter(x);
    CheckParameter(y);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetRenderingOrigin(x, y);

    return Ok;
}



GpStatus
WINGDIPAPI
GdipSetCompositingMode(
    GpGraphics* graphics,
    CompositingMode newMode
    )
{
    API_ENTRY(GdipSetCompositingMode);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->SetCompositingMode(newMode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetCompositingMode(
    GpGraphics *graphics,
    CompositingMode *mode
    )
{
    API_ENTRY(GdipGetCompositingMode);
    CheckParameter(mode);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *mode = graphics->GetCompositingMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetCompositingQuality(
    GpGraphics* graphics,
    CompositingQuality newQuality
    )
{
    API_ENTRY(GdipSetCompositingQuality);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->SetCompositingQuality(newQuality);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetCompositingQuality(
    GpGraphics *graphics,
    CompositingQuality *quality
    )
{
    API_ENTRY(GdipGetCompositingQuality);
    CheckParameter(quality);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *quality = graphics->GetCompositingQuality();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetSmoothingMode(
    GpGraphics* graphics,
    SmoothingMode smoothingMode
    )
{
    API_ENTRY(GdipSetSmoothingMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   // For now, have it so that a Rendering hint of 1
   // means antialiasing ON and a Rendering Hint of 0
   // means Off.

   switch(smoothingMode)
   {
   case SmoothingModeDefault:
   case SmoothingModeHighSpeed:
   case SmoothingModeNone:
       graphics->SetAntiAliasMode(FALSE);
       break;

   case SmoothingModeHighQuality:
   case SmoothingModeAntiAlias:
       graphics->SetAntiAliasMode(TRUE);
       break;

   default:
       // unknown rendering mode
       return InvalidParameter;
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetSmoothingMode(
    GpGraphics *graphics,
    SmoothingMode *smoothingMode
    )
{
    API_ENTRY(GdipGetSmoothingMode);
   CheckParameter(smoothingMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   BOOL aaOn = graphics->GetAntiAliasMode();

   if (aaOn)
   {
       *smoothingMode = SmoothingModeAntiAlias;
   }
   else
   {
       *smoothingMode = SmoothingModeNone;
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPixelOffsetMode(
    GpGraphics* graphics,
    PixelOffsetMode newMode
    )
{
    API_ENTRY(GdipSetPixelOffsetMode);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter((newMode >= PixelOffsetModeDefault) &&
                   (newMode <= PixelOffsetModeHalf));

    graphics->SetPixelOffsetMode(newMode);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPixelOffsetMode(
    GpGraphics *graphics,
    PixelOffsetMode *pixelOffsetMode
    )
{
    API_ENTRY(GdipGetPixelOffsetMode);
   CheckParameter(pixelOffsetMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *pixelOffsetMode = graphics->GetPixelOffsetMode();
   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetTextRenderingHint(
    GpGraphics* graphics,
    TextRenderingHint newMode
    )
{
    API_ENTRY(GdipSetTextRenderingHint);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   // For now, have it so that a Rendering hint of 1
   // means antialiasing ON and a Rendering Hint of 0
   // means Off.

   switch(newMode)
   {
   case TextRenderingHintSystemDefault:
   case TextRenderingHintSingleBitPerPixelGridFit:
   case TextRenderingHintSingleBitPerPixel:
   case TextRenderingHintAntiAlias:
   case TextRenderingHintAntiAliasGridFit:
   case TextRenderingHintClearTypeGridFit:
       graphics->SetTextRenderingHint(newMode);
       break;

   default:
       // unknown rendering mode
       return InvalidParameter;
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetTextContrast(
    GpGraphics* graphics,
    UINT        contrast
    )
{
    API_ENTRY(GdipSetTextContrast);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->SetTextContrast(contrast);
}

GpStatus
WINGDIPAPI
GdipGetTextContrast(
    GpGraphics* graphics,
    UINT      * contrast
    )
{
    API_ENTRY(GdipGetTextContrast);
   CheckParameter(contrast);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *contrast = graphics->GetTextContrast();

   return Ok;
}


GpStatus
WINGDIPAPI
GdipGetTextRenderingHint(
    GpGraphics *graphics,
    TextRenderingHint *mode
    )
{
    API_ENTRY(GdipGetTextRenderingHint);
   CheckParameter(mode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *mode = graphics->GetTextRenderingHint();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetInterpolationMode(
    GpGraphics* graphics,
    InterpolationMode interpolationMode
    )
{
    API_ENTRY(GdipSetInterpolationMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameter((interpolationMode >= InterpolationModeDefault) &&
                  (interpolationMode <= InterpolationModeHighQualityBicubic));

   if(Globals::ForceBilinear)
   {
       if(interpolationMode != InterpolationModeNearestNeighbor)
       {
           interpolationMode = InterpolationModeBilinear;
       }
   }
   else
   {
       if(interpolationMode == InterpolationModeDefault ||
          interpolationMode == InterpolationModeLowQuality)
       {
           interpolationMode = InterpolationModeBilinear;
       }
       else if(interpolationMode == InterpolationModeHighQuality)
       {
           interpolationMode = InterpolationModeHighQualityBicubic;
       }
   }

   graphics->SetInterpolationMode(interpolationMode);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetInterpolationMode(
    GpGraphics* graphics,
    InterpolationMode *interpolationMode
    )
{
    API_ENTRY(GdipGetInterpolationMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *interpolationMode = graphics->GetInterpolationMode();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetWorldTransform(
    GpGraphics *graphics,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetWorldTransform);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);
    
   return graphics->SetWorldTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipResetWorldTransform(
    GpGraphics *graphics
    )
{
    API_ENTRY(GdipResetWorldTransform);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->ResetWorldTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyWorldTransform(
    GpGraphics *graphics,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipMultiplyWorldTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    return graphics->MultiplyWorldTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslateWorldTransform(
    GpGraphics *graphics,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateWorldTransform);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(MatrixOrderIsValid(order));

    return graphics->TranslateWorldTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScaleWorldTransform(
    GpGraphics *graphics,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleWorldTransform);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(MatrixOrderIsValid(order));
    
    return graphics->ScaleWorldTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotateWorldTransform(
    GpGraphics *graphics,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateWorldTransform);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(MatrixOrderIsValid(order));

    return graphics->RotateWorldTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipGetWorldTransform(
    GpGraphics *graphics,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetWorldTransform);
    CheckParameter(matrix);
    CheckObjectBusy(matrix);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetWorldTransform(*matrix);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipResetPageTransform(
    GpGraphics *graphics
    )
{
    API_ENTRY(GdipResetPageTransform);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->ResetPageTransform();
}

GpStatus
WINGDIPAPI
GdipGetPageUnit(
    GpGraphics* graphics,
    GpPageUnit* unit
    )
{
    API_ENTRY(GdipGetPageUnit);
   CheckParameter(unit);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *unit = graphics->GetPageUnit();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPageUnit(
    GpGraphics* graphics,
    GpPageUnit unit
    )
{
    API_ENTRY(GdipSetPageUnit);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

   // PageUnit can't be world
    CheckParameter((unit > UnitWorld) && (unit <= UnitMillimeter));

    return graphics->SetPageUnit(unit);
}

GpStatus
WINGDIPAPI
GdipGetPageScale(
    GpGraphics* graphics,
    REAL* scale
    )
{
    API_ENTRY(GdipGetPageScale);
   CheckParameter(scale);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *scale = graphics->GetPageScale();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPageScale(
    GpGraphics* graphics,
    REAL scale
    )
{
    API_ENTRY(GdipSetPageScale);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->SetPageScale(scale);
}

GpStatus
WINGDIPAPI
GdipGetDpiX(
    GpGraphics* graphics,
    REAL* dpi
    )
{
    API_ENTRY(GdipGetDpiX);
   CheckParameter(dpi);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *dpi = graphics->GetDpiX();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetDpiY(
    GpGraphics* graphics,
    REAL* dpi
    )
{
    API_ENTRY(GdipGetDpiY);
   CheckParameter(dpi);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *dpi = graphics->GetDpiY();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipTransformPoints(
    GpGraphics *graphics,
    GpCoordinateSpace destSpace,
    GpCoordinateSpace srcSpace,
    GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipTransformPoints);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->TransformPoints(points, count, srcSpace, destSpace);
}

GpStatus
WINGDIPAPI
GdipTransformPointsI(
    GpGraphics *graphics,
    GpCoordinateSpace destSpace,
    GpCoordinateSpace srcSpace,
    GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipTransformPointsI);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   INT i;
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = graphics->TransformPoints(pointsF, count, srcSpace, destSpace);

   for (i=0; i<count; i++)
   {
       points[i].X = GpRound(pointsF[i].X);
       points[i].Y = GpRound(pointsF[i].Y);
   }

   return status;
}

//------------------------------------------------------------------------
// GetNearestColor (for <= 8bpp surfaces)
//------------------------------------------------------------------------

GpStatus
WINGDIPAPI
GdipGetNearestColor(
    GpGraphics *graphics,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetNearestColor);
    CheckParameter(argb);
    CheckColorParameter(*argb);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    ARGB temp = graphics->GetNearestColor(*argb);
    *argb = temp;
    return Ok;
}

// defined in Engine\render\Halftone.cpp
extern HPALETTE WINGDIPAPI GdipCreateHalftonePalette();

GpStatus
WINGDIPAPI
GdipDrawLine(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2
    )
{
    API_ENTRY(GdipDrawLine);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);


    return graphics->DrawLine(pen, x1, y1, x2, y2);
}

GpStatus
WINGDIPAPI
GdipDrawLineI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x1,
    INT y1,
    INT x2,
    INT y2
    )
{
    API_ENTRY(GdipDrawLineI);
    return GdipDrawLine(graphics, pen, TOREAL(x1), TOREAL(y1), TOREAL(x2), TOREAL(y2));
}

GpStatus
WINGDIPAPI
GdipDrawLines(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawLines);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawLines(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawLinesI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawLinesI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawLines(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawArc(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawArc);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawArc(pen, x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawArcI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawArcI);
   return GdipDrawArc(graphics, pen, TOREAL(x), TOREAL(y),
                      TOREAL(width), TOREAL(height), startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawBezier(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2,
    REAL x3,
    REAL y3,
    REAL x4,
    REAL y4
    )
{
    API_ENTRY(GdipDrawBezier);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawBezier(pen, x1, y1, x2, y2, x3, y3, x4, y4);
}

GpStatus
WINGDIPAPI
GdipDrawBezierI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x1,
    INT y1,
    INT x2,
    INT y2,
    INT x3,
    INT y3,
    INT x4,
    INT y4
    )
{
    API_ENTRY(GdipDrawBezierI);
   return GdipDrawBezier(graphics, pen, TOREAL(x1), TOREAL(y1),
                         TOREAL(x2), TOREAL(y2), TOREAL(x3), TOREAL(y3),
                         TOREAL(x4), TOREAL(y4));
}

GpStatus
WINGDIPAPI
GdipDrawBeziers(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawBeziers);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawBeziers(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawBeziersI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawBeziersI);
    
    // Must check these parameters because we use them before calling into
    // GdipDrawBeziers
    
    CheckParameter(points && count > 0);
    
    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipDrawBeziers(graphics, pen, pointsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipDrawRectangle(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height)
{
    API_ENTRY(GdipDrawRectangle);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawRect(pen, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipDrawRectangleI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height)
{
    API_ENTRY(GdipDrawRectangleI);
   return GdipDrawRectangle(graphics, pen,
                            TOREAL(x), TOREAL(y),
                            TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipDrawRectangles(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpRectF *rects,
    INT count
    )
{
    API_ENTRY(GdipDrawRectangles);
   CheckParameter(rects && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawRects(pen, rects, count);
}

GpStatus
WINGDIPAPI
GdipDrawRectanglesI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpRect *rects,
    INT count
    )
{
    API_ENTRY(GdipDrawRectanglesI);
    CheckParameter(rects && count > 0);
   
   StackBuffer buffer;

   GpRectF *rectsF = (GpRectF*) buffer.GetBuffer(count*sizeof(GpRectF));

   if(!rectsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       rectsF[i].X = TOREAL(rects[i].X);
       rectsF[i].Y = TOREAL(rects[i].Y);
       rectsF[i].Width = TOREAL(rects[i].Width);
       rectsF[i].Height = TOREAL(rects[i].Height);
   }

   GpStatus status = GdipDrawRectangles(graphics, pen, rectsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawEllipse(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipDrawEllipse);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawEllipse(pen, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipDrawEllipseI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipDrawEllipseI);
   return GdipDrawEllipse(graphics, pen,
                          TOREAL(x), TOREAL(y),
                          TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipDrawPie(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawPie);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawPie(pen, x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawPieI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawPieI);
   return GdipDrawPie(graphics, pen,
                      TOREAL(x), TOREAL(y),
                      TOREAL(width), TOREAL(height),
                      startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawPolygon(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count)
{
    API_ENTRY(GdipDrawPolygon);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawPolygon(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawPolygonI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count)
{
    API_ENTRY(GdipDrawPolygonI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawPolygon(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawPath(
    GpGraphics *graphics,
    GpPen *pen,
    GpPath *path)
{
    API_ENTRY(GdipDrawPath);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(path);
    CheckObjectBusy(path);


    return graphics->DrawPath(pen, path);
}

GpStatus
WINGDIPAPI
GdipDrawCurve(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawCurve(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawCurveI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawCurveI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawCurve(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawCurve2(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawCurve(pen, points, count, tension, 0, count - 1);
}

GpStatus
WINGDIPAPI
GdipDrawCurve2I(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawCurve2(graphics, pen, pointsF, count, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawCurve3(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve3);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawCurve(pen, points, count, tension,
                              offset, numberOfSegments);
}

GpStatus
WINGDIPAPI
GdipDrawCurve3I(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve3I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawCurve3(graphics, pen, pointsF, count,
                                    offset, numberOfSegments, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurve(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count)
{
    API_ENTRY(GdipDrawClosedCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawClosedCurve(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurveI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count)
{
    API_ENTRY(GdipDrawClosedCurveI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawClosedCurve(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurve2(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension)
{
    API_ENTRY(GdipDrawClosedCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawClosedCurve(pen, points, count, tension);
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurve2I(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension)
{
    API_ENTRY(GdipDrawClosedCurve2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawClosedCurve2(graphics, pen, pointsF, count, tension);

   return status;
}

GpStatus WINGDIPAPI
GdipGraphicsClear(
    GpGraphics *graphics,
    ARGB color)
{
    API_ENTRY(GdipGraphicsClear);
    CheckColorParameter(color);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->Clear(GpColor(color));
}

GpStatus
WINGDIPAPI
GdipFillRectangle(
    GpGraphics *graphics,
    GpBrush *fill,
    REAL x,
    REAL y,
    REAL width,
    REAL height)
{
    API_ENTRY(GdipFillRectangle);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillRect(fill, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipFillRectangleI(
    GpGraphics *graphics,
    GpBrush *fill,
    INT x,
    INT y,
    INT width,
    INT height)
{
    API_ENTRY(GdipFillRectangleI);
   return GdipFillRectangle(graphics, fill, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipFillRectangles(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpRectF *rects,
    INT count)
{
    API_ENTRY(GdipFillRectangles);
   CheckParameter(rects && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillRects(fill, rects, count);
}

GpStatus
WINGDIPAPI
GdipFillRectanglesI(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpRect *rects,
    INT count)
{
    API_ENTRY(GdipFillRectanglesI);
    StackBuffer buffer;

    GpRectF *rectsF = (GpRectF*) buffer.GetBuffer(count*sizeof(GpRectF));

    if(!rectsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        rectsF[i].X = TOREAL(rects[i].X);
        rectsF[i].Y = TOREAL(rects[i].Y);
        rectsF[i].Width = TOREAL(rects[i].Width);
        rectsF[i].Height = TOREAL(rects[i].Height);
    }

    GpStatus status = GdipFillRectangles(graphics, fill, rectsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipFillPolygon(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillPolygon);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillPolygon(fill, points, count, fillMode);
}

GpStatus
WINGDIPAPI
GdipFillPolygonI(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillPolygonI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillPolygon(graphics, fill, pointsF, count, fillMode);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillPolygon2(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipFillPolygon2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillPolygon(fill, points, count);
}

GpStatus
WINGDIPAPI
GdipFillPolygon2I(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipFillPolygon2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillPolygon2(graphics, fill, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillEllipse(
    GpGraphics *graphics,
    GpBrush *fill,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipFillEllipse);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillEllipse(fill, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipFillEllipseI(
    GpGraphics *graphics,
    GpBrush *fill,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipFillEllipseI);
   return GdipFillEllipse(graphics, fill, TOREAL(x), TOREAL(y),
                          TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipFillPie(
    GpGraphics *graphics,
    GpBrush *fill,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipFillPie);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillPie(fill, x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipFillPieI(
    GpGraphics *graphics,
    GpBrush *fill,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipFillPieI);
   return GdipFillPie(graphics, fill, TOREAL(x), TOREAL(y),
                      TOREAL(width), TOREAL(height), startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipFillPath(
    GpGraphics *graphics,
    GpBrush *fill,
    GpPath *path
    )
{
    API_ENTRY(GdipFillPath);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);
   CheckParameterValid(path);
   CheckObjectBusy(path);


   return graphics->FillPath(fill, path);
}

GpStatus
WINGDIPAPI
GdipFillClosedCurve(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipFillClosedCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillClosedCurve(fill, points, count);
}

GpStatus
WINGDIPAPI
GdipFillClosedCurveI(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipFillClosedCurveI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillClosedCurve(graphics, fill, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillClosedCurve2(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillClosedCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillClosedCurve(fill, points, count, tension, fillMode);
}


GpStatus
WINGDIPAPI
GdipFillClosedCurve2I(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillClosedCurve2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillClosedCurve2(graphics, fill, pointsF, count, tension, fillMode);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillRegion(
    GpGraphics *graphics,
    GpBrush *fill,
    GpRegion *region
    )
{
    API_ENTRY(GdipFillRegion);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);
   CheckParameterValid(region);
   CheckObjectBusy(region);


   return graphics->FillRegion(fill, region);
}

GpStatus
WINGDIPAPI
GdipDrawString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                      length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush        *brush
)
{
    API_ENTRY(GdipDrawString);
    CheckParameter(string && layoutRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    if (EmptyString(string, length))
    {
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);
    CheckOptionalParameterValid(stringFormat);

    return graphics->DrawString(
        string,
        length,
        font,
        layoutRect,
        stringFormat,
        brush);
}

GpStatus
WINGDIPAPI
GdipMeasureString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF                    *boundingBox,
    INT                      *codepointsFitted,   // Optional parameter
    INT                      *linesFilled         // Optional parameter
)
{
    API_ENTRY(GdipMeasureString);
    CheckParameter(string && layoutRect && boundingBox);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    if (EmptyString(string, length))
    {
        SetEmptyRectF(boundingBox);
        if (codepointsFitted)
            *codepointsFitted = 0;
        if (linesFilled)
            *linesFilled = 0;
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);
    CheckOptionalParameterValid(stringFormat);

    return graphics->MeasureString(
        string,
        length,
        font,
        layoutRect,
        stringFormat,
        boundingBox,
        codepointsFitted,
        linesFilled
    );
}

GpStatus
WINGDIPAPI
GdipMeasureCharacterRanges(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          &layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    INT                       regionCount,
    GpRegion                **regions
)
{
    API_ENTRY(GdipMeasureCharacterRanges);
    CheckParameter(string && (&layoutRect));
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(font);
    CheckOptionalParameterValid(stringFormat);
    CheckParameter(regions);

    if (EmptyString(string, length))
    {
        return InvalidParameter;
    }


    GlobalTextLock lock;

    GpStatus status = graphics->MeasureCharacterRanges(
        string,
        length,
        font,
        layoutRect,
        stringFormat,
        regionCount,
        regions
    );

    return status;
}


GpStatus
WINGDIPAPI
GdipDrawDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST GpBrush *brush,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix
)
{
    API_ENTRY(GdipDrawDriverString);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    CheckParameter(text && positions);

    if (length == -1 && !(flags & DriverStringOptionsCmapLookup))
    {
        return InvalidParameter;
    }
    if (EmptyString(text, length))
    {
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);

    return graphics->DrawDriverString(
        text,
        length,
        font,
        brush,
        positions,
        flags,
        matrix
    );
}

GpStatus
WINGDIPAPI
GdipMeasureDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix,
    RectF *boundingBox
)
{
    API_ENTRY(GdipMeasureDriverString);
    GpStatus status;
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    CheckParameter(text && positions && boundingBox);

    if (length == -1 && !(flags & DriverStringOptionsCmapLookup))
    {
        return InvalidParameter;
    }

    if (EmptyString(text, length))
    {
        SetEmptyRectF(boundingBox);
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);

    return graphics->MeasureDriverString(
        text,
        length,
        font,
        positions,
        flags,
        matrix,
        boundingBox
    );
}

GpStatus
WINGDIPAPI
GdipGetFamilyName(
    GDIPCONST GpFontFamily *family,
    WCHAR                   name[LF_FACESIZE],
    LANGID                  language
)
{
    API_ENTRY(GdipGetFamilyName);

    GlobalTextLock lock;

    CheckParameterValid(family);

    return family->GetFamilyName(name, language);
}

/// end font/text stuff - move to end



GpStatus
WINGDIPAPI
GdipDrawImage(
    GpGraphics *graphics,
    GpImage *image,
    REAL x,
    REAL y
    )
{
    API_ENTRY(GdipDrawImage);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);


   return graphics->DrawImage(image, x, y);
}


GpStatus
WINGDIPAPI
GdipDrawImageI(
    GpGraphics *graphics,
    GpImage *image,
    INT x,
    INT y
    )
{
    API_ENTRY(GdipDrawImageI);
   return GdipDrawImage(graphics, image, TOREAL(x), TOREAL(y));
}

GpStatus
WINGDIPAPI
GdipDrawImageRect(
    GpGraphics *graphics,
    GpImage *image,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipDrawImageRect);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);


   return graphics->DrawImage(image, x, y, width, height);
}


GpStatus
WINGDIPAPI
GdipDrawImageRectI(
    GpGraphics *graphics,
    GpImage *image,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipDrawImageRectI);
   return GdipDrawImageRect(graphics, image, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipDrawImagePoints(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawImagePoints);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);


   return graphics->DrawImage(image, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointsI(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawImagePointsI);
    CheckParameter(points && count > 0);

    StackBuffer buffer;

    GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    } 

    GpStatus status = GdipDrawImagePoints(graphics, image, pointsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipDrawImagePointRect(
    GpGraphics *graphics,
    GpImage *image,
    REAL x,
    REAL y,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    GpPageUnit srcUnit
    )
{
    API_ENTRY(GdipDrawImagePointRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    
    // This additional check is required because we don't support the other 
    // source units in drawimage yet. RAID 311474
    
    if(UnitPixel != srcUnit)
    {
        return NotImplemented;
    }

    GpRectF srcRect(srcx, srcy, srcwidth, srcheight);


    return graphics->DrawImage(image, x, y, srcRect, srcUnit);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointRectI(
    GpGraphics *graphics,
    GpImage *image,
    INT x,
    INT y,
    INT srcx,
    INT srcy,
    INT srcwidth,
    INT srcheight,
    GpPageUnit srcUnit
    )
{
    API_ENTRY(GdipDrawImagePointRectI);
   return GdipDrawImagePointRect(graphics, image, TOREAL(x), TOREAL(y), TOREAL(srcx),
                                 TOREAL(srcy), TOREAL(srcwidth), TOREAL(srcheight),
                                 srcUnit);
}

GpStatus
WINGDIPAPI
GdipDrawImageRectRect(
    GpGraphics *graphics,
    GpImage *image,
    REAL dstx,
    REAL dsty,
    REAL dstwidth,
    REAL dstheight,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImageRectRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    
    // This additional check is required because we don't support the other 
    // source units in drawimage yet. RAID 311474
    
    if(UnitPixel != srcUnit)
    {
        return NotImplemented;
    }
    
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);

    GpRectF srcrect(srcx, srcy, srcwidth, srcheight);
    GpRectF destrect(dstx, dsty, dstwidth, dstheight);


    return graphics->DrawImage(image, destrect, srcrect, srcUnit,
                               imageAttributes, callback, callbackData);
}

GpStatus
WINGDIPAPI
GdipDrawImageRectRectI(
    GpGraphics *graphics,
    GpImage *image,
    INT dstx,
    INT dsty,
    INT dstwidth,
    INT dstheight,
    INT srcx,
    INT srcy,
    INT srcwidth,
    INT srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImageRectRectI);
   return GdipDrawImageRectRect(graphics, image, TOREAL(dstx), TOREAL(dsty),
                                TOREAL(dstwidth), TOREAL(dstheight),
                                TOREAL(srcx), TOREAL(srcy), TOREAL(srcwidth),
                                TOREAL(srcheight), srcUnit,
                                imageAttributes, callback, callbackData);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointsRect(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPointF *points,
    INT count,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImagePointsRect);
    CheckParameter(points && count > 0);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    
    // This additional check is required because we don't support the other 
    // source units in drawimage yet. RAID 311474
    
    if(UnitPixel != srcUnit)
    {
        return NotImplemented;
    }
    
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);

    GpRectF srcrect(srcx, srcy, srcwidth, srcheight);


    return graphics->DrawImage(image, points, count, srcrect, srcUnit,
                               imageAttributes, callback, callbackData);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointsRectI(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPoint *points,
    INT count,
    INT srcx,
    INT srcy,
    INT srcwidth,
    INT srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImagePointsRectI);
    CheckParameter(points && count > 0);
   
    StackBuffer buffer;

    GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipDrawImagePointsRect(
        graphics, 
        image, 
        pointsF, 
        count,
        TOREAL(srcx), 
        TOREAL(srcy), 
        TOREAL(srcwidth),
        TOREAL(srcheight), 
        srcUnit,
        imageAttributes, 
        callback, 
        callbackData
    );

    return status;
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPoint);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoint,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPointI);
    GpPointF    destPointF(TOREAL(destPoint.X), TOREAL(destPoint.Y));

    return GdipEnumerateMetafileDestPoint(
                graphics,
                metafile,
                destPointF,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestRect);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destRect,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestRectI);
    GpRectF     destRectF(TOREAL(destRect.X), TOREAL(destRect.Y),
                          TOREAL(destRect.Width), TOREAL(destRect.Height));

    return GdipEnumerateMetafileDestRect(
                graphics,
                metafile,
                destRectF,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPoints);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoints,
                        count,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *      metafile,
    GDIPCONST Point *           destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPointsI);
    CheckParameter(destPoints && (count > 0));

    StackBuffer buffer;

    GpPointF *destPointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!destPointsF) return OutOfMemory;

    for (INT i = 0; i < count; i++)
    {
        destPointsF[i].X = TOREAL(destPoints[i].X);
        destPointsF[i].Y = TOREAL(destPoints[i].Y);
    }

    return GdipEnumerateMetafileDestPoints(
                graphics,
                metafile,
                destPointsF,
                count,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPoint);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoint,
                        srcRect,
                        srcUnit,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPointI);
    GpPointF    destPointF(TOREAL(destPoint.X), TOREAL(destPoint.Y));
    GpRectF     srcRectF(TOREAL(srcRect.X), TOREAL(srcRect.Y),
                         TOREAL(srcRect.Width), TOREAL(srcRect.Height));

    return GdipEnumerateMetafileSrcRectDestPoint(
                graphics,
                metafile,
                destPointF,
                srcRectF,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestRect);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destRect,
                        srcRect,
                        srcUnit,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestRectI);
    GpRectF     destRectF(TOREAL(destRect.X), TOREAL(destRect.Y),
                          TOREAL(destRect.Width), TOREAL(destRect.Height));
    GpRectF     srcRectF(TOREAL(srcRect.X), TOREAL(srcRect.Y),
                         TOREAL(srcRect.Width), TOREAL(srcRect.Height));

    return GdipEnumerateMetafileSrcRectDestRect(
                graphics,
                metafile,
                destRectF,
                srcRectF,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPoints);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoints,
                        count,
                        srcRect,
                        srcUnit,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPointsI);
    CheckParameter(destPoints && (count > 0));

    GpRectF     srcRectF(TOREAL(srcRect.X), TOREAL(srcRect.Y),
                         TOREAL(srcRect.Width), TOREAL(srcRect.Height));

    StackBuffer buffer;

    GpPointF *destPointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!destPointsF) return OutOfMemory;

    for (INT i = 0; i < count; i++)
    {
        destPointsF[i].X = TOREAL(destPoints[i].X);
        destPointsF[i].Y = TOREAL(destPoints[i].Y);
    }

    return GdipEnumerateMetafileSrcRectDestPoints(
                graphics,
                metafile,
                destPointsF,
                count,
                srcRectF,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus
WINGDIPAPI
GdipPlayMetafileRecord(
    GDIPCONST GpMetafile *  metafile,
    EmfPlusRecordType       recordType,
    UINT                    flags,
    UINT                    dataSize,
    GDIPCONST BYTE *        data
    )
{
    API_ENTRY(GdipPlayMetafileRecord);
    CheckParameterValid(metafile);
    CheckParameter(recordType);

    // The metafile must be already locked by the enumerator
    GpLock lockMetafile (metafile->GetObjectLock());
    if (lockMetafile.IsValid())
    {
        return InvalidParameter;
    }

    // Only the current thread can play back records from this enumeration
    if (GetCurrentThreadId() != metafile->GetThreadId())
    {
        return ObjectBusy;
    }


    return metafile->PlayRecord(recordType, flags, dataSize, data);
}

GpStatus
WINGDIPAPI
GdipSetClipGraphics(
    GpGraphics *    graphics,
    GpGraphics *    srcgraphics,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipGraphics);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(srcgraphics);
    CheckObjectBusy(srcgraphics);
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(srcgraphics, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipRect(
    GpGraphics *    graphics,
    REAL            x,
    REAL            y,
    REAL            width,
    REAL            height,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(CombineModeIsValid(combineMode));

    GpRectF rect(x, y, width, height);


    return graphics->SetClip(rect, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipRectI(
    GpGraphics *    graphics,
    INT             x,
    INT             y,
    INT             width,
    INT             height,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipRectI);
    return GdipSetClipRect(graphics, TOREAL(x), TOREAL(y),
                           TOREAL(width), TOREAL(height), combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipPath(
    GpGraphics *    graphics,
    GpPath *        path,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipPath);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(path, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipRegion(
    GpGraphics *    graphics,
    GpRegion *      region,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipRegion);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(region, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipHrgn(
    GpGraphics *    graphics,
    HRGN            hRgn,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipHrgn);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(hRgn && (GetObjectTypeInternal(hRgn) == OBJ_REGION));
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(hRgn, combineMode);
}

GpStatus
WINGDIPAPI
GdipResetClip(
    GpGraphics *graphics
    )
{
    API_ENTRY(GdipResetClip);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->ResetClip();
}

GpStatus
WINGDIPAPI
GdipTranslateClip(
    GpGraphics *graphics,
    REAL dx,
    REAL dy
    )
{
    API_ENTRY(GdipTranslateClip);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    return graphics->OffsetClip(dx, dy);
}

GpStatus
WINGDIPAPI
GdipTranslateClipI(
    GpGraphics *graphics,
    INT dx,
    INT dy
    )
{
    API_ENTRY(GdipTranslateClipI);
    return GdipTranslateClip(graphics, TOREAL(dx), TOREAL(dy));
}

GpStatus
WINGDIPAPI
GdipGetClip(
    GpGraphics *graphics,
    GpRegion *region
    )
{
    API_ENTRY(GdipGetClip);
    CheckParameter(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->GetClip(region);
}

GpStatus
WINGDIPAPI
GdipGetClipBounds(
    GpGraphics *graphics,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetClipBounds);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetClipBounds(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetClipBoundsI(
    GpGraphics *graphics,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetClipBoundsI);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    RectF rectf;

    graphics->GetClipBounds(rectf);

    rect->X = GpRound(rectf.X);
    rect->Y = GpRound(rectf.Y);
    rect->Width = GpRound(rectf.Width);
    rect->Height = GpRound(rectf.Height);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsClipEmpty(
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsClipEmpty);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *result = graphics->IsClipEmpty();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetVisibleClipBounds(
    GpGraphics *graphics,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetVisibleClipBounds);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetVisibleClipBounds(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetVisibleClipBoundsI(
    GpGraphics *graphics,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetVisibleClipBoundsI);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    RectF rectf;

    graphics->GetVisibleClipBounds(rectf);

    rect->X = GpRound(rectf.X);
    rect->Y = GpRound(rectf.Y);
    rect->Width = GpRound(rectf.Width);
    rect->Height = GpRound(rectf.Height);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisibleClipEmpty(
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleClipEmpty);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *result = graphics->IsVisibleClipEmpty();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePoint(
    GpGraphics *graphics,
    REAL x,
    REAL y,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePoint);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpPointF pt(x,y);


    *result = graphics->IsVisible(pt);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePointI(
    GpGraphics *graphics,
    INT x,
    INT y,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePointI);
    return GdipIsVisiblePoint(graphics, TOREAL(x), TOREAL(y), result);
}

GpStatus
WINGDIPAPI
GdipIsVisibleRect(
    GpGraphics *graphics,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRect);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpRectF rect(x, y, width, height);


    *result = graphics->IsVisible(rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisibleRectI(
    GpGraphics *graphics,
    INT x,
    INT y,
    INT width,
    INT height,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRectI);
    return GdipIsVisibleRect(graphics, TOREAL(x), TOREAL(y),
                             TOREAL(width), TOREAL(height), result);
}

GpStatus
WINGDIPAPI
GdipSaveGraphics(
    GpGraphics *graphics,
    GraphicsState *state
    )
{
    API_ENTRY(GdipSaveGraphics);
    CheckParameter(state);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *state = (GraphicsState)graphics->Save();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipRestoreGraphics(
    GpGraphics *graphics,
    GraphicsState state
    )
{
    API_ENTRY(GdipRestoreGraphics);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   graphics->Restore((INT)state);

   return Ok;
}


GpStatus
WINGDIPAPI
GdipBeginContainer(
    GpGraphics *graphics,
    GDIPCONST GpRectF *dstrect,
    GDIPCONST GpRectF *srcrect,
    GpPageUnit unit,
    GraphicsContainer *state
    )
{
    API_ENTRY(GdipBeginContainer);
    CheckParameter(state && dstrect && srcrect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(SrcUnitIsValid((Unit)unit));


    *state = (GraphicsContainer)graphics->BeginContainer(*dstrect, *srcrect, unit);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipBeginContainer2(
    GpGraphics *graphics,
    GraphicsContainer *state
    )
{
    API_ENTRY(GdipBeginContainer2);
   CheckParameter(state);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);


   *state = (GraphicsContainer)graphics->BeginContainer();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipBeginContainerI(
    GpGraphics *graphics,
    GDIPCONST GpRect *dstrect,
    GDIPCONST GpRect *srcrect,
    GpPageUnit unit,
    GraphicsContainer *state
    )
{
    API_ENTRY(GdipBeginContainerI);
   GpRectF dstrectF(TOREAL(dstrect->X), TOREAL(dstrect->Y), TOREAL(dstrect->Width), TOREAL(dstrect->Height));
   GpRectF srcrectF(TOREAL(srcrect->X), TOREAL(srcrect->Y), TOREAL(srcrect->Width), TOREAL(srcrect->Height));

   return GdipBeginContainer(graphics, &dstrectF, &srcrectF, unit, state);
}

GpStatus
WINGDIPAPI
GdipEndContainer(
    GpGraphics *graphics,
    GraphicsContainer state
    )
{
    API_ENTRY(GdipEndContainer);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   graphics->EndContainer((INT)state);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromWmf(
    HMETAFILE           hWmf,
    GDIPCONST WmfPlaceableFileHeader *     wmfPlaceableFileHeader,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromWmf);
    CheckParameter(hWmf && wmfPlaceableFileHeader);


    return GetMetafileHeader(hWmf, wmfPlaceableFileHeader, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromEmf(
    HENHMETAFILE        hEmf,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromEmf);
    CheckParameter(hEmf);


    return GetMetafileHeader(hEmf, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromFile(
    GDIPCONST WCHAR*        filename,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromFile);
    CheckParameter(filename);


    return GetMetafileHeader(filename, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromStream(
    IStream *           stream,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromStream);
    CheckParameter(stream);


    return GetMetafileHeader(stream, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromMetafile(
    GpMetafile *        metafile,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromMetafile);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);


    metafile->GetHeader(*header);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetHemfFromMetafile(
    GpMetafile *        metafile,
    HENHMETAFILE *      hEmf
    )
{
    API_ENTRY(GdipGetHemfFromMetafile);
    CheckParameter(hEmf);

    *hEmf = NULL;   // init to NULL in case the metafile is busy or invalid (Windows bug 216941)

    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);

    return metafile->GetHemf(hEmf);
}

GpStatus
WINGDIPAPI
GdipCreateStreamOnFile(
    GDIPCONST WCHAR *   filename,
    UINT            access,     // GENERIC_READ and/or GENERIC_WRITE
    IStream **      stream
    )
{
    API_ENTRY(GdipCreateStreamOnFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(filename && stream);
    CheckParameter((access & (GENERIC_READ | GENERIC_WRITE)) != 0);

    if ((*stream = CreateStreamOnFile(filename, access)) != NULL)
    {
        return Ok;
    }
    return GenericError;
}
GpStatus
WINGDIPAPI
GdipCreateMetafileFromWmf(
    HMETAFILE       hWmf,
    BOOL            deleteWmf,
    GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader,  // can be NULL
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromWmf);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(hWmf && metafile);


    *metafile = new GpMetafile(hWmf, wmfPlaceableFileHeader, deleteWmf);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromEmf(
    HENHMETAFILE    hEmf,
    BOOL            deleteEmf,
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromEmf);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(hEmf && metafile);


    *metafile = new GpMetafile(hEmf, deleteEmf);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromFile(
    GDIPCONST WCHAR*    filename,
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(filename && metafile);


    *metafile = new GpMetafile(filename);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromWmfFile(
    GDIPCONST WCHAR*            filename,
    GDIPCONST WmfPlaceableFileHeader *   wmfPlaceableFileHeader,  // can be NULL
    GpMetafile **               metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromWmfFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(filename && metafile);


    *metafile = new GpMetafile(filename, wmfPlaceableFileHeader);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromStream(
    IStream *       stream,
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromStream);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(stream && metafile);


    *metafile = new GpMetafile(stream);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafile);
    CheckParameter(referenceHdc && metafile);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));


    *metafile = new GpMetafile(referenceHdc, type, frameRect, frameUnit, description);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafileI(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *      frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileI);
    CheckParameter(referenceHdc && frameRect);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));

    GpRectF frameRectF(TOREAL(frameRect->X),
                       TOREAL(frameRect->Y),
                       TOREAL(frameRect->Width),
                       TOREAL(frameRect->Height));

    return GdipRecordMetafile(referenceHdc,
                              type,
                              &frameRectF,
                              frameUnit,
                              description,
                              metafile);
}

GpStatus
WINGDIPAPI
GdipRecordMetafileFileName(
    GDIPCONST WCHAR*        fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileFileName);
    CheckParameter(fileName && referenceHdc && metafile);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));


    *metafile = new GpMetafile(fileName, referenceHdc, type, frameRect, frameUnit, description);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafileFileNameI(
    GDIPCONST WCHAR*        fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *      frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileFileNameI);
    CheckParameter(referenceHdc && frameRect);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));

    GpRectF frameRectF(TOREAL(frameRect->X),
                       TOREAL(frameRect->Y),
                       TOREAL(frameRect->Width),
                       TOREAL(frameRect->Height));

    return GdipRecordMetafileFileName(fileName,
                                      referenceHdc,
                                      type,
                                      &frameRectF,
                                      frameUnit,
                                      description,
                                      metafile);
}


GpStatus
WINGDIPAPI
GdipRecordMetafileStream(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileStream);
    CheckParameter(stream && referenceHdc && metafile);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));


    *metafile = new GpMetafile(stream, referenceHdc, type, frameRect, frameUnit, description);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafileStreamI(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *      frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileStreamI);
    CheckParameter(referenceHdc && frameRect);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));

    GpRectF frameRectF(TOREAL(frameRect->X),
                       TOREAL(frameRect->Y),
                       TOREAL(frameRect->Width),
                       TOREAL(frameRect->Height));

    return GdipRecordMetafileStream(stream,
                                    referenceHdc,
                                    type,
                                    &frameRectF,
                                    frameUnit,
                                    description,
                                    metafile);
}

GpStatus 
WINGDIPAPI
GdipSetMetafileDownLevelRasterizationLimit(
    GpMetafile *            metafile,
    UINT                    metafileRasterizationLimitDpi
    )
{
    API_ENTRY(GdipSetMetafileDownLevelRasterizationLimit);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);

    // Since the rasterization limit is actually set in the graphics,
    // we check if the graphics is busy too.
    GpGraphics *    g = metafile->PrivateAPIForGettingMetafileGraphicsContext();
    CheckOptionalObjectBusy(g);
    
    return metafile->SetDownLevelRasterizationLimit(metafileRasterizationLimitDpi);
}

GpStatus WINGDIPAPI
GdipGetMetafileDownLevelRasterizationLimit(
    GDIPCONST GpMetafile *  metafile,
    UINT *                  metafileRasterizationLimitDpi
    )
{
    API_ENTRY(GdipGetMetafileDownLevelRasterizationLimit);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(metafileRasterizationLimitDpi);

    // Since the rasterization limit is actually set in the graphics,
    // we check if the graphics is busy too.
    GpGraphics *    g = metafile->PrivateAPIForGettingMetafileGraphicsContext();
    CheckOptionalObjectBusy(g);


    return metafile->GetDownLevelRasterizationLimit(metafileRasterizationLimitDpi);
}

// Codec management APIs

#define COPYCODECINFOSTR(_f)            \
        dst->_f = (GDIPCONST WCHAR*) buf;   \
        size = SizeofWSTR(cur->_f);     \
        memcpy(buf, cur->_f, size);     \
        buf += size

/**************************************************************************\
*
* Function Description:
*
*   Returns, via the OUT arguments, the number of installed decoders
*   and how much memory is needed to store the ImageCodecInfo for all the
*   decoders.  size tells how much memory the caller should allocate for
*   the call to GdipGetImageDecoders.
*
* Arguments:
*   numDecoders -- number of installed decoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the decoders
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageDecodersSize(OUT UINT *numDecoders, OUT UINT *size)
{
    API_ENTRY(GdipGetImageDecodersSize);
    // Acquire global critical section

    ImagingCritSec critsec;

    ReloadCachedCodecInfo();

    CachedCodecInfo* cur;

    // Count the number of selected codecs
    // and figure the amount of memory we need to allocate

    *numDecoders = 0;
    *size = 0;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if (cur->Flags & IMGCODEC_DECODER)
        {
            (*numDecoders)++;
            *size += cur->structSize;
        }
    }
    // Global critical section is released in critsec destructor
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Given the number of decoders (numDecoders), the size of
*   the incoming buffer (size), and a pointer to the buffer (decoders),
*   fill the buffer with the decoder information.
*
* Arguments:
*   numDecoders -- number of installed decoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the decoders
*   decoders    -- pointer to a buffer to fill in the ImageCodecInfo
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageDecoders(UINT numDecoders,
                     UINT size,
                     ImageCodecInfo *decoders)
{
    API_ENTRY(GdipGetImageDecoders);
    GpStatus rv;
    HRESULT hResult;
    BYTE *buf;
    ImageCodecInfo* dst;
    CachedCodecInfo* cur;
    UINT numDecodersCheck = 0;
    UINT sizeCheck = 0;

    // Acquire global critical section

    ImagingCritSec critsec;

    if (decoders == NULL)
    {
        rv = GenericError;
        goto done;
    }

    GdipGetImageDecodersSize(&numDecodersCheck, &sizeCheck);
    // Check that the number of codecs (and size) now equals the number
    // that the user thinks there is.
    if ((numDecoders != numDecodersCheck) || (size != sizeCheck))
    {
        rv = GenericError;
        goto done;
    }
    // ASSERT: The result placed in sizeCheck is not used throughout
    // the rest of this function.

    buf = (BYTE *) decoders;

    // Copy codec information to the output buffer

    dst = decoders;
    buf += numDecoders * sizeof(ImageCodecInfo);

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if ((cur->Flags & IMGCODEC_DECODER) == 0)
            continue;

        // First do a simple memory copy

        *dst = *static_cast<ImageCodecInfo *>(cur);

        // Then modify the pointer fields

        COPYCODECINFOSTR(CodecName);
        COPYCODECINFOSTR(FormatDescription);
        COPYCODECINFOSTR(FilenameExtension);
        COPYCODECINFOSTR(MimeType);

        if (size = cur->SigCount*cur->SigSize)
        {
            dst->SigPattern = buf;
            memcpy(buf, cur->SigPattern, size);
            buf += size;

            dst->SigMask = buf;
            memcpy(buf, cur->SigMask, size);
            buf += size;
        }

        dst++;
    }

    rv = Ok;

    // Global critical section is released in critsec destructor

done:
    return rv;
}


/**************************************************************************\
*
* Function Description:
*
*   Returns, via the OUT arguments, the number of installed encoders
*   and how much memory is needed to store the ImageCodecInfo for all the
*   encoders.  size tells how much memory the caller should allocate for
*   the call to GdipGetImageEncoders.
*
* Arguments:
*   numDecoders -- number of installed encoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the encoders
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageEncodersSize(OUT UINT *numEncoders, OUT UINT *size)
{
    API_ENTRY(GdipGetImageEncodersSize);
    // Acquire global critical section

    ImagingCritSec critsec;

    ReloadCachedCodecInfo();

    CachedCodecInfo* cur;

    // Count the number of selected codecs
    // and figure the amount of memory we need to allocate

    *numEncoders = 0;
    *size = 0;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if (cur->Flags & IMGCODEC_ENCODER)
        {
            (*numEncoders)++;
            *size += cur->structSize;
        }
    }
    // Global critical section is released in critsec destructor
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Given the number of encoders (numEncoders), the size of
*   the incoming buffer (size), and a pointer to the buffer (encoders),
*   fill the buffer with the encoder information.
*
* Arguments:
*   numEncoders -- number of installed encoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the encoders
*   encoders    -- pointer to a buffer to fill in the ImageCodecInfo
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageEncoders(UINT numEncoders,
                     UINT size,
                     ImageCodecInfo *encoders)
{
    API_ENTRY(GdipGetImageEncoders);
    GpStatus rv;
    HRESULT hResult;
    BYTE *buf;
    ImageCodecInfo* dst;
    CachedCodecInfo* cur;
    UINT numEncodersCheck = 0;
    UINT sizeCheck = 0;

    // Acquire global critical section

    ImagingCritSec critsec;

    if (encoders == NULL)
    {
        rv = GenericError;
        goto done;
    }

    GdipGetImageEncodersSize(&numEncodersCheck, &sizeCheck);

    // Check that the number of codecs (and size) now equals the number
    // that the user thinks there is.
    if ((numEncoders != numEncodersCheck) || (size != sizeCheck))
    {
        rv = GenericError;
        goto done;
    }
    // ASSERT: The result placed in sizeCheck is not used throughout
    // the rest of this function.

    buf = (BYTE *) encoders;

    // Copy codec information to the output buffer

    dst = encoders;
    buf += numEncoders * sizeof(ImageCodecInfo);

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if ((cur->Flags & IMGCODEC_ENCODER) == 0)
            continue;

        // First do a simple memory copy

        *dst = *static_cast<ImageCodecInfo*>(cur);

        // Then modify the pointer fields

        COPYCODECINFOSTR(CodecName);
        COPYCODECINFOSTR(FormatDescription);
        COPYCODECINFOSTR(FilenameExtension);
        COPYCODECINFOSTR(MimeType);

        if (size = cur->SigCount*cur->SigSize)
        {
            dst->SigPattern = buf;
            memcpy(buf, cur->SigPattern, size);
            buf += size;

            dst->SigMask = buf;
            memcpy(buf, cur->SigMask, size);
            buf += size;
        }

        dst++;
    }

    rv = Ok;

    // Global critical section is released in critsec destructor

done:
    return rv;
}

void*
WINGDIPAPI
GdipAlloc(
    size_t size
)
{
    API_ENTRY(GdipAlloc);
    CheckGdiplusInitialized_ReturnNULL;

    #if DBG
    return GpMallocAPI(size);
    #else
    return GpMalloc(size);
    #endif
}

void
WINGDIPAPI
GdipFree(
    void* ptr
)
{
    API_ENTRY(GdipFree);
    GpFree(ptr);
}

/// Out of place font/text stuff

GpStatus
WINGDIPAPI
GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
                             GpFontCollection *fontCollection,
                             GpFontFamily **fontFamily)
{
    API_ENTRY(GdipCreateFontFamilyFromName);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(name && fontFamily);

    GlobalTextLock lock;

    CheckOptionalParameterValid(fontCollection);

    return GpFontFamily::CreateFontFamilyFromName(
                            name,
                            fontCollection,
                            fontFamily);
}


GpStatus
WINGDIPAPI
GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily)
{
    API_ENTRY(GdipGetGenericFontFamilySansSerif);
    CheckParameter(nativeFamily);
    return GpFontFamily::GetGenericFontFamilySansSerif(nativeFamily);
}

GpStatus
WINGDIPAPI
GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily)
{
    API_ENTRY(GdipGetGenericFontFamilySerif);
    CheckParameter(nativeFamily);
    return GpFontFamily::GetGenericFontFamilySerif(nativeFamily);
}

GpStatus
WINGDIPAPI
GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily)
{
    API_ENTRY(GdipGetGenericFontFamilyMonospace);
    CheckParameter(nativeFamily);
    return GpFontFamily::GetGenericFontFamilyMonospace(nativeFamily);
}


GpStatus
WINGDIPAPI
GdipCreateFont(
    GDIPCONST GpFontFamily *fontFamily,
    REAL                size,
    INT                 style,
    Unit                unit,
    GpFont            **font
)
{
    API_ENTRY(GdipCreateFont);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = Ok;
    // check parameters
    CheckParameter(font);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    if (size <= 0 ||
//        (style < StyleRegular || style > StyleStrikeout) ||
        (unit < UnitWorld || unit > UnitMillimeter || unit == UnitDisplay))
    {
        return InvalidParameter;
    }

    GlobalTextLock lock;

    CheckParameterValid(fontFamily);

    if (*font = new GpFont(size, fontFamily, style, unit)) {
        if (!(*font)->GetFace()) {
           delete *font;
           *font = NULL;
           status = FontStyleNotFound;
        }
     }
    else
    {
        status = OutOfMemory;
    }

    return status;
}


GpStatus
WINGDIPAPI
GdipDeleteFontFamily(GpFontFamily *gpFontFamily)
{
    API_ENTRY(GdipDeleteFontFamily);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(gpFontFamily);

    GlobalTextLock lock;

    gpFontFamily->DecFontFamilyRef();

    if (gpFontFamily->IsFileLoaded(FALSE))
    {
        // Try to delete the font file (RemoveFontFile) for each Face[].
        // This also will have the side effect of attempting to delete
        // any deletable GpFontFamily objects.
        UINT iFace = 0;
        UINT iLastFace = 0;
        GpFontFace *face = NULL;

        // Compute the index of the last non-NULL Face[] pointer.
        for (iFace = 0; iFace < NumFontFaces; iFace++)
        {
            face = gpFontFamily->GetFaceAbsolute(iFace);
            if (face != NULL)
            {
                iLastFace = iFace;
            }
        }

        for (iFace = 0; iFace <= iLastFace; iFace++)
        {
            face = gpFontFamily->GetFaceAbsolute(iFace);
            // Try to remove the font file if RemoveFontFile has
            // already been called on it.
            // Note that if iFace == iLastFace, then the call to
            // RemoveFontFile below might delete this gpFontFamily object,
            // which means the Face[] pointers would be garbage.  This is
            // why the for loop index goes up to iLastFace.
            if (face && face->pff->bRemoved)
            {
                GpFontCollection* actualFontCollection;
                actualFontCollection = gpFontFamily->GetFontCollection();
                actualFontCollection = actualFontCollection ?
                                        actualFontCollection :
                                        GpInstalledFontCollection::GetGpInstalledFontCollection();

                actualFontCollection->GetFontTable()->RemoveFontFile(face->pff->pwszPathname_);
            }
        }
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCloneFontFamily(GpFontFamily *gpFontFamily, GpFontFamily **gpClonedFontFamily)
{
    API_ENTRY(GdipCloneFontFamily);
    CheckParameter(gpClonedFontFamily);

    GlobalTextLock lock;

    CheckParameterValid(gpFontFamily);

    gpFontFamily->IncFontFamilyRef();
    *gpClonedFontFamily = gpFontFamily;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFamily(GpFont *font, GpFontFamily **family)
{
    API_ENTRY(GdipGetFamily);
    CheckParameter(family);

    GlobalTextLock lock;

    CheckParameterValid(font);

    *family = const_cast<GpFontFamily *>(font->GetFamily());

    return Ok;

}

GpStatus
WINGDIPAPI
GdipGetFontStyle(GpFont *font, INT *style)
{
    API_ENTRY(GdipGetFontStyle);
    CheckParameter(style);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *style = font->GetStyle();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLogFontA(GpFont * font, GpGraphics *graphics, LOGFONTA * logfontA)
{
    API_ENTRY(GdipGetLogFontA);
    CheckParameter(logfontA);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    GlobalTextLock lock;

    CheckParameterValid(font);
    font->GetLogFontA(graphics, logfontA);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLogFontW(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW)
{
    API_ENTRY(GdipGetLogFontW);
    CheckParameter(logfontW);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    GlobalTextLock lock;

    CheckParameterValid(font);
    font->GetLogFontW(graphics, logfontW);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFontSize(GpFont *font, REAL *size)
{
    API_ENTRY(GdipGetFontSize);
    CheckParameter(size);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *size = font->GetEmSize();

    return Ok;
}


GpStatus
WINGDIPAPI
GdipGetFontUnit(GpFont *font, Unit *unit)
{
    API_ENTRY(GdipGetFontUnit);
    CheckParameter(unit);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *unit = font->GetUnit();

    return Ok;
}


GpStatus
WINGDIPAPI
GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, REAL *height)
{
    API_ENTRY(GdipGetFontHeight);
    CheckParameter(height);
    CheckOptionalParameterValid(graphics);
    CheckOptionalObjectBusy(graphics);

    GlobalTextLock lock;

    CheckParameterValid(font);
    return font->GetHeight(graphics, height);
}


GpStatus
WINGDIPAPI
GdipGetFontHeightGivenDPI(GDIPCONST GpFont *font, REAL dpi, REAL *height)
{
    API_ENTRY(GdipGetFontHeight);
    CheckParameter(height);

    GlobalTextLock lock;

    CheckParameterValid(font);
    return font->GetHeight(dpi, height);
}


GpStatus
WINGDIPAPI
GdipCloneFont(
    GpFont* font,
    GpFont** cloneFont
    )
{
    API_ENTRY(GdipCloneFont);
    CheckParameter(cloneFont);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *cloneFont = font->Clone();

    if (*cloneFont)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteFont(
    GpFont* font
    )
{
    API_ENTRY(GdipDeleteFont);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(font);

    GlobalTextLock lock;

    delete font;

    return Ok;
}

/// End out of place font/text stuff

GpStatus
WINGDIPAPI
GdipGetDC(
    GpGraphics*     graphics,
    HDC *           hdc
    )
{
    API_ENTRY(GdipGetDC);
    CheckParameter(hdc);
    CheckParameterValid(graphics);

    // NOTE: We have to leave the graphics locked until the GdipReleaseDC call

    LONG *      lockCount = (graphics->GetObjectLock())->GetLockCount();
    LONG        result    = InterlockedIncrement(lockCount);

    if (result != 0)
    {
        InterlockedDecrement(lockCount);
        return ObjectBusy;
    }

    if ((*hdc = graphics->GetHdc()) == NULL)
    {
        InterlockedDecrement(lockCount);
        return InvalidParameter;
    }

    graphics->LockedByGetDC = -1;   // set graphics GetDC lock
    return Ok;
}

GpStatus
WINGDIPAPI
GdipReleaseDC(
    GpGraphics*     graphics,
    HDC             hdc
    )
{
    API_ENTRY(GdipReleaseDC);
    CheckParameter(hdc);
    CheckParameterValid(graphics);

    // NOTE: The graphics should already be locked from the GdipGetDC call

    LONG        result;

    if ((InterlockedIncrement(&(graphics->LockedByGetDC)) != 0) ||
        (!(graphics->GetObjectLock())->IsLocked()))
    {
        InterlockedDecrement(&(graphics->LockedByGetDC));
        return InvalidParameter;
    }

    graphics->ReleaseHdc(hdc);

    InterlockedDecrement((graphics->GetObjectLock())->GetLockCount());

    return Ok;
}

GpStatus
WINGDIPAPI
GdipComment(
    GpGraphics*     graphics,
    UINT            sizeData,
    GDIPCONST BYTE *    data
    )
{
    API_ENTRY(GdipComment);
    CheckParameter(data && (sizeData > 0));
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->Comment(sizeData, data);
}


// FontFamily

/// GdipCreateFontFamilyFromName should be moved here

/// GdipEnumerableFonts should be moved here

/// GdipEnumerateFonts should be moved here

/// GdipGetFamilyName should be moved here

GpStatus
WINGDIPAPI
GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style, BOOL * IsAvailable)
{
    API_ENTRY(GdipIsStyleAvailable);
    CheckParameter(IsAvailable);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *IsAvailable = family->IsStyleAvailable(style);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, UINT16 * EmHeight)
{
    API_ENTRY(GdipGetEmHeight);
    CheckParameter(EmHeight);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *EmHeight = family->GetDesignEmHeight(style);

    return Ok;

}

GpStatus
WINGDIPAPI
GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellAscent)
{
    API_ENTRY(GdipGetCellAscent);
    CheckParameter(CellAscent);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *CellAscent = family->GetDesignCellAscent(style);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellDescent)
{
    API_ENTRY(GdipGetCellDescent);
    CheckParameter(CellDescent);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *CellDescent = family->GetDesignCellDescent(style);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, UINT16 * LineSpacing)
{
    API_ENTRY(GdipGetLineSpacing);
    CheckParameter(LineSpacing);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *LineSpacing = family->GetDesignLineSpacing(style);

    return Ok;
}

// Font

GpStatus
WINGDIPAPI
GdipCreateFontFromDC(
    HDC        hdc,
    GpFont   **font
)
{
    API_ENTRY(GdipCreateFontFromDC);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = GenericError;
    CheckParameter(hdc);

    GlobalTextLock lock;

    if (*font = new GpFont(hdc))
    {
        // we should fail in case we don't have valid font family. (non-true type font selected in the hdc)
        if (!(*font)->IsValid())
        {
           delete *font;
           *font = NULL;
           status = NotTrueTypeFont;
        }
        else
            status = Ok;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipCreateFontFromLogfontA(
    HDC              hdc,
    GDIPCONST LOGFONTA  *logfont,
    GpFont         **font
)
{
    API_ENTRY(GdipCreateFontFromLogfontA);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = GenericError;
    CheckParameter(hdc && logfont);

    GlobalTextLock lock;

    if (*font = new GpFont(hdc, const_cast<LOGFONTA*>(logfont)))
    {
        // we should fail in case we don't have valid font family. (non-true type font selected in the hdc)
        if (!(*font)->IsValid())
        {
           delete *font;
           *font = NULL;
           status = NotTrueTypeFont;
        }
        else
            status = Ok;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipCreateFontFromLogfontW(
    HDC             hdc,
    GDIPCONST LOGFONTW  *logfont,
    GpFont          **font
)
{
    API_ENTRY(GdipCreateFontFromLogfontW);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = GenericError;
    CheckParameter(hdc && logfont);

    GlobalTextLock lock;

    if (*font = new GpFont(hdc, const_cast<LOGFONTW*>(logfont)))
    {
        // we should fail in case we don't have valid font family. (non-true type font selected in the hdc)
        if (!(*font)->IsValid())
        {
           delete *font;
           *font = NULL;
           status = NotTrueTypeFont;
        }
        else
            status = Ok;
    }

    return status;
}

/// GdipCreateFont should be moved here

/// GdipCloneFont should be moved here

/// GdipDeleteFont should be moved here

/// GdipGetFamily should be moved here

/// GdipGetFontStyle should be moved here

/// GdipGetFontSize should be moved here


GpStatus
WINGDIPAPI
GdipNewInstalledFontCollection(GpFontCollection** fontCollection)
{
    API_ENTRY(GdipNewInstalledFontCollection);
    CheckParameter (fontCollection);

    GlobalTextLock lock;

    *fontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

    return (*fontCollection ? Ok : FileNotFound);
}

GpStatus
WINGDIPAPI
GdipNewPrivateFontCollection(GpFontCollection** fontCollection)
{
    API_ENTRY(GdipNewPrivateFontCollection);
    CheckParameter (fontCollection);

    GlobalTextLock lock;

    *fontCollection = new GpPrivateFontCollection;

    return (*fontCollection ? Ok : GenericError);
}

GpStatus
WINGDIPAPI
GdipDeletePrivateFontCollection(GpFontCollection** fontCollection)
{
    API_ENTRY(GdipDeletePrivateFontCollection);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter (fontCollection);

    GlobalTextLock lock;

    delete static_cast<GpPrivateFontCollection *>(*fontCollection);

    *fontCollection = NULL;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFontCollectionFamilyCount(
    GpFontCollection*   fontCollection,
    INT       *             numFound
    )
{
    API_ENTRY(GdipGetFontCollectionFamilyCount);
    CheckParameter (numFound);

    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    *numFound = fontCollection->GetFamilyCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFontCollectionFamilyList(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
    )
{
    API_ENTRY(GdipGetFontCollectionFamilyList);
    GpStatus status;
    CheckParameter(gpfamilies);
    CheckParameter (numFound);

    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    return fontCollection->GetFamilies(
        numSought,
        gpfamilies,
        numFound);
}

GpStatus
WINGDIPAPI
GdipPrivateAddFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
    )
{
    API_ENTRY(GdipPrivateAddFontFile);
    CheckParameter (filename);

    // We can cast the fontCollection because we know that this
    // function is called only from PrivateFontCollection::AddFontFile,
    // and so we know that fontCollection really was constructed as
    // a PrivateFontCollection.
    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    return static_cast<GpPrivateFontCollection *>
        (fontCollection)->AddFontFile(filename);
}

GpStatus
WINGDIPAPI
GdipPrivateAddMemoryFont(
    GpFontCollection* fontCollection,
    GDIPCONST void* memory,
    INT length
    )
{
    API_ENTRY(GdipPrivateAddMemoryFont);
    CheckParameter (memory);

    // We can cast the fontCollection because we know that this
    // function is called only from PrivateFontCollection::AddMemoryFontFile,
    // and so we know that fontCollection really was constructed as
    // an PrivateFontCollection.
    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    return static_cast<GpPrivateFontCollection *>
        (fontCollection)->AddMemoryFont(memory, length);
}

GpStatus
WINGDIPAPI
GdipSetFontSize(GpFont *font, REAL size, Unit unit)
{
    API_ENTRY(GdipSetFontSize);

    GlobalTextLock lock;

    CheckParameterValid(font);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    if ((unit >= UnitWorld) && (unit <= UnitMillimeter) && (unit != UnitDisplay))
    {
        font->SetEmSize(size);
        font->SetUnit(unit);
        return Ok;
    }
    else
    {
        return GenericError;
    }
}


GpStatus
WINGDIPAPI
GdipCreateStringFormat(
    INT               formatAttributes,
    LANGID            language,
    GpStringFormat  **format
)
{
    API_ENTRY(GdipCreateStringFormat);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(format);

    GlobalTextLock lock;

    *format = new GpStringFormat(formatAttributes, language);

    return format ? Ok : OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipStringFormatGetGenericDefault(GpStringFormat **format)
{
    API_ENTRY(GdipStringFormatGetGenericDefault);
    CheckParameter(format);

    GlobalTextLock lock;
    *format = GpStringFormat::GenericDefault();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipStringFormatGetGenericTypographic(GpStringFormat **format)
{
    API_ENTRY(GdipStringFormatGetGenericTypographic);
    CheckParameter(format);
    GlobalTextLock lock;
    *format = GpStringFormat::GenericTypographic();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipCloneStringFormat(
    GDIPCONST GpStringFormat *format,
    GpStringFormat **newFormat)
{
    API_ENTRY(GdipCloneStringFormat);
    CheckParameter(newFormat);

    GlobalTextLock lock;
    CheckParameterValid(format);

    *newFormat = format->Clone();

    return newFormat == NULL ? OutOfMemory : Ok;
}

GpStatus
WINGDIPAPI
GdipDeleteStringFormat(GpStringFormat *format)
{
    API_ENTRY(GdipDeleteStringFormat);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(format);

    GlobalTextLock lock;

    if (!format->IsPermanent())
    {
        delete format;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatFlags(GpStringFormat *format, INT flags)
{
    API_ENTRY(GdipSetStringFormatFlags);

    GlobalTextLock lock;
    CheckParameterValid(format);

    format->SetFormatFlags(flags);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetStringFormatFlags(GDIPCONST GpStringFormat *format, INT *flags)
{
    API_ENTRY(GdipGetStringFormatFlags);
    CheckParameter(flags);

    GlobalTextLock lock;
    CheckParameterValid(format);
    *flags = format->GetFormatFlags();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatAlign(
    GpStringFormat   *format,
    StringAlignment   align)
{
    API_ENTRY(GdipSetStringFormatAlign);
    GlobalTextLock lock;
    CheckParameterValid(format);

    CheckParameter(    align >= StringAlignmentNear
                   &&  align <= StringAlignmentFar);

    return format->SetAlign(align);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatAlign(
    GDIPCONST GpStringFormat *format,
    StringAlignment            *align)
{
    API_ENTRY(GdipGetStringFormatAlign);
    CheckParameter(align);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetAlign(align);
}

GpStatus
WINGDIPAPI
GdipSetStringFormatLineAlign(
    GpStringFormat   *format,
    StringAlignment   align)
{
    API_ENTRY(GdipSetStringFormatLineAlign);

    GlobalTextLock lock;
    CheckParameterValid(format);

    CheckParameter(    align >= StringAlignmentNear
                   &&  align <= StringAlignmentFar);

    return format->SetLineAlign(align);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatLineAlign(
    GDIPCONST GpStringFormat *format,
    StringAlignment          *align)
{
    API_ENTRY(GdipGetStringFormatLineAlign);
    CheckParameter(align);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetLineAlign(align);
}


GpStatus
WINGDIPAPI
GdipSetStringFormatHotkeyPrefix(
    GpStringFormat *format,
    INT             hotkeyPrefix)
{
    API_ENTRY(GdipSetStringFormatHotkeyPrefix);
    CheckParameter(    hotkeyPrefix >= HotkeyPrefixNone
                   &&  hotkeyPrefix <= HotkeyPrefixHide);

    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetHotkeyPrefix(hotkeyPrefix);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatHotkeyPrefix(
    GDIPCONST GpStringFormat *format,
    INT                      *hotkeyPrefix)
{
    API_ENTRY(GdipGetStringFormatHotkeyPrefix);
    CheckParameter(hotkeyPrefix);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetHotkeyPrefix(hotkeyPrefix);
}

GpStatus
WINGDIPAPI
GdipSetStringFormatTabStops(
    GpStringFormat  *format,
    REAL            firstTabOffset,
    INT             count,
    GDIPCONST REAL            *tabStops
)
{
    API_ENTRY(GdipSetStringFormatTabStops);
    CheckParameter(tabStops);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetTabStops (
                firstTabOffset,
                count,
                tabStops
           );
}

GpStatus
WINGDIPAPI
GdipGetStringFormatTabStopCount(
    GDIPCONST GpStringFormat    *format,
    INT                     *count
)
{
    API_ENTRY(GdipGetStringFormatTabStopCount);
    CheckParameter(count);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetTabStopCount (count);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatTabStops(
    GDIPCONST GpStringFormat    *format,
    INT                     count,
    REAL                    *firstTabOffset,
    REAL                    *tabStops
)
{
    API_ENTRY(GdipGetStringFormatTabStops);
    CheckParameter(firstTabOffset && tabStops);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetTabStops (
                firstTabOffset,
                count,
                tabStops
           );
}

GpStatus
WINGDIPAPI
GdipGetStringFormatMeasurableCharacterRangeCount(
    GDIPCONST GpStringFormat    *format,
    INT                         *count
)
{
    API_ENTRY(GdipGetStringFormatMeasurableCharacterRangeCount);
    CheckParameter(count);
    CheckParameterValid(format);

    *count = format->GetMeasurableCharacterRanges();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatMeasurableCharacterRanges(
    GpStringFormat              *format,
    INT                         rangeCount,
    GDIPCONST CharacterRange    *ranges
)
{
    API_ENTRY(GdipSetStringFormatMeasurableCharacterRanges);
    CheckParameter(ranges);
    CheckParameterValid(format);

    if (rangeCount > 32)
    {
        return ValueOverflow;
    }

    return format->SetMeasurableCharacterRanges(
        rangeCount,
        ranges
    );
    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatDigitSubstitution(
    GpStringFormat       *format,
    LANGID                language,
    StringDigitSubstitute substitute
)
{
    API_ENTRY(GdipSetStringFormatDigitSubstitution);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetDigitSubstitution (
                language,
                substitute
           );
}

GpStatus
WINGDIPAPI
GdipGetStringFormatDigitSubstitution(
    GDIPCONST GpStringFormat        *format,
    LANGID                *language,
    StringDigitSubstitute *substitute
)
{
    API_ENTRY(GdipGetStringFormatDigitSubstitution);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetDigitSubstitution (
                language,
                substitute
           );
}

GpStatus
WINGDIPAPI
GdipSetStringFormatTrimming(
    GpStringFormat  *format,
    StringTrimming   trimming
)
{
    API_ENTRY(GdipSetStringFormatTrimming);
    CheckParameter(    trimming >= StringTrimmingNone
                   &&  trimming <= StringTrimmingEllipsisPath);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetTrimming(trimming);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatTrimming(
    GDIPCONST GpStringFormat *format,
    StringTrimming       *trimming
)
{
    API_ENTRY(GdipGetStringFormatTrimming);
    CheckParameter(trimming);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetTrimming(trimming);
}

GpStatus
WINGDIPAPI
GdipCreateCachedBitmap(
    GpBitmap *bitmap,
    GpGraphics *graphics,
    GpCachedBitmap **nativeCachedBitmap
)
{
    API_ENTRY(GdipCreateCachedBitmap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(nativeCachedBitmap);

    // must have a bitmap and a graphics to create a CachedBitmap.
    // Also we must lock both objects for the duration of this call
    // because we can't have any other APIs modifying them.

    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    *nativeCachedBitmap = new GpCachedBitmap(bitmap, graphics);
    if(nativeCachedBitmap)
    {
        return Ok;
    }
    else
    {
        return OutOfMemory;
    }

}

GpStatus WINGDIPAPI
GdipDeleteCachedBitmap(GpCachedBitmap *nativeCachedBitmap)
{
    API_ENTRY(GdipDeleteCachedBitmap);

    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(nativeCachedBitmap);

    // Grab the lock for the duration of the delete so that we bounce if
    // someone is busy rendering on it.

    // !!! [asecchia] note this will bounce if the object is locked and then
    // the deletion will fail. This will cause the app to leak memory because
    // there is no way to check the return status from delete.
    // This problem is common to all our deletion APIs

    CheckObjectBusyForDelete(nativeCachedBitmap);

    delete nativeCachedBitmap;

    return Ok;
}

GpStatus WINGDIPAPI
GdipDrawCachedBitmap(
    GpGraphics *nativeGraphics,
    GpCachedBitmap *cb,
    INT x,
    INT y
)
{
    API_ENTRY(GdipDrawCachedBitmap);
    // Check the input parameters for NULL

    CheckParameterValid(nativeGraphics);
    CheckParameterValid(cb);

    // Grab the lock to make sure nobody is currently trying to delete the
    // object under us.

    CheckObjectBusy(cb);

    // Grab the lock on the GpGraphics

    CheckObjectBusy(nativeGraphics);

    return (nativeGraphics->DrawCachedBitmap(cb, x, y));
}

// The palette must be freed and recreated whenever the Desktop colors change
HPALETTE
WINGDIPAPI
GdipCreateHalftonePalette()
{
    API_ENTRY(GdipCreateHalftonePalette);

    // !!! [agodfrey]: I bet we haven't documented the fact that the user
    //     has to call this any time the desktop colors change.
    //     Also, I don't know why we read 12 colors instead of 4 (I thought
    //     there were only 4 magic colors.)

    HPALETTE    hpalette;
    HDC         hdc = ::GetDC(NULL);  // Get a screen DC

    if (hdc != NULL)
    {
        // See if we need to get the desktop colors
        if ((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
            (::GetSystemPaletteUse(hdc) == SYSPAL_STATIC) &&
            (::GetDeviceCaps(hdc, SIZEPALETTE) == 256))
        {
            // We have to get the desktop colors to guarantee
            // a XO_TRIVIAL translate in GDI.

            // First Entry is always Black
            ::GetSystemPaletteEntries(hdc, 1, 9,
                                      Win9xHalftonePalette.palPalEntry + 1);

            // We only can handle changes to the first 3 of the last 10
            ::GetSystemPaletteEntries(hdc, 246, 3,
                                      Win9xHalftonePalette.palPalEntry + 246);
        }
        ::ReleaseDC(NULL, hdc);
    }
    hpalette = ::CreatePalette((LOGPALETTE *)(&Win9xHalftonePalette));
    return hpalette;
}

GpStatus
WINGDIPAPI
GdipMonitorControl(GpMonitorControlEnum control, void * param)
{
    API_ENTRY(GdipMonitorControl);

    if(Globals::Monitors == NULL)
    {
        Globals::Monitors = new GpMonitors;

        if(Globals::Monitors == NULL)
            return OutOfMemory;
    }

    return Globals::Monitors->Control(control, param);
}

GpStatus
WINGDIPAPI
GdipTestControl(GpTestControlEnum control, void * param)
{
    API_ENTRY(GdipTestControl);

    GpStatus result = Ok;

    switch(control)
    {
    case TestControlForceBilinear:
        Globals::ForceBilinear = *((BOOL *) param);
        break;

    case TestControlNoICM:
        Globals::NoICM = *((BOOL *) param);
        break;

    case TestControlGetBuildNumber:
        *((INT32 *) param) = VER_PRODUCTBUILD;
        break;

    default:
        result = InvalidParameter;
        break;
    }

    return result;
}

UINT
WINGDIPAPI
GdipEmfToWmfBits(HENHMETAFILE hemf,
                 UINT         cbData16,
                 LPBYTE       pData16,
                 INT          iMapMode,
                 INT          eFlags)
{
    API_ENTRY(GdipEmfToWmfBits);
    return ConvertEmfToPlaceableWmf(
            hemf,
            cbData16,
            pData16,
            iMapMode,
            eFlags);
}

// Version information for debugging purposes
UINT32 GpBuildNumber = VER_PRODUCTBUILD;

} // end of extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\lib\makefile.inc ===
$(O)\gdipstat.lib: $(O)\gpbroken.lib
        workaround.bat $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\dll\dllentry.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDIPLUS.DLL entry point
*
* Abstract:
*
*   DLL initialization and uninitialization.
*
* Revision History:
*
*   09/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* DllInitialize:
*
*   This is the very first function call into GDI+, and takes place
*   when the DLL is first loaded.  We do some one-time initialization
*   here.
*
*   NOTE: Add GDI+ specific functionality to InitializeGdiplus(), not here!
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Flat\Dll\DllEntry.cpp
*
\**************************************************************************/

//
// DLL instance handle
//

extern HINSTANCE DllInstance;

extern "C"
BOOL
DllMain(
    HINSTANCE   dllHandle,
    ULONG       reason,
    CONTEXT*    context
    )
{
    BOOL b = TRUE;

    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        {
            DllInstance = dllHandle;

            __try
            {
                GdiplusStartupCriticalSection::InitializeCriticalSection();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // We couldn't allocate the criticalSection
                // Return an error
                b = FALSE;
            }
    
            // To improve the working set, we tell the system we don't
            // want any DLL_THREAD_ATTACH calls:
    
            DisableThreadLibraryCalls((HINSTANCE) dllHandle);
    
            break;
        }    

    case DLL_PROCESS_DETACH:
        // If we could use an assertion here, I'd assert that 
        // Globals::LibraryInitRefCount == 0.
        // But ASSERT would crash here, since we've shut down already.
        
        GdiplusStartupCriticalSection::DeleteCriticalSection();
        break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\dll\makefile.inc ===
$(O)\gdiplus.def: gdiplus.def
    $(C_PREPROCESSOR) gdiplus.def > $@

$(O)\gdiplus.static.def: gdiplus.def
    $(C_PREPROCESSOR) gdiplus.def /DGP_STATIC_BUILD > $@


$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\gdiplus.lib : $(O)\gdiplus.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\officehack\officehack.cpp ===
#include <windows.h>
#include <initguid.h>
#include "imgguids.h"
#include "gdiplusmem.h"
#include <math.h>

typedef VOID (__cdecl *DEBUGEVENTFUNCTION)(INT level, CHAR *message);

extern "C" BOOL __stdcall InitializeGdiplus(DEBUGEVENTFUNCTION debugEventFunction) { return TRUE; }
extern "C" VOID __stdcall UninitializeGdiplus() {}

extern "C" void *GpMalloc(size_t size) {
    return GdipAlloc(size);
}

extern "C" void GpFree(void *p) {
    GdipFree(p);
}

extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber) {
    return GdipAlloc(size);
}
namespace GpRuntime
{
    double __stdcall Exp(double x)
    {
        return exp(x);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fnt.h ===
/*
	File:       fnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>     4/30/97    CB      ClaudeBe, catching infinite loops/recursions
	      <>     2/21/97    CB      ClaudeBe, scaled component in composite glyphs
	      <>     2/05/96    CB      ClaudeBe, add bHintForGray in globalGS
	   <11+>     9/15/90    MR,rb   Change pvx and pvy to proj.[xy].  Same for freedom vector.
									Conditionalize vectors for Fracts or ShortFracts.
		<10>     7/26/90    MR      rearrange local graphic state, remove unused parBlockPtr
		 <9>     7/18/90    MR      change loop variable from long to short, and other Ansi-changes
		 <8>     7/13/90    MR      Prototypes for function pointers
		 <5>      6/4/90    MR      Remove MVT
		 <4>      5/3/90    RB      replaced dropoutcontrol with scancontrolin and scancontrol out
									in global graphics state
		 <3>     3/20/90    CL      fields for multiple preprograms fields for ppemDot6 and
									pointSizeDot6 changed SROUND to take D/2 as argument
		 <2>     2/27/90    CL      Added DSPVTL[] instruction.  Dropoutcontrol scanconverter and
									SCANCTRL[] instruction
	   <3.1>    11/14/89    CEL     Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
									S45ROUND.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
*/
/*  rwb 4/24/90 Replaced dropoutControl with scanControlIn and scanControlOut in
		global graphics state. 
		<3+>     3/20/90    mrr     Added support for IDEFs.  Made funcDefs long aligned
									by storing int16 length instead of int32 end.
*/

#ifndef FNT_DEFINED
#define FNT_DEFINED

#define STUBCONTROL 0x10000
#define NODOCONTROL 0x20000

#define FNT_PIXELSIZE  ((F26Dot6)0x40)
#define FNT_PIXELSHIFT 6

// public phantom points (cf. scale.c for private phantom points), relative to number of points in glyph
#define LEFTSIDEBEARING		0
#define RIGHTSIDEBEARING	1

#define TOPSIDEBEARING		2
#define BOTTOMSIDEBEARING	3

#define VECTORTYPE	ShortFract

#define NON90DEGTRANS_ROTATED	0x01
#define NON90DEGTRANS_STRETCH	0x02

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel hinting flag field, internal flags */
#define FNT_SP_SUB_PIXEL			0x0001      /* set when calling fs_NewTransformation() */
#define FNT_SP_COMPATIBLE_WIDTH		0x0002      /* set when calling fs_NewTransformation() */
#define FNT_SP_VERTICAL_DIRECTION	0x0004		// set when calling fs_NewTransformation()
#define FNT_SP_BGR_ORDER			0x0008		// set when calling fs_NewTransformation()

#define SPCF_iupxCalled				0x0001		// individual bits of GlobalGS.subPixelCompatibilityFlags
#define SPCF_iupyCalled				0x0002
#define SPCF_inDiagEndCtrl			0x0004
#define SPCF_inVacuformRound		0x0008
#define SPCF_inSkippableDeltaFn		0x0010
#define SPCF_detectedDandIStroke	0x0100
#define SPCF_detectedJellesSpacing	0x0200
#define SPCF_detectedVacuformRound	0x0400
#define SPCF_detectedTomsDiagonal	0x0800


#endif // FSCFG_SUBPIXEL

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA

	#define BADREL	0x01
	#define DONE	0x02
	#define DOING	0x04

	// Data structure for information leap. This information leap is necessary because of the following reason:
	// Technically, what we're doing is to automatically add on-the-fly in-line deltas to the stream of instructions. Such deltas appear
	// after an incoming "link" (MIRP, MDRP), but before one or more outgoing "links". If one of these outgoing links controls a stroke,
	// then this stroke's phase may need to be adjusted (by a delta). However, we don't know whether any of the outgoing links controls a
	// stroke, nor which one, until we've interpreted them all, at which point it is too late to apply a delta, because the delta has to be
	// applied before any outgoing links (dependency). Conversely, the incoming link does not bear any information that would suggest that
	// it links to a stroke (don't know the future). To make matters worse, it is possible that in the stream of instructions the link that
	// controls a stroke comes at the very end of the TT code, even though there may have been many other, unrelated instructions inbetween.
	// Therefore, we have to interpert the entire TT code (upto the IUP instruction in the SP direction) before we know all we need to 
	// calculate and apply the phase control.
	
	typedef struct {
		int16 parent0,parent1; // -1 for none
		int16 child; // for black links (we can satisfy 1 phase shift only, hence no need for several children), else -1
		uint16 flags; // BADREL, DONE, DOING
		F26Dot6 phaseShift;
	} PhaseControlRelation; // 12 bytes (?)
	
#endif

typedef struct VECTOR {
	VECTORTYPE x;
	VECTORTYPE y;
} VECTOR;

typedef struct {
	F26Dot6 *x;         /* The Points the Interpreter modifies */
	F26Dot6 *y;         /* The Points the Interpreter modifies */
	F26Dot6 *ox;        /* Old Points */
	F26Dot6 *oy;        /* Old Points */
	F26Dot6 *oox;       /* Old Unscaled Points, really ints */
	F26Dot6 *ooy;       /* Old Unscaled Points, really ints */
	uint8   *onCurve;   /* indicates if a point is on or off the curve */
	int16   *sp;        /* Start points */
	int16   *ep;        /* End points */
	uint8   *f;         /* Internal flags, one byte for every point */
	int16   nc;         /* Number of contours */
	uint8   *fc;         /* contour flags, one byte for every contour */
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	boolean phaseControlExecuted;
	PhaseControlRelation *pcr;
#endif
} fnt_ElementType;

/* flags for contour flags : */
#define OUTLINE_MISORIENTED 1

typedef struct {
	int32 start;        /* offset to first instruction */
	uint16 length;      /* number of bytes to execute <4> */
	uint16 pgmIndex;    /* index to appropriate preprogram for this func (0..1) */
} fnt_funcDef;

/* <4> pretty much the same as fnt_funcDef, with the addition of opCode */
typedef struct {
	int32 start;
	uint16 length;
	uint8  pgmIndex;
	uint8  opCode;
} fnt_instrDef;

typedef struct {
	uint8 *    Instruction;
	uint32     Length;
} fnt_pgmList;

struct fnt_LocalGraphicStateType;
typedef void (FS_CALLBACK_PROTO *FntTraceFunc)(struct fnt_LocalGraphicStateType*, uint8*);

#ifdef FSCFG_REENTRANT
typedef uint8* (*FntFunc)(struct fnt_LocalGraphicStateType*, uint8*, int32);
typedef void (*FntMoveFunc)(struct fnt_LocalGraphicStateType*, fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
typedef void (*InterpreterFunc)(struct fnt_LocalGraphicStateType*, uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
#else 
typedef uint8* (*FntFunc)(uint8*, int32);
typedef void (*FntMoveFunc)(fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(F26Dot6 x, F26Dot6 y);
typedef void (*InterpreterFunc)(uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(F26Dot6 xin, F26Dot6 engine);
#endif 

typedef struct {

/* PARAMETERS CHANGEABLE BY TT INSTRUCTIONS */
	F26Dot6 wTCI;                   /* width table cut in */
	F26Dot6 sWCI;                   /* single width cut in */
	F26Dot6 scaledSW;               /* scaled single width */
	int32 scanControl;              /* controls kind and when of dropout control */
	int32 instructControl;          /* controls gridfitting and default setting */
	
	F26Dot6 minimumDistance;        /* moved from local gs  7/1/90  */
	FntRoundFunc RoundValue;        /*                              */
#ifdef FSCFG_SUBPIXEL
	uint16		roundState;			// see comments in interp.c
#endif
	F26Dot6 periodMask;             /* ~(gs->period-1)              */
	VECTORTYPE period45;            /*                              */
	int16   period;                 /* for power of 2 periods       */
	int16   phase;                  /*                              */
	int16   threshold;              /* moved from local gs  7/1/90  */

	int16 deltaBase;
	int16 deltaShift;
	int16 angleWeight;
	int16 sW;                       /* single width, expressed in the same units as the character */
	int8 autoFlip;                  /* The auto flip Boolean */
	int8 pad;   
#ifndef FSCFG_NOPAD_PARAMETER_BLOCK_4
	int16 pad2;   
#endif 
} fnt_ParameterBlock;               /* this is exported to client */

#define PREPROGRAM     0
#define FONTPROGRAM    1
#define GLYPHPROGRAM   2

#define MAXPREPROGRAMS 2

#ifdef FSCFG_SUBPIXEL
	#define maxDeltaFunctions	4
#endif

typedef struct fnt_ScaleRecord {
	Fixed fixedScale;       /* Slow Scale */
	int32 denom;            /* Fast and Medium Scale */
	int32 numer;            /* Fast and Medium Scale */
	int32 shift;            /* Fast Scale */
} fnt_ScaleRecord;

typedef F26Dot6 (*GlobalGSScaleFunc)(fnt_ScaleRecord*, F26Dot6);

typedef struct fnt_GlobalGraphicStateType {
	F26Dot6* stackBase;             /* the stack area */
	F26Dot6* store;                 /* the storage area */
	F26Dot6* controlValueTable;     /* the control value table */
	
	uint16  pixelsPerEm;            /* number of pixels per em as an integer */
	uint16  pointSize;              /* the requested point size as an integer */
	Fixed   fpem;                   /* fractional pixels per em    <3> */
	F26Dot6 engine[4];              /* Engine Characteristics */
	
	fnt_ParameterBlock defaultParBlock; /* variables settable by TT instructions */
	fnt_ParameterBlock localParBlock;

	/* Only the above is exported to Client throught FontScaler.h */

/* VARIABLES NOT DIRECTLY MANIPULABLE BY TT INSTRUCTIONS  */
	
	fnt_funcDef*    funcDef;           /* function Definitions identifiers */
	fnt_instrDef*   instrDef;         /* instruction Definitions identifiers */
	GlobalGSScaleFunc ScaleFuncXChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncYChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncX;
	GlobalGSScaleFunc ScaleFuncY;
	GlobalGSScaleFunc ScaleFuncCVT;
	fnt_pgmList     pgmList[MAXPREPROGRAMS];  /* each program ptr is in here */
	
/* These are parameters used by the call back function */
	fnt_ScaleRecord   scaleXChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleYChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleX;
	fnt_ScaleRecord   scaleY;
	fnt_ScaleRecord   scaleCVT;

	Fixed           cvtStretchX;
	Fixed           cvtStretchY;

	int8            identityTransformation;  /* true/false  (does not mean identity from a global sense) */
	int8            non90DegreeTransformation; /* bit 0 is 1 if non-90 degree, bit 1 is 1 if x scale doesn't equal y scale */
	Fixed           xStretch;           /* Tweaking for glyphs under transformational stress <4> */
	Fixed           yStretch;           /* Tweaking for glyphs under transformational stress <4> */
	
	int8            init;               /* executing preprogram ?? */
	/* !!! Should not be uint8, instead fnt_ProgramIndex */
	uint8           pgmIndex;           /* which preprogram is current */
	int32           instrDefCount;      /* number of currently defined IDefs */
	uint8			bSameStretch;
	uint8			bCompositeGlyph;	/* Flag that indicates composite glyph */
	LocalMaxProfile *	 maxp;
	uint16          cvtCount;
	Fixed           interpScalarX;      /* scalar for instructable things */
	Fixed           interpScalarY;      /* scalar for instructable things */
	Fixed           fxMetricScalarX;    /* scalar for metric things */
	Fixed           fxMetricScalarY;    /* scalar for metric things */
	/* int16  pad2; */

	boolean	bHintForGray;
	uint8			bSameTransformAsMaster;	/* for composite glyph, indicate the the sub-componenent has the same scaling than the master glyph */
	uint8			bOriginalPointIsInvalid;/* original point are invalid, we need to use ox/oy instead of scaling oox/ooy */

	uint32		ulMaxJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulMaxRecursiveCall;		/* recursive calls counter used to check the level of recursion */
    ClientIDType            clientID;  /* client private id/stamp, it's saved here to allow a trace function to access it */
#ifdef FSCFG_SECURE
	F26Dot6* stackMax;             /* maximum stack area */
	int32      maxPointsIncludePhantom;  /* in an individual glyph, including maxCompositePoints  */
#endif // FSCFG_SECURE
	uint16	uBoldSimulVertShift; /* vertical and horizontal (along baseline) shift for embolding simulation */
	uint16	uBoldSimulHorShift;
	F26Dot6	fxScaledDescender; /* scaled descender, used to clip emboldening if necessary */
#ifdef FSCFG_SUBPIXEL
	uint16	flHintForSubPixel;
	uint16	subPixelCompatibilityFlags;
	uint16	numDeltaFunctionsDetected;		  // fns to implement delta instr for range of ppem sizes or odd delta size use SHPIX,
	uint16	deltaFunction[maxDeltaFunctions]; // keep track of these cases to intelligently skip SHPIX
	Fixed	compatibleWidthStemConcertina;
#endif // FSCFG_SUBPIXEL
	boolean bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
									   or text animation where we want to turn off gridfitting hinting
									   but for fonts where glyphs are build by hinting, we still want the
									   glyph shape to be correct */
} fnt_GlobalGraphicStateType;

/* 
 * This is the local graphics state  
 */
typedef struct fnt_LocalGraphicStateType {
	fnt_ElementType *CE0, *CE1, *CE2;   /* The character element pointers */
	VECTOR proj;                        /* Projection Vector */
	VECTOR free;                        /* Freedom Vector */
	VECTOR oldProj;                     /* Old Projection Vector */
	F26Dot6 *stackPointer;

	uint8 *insPtr;                      /* Pointer to the instruction we are about to execute */
	fnt_ElementType *elements;
	fnt_GlobalGraphicStateType *globalGS;
		FntTraceFunc TraceFunc;

	int32 Pt0, Pt1, Pt2;           /* The internal reference points */
	int16 roundToGrid;
	int32 loop;                         /* The loop variable */
	uint8 opCode;                       /* The instruction we are executing */
	uint8 padByte;
	int16 padWord;

	/* Above is exported to client in FontScaler.h */

	VECTORTYPE pfProj; /* = pvx * fvx + pvy * fvy */

	FntMoveFunc MovePoint;
	FntProject Project;
	FntProject OldProject;
	InterpreterFunc Interpreter;
#ifdef FSCFG_REENTRANT
		F26Dot6 (*GetCVTEntry) (struct fnt_LocalGraphicStateType*,int32);
		F26Dot6 (*GetSingleWidth) (struct fnt_LocalGraphicStateType*);
#else 
		F26Dot6 (*GetCVTEntry) (int32 n);
		F26Dot6 (*GetSingleWidth) (void);
#endif 
	FntMoveFunc ChangeCvt;
	Fixed       cvtDiagonalStretch;

	int16       MIRPCode;               /* for fast or slow MIRP's */

	ErrorCode   ercReturn;              /* NO_ERR unless illegal instruction */
	uint8       *pbyEndInst;            /* one past last instruction */
	uint8       *pbyStartInst;          /* used to detect a jump before the begining of the program */

	uint32		ulJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulRecursiveCall;		/* recursive calls counter used to check the level of recursion */
#ifdef FSCFG_SUBPIXEL
	uint16		inSubPixelDirection;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int16		pt0,pt1;
#endif
#endif
} fnt_LocalGraphicStateType;

#endif  /* FNT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\flat\crtcheck\crtcheck.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   C runtime reference detector
*
* Abstract:
*
*   This is used to create the dummy CrtCheck.DLL, which checks
*   that we aren't using any illegal CRT functions.
*
*   CrtCheck.DLL isn't expected to run - this is only a linking test.
*
*   Because Office disallows use of MSVCRT, we can only call CRT functions
*   that are either provided by Office or reimplemented by us.
*
* Notes:
*
*   
*
* Created:
*
*   09/01/1999 agodfrey
*
\**************************************************************************/

#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
typedef unsigned short wchar_t;
typedef char *  va_list;
typedef long    time_t;

/*
    The following references are supported by Office
*/

extern "C" {    
    long __cdecl _ftol(float) { return 0; }
}

extern "C" const int _except_handler3 = 0;
extern "C" const int _except_list = 0;
extern "C" const int _fltused = 0;    

int __cdecl _purecall(void) { return 0; }
extern "C" const int _chkstk = 0;

// They told us they didn't support memmove, but it turns out that they have a
// definition for it. Anyway, some references to it crept in while crtcheck
// was broken, so this has to be here until that's resolved.
extern "C" void *  __cdecl memmove(void *, const void *, size_t) { return 0; }

/*
    The following references are implemented by us
*/

extern "C" {
    int __stdcall DllInitialize(int, int, int) { return 0; }
}

/* The following functions have intrinsic forms, 
   so we can use them safely:
   atan, atan2, cos, log, log10, sin, sqrt, tan
        
   If the /Og compiler option is not specified (e.g. in checked builds),
   the compiler generates out-of-line references to _CIatan etc., so we
   need to define them here.
   
   exp is an exception. It's in MSDN's list of intrinsic functions, but
   the compiler doesn't inline it if you specify /Os (optimize for space),
   which is what we always use. So we can't use exp, even though it's
   intrinsic. Use our replacement (Exp) instead.
*/
   
extern "C" {
//  We can't use this:
//  double  __cdecl _CIexp(double) { return 0; }

    double  __cdecl _CIatan(double) { return 0; }
    double  __cdecl _CIatan2(double, double) { return 0; }
    double  __cdecl _CIcos(double) { return 0; }
    double  __cdecl _CIlog(double) { return 0; }
    double  __cdecl _CIlog10(double) { return 0; }
    double  __cdecl _CIsin(double) { return 0; }
    double  __cdecl _CIsqrt(double) { return 0; }
    double  __cdecl _CItan(double) { return 0; }
}

/*
    The following references are needed for debugging.
    But they're only legal in the checked build.
    
    3/6/00 [agodfrey]: Office wants our debug builds too, so I'm checking
        with them on the legality of these references.
*/        

#ifdef DBG
extern "C" {
    int __cdecl rand(void) { return 0; }
    void __cdecl srand(unsigned int) { }
    time_t __cdecl time(time_t *) { return 0; }

    char *  __cdecl strrchr(const char *, int) { return 0; }
    int __cdecl printf(const char *, ...) { return 0; }
    int __cdecl _vsnprintf(char *, size_t, const char *, va_list) { return 0; }
    int __cdecl _snprintf(char *, size_t, const char *, ...) { return 0; }

// (* sigh *)
    void *  __cdecl memcpy(void *, const void *, size_t);
#pragma function(memcpy)    
    void *  __cdecl memcpy(void *, const void *, size_t) { return 0; }

    int __cdecl vsprintf(char *, const char *, va_list) { return 0; }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fnterr.c ===
/**********************************************************************
	
	fnterr.c -- Error Support Routines.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This source file provides support for debugging routines in fnt.c
	(and macjob.c to a much lesser extent).  This module keys on the
	 #define FSCFG_FNTERR which is defined in fsconfig.h

	 7/28/92 dj         First cut.
	 8/12/94 deanb      included fnterr.h for mac
	12/07/94 deanb		changed %x to %hx or %lx; %d to %hd

 **********************************************************************/

#define FSCFG_INTERNAL

#include "fsconfig.h"
#include "fnterr.h"

#ifdef FSCFG_FNTERR
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* FILE * fopen(); */
int    abs (int);
/*
int    strlen (char*);
int    strcmp (char*, char*);
int    strcpy (char*, char*);
int    strncpy( char*, char *, int);
*/

#define ERR_MAX_IFS      8
#define ERR_MAX_CODE     16
#define ERR_MAX_FNAME    80
#define ERR_MAX_MSG  512

static int               errOpc;
static int               errBreak;
static int               errIfOk  = 1;
static unsigned short    errSize  = 0;
static unsigned short    errCode  = 0;
static int               errIfNdx = 0;
static long              errInstCount;
static int               errIfs[ERR_MAX_IFS];
static char              errOpName[ERR_MAX_CODE];
static char              errFname[ERR_MAX_FNAME];
static char            * errOpcs[] =
{
  "SVTCA_0",
  "SVTCA_1",
  "SPVTCA",
  "SPVTCA",
  "SFVTCA",
  "SFVTCA",
  "SPVTL",
  "SPVTL",
  "SFVTL",
  "SFVTL",
  "WPV",
  "WFV",
  "RPV",
  "RFV",
  "SFVTPV",
  "ISECT",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetLocalGraphicState",
  "SetRoundState",
  "SetRoundState",
  "LMD",
  "ELSE",
  "JMPR",
  "LWTCI",
  "LSWCI",
  "LSW",
  "DUP",
  "SetLocalGraphicState",
  "CLEAR",
  "SWAP",
  "DEPTH",
  "CINDEX",
  "MINDEX",
  "ALIGNPTS",
  "RAW",
  "UTP",
  "LOOPCALL",
  "CALL",
  "FDEF",
  "IllegalInstruction",
  "MDAP",
  "MDAP",
  "IUP",
  "IUP",
  "SHP",
  "SHP",
  "SHC",
  "SHC",
  "SHE",
  "SHE",
  "SHPIX",
  "IP",
  "MSIRP",
  "MSIRP",
  "ALIGNRP",
  "SetRoundState",
  "MIAP",
  "MIAP",
  "NPUSHB",
  "NPUSHW",
  "WS",
  "RS",
  "WCVT",
  "RCVT",
  "RC",
  "RC",
  "WC",
  "MD",
  "MD",
  "MPPEM",
  "MPS",
  "FLIPON",
  "FLIPOFF",
  "DEBUG",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "IF",
  "EIF",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "DELTAP1",
  "SDB",
  "SDS",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "ROUND",
  "ROUND",
  "ROUND",
  "ROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "WCVTFOD",
  "DELTAP2",
  "DELTAP3",
  "DELTAC1",
  "DELTAC2",
  "DELTAC3",
  "SROUND",
  "S45ROUND",
  "JROT",
  "JROF",
  "SetRoundState",
  "IllegalInstruction",
  "SetRoundState",
  "SetRoundState",
  "SANGW",
  "AA",
  "FLIPPT",
  "FLIPRGON",
  "FLIPRGOFF",
  "IDefPatch",
  "IDefPatch",
  "SCANCTRL",
  "SDPVTL",
  "SDPVTL",
  "GETINFO",
  "IDEF",
  "ROTATE",
  "BinaryOperand",
  "BinaryOperand",
  "SCANTYPE",
  "INSTCTRL",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP"
};

/*
  errOutput() - writes an error to standard out and to a log file.  the
  log file is always opened and closes in order to avoid file corruption
  by an application gone wild.
*/
static void errOutput( char * );
static void errOutput( char * msg )
{
  static  int firsttime = 1;
  FILE  * fp;

  printf("%s", msg);
  fp = fopen ("compfont.err", (firsttime ? "w" : "a"));
  if (fp)
  {
	fprintf (fp, "%s", msg);
	fclose (fp);
  }
  firsttime = 0;
  return;
}

/*
  errPrint() - used to generate a useful (?) error message based on the 
  error 'flag' and the parameters ('v1..v4').
*/
static void errPrint (int, long, long, long, long);
static void errPrint (int flag, long v1, long v2, long v3, long v4)
{
  char   msg[ERR_MAX_MSG];
  char * opcodeName;
  char   c;
  int    i;

/*
  build the context line.  it indicates the file being processed, the point
  size, the character code (or glyph index), as well as the releative inst 
  number of this instruction for this code.
*/
  i  = sprintf (msg,   "\n*** ERROR*** ");
  i += sprintf (msg+i, "\"%s\", ", errFname);
  i += sprintf (msg+i, "%hd Point, ", errSize);
  i += sprintf (msg+i, "Code %hd (0x%hX), ", errCode, errCode);
  i += sprintf (msg+i, "Inst: #%ld\n", errInstCount);

/*
  build the error line.  it indicates the name of the instruction followed
  by the actual error information.  note: finding the actual opcode name
  for some the instructions is sorta kludgy.  names like "SetLocalGraphicState",
  and "BinaryOperand" are not actual instructions.  In these cases, look to
  the second character of the name - if it is lower case, then we need to 
  work a little harder, so look to 'errOpName' (which should be set by this
  point) it should contain the correct instruction name.
*/
  c = *(errOpcs[errOpc]+1);
  opcodeName =(islower(c) && strlen(errOpName)) ? errOpName : errOpcs[errOpc];
  i += sprintf (msg+i, "(%s) ", opcodeName);
  errOpName[0] = '\0';

/*
  output what you have so far and then process the error
*/
  errOutput (msg);
  switch (flag)
  {
	case ERR_RANGE:
	  sprintf (msg, "Value out of range: value = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ASSERTION:
	  sprintf (msg, "Assertion check failed\n"); 
	  break;
	case ERR_CVT:
	  sprintf (msg, "CVT out of range: CVT = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_FDEF:
	  sprintf (msg, "FDEF out of range: FDEF = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ELEMENT:
	  sprintf (msg, "Element %ld exceeds max elements (%ld)\n", v1, v2, v3); 
	  break;
	case ERR_CONTOUR:
	  i = sprintf (msg, "CONTOUR out of range: ");
	sprintf (msg+i, "CONTOUR = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_POINT:
	  i = sprintf (msg, "POINT out of range: ");
	sprintf (msg+i, "POINT = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_INDEX:
	  i = sprintf (msg, "POINT 0x%lX is neither element[0] ", v1);
	  sprintf( msg+i, "(0x%lX) nor element[1] (0x%lX)\n", v2, v3); 
	  break;
	case ERR_STORAGE:
	  i = sprintf (msg, "Storage index out of range: ");
	sprintf (msg+i, "Index = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_STACK:
	  i = sprintf (msg, "Stack pointer out of range: ");
	sprintf (msg+i, "Pointer = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_VECTOR:
	  sprintf (msg, "Illegal (x.y) vector: (%ld.%ld)\n", v1, v2); 
	  break;
	case ERR_LARGER:
	  sprintf (msg, "Value too small: %ld is not larger than %ld\n", v2, v1); 
	  break;
	case ERR_INT8:
	  sprintf (msg, "Value too large: 0x%lX exceeds 1 byte capacity\n", v1);
	  break;
	case ERR_INT16:
	  sprintf (msg, "Value too large: 0x%lX exceeds 2 byte capacity\n", v1);
	  break;
	case ERR_SCANMODE:
	  sprintf (msg, "Invalid scan mode: %ld\n", v1);
	  break;
	case ERR_SELECTOR:
	  sprintf (msg, "Invalid scan value: %ld\n", v1);
	  break;
	case ERR_STATE:
	  i = sprintf (msg, "Boundry limit error: xmin = ");
	  sprintf (msg+1, "%ld, xmax = %ld, ymin = %ld, ymax = %ld\n",
				v1, v2, v3, v4); 
	  break;
	case ERR_GETSINGLEWIDTHNIL:
	  sprintf (msg, "Sanity: Single width is nil\n");
	  break;
	case ERR_GETCVTENTRYNIL:
	  sprintf (msg, "Sanity: CVT Entry is nil\n");
	  break;
	case ERR_INVOPC:
	  sprintf (msg, "Invalid opcode: %ld\n", v1);
	  break;
	case ERR_UNBALANCEDIF:
	  sprintf (msg, "Unbalanced: missing %s instruction\n",
				( v1 > 0 ) ? "EIF" : "IF" );
	  break;
	default:
	  sprintf (msg, "Unknown Error:\n");
	  break;
  }

/*
  output the rest and return
*/
  errOutput (msg);
  return;
}

/*
  fnterr_Context() - called before any other fnterr routine.  it records
  the job name, character size and character code / glyph index.
*/
void fnterr_Context (int sw, char * str, unsigned short sz, unsigned short cd)
{
/*
  record a piece of the context
*/
  switch (sw)
  {
	case ERR_CONTEXT_FILE:
	  strncpy ( errFname, str, ERR_MAX_FNAME);
	  errFname[ERR_MAX_FNAME-1] = '\0';
	  break;
	case ERR_CONTEXT_SIZE:
	  errSize = sz;
	  break;
	case ERR_CONTEXT_CODE:
	  errCode = cd;
	  break;
  }

/*
  reset errOpName to be NULL before we start any real processing
*/
  errOpName[0] = '\0';
  return;
}

/*
  fnterr_Start() - called before the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it resets the instruction count to zero, and errBreak
  to 0 (ie: don't break out of execution loop).  set up IF/EIF counter for
  this level.
*/
void fnterr_Start (void)
{
  errInstCount = 0L;
  errBreak = 0;

  if (errIfOk && (++errIfNdx < ERR_MAX_IFS ))
	errIfs[errIfNdx] = 0;
  else
	errIfOk = 0;

  return;
}

/*
  fnterr_Record() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it increments the instruction count, and resets
  the opcode number.  IFs or EIFs are accounted for. (note: other IFs and
  EIFs will be accounted for by calls to ERR_IF() in fnt.c)
*/
void fnterr_Record (int opc)
{
  errInstCount++;
  errOpc = opc;

  if (!strcmp ("IF", errOpcs[errOpc]))
	fnterr_If (1);
  else if (!strcmp ("EIF", errOpcs[errOpc]))
	fnterr_If (-1);

  return;
}

/*
  fnterr_Report() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it calls errPrint() (with the passed parameters)
  to note the error, and sets errBreak so that the execution loop will end.
*/
void fnterr_Report (int flag, long v1, long v2, long v3, long v4)
{
  errPrint (flag, v1, v2, v3, v4);
  errBreak = 1;
  return;
}

/*
  fnterr_Break() - returns the value of errBreak.  if a non-zero valid is
  returned (re: fnterr_Report()), the main execute loop of fnt_Execute()
  or fnt_TraceExecute() will terminate.
*/
int fnterr_Break (void)
{
  return (errBreak);
}

/*
  fnterr_Opc() - called by combinate fnt calls to indicate the actual
  opcode errGet() can use.  this is a kludgy way to get around the non
  real opcode name in the errOpcs[] table.
*/
void fnterr_Opc (char *opc)
{
  strcpy (errOpName, opc);
  return;
}

/*
  fnterr_End() - called after the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it checks for balanced IF/EIF pairs.
*/
void fnterr_End (void)
{
  if (errIfOk)
  {
	if (errIfs[errIfNdx])
	  errPrint (ERR_UNBALANCEDIF, (long)errIfs[errIfNdx], 0L, 0L, 0L);
	if (--errIfNdx < 0)
	  errIfOk = 0;
  }
  return;
}

/*
  fnterr_If() - records IF/EIF activity inside of fnt_IF(), fnt_ELSE() and
  fnt_EIF() (re: fnt.c).
*/
void fnterr_If (int val)
{
  if (errIfOk)
	errIfs[errIfNdx] += val;
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fontmath.h ===
/*
		File:           fontmath.h

		Contains:       xxx put contents here xxx

		Written by:     xxx put writers here xxx

		Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.
						(c) 1989-1997. Microsoft Corporation, all rights reserved.

		Change History (most recent first):

				  <>     2/21/97		CB				ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
				 <4>    11/27/90        MR              make pascal declaration a macro, conditionalize traps -vs-
																		externs for Fix/Frac math routines. [ph]
				 <3>     11/5/90        MR              Move [U]SHORTMUL into fscdefs.h Rename FixMulDiv to LongMulDiv.
																		[rb]
				 <2>    10/20/90        MR              Add some new math routines (stolen from skia). [rj]
				 <1>     4/11/90        dba             first checked in

		To Do:
*/
#ifdef __cplusplus
extern "C" {
#endif

#define HIWORDMASK              0xffff0000
#define LOWORDMASK              0x0000ffff
#define DOT6ONEHALF             0x00000020
#define ONESHORTFRAC            (1 << 14)

#define ROUNDFIXTOINT( x )      (int16)((((Fixed) x) + ONEHALFFIX) >> 16)
#define ROUNDFIXED( x )         (((x) + (Fixed)ONEHALFFIX) & (Fixed)HIWORDMASK)
#define DOT6TOFIX(n)            ((Fixed) (n) << 10)
#define FIXEDTODOT6(n)          (F26Dot6) (((n) + ((1) << (9))) >> 10)
#define INTTOFIX(n)             ((Fixed) (n) << 16)
#define INTTODOT6(n)            ((F26Dot6) (n) << 6)
#define FS_HIWORD(n)            ((uint16)((uint32)(n) >> 16))
#define FS_LOWORD(n)            ((uint16)(n))
#define LOWSIXBITS              0x3F


#ifndef __TOOLUTILS__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul(Fixed,Fixed)   FS_MAC_TRAP(0xA868);
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB);
#endif

#ifndef __FIXMATH__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv(Fixed,Fixed)  FS_MAC_TRAP(0xA84D);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul(Fract,Fract) FS_MAC_TRAP(0xA84A);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv(Fract,Fract) FS_MAC_TRAP(0xA84B);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt(Fract)      FS_MAC_TRAP(0xA849);
#endif


ShortFract      TMP_CONV NEAR ShortFracDot (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR ShortFracMul (F26Dot6 x, ShortFract y);
ShortFract      TMP_CONV NEAR ShortFracDiv (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR Mul26Dot6 (F26Dot6 a, F26Dot6 b);
F26Dot6         TMP_CONV NEAR Div26Dot6 (F26Dot6 num, F26Dot6 den);
int16           TMP_CONV NEAR MulDivShorts (int16 x, int16 y, int16 z);


#define MulDiv26Dot6(a,b,c) LongMulDiv(a,b,c)

int32 LongMulDiv(int32 a, int32 b, int32 c);     /* (a*b)/c */

int32 ShortMulDiv(int32 a, int16 b, int16 c);     /* (a*b)/c */

ShortFract ShortFracMulDiv(ShortFract,ShortFract,ShortFract);

void mth_FixXYMul (Fixed* x, Fixed* y, transMatrix* matrix);
void mth_FixVectorMul (vectorType* v, transMatrix* matrix);

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix* matrixA, transMatrix* matrixB);

/*
 * scales a matrix by sx and sy.
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB);

boolean mth_IsMatrixStretched (transMatrix*trans);

boolean mth_Identity (transMatrix *matrix);
boolean mth_PositiveSquare (transMatrix *matrix);
boolean mth_PositiveRectangle (transMatrix *matrix);

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix);

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY);

boolean mth_GeneralRotation (transMatrix *matrix);
uint16 mth_90degRotationFactor (transMatrix *matrix);
uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix);
uint16 mth_90degClosestRotationFactor (transMatrix *matrix);
void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching);

int32 mth_CountLowZeros (uint32 n );
Fixed mth_max_abs (Fixed a, Fixed b);

int32 mth_GetShift (uint32 n);

void mth_ReduceMatrix(transMatrix *trans);

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch);

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans);

/*********************************************************************/

/*  Scan Converter Math Functions Appended for now         <5> DeanB */

/*********************************************************************/

int32 PowerOf2(
		int32                   /* + or - 32 bit value */
);

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor);
FS_PUBLIC int32 mth_DivShiftLong(int32 sValue, int16 sFactor);

/*********************************************************************/
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fontmath.c ===
/*
	File:       FontMath.c

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		  <>     2/21/97	CB		ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
		 <3>     11/9/90    MR      Fix CompDiv when numer and denom have zero hi longs. [rb]
		 <2>     11/5/90    MR      Remove Types.h from include list, rename FixMulDiv to LongMulDiv
									[rb]
		 <1>    10/20/90    MR      Math routines for font scaler. [rj]

	To Do:
*/

// Has anybody ever thought of replacing some of the 64bit arithmetic in here (and probably in other places)
// by "native" __int64 arithmetic, at least in the INTEL case? Could be faster, since the compiler gets to do
// the inline code, and would be ready for future 64bit architectures. Just a thought. B.St.

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fserror.h"
#include "fontmath.h"

#define HIBITSET                      0x80000000UL
#define POSINFINITY               0x7FFFFFFFUL
#define NEGINFINITY               0x80000000UL
#define POINTSPERINCH               72
#define ALMOSTZERO 33
#define ISNOTPOWEROF2(n)        ((n) & ((n)-1))
#define CLOSETOONE(x)   ((x) >= ONEFIX-ALMOSTZERO && (x) <= ONEFIX+ALMOSTZERO)
#define MAKEABS(x)  if (x < 0) x = -x
#define FXABS(x)  ((x) >= 0L ? (x) : -(x))
#define FRACT2FIX(n)    (((n) + (1 << (sizeof (Fract) - 3))) >> 14)

#define FASTMUL26LIMIT      46340
#define FASTDIV26LIMIT  (1L << 25)

#define USHORTMUL(a, b) ((uint32)((uint32)(uint16)(a)*(uint32)(uint16)(b)))

boolean mth_Max45Trick (Fixed x, Fixed y);

/*******************************************************************/

/* local prototypes */

void CompMul(int32 src1, int32 src2, int32 dst[2]);

int32 CompDiv(int32 src1, int32 src2[2]);

/*******************************************************************/

#ifndef CompMul

void CompMul(int32 lSrc1, int32 lSrc2, int32 alDst[2])
{
	boolean     bNegative;
	uint32      ulDstLo;
	uint32      ulDstHi;
	uint16      usSrc1lo;
	uint16      usSrc1hi;
	uint16      usSrc2lo;
	uint16      usSrc2hi;
	uint32      ulTemp;

	bNegative = (lSrc1 ^ lSrc2) < 0;

	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}
	if (lSrc2 < 0)
	{
		lSrc2 = -lSrc2;
	}

	usSrc1hi = (uint16)(lSrc1 >> 16);
	usSrc1lo = (uint16)lSrc1;
	usSrc2hi = (uint16)(lSrc2 >> 16);
	usSrc2lo = (uint16)lSrc2;
	ulTemp   = (uint32)usSrc1hi * (uint32)usSrc2lo + (uint32)usSrc1lo * (uint32)usSrc2hi;
	ulDstHi  = (uint32)usSrc1hi * (uint32)usSrc2hi + (ulTemp >> 16);
	ulDstLo  = (uint32)usSrc1lo * (uint32)usSrc2lo;
	ulTemp <<= 16;
	ulDstLo += ulTemp;
	ulDstHi += (uint32)(ulDstLo < ulTemp);

	if (bNegative)
	{
		ulDstLo = (uint32)-((int32)ulDstLo);

		if (ulDstLo != 0L)
		{
			ulDstHi = ~ulDstHi;
		}
		else
		{
			ulDstHi = (uint32)-((int32)ulDstHi);
		}
	}

	alDst[0] = (int32)ulDstHi;
	alDst[1] = (int32)ulDstLo;
}
#endif

/*******************************************************************/

#ifndef CompDiv

int32 CompDiv(int32 lSrc1, int32 alSrc2[2])
{
	boolean     bNegative;
	uint32      ulSrc1Lo;
	uint32      ulSrc1Hi;
	uint32      ulSrc2Lo;
	uint32      ulSrc2Hi;
	uint32      ulResult;
	uint32      ulPlace;

	int32    lResult;

	ulSrc2Hi = (uint32)alSrc2[0];
	ulSrc2Lo = (uint32)alSrc2[1];

	bNegative = ((int32)ulSrc2Hi ^ lSrc1) < 0;

	if ((int32)ulSrc2Hi < 0L)
	{
		ulSrc2Lo = (uint32)-((int32)ulSrc2Lo);

		if (ulSrc2Lo != 0L)
		{
			ulSrc2Hi = ~ulSrc2Hi;
		}
		else
		{
			ulSrc2Hi = (uint32)-((int32)ulSrc2Hi);
		}
	}
	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}

	ulResult = 0;
	ulPlace = HIBITSET >> 1;

	ulSrc1Hi = (uint32)lSrc1;

	if (ulSrc1Hi & 1)
	{
		ulSrc1Lo = HIBITSET;
	}
	else
	{
		ulSrc1Lo = 0;
	}

	ulSrc1Hi >>= 1;
	ulSrc2Lo += ulSrc1Hi;
	ulSrc2Hi += (uint32)(ulSrc2Lo < ulSrc1Hi);      /* round the result */

	if (ulSrc2Hi > ulSrc1Hi || ulSrc2Hi == ulSrc1Hi && ulSrc2Lo >= ulSrc1Lo)
	{
		if (bNegative)
		{
			return (int32)NEGINFINITY;
		}
		else
		{
			return (int32)POSINFINITY;
		}
	}

	while (ulPlace && ulSrc2Hi)
	{
		ulSrc1Lo >>= 1;
		if (ulSrc1Hi & 1)
		{
			ulSrc1Lo += HIBITSET;
		}
		ulSrc1Hi >>= 1;
		if (ulSrc1Hi < ulSrc2Hi)
		{
			/* 64 bit subtract */
			ulSrc2Hi -= ulSrc1Hi;
			ulSrc2Hi -= (uint32)(ulSrc1Lo > ulSrc2Lo);
			ulSrc2Lo -= ulSrc1Lo;

			ulResult += ulPlace;
		}
		else if (ulSrc1Hi == ulSrc2Hi && ulSrc1Lo <= ulSrc2Lo)
		{
			ulSrc2Hi = 0;
			ulSrc2Lo -= ulSrc1Lo;
			ulResult += ulPlace;
		}
		ulPlace >>= 1;
	}
	if (ulSrc2Lo >= (uint32)lSrc1)   /* Assert(lSrc1 >= 0)   */
	{
		ulResult += ulSrc2Lo/(uint32)lSrc1;
	}
	if (bNegative)
	{
		lResult = -((int32)ulResult);
	}
	else
	{
		lResult = (int32)ulResult;
	}
	return lResult;
}
#endif

/*******************************************************************/

/*
 *  a*b/c
 */
int32 LongMulDiv(int32 a, int32 b, int32 c)
{
	int32 temp[2];

	 CompMul(a, b, temp);
	return CompDiv(c, temp);
}

/*******************************************************************/

F26Dot6 ShortFracMul (F26Dot6 aDot6, ShortFract b)
{
	int32       lTemp[2];
	uint32      ulLow;
	F26Dot6     fxProduct;

	CompMul(aDot6, b, lTemp);

	ulLow = (((uint32)lTemp[1]) >> 13) + 1;           /* rounds up */
	fxProduct = (F26Dot6)(lTemp[0] << 18) + (F26Dot6)(ulLow >> 1);

	return (fxProduct);
}

/*******************************************************************/

ShortFract ShortFracDot (ShortFract a, ShortFract b)
{
	return (ShortFract)((((int32)a * (int32)b) + (1L << 13)) >> 14);
}


int32 ShortMulDiv(int32 a, int16 b, int16 c)
{
	return LongMulDiv(a, (int32)b, (int32)c);
}

int16 MulDivShorts (int16 a, int16 b, int16 c)
{
	return (int16)LongMulDiv((int32)a, (int32)b, (int32)c);
}

/*
 *  Total precision routine to multiply two 26.6 numbers        <3>
 */
F26Dot6 Mul26Dot6(F26Dot6 a, F26Dot6 b)
{
	 int32 negative = false;
	uint16 al, bl, ah, bh;
	uint32 lowlong, midlong, hilong;

	if ((a <= FASTMUL26LIMIT) && (b <= FASTMUL26LIMIT) && (a >= -FASTMUL26LIMIT) && (b >= -FASTMUL26LIMIT))
		  return (F26Dot6)((int32)(a * b + (1 << 5)) >> 6);                            /* fast case */

	if (a < 0) { a = -a; negative = true; }
	if (b < 0) { b = -b; negative ^= true; }

	 al = FS_LOWORD(a); ah = FS_HIWORD(a);
	 bl = FS_LOWORD(b); bh = FS_HIWORD(b);

	midlong = USHORTMUL(al, bh) + USHORTMUL(ah, bl);
	 hilong = USHORTMUL(ah, bh) + (uint32)FS_HIWORD(midlong);
	midlong <<= 16;
	midlong += 1 << 5;
	lowlong = USHORTMUL(al, bl) + midlong;
	hilong += (uint32)(lowlong < midlong);

	midlong = (lowlong >> 6) | (hilong << 26);
	if( negative)
	{
		return  (F26Dot6)-((int32)midlong);
	}
	else
	{
		return (F26Dot6)midlong;
	}
}

/*
 *  Total precision routine to divide two 26.6 numbers          <3>
 */
F26Dot6 Div26Dot6(F26Dot6 num, F26Dot6 den)
{
	 int32 negative = false;
	uint32 hinum, lownum, hiden, lowden, result, place;

	if (den == 0L)
	{
		if (num < 0L )
		{
				return (F26Dot6)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	if ( (num <= FASTDIV26LIMIT) && (num >= -FASTDIV26LIMIT) )          /* fast case */
		  return (F26Dot6)(((int32)num << 6) / den);

	if (num < 0)
	{
		num = -num;
		negative = true;
	}
	if (den < 0)
	{
		den = -den;
		negative ^= true;
	}

	hinum = ((uint32)num >> 26);
	lownum = ((uint32)num << 6);
	hiden = (uint32)den;
	lowden = 0;
	result = 0;
	place = HIBITSET;

	if (hinum >= hiden)
	{
		if( negative )
		{
				return (F26Dot6)(uint32)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	while (place)
	{
		lowden >>= 1;
		if (hiden & 1)
		{
			lowden += HIBITSET;
		}
		hiden >>= 1;
		if (hiden < hinum)
		{
			hinum -= hiden;
			hinum -= (uint32)(lowden > lownum);
			lownum -= lowden;
			result += place;
		}
		else if (hiden == hinum && lowden <= lownum)
		{
			hinum = 0;
			lownum -= lowden;
			result += place;
		}
		place >>= 1;
	}

	if (negative)
	{
		return (F26Dot6)-((int32)result);
	}
	else
	{
		return (F26Dot6)result;
	}
}

ShortFract ShortFracDiv(ShortFract num,ShortFract denum)
{
	return (ShortFract)(((int32)(num) << 14) / (int32)denum);
}

ShortFract ShortFracMulDiv(ShortFract numA,ShortFract numB,ShortFract denum)
{
	return (ShortFract) LongMulDiv ((int32) numA,(int32) numB, (int32)denum);
}

/* ------------------------------------------------------------ */

#ifndef FSCFG_USE_EXTERNAL_FIXMATH
/*  Here we define Fixed [16.16] and Fract [2.30] precision 
 *  multiplication and division functions and a Fract square root 
 *  function which are compatible with those in the Macintosh toolbox.
 *
 *  The division functions load the 32-bit numerator into the "middle"
 *  bits of a 64-bit numerator, then call the 64-bit by 32-bit CompDiv()
 *  function defined above, which can return a NEGINFINITY or POSINFINITY
 *  overflow return code.
 *
 *  The multiply functions call the 32-bit by 32-bit CompMul() function
 *  defined above which produces a 64-bit result, then they extract the
 *  "interesting" 32-bits from the middle of the 64-bit result and test 
 *  for overflow.
 *
 *  The GET32(a,i) macro defined below extracts a 32-bit value with "i" 
 *  bits of fractional precision from the 64-bit value in "a", a 2-element
 *  array of longs.
 *
 *  The CHKOVF(a,i,v) macro tests the most significant bits of the 
 *  64-bit value in "a", a 2-element array of longs, and tests the 
 *  32-bit result "v" for overflow.  "v" is defined as having "i" bits
 *  of fractional precision.
 *
 *  BIT() and OVFMASK() are "helper" macros used by GET32() and CHKOVF().
 *
 *  BIT(i) returns a mask with the "i"-th bit set.
 *  OVFMASK(i) returns a mask with the most-significant "32-i" bits set.
 */

#define BIT(i)          (1L<<(i))
#define OVFMASK(i)   ( ~0L ^ ( ((uint32)BIT(i)) - 1 ) )
#define CHKOVF(a,i,v)   (\
		( ((uint32)(a)[0] & OVFMASK(i))==0)          ? ( (v)>=0 ?(v) :POSINFINITY) : \
		( ((uint32)(a)[0] & OVFMASK(i))==OVFMASK(i)) ? ( (v)<=0 ?(v) :NEGINFINITY) : \
		( ((uint32)(a)[0] & BIT(31))                 ? POSINFINITY   :NEGINFINITY)   \
	)
#define GET32(b,a,i) \
((((a)[0]<<(32-(i))) | (int32)((uint32)((a)[1])>>(i))) + \
(int32)!!( ((a)[1] & BIT((i)-1))  && ( b ? ( ( ((a)[1] & ~OVFMASK(i-1) )) & ~OVFMASK(i-1) ) : TRUE ) ) )

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul (Fixed fxA, Fixed fxB)
{
 	int32 alCompProd[2];
	Fixed fxProd;
	int  bNegative=FALSE;

	if  (fxA == 0 || fxB == 0)
		return 0;

	if( ((fxA > 0) && (fxB < 0)) || ((fxA < 0) && (fxB > 0)) )
		bNegative = TRUE;

        CompMul ((int32)fxA, (int32)fxB, alCompProd);

	fxProd = (Fixed)GET32 (bNegative,alCompProd,16);

	return (Fixed)CHKOVF(alCompProd,16,fxProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv (Fixed fxA, Fixed fxB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = fxA >> 16;
	alCompProd[1] = fxA << 16;

	return CompDiv ((int32)fxB, alCompProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = ((int32)(sA)) >> 16;
	alCompProd[1] = ((int32)(sA)) << 16;

	return CompDiv ((int32)(sB), alCompProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul (Fract frA, Fract frB)
{
	int32 alCompProd[2];
	Fract frProd;
	int  bNegative=FALSE;

	if  (frA == 0 || frB == 0)
		return 0;

	if( ((frA > 0) && (frB < 0)) || ((frA < 0) && (frB > 0)) )
		bNegative = TRUE;

        CompMul (frA,frB,alCompProd);
	frProd = (Fract)GET32 (bNegative,alCompProd,30);

	return (Fract)CHKOVF(alCompProd,30,frProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv (Fract frA, Fract frB)
{
	int32 alCompProd[2];

	alCompProd[0] = frA >> 2;
	alCompProd[1] = frA << 30;
	return CompDiv ((int32)frB, alCompProd);
}

/*******************************************************************/

#ifndef FracSqrt

/* 
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt (Fract xf)
{
	Fract b = 0L;
	uint32 c, d, x = xf;
	
	if (xf < 0) return (NEGINFINITY);

	/*
	The algorithm extracts one bit at a time, starting from the
	left, and accumulates the square root in b.  The algorithm 
	takes advantage of the fact that non-negative input values
	range from zero to just under two, and corresponding output
	ranges from zero to just under sqrt(2).  Input is assigned
	to temporary value x (unsigned) so we can use the sign bit
	for more precision.
	*/
	
	if (x >= 0x40000000)
	{
		x -= 0x40000000; 
		b  = 0x40000000; 
	}

	/*
	This is the main loop.  If we had more precision, we could 
	do everything here, but the lines above perform the first
	iteration (to align the 2.30 radix properly in b, and to 
	preserve full precision in x without overflow), and afterward 
	we do two more iterations.
	*/
	
	for (c = 0x10000000; c; c >>= 1)
	{
		d = b + c;
		if (x >= d)
		{
			x -= d; 
			b += (c<<1); 
		}
		x <<= 1;
	}

	/*
	Iteration to get last significant bit.
	
	This code has been reduced beyond recognition, but basically,
	at this point c == 1L>>1 (phantom bit on right).  We would
	like to shift x and d left 1 bit when we enter this iteration,
	instead of at the end.  That way we could get phantom bit in
	d back into the word.  Unfortunately, that may cause overflow
	in x.  The solution is to break d into b+c, subtract b from x,
	then shift x left, then subtract c<<1 (1L).
	*/
	
	if (x > (uint32)b) /* if (x == b) then (x < d).  We want to test (x >= d). */
	{
		x -= b;
		x <<= 1;
		x -= 1L;
		b += 1L; /* b += (c<<1) */
	}
	else
	{
		x <<= 1;
	}

	/* 
	Final iteration is simple, since we don't have to maintain x.
	We just need to calculate the bit to the right of the least
	significant bit in b, and use the result to round our final answer.
	*/
	
	return ( b + (Fract)(x>(uint32)b) );
}

#endif  /* FracSqrt */

/*******************************************************************/

#endif


/* TRANSFORMATION ROUTINES */

/*
 *  Good for transforming fixed point values.  Assumes NO translate  <4>
 */
void mth_FixXYMul (Fixed*x, Fixed*y, transMatrix*matrix)
{
  Fixed xTemp, yTemp;
  Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);
  *y = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);

#ifndef PC_OS   /* Never a perspecitive with Windows */ /* !!!DISCUSS   */

  if (*m0 || *m1)     /* these two are Fracts */
  {
	Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
	tmp += matrix->transform[2][2];
	if (tmp && tmp != ONEFIX)
	{
	  *x = FixDiv (*x, tmp);
	  *y = FixDiv (*y, tmp);
	}
  }
#endif
}


/*
 *  This could be faster        <4>
 */
void mth_FixVectorMul (vectorType*v, transMatrix*matrix)
{
  mth_FixXYMul (&v->x, &v->y, matrix);
}


/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix*A, transMatrix*B)
{
  Fixed storage[6];
  Fixed * s = storage;
  int32 i, j;

  for (j = 0; j < 2; j++)
	for (i = 0; i < 3; i++)
	  *s++ = FixMul (A->transform[j][0], B->transform[0][i]) + FixMul (A->transform[j][1], B->transform[1][i]);

  {
	Fixed*dst = &B->transform[2][0];
	Fixed*src = s;
	int16 i;
	for (i = 5; i >= 0; --i)
	  *--dst = *--src;
  }
}


/*
 * scales a matrix by sx and sy.
 *
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 *
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB)
{
  int32       i;
  Fixed  *m = (Fixed *) & matrixB->transform[0][0];

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sx, *m);

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sy, *m);
}


/*
 *  Return 45 degreeness
 */
#ifndef PC_OS   /* !!!DISCUSS   */
boolean mth_Max45Trick (Fixed x, Fixed y)
{
  MAKEABS (x);
  MAKEABS (y);

  if (x < y)      /* make sure x > y */
  {
	Fixed z = x;
	x = y;
	y = z;
  }

  return  (x - y <= ALMOSTZERO);
}
#else
  #define mth_Max45Trick(x,y)     (x == y || x == -y)
#endif


/*
 *  Sets bPhaseShift to true if X or Y are at 45 degrees, flaging the outline
 *  to be moved in the low bit just before scan-conversion.
 *  Sets [xy]Stretch factors to be applied before hinting.
 *  Returns true if the contours need to be reversed.
 */
boolean mth_IsMatrixStretched (transMatrix*trans)
{
  Fixed*matrix = &trans->transform[0][0];
  Fixed x, y;
  int32 i;
  boolean   bPhaseShift;

  bPhaseShift = FALSE;

  for (i = 0; i < 2; i++, matrix++)
  {
	x = *matrix++;
	y = *matrix++;
	bPhaseShift |= mth_Max45Trick (x, y);
  }
  return( bPhaseShift );
}


/*
 * Returns true if we have the identity matrix.
 */

boolean mth_PositiveSquare (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] >= 0);
}

boolean mth_Identity (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] == ONEFIX);
}


boolean mth_PositiveRectangle (transMatrix *matrix)
{
	 return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] >= 0 && matrix->transform[1][1] >= 0);
}

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix)
{
	return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && FXABS(matrix->transform[0][0]) == FXABS(matrix->transform[1][1]) && FXABS(matrix->transform[0][0]) == ONEFIX);
}

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY)
{
	return(fxScaleX == fxScaleY);
}

boolean mth_GeneralRotation (transMatrix *matrix)
{
  return ((matrix->transform[0][0] || matrix->transform[1][1]) && (matrix->transform[1][0] || matrix->transform[0][1]));
}

/* for a rotation that is a multiple of 90 degrees, return the multiplier factor */
/* for non 90 degree rotations, return 4  (this is used for sbit rotations) */

uint16 mth_90degRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
    	if (matrix->transform[0][0] > 0 && matrix->transform[1][1] > 0)
            return (0);
    	else if (matrix->transform[0][0] < 0 && matrix->transform[1][1] < 0)
            return (2);
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0 && matrix->transform[0][1] > 0)
            return (1);
       	else if (matrix->transform[1][0] > 0 && matrix->transform[0][1] < 0)
            return (3);
	}
    return (4);                 /* non 90 degree rotation */
}

uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
		if (matrix->transform[0][0] > 0){
			if(matrix->transform[1][1] > 0)
				return (0);	// 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			else
				return (4); // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
		}
		else if (matrix->transform[0][0] < 0){
			if(matrix->transform[1][1] < 0)
				return (2); // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			else
				return (6); // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
		}
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0){
			if(matrix->transform[0][1] > 0)
				return (1); // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			else
				return (7); // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
		}
       	else if (matrix->transform[1][0] > 0){
			if(matrix->transform[0][1] < 0)
				return (3); // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			else
				return (5); // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
		}
	}
    return (8);                 /* non 90 degree rotation */
}

/* This is for Italic simulation.

/* return values with non-vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	0				4				6				2
90  degree	1				5				7				3
180 degree	2				6				4				0
270 degree	3				7				5				1

/* return values with vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	1				7				5				3
90  degree	2				4				6				0
180 degree	3				5				7				1
270 degree	0				6				4				2
*/

uint16 mth_90degClosestRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
        matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (0); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] == 0 ) 
        return (1); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (2); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] ==  0 ) 
        return (3); 
	else if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
			 matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (4); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] == 0 ) 
        return (5); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (6); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] ==  0 ) 
        return (7); 
    // anything else
    else
        return (8); 
}

void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching) {
	Fixed Xx,Xy,Yx,Yy;

	// first, we apply the matrix to the base vectors X = (1, 0) and Y = (0, 1)
	// this seemingly trivial step tends to be a hidden trap because there are two ways to apply a matrix to a vector, prefix and postfix.
	// in the rasterizer we seem to apply matrices as postfix operators, i.e.
	//
	//          (a00 a01)
	// (x, y) * (       ) = (a00*x + a10*y, a01*x + a11*y)
	//          (a10 a11)
	//
	//   apply to X = (1, 0)           apply to Y = (0, 1)
	Xx = matrix->transform[0][0]; Yx = matrix->transform[1][0];
	Xy = matrix->transform[0][1]; Yy = matrix->transform[1][1];

	// then we test whether the transformation shears the coordinates
	// if so, the transformed base vectors are no longer perpendicular, so we test their dot product against 0
	// notice that due to the limited precision of the fixed point representation , we may introduce a numerical error in general. 	
	// however, we're interested in identifying special cases like multiples of 90 rotations, for which one of the components
	// of the transformed vectors will be 0, hence the dot product should be accurate in these cases.
	if (FixMul(Xx,Yx) + FixMul(Xy,Yy) == 0) { // we're perpendicular

		// next we analyze whether the transformation rotates by a multiple of 90 or not
		// rotations which are multiples of 90 have 0s in either both non-diagonal matrix elements or both diagonal matrix elements
		// notice that this analysis includes mirrorings in x or y, which are handled in much the same way
		*non90degreeRotation = !(Xx == 0 && Yy == 0 || Xy == 0 && Yx == 0);

		// finally we analyze whether the transformation stretches the coordinates uniformly or not
		// for uniform stretchings the transformed base vectors have the same lengths
		// notice again that due to limited precision we may introduce a numerical error which we can ignore for the same reasons
		*nonUniformStretching = FixMul(Xx,Xx) + FixMul(Xy,Xy) != FixMul(Yx,Yx) + FixMul(Yy,Yy);
	
	} else { // we're sheared
		
		// here, we analyze whether the transformation rotates the x-axis by a multiple of 90 or not
		// we do not consider the y-axis because we don't want to exclude italicized fonts
		// for a multiple of 90 rotation, the transformed base vector X is either [anti-]parallel or perpendicular to its original
		// to be perpendicular, its x-component must be 0, hence a00 = 0; to be [anti-]parallel, its y-component must be 0, hence a01 = 0
		*non90degreeRotation = !(Xx == 0 || Xy == 0);

		// finally, we need to know whether the transformation stretches the coordinates at all
		// we know already that the stretching is not uniform, except in the unlikely case that the transformation rotates the y-axis
		// relative to the x-axis, which is a combination of stretching in y (actually, squeezing) by a particular amount, followed by
		// shearing, which stretches the y-axis again. For the correct combination of squeezing and shearing, this yields a uniform
		// stretching. For italicizing characters, this is an unlikely scenario, as italics tend to have the same [x-]height as their
		// roman ancestors. Italicizing is achieved by a shearing without separate stretching, which is a much more likely scenario.
		// For the reasons of their likelyhood, we consider shearing a uniform stretching, but not the rotation of the y-axis. Further-
		// more, for the purpose of identifying special cases, we do so only for rotations by multiples of 90, and only if the area
		// of the parallelogram defined by the two transformed base vectors remains 1, which is what happens under shearing. The area
		// of the parallelogram equals the determinant of the matrix. All other cases are considered proper non-uniform stretchings.
		
		*nonUniformStretching = *non90degreeRotation || FixMul(Xx,Xx) + FixMul(Xy,Xy) != ONEFIX || FixMul(Xx,Yy) - FixMul(Xy,Yx) != ONEFIX;
	}

} // mth_Non90DegreeTransformation

/*
 * mth_GetShift
 * return 2log of n if n is a power of 2 otherwise -1;
 */
int32 mth_GetShift( uint32 n )
{
		if (ISNOTPOWEROF2(n) || !n)
				return -1;
		else
				return mth_CountLowZeros( n );
}

int32 mth_CountLowZeros( uint32 n )
{
		  int32 shift = 0;
		  uint32    one = 1;
		for (shift = 0; !( n & one ); shift++)
				n >>= 1;
		return shift;
}

Fixed mth_max_abs (Fixed a, Fixed b)
{
  if (a < 0)
	a = -a;
  if (b < 0)
	b = -b;
  return (a > b ? a : b);
}

/*
 *  Call this guy before you use the matrix.  He does two things:
 *      He folds any perspective-translation back into perspective,
 *       and then changes the [2][2] element from a Fract to a fixed.
 */
void mth_ReduceMatrix(transMatrix *trans)
{
	Fixed a, *matrix = &trans->transform[0][0];
	Fract bottom = matrix[8];

/*
 *  First, fold translation into perspective, if any.
 */
	a = matrix[2];

	if (a != 0)
	{
		matrix[0] -= LongMulDiv(a, matrix[6], bottom);
		matrix[1] -= LongMulDiv(a, matrix[7], bottom);
	}

	a = matrix[5];

	if (a != 0)
	{
		matrix[3] -= LongMulDiv(a, matrix[6], bottom);
		matrix[4] -= LongMulDiv(a, matrix[7], bottom);
	}
	matrix[6] = matrix[7] = 0;
	matrix[8] = FRACT2FIX(bottom);      /* make this guy a fixed for XYMul routines */
}

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch)

{
	Fixed   fxM00;
	Fixed   fxM01;
	Fixed   fxM10;
	Fixed   fxM11;
	Fixed   fxOrigX;
	Fixed   fxOrigY;

	if (fxXStretch == 0L || fxYStretch == 0L)
	{
		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			*fxY++ = 0;
			*fxX++ = 0;
		}
	}
	else
	{
		if(fxXStretch != ONEFIX)
		{
			fxM00 = FixDiv (trans->transform[0][0], fxXStretch);
			fxM01 = FixDiv (trans->transform[0][1], fxXStretch);
		}
		else
		{
			fxM00 = trans->transform[0][0];
			fxM01 = trans->transform[0][1];
		}

		if(fxYStretch != ONEFIX)
		{
			fxM10 = FixDiv (trans->transform[1][0], fxYStretch);
			fxM11 = FixDiv (trans->transform[1][1], fxYStretch);
		}
		else
		{
			fxM10 = trans->transform[1][0];
			fxM11 = trans->transform[1][1];
		}

		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			fxOrigX = *fxX;
			fxOrigY = *fxY;

			*fxX++ = (F26Dot6) (FixMul (fxM00, fxOrigX) + FixMul (fxM10, fxOrigY));
			*fxY++ = (F26Dot6) (FixMul (fxM01, fxOrigX) + FixMul (fxM11, fxOrigY));
		}
	}
}


/*
 *  Fold the point size and resolution into the matrix
 */

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans)
{
	Fixed fxScale;

	fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
	trans->transform[0][1] = FixMul( trans->transform[0][1], fxScale );
	trans->transform[1][1] = FixMul( trans->transform[1][1], fxScale );
	trans->transform[2][1] = FixMul( trans->transform[2][1], fxScale );

	fxScale = ShortMulDiv(fxPointSize, sXResolution, POINTSPERINCH);
	trans->transform[0][0] = FixMul( trans->transform[0][0], fxScale );
	trans->transform[1][0] = FixMul( trans->transform[1][0], fxScale );
	trans->transform[2][0] = FixMul( trans->transform[2][0], fxScale );
}


/*********************************************************************/

/*  Find the power of 2 greater than the absolute value of passed parameter  */

int32 PowerOf2(
		int32 lValue )
{
	static const int32 iTable[] = { 0, 1, 2, 2, 3, 3, 3, 3,
								  4, 4, 4, 4, 4, 4, 4, 4  };

	if (lValue < 0L)
	{
		lValue = -lValue;
	}

	if (lValue < (1L << 16))
	{
		if (lValue < (1L << 8))
		{
			if (lValue < (1L << 4))
			{
				return (iTable[lValue]);
			}
			else
			{
				return (iTable[lValue >> 4] + 4);
			}
		}
		else
		{
			if (lValue < (1L << 12))
			{
				return (iTable[lValue >> 8] + 8);
			}
			else
			{
				return (iTable[lValue >> 12] + 12);
			}
		}
	}
	else
	{
		if (lValue < (1L << 24))
		{
			if (lValue < (1L << 20))
			{
				return (iTable[lValue >> 16] + 16);
			}
			else
			{
				return (iTable[lValue >> 20] + 20);
			}
		}
		else
		{
			if (lValue < (1L << 28))
			{
				return (iTable[lValue >> 24] + 24);
			}
			else
			{
				return (iTable[lValue >> 28] + 28);
			}
		}
	}
}

/********************************************************************/

/* divide by shifting for translation invariant negatives */

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor)
{
	return (int16)mth_DivShiftLong((int32)sValue, sFactor);
}

FS_PUBLIC int32 mth_DivShiftLong(int32 lValue, int16 sFactor)
{
	switch (sFactor)
	{
	case 0:
	case 1:
		break;
	case 2:
		lValue >>= 1;
		break;
	case 4:
		lValue >>= 2;
		break;
	case 8:
		lValue >>= 3;
		break;
	default:
		if (lValue >= 0)
		{
			lValue /= (int32)sFactor;
		}
		else
		{
			lValue = ((lValue - (int32)sFactor + 1) / (int32)sFactor);
		}
		break;
	}
	return lValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fnterr.h ===
#ifndef _FNTERR_H
#define _FNTERR_H
/**********************************************************************
	
	fnterr.h -- Error Support Routines prototypes.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This header file provides prototypes for the fnterr.c 
	 source module.  This module keys on the #define FSCFG_FNTERR
	which is defined in fsconfig.h

	 7/28/92 dj         First cut.

 **********************************************************************/


#ifdef FSCFG_FNTERR

#define ERR_RANGE                 1
#define ERR_ASSERTION             2
#define ERR_CVT                   3
#define ERR_FDEF                  4
#define ERR_ELEMENT               5
#define ERR_INDEX                 6
#define ERR_STORAGE               7
#define ERR_STACK                 8
#define ERR_POINT                 9
#define ERR_POINT_TLP             10
#define ERR_POINT_PP              11
#define ERR_CONTOUR               12
#define ERR_VECTOR                13
#define ERR_LARGER                14
#define ERR_INT8                  15
#define ERR_INT16                 16
#define ERR_SCANMODE              17
#define ERR_SELECTOR              18
#define ERR_STATE                 19
#define ERR_GETSINGLEWIDTHNIL     20
#define ERR_GETCVTENTRYNIL        21
#define ERR_INVOPC                22
#define ERR_UNBALANCEDIF          23

#define ERR_CONTEXT_FILE          0
#define ERR_CONTEXT_SIZE          1
#define ERR_CONTEXT_CODE          2

#define ERR_CONTEXT(a,b,c,d)      fnterr_Context((a),(b),(c),(d))
#define ERR_START()               fnterr_Start()
#define ERR_RECORD(a)             fnterr_Record((int)(a))
#define ERR_REPORT(a,b,c,d,e)     fnterr_Report((int)(a),(long)(b),(long)(c),(long)(d),(long)(e))
#define ERR_BREAK()               { if ( fnterr_Break() ) break; }
#define ERR_OPC(a)                fnterr_Opc(a)
#define ERR_END()                 fnterr_End()
#define ERR_IF(a)                 fnterr_If(a)

void fnterr_Context (int, char *, unsigned short, unsigned short);
void fnterr_Start (void);
void fnterr_Record (int);
void fnterr_Report (int, long, long, long, long);
int  fnterr_Break (void);
void fnterr_Opc (char*);
void fnterr_End (void);
void fnterr_If (int);

#else

#define ERR_CONTEXT(a,b,c,d)
#define ERR_START()
#define ERR_RECORD(a)
#define ERR_REPORT(a,b,c,d,e)     DEBUGGER ()
#define ERR_BREAK()
#define ERR_OPC(a)
#define ERR_END()
#define ERR_IF(a)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fscaler.c ===
/*
	File:       FontScaler.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		<>      10/14/97    CB      move usOverScale to fs_NewTransformation
		<>       2/21/97    CB      no need to call pre-program if no hints (was causing div by zero)
		<>       1/10/97    CB      empty bitmap with bMatchBbox == TRUE causes crash
		<>      12/14/95    CB      add	usNonScaledAH to the private key
		<11>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
									and one (always fractional) metrics. [rb]
		<10>    11/21/90    RB      Allow client to disable DropOutControl by returning a NIL
									pointer to memoryarea[7]. Also make it clear that we inhibit
									DOControl whenever we band. [This is a reversion to 8, so mr's
									initials are added by proxy]
		 <9>    11/13/90    MR      (dnf) Revert back to revision 7 to fix a memmory-trashing bug
									(we hope). Also fix signed/unsigned comparison bug in outline
									caching.
		 <8>    11/13/90    RB      Fix banding so that we can band down to one row, using only
									enough bitmap memory and auxillary memory for one row.[mr]
		 <7>     11/9/90    MR      Add Default return to fs_dropoutval. Continue to fiddle with
									banding. [rb]
		 <6>     11/5/90    MR      Remove FixMath.h from include list. Clean up Stamp macros. [rb]
		 <5>    10/31/90    MR      Conditionalize call to ComputeMapping (to avoid linking
									MapString) [ha]
		 <4>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <3>    10/30/90    RB      [MR] Inhibit DropOutControl when Banding
		 <2>    10/20/90    MR      Restore changes since project died. Converting to smart math
									routines, integer ppem scaling. [rb]
		<16>     7/26/90    MR      don't include ToolUtils.h
		<15>     7/18/90    MR      Fix return bug in GetAdvanceWidth, internal errors are now ints.
		<14>     7/14/90    MR      remove unused fields from FSInfo
		<13>     7/13/90    MR      Ansi-C fixes, rev. for union in FSInput
		<11>     6/29/90    RB      Thus endeth the too long life of encryption
		<10>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <9>     6/21/90    RB      add scanKind info to fs_dropoutVal
		 <8>      6/5/90    MR      remove fs_MapCharCodes
		 <7>      6/1/90    MR      
		 <6>      6/1/90    RB      fixed bandingbug under dropout control
		 <4>      5/3/90    RB      added dropoutval function.  simplified restore outlines.
									support for new scanconverter in contourscan, findbitmapsize,
									saveoutlines, restoreoutlines.
		 <3>     3/20/90    CL      Changed to use fpem (16.16) instead of pixelsPerEm (int) Removed
									call to AdjustTransformation (not needed with fpem) Added call
									to RunXFormPgm Removed WECANNOTDOTHIS #ifdef Added
									fs_MapCharCodes
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409).  New
									CharToIndexMap Table format.
									Fixed transformed component bug.
	   <3.6>    11/15/89    CEL     Put an else for the ifdef WeCanNotDoThis so Printer compile
									could use more effecient code.
	   <3.5>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Now it is legal
									to pass in zero as the address of memory when a piece of the
									sfnt is requested by the scaler. If this happens the scaler will
									simply exit with an error code ! Five unnecessary element in the
									output data structure have been deleted. (All the information is
									passed out in the bitmap data structure) fs_FindBMSize now also
									returns the bounding box.
	   <3.4>     9/28/89    CEL     fs_newglyph did not initialize the output error. Caused routine
									to return error from previous routines.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Changed the NEED_PROTOTYPE ifdef to use the NOT_ON_THE_MAC flag
									that existed previously.
	   <3.1>     9/15/89    CEL     Changed dispatch scheme. Calling conventions through a trap
									needed to match Macintosh pascal. Pascal can not call C unless
									there is extra mucky glue. Bug that caused text not to appear.
									The font scaler state was set up correctly but the sfnt was
									purged. It was reloaded and the clientid changed but was still
									the same font. Under the rules of the FontScaler fs_newsfnt
									should not have to be called again to reset the state. The extra
									checks sent back a BAD_CLIENTID_ERROR so QuickDraw would think
									it was a bad font and not continue to draw.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.4>     8/17/89    sjk     Coded around MPW C3.0 bug
	   <2.3>     8/14/89    sjk     1 point contours now OK
	   <2.2>      8/8/89    sjk     Improved encryption handling
	   <2.1>      8/2/89    sjk     Fixed outline caching bug
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Conditionalized error checking in fs_SetUpKey.
									Compiler option for stamping memmory areas for debugging
									Removed error field from FSInfo structure.
									Added call to RunFontProgram
									Added private function prototypes.
									Optimizations from diet clinic

*/

/** FontScaler's Includes **/

#define FSCFG_INTERNAL

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"        /* For numeric conversion macros    */
#include "fnt.h"
#include "scentry.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "sbit.h"
#include "fscaler.h"         // moved this to be the last include file (key moved in dot h)


#include "stat.h"                   /* STAT timing card prototypes */
boolean gbTimer = FALSE;            /* set true when timer running */

#ifndef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/* new transformation parameters saved in the internal Key */
typedef struct fs_NewTrans {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			transMatrix     transformMatrix;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} fs_NewTrans;

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
	fs_NewTrans			SavedTransformInfo; /* saved transformation info */
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

/*  CONSTANTS   */

/* Change this if the format for cached outlines change. */
/* Someone might be caching old stuff for years on a disk */

#define OUTLINESTAMP 0x2D0CBBAD
#define OUTLINESTAMP2 0xA5

#define BITMAP_MEMORY_COUNT 4       /* now for gray scale we need 4 */

/* for the key->ulState field */
#define INITIALIZED 0x0000L
#define NEWSFNT     0x0002L
#define NEWTRANS    0x0004L
#define GOTINDEX    0x0008L
#define GOTGLYPH    0x0010L
#define SIZEKNOWN   0x0020L

#define STAMPEXTRA      4

/* 'sfnt' in ASCII  */
#define STAMP           0x73666E74

/*** Memory shared between all fonts and sizes and transformations ***/
#define KEY_PTR_BASE                0 /* Constant Size ! */
#define VOID_FUNC_PTR_BASE          1 /* Constant Size ! */
#define SCAN_PTR_BASE               2 /* Constant Size ! */
#define WORK_SPACE_BASE             3 /* size is sfnt dependent, can't be shared between grid-fitting and scan-conversion */
/*** Memory that can not be shared between fonts and different sizes, can not dissappear after InitPreProgram () ***/
#define PRIVATE_FONT_SPACE_BASE     4 /* size is sfnt dependent */
/* Only needs to exist when ContourScan is called, and it can be shared */
#define BITMAP_PTR_1                5 /* the bitmap - size is glyph size dependent */
#define BITMAP_PTR_2                6 /* size is proportional to number of rows */
#define BITMAP_PTR_3                7 /* used for dropout control - glyph size dependent */
#define BITMAP_PTR_4                8 /* used in gray scale for overscaled bitmap */

static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};


/* PRIVATE DEFINITIONS    */

FS_PRIVATE fs_SplineKey *  fs_SetUpKey (fs_GlyphInputType* inptr, uint32 ulStateBits, ErrorCode * error);
FS_PRIVATE void            fs_InitializeKey(fs_SplineKey * key);
FS_PRIVATE int32           fs__Contour (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE int32           fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE void            fs_SetState(fs_SplineKey * key, uint32 ulState);
FS_PRIVATE void            FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p);
FS_PRIVATE void            CHECKSTAMP (char * p);
FS_PRIVATE void            SETSTAMP (char * p);

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound, point *pf26DevAdvanceWidth );
FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound,
    point *pf26DevAdvanceHeight);

/* FUNCTIONS    */

FS_PRIVATE void SETSTAMP (char * p)
{
	* ((uint32 *) ((p) - STAMPEXTRA)) = STAMP;
}


FS_PRIVATE void CHECKSTAMP (char * p)
{
	if (* ((uint32 *) ((p) - STAMPEXTRA)) != STAMP)
	{
#ifdef  NOT_ON_THE_MAC
		Assert(FALSE);
#else
		DEBUGGER ();
#endif
	}
}


FS_PRIVATE void FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p)
{
	FS_UNUSED_PARAMETER(p);
}

FS_PRIVATE void   fs_SetState(fs_SplineKey * key, uint32 ulState)
{
	key->ulState = ulState;
}

/*
 *  Set up the key in case memmory has moved or been purged.
 */
FS_PRIVATE fs_SplineKey * fs_SetUpKey (
	fs_GlyphInputType * inptr,
	uint32              ulStateBits,
	ErrorCode *         error)
{
	fs_SplineKey *  key;

	key = (fs_SplineKey *)inptr->memoryBases[KEY_PTR_BASE];
	if (key == NULL)
	{
		*error = NULL_KEY_ERR;
		return 0;
	}

	key->memoryBases =                           inptr->memoryBases;
	if(key->memoryBases == NULL)
	{
		*error = NULL_MEMORY_BASES_ERR;
		return 0;
	}
	key->ClientInfo.GetSfntFragmentPtr =    inptr->GetSfntFragmentPtr;
	if(key->ClientInfo.GetSfntFragmentPtr == NULL)
	{
		*error = NULL_SFNT_FRAG_PTR_ERR;
		return 0;
	}

	key->ClientInfo.ReleaseSfntFrag = inptr->ReleaseSfntFrag;
	if (!(key->ClientInfo.ReleaseSfntFrag))
	{
		key->ClientInfo.ReleaseSfntFrag = dummyReleaseSfntFrag;
	}

	if ((key->ulState & ulStateBits) != ulStateBits)
	{
		*error = OUT_OFF_SEQUENCE_CALL_ERR;
		return 0;
	}

	key->ClientInfo.lClientID = inptr->clientID;
	*error = NO_ERR;

	return key;
}

FS_PRIVATE void fs_InitializeKey(fs_SplineKey * key)
{
	MEMSET(key, 0, sizeof(fs_SplineKey));
	key->TransformInfo.currentTMatrix = IdentTransform;
#ifdef FSCFG_SUBPIXEL
	key->TransformInfoSubPixel.currentTMatrix = IdentTransform;
#endif // FSCFG_SUBPIXEL
}

/*** FONT SCALER INTERFACE ***/

/*
 *
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	Assert(FS_SBIT_BITDEPTH_MASK == SBIT_BITDEPTH_MASK);
	/* sanity check that the embedded bitmap mask is the same in fscaler.h than in sfntaccs.h */

	if ( outputPtr )
	{
		outputPtr->memorySizes[KEY_PTR_BASE]        = (int32)sizeof (fs_SplineKey) + STAMPEXTRA;
		outputPtr->memorySizes[VOID_FUNC_PTR_BASE]  = 0;
		outputPtr->memorySizes[SCAN_PTR_BASE]       = 0;
		outputPtr->memorySizes[WORK_SPACE_BASE]      = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[BITMAP_PTR_1]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_2]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_3]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_4]         = 0; /* gray scale memory */
	}
	else
	{
		return NULL_OUTPUT_PTR_ERR;
	}
	if ( inputPtr )
	{
		inputPtr->memoryBases[KEY_PTR_BASE]             = NULL;
		inputPtr->memoryBases[VOID_FUNC_PTR_BASE]       = NULL;
		inputPtr->memoryBases[SCAN_PTR_BASE]            = NULL;
		inputPtr->memoryBases[WORK_SPACE_BASE]          = NULL;
		inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE]  = NULL;
		inputPtr->memoryBases[BITMAP_PTR_1]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_2]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_3]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_4]             = NULL;
	}
	else
	{
		return NULL_INPUT_PTR_ERR;
	}
	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;

	FS_UNUSED_PARAMETER(outputPtr);

	key = (fs_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
	SETSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	fs_InitializeKey(key);

	key->memoryBases = inputPtr->memoryBases;

	fs_SetState(key, INITIALIZED);

	fsc_Initialize();                            /* initialize scan converter */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	return NO_ERR;
}


/*
 *  This guy asks for memmory for points, instructions, fdefs and idefs
 */
FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_NEWSFNT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_DoOffsetTableMap (&key->ClientInfo);  /* Map offset and length table */

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_LoadCriticalSfntMetrics(
		&key->ClientInfo,
		&key->TransformInfo.usEmResolution,
		&key->TransformInfo.bIntegerScaling,
		&key->maxProfile);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = (int32)fsg_PrivateFontSpaceSize (&key->ClientInfo, &key->maxProfile, &key->PrivateSpaceOffsets) + STAMPEXTRA;
	outputPtr->memorySizes[WORK_SPACE_BASE]         = (int32)fsg_WorkSpaceSetOffsets (&key->maxProfile, &key->WorkSpaceOffsets, &key->lExtraWorkSpace) + STAMPEXTRA;


	error = sfac_ComputeMapping (
		&key->ClientInfo,
		inputPtr->param.newsfnt.platformID,
		inputPtr->param.newsfnt.specificID);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT));

	/*
	 *  Can't run font program yet, we don't have any memory for the
	 *  graphic state. Mark it to be run in NewTransformation.
	 */

	key->bExecuteFontPgm = TRUE;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_OFF_NEWSFNT;                /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, TRUE);
}


FS_PRIVATE int32 fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints)
{
	void *          pvGlobalGS;
	void *          pvStack;
	void *          pvTwilightZone;
	void *          pvFontProgram;
	void *          pvPreProgram;
	ErrorCode       error;
	fs_SplineKey *  key;
	int16			xOverResolution;
#ifdef FSCFG_SUBPIXEL
	void *          pvGlobalGSSubPixel;
    uint16          flSubPixelHintFlag;
	void *          pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL
   	uint16            usPPEMX;                  /* for sbits */
	uint16            usPPEMY; 
    uint16            usRotation;

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	SETSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	SETSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWTRAN;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}


	if ((key->ulState & NEWTRANS) != 0)
	{

		if ((key->SavedTransformInfo.pointSize == inputPtr->param.newtrans.pointSize) &&
			(key->SavedTransformInfo.xResolution == inputPtr->param.newtrans.xResolution) &&
			(key->SavedTransformInfo.yResolution == inputPtr->param.newtrans.yResolution) &&
			(key->SavedTransformInfo.transformMatrix.transform[0][0] == inputPtr->param.newtrans.transformMatrix->transform[0][0]) &&
			(key->SavedTransformInfo.transformMatrix.transform[1][1] == inputPtr->param.newtrans.transformMatrix->transform[1][1]) &&
			(key->SavedTransformInfo.transformMatrix.transform[1][0] == inputPtr->param.newtrans.transformMatrix->transform[1][0]) &&
			(key->SavedTransformInfo.transformMatrix.transform[0][1] == inputPtr->param.newtrans.transformMatrix->transform[0][1]) &&
			(key->SavedTransformInfo.transformMatrix.transform[2][0] == inputPtr->param.newtrans.transformMatrix->transform[2][0]) &&
			(key->SavedTransformInfo.transformMatrix.transform[2][1] == inputPtr->param.newtrans.transformMatrix->transform[2][1]) &&
			(key->SavedTransformInfo.transformMatrix.transform[2][2] == inputPtr->param.newtrans.transformMatrix->transform[2][2]) &&
			(key->SavedTransformInfo.usOverScale == inputPtr->param.newtrans.usOverScale) &&
			(key->SavedTransformInfo.bHintAtEmSquare == inputPtr->param.newtrans.bHintAtEmSquare) &&
			(key->SavedTransformInfo.flSubPixel == inputPtr->param.newtrans.flSubPixel) &&
			(key->SavedTransformInfo.usEmboldWeightx == inputPtr->param.newtrans.usEmboldWeightx) &&
			(key->SavedTransformInfo.usEmboldWeighty == inputPtr->param.newtrans.usEmboldWeighty) &&
			(key->SavedTransformInfo.lDescDev == inputPtr->param.newtrans.lDescDev) &&
			(key->SavedTransformInfo.bBitmapEmboldening == inputPtr->param.newtrans.bBitmapEmboldening) &&
			(key->TransformInfo.fxPixelDiameter  == inputPtr->param.newtrans.pixelDiameter)
			)
		{
			/* set the subpixel position, we want to ingnore difference in those fields */
			key->TransformInfo.currentTMatrix.transform[0][2] = inputPtr->param.newtrans.transformMatrix->transform[0][2];
			key->TransformInfo.currentTMatrix.transform[1][2] = inputPtr->param.newtrans.transformMatrix->transform[1][2];
			/* we have the same transformation except for the subpixel position, we don't
			   need to do anything more */
			return (FS_ENTRY)error;
		}
		else
		{
			// clear the flag for safety in case we get an error during fs__NewTransformation
			key->ulState &= ~NEWTRANS;
		}
	}

    key->bHintingEnabled = useHints;

	fsg_UpdateWorkSpaceAddresses(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

	fsg_UpdatePrivateSpaceAddresses(
		&key->ClientInfo,
		&key->maxProfile,
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets),
		pvStack,
		&pvFontProgram,
		&pvPreProgram);

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);

	key->bExecutePrePgm = (boolean) !inputPtr->param.newtrans.traceFunc;

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = TRUE;
        key->bExecuteFontPgm = FALSE;
    }

    /* Load the font program and pre program if necessary */

	if (key->bExecuteFontPgm)
	{
		error = sfac_CopyFontAndPrePrograms(
			&key->ClientInfo,
			(char *)pvFontProgram,
			(char *)pvPreProgram);

		if(error)
		{
			return (FS_ENTRY)error;
		}
	}

	key->TransformInfo.currentTMatrix = *inputPtr->param.newtrans.transformMatrix;
	key->TransformInfo.fxPixelDiameter  = inputPtr->param.newtrans.pixelDiameter;

	key->SavedTransformInfo.pointSize = inputPtr->param.newtrans.pointSize;
	key->SavedTransformInfo.xResolution = inputPtr->param.newtrans.xResolution;
	key->SavedTransformInfo.yResolution = inputPtr->param.newtrans.yResolution;
	key->SavedTransformInfo.transformMatrix  = *inputPtr->param.newtrans.transformMatrix;
	key->SavedTransformInfo.usOverScale = inputPtr->param.newtrans.usOverScale;
	key->SavedTransformInfo.usEmboldWeightx = inputPtr->param.newtrans.usEmboldWeightx;
	key->SavedTransformInfo.usEmboldWeighty = inputPtr->param.newtrans.usEmboldWeighty;
	key->SavedTransformInfo.lDescDev = inputPtr->param.newtrans.lDescDev;
	key->SavedTransformInfo.bBitmapEmboldening = inputPtr->param.newtrans.bBitmapEmboldening;
	key->SavedTransformInfo.flSubPixel = inputPtr->param.newtrans.flSubPixel;
	key->SavedTransformInfo.bHintAtEmSquare = inputPtr->param.newtrans.bHintAtEmSquare;

	xOverResolution = inputPtr->param.newtrans.xResolution;

#ifdef FSCFG_SUBPIXEL
    /* convert from external client flags to internal flags */
    key->flSubPixel = 0;
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL)
    {
        key->flSubPixel |= FNT_SP_SUB_PIXEL;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH)
    {
        /* compatible width is disabled under rotation but kept under italization */
        if (key->TransformInfo.currentTMatrix.transform[0][1] == 0)
        {
            key->flSubPixel |= FNT_SP_COMPATIBLE_WIDTH;
        }
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_VERTICAL_DIRECTION)
    {
        key->flSubPixel |= FNT_SP_VERTICAL_DIRECTION;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL && key->TransformInfo.currentTMatrix.transform[0][0] == 0) {
	// we have a combination of rotation and/or mirroring which swaps the roles of the x- and y-axis
		key->flSubPixel ^= FNT_SP_VERTICAL_DIRECTION;
	}
	
	if (inputPtr->param.newtrans.flSubPixel & SP_BGR_ORDER)
    {
        key->flSubPixel |= FNT_SP_BGR_ORDER;
    }
	
    flSubPixelHintFlag = 0;

	if (((key->flSubPixel & FNT_SP_SUB_PIXEL) && (key->SavedTransformInfo.usOverScale != 0) ) || 
        (((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) || (key->flSubPixel & FNT_SP_VERTICAL_DIRECTION) || (key->flSubPixel & FNT_SP_BGR_ORDER)) && !(key->flSubPixel & FNT_SP_SUB_PIXEL)))
	{
		/*****
		We do not yet allow a combination of SubPixel and Gray antialiazing
        The following table lists legal combinations of flags in flSubPixel:

		SubPixel	CompWidth	VertDirect	BGROrder	Comment
			No			No			No			No		b/w
			No			No			No			Yes		Illegal to ask for BGR order without asking for SubPixel
			No			No			Yes			No		Illegal to ask for vertical direction without asking for SubPixel
			No			No			Yes			Yes		Illegal by disjunctive combination
			No			Yes			No			No		Illegal to ask for compatible width without asking for SubPixel 
			No			Yes			No			Yes		Illegal by disjunctive combination 
			No			Yes			Yes			No		Illegal by disjunctive combination
			No			Yes			Yes			Yes		Illegal by disjunctive combination
			Yes			No			No			No		Plain SubPixel horizontal direction RGB
			Yes			No			No			Yes		Plain SubPixel horizontal direction BGR
			Yes			No			Yes			No		Plain SubPixel vertical direction RGB
			Yes			No			Yes			Yes		Plain SubPixel vertical direction BGR
			Yes			Yes			No			No		b/w compatible advance width SubPixel horizontal direction RGB
			Yes			Yes			No			Yes		b/w compatible advance width SubPixel horizontal direction BGR
			Yes			Yes			Yes			No		b/w compatible advance width SubPixel vertical direction RGB
			Yes			Yes			Yes			Yes		b/w compatible advance width SubPixel vertical direction BGR
		
		Note that it could be argued that in vertical direction RGB|BGR, advance widths should be b/w compatible
		by nature, because we are not rounding any x-direction positions and distances any differently than
		in b/w. However, with vertical direction RGB, a glyph may assume a height that is closer to its natural
		height than what it would in b/w, and as a result may seem too narrow or too wide, which in turn would
		call for a correction in x, specific to SubPixel with vertical direction RGB and potentially making the
		advance width incompatible. Therefore, we allow the last two combinations of flags.
		*****/

		return BAD_GRAY_LEVEL_ERR;
	}
	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)
        {
	        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
	        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
            key->TransformInfoSubPixel = key->TransformInfo;
        } else
        {
            xOverResolution = xOverResolution * HINTING_HOR_OVERSCALE;
            flSubPixelHintFlag = key->flSubPixel;
        }

    }
#endif // FSCFG_SUBPIXEL

	if (key->SavedTransformInfo.usOverScale != 0 && 
			(((1 << (key->SavedTransformInfo.usOverScale - 1)) & FS_GRAY_VALUE_MASK) == 0) || key->SavedTransformInfo.usOverScale> 31)
	{
		return BAD_GRAY_LEVEL_ERR;
	}


	key->bGrayScale = (key->SavedTransformInfo.usOverScale == 0) ? FALSE : TRUE;
	fsg_SetHintFlags(pvGlobalGS, key->bGrayScale
#ifdef FSCFG_SUBPIXEL
	    ,flSubPixelHintFlag
#endif // FSCFG_SUBPIXEL
        );

	error = fsg_InitInterpreterTrans (
		&key->TransformInfo,
		pvGlobalGS,
		inputPtr->param.newtrans.pointSize,
#ifdef FSCFG_SUBPIXEL
        xOverResolution,
#else
		inputPtr->param.newtrans.xResolution,
#endif // FSCFG_SUBPIXEL
		inputPtr->param.newtrans.yResolution,
		inputPtr->param.newtrans.bHintAtEmSquare,
		inputPtr->param.newtrans.usEmboldWeightx ,
		inputPtr->param.newtrans.usEmboldWeighty,
		key->ClientInfo.sWinDescender,
		inputPtr->param.newtrans.lDescDev,
		&key->sBoldSimulHorShift,
		&key->sBoldSimulVertShift );

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    fsg_SetHintFlags(pvGlobalGSSubPixel, key->bGrayScale, key->flSubPixel);

	    error = fsg_InitInterpreterTrans (
		    &key->TransformInfoSubPixel,
		    pvGlobalGSSubPixel,
		    inputPtr->param.newtrans.pointSize,
		    (int16)(xOverResolution * HINTING_HOR_OVERSCALE),
		    inputPtr->param.newtrans.yResolution,
		    inputPtr->param.newtrans.bHintAtEmSquare,
		    inputPtr->param.newtrans.usEmboldWeightx ,
		    inputPtr->param.newtrans.usEmboldWeighty,
		    key->ClientInfo.sWinDescender,
		    inputPtr->param.newtrans.lDescDev,
		    &key->sBoldSimulHorShift,
		    &key->sBoldSimulVertShift  );
    }
#endif // FSCFG_SUBPIXEL

	if(error)
	{
		return (FS_ENTRY)error;
	}

	if (key->bExecuteFontPgm)
	{
		error = fsg_RunFontProgram (pvGlobalGS, &key->pWorkSpaceAddr, pvTwilightZone,
									inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			return (FS_ENTRY)error;
		}

        key->bExecuteFontPgm = FALSE;
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
		fsg_CopyFontProgramResults (pvGlobalGS, pvGlobalGSSubPixel);
    }
#endif // FSCFG_SUBPIXEL

	if (!key->bExecutePrePgm)
	{

		/* Do this now so we do not confuse font editors    */
		/* Run the pre program and scale the control value table */
		/* Sets key->bExecutePrePgm to false          */

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    inputPtr->param.newtrans.traceFunc);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
        }
#endif // FSCFG_SUBPIXEL
	}

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

    fsg_QueryPPEMXY(pvGlobalGS, &key->TransformInfo, 
	            &usPPEMX, &usPPEMY, &usRotation);

	error = sbit_NewTransform(&key->SbitMono,key->TransformInfo.usEmResolution,
		key->sBoldSimulHorShift, key->sBoldSimulVertShift, usPPEMX, usPPEMY, usRotation);      /* setup for sbits */
	
	if(error)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWTRAN;             /* stop STAT timer */

	return NO_ERR;
}


/*
 * Compute the glyph index from the character code.
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode         error;
	fs_SplineKey *    key;
	void *            pvGlobalGS;
	uint16			  usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWGLYPH;                /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (inputPtr->param.newglyph.characterCode != NONVALID)
	{
		error = sfac_GetGlyphIndex(
			&key->ClientInfo,
			inputPtr->param.newglyph.characterCode);

		if(error)
		{
			return (FS_ENTRY)error;
		}

		outputPtr->numberOfBytesTaken = 2;  /*  !!!DISCUSS  */
		outputPtr->glyphIndex = key->ClientInfo.usGlyphIndex;
	}
	else
	{
		key->ClientInfo.usGlyphIndex = inputPtr->param.newglyph.glyphIndex;
		outputPtr->glyphIndex =        inputPtr->param.newglyph.glyphIndex;
		outputPtr->numberOfBytesTaken = 0;
	}

	if( key->ClientInfo.usGlyphIndex > key->maxProfile.numGlyphs - 1)
	{
		return INVALID_GLYPH_INDEX;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	key->bEmbeddedBitmap = !inputPtr->param.newglyph.bNoEmbeddedBitmap; /* read input param */

	key->bMatchBBox = inputPtr->param.newglyph.bMatchBBox;

	if (inputPtr->param.newglyph.bNoEmbeddedBitmap)
	{
		outputPtr->usBitmapFound = FALSE;
	} else {
		error = sbit_SearchForBitmap(
			&key->SbitMono,
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			key->SavedTransformInfo.usOverScale,
			&usBitDepth,
			&outputPtr->usBitmapFound );
	
		if(error)
		{
			return (FS_ENTRY)error;
		}

	}

	if (key->SavedTransformInfo.usOverScale == 0)
	{
		outputPtr->usGrayLevels = 0; 
		/* usGrayLevels == 0 means 1 bit per pixel */
	} else {
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		if(outputPtr->usBitmapFound)
		{
			outputPtr->usGrayLevels = 0x01 << usBitDepth;
		} else {
#endif // FSCFG_CONVERT_GRAY_LEVELS
			outputPtr->usGrayLevels = key->SavedTransformInfo.usOverScale * key->SavedTransformInfo.usOverScale + 1;
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		}
#endif // FSCFG_CONVERT_GRAY_LEVELS
	}

	key->bEmbeddedBitmap = outputPtr->usBitmapFound;

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		outputPtr->usBitmapFound = FALSE;
	}
#endif // FSCFG_SUBPIXEL

	/* clear all other bits */

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWGLYPH;                   /* stop STAT timer */

	return NO_ERR;
}


/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledLSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	error = sfac_ReadGlyphHorMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAW,
		&sNonScaledLSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
		&outputPtr->metricInfo.advanceWidth);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	}
#endif // FSCFG_SUBPIXEL
	return NO_ERR;
}

/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledTSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));


	error = sfac_ReadGlyphVertMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAH,
		&sNonScaledTSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
		&outputPtr->verticalMetricInfo.advanceHeight);

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	}
#endif
    return NO_ERR;
}

FS_PRIVATE int32 fs__Contour (fs_GlyphInputType*inputPtr, fs_GlyphInfoType*outputPtr, boolean useHints)
{
	ErrorCode       error;
	void *          pvGlobalGS;
	fs_SplineKey *  key;
	point           f26DevAdvanceWidth;
	point           f26DevAdvanceHeight;
	void *          pvTwilightZone;
	void *          pvStack;
	void *          pvFontProgram;
	void *          pvPreProgram;
#ifdef FSCFG_SUBPIXEL	
	void *          pvGlobalGSSubPixel;
	void *          pvTwilightZoneSubPixel;
	boolean         bSubPixelWidth = FALSE;
#endif // FSCFG_SUBPIXEL

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_GRIDFIT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	/* The element data structures need to be updated here because if the    */
	/* WorkSpace memory is shared, the pointers will not be correct. Since  */
	/* fs_Contour[No]GridFit - fs_ContourScan must have the same shared      */
	/* base, these address do not have to be updated explicitly between      */
	/* each call, only if the memory base has physically moved.              */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }

	if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = FALSE;
        useHints = FALSE;
    }

	/*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

#ifdef FSCFG_SUBPIXEL
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))
#else
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap)
#endif // FSCFG_SUBPIXEL	
	{
		key->bGridFitSkipped = TRUE;    /* disallow grayscale, outline caching, banding */
		
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth );
		
		if(error)
		{
			return (FS_ENTRY)error;
		}

		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceHeight );

		if(error)
		{
			return (FS_ENTRY)error;
		}

	}
	else                                /* if we're using the outline */
	{
		key->bGridFitSkipped = FALSE;   /* allow grayscale, outline caching, banding */

		/* THE CALL */

		error = fsg_GridFit (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.gridfit.traceFunc,
			useHints,
			&key->usScanType,
			&key->bGlyphHasOutline,
			&key->usNonScaledAW,
			key->SavedTransformInfo.bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
			);

		if(error)
		{
			return (FS_ENTRY)error;
		}

#ifdef FSCFG_SUBPIXEL

        if (key->flSubPixel & FNT_SP_SUB_PIXEL) {
            Fixed   fxCompatibleWidthScale;
            F26Dot6 devAdvanceWidthX, devLeftSideBearingX, devRightSideBearingX;
            F26Dot6 horTranslation;
			
			/* default scale back factor if we don't need to adjust for compatible width
			   (FNT_SP_COMPATIBLE_WIDTH is set off under rotation at fs_NewTransformation) */
			
			fxCompatibleWidthScale = SUBPIXEL_SCALEBACK_FACTOR; 

            if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) {
				Fixed concertFactor;

				// compute the B/W glyph metrics
        	    if (key->bEmbeddedBitmap) {
		            error = sbit_CalcDevHorMetrics (&key->SbitMono,&key->ClientInfo,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
		            if(error)
		                return (FS_ENTRY)error;
				} else {
		            fsg_CalcDevHorMetrics(&key->pWorkSpaceAddr,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                }

				if (key->usNonScaledAW) {
					concertFactor = FixDiv(devAdvanceWidthX,((fnt_GlobalGraphicStateType *)pvGlobalGS)->ScaleFuncX(
										   &((fnt_GlobalGraphicStateType *)pvGlobalGS)->scaleX,(F26Dot6)key->usNonScaledAW));
					if (concertFactor < 0) concertFactor = -concertFactor;
				} else {
					concertFactor = 0x10000; // Fixed 1.0 for 0 AW glyphs
				}
				((fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel)->compatibleWidthStemConcertina = concertFactor;
				
				/* grid fit for the SubPixel overscale resolution */
		        error = fsg_GridFit (
			        &key->ClientInfo,
			        &key->maxProfile,
			        &key->TransformInfoSubPixel,
			        pvGlobalGSSubPixel,
			        &key->pWorkSpaceAddr,
			        pvTwilightZoneSubPixel,
			        inputPtr->param.gridfit.traceFunc,
			        useHints,
			        &key->usScanType,
			        &key->bGlyphHasOutline,
			        &key->usNonScaledAW,
			        key->SavedTransformInfo.bBitmapEmboldening,
			        (key->flSubPixel & FNT_SP_SUB_PIXEL)
			        );

		        if(error) {
			        return (FS_ENTRY)error;
		        }
			} // key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH
			
			fsg_ScaleToCompatibleWidth(&key->pWorkSpaceAddr,fxCompatibleWidthScale);

			if (useHints && (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)) {
				horTranslation = 0;
				fsg_AdjustCompatibleMetrics (
					&key->pWorkSpaceAddr,
					horTranslation,
					devAdvanceWidthX*RGB_OVERSCALE);
			}
		}
#endif // FSCFG_SUBPIXEL

        fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
			&outputPtr->xPtr,
			&outputPtr->yPtr,
			&outputPtr->startPtr,
			&outputPtr->endPtr,
			&outputPtr->onCurve,
			&outputPtr->fc,
			&outputPtr->numberOfContours);

		fsg_GetDevAdvanceWidth(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceWidth);

		fsg_GetDevAdvanceHeight(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceHeight);
	}
	
	outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
	outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);

	outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
	outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
		ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
	}
#endif // FSCFG_SUBPIXEL

	outputPtr->outlinesExist = (uint16)key->bGlyphHasOutline;

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_GRIDFIT;             /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, TRUE);
}

/*********************************************************************/

/* Calculate scan conversion memory requirements                     */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{

	ErrorCode       error;
	BitMap *        pBMI;

	ContourList     CList;        /* newscan contour list type */
	void *          pvGlobalGS;
	fs_SplineKey *  key;

	point           f26DevAdvanceWidth;
	point           f26DevLeftSideBearing;
	point           f26LeftSideBearing;
	point           f26DevLeftSideBearingLine;
	point           f26LeftSideBearingLine;

	point           f26DevAdvanceHeight;
	point           f26DevTopSideBearing;
	point           f26TopSideBearing;
	point           f26DevTopSideBearingLine;
	point           f26TopSideBearingLine;

	int16           sOverScale;
	uint16          usRoundXMin;
	Rect *          pOrigB;             /* original outline bounding box */
	Rect *          pOverB;             /* over scaled outline bounding box */
	GlyphBitMap *   pOverG;             /* over scaled glyph bitmap struct */
	GlyphBitMap *   pGBMap;             /* orig or over pointer */
	
	uint16          usRowBytes;
	uint32          ulSbitOutSize;      /* sbit output memory */
	uint32          ulSbitWorkSize;     /* sbit workspace memory */
	int16           sNonScaledLSB;      /* for non-dev metrics calc */
	int16           sNonScaledTSB;      /* for non-dev metrics calc */
	int16           sNonScaledTopOriginX;      /* for non-dev metrics calc */
    int16           sBitmapEmboldeningHorExtra;      
	int16           sBitmapEmboldeningVertExtra;      

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_FINDBMS;                 /* start STAT timer */
	
	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pOrigB = &key->GBMap.rectBounds;    /* local copy of bounds pointer */

#ifdef FSCFG_SUBPIXEL
	if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
	{
		error = sbit_GetMetrics (                   /* get device metrics */
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
            &f26LeftSideBearing,
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			pOrigB,
			&usRowBytes,
			&ulSbitOutSize,
			&ulSbitWorkSize );
		
		if (error != NO_ERR)
		{
			return(error);
		}
		
		outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y = DOT6TOFIX(f26LeftSideBearing.y);
		
		outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y = DOT6TOFIX(f26TopSideBearing.y);
		
        /* just copy to 'Line' metrics */

		outputPtr->metricInfo.devLeftSideBearingLine.x = outputPtr->metricInfo.devLeftSideBearing.x;
		outputPtr->metricInfo.devLeftSideBearingLine.y = outputPtr->metricInfo.devLeftSideBearing.y;
		outputPtr->metricInfo.leftSideBearingLine.x = outputPtr->metricInfo.leftSideBearing.x;
		outputPtr->metricInfo.leftSideBearingLine.y = outputPtr->metricInfo.leftSideBearing.y;

		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = outputPtr->verticalMetricInfo.devTopSideBearing.x;
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = outputPtr->verticalMetricInfo.devTopSideBearing.y;
		outputPtr->verticalMetricInfo.topSideBearingLine.x = outputPtr->verticalMetricInfo.topSideBearing.x;
		outputPtr->verticalMetricInfo.topSideBearingLine.y = outputPtr->verticalMetricInfo.topSideBearing.y;


	error = sfac_ReadGlyphMetrics (             /* get non-dev adv width */
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			&key->usNonScaledAW,
			&key->usNonScaledAH,
			&sNonScaledLSB,
			&sNonScaledTSB,
            &sNonScaledTopOriginX);

		if(error != NO_ERR)
		{
			return error;
		}

		fsg_UpdateAdvanceWidth (
			&key->TransformInfo,                    /* scale the design adv width */
			pvGlobalGS, 
			key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth );

		fsg_UpdateAdvanceHeight (
			&key->TransformInfo,                    /* scale the design adv height */
			pvGlobalGS, 
			key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight );

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
		pBMI->bounds.right = pOrigB->right;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->rowBytes = (int16)usRowBytes;
		pBMI->baseAddr = 0L;

		outputPtr->memorySizes[BITMAP_PTR_1] = ulSbitOutSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = ulSbitWorkSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = 0L;
		outputPtr->memorySizes[BITMAP_PTR_4] = 0L;
	}
	else                                /* if rasterizing from a contour */
	{
		if (key->TransformInfo.bPhaseShift)
		{
			fsg_45DegreePhaseShift (&key->pWorkSpaceAddr);
		}

		fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			FALSE,            
#endif // FSCFG_SUBPIXEL
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		error = fsc_RemoveDups(&CList);                 /* collapse dup'd points */
		if (error != NO_ERR)
		{
			return(error);
		}

		pGBMap = &key->GBMap;                           /* default to usual structure */
		usRoundXMin = 1;

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			error = fsc_OverScaleOutline(&CList, key->SavedTransformInfo.usOverScale);
			if (error != NO_ERR)
			{
				return(error);
			}
			pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
			usRoundXMin = key->SavedTransformInfo.usOverScale;
		}
		
		fsg_GetWorkSpaceExtra(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->WScan.pchRBuffer));
		key->WScan.lRMemSize = key->lExtraWorkSpace;    /* use extra for MeasureGlyph workspace */
		
		if (key->SavedTransformInfo.bBitmapEmboldening) 
		{
			if (key->bGrayScale)                                 /* if doing gray scale */
			{
				sBitmapEmboldeningHorExtra = key->SavedTransformInfo.usOverScale * key->sBoldSimulHorShift;
				sBitmapEmboldeningVertExtra = key->SavedTransformInfo.usOverScale * key->sBoldSimulVertShift;
			} 
#ifdef FSCFG_SUBPIXEL
			else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
			{
				sBitmapEmboldeningHorExtra = RGB_OVERSCALE * key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
#endif // FSCFG_SUBPIXEL
			else
			{
				sBitmapEmboldeningHorExtra = key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
		}
		else
		{
			sBitmapEmboldeningHorExtra = 0;
			sBitmapEmboldeningVertExtra = 0;
		}

		error = fsc_MeasureGlyph(
			&CList, 
			pGBMap, 
			&key->WScan, 
			key->usScanType, 
			usRoundXMin,
			sBitmapEmboldeningHorExtra,
			sBitmapEmboldeningVertExtra );

		if (error == SMART_DROP_OVERFLOW_ERR)
		{
			/* glyph is too complex for the smart dropout control */
			key->usScanType &= ~SK_SMART;
			error = fsc_MeasureGlyph(
				&CList, 
				pGBMap, 
				&key->WScan, 
				key->usScanType, 
				usRoundXMin,
				sBitmapEmboldeningHorExtra,
				sBitmapEmboldeningVertExtra );
		}
		if (error != NO_ERR)
		{
			return(error);
		}
		Assert(key->WScan.lRMemSize < key->lExtraWorkSpace);
		
		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			sOverScale = (int16)key->SavedTransformInfo.usOverScale;
			
			if (key->bMatchBBox)        /* if bounding box is fixed */
			{                                           /* the calc as if orig monochrome */
				pOverG = &key->OverGBMap;        
				pOrigB->left = (int16)((mth_DivShiftLong(pOverG->fxMinX, sOverScale) + 31L) >> 6);
				pOrigB->right = (int16)((mth_DivShiftLong(pOverG->fxMaxX, sOverScale) + 32L) >> 6);
				pOrigB->bottom = (int16)((mth_DivShiftLong(pOverG->fxMinY, sOverScale) + 31L) >> 6);
				pOrigB->top = (int16)((mth_DivShiftLong(pOverG->fxMaxY, sOverScale) + 32L) >> 6);

				/* force the bitmap to have at least one pixel wide and one pixel high */
				if (pOrigB->left == pOrigB->right)
				{
					pOrigB->right++;                                /* force 1 pixel wide */
				}
				if (pOrigB->bottom == pOrigB->top)
				{
					pOrigB->top++;                                /* force 1 pixel high */
				}

			}
			else                                        /* if bounding box can grow */
			{                                           /* then size to gray box */
				pOverB = &key->OverGBMap.rectBounds;        
				pOrigB->left = mth_DivShiftShort(pOverB->left, sOverScale);
				pOrigB->right = mth_DivShiftShort((int16)(pOverB->right + sOverScale - 1), sOverScale);
				pOrigB->bottom = mth_DivShiftShort(pOverB->bottom, sOverScale);
				pOrigB->top = mth_DivShiftShort((int16)(pOverB->top + sOverScale - 1), sOverScale);
			}
		}
		
		fsg_CalcLSBsAndAdvanceWidths(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
			&f26LeftSideBearing,
			&f26DevLeftSideBearingLine,
			&f26LeftSideBearingLine);

		outputPtr->metricInfo.devAdvanceWidth.x        = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y        = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x     = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y     = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x        = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y        = DOT6TOFIX(f26LeftSideBearing.y);
		outputPtr->metricInfo.devLeftSideBearingLine.x = DOT6TOFIX(f26DevLeftSideBearingLine.x);
		outputPtr->metricInfo.devLeftSideBearingLine.y = DOT6TOFIX(f26DevLeftSideBearingLine.y);
		outputPtr->metricInfo.leftSideBearingLine.x    = DOT6TOFIX(f26LeftSideBearingLine.x);
		outputPtr->metricInfo.leftSideBearingLine.y    = DOT6TOFIX(f26LeftSideBearingLine.y);

		fsg_CalcTSBsAndAdvanceHeights(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			&f26DevTopSideBearingLine,
			&f26TopSideBearingLine);

		outputPtr->verticalMetricInfo.devAdvanceHeight.x      = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y      = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x     = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y     = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x        = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y        = DOT6TOFIX(f26TopSideBearing.y);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = DOT6TOFIX(f26DevTopSideBearingLine.x);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = DOT6TOFIX(f26DevTopSideBearingLine.y);
		outputPtr->verticalMetricInfo.topSideBearingLine.x    = DOT6TOFIX(f26TopSideBearingLine.x);
		outputPtr->verticalMetricInfo.topSideBearingLine.y    = DOT6TOFIX(f26TopSideBearingLine.y);

		fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth);

		fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight);

		MEMCPY(&key->metricInfo, &outputPtr->metricInfo, sizeof( metricsType ));
		MEMCPY(&key->verticalMetricInfo, &outputPtr->verticalMetricInfo, sizeof( verticalMetricsType ));

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->baseAddr = 0;
		
#ifdef FSCFG_SUBPIXEL
		if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
	        if (!(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	        {
                /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	        }
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearingLine.x);

			pBMI->bounds.left = FLOOR_RGB_OVERSCALE(pOrigB->left);               /* return bbox to client */
			pBMI->bounds.right = CEIL_RGB_OVERSCALE(pOrigB->right);

			pBMI->rowBytes = ((pBMI->bounds.right - pBMI->bounds.left) + 3) & (-4);

            key->OverGBMap = key->GBMap;
            key->GBMap.sRowBytes = pBMI->rowBytes;
            key->GBMap.rectBounds.left = pBMI->bounds.left;
            key->GBMap.rectBounds.right = pBMI->bounds.right;
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(key->GBMap.rectBounds.top - key->GBMap.rectBounds.bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		else
		{
#endif // FSCFG_SUBPIXEL
			pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
			pBMI->bounds.right = pOrigB->right;
			pBMI->rowBytes = key->GBMap.sRowBytes;
#ifdef FSCFG_SUBPIXEL
		}
#endif // FSCFG_SUBPIXEL

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			pBMI->rowBytes = ((pOrigB->right - pOrigB->left) + 3) & (-4);
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(pOrigB->top - pOrigB->bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		
		key->GBMap.sRowBytes = pBMI->rowBytes;
		outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;

	}
	fsg_CheckWorkSpaceForFit(
		&(key->WorkSpaceOffsets),
		key->lExtraWorkSpace,
		key->WScan.lRMemSize,
		&(outputPtr->memorySizes[BITMAP_PTR_2]),
		&(outputPtr->memorySizes[BITMAP_PTR_3]));

	key->usBandType = FS_BANDINGOLD;                /* assume old banding */
	key->usBandWidth = 0;
	key->bOutlineIsCached = FALSE;                  /* assume no caching */

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_FINDBMS;             /* stop STAT timer */
	
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *     key;
	int32              ulSize;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bEmbeddedBitmap)
	{
        return SBIT_OUTLINE_CACHE_ERR;      /* can't cache sbits */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	ulSize = (uint32)sizeof( uint32 );                         /* OUTLINESTAMP              */
	ulSize += (uint32)( sizeof( FS_MEMORY_SIZE ) * BITMAP_MEMORY_COUNT );   /* Memory Bases */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outlines Exist (padded)   */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Scan Type (padded)        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Glyph Index (padded)      */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outline Cache Size        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Gray Scale Over Factor    */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Grid Fit Skipped Boolean  */
	ulSize += (uint32)( sizeof( uint32 ));                     /* no embedded bitmap Boolean*/
	ulSize += (uint32)sizeof( metricsType );                   /* Metrics information       */
	ulSize += (uint32)sizeof( verticalMetricsType );           /* Vert metrics information  */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Glyph Bitmap              */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Gray Overscaled Bitmap    */
	ulSize += (uint32)sizeof( WorkScan );                      /* Scanconverter Workspace   */
	ulSize += (uint32)key->WScan.lRMemSize;                    /* Reversal list             */
	ulSize += fsg_GetContourDataSize(&key->pWorkSpaceAddr);    /* Contour Data              */
	ulSize += (uint32)sizeof( uint32 );                        /* OUTLINESTAMP2             */
	ALIGN(uint32, ulSize);

	outputPtr->outlineCacheSize = ulSize;
	key->ulGlyphOutlineSize = ulSize;

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	uint8 *            pbyDest;

	fs_SplineKey *     key;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	if( (outputPtr->memorySizes[BITMAP_PTR_2] == 0L) || (outputPtr->memorySizes[BITMAP_PTR_3] == 0L))
	{
		fsg_GetRealBitmapSizes(
			&(key->WorkSpaceOffsets),
			&outputPtr->memorySizes[BITMAP_PTR_2],
			&outputPtr->memorySizes[BITMAP_PTR_3]);
	}

	pbyDest = (uint8 *)inputPtr->param.outlineCache;

	*((uint32 *)pbyDest) = OUTLINESTAMP;
	pbyDest += sizeof( uint32 );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_1];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_2];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_3];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_4];
	pbyDest += sizeof( FS_MEMORY_SIZE   );
	 
	/* Outlines exist state */

	*((uint32 *)pbyDest) = (uint32)key->bGlyphHasOutline;
	pbyDest += sizeof( uint32 );

	/* Dropout control state */

	*((uint32 *)pbyDest) = (uint32)key->usScanType;
	pbyDest += sizeof( uint32 );

	/* Glyph Index */

	*((uint32 *)pbyDest) = (uint32)key->ClientInfo.usGlyphIndex;
	pbyDest += sizeof( uint32 );

	/* Outline Cache Size */

	*((uint32 *)pbyDest) = (uint32)key->ulGlyphOutlineSize;
	pbyDest += sizeof( uint32 );

	/* Gray Over Scale Factor */

	*((uint32 *)pbyDest) = (uint32)key->SavedTransformInfo.usOverScale;
	pbyDest += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bGridFitSkipped;
	pbyDest += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bEmbeddedBitmap;
	pbyDest += sizeof( uint32 );

	/* Glyph metrics */

	MEMCPY(pbyDest, &key->metricInfo, sizeof(metricsType));
	pbyDest += sizeof(metricsType);

	MEMCPY(pbyDest, &key->verticalMetricInfo, sizeof(verticalMetricsType));
	pbyDest += sizeof(verticalMetricsType);

	/* Scan Converter Data Structures */

	MEMCPY(pbyDest, &key->GBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->OverGBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->WScan, sizeof(WorkScan));
	pbyDest += sizeof(WorkScan);

	MEMCPY(pbyDest, key->WScan.pchRBuffer, (size_t)key->WScan.lRMemSize);
	pbyDest += key->WScan.lRMemSize;

	/*** save charData ***/

	fsg_DumpContourData(&key->pWorkSpaceAddr, &pbyDest);

	*((uint32 *)pbyDest) = OUTLINESTAMP2;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;
	uint8 *         pbySrc;
	ErrorCode       error;

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pbySrc = (uint8 *)inputPtr->param.outlineCache;

	if ( *((uint32 *)pbySrc) != OUTLINESTAMP )
	{
		return TRASHED_OUTLINE_CACHE;
	}
	pbySrc += sizeof(uint32);

	outputPtr->memorySizes[BITMAP_PTR_1] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_2] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_3] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_4] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE    );

	/* Read in GlyphHasOutline */

	outputPtr->outlinesExist = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read ScanType state */

	key->usScanType = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Glyph Index */

	outputPtr->glyphIndex = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Size of Outline Cache  */

	outputPtr->outlineCacheSize = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Gray Over Scale Factor  */

    key->SavedTransformInfo.usOverScale = (uint16)(*((uint32 *)pbySrc));
	outputPtr->usGrayLevels = key->SavedTransformInfo.usOverScale * key->SavedTransformInfo.usOverScale + 1;
	key->bGrayScale = (key->SavedTransformInfo.usOverScale == 0) ? FALSE : TRUE;
	pbySrc += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    key->bGridFitSkipped = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    key->bEmbeddedBitmap = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Load fs_FindBitmapSize metrics */

	MEMCPY(&outputPtr->metricInfo, pbySrc, sizeof(metricsType));
	pbySrc += sizeof(metricsType);

	MEMCPY(&outputPtr->verticalMetricInfo, pbySrc, sizeof(verticalMetricsType));
	pbySrc += sizeof(verticalMetricsType);

	/* Load ScanConverter data structures */

	MEMCPY(&key->GBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->OverGBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->WScan, pbySrc, sizeof(WorkScan));
	pbySrc += sizeof(WorkScan);

	key->WScan.pchRBuffer = (char *)pbySrc;
	pbySrc += key->WScan.lRMemSize;

	fsg_RestoreContourData(
		&pbySrc,
		&outputPtr->xPtr,
		&outputPtr->yPtr,
		&outputPtr->startPtr,
		&outputPtr->endPtr,
		&outputPtr->onCurve,
		&outputPtr->fc,
		&outputPtr->numberOfContours);

	outputPtr->bitMapInfo.baseAddr = NULL;
	outputPtr->bitMapInfo.rowBytes = key->GBMap.sRowBytes;
	outputPtr->bitMapInfo.bounds.left = key->GBMap.rectBounds.left;
	outputPtr->bitMapInfo.bounds.right = key->GBMap.rectBounds.right;
	outputPtr->bitMapInfo.bounds.top = key->GBMap.rectBounds.bottom;   /* reversed! */
	outputPtr->bitMapInfo.bounds.bottom = key->GBMap.rectBounds.top;

	outputPtr->scaledCVT = NULL;
	outputPtr->numberOfBytesTaken = 0;

	key->usBandType = FS_BANDINGOLD;                    /* assume old banding */
	key->usBandWidth = 0;
    key->apbPrevMemoryBases[BITMAP_PTR_2] = NULL;       /* for fast/faster check */
    key->apbPrevMemoryBases[BITMAP_PTR_3] = NULL;

	key->bOutlineIsCached = TRUE;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));
	return NO_ERR;
}

/*********************************************************************/

/* Calculate memory requirements for banding                         */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;
	uint8 *         pbyOutline;
	int16           sMaxOvershoot;
	int16           sHiOvershoot;
	int16           sLoOvershoot;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bGridFitSkipped || key->bEmbeddedBitmap)
	{
		return SBIT_BANDING_ERR;                /* can't band sbits */
	}
	
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets));
	}
	else
	{
		/* Unload the outline cache */

		pbyOutline = (uint8 *)inputPtr->param.band.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			  return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			  (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			  + sizeof( uint32 )                      /* Outlines Exist (padded)  */
			  + sizeof( uint32 )                      /* Scan Type (padded)        */
			  + sizeof( uint32 )                      /* Glyph Index (padded)      */
			  + sizeof( uint32 )                      /* Outline Cache Size        */
			  + sizeof( uint32 )                      /* Gray Over Scale Factor    */
			  + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
			  + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			  + sizeof( metricsType )                 /* Metrics information       */
			  + sizeof( verticalMetricsType )         /* Vert metrics information  */
			  + sizeof( GlyphBitMap )
			  + sizeof( GlyphBitMap )                 /* Over Scale structure      */
			  + sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;

		/* No need to further unload outline cache */
	}

	pGBMap = &key->GBMap;                           /* default usual structure */
	key->usBandWidth = inputPtr->param.band.usBandWidth;
	key->usBandType = inputPtr->param.band.usBandType;

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
		key->usBandWidth *= key->SavedTransformInfo.usOverScale;
/*  
 *  Band width for the over scaled bitmap is basically just the requested band 
 *  width times the overscale factor.  However! if the gray scaled bounding 
 *  box has been trimmed to match the monochrome box (i.e. bMatchBBox = TRUE),
 *  then top and bottom bands must be made bigger to include the entire over
 *  scaled bitmap.  If this were not done it would break dropout control, and
 *  bitmaps would change with banding.  So that's why we do this messing around
 *  with overshoot in the key->usBandWidth calculation.
 */
		sMaxOvershoot = 0;
		sHiOvershoot = (int16)(key->OverGBMap.rectBounds.top -
					   key->GBMap.rectBounds.top * (int16)key->SavedTransformInfo.usOverScale);
		if (sHiOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sHiOvershoot;
		}
		sLoOvershoot = (int16)(key->GBMap.rectBounds.bottom * (int16)key->SavedTransformInfo.usOverScale -
					   key->OverGBMap.rectBounds.bottom);
		if (sLoOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sLoOvershoot;
		}
		key->usBandWidth += (uint16)sMaxOvershoot;
	}

	error = fsc_MeasureBand(
		pGBMap,                     /* orig or over scaled bounding box, etc. */
		&key->WScan,
		key->usBandType,
		key->usBandWidth,           /* worst case band width */
		key->usScanType );
	if (error != NO_ERR)
	{
		return(error);
	}

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		key->GBMap.lMMemSize = (int32)key->GBMap.sRowBytes * (int32)inputPtr->param.band.usBandWidth;
		outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize;
	}
	
	outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
	outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
	outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;
	
	if( !key->bOutlineIsCached )
	{
		fsg_CheckWorkSpaceForFit(
			&(key->WorkSpaceOffsets),
			key->lExtraWorkSpace,
			key->WScan.lRMemSize,                             /* MeasureGlyph workspace */
			&(outputPtr->memorySizes[BITMAP_PTR_2]),
			&(outputPtr->memorySizes[BITMAP_PTR_3]));
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	return NO_ERR;
}

/*********************************************************************/

#ifdef FSCFG_CONVERT_GRAY_LEVELS

// Tables to speed up bitmap translation from different GrayLevels.
uint8 Gray4To5Table[4]= {0,1,3,4};
uint8 Gray16To5Table[16]={0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4};

uint8 Gray4To17Table[4]= {0,5,11,16};
uint8 Gray16To17Table[16]={0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16};

uint8 Gray4To65Table[4]= {0,21,43,64};
uint8 Gray16To65Table[16]={0,4,9,13,17,21,26,30,34,38,43,47,51,55,60,64};

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth);

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth)
	{
	  uint16    index; // Gray level xlate table index
      switch (usOverScale) {
       case 2:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To5Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
		   }
          break;
       case 4:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To17Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;
       case 8:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To65Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;

       default:
               return BAD_GRAY_LEVEL_ERR;
       } /* endswitch */
	   return NO_ERR;

    } /* end if bGrayScale */

#endif // FSCFG_CONVERT_GRAY_LEVELS

/* Generate a bitmap                                                 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{    
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;
	char *          pBitmapPtr2;
	char *          pBitmapPtr3;
	uint8 *         pbyOutline;
	ErrorCode       error;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_SCAN;                    /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if( !key->bOutlineIsCached )                /* if outline or embedded bitmap */
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

		if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
		{
			fsg_UpdateWorkSpaceAddresses(
				 key->memoryBases[WORK_SPACE_BASE],
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			fsg_UpdateWorkSpaceElement(
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			key->apbPrevMemoryBases[WORK_SPACE_BASE] = key->memoryBases[WORK_SPACE_BASE];
		}

		fsg_SetUpWorkSpaceBitmapMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			key->memoryBases[BITMAP_PTR_2],
			key->memoryBases[BITMAP_PTR_3],
			&pBitmapPtr2,                       /* sbits may need Ptr2 */
			&pBitmapPtr3);

        /* check for embedded bitmap, quick return if found */

#ifdef FSCFG_SUBPIXEL
	    if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	    if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
    	{
    		if ((inputPtr->param.scan.topClip > inputPtr->param.scan.bottomClip) &&  /* if legal band */
               ((inputPtr->param.scan.topClip < key->GBMap.rectBounds.top) ||
                (inputPtr->param.scan.bottomClip > key->GBMap.rectBounds.bottom)))
    		{
        		return SBIT_BANDING_ERR;            /* can't band sbits */
            }

    		error = sbit_GetBitmap (
    			&key->SbitMono,
    			&key->ClientInfo,
    			(uint8 *) inputPtr->memoryBases[BITMAP_PTR_1],
    			(uint8 *) pBitmapPtr2 );
		
    		if (error != NO_ERR)
    		{
    			return((FS_ENTRY)error);
    		}
        	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

        	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
       		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

        	STAT_OFF_SCAN;                  /* stop STAT timer */

#ifdef FSCFG_CONVERT_GRAY_LEVELS
			if (key->bGrayScale)
			{
				error = fs_ConvertGrayLevels (outputPtr, key->SavedTransformInfo.usOverScale, key->SbitMono.usBitDepth);
			
				if(error)
				{
					return (FS_ENTRY)error;
				}
			} /* end if bGrayScale */
#endif // FSCFG_CONVERT_GRAY_LEVELS

        	return NO_ERR;                  /* return now with an sbit */
    	}
        else        /* if scan converting an outline */
        {
			fsg_GetWorkSpaceExtra(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->WScan.pchRBuffer));

			fsg_GetContourData(
				&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
				FALSE,            
#endif // FSCFG_SUBPIXEL
				&CList.afxXCoord,
				&CList.afxYCoord,
				&CList.asStartPoint,
				&CList.asEndPoint,
				&CList.abyOnCurve,
				&CList.abyFc,
				&CList.usContourCount);
        }
    }
    else            /* Unload the outline cache */
	{
		pbyOutline = (uint8 *)inputPtr->param.scan.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			 return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			(BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			+ sizeof( uint32 )                      /* Outlines Exist (padded)  */
			+ sizeof( uint32 )                      /* Scan Type (padded)        */
			+ sizeof( uint32 )                      /* Glyph Index (padded)      */
			+ sizeof( uint32 )                      /* Outline Cache Size        */
			+ sizeof( uint32 )                      /* Gray Over Scale Factor    */
	        + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
	        + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			+ sizeof( metricsType )                 /* Metrics information       */
			+ sizeof( verticalMetricsType )         /* Vert metrics information  */
			+ sizeof( GlyphBitMap )
			+ sizeof( GlyphBitMap )                 /* Over Scale structure      */
			+ sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;
		pbyOutline += key->WScan.lRMemSize;

		fsg_RestoreContourData(
			&pbyOutline,
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP2 )
		{
			return TRASHED_OUTLINE_CACHE;
		}

		pBitmapPtr2 = key->memoryBases[BITMAP_PTR_2];
		pBitmapPtr3 = key->memoryBases[BITMAP_PTR_3];
	}

	if (pBitmapPtr3 == NULL)  /* Allow client to turn off DOControl */
	{
		key->usScanType = SK_NODROPOUT;
	}

	key->GBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_1];
	key->GBMap.sHiBand = inputPtr->param.scan.topClip;
	key->GBMap.sLoBand = inputPtr->param.scan.bottomClip;

	if (key->GBMap.sHiBand <= key->GBMap.sLoBand)            /* if negative or no band */
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* then for Apple compatiblity */
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* do the entire bitmap */
	}
	if (key->GBMap.sHiBand > key->GBMap.rectBounds.top)
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* clip to bounding box */
	}
	if (key->GBMap.sLoBand < key->GBMap.rectBounds.bottom)
	{
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* clip to bounding box */
	}
		 
	if ((key->usBandType == FS_BANDINGFASTER) &&
		((key->apbPrevMemoryBases[BITMAP_PTR_2] != pBitmapPtr2) ||
		 (key->apbPrevMemoryBases[BITMAP_PTR_3] != pBitmapPtr3)))
	{
		 key->usBandType = FS_BANDINGFAST;  /* to recalculate memory */
	}

	if (key->usBandType == FS_BANDINGOLD)   /* if FindGrayBandingSize wasn't called */
	{
		if ((key->GBMap.sHiBand != key->GBMap.rectBounds.top) ||
			(key->GBMap.sLoBand != key->GBMap.rectBounds.bottom))   /* if banding */
		{
			if (key->bGrayScale)
			{
				return GRAY_OLD_BANDING_ERR;        /* gray scale fails with old banding */
			}
			key->usScanType = SK_NODROPOUT;         /* else force dropout off */
		}
	}
	else if (key->usBandType == FS_BANDINGSMALL)  /* if small mem type */
	{
		if (key->bGrayScale)
		{
			if (key->SavedTransformInfo.usOverScale *(key->GBMap.sHiBand - key->GBMap.sLoBand) > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		} else {
			if (key->GBMap.sHiBand - key->GBMap.sLoBand > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		}
		key->usScanType = SK_NODROPOUT;       /* turn off dropout control */
	}
	pGBMap = &key->GBMap;                     /* default to usual structure */
	
	if (key->bGrayScale)
	{
		pGBMap = &key->OverGBMap;             /* measure overscaled structure */
		
		if (key->GBMap.sHiBand == key->GBMap.rectBounds.top)            /* if gray band at top */
		{
			key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;     /* use over top */
		}
		else
		{
			key->OverGBMap.sHiBand = (int16)(key->GBMap.sHiBand * (int16)key->SavedTransformInfo.usOverScale);
			if (key->OverGBMap.sHiBand > key->OverGBMap.rectBounds.top)
			{
				key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top; /* clip */
			}
		}
		if (key->GBMap.sLoBand == key->GBMap.rectBounds.bottom)         /* if gray band at bottom */
		{
			key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* use over bottom */
		}
		else
		{
			key->OverGBMap.sLoBand = (int16)(key->GBMap.sLoBand * (int16)key->SavedTransformInfo.usOverScale);
			if (key->OverGBMap.sLoBand < key->OverGBMap.rectBounds.bottom)
			{
				key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* clip */
			}
		}
		key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];
	}
#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		pGBMap = &key->OverGBMap;             /* draw into the overscaled structure */

	    key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];

        /* no banding yet !!! */
	    key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;
	    key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;
    }
#endif // FSCFG_SUBPIXEL

	key->WScan.pchHBuffer = pBitmapPtr2;
	key->WScan.pchVBuffer = pBitmapPtr3;

	error = fsc_FillGlyph(
		&CList,
		pGBMap,
		&key->WScan,
		key->usBandType,
		key->usScanType
		);
	if (error != NO_ERR)
	{
		return(error);
	}
	 
	if (key->bGrayScale)
	{
		error = fsc_CalcGrayMap(
			&key->OverGBMap, 
			&key->GBMap, 
			key->SavedTransformInfo.usOverScale
			);
		if (error != NO_ERR)
		{
			return((FS_ENTRY)error);
		}
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
		outputPtr->overscaledBitmapInfo.baseAddr = key->OverGBMap.pchBitMap;
		outputPtr->overscaledBitmapInfo.rowBytes = key->OverGBMap.sRowBytes;
		outputPtr->overscaledBitmapInfo.bounds = key->OverGBMap.rectBounds; // save for more detailed processing
#endif
        fsc_OverscaleToSubPixel (&key->OverGBMap, (key->flSubPixel & FNT_SP_BGR_ORDER) > 0, &key->GBMap);
	}
#endif // FSCFG_SUBPIXEL

	if (key->SavedTransformInfo.bBitmapEmboldening)
	{
		if (key->bGrayScale)
		{
			uint16 usGrayLevels = key->SavedTransformInfo.usOverScale * key->SavedTransformInfo.usOverScale + 1;
			sbit_EmboldenGray((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes,usGrayLevels, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#ifdef FSCFG_SUBPIXEL
		else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
			sbit_EmboldenSubPixel((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#endif // FSCFG_SUBPIXEL
		else 
		{
			sbit_Embolden((uint8 *)pGBMap->pchBitMap, (uint16)(pGBMap->rectBounds.right - pGBMap->rectBounds.left), 
						  (uint16)(pGBMap->sHiBand - pGBMap->sLoBand), pGBMap->sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		}
	}

/*  Setting the Band Type to FS_BANDINGFASTER will allow the next call      */
/*  to fsc_FillGlyph to skip the rendering phase of scan conversion and     */
/*  get right to the bitmap fill.  If the client moves either memoryBase[6] */ 
/*  or memoryBase[7] between fs_ContourScan calls, then we must reset the   */
/*  band type to FS_BANDINGFAST to regenerate the data structures.          */

	if (key->usBandType == FS_BANDINGFAST)
	{
		key->usBandType = FS_BANDINGFASTER;    /* to save re-rendering */
		key->apbPrevMemoryBases[BITMAP_PTR_2] = pBitmapPtr2;
		key->apbPrevMemoryBases[BITMAP_PTR_3] = pBitmapPtr3;
	}

	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	STAT_OFF_SCAN;                /* stop STAT timer */

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	FS_UNUSED_PARAMETER(inputPtr);
	FS_UNUSED_PARAMETER(outputPtr);
	return NO_ERR;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void FS_ENTRY_PROTO fs_InitializeData (void)
	{
		fsg_InitializeData ();
	}
#endif



/*********************************************************************/

/* fs_GetScaledAdvanceWidths returns only horizontal advance widths and is not meant to be used under rotation */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvStack;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvTwilightZone;
	uint16              usCurrentGlyphIndex;
	uint16              usGlyphIndex;
	uint16              usPPEm;
	int16               sNonScaledLSB;
	vectorType          fxGlyphWidth;
	point               f26DevAdvanceWidth;
	boolean             bHdmxEntryExist;
	boolean             bBitmapFound;
	ErrorCode           error;
#ifdef FSCFG_SUBPIXEL	
	boolean             bSubPixelWidth = FALSE;
    fsg_TransformRec *  TransformInfoForGridFit;
	void *              pvGlobalGSSubPixel;
	void *              pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Initialization  */

	bHdmxEntryExist = FALSE;

#ifdef FSCFG_SUBPIXEL	
	if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL	

	/*  Save current glyph index    */

	usCurrentGlyphIndex = key->ClientInfo.usGlyphIndex;

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psGlyphWidths == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);
	/* Only Grab 'hdmx' if not stretched or rotated */

#ifdef FSCFG_SUBPIXEL	
    /* for SubPixel, use Hdmx width only if we are in compatible width mode */
	if( !bSubPixelWidth &&
	    (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
	if( (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
	{

		/*  Check if we can quickly grab the widths from the 'hdmx' table   */

		error = sfac_CopyHdmxEntry(
			&key->ClientInfo,
			usPPEm,
			&bHdmxEntryExist,
			usFirstGlyph,
			usLastGlyph,
			psGlyphWidths);

		if (error != NO_ERR)
		{
			return(error);
		}

		/* If we got a hit on the 'hdmx' we are done    */

		if( bHdmxEntryExist )
		{
			return NO_ERR;
		}
	}

	/* No hit on 'hmdx', now it is time for the dirty work  */

	/* We need to prepare ourselves here for a potential grid fit */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL
    TransformInfoForGridFit = &key->TransformInfo;
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }
#endif // FSCFG_SUBPIXEL

    /*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, prevent further glyphs from being called */
			fs_SetState(key, (INITIALIZED | NEWSFNT));

			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, prevent further glyphs from being called */
			    fs_SetState(key, (INITIALIZED | NEWSFNT));

                /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

	/*  Now check 'LTSH' table for linear cutoff information    */

	error = sfac_GetLTSHEntries(
		&key->ClientInfo,
		usPPEm,
		usFirstGlyph,
		usLastGlyph,
		psGlyphWidths);

	/* The pfxGlyphWidths array contains a boolean for each glyph (from     */
	/* first glyph to last glyph) that indicates if the glyph scales        */
	/* linearly.                                                            */

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
#ifdef FSCFG_SUBPIXEL
        /* for SubPixel, use linear width only if we are in compatible width mode */
		if( !bSubPixelWidth &&
            (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
		if( (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
		{
			/* Glyph Scales Linearly    */


		error = sfac_ReadGlyphHorMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&key->usNonScaledAW,
				&sNonScaledLSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_UpdateAdvanceWidth (
				&key->TransformInfo,
				pvGlobalGS,
				key->usNonScaledAW,
				&fxGlyphWidth);

			psGlyphWidths[usGlyphIndex - usFirstGlyph] = (int16)((fxGlyphWidth.x + ONEHALFFIX) >> 16);
		}
		else    /* Glyph does not scale linearly */
		{
			error = LookForSbitAdvanceWidth (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceWidth );          /* value returned if found */
			
			if(error)
			{
				return (FS_ENTRY)error;
			}

			if (bBitmapFound == FALSE)
			{
				/* Glyph needs to be grid fitted */

				key->ClientInfo.usGlyphIndex = usGlyphIndex;

				error = fsg_GridFit (
					&key->ClientInfo,
					&key->maxProfile,
					&key->TransformInfo,
					pvGlobalGS,
					&key->pWorkSpaceAddr,
					pvTwilightZone,
					(FntTraceFunc)NULL,
					TRUE,
					&key->usScanType,
					&key->bGlyphHasOutline,
					&key->usNonScaledAW,
					key->SavedTransformInfo.bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
					);

				if(error)
				{
					return (FS_ENTRY)error;
				}

				fsg_GetDevAdvanceWidth (
					&key->pWorkSpaceAddr,
					&f26DevAdvanceWidth );
#ifdef FSCFG_SUBPIXEL
                if (bSubPixelWidth)
                /* we need to scale the value downs from hinting overscale */
                {
                    ROUND_FROM_HINT_OVERSCALE(f26DevAdvanceWidth.x);
                }
#endif // FSCFG_SUBPIXEL
			}
			psGlyphWidths[(size_t)(usGlyphIndex - usFirstGlyph)] = (int16)((f26DevAdvanceWidth.x + DOT6ONEHALF) >> 6);
		}
	}

	/* Restore current glyph    */

	key->ClientInfo.usGlyphIndex = usCurrentGlyphIndex;
	
	return NO_ERR;
}

/*********************************************************************/

/*                  Vertical Metrics Helper Function                 */

/*            returns AdvanceHeight vectors for glyph range          */

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvStack;
	uint16              usGlyphIndex;
	uint16              usPPEm;
    uint16              usNonScaledAH;              /* advance height from vmtx */
	int16               sNonScaledTSB;              /* top side bearing from vmtx, not used */
	shortVector		    svDevAdvanceHeight;         /* advance height from sbits */
	vectorType			vecAdvanceHeight;
	vectorType			vecTopSideBearing;			/* not used */
	point               f26DevAdvanceHeight;
	boolean             bBitmapFound;
	ErrorCode           error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psvAdvanceHeights == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
		error = LookForSbitAdvanceHeight (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceHeight);           /* values returned if found */

		if(error)
		{
			return (FS_ENTRY)error;
		}

		if (bBitmapFound)                      /*   if bitmap metrics found */
		{
			svDevAdvanceHeight.x = (int16)((f26DevAdvanceHeight.x + DOT6ONEHALF) >> 6);
			svDevAdvanceHeight.y = (int16)((f26DevAdvanceHeight.y + DOT6ONEHALF) >> 6);
		}
		else        /* if (bBitmapFound == FALSE)   if no bitmap, read vmtx */
		{
			error = sfac_ReadGlyphVertMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&usNonScaledAH,
				&sNonScaledTSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_ScaleVerticalMetrics (
				&key->TransformInfo,
				pvGlobalGS,
				usNonScaledAH,
				sNonScaledTSB,
				&vecAdvanceHeight,
				&vecTopSideBearing);

			svDevAdvanceHeight.x = (int16)((vecAdvanceHeight.x + ONEHALFFIX) >> 16);
			svDevAdvanceHeight.y = (int16)((vecAdvanceHeight.y + ONEHALFFIX) >> 16);
		}
    	
    	*psvAdvanceHeights++ = svDevAdvanceHeight;
	}

	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance width */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceWidth )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->SavedTransformInfo.usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			pf26DevAdvanceWidth );
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance height */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceHeight )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->SavedTransformInfo.usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
        	pf26DevAdvanceHeight);
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}


/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*      returns glyph IDs for array or range of character codes      */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetMultiGlyphIDs(
	    &key->ClientInfo, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to Win95 - needs no font context, just a cmap pointer  */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;

	error = sfac_GetWin95GlyphIDs(
	    pbyCmapSubTable, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to WinNT                                               */

/*********************************************************************/

/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetWinNTGlyphIDs(
	    &key->ClientInfo, 
	    usCharCount, 
	    usFirstChar, 
		ulCharCodeOffset,
	    pulCharCode, 
	    pulGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}


/*********************************************************************/

/*                Outline Coordinates Helper Function                */

/* returns (x,y) coordinates of array of points on the glyph outline */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates)
{
	ErrorCode       error;
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}
	if (key->ulState & SIZEKNOWN)               /* fail a call after FindBimapSize */
	{
		return OUT_OFF_SEQUENCE_CALL_ERR;
	}
    
    if (key->bGlyphHasOutline == FALSE)
    {
        return BAD_POINT_INDEX_ERR;             /* no meaning if no outlines */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	fsg_GetContourData(
		&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
		(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
		&CList.afxXCoord,
		&CList.afxYCoord,
		&CList.asStartPoint,
		&CList.asEndPoint,
		&CList.abyOnCurve,
		&CList.abyFc,
		&CList.usContourCount);

	error = fsc_GetCoords(&CList, usPointCount, pusPointIndex, (PixCoord *)psvCoordinates);
	if (error != NO_ERR)
	{
		return(error);
	}

	return NO_ERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fscaler.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
	File:       fscaler.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>    10/14/97    CB      move usOverScale to fs_NewTransformation
		<9+>     7/17/90    MR      Conditionalize names in FSInput
		 <9>     7/14/90    MR      rename SQRT2 to FIXEDSQRT2, removed specificID and lowestRecPPEM
									from FSInfo
		 <8>     7/13/90    MR      FSInput now has a union to save space, points to matrix instead
									of storing it
		 <6>     6/21/90    MR      Change fillFunc to ReleaseSfntFrag
		 <5>      6/5/90    MR      remove readmvt and mapcharcodes
		 <4>      5/3/90    RB      Added memory area for new scan converter. MIKE REED - Removed
									.error from fsinfo structure. Added MapCharCodes and ReadMVT
									calls.
		 <3>     3/20/90    CL      New comment style for BBS. 
		 <2>     2/27/90    CL      New CharToIndexMap Table format.
	   <3.5>    11/15/89    CEL     Placed an ifdef around inline MPW calls to the trap. This makes
									it easier to compile for skia and the likes who do not use the
									MPW compiler.
	   <3.4>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Five
									unnecessary element in the output data structure have been
									deleted. (All the information is passed out in the bitmap data
									structure) fs_FindBMSize now also returns the bounding box.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Took out Mac specific functions.
	   <3.1>     9/15/89    CEL     Re-working dispatcher.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#include    "fscdefs.h"
#include    "fnt.h"

/* QuickDraw Types */

#ifndef _Quickdraw_
#ifndef __QUICKDRAW__   
	typedef struct BitMap {
		char* baseAddr;
		int16 rowBytes;
		Rect bounds;
	} BitMap;
#endif
#endif

#define MEMORYFRAGMENTS 9           /* extra memory base for overscaled bitmap */

#define NONVALID        0xffff

/* For the flags field in the flags field */

/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_SHORT_IS_OK 0x0001          /* set when calling fs_OpenFonts() */
/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_LONG_IS_OK  0x0002          /* set when calling fs_OpenFonts() */

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel flag field */
#define SP_SUB_PIXEL			0x0001          /* set when calling fs_NewTransformation() */
#define SP_COMPATIBLE_WIDTH		0x0002          /* set when calling fs_NewTransformation() */
#define SP_VERTICAL_DIRECTION	0x0004          /* set when calling fs_NewTransformation() */
#define SP_BGR_ORDER			0x0008          /* set when calling fs_NewTransformation() */
#endif // FSCFG_SUBPIXEL

typedef struct {
	vectorType      advanceWidth, leftSideBearing;
	vectorType      leftSideBearingLine, devLeftSideBearingLine;/* along AW line */
	vectorType      devAdvanceWidth, devLeftSideBearing;
} metricsType;

typedef struct {
	vectorType      advanceHeight, topSideBearing;
	vectorType      topSideBearingLine, devTopSideBearingLine;/* along AH line */
	vectorType      devAdvanceHeight, devTopSideBearing;
} verticalMetricsType;

#define FS_MEMORY_SIZE  int32

/*
 * Output data structure to the Font Scaler.
 */
typedef struct {
	FS_MEMORY_SIZE  memorySizes[MEMORYFRAGMENTS];

	uint16          glyphIndex;
	uint16          numberOfBytesTaken; /* from the character code */

	metricsType     metricInfo;
	BitMap          bitMapInfo;

	/* Spline Data */
	int32           outlineCacheSize;
	uint16          outlinesExist;
	uint16          numberOfContours;
	F26Dot6         *xPtr, *yPtr;
	int16           *startPtr;
	int16           *endPtr;
	uint8           *onCurve;
	/* End of spline data */

	/* Only of interest to editors */
	F26Dot6         *scaledCVT;

	/* embedded bitmap return values */
	uint16          usBitmapFound;

	/* vertical metrics */
	verticalMetricsType     verticalMetricInfo;

	/* resulting number of gray levels, 0 means black/white, 1 bit per pixel,
	   (grayscale bitmap are 1 byte per pixel)
	   the number of level you receive is not necessarily what you ask for.
	   If there is no embedded gray bitmap :
			usOverscale 2 -> usGrayLevels 5,
			usOverscale 4 -> usGrayLevels 17,
			usOverscale 8 -> usGrayLevels 65,
	   If an embedded gray bitmap is present in the font, the embedded bitmap
	   will be selected before a gray bitmap generated with an higher overscale.
	   If you are unhappy with the number of gray levels (usGrayLevels) you can force
	   the embedded bitmap off by setting bNoEmbeddedBitmap to TRUE  */
	uint16          usGrayLevels;            
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
	BitMap			overscaledBitmapInfo;
#endif
	uint8			*fc;         /* contour flags, one byte for every contour */
} fs_GlyphInfoType;

/*
 * Input data structure to the Font Scaler.
 *
 * styleFunc is not supported in this version of the Font Scalar. Should be set to NULL.
 *
 */

#ifndef UNNAMED_UNION

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		} newsfnt;
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    traceFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} newtrans;
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		} newglyph;
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceFunc;
			boolean         bSkipIfBitmap;
		} gridfit;
		int32*  outlineCache;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache;           /* cacheing works with banding */
		} band;
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache;
		} scan;
	} param;
} fs_GlyphInputType;

#else

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		};
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    tracePreProgramFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		};
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		};
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceGridFitFunc;
			boolean         bSkipIfBitmap;
		};
		int32*              outlineCache1;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache3;          /* cacheing works with banding */
		};
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache2;
		};
	};
} fs_GlyphInputType;

#endif      /* unnamed union */

#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/* Font scaler trap selctors */
#define OUTLINEFONTTRAP     0xA854
#define FS_OPENFONTS        0x8000
#define FS_INITIALIZE       0x8001
#define FS_NEWSFNT          0x8002
#define FS_NEWTRANS         0x8003
#define FS_NEWGLYPH         0x8004
#define FS_GETAW            0x8005
#define FS_GRIDFITT         0x8006
#define FS_NOGRIDFITT       0x8007
#define FS_FINDBMSIZE       0x8008
#define FS_SIZEOFOUTLINES   0x8009
#define FS_SAVEOUTLINES     0x800a
#define FS_RESTOREOUTLINES  0x800b
#define FS_CONTOURSCAN      0x800c
#define FS_CLOSE            0x800d
#define FS_READMVT          0x800e
#define FS_MAPCHAR_CODES    0x800f

#ifndef FS_ENTRY
#define FS_ENTRY int32
#endif

#ifdef MACINIT
extern FS_ENTRY fs__OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_OPENFONTS,0xA854};
extern FS_ENTRY fs__Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_INITIALIZE,0xA854};
extern FS_ENTRY fs__NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWSFNT,0xA854};
extern FS_ENTRY fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWTRANS,0xA854};
extern FS_ENTRY fs__NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWGLYPH,0xA854};
extern FS_ENTRY fs__GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GETAW,0xA854};
extern FS_ENTRY fs__ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GRIDFITT,0xA854};
extern FS_ENTRY fs__ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NOGRIDFITT,0xA854};
extern FS_ENTRY fs__FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};
extern FS_ENTRY fs__FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs__SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SIZEOFOUTLINES,0xA854};
extern FS_ENTRY fs__SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SAVEOUTLINES,0xA854};
extern FS_ENTRY fs__RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_RESTOREOUTLINES,0xA854};

extern FS_ENTRY fs__ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CONTOURSCAN,0xA854};
extern FS_ENTRY fs__CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CLOSE,0xA854};

#else

/*** Direct Calls to Font Scaler Client Interface, for Clients not using the trap mechanism ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

/* these three optional calls are for caching the outlines */
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#endif

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void FS_ENTRY_PROTO fs_InitializeData (void);
#endif

/*** Rasterizer Helper Functions ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths);

typedef struct {
	int16 x;
	int16 y;
} shortVector;

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);


/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates);

/*** Gray scale definitions ***/

#ifndef FSCFG_DISABLE_GRAYSCALE

#define FS_GRAY_VALUE_MASK  0x008B      /* support usOverScale of 1, 2, 4, & 8 */
#define FS_SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#else

#define FS_GRAY_VALUE_MASK  0x0000      /* no grayscale support */
#define FS_SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#endif
/* the value of FS_GRAY_VALUE_MASK and FS_SBIT_BITDEPTH_MASK can be used to determine
   the usGrayLevels the client need to support.

   Fonts without embedded bitmap :
		usGrayLevels = usOverScale * usOverScale + 1;

   Fonts with embedded bitmap (sbit) :
		usGrayLevels = 0x01 << usBitDepth;

  The usGrayLevels the client may receive with the current version are :

  0 for black/white
  5, 17, 65 fonts without embedded bitmap
  4, 16, 256 fonts with embedded bitmap

*/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);


#ifdef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/* new transformation parameters saved in the internal Key */
typedef struct fs_NewTrans {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			transMatrix     transformMatrix;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} fs_NewTrans;

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
	fs_NewTrans			SavedTransformInfo; /* saved transformation info */
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fscdefs.h ===
/*
	File:       fscdefs.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	Copyright:  c 1991-1999 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		
				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <3>    11/27/90    MR      Add #define for PASCAL. [ph]
		 <2>     11/5/90    MR      Move USHORTMUL from fontmath.h, add Debug definition [rb]
		 <7>     7/18/90    MR      Add byte swapping macros for INTEL, moved rounding macros from
									fnt.h to here
		 <6>     7/14/90    MR      changed defines to typedefs for int[8,16,32] and others
		 <5>     7/13/90    MR      Declared ReleaseSFNTFunc and GetSFNTFunc
		 <4>      5/3/90    RB      cant remember any changes
		 <3>     3/20/90    CL      type changes for Microsoft
		 <2>     2/27/90    CL      getting bbs headers
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#ifndef FSCDEFS_DEFINED
#define FSCDEFS_DEFINED

#include "fsconfig.h"
#include <stddef.h>
#include <limits.h>

#if !defined(__cplusplus)       // true/false are reserved words for C++
#define true 1
#define false 0
#endif

#ifndef TRUE
	#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef FS_PRIVATE
#define FS_PRIVATE static
#endif

#ifndef FS_PUBLIC
#define FS_PUBLIC
#endif

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

#define NULL_GLYPH  0

/* banding type constants */

#define FS_BANDINGOLD       0
#define FS_BANDINGSMALL     1
#define FS_BANDINGFAST      2
#define FS_BANDINGFASTER    3

/* Dropout control values are now defined as bit masks to retain compatability */
/* with the old definition, and to allow for current and future expansion */

#define SK_STUBS          0x0001       /* leave stubs white */
#define SK_NODROPOUT      0x0002       /* disable all dropout control */
#define SK_SMART              0x0004        /* symmetrical dropout, closest pixel */

/* Values used to decode curves */

#define ONCURVE             0x01

typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef __int64 int64;
typedef unsigned __int64 uint64;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef short ShortFract;                       /* 2.14 */

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#ifndef ClientIDType
#define ClientIDType int32
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef TMP_CONV
#define TMP_CONV
#endif

#ifndef FS_MAC_PASCAL
#define FS_MAC_PASCAL
#endif

#ifndef FS_PC_PASCAL
#define FS_PC_PASCAL
#endif

#ifndef FS_MAC_TRAP
#define FS_MAC_TRAP(a)
#endif

/* QuickDraw Types */

#ifndef _MacTypes_
#ifndef __TYPES__
	typedef struct Rect {
		int16 top;
		int16 left;
		int16 bottom;
		int16 right;
	} Rect;

typedef long Fixed;         /* also defined in Mac's types.h */
typedef long Fract;

#endif
#endif

typedef struct {
	Fixed       transform[3][3];
} transMatrix;

typedef struct {
	Fixed       x, y;
} vectorType;

/* Private Data Types */
typedef struct {
	int16 xMin;
	int16 yMin;
	int16 xMax;
	int16 yMax;
} BBOX;

typedef struct {
	F26Dot6 x;
	F26Dot6 y;
} point;

typedef int32 ErrorCode;

#define ALIGN(object, p) p =    (p + ((uint32)sizeof(object) - 1)) & ~((uint32)sizeof(object) - 1);

#define ROWBYTESLONG(x)     (((x + 31) >> 5) << 2)

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

#ifdef FSCFG_BIG_ENDIAN /* target byte order matches Motorola 68000 */
	#define SWAPL(a)        (a)
	#define CSWAPL(a)       (a)
	#define SWAPW(a)        (a)
	#define CSWAPW(a)       (a)
	#define SWAPWINC(a)     (*(a)++)
#else
	/* Portable code to extract a short or a long from a 2- or 4-byte buffer */
	/* which was encoded using Motorola 68000 (TrueType "native") byte order. */
	#define FS_2BYTE(p) ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
	#define FS_4BYTE(p) ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )
	#define SWAPW(a)	((int16) FS_2BYTE( (unsigned char *)(&a) ))
	#define CSWAPW(num)	(((((num) & 0xff) << 8) & 0xff00) + (((num) >> 8) & 0xff)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPL(a)	((int32) FS_4BYTE( (unsigned char *)(&a) ))
	#define CSWAPL(num)	((CSWAPW((num) & 0xffff) << 16) + CSWAPW((num) >> 16)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPWINC(a) SWAPW(*(a)); a++    /* Do NOT parenthesize! */
#endif

#ifndef SWAPW // provoke compiler error if still not defined
	#define SWAPW	a
	#define SWAPW	b
#endif

#ifndef LoopCount
#define LoopCount int16      /* short gives us a Motorola DBF */
#endif

#ifndef ArrayIndex
#define ArrayIndex int32     /* avoids EXT.L on Motorola */
#endif

typedef void (*voidFunc) ();
typedef void * voidPtr;
typedef void (FS_CALLBACK_PROTO *ReleaseSFNTFunc) (voidPtr);
typedef void * (FS_CALLBACK_PROTO *GetSFNTFunc) (ClientIDType, int32, int32);

#ifndef	FS_ASSERT
#define FS_ASSERT(expression, message)
#endif

#ifndef Assert
#define Assert(a)
#endif

#ifndef MEMSET
#define MEMSET(dst, value, size) (void)memset(dst,value,(size_t)(size))
#define FS_NEED_STRING_DOT_H
#endif

#ifndef MEMCPY
#define MEMCPY(dst, src, size) (void)memcpy(dst,src,(size_t)(size))
#ifndef FS_NEED_STRING_DOT_H
#define FS_NEED_STRING_DOT_H
#endif
#endif

#ifdef FS_NEED_STRING_DOT_H
#undef FS_NEED_STRING_DOT_H
#include <string.h>
#endif

#ifndef FS_UNUSED_PARAMETER
#define FS_UNUSED_PARAMETER(a) (a=a)     /* Silence some warnings */
#endif

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} LocalMaxProfile;

#ifdef FSCFG_SUBPIXEL

	// master switch for turning on Backwards Compatible SubPixel
	// if we turn this off, we basically get the same as in b/w, but with coloured fringes
	// to get the complete original 16x overscaling behaviour back, set HINTING_HOR_OVERSCALE below to 16
	#define	SUBPIXEL_BC
	
	#define ProjVectInX(localGS)	((localGS).proj.x == ONEVECTOR && (localGS).proj.y == 0)
	#define	ProjVectInY(localGS)	((localGS).proj.y == ONEVECTOR && (localGS).proj.x == 0)
	
	#ifdef SUBPIXEL_BC
		
		// master switch for turning on Enhanced Backwards Compatible Advance Width SubPixel Algorithm
		#define SUBPIXEL_BC_AW_STEM_CONCERTINA
		
		#define RunningSubPixel(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_SUB_PIXEL))
		#define CompatibleWidthSP(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
		#define VerticalSPDirection(globalGS)	((uint16)((globalGS)->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
		#define BGROrderSP(globalGS)			((uint16)((globalGS)->flHintForSubPixel & FNT_SP_BGR_ORDER))
	//	assume that horizontal direction RGB is more frequent than vertical direction, hence put the latter into the else-path
	//	Notice that in order to decide whether we're currently in SubPixel direction, we look at the projection vector, because that's the direction
	//	along which distances are measured. If this projection vector has a non-zero component in the physical direction of our device, we will decide
	//	that rounding should be done in the SubPixel way. For example, if our device has its SubPixel direction in x, and if the projection vector
	//	points in any direction other than the y direction, the pv has a non-zero component in x, hence we round in the SubPixel way. This behaviour
	//	corresponds to the original implementation of the 16x overscaling rasterizer, where the non-zero component in x would be overscaled by 16.
		#define InSubPixelDirection(localGS)	((uint16)(!VerticalSPDirection((localGS).globalGS) ? !ProjVectInY(localGS) : !ProjVectInX(localGS)))
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				16 // for itrp_RoundToGrid & al to work properly, this should be a power of two, else have to tabulate rounding
		#define VISUAL_OVERSCALE				2  // between 1.7 and 3, corresponding to the visually experienced resolution relative to the physical resolution.
												   // for our purposes, the exact value is not particularly crucial (cf. ENGINE_COMP_OVERSCALE, MIN_DIST_OVERSCALE,
												   // in interp.c) hence we set it to 2 for efficiency
	#else
		#define RunningSubPixel(globalGS)		false
		#define CompatibleWidthSP(globalGS)		false
		#define VerticalSPDirection(globalGS)	false
		#define InSubPixelDirection(localGS)	false
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				1
		#define VISUAL_OVERSCALE				1
	#endif
//	#define VIRTUAL_PIXELSIZE		(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
//	these values are used in various rounding functions, which includes rounding the advance width
//	they are specific to the rounding operation, if this should become necessary in the future
	#define VIRTUAL_PIXELSIZE_RTDG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RDTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RUTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTHG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_ROFF	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	

	#define HINTING_HOR_OVERSCALE 1 // see SUBPIXEL_BC above for further comments

#ifdef FSCFG_SUBPIXEL_STANDALONE
	
	#define R_Subpixels		5
	#define G_Subpixels		9
	#define B_Subpixels		2

	/* IMPORTANT :
 
	   If you change any of the above
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) <= 256

	  */

	#define RGB_OVERSCALE (R_Subpixels + G_Subpixels + B_Subpixels)

#else

	#define SUBPIXEL_OVERSCALE 2

	/* IMPORTANT :
 
	   If you change SUBPIXEL_OVERSCALE
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) <= 256

	  */

	#define RGB_OVERSCALE (SUBPIXEL_OVERSCALE * 3)
#endif

	#define ROUND_FROM_RGB_OVERSCALE(x) x = ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE
	#define ROUND_FROM_HINT_OVERSCALE(x) x = ((x) + (HINTING_HOR_OVERSCALE >> 1) ) / HINTING_HOR_OVERSCALE
	#define ROUND_RGB_OVERSCALE(x) ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE

	#define FLOOR_RGB_OVERSCALE(x) ((x) < 0) ? -((-(x)+ RGB_OVERSCALE -1) / RGB_OVERSCALE) : ((x) / RGB_OVERSCALE) // by the way, this is NOT a floor operation
	#define CEIL_RGB_OVERSCALE(x) FLOOR_RGB_OVERSCALE((x) + RGB_OVERSCALE -1)

	/* we are storing into 2 bits per pixels, weight for each color can be 0,1 or 2 */
	#define MAX_RGB_INDEX (2 * 16 + 2 * 4 + 2 )

	#define SUBPIXEL_SCALEBACK_FACTOR ((RGB_OVERSCALE << 16) / HINTING_HOR_OVERSCALE)

	#define SUBPIXEL_SCALEBACK_UPPER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *120 /100)
	#define SUBPIXEL_SCALEBACK_LOWER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *100 /120)
#endif // FSCFG_SUBPIXEL

#endif  /* FSCDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fserror.h ===
/*
    File:       fserror.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		<>      10/14/97    CB      error if FDEF/IDEF in GlyphProgram
 		 <>     04/30/97    CB      ClaudeBe, missing ENDF, infinite loop/recursion
		 <>     03/1/97    CB      ClaudeBe, div by 0 in hinting error
        <4>     7/13/90    MR      made endif at bottom use a comment
         <3>      5/3/90    RB      Changed char to int8 for variable type.   Now it is legal to
                                    pass in zero as the address of memory when a piece of
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)
       <3.1>    11/14/89    CEL     Now it is legal to pass in zero as the address of memory when a
                                    piece of the sfnt is requested by the scaler. If this happens
                                    the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/************/
/** ERRORS **/
/************/
#define NO_ERR                      0x0000
#define NULL_KEY                    0x0000


/** EXTERNAL INTERFACE PACKAGE **/
#define NULL_KEY_ERR                0x1001
#define NULL_INPUT_PTR_ERR          0x1002
#define NULL_MEMORY_BASES_ERR       0x1003
#define VOID_FUNC_PTR_BASE_ERR      0x1004  /* No longer used */
#define OUT_OFF_SEQUENCE_CALL_ERR   0x1005
#define BAD_CLIENT_ID_ERR           0x1006
#define NULL_SFNT_DIR_ERR           0x1007
#define NULL_SFNT_FRAG_PTR_ERR      0x1008
#define NULL_OUTPUT_PTR_ERR         0x1009
#define INVALID_GLYPH_INDEX         0x100A
#define BAND_TOO_BIG_ERR            0x100B  /* possible with FindBandingSize */
#define INVALID_CHARCODE_ERR        0x100C

/* fnt_execute */
#define UNDEFINED_INSTRUCTION_ERR   0x1101
#define TRASHED_MEM_ERR             0x1102
#define DIV_BY_0_IN_HINTING_ERR     0x1103
#define MISSING_ENDF_ERR			0x1104
#define MISSING_EIF_ERR				0x1105
#define INFINITE_RECURSION_ERR		0x1106 
#define INFINITE_LOOP_ERR			0x1107 
#define FDEF_IN_GLYPHPGM_ERR		0x1108 
#define IDEF_IN_GLYPHPGM_ERR		0x1109 

#define TRACE_FAILURE_ERR			0x110A  /* can be used by a trace function to notify of an 
                                               internal error (memory allocation failed,...) */
#define JUMP_BEFORE_START_ERR	    0x110B
#define INSTRUCTION_ERR             0x110C  /* can be used by a trace function to notify the discovery of an error */

#define RAW_NOT_IN_GLYPHPGM_ERR		0x110D 

#define SECURE_STACK_UNDERFLOW      0x1110
#define SECURE_STACK_OVERFLOW       0x1111
#define SECURE_POINT_OUT_OF_RANGE   0x1112
#define SECURE_INVALID_STACK_ACCESS 0x1113
#define SECURE_FDEF_OUT_OF_RANGE    0x1114
#define SECURE_ERR_FUNCTION_NOT_DEFINED    0x1115
#define SECURE_INVALID_ZONE         0x1116
#define SECURE_INST_OPCODE_TO_LARGE 0x1117
#define SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP  0x1118
#define SECURE_STORAGE_OUT_OF_RANGE 0x1119
#define SECURE_CONTOUR_OUT_OF_RANGE 0x111A
#define SECURE_CVT_OUT_OF_RANGE     0x111B
#define SECURE_UNITIALIZED_ZONE     0x111C


/* fsg_CalculateBBox */
#define POINT_MIGRATION_ERR         0x1201

/* sc_ScanChar */
#define BAD_START_POINT_ERR         0x1301
#define SCAN_ERR                    0x1302
#define BAD_SCAN_KIND_ERR           0x1303
#define BAD_POINT_INDEX_ERR         0x1304

#define SMART_DROP_OVERFLOW_ERR     0x1305


/** SFNT DATA ERROR and errors in sfnt.c **/
#define SFNT_DATA_ERR               0x1400
#define POINTS_DATA_ERR             0x1401
#define INSTRUCTION_SIZE_ERR        0x1402
#define CONTOUR_DATA_ERR            0x1403
#define GLYPH_INDEX_ERR             0x1404
#define BAD_MAGIC_ERR               0x1405
#define OUT_OF_RANGE_SUBTABLE       0x1406
#define UNKNOWN_COMPOSITE_VERSION   0x1407
#define CLIENT_RETURNED_NULL        0x1408
#define MISSING_SFNT_TABLE          0x1409
#define UNKNOWN_CMAP_FORMAT         0x140A
#define BAD_MAXP_DATA               0x140B
#define SFNT_RECURSIVE_COMPOSITE_ERR 0x140C
#define GLYF_TABLE_CORRUPTION_ERR   0x140D
#define BAD_UNITSPEREM_ERR          0x140E
#define BAD_NUMLONGHORMETRICS_ERR   0x140F

/* spline call errors */
#define BAD_CALL_ERR                0x1500

#define TRASHED_OUTLINE_CACHE       0x1600

/* gray scale errors */
#define BAD_GRAY_LEVEL_ERR          0x1701
#define GRAY_OLD_BANDING_ERR        0x1703
#define GRAY_NO_OUTLINE_ERR         0x1704

/* embedded bitmap (sbit) errors */
#define SBIT_COMPONENT_MISSING_ERR  0x1801
#define SBIT_ROTATION_ERR           0x1802
#define SBIT_BANDING_ERR            0x1803
#define SBIT_OUTLINE_CACHE_ERR      0x1804

/* new transformation errors : */
#define TRAN_NULL_TRANSFORM_ERR     0x1901

/************ For Debugging *************/

#ifdef XXX
#define DEBUG_ON
pascal  Debug ()                     /* User break drop into Macsbug */
#ifdef  DEBUG_ON
extern  0xA9FF;
#else
{
    ;
}
#endif

#ifndef DEBUGGER
pascal void DEBUGGER(void) = 0xA9FF; 
#endif

#ifdef  LEAVEOUT
#ifndef DEBUGSTR
pascal  void DEBUGSTR (aString) int8 *aString; extern 0xABFF;
int8    *c2pstr ();
#define BugInfo( aString) DEBUGSTR( c2pstr(aString))
#endif
#endif

#endif  /* XXX */
/****************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fsglue.h ===
/*
	File:       fsglue.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1996. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

	      <>    12/15/95    CB      add fsg_UpdateAdvanceHeight
	   <11+>     7/17/90    MR      Change error return type to int
		<11>     7/13/90    MR      Declared function pointer prototypes, Debug fields for runtime
									range checking
		 <8>     6/21/90    MR      Add field for ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vectorMappingF
		 <6>      6/4/90    MR      Remove MVT
		 <5>      6/1/90    MR      Thus endeth the too-brief life of the MVT...
		 <4>      5/3/90    RB      adding support for new scan converter and decryption.
		 <3>     3/20/90    CL      Added function pointer for vector mapping
									Removed devRes field
									Added fpem field
		 <2>     2/27/90    CL      Change: The scaler handles both the old and new format
									simultaneously! It reconfigures itself during runtime !  Changed
									transformed width calculation.  Fixed transformed component bug.
	   <3.1>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Now it is legal to pass in zero as the address of
									memory when a piece of the sfnt is requested by the scaler. If
									this happens the scaler will simply exit with an error code !
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Added flag executeFontPgm, set in fs_NewSFNT
*/


/*** Offset table ***/

typedef struct {
	uint32 x;
	uint32 y;
	uint32 ox;
	uint32 oy;
	uint32 oox;
	uint32 ooy;
	uint32 onCurve;
	uint32 sp;
	uint32 ep;
	uint32 f;
	uint32 fc;        
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	uint32 pcr;
#endif
} fsg_OutlineFieldInfo;

typedef struct fsg_WorkSpaceAddr{
	 F26Dot6 *              pStack;                     /* Address of stack                  */
	 void *                 pGlyphOutlineBase;      /* Address of Glyph Outline Base     */
	 fnt_ElementType *  pGlyphElement;          /* Address of Glyph Element array    */
	 boolean *              pGlyphDataByteSet;      /* Address of ByteSet array          */
	 void *                 pvGlyphData;                /* Address of GlyphData array        */
	 void *                 pReusableMemoryMarker;  /* Address of reusable memory        */
} fsg_WorkSpaceAddr;

typedef struct fsg_WorkSpaceOffsets {
	uint32                  ulStackOffset;
	uint32                  ulGlyphOutlineOffset;
	uint32                  ulGlyphElementOffset;
	uint32                  ulGlyphDataByteSetOffset;
	uint32                  ulGlyphDataOffset;
	fsg_OutlineFieldInfo    GlyphOutlineFieldOffsets;
	 uint32                      ulReusableMemoryOffset;
	uint32                  ulMemoryBase6Offset;
	uint32                  ulMemoryBase7Offset;
	 uint32                      ulMemoryBase6Size;
	 uint32                      ulMemoryBase7Size;
} fsg_WorkSpaceOffsets;

typedef struct fsg_PrivateSpaceOffsets {
	 uint32                      offset_storage;
	 uint32                      offset_functions;
	 uint32                      offset_instrDefs;       /* <4> */
	 uint32                      offset_controlValues;
	 uint32                      offset_globalGS;
	 uint32                      offset_FontProgram;
	 uint32                      offset_PreProgram;
	 uint32                      offset_TwilightZone;
	 uint32                      offset_TwilightOutline;
	fsg_OutlineFieldInfo    TwilightOutlineFieldOffsets;
#ifdef FSCFG_SUBPIXEL
	 uint32                      offset_storageSubPixel;
	 uint32                      offset_functionsSubPixel;
	 uint32                      offset_instrDefsSubPixel;       /* <4> */
	 uint32                      offset_controlValuesSubPixel;
	 uint32                      offset_globalGSSubPixel;
	 uint32                      offset_TwilightZoneSubPixel;
	 uint32                      offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL
} fsg_PrivateSpaceOffsets;

typedef struct fsg_TransformRec {
	uint16              usEmResolution;     /* used to be int32 <4> */
	transMatrix         currentTMatrix;     /* Current Transform Matrix */
	boolean             bPhaseShift;        /* 45 degrees flag <4> */
	boolean             bPositiveSquare;    /* Transform is a positive square */
	boolean             bIntegerScaling;    /* Font uses integer scaling */
	Fixed               fxPixelDiameter;
	uint32              ulImageState;       /* is glyph rotated, stretched, etc. */
	boolean				bEmboldSimulation; 
	uint16	uBoldSimulHorShift;
} fsg_TransformRec;

/**********************/
/** MODULE INTERFACE **/
/**********************/

/*      Memory Management Routines  */

FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	 LocalMaxProfile *            pMaxProfile,    /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets);

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table    */
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace);

FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,      /* Cached sfnt information */
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram);  /* pointer to pre program   */

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets);

FS_PUBLIC void fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2);

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	 int32 *                     plSizeBitmap2);

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7);

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra);

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation);


/*      FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **			pFc,
	uint16 *            pNc);

FS_PUBLIC uint32      fsg_GetContourDataSize(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_DumpContourData(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 uint8 **               pbyOutline);

FS_PUBLIC void  fsg_RestoreContourData(
	 uint8 **               ppbyOutline,
	 F26Dot6 **             ppX,
	 F26Dot6 **             ppY,
	 int16 **               ppSp,
	 int16 **               ppEp,
	 uint8 **               ppOnCurve,
	 uint8 **               ppFc,
	 uint16 *               pNc);

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceWidth);

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceHeight);

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT);

FS_PUBLIC void  fsg_45DegreePhaseShift(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth);

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight);

FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing);

FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceWidth,
	 point *                devLeftSideBearing,
	 point *                LeftSideBearing,
	 point *                devLeftSideBearingLine,
	 point *                LeftSideBearingLine);

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceHeight,
	 point *                devTopSideBearing,
	 point *                TopSideBearing,
	 point *                devTopSideBearingLine,
	 point *                TopSideBearingLine);

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo);

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo);

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,     /* GlobalGS */
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16             usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16             usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *            psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *            psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	);

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC ErrorCode fsg_RunFontProgram(
	 void *                 globalGS,           /* GlobalGS */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_RunPreProgram (
	 sfac_ClientRec *   ClientInfo,
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table    */
	 fsg_TransformRec * TransformInfo,
	 void *                 pvGlobalGS,
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_GridFit (
	 sfac_ClientRec *   ClientInfo,      /* sfnt Client information     */
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table               */
	 fsg_TransformRec * TransformInfo,  /* Transformation information    */
	 void *                 pvGlobalGS,      /* GlobalGS                            */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc,
	 boolean                bUseHints,
	 uint16 *               pusScanType,
	 boolean *              pbGlyphHasOutline,
	 uint16 *               pusNonScaledAW,
	boolean                bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			    bSubPixel
#endif // FSCFG_SUBPIXEL
	 );

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void);
#endif

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel);


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fshelper.h ===
/*
	 File:		 helper.h

	 Contains:	 Helper exports for Font Scaler

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1993. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		 <1>		 6/11/93	 GregH		Created.
*/

#ifndef FS_MATH_PROTO
#define FS_MATH_PROTO
#endif

int32 FS_MATH_PROTO ShortMulDiv(int32 a, int16 b, int16 c);	 /* (a*b)/c */

Fract FS_MATH_PROTO FracSqrt(Fract);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fsconfig.h ===
/*
	File:       fsconfig.h : (Portable "Standard C" version)

	Written by: Lenox Brassell

	Contains:   #define directives for FontScaler build options

   Copyright:  c 1989-1993 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		<3>      4/21/93 GregH Documented file
		<2>      7/16/92    DJ      Added fnt_Report_Error() declaration.
		<1>      8/27/91    LB      Created file.

	Usage:  This file is "#include"-ed as the first statement in
			"fscdefs.h".  This file contains platform-specific
			override definitions for the following #define-ed data
		types and macros, which have default definitions in
		"fscdefs.h":

	Purpose:

		This file gives the integrator a place to override the
		default definitions of these items, as well as a place
		to define other configuration-specific macros.

	Definitions:

		The following type definitations can be changed. The defaults have been
		set up for a 32-bit system. Caveat emptor: any change to the defaults may
		severly effect performace or place severe limitations on the capabilities
		of the TrueType rasterizer.

				F26Dot6
					 This is currently defined as a fixed point 26.6 number.
					 If changed to short, it is a 10.6 number.

		The following definition changes the return type for all Font Scalar
		Client Interface calls.

				FS_ENTRY

		The following definition changes the calling convention for all Font
		Scalar Client Interface calls.  By default, the rasterizer uses register
		calling conventions because of the performance gains.

				FS_ENTRY_PROTO

		The following definitions are used for all private and public entry points
		in the TrueType Rasterizer. By default FS_PRIVATE is set to static, but
		for some uses, like profiling and debugging this is undesirable, and
		FS_PRIVATE can be set to null. FS_PUBLIC defaults to null.

				FS_PRIVATE
				FS_PUBLIC

		The following definitions are used for calling conventions to external
		math routines. The Macintosh has external math routines that use pascal
		calling conventions. To enable these, the FS_MAC_PASCAL must be set to
		"pascal". Similary the FS_PC_PASCAL variable needs to be set to "pascal"
		when calling external routines using pascal calling conventions.

				FS_MAC_PASCAL
				FS_PC_PASCAL

		This definition is used for calling Macintosh ToolBox routines. If the
		rasterizer is implemented on a non-Macintosh platform, this Macro should
		be null.

				FS_MAC_TRAP

		These macros are used to override the C memcpy and memset routines

				MEMCPY
				MEMSET

		These math routines can be hooked out by system routines.

				SHORTDIV
				SHORTMUL

		These macros are used to convert big-endian to little-endian. When
		running on a big-endian platform these macros are not necessary.

				SWAPL
				SWAPW
				SWAPWINC

		These macros are used to replace some math routines by faster assembly
		language routines. The notation used for the assembly language routines
		should indicate the processor targeted. For example:

				#define CompMul   CompMul386
				#define CompDiv   CompDiv386
				#define FracSqrt      FracSqrt386

	The following definitions change the way the TrueType rasterizer works on
	specific implementations. These definitions are usually switches that are
	defined or not defined.

		FSCFG_DEBUG

		This is used to create a debugging version of the rasterizer. This
		version does additional error checking and creates a debugger trap
		when the TrueType DEBUG instruction is called.

		FSCFG_FNTERR

		This is used to create a error checking version of the rasterizer. With
		this set, parameters passed to TrueType instructions are range checked.
		If any instructions fails a test, a error message is returned.

		FSCFG_MOVEABLE_MEMBASE

		This is used to implement moveable memory bases. If it is possible that
		the address of a memory base could change between a Font Scaler Client
		Interface call, then this flag should be set in the rasterizer.

		FSCFG_MICROSOFT_KK

		This flag is used to implement the Microsoft KK version of the TrueType
		rasterizer. The effect of this flag is to use a slightly different
		algorithm for parsing the Format 2 cmap table.

		FSCFG_BIG_ENDIAN

		This flag indicates the target platform of the rasterizer uses big-endian
		representation of multiple-byte integers. If this flag is not set, SWAP
		macros are used to convert all multiple-byte integers read from TrueType
		Font Files.

		FSCFG_REENTRANT

		This flag indicates that the TrueType rasterizer should be reentrant.
		This allows multiple treads of execution through the executable and gives
		better system through put on multi-threaded/process environments. Slight
		performance gains are possible when not setting this flag in single tasking
		environments.

		FSCFG_NO_INITIALIZED_DATA

		This flag should be set for platforms that do not support static
		initialization of data. With this flag, a new Font Scalar Client Interface
		call fs_InitializeData needs to be made.

		FSCFG_USESTATCARD

		This flag is set to turn on stat card timing services in the rasterizer.
		This can be used to collect timing information for profiling.
		
		FSCFG_USE_MASK_SHIFT

		This flag is set to enable bitmask generated by shifting rather than by
		table lookup.  Shifted bitmasks use less memory and MAY be faster than
		table bitmasks.  On Big-Endian platforms shifted bitmasks will produce
		bitmaps that are identical to Apple's definition (same byte order).
		Table bitmaps will be identical for all platforms.

		FSCFG_DISABLE_GRAYSCALE

		This flag is set to disable all grayscale functions and save a little
		code space along the way. If defined, all grayscale functions return
		a BAD_GRAY_LEVEL_ERR error code.

		FSCFG_FONTOGRAPHER_BUG

		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error

		FSCFG_EUDC_EDITOR_BUG

		The EUDC editor under NT 4.0 has a bug and create bogous fonts.
        	The EUDC editor set maxp->maxStackElements to 0 and use 1 stack element
        	in the pre/font program. If this flag is defined, we will ensure that
        	at least one StackElement is reserved to avoid memory corruption.

       		FSCFG_CONVERT_GRAY_LEVELS

        	with grayscale embedded bitmap, the number of gray levels can be different than expected
        	4, 16, 256 instead of 5, 17, 65. If FSCFG_CONVERT_GRAY_LEVELS is defined, a conversion will be done
        	in the rasterizer to the expected number of gray levels

       FSCFG_SUBPIXEL

        will activate the SubPixel code

		FSCFG_SUBPIXEL_STANDALONE

		will activate a special variant of the SubPixel code for the stand-alone rasterizer
		
        	FSCFG_SECURE

        	Enable critical error checking in the TrueType rasterizer.

		MAC_INIT

		This flag indicates that the TrueType rasterizer will be implemented as
		a Macintosh Init.

		UNNAMED_UNION

		This flag is set for compilers that implement unnamed unions

                ClientIDType

                This definition allow the change the type definition for ClientID. If you are using ClientID to pass a pointer
                and compiling the TrueType rasterizer for a platform where pointer are bigger than 32 bits, 
                you need to change this definition.

        FSCFG_NEW_GRAY_FILTER

        This flag indicates that we should use the new 6x6 filter over the
        4x4 overscale in fsc_CalcGrayMap.
*/

/* #define FSCFG_MICROSOFT_KK   */
/* #define FSCFG_USESTATCARD      */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_FNTERR           */
/* #define FSCFG_DEBUG            */
/* #define FSCFG_MOVABLE_MEM_BASE */
/* #define FSCFG_BIG_ENDIAN   */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_USE_MASK_SHIFT */
/* #define FSCFG_DISABLE_GRAYSCALE */

#define FSCFG_REENTRANT

#define FSCFG_FONTOGRAPHER_BUG

#define FSCFG_EUDC_EDITOR_BUG

#define FSCFG_SECURE

#define FSCFG_CONVERT_GRAY_LEVELS

#define FSCFG_SUBPIXEL

#define FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+


/* Windows NT, is moving the definition of the internal rasterizer key in fscaler.h for optimization purpose */
#define FSCFG_MOVE_KEY_IN_DOT_H

/* !!! This should be removed */
#define NOT_ON_THE_MAC

/* Assembly Optimization Switches */

/* #define CompMul      CompMul386  */
/* #define CompDiv      CompDiv386  */
/* #define FracSqrt     FracSqrt386 */

// use RtlRoutines for memory operations

// in all uses in the rasterizer MEMSET  is used to zero out the mem

// to get the prototype for RtlZeroMemory and RtlCopyMemory :

#ifdef FSCFG_INTERNAL
#include "nt.h"
#include "ntrtl.h"

#if DBG
/* to activate rasterizer assertions : */
VOID __cdecl TtfdDbgPrint(PCHAR DebugMessage,...);
    
VOID EngDebugBreak(
    VOID
    );

#define FS_ASSERT(expression, message) { if (!(expression)) { TtfdDbgPrint(message); EngDebugBreak();} }
#define Assert(expression) { if (!(expression)) { TtfdDbgPrint("FONT: TrueType rasterizer internal assert"); EngDebugBreak();} }
#endif // DBG

#endif

#define MEMSET(dst, value, size) RtlZeroMemory(dst, size)
#define MEMCPY(dst, src, size)   RtlCopyMemory(dst, src, size)


// easier to debug with no static functions [BODIND]

#define FS_PRIVATE

// interface to the outside world [bodind]

#define FS_ENTRY_PROTO           __cdecl
#define FS_CALLBACK_PROTO	 __cdecl

// client ID is commonly used to pass a pointer to a structure, for backwards compatibility it
// need to be at least a 32 bits value, to get ready for the 64 bits platform, we define it as ULONG_PTR

#define ClientIDType ULONG_PTR

// only do stamp checking in the debug version

// #if DBG
// #define DEBUGSTAMP
// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fsglue.c ===
/*++
	File:       FSglue.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):


				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <>     02/21/97    CB      ClaudeBe, scaled component in composite glyphs
		 <>     12/14/95    CB      add usNonScaledAH and sNonScaledTSB to  GlyphData
		 <7>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
													and one (always fractional) metrics. [rb]
		 <6>    11/16/90    MR      Add SnapShotOutline to make instructions after components work
													[rb]
		 <5>     11/9/90    MR      Unrename fsg_ReleaseProgramPtrs to RELEASESFNTFRAG. [rb]
		 <4>     11/5/90    MR      Change globalGS.ppemDot6 to globalGS.fpem, change all instrPtr
													and curve flags to uint8. [rb]
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Change matrix[2][2] back to a fract (in response to change in
													skia). However, ReduceMatrix converts it to a fixed after it has
													been used to "regularize" the matrix. Changed scaling routines
													for outline and CVT to use integer pixelsPerEm. Removed
													scaleFunc from the splineKey. Change some routines that were
													calling FracDiv and FixDiv to use LongMulDiv and ShortMulDiv for
													greater speed and precision. Removed fsg_InitScaling. [rb]
		<20>     8/22/90    MR      Only call fixmul when needed in finalComponentPass loop
		<19>      8/1/90    MR      Add line to set non90DegreeTransformation
		<18>     7/26/90    MR      remove references to metricInfo junk, don't include ToolUtils.h
		<17>     7/18/90    MR      Change error return type to int, split WorkSpace routine into
													two calls, added SWAPW macros
		<16>     7/14/90    MR      Fixed reference to const SQRT2 to FIXEDSQRT2
		<15>     7/13/90    MR      Ansi-C stuff, tried to use correct sizes for variables to avoid
									coercion (sp?)
		<12>     6/21/90    MR      Add calls to ReleaseSfntFrag
		<11>      6/4/90    MR      Remove MVT, change matrix to have bottom right element be a
									fixed.
		<10>      6/1/90    MR      Thou shalt not pay no more attention to the MVT!
		<8+>     5/29/90    MR      look for problem in Max45Trick
		 <8>     5/21/90    RB      bugfix in fsg_InitInterpreterTrans setting key->imageState
		 <7>      5/9/90    MR      Fix bug in MoreThanXYStretch
		 <6>      5/4/90    RB      support for new scan converter and decryption          mrr - add
									fsg_ReverseContours and key->reverseContour         to account
									for glyphs that are flipped.         This keeps the
									winding-number correct for         the scan converter.  Mike
									fixed fsg_Identity
		 <5>      5/3/90    RB      support for new scan converter and decryption  mrr - add
									fsg_ReverseContours and key->reverseContour to account for
									glyphs that are flipped. This keeps the winding-number correct
									for the scan converter.
		 <4>     4/10/90    CL      Fixed infinite loop counter - changed uint16 to int16 (Mikey).
		 <3>     3/20/90    CL      Added HasPerspective for finding fast case
									Removed #ifdef SLOW, OLD
									Changed NormalizeTransformation to use fpem (16.16) and to use max instead of length
									and to loop instead of recurse.
									Removed compensation for int ppem in fsg_InitInterpreterTrans (not needed with fpem)
									Greased loops in PreTransformGlyph, PostTransformGlyph, LocalPostTransformGlyph,
													 ShiftChar, ZeroOutTwilightZone, InitLocalT
									Changed GetPreMultipliers to special case unit vector * 2x2 matrix
									Added support for ppemDot6 and pointSizeDot6
									Changed fsg_MxMul to treat the perspective elements as Fracts
									arrays to pointers in ScaleChar
									Fixed bugs in loops in posttransformglyph, convert loops to --numPts >= 0
		 <2>     2/27/90    CL      It reconfigures itself during runtime !  New lsb and rsb
									calculation.  Shift bug in instructed components:  New error
									code for missing but needed table. (0x1409)  Optimization which
									has to do with shifting and copying ox/x and oy/y.  Fixed new
									format bug.  Changed transformed width calculation.  Fixed
									device metrics for transformed uninstructed sidebearing
									characters.  Dropoutcontrol scanconverter and SCANCTRL[]
									instruction.  Fixed transformed component bug.
									
	   <3.3>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. The old perspective bug has been fixed. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Changed
									sidebearing point calculations to use 16.16 precision. For zero
									or negative numbers in my tricky/fast square root computation it
									would go instable and loop forever. It was not able to handle
									large transformations correctly. This has been fixed and the
									normalization may call it self recursively to gain extra
									precision! It used to normalize an identity transformation
									unecessarily.
	   <3.2>     10/6/89    CEL     Phantom points were removed causing a rounding of last 2 points
									bug. Characters would become distorted.
	   <3.1>     9/27/89    CEL     Fixed transformation anchor point bug.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some
									enhanclocalpostements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/* rwb r/24/90 - Add support for scanControlIn and scanControlOut variables in global graphiscs
 * state
 */
/** System Includes **/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "interp.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "scale.h"

/*  CONSTANTS   */

/*  These constants are used for interpreting the scan control and scan type
	fields returned by the interpreter. They are documented in the TrueType
	specification under the SCANCTRL and SCANTYPE instructions.
 */

#define SCANINFO_SIZE_MASK   0x000000FF
#define SCANINFO_FLAGS_MASK  0x00003F00
#define SCANINFO_TYPE_MASK   0xFFFF0000
#define SCANINFO_SIZE_CLEAR  ~SCANINFO_SIZE_MASK
#define SCANINFO_FLAGS_CLEAR ~SCANINFO_FLAGS_MASK
#define SCANINFO_TYPE_CLEAR  ~SCANINFO_TYPE_MASK
#define SCANINFO_FLAGS_DONT  0x00003800
#define SCANINFO_FLAGS_DO    0x00000700
#define SCANCTRL_SIZE_MASK                   0x000000FF
#define SCANCTRL_DROPOUT_ALL_SIZES           0xFF
#define SCANCTRL_DROPOUT_IF_LESS             0x0100
#define SCANCTRL_DROPOUT_IF_ROTATED          0x0200
#define SCANCTRL_DROPOUT_IF_STRETCHED        0x0400
#define SCANCTRL_NODROP_UNLESS_LESS          0x0800
#define SCANCTRL_NODROP_UNLESS_ROTATED       0x1000
#define SCANCTRL_NODROP_UNLESS_STRETCH       0x2000
#define SCANTYPE_UNINITIALIZED               0xFFFF

/* fo the key->imageState field */
#define IMAGESTATE_ROTATED      0x0400
#define IMAGESTATE_STRETCHED    0x1000
#define IMAGESTATE_NON_POS_RECT 0x2000
#define IMAGESTATE_SIZE_MASK    0x00FF
#define IMAGESTATE_MAX_PPEM_SIZE 0x000000FF

#define COMPOSITE_ROOT                  0
#define MAX_TWILIGHT_CONTOURS       1
#define DEFAULT_COMPONENT_ELEMENTS  3UL
#define DEFAULT_COMPONENT_DEPTH     1UL
static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};

/*********** macros ************/

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define CHECK_GLYPHDATA(pglyphdata) FS_ASSERT((( (pglyphdata)->acIdent[0] == 'G') &&                            \
											( (pglyphdata)->acIdent[1] == 'D')),"Illegal GlyphData pointer");
#define MAX_COMPONENT_DEPTH(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentDepth, DEFAULT_COMPONENT_DEPTH)
#define MAX_COMPONENT_ELEMENTS(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentElements, DEFAULT_COMPONENT_ELEMENTS)

#define MAX_NESTED_GLYPHS(pMaxProfile) (uint32)((MAX_COMPONENT_DEPTH(pMaxProfile) + 1) + MAX_COMPONENT_ELEMENTS(pMaxProfile));

/**********************************************************************************/
/*  TYPEDEFS    */

typedef enum {
	glyphSimple,
	glyphIncompleteComposite,
	glyphComposite,
	glyphUndefined
} GlyphTypes;


/* Glyph Data   */

typedef struct GlyphData GlyphData;

struct GlyphData{
	char        acIdent[2];             /* Identifier for GlyphData                         */
	GlyphData * pSibling;               /* Pointer to siblings                              */
	GlyphData * pChild;                 /* Pointer to children                              */
	GlyphData * pParent;                /* Pointer to parent                                */
	sfac_GHandle hGlyph;                /* Handle for font access                           */
	GlyphTypes  GlyphType;              /* Type of glyph                                    */
	uint16      usGlyphIndex;           /* Glyph Index                                      */
	BBOX        bbox;                   /* Bounding box for glyph                           */
	uint16      usNonScaledAW;          /* Nonscaled Advance Width                          */
	uint16      usNonScaledAH;          /* Nonscaled Advance Height                         */
	int16       sNonScaledLSB;          /* Nonscaled Left Side Bearing                      */
	int16       sNonScaledTSB;          /* Nonscaled Top Side Bearing                       */
	uint16      usDepth;                /* Depth of Glyph in composite tree                 */
	sfac_ComponentTypes MultiplexingIndicator;/* Flag for arguments of composites                */
	boolean     bRoundXYToGrid;         /* Round composite offsets to grid                  */
	int16       sXOffset;               /* X offset for composite (if supplied)             */
	int16       sYOffset;               /* Y offset for composite (if supplied)             */
	uint16      usAnchorPoint1;         /* Anchor Point 1 for composites (if not offsets)   */
	uint16      usAnchorPoint2;         /* Anchor Point 2 for composites (if not offsets)   */
	transMatrix mulT;                   /* Transformation matrix for composite              */
	boolean     bUseChildMetrics;       /* Should use child metrics?                        */
	boolean     bUseMyMetrics;          /* Is glyph USE_MY_METRICS?                         */
	boolean     bScaleCompositeOffset; 	/* false by default, Apple scale the composite offset, MS doesn't */ 
	point       ptDevLSB;               /* Left Side Bearing Point                          */
	point       ptDevRSB;               /* Right Side Bearing Point                         */
	uint16      usScanType;             /* ScanType value for this glyph                    */
	uint16      usSizeOfInstructions;   /* Size (in bytes) of glyph instructions            */
	uint8 *     pbyInstructions;        /* Pointer to glyph instructions                    */
	fnt_ElementType * pGlyphElement;    /* Current glyph element pointer                    */

	/* the following variables were added to allow correct handling of scaled/rotated coposite glyphs */
	transMatrix currentTMatrix;         /* current Transf matrix, composite + user transform */
	boolean     bSameTransformAsMaster; /* same transformation as the master glyph, no composite scaling or rotation  */
	int16       sNonScaledTopOriginX;   /* Nonscaled Top Origin X                            */
};

/**********************************************************************************/

/* PRIVATE PROTOTYPES <4> */

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16      usMaxPoints,
	uint16      usMaxContours,
	fsg_OutlineFieldInfo * offsetPtr,
	uint32 *    pulOutlineSize,
	uint32 *    pulReusableMarker);

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter   */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW);     /* Return NonScaled Advance Width    */
	
FS_PRIVATE ErrorCode   fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max nested components */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,      /* True if glyph has outline         */
    uint32*             pCompositePoints,   /* total number of point for composites, to check for overflow */
    uint32*             pCompositeContours); /* total number of contours for composites, to check for overflow */
	
FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address        */
	GlyphData *         pGlyphData,         /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData);   /* Next GlyphData pointer   */

FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,             /* GlyphData pointer        */
	GlyphData *     pChildGlyphData);       /* Child GlyphData pointer  */

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution);

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData);            /* GlyphData pointer    */

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,             /* GlyphData pointer    */
	GlyphData *     pParentGlyphData);      /* GlyphData pointer    */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState);

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr);/* WorkSpace Address    */

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData **            ppGlyphData);   /* GlyphData pointer    */

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address    */
	GlyphData *         pGlyphData);        /* GlyphData pointer    */

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth);       /* Glyph depth          */

FS_PRIVATE void fsg_CheckFit(
	int32       lSize1,
	int32       lSize2,
	int32       lSize3,
	int32       lTotalSize,
	uint32 *    pfResult);

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
	);     

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement);

/* FSGlue Code  */

/* ..............MEMORY MANAGEMENT ROUTINES................ */


/*                                                              
 * fsg_PrivateFontSpaceSize : This data should remain intact for the life of the sfnt
 *              because function and instruction defs may be defined in the font program
 *              and/or the preprogram.
 */
/*

	 PRIVATE SPACE Memory Layout

typedef struct fsg_PrivateSpaceOffsets {
	 0  +===========+   ---------------------  <- PrivateSpaceOffsets.offset_storage;
		|           |
		|           |   TrueType Storage
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_functions;
		|           |
		|           |   TrueType Function Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_instrDefs;
		|           |
		|           |   TrueType Instruction Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_controlValues;
		|           |
		|           |   TrueType Scaled CVT
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_globalGS;
		| pStack    |
		| pStorage  |
		| pCVT      |
		| pFDEF     |   TrueType Global GS
		| pIDEF     |
		| pFPGM     |
		| pPPGM     |
		| pGlyphPgm |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_FontProgram;
		|           |
		|           |   TrueType Font Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_PreProgram;
		|           |
		|           |   TrueType Pre Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightZone;
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Twilight Element
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightOutline;
		|x[maxtzpts]|   Twilight Outline
		+-----------+
		|y[maxtzpts]|
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxtzct]|
		+-----------+
		|ox[maxtzpt]|
		+-----------+
		|oox[mxtzpt]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxtzpts]|
		+===========+   ---------------------

*/
FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	LocalMaxProfile *           pMaxProfile,      /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets)
{
	uint32  ulOutlineSize;
	uint32  ulReusableMarker;   /* Unused dummy variable */
    uint32  ulLastOffset;

	PrivateSpaceOffsets->offset_storage         = 0L;
	PrivateSpaceOffsets->offset_functions       = PrivateSpaceOffsets->offset_storage         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefs       = PrivateSpaceOffsets->offset_functions   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValues   = PrivateSpaceOffsets->offset_instrDefs   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGS        = PrivateSpaceOffsets->offset_controlValues + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGS);
#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_storageSubPixel         = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
	PrivateSpaceOffsets->offset_functionsSubPixel       = PrivateSpaceOffsets->offset_storageSubPixel         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefsSubPixel       = PrivateSpaceOffsets->offset_functionsSubPixel   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValuesSubPixel   = PrivateSpaceOffsets->offset_instrDefsSubPixel   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGSSubPixel        = PrivateSpaceOffsets->offset_controlValuesSubPixel + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGSSubPixel);
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGSSubPixel + (uint32)sizeof (fnt_GlobalGraphicStateType);
#else
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
#endif // FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_PreProgram      = PrivateSpaceOffsets->offset_FontProgram + (uint32)SFAC_LENGTH (ClientInfo, sfnt_fontProgram);

    PrivateSpaceOffsets->offset_TwilightZone    = PrivateSpaceOffsets->offset_PreProgram      + (uint32)SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZone);

#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_TwilightZoneSubPixel    = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZoneSubPixel);
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZoneSubPixel + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
#else
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutline;
#endif // FSCFG_SUBPIXEL

/*
	Setup Twilight Zone outline space. This space contains all of the components
	to describe a Twilight Zone outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the field
	offsets e.g. x, ox, oox, &c.
*/
	/*** Outline -- TWILIGHT ZONE ***/

	fsg_GetOutlineSizeAndOffsets(
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS,
		&(PrivateSpaceOffsets->TwilightOutlineFieldOffsets),
		&ulOutlineSize,
		&ulReusableMarker);

#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_TwilightOutlineSubPixel = PrivateSpaceOffsets->offset_TwilightOutline + ulOutlineSize;
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutlineSubPixel);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL

#ifdef FSCFG_FONTOGRAPHER_BUG
/*
		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error */

	if ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_controlValues < 256 * (uint32)sizeof (F26Dot6))
	{
		ulOutlineSize = (256 * (uint32)sizeof (F26Dot6)) + PrivateSpaceOffsets->offset_controlValues - ulLastOffset;
	}
#endif // FSCFG_FONTOGRAPHER_BUG

	return ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_storage);
}


/*                          
 * fsg_WorkSpaceSetOffsets : This stuff changes with each glyph
 *
 * Computes the workspace size and sets the offsets into it.
 *
 */

/*

	WORKSPACE Memory Layout

	  0 +===========+    ---------------------  <- WorkSpaceOffsets.ulGlyphElementOffset
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 1
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 2
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|           |
		:           :          :
		|           |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element [MaxComponentDepth + 1]
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphOutlineOffset
		|x[maxpts]  |   Glyph Outline
		+-----------+
		|y[maxpts]  |
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxctrs]|
		+-----------+
		|ox[maxpts] |   <- WorkSpaceOffsets.ulReusableMemoryOffset


        !!! with SubPixel, we need to put the ulReusableMemoryOffset after ox because of the conversion done in GetContourData !!!
		+-----------+
		|oox[maxpts]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxpts]  |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataByteSetBaseOffset
		| T| F| T| F|
		+-----------+
		| F| F| F| F|
		+-----------+
		| F| F| F| F|   Glyph Data Allocation ByteSet
		+-----------+   (number of bytes = ulGlyphDataCount)
		| F| F| F| F|
		+-----------+
		| F| F| F| F|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataBaseOffset
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 1
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 2
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|           |
		:           :           :
		|           |
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData [ulGlyphDataCount]
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulStackOffset
		|           |
		|           |
		|           |   Stack
		|           |
		|           |
		|           |
		+===========+   ---------------------

*/

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	LocalMaxProfile *        pMaxProfile,    /* Max Profile Table    */
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace)
{
	uint32                       ulOutlineDataSize;
	uint32                       ulWorkSpacePos;
	uint32                       ulGlyphDataCount;
    uint16                       maxStackElements;

	ulWorkSpacePos = 0UL;

/*
	Setup the glyph element data array. This data structure contains all of the
	addresses into the glyph outline space. There are the same number of glyph
	element arrays as there are outline spaces; this allows us to handle the
	worstcase composite in the font.
*/
	WorkSpaceOffsets->ulGlyphElementOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof (fnt_ElementType) *
		  (uint32)(MAX_COMPONENT_DEPTH(pMaxProfile) + 1);

/*** Outline -- GLYPH *****/
/*
	Setup Glyph outline space. This space contains all of the components
	to describe a Glyph outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the elemental
	offsets e.g. x, ox, oox, &c.

	Once we have calculated the size of one outline space, we will duly note
	its size, and then add enough space to handle the outlines for the worst
	case composite depth in the font.
*/
	ALIGN(int16, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphOutlineOffset = ulWorkSpacePos; /* Remember start of Glyph Element */

	fsg_GetOutlineSizeAndOffsets(
		(uint16)(PHANTOMCOUNT + MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints)),
		(uint16)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours),
		&(WorkSpaceOffsets->GlyphOutlineFieldOffsets),
		&ulOutlineDataSize,
		(uint32 *)&(WorkSpaceOffsets->ulReusableMemoryOffset));

	/* Adjust Reusable memory marker to be based from zero, rather than GlyphOutline */

	WorkSpaceOffsets->ulReusableMemoryOffset += WorkSpaceOffsets->ulGlyphOutlineOffset;

	ulWorkSpacePos += ulOutlineDataSize;
/*
	Set the GlyphData ByteSet array. This array is used to track the memory used
	in GlyphData. Each entry in this array is a boolean.  One needs to also
	calculate the number of GlyphData's that will be needed to handle the
	worstcase composite in the font.
*/
	ALIGN(boolean, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataByteSetOffset = ulWorkSpacePos;
	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	ulWorkSpacePos += ulGlyphDataCount * (uint32)sizeof (boolean);
/*
	Set up the GlyphData array. This array contains the information needed
	to describe composites and components for a glyph.
*/
	ALIGN(voidPtr, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof(GlyphData) * ulGlyphDataCount;


	ALIGN(F26Dot6, ulWorkSpacePos);
	WorkSpaceOffsets->ulStackOffset = ulWorkSpacePos;

    maxStackElements = pMaxProfile->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
        maxStackElements = 1;
    }
#endif // FSCFG_EUDC_EDITOR_BUG

	ulWorkSpacePos += (uint32)maxStackElements * (uint32)sizeof (F26Dot6);

/* Calculate amount of extra memory */

	*plExtraWorkSpace = (int32)ulWorkSpacePos - (int32)WorkSpaceOffsets->ulReusableMemoryOffset;
	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

/* Return the total size of the WorkSpace memory.   */

	return(ulWorkSpacePos);

}

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16                  usMaxPoints,
	uint16                  usMaxContours,
	fsg_OutlineFieldInfo *  offsetPtr,
	uint32 *                pulOutlineSize,
	uint32 *                pulReusableMarker)

{
	uint32      ulArraySize;

	offsetPtr->onCurve = 0;

	*pulOutlineSize    = (uint32)usMaxPoints * (uint32)sizeof (uint8);
	ALIGN(int16, *pulOutlineSize);

	offsetPtr->sp   = *pulOutlineSize;
	ulArraySize = (uint32)usMaxContours * (uint32)sizeof (int16);
	*pulOutlineSize += ulArraySize;
	offsetPtr->ep   = *pulOutlineSize;
	*pulOutlineSize += ulArraySize;

	/* need to be before the reusable marker, now that this flag is exported */
	offsetPtr->fc       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxContours * (uint32)sizeof (uint8);

	ALIGN(F26Dot6, *pulOutlineSize);
	offsetPtr->x       = *pulOutlineSize;
	ulArraySize = (uint32)usMaxPoints * (uint32)sizeof (F26Dot6);
	*pulOutlineSize    += ulArraySize;
	offsetPtr->y       = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifndef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL
	/* Everything below this point can be reused during contour scanning */

	offsetPtr->ox      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifdef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL

    offsetPtr->oy      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

    offsetPtr->oox     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;
	offsetPtr->ooy     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

	offsetPtr->f       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (uint8);

    ALIGN(int32, *pulOutlineSize);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	offsetPtr->pcr      = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (PhaseControlRelation);
#endif

}


FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,     /* Cached sfnt information  */
	LocalMaxProfile *       pMaxProfile,     /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram)   /* pointer to pre program   */
{
	void *                       pvGlobalGS;
	void *                       pvCVT;          /* pointer to CVT  */
	void *                       pvStore;
	void *                       pvFuncDef;
	void *                       pvInstrDef;
	uint32                       ulLengthFontProgram, ulLengthPreProgram;

	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storage;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functions;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefs;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS;

	*pvFontProgram =  pPrivateFontSpace + PrivateSpaceOffsets->offset_FontProgram;
	ulLengthFontProgram = SFAC_LENGTH(ClientInfo, sfnt_fontProgram);
	*pvPreProgram =   pPrivateFontSpace + PrivateSpaceOffsets->offset_PreProgram;
	ulLengthPreProgram = SFAC_LENGTH(ClientInfo, sfnt_preProgram);

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);

#ifdef FSCFG_SUBPIXEL
    /* prepare the second pvGlobalGS for SubPixel compatible width */
	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValuesSubPixel;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storageSubPixel;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functionsSubPixel;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefsSubPixel;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel;

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);
#endif // FSCFG_SUBPIXEL

}

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	pWorkSpaceAddr->pStack = (F26Dot6 *)(WorkSpaceOffsets->ulStackOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphOutlineBase = WorkSpaceOffsets->ulGlyphOutlineOffset + pWorkSpace;
	pWorkSpaceAddr->pGlyphElement = (fnt_ElementType *)(WorkSpaceOffsets->ulGlyphElementOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphDataByteSet = (boolean *)(WorkSpaceOffsets->ulGlyphDataByteSetOffset + pWorkSpace);
	pWorkSpaceAddr->pvGlyphData = (void *)(WorkSpaceOffsets->ulGlyphDataOffset + pWorkSpace);
	pWorkSpaceAddr->pReusableMemoryMarker = WorkSpaceOffsets->ulReusableMemoryOffset + pWorkSpace;
}

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	char *                  pOutlineBase;
	fnt_ElementType *       pGlyphElement;        /* Address of Glyph Element array   */
	fsg_OutlineFieldInfo *  pOffset;

	pOutlineBase =  (char *)pWorkSpaceAddr->pGlyphOutlineBase;
	pGlyphElement = pWorkSpaceAddr->pGlyphElement;

	/* Note: only the first level glyph element has address updated. Second */
	/* levels are updated when referenced.                                           */

	pOffset             = & (WorkSpaceOffsets->GlyphOutlineFieldOffsets);

	pGlyphElement->x        = (F26Dot6 *) (pOutlineBase + pOffset->x);
	pGlyphElement->y        = (F26Dot6 *) (pOutlineBase + pOffset->y);
	pGlyphElement->ox       = (F26Dot6 *) (pOutlineBase + pOffset->ox);
	pGlyphElement->oy       = (F26Dot6 *) (pOutlineBase + pOffset->oy);
	pGlyphElement->oox      = (F26Dot6 *) (pOutlineBase + pOffset->oox);
	pGlyphElement->ooy      = (F26Dot6 *) (pOutlineBase + pOffset->ooy);
	pGlyphElement->sp       = (int16 *) (pOutlineBase + pOffset->sp);
	pGlyphElement->ep       = (int16 *) (pOutlineBase + pOffset->ep);
	pGlyphElement->onCurve  = (uint8 *) (pOutlineBase + pOffset->onCurve);
	pGlyphElement->f        = (uint8 *) (pOutlineBase + pOffset->f);

	pGlyphElement->fc       = (uint8 *) (pOutlineBase + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pGlyphElement->pcr      = (PhaseControlRelation *) (pOutlineBase + pOffset->pcr);
#endif
}

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS));
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel));
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutline;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZone);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

	pTwilightElement->fc        = (uint8 *) (pTemp + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif

	return (void *)pTwilightElement;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZoneSubPixel);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif
	return (void *)pTwilightElement;
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    /* we don't allow the stack to be used to pass informations between pre-program and glyph program
       or between two glyph programs */
	return ((void *)pWorkSpaceAddr->pStack);
}

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets)
{
	return pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset;
}

FS_PUBLIC void  fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	uint32              ulMemoryOffset;

	ulMemoryOffset = WorkSpaceOffsets->ulReusableMemoryOffset;

	ulMemoryOffset += (uint32)lMGWorkSpace;  /* correct for MeasureGlyph Workspace */
	lExtraWorkSpace -= lMGWorkSpace;

	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

	/* Save original sizes */

	WorkSpaceOffsets->ulMemoryBase6Size = *plSizeBitmap1;
	WorkSpaceOffsets->ulMemoryBase7Size = *plSizeBitmap2;

	if( *plSizeBitmap1 > *plSizeBitmap2)
	{
		if( *plSizeBitmap1 <= lExtraWorkSpace )
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap1;

			if (( *plSizeBitmap2 <= lExtraWorkSpace - *plSizeBitmap1 ) &&
				( *plSizeBitmap2 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
				*plSizeBitmap2 = 0L;
			}
			*plSizeBitmap1 = 0L;
		}
		else if (( *plSizeBitmap2 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap2 > 0L))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			*plSizeBitmap2 = 0L;
		}

	}
	else  /* (plSizeBitmap1 <= *plSizeBitmap2) */
	{
		if(( *plSizeBitmap2 <= lExtraWorkSpace ) &&
		   ( *plSizeBitmap2 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap2;

			if (( *plSizeBitmap1 <= lExtraWorkSpace - *plSizeBitmap2 ) &&
				 ( *plSizeBitmap1 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
				*plSizeBitmap1 = 0L;
			}
			*plSizeBitmap2 = 0L;
		}
		else if (( *plSizeBitmap1 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap1 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			*plSizeBitmap1 = 0L;
		}
	}
}

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	 *plSizeBitmap1 = WorkSpaceOffsets->ulMemoryBase6Size;
	 *plSizeBitmap2 = WorkSpaceOffsets->ulMemoryBase7Size;
}

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7)
{
	if(WorkSpaceOffsets->ulMemoryBase6Offset != 0L)
	{
		*ppMemoryBase6 = WorkSpaceOffsets->ulMemoryBase6Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase6 = pClientBitmapPtr2;
	}

	if(WorkSpaceOffsets->ulMemoryBase7Offset != 0L)
	{
		  *ppMemoryBase7 = WorkSpaceOffsets->ulMemoryBase7Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase7 = pClientBitmapPtr3;
	}
}

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra)
{
	 *ppWorkSpaceExtra = (char *)(pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset);
}

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	scl_QueryPPEM(pvGlobalGS, pusPPEM);
}

/*  Return PPEM in both X and Y and 90 degree rotation factor for sbit matching */

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation)
{
	*pusRotation = mth_90degRotationFactor( &TransformInfo->currentTMatrix );
	scl_QueryPPEMXY(pvGlobalGS, pusPPEMX, pusPPEMY);
}


/*  FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **            pFc,
	uint16 *            pNc)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	*pX =       pElement->x;
	*pY =       pElement->y;
	*pSp =      pElement->sp;
	*pEp =      pElement->ep;
	*pOnCurve = pElement->onCurve;
	*pFc =     pElement->fc;
	*pNc      = (uint16)pElement->nc;
#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		/* we scale down the coordinate from x,y into ox, oy and return those */
		scl_ScaleDownFromSubPixelOverscale(pElement);
		*pX =       pElement->ox;
	}
#endif // FSCFG_SUBPIXEL
}

FS_PUBLIC uint32      fsg_GetContourDataSize(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	return( scl_GetContourDataSize( pElement ) );
}

FS_PUBLIC void  fsg_DumpContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	uint8 **            ppbyOutline)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_DumpContourData(pElement, ppbyOutline);
}

FS_PUBLIC void  fsg_RestoreContourData(
	uint8 **        ppbyOutline,
	F26Dot6 **      ppX,
	F26Dot6 **      ppY,
	int16 **        ppSp,
	int16 **        ppEp,
	uint8 **        ppOnCurve,
	uint8 **        ppFc,
	uint16 *        pNc)
{
	fnt_ElementType     pElement;

	scl_RestoreContourData(&pElement, ppbyOutline);

	*ppX =          pElement.x;
	*ppY =          pElement.y;
	*ppSp =         pElement.sp;
	*ppEp =         pElement.ep;
	*ppOnCurve =    pElement.onCurve;
	*ppFc =         pElement.fc;
	*pNc =          (uint16)pElement.nc;
}

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceWidth)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceWidth(pElement, pDevAdvanceWidth);
}

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceHeight)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceHeight(pElement, pDevAdvanceHeight);
}

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT)
{
	*ppScaledCVT = (F26Dot6 *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues);
}

FS_PUBLIC void  fsg_45DegreePhaseShift(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_45DegreePhaseShift(pElement);
}

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth)
{
	AdvanceWidth->y = 0;
	scl_ScaleAdvanceWidth(
		pvGlobalGS,
		AdvanceWidth,
		usNonScaledAW,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight)
{
	AdvanceHeight->x = 0;
	scl_ScaleAdvanceHeight(
		pvGlobalGS,
		AdvanceHeight,
		usNonScaledAH,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}


FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing )
{
	pvecAdvanceHeight->x = 0;           /* start with x values at zero */
	pvecTopSideBearing->x = 0;          /* since 'vmtx' refers to y values */

    scl_ScaleVerticalMetrics (
    	pvGlobalGS,
    	usNonScaledAH,
    	sNonScaledTSB,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix,
    	pvecAdvanceHeight,
    	pvecTopSideBearing);
}


FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceWidth,
	point *                 devLeftSideBearing,
	point *                 LeftSideBearing,
	point *                 devLeftSideBearingLine,
	point *                 LeftSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcLSBsAndAdvanceWidths(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceWidth,
		devLeftSideBearing,
		LeftSideBearing,
		devLeftSideBearingLine,
		LeftSideBearingLine);
}

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceHeight,
	point *                 devTopSideBearing,
	point *                 TopSideBearing,
	point *                 devTopSideBearingLine,
	point *                 TopSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcTSBsAndAdvanceHeights(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceHeight,
		devTopSideBearing,
		TopSideBearing,
		devTopSideBearingLine,
		TopSideBearingLine);
}

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_STRETCHED ) == IMAGESTATE_STRETCHED);
}

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_ROTATED ) == IMAGESTATE_ROTATED);
}

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16            usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16              usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *				psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *				psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	)
{
	ErrorCode       error;
	uint32          ulPixelsPerEm;
	transMatrix *   trans;

	trans = &TransformInfo->currentTMatrix;

	error = scl_InitializeScaling(
		pvGlobalGS,
		TransformInfo->bIntegerScaling,
		&TransformInfo->currentTMatrix,
		TransformInfo->usEmResolution,
		fxPointSize,
		sXResolution,
		sYResolution,
		usEmboldWeightx,       /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
		usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
		sWinDescender,
		lDescDev,
		psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
		psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
		bHintAtEmSquare,
		&ulPixelsPerEm);

	if(error)
	{
		return error;
	}

	TransformInfo->bPhaseShift = false;

	if ( ulPixelsPerEm > IMAGESTATE_MAX_PPEM_SIZE )
	{
		TransformInfo->ulImageState = (uint32)IMAGESTATE_MAX_PPEM_SIZE;
	}
	else
	{
		TransformInfo->ulImageState = ulPixelsPerEm;
	}

	TransformInfo->bPositiveSquare = mth_PositiveSquare( trans );

	if ( !(mth_PositiveRectangle( trans )))
	{
		TransformInfo->ulImageState |= IMAGESTATE_NON_POS_RECT;
	}

	if ( !(TransformInfo->bPositiveSquare) )
	{
		if( mth_GeneralRotation (trans))
		{
			TransformInfo->ulImageState |=  IMAGESTATE_ROTATED;
		}

		TransformInfo->ulImageState |= IMAGESTATE_STRETCHED;

		TransformInfo->bPhaseShift = mth_IsMatrixStretched(trans); /*<8>*/
	}

	TransformInfo->bEmboldSimulation = ((usEmboldWeightx != 0) || (usEmboldWeighty != 0)); 

	return NO_ERR;
}

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	scl_SetHintFlags(
		pvGlobalGS,
		bHintForGray
#ifdef FSCFG_SUBPIXEL
	    ,flHintForSubPixel
#endif // FSCFG_SUBPIXEL
        );
}
/*
 *  All this guy does is record FDEFs and IDEFs, anything else is ILLEGAL
 */
FS_PUBLIC ErrorCode fsg_RunFontProgram(
	void *                  pvGlobalGS,               /* GlobalGS     */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	void *                  pvTwilightElement,
	FntTraceFunc           traceFunc)
{
	return itrp_ExecuteFontPgm (
		(fnt_ElementType *)pvTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);
}

/*
 * fsg_RunPreProgram
 *
 * Runs the pre-program and scales the control value table
 *
 */
FS_PUBLIC ErrorCode fsg_RunPreProgram (
	sfac_ClientRec *    ClientInfo,
	LocalMaxProfile *   pMaxProfile,     /* Max Profile Table    */
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc)
{
	ErrorCode           result;
	F26Dot6 *           pfxCVT;
	fnt_ElementType *   pTwilightElement;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	result = itrp_SetDefaults (pvGlobalGS, TransformInfo->fxPixelDiameter);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_GetCVTPtr(pvGlobalGS, &pfxCVT);

	result = sfac_CopyCVT(ClientInfo, pfxCVT);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_ScaleCVT (pvGlobalGS, pfxCVT);

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	scl_ZeroOutlineData(
		pTwilightElement,
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = itrp_ExecutePrePgm (
		pTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);

	return result;
}

/*
 *      fsg_GridFit
 */
FS_PUBLIC ErrorCode fsg_GridFit (
	sfac_ClientRec *    ClientInfo,     /* sfnt Client information      */
	LocalMaxProfile *   pMaxProfile,    /* Max Profile Table            */
	fsg_TransformRec *  TransformInfo,  /* Transformation information   */
	void *              pvGlobalGS,     /* GlobalGS                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc,
	boolean             bUseHints,
	uint16 *            pusScanType,
	boolean *           pbGlyphHasOutline,
	uint16 *            pusNonScaledAW,
	boolean            bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	)
{
	ErrorCode           result;
	fnt_ElementType *   pTwilightElement;
	fnt_GlobalGraphicStateType *globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = fsg_CreateGlyphData (
		ClientInfo,
		pMaxProfile,
		TransformInfo,
		pvGlobalGS,
		pWorkSpaceAddr,
		pTwilightElement,
		traceFunc,
		bUseHints,
		pusScanType,
		pbGlyphHasOutline,
		pusNonScaledAW);

	if(result == NO_ERR)
	{
		if (TransformInfo->bEmboldSimulation)
		{
			fsg_Embold( pWorkSpaceAddr, pvGlobalGS, bUseHints, bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
			if(*pusNonScaledAW)
				*pusNonScaledAW +=  (TransformInfo->usEmResolution * 2 - 1) / 100; /* adjust pusNonScaledAW by 2% of Em height */
		}

		if ((TransformInfo->ulImageState & (IMAGESTATE_NON_POS_RECT)) || globalGS->bHintAtEmSquare)
		{
			scl_PostTransformGlyph (
				pvGlobalGS,
				pWorkSpaceAddr->pGlyphElement,
				&TransformInfo->currentTMatrix);
		}

		/* apply the translation part of the transformation matrix */
		scl_ApplyTranslation (
			pWorkSpaceAddr->pGlyphElement,
			&TransformInfo->currentTMatrix,
			bUseHints,
			globalGS->bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
	}
	return result;
}

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW)     /* Return NonScaled Advance Width    */
{
	GlyphData * pGlyphData;
	GlyphData * pNextGlyphData;
	boolean      bHasOutline;
	uint32       ulGlyphDataCount;
	ErrorCode   ReturnCode;
    uint32      CompositePoints = 0;
    uint32      CompositeContours = 0;

	*pbGlyphHasOutline = FALSE;
	bHasOutline = FALSE;

	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	fsg_InitializeGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr);
	ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pGlyphData); /* Allocates GlyphData for topmost   */
	if(ReturnCode != NO_ERR)
	{
		return ReturnCode;
	}
												 /* parent  */
	fsg_InitializeGlyphData(pGlyphData, pWorkSpaceAddr,
		ClientInfo->usGlyphIndex, COMPOSITE_ROOT);

	while(pGlyphData != NULL)
	{
		CHECK_GLYPHDATA( pGlyphData );

		ReturnCode = fsg_ExecuteGlyph(
			ClientInfo,
			pMaxProfile,
			TransformInfo,
			ulGlyphDataCount,
			pvGlobalGS,
			pGlyphData,
			pWorkSpaceAddr,
			pTwilightElement,
			traceFunc,
			bUseHints,
			&bHasOutline,
            &CompositePoints,
            &CompositeContours);
		if(ReturnCode)
		{
			return ReturnCode;
		}
		*pbGlyphHasOutline |= bHasOutline;
		*pusScanType = pGlyphData->usScanType;
		fsg_ChooseNextGlyph(pWorkSpaceAddr, pGlyphData, &pNextGlyphData);
		*pusNonScaledAW = pGlyphData->usNonScaledAW;
		pGlyphData = pNextGlyphData;
	}

	return NO_ERR;
}

FS_PRIVATE ErrorCode    fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max Number of nested glyphs */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                      */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,       /* True if glyph has outline         */
    uint32*                pCompositePoints,/* total number of point for composites, to check for overflow */
    uint32*                pCompositeContours)  /* total number of contours for composites, to check for overflow */
{
	ErrorCode       ReturnCode;
	boolean         bCompositeGlyph;
	boolean         bLastComponent;
	boolean         bWeHaveInstructions;
	boolean         bWeHaveCompositeInstructions;
	boolean         bScanInfoChanged;
	boolean 		bWeHaveAScale;
	uint16          usScanType;
	uint16          usScanControl;
	GlyphData *     pChildGlyphData;
	uint16          usComponentElementCount;
	uint16          contour;

	*pbHasOutline = FALSE;

	if (pGlyphData->GlyphType == glyphUndefined)
	{
		if(pGlyphData->pParent != NULL)
		{
			scl_IncrementChildElement(pGlyphData->pGlyphElement, pGlyphData->pParent->pGlyphElement);
		} else {
			pGlyphData->currentTMatrix = TransformInfo->currentTMatrix;
		}

		ReturnCode = sfac_ReadGlyphHeader(ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->hGlyph, &bCompositeGlyph, pbHasOutline,
			&pGlyphData->pGlyphElement->nc, &pGlyphData->bbox);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		/* Get advance width, advance height, left side bearing and top side bearing information  */

		ReturnCode = sfac_ReadGlyphMetrics(
			ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->usNonScaledAW, &pGlyphData->usNonScaledAH, 
			&pGlyphData->sNonScaledLSB, &pGlyphData->sNonScaledTSB, &pGlyphData->sNonScaledTopOriginX);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (bCompositeGlyph)
		{
			pGlyphData->GlyphType = glyphIncompleteComposite;
		}
		else
		{
			pGlyphData->GlyphType = glyphSimple;
		}
	}

	if (pGlyphData->GlyphType == glyphSimple)
	{
		ReturnCode = sfac_ReadOutlineData(
			pGlyphData->pGlyphElement->onCurve,
			pGlyphData->pGlyphElement->ooy, pGlyphData->pGlyphElement->oox,
			&pGlyphData->hGlyph, pMaxProfile, *pbHasOutline, pGlyphData->pGlyphElement->nc,
			pGlyphData->pGlyphElement->sp, pGlyphData->pGlyphElement->ep,
			&pGlyphData->usSizeOfInstructions, &pGlyphData->pbyInstructions,
            pCompositePoints, pCompositeContours);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}


        fsg_CheckOutlineOrientation (pGlyphData->pGlyphElement);

        ReturnCode = fsg_SimpleInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->sNonScaledTopOriginX,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
		{
			pGlyphData->usScanType = SK_NODROPOUT;
		}
		else
		{
			pGlyphData->usScanType = usScanType;
		}

		// here we update the contour orientation bit if necessary, to reflect the final orientation of the contours in the composite
		if (FixMul(pGlyphData->mulT.transform[0][0],pGlyphData->mulT.transform[1][1]) - FixMul(pGlyphData->mulT.transform[0][1],pGlyphData->mulT.transform[1][0]) < 0) {
			for (contour = 0; contour < pGlyphData->pGlyphElement->nc; contour++) {
				pGlyphData->pGlyphElement->fc[contour] ^= OUTLINE_MISORIENTED;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphComposite)
	{
		ReturnCode = fsg_CompositeInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->sNonScaledTopOriginX,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (pGlyphData->bUseChildMetrics)
		{
			scl_SetSideBearingPoints(
				pGlyphData->pGlyphElement,
				&pGlyphData->ptDevLSB,
				&pGlyphData->ptDevRSB);
		}

		/* If composite has set SCANCTRL, use that value, otherwise merged children */

		if(bScanInfoChanged)
		{
			if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
			{
				pGlyphData->usScanType = SK_NODROPOUT;
			}
			else
			{
				pGlyphData->usScanType = usScanType;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphIncompleteComposite)
	{
		bLastComponent = FALSE;
		bWeHaveInstructions = FALSE;
		bWeHaveCompositeInstructions = FALSE;

		pGlyphData->GlyphType = glyphComposite;

		usComponentElementCount = 0;

		do
		{
			if(pGlyphData->usDepth + 1UL > MAX_COMPONENT_DEPTH(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			usComponentElementCount++;

			if(usComponentElementCount > MAX_COMPONENT_ELEMENTS(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pChildGlyphData);
			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			fsg_InitializeGlyphData(
				pChildGlyphData,
				pWorkSpaceAddr,
				NULL_GLYPH,
				(uint16)(pGlyphData->usDepth + 1U) );

			fsg_LinkChild(pGlyphData, pChildGlyphData);

			ReturnCode = sfac_ReadComponentData(
				&pGlyphData->hGlyph,
				&pChildGlyphData->MultiplexingIndicator,
				&pChildGlyphData->bRoundXYToGrid,
				&pChildGlyphData->bUseMyMetrics,
				&pChildGlyphData->bScaleCompositeOffset,
				&bWeHaveInstructions,
				&pChildGlyphData->usGlyphIndex,
				&pChildGlyphData->sXOffset,
				&pChildGlyphData->sYOffset,
				&pChildGlyphData->usAnchorPoint1,
				&pChildGlyphData->usAnchorPoint2,
				&pChildGlyphData->mulT,
				&bWeHaveAScale,
				&bLastComponent);

			if (bWeHaveAScale)
			{
				mth_MxConcat2x2( &pChildGlyphData->mulT, &pChildGlyphData->currentTMatrix );
				if (!mth_UnitarySquare(&pChildGlyphData->mulT))
				{
					pChildGlyphData->bSameTransformAsMaster	= FALSE; /* the component is scaled/rotated */
				}

			}

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			bWeHaveCompositeInstructions |= bWeHaveInstructions;
		}
		while (!bLastComponent);

		if(bWeHaveCompositeInstructions)
		{
			ReturnCode = sfac_ReadCompositeInstructions(
				&pGlyphData->hGlyph,
				&pGlyphData->pbyInstructions,
				&pGlyphData->usSizeOfInstructions);

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}
		}

	}
	return NO_ERR;
}


/*
 *      fsg_SimpleInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix			CurrentTMatrix,                  /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode           result;
/*
	On entry to fsg_SimpleInnerGrid fit the element structure should
	contain only valid original points (oox, ooy). The original points
	will be scaled into the old points (ox, oy) and those will be
	copied into the current points (x, y).
*/
	itrp_SetCompositeFlag(pvGlobalGS, FALSE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH, sNonScaledTopOriginX);

	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
		}

		/* hint and same transformation as master glyph */
		scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldCharSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);
		scl_AdjustOldPhantomSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentCharPoints(pGlyphElement);
		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}

		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}
	}
	else 
		/* no hints */
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentCharPoints(pGlyphElement);
			scl_CopyCurrentPhantomPoints(pGlyphElement);
		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalCharPointsToCurrentFixedFUnits (pGlyphElement);
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);
		}
	}

	return NO_ERR;
}


/*
 *      fsg_CompositeInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode             result;
/*
	On entry to fsg_CompositeInnerGridFit, the current points (x, y)
	are the only valid points in the element. We copy the current points
	onto the old points (ox, oy)
*/
	itrp_SetCompositeFlag(pvGlobalGS, TRUE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	/* Note: The original composite character points are invalid at this point. */
	/*       The interpreter handles this case correctly for composites.        */

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH, sNonScaledTopOriginX);
																  
	scl_CopyOldCharPoints(pGlyphElement);


	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
			scl_ScaleFixedCurrentCharPoints (pGlyphElement, pvGlobalGS);
		}

		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldSideBearingPoints(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}
		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}

	}
	else 
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentPhantomPoints(pGlyphElement);

		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);

		}
	}

	return NO_ERR;
}

FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address        */
	GlyphData *         pGlyphData,     /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData)/* Next GlyphData pointer   */
{
	if (pGlyphData->pChild != NULL)
	{
		*ppNextGlyphData = pGlyphData->pChild;
		CHECK_GLYPHDATA( *ppNextGlyphData );
		pGlyphData->pChild = NULL;
	}
	else
	{
		*ppNextGlyphData = pGlyphData->pSibling;
		fsg_DeallocateGlyphDataMemory(pWorkSpaceAddr, pGlyphData);
	}
}

#ifdef FSCFG_SUBPIXEL
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM);
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM) {
	if (CTM->transform[0][1] == 0 && CTM->transform[1][0] == 0) return 0; // Identity, 180 rotation, mirroring in x or y
	if (CTM->transform[0][0] == 0 && CTM->transform[1][1] == 0) return 1; // 90 rotation, 270 rotation, or any combination of these rotation with a mirroring in x or y
	return 2; // assume arbitrary rotation
} // fsg_AnalyzeCurrentTransformationMatrix
#endif

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution)
{
	fnt_ElementType * pChildElement;
	fnt_ElementType * pParentElement;
	F26Dot6         fxXOffset, fxYOffset;
	GlyphData *     pParentGlyphData; /* Parent GlyphData pointer   */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity;
#endif

	CHECK_GLYPHDATA(pChildGlyphData);
	pParentGlyphData = pChildGlyphData->pParent;
	CHECK_GLYPHDATA(pParentGlyphData);

	pChildElement = pChildGlyphData->pGlyphElement;
	pParentElement = pParentGlyphData->pGlyphElement;

	fsg_TransformChild(pChildGlyphData);

	if (!pChildGlyphData->bSameTransformAsMaster && pChildGlyphData->pParent->bSameTransformAsMaster)
	{
		/* coordinates need to be converted from fixed FUnits to user space */
		/* scaling the cordinate of the child glyph from fixed FUnits to user space,
		   scaling from original coordinate x/y to original coordinate x/y 
		   this is done to have the child and parent glyph at the same coordinate space */

		/* use the master transform */
		itrp_SetSameTransformFlag(pvGlobalGS, TRUE);

		scl_ScaleFixedCurrentCharPoints(pChildElement, pvGlobalGS);
		scl_ScaleFixedCurrentPhantomPoints(pChildElement, pvGlobalGS);

		pChildGlyphData->bSameTransformAsMaster = TRUE;
	}
	
#ifdef FSCFG_SUBPIXEL
	rotationParity = fsg_AnalyzeCurrentTransformationMatrix(&pParentGlyphData->currentTMatrix);
#endif

	if (pChildGlyphData->MultiplexingIndicator == OffsetPoints)
	{
		if (!pChildGlyphData->pParent->bSameTransformAsMaster)
		{
			/* we have both the parent and the child that are not at the same transformation as the master glyph
			   we need to use the scaling of the parent as a child scaling to scale the offset */
			scl_InitializeChildScaling(
				pvGlobalGS,
				pChildGlyphData->pParent->currentTMatrix,
				usEmResolution);
		}

		scl_CalcComponentOffset(
			pvGlobalGS,
			pChildGlyphData->sXOffset,
			pChildGlyphData->sYOffset,
			pChildGlyphData->bRoundXYToGrid,
			pChildGlyphData->bSameTransformAsMaster,
			pChildGlyphData->bScaleCompositeOffset,
			pChildGlyphData->mulT,
#ifdef FSCFG_SUBPIXEL
			rotationParity,
#endif
			&fxXOffset,
			&fxYOffset);
	}
	else        /* Values are anchor points */
	{
		FS_ASSERT(pChildGlyphData->MultiplexingIndicator == AnchorPoints,
			   "Bad Multiplexing Indicator");
		scl_CalcComponentAnchorOffset(
			pParentElement,
			pChildGlyphData->usAnchorPoint1,
			pChildElement,
			pChildGlyphData->usAnchorPoint2,
			&fxXOffset,
			&fxYOffset);
	}
	scl_ShiftCurrentCharPoints(pChildElement, fxXOffset, fxYOffset);


	/* If USE_MY_METRICS, copy side bearings to parent  */

	if (pChildGlyphData->bUseMyMetrics)
	{
		pParentGlyphData->bUseChildMetrics = TRUE;

		scl_SaveSideBearingPoints(
			pChildElement,
			&pParentGlyphData->ptDevLSB,
			&pParentGlyphData->ptDevRSB);
	}

	fsg_MergeScanType(pChildGlyphData, pParentGlyphData);

	/* Start the copy   */

	/* scl_AppendOutlineData(pChildElement, pParentElement); */

	scl_UpdateParentElement(pChildElement, pParentElement);

	pChildElement->nc = 0;
}



FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,     /* GlyphData pointer        */
	GlyphData *     pChildGlyphData)/* Child GlyphData pointer  */
{
	GlyphData * pTempGlyphData;

	if (pGlyphData->pChild == NULL)
	{
		pGlyphData->pChild = pChildGlyphData;
	}
	else
	{

		pTempGlyphData = pGlyphData->pChild;

		CHECK_GLYPHDATA(pTempGlyphData);

		while (pTempGlyphData->pSibling != pGlyphData)
		{
			pTempGlyphData = pTempGlyphData->pSibling;
			CHECK_GLYPHDATA(pTempGlyphData);
		}

		pTempGlyphData->pSibling = pChildGlyphData;
	}
	pChildGlyphData->pSibling = pGlyphData;
	pChildGlyphData->pParent =  pGlyphData;

	/* copy the transformation info from the parent */
	pChildGlyphData->currentTMatrix = pGlyphData->currentTMatrix;
	pChildGlyphData->bSameTransformAsMaster = pGlyphData->bSameTransformAsMaster;
}

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData)     /* GlyphData pointer    */
{

	/* Apply local transform to glyph   */

	if (!mth_Identity(&pGlyphData->mulT))
	{
		scl_LocalPostTransformGlyph (pGlyphData->pGlyphElement, &pGlyphData->mulT);
	}
}

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,       /* GlyphData pointer  */
	GlyphData *     pParentGlyphData) /* GlyphData pointer  */
{
	CHECK_GLYPHDATA(pGlyphData);
	CHECK_GLYPHDATA(pParentGlyphData);

	/* Merge Scan Type of parent and child  */

	if(pParentGlyphData->usScanType != SCANTYPE_UNINITIALIZED)
	{

		pParentGlyphData->usScanType =
			(uint16)(((pParentGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS)) &
			(pGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS))) |
			(pParentGlyphData->usScanType & SK_SMART));
	}
	else
	{
		pParentGlyphData->usScanType = pGlyphData->usScanType;
	}
}

/* Use various spline key values to determine if dropout control is to be activated
 * for this glyph, and if so what kind of dropout control.
 * The use of dropout control mode in the scan converter is controlled by 3 conditions.
 * The conditions are: Is the glyph rotated?, is the glyph stretched?,
 * is the current pixels per Em less than a specified threshold?
 * These conditions can be OR'd or ANDed together to determine whether the dropout control
 * mode ought to be used.

Six bits are used to specify the joint condition.  Their meanings are:

BIT     Meaning if set
8       Do dropout mode if other conditions don't block it AND
			pixels per em is less than or equal to bits 0-7
9       Do dropout mode if other conditions don't block it AND
			glyph is rotated
10      Do dropout mode if other conditions don't block it AND
			glyph is stretched
11      Do not do dropout mode unless ppem is less than or equal to bits 0-7
			A value of FF in 0-7  means all sizes
			A value of 0 in 0-7 means no sizes
12      Do not do dropout mode unless glyph is rotated
13      Do not do dropout mode unless glyph is stretched

In other words, we do not do dropout control if:
No bits are set,
Bit 8 is set, but ppem is greater than threshold
Bit 9 is set, but glyph is not rotated
Bit 10 is set, but glyph is not stretched
None of the conditions specified by bits 11-13 are true.

For example, 0xA10 specifies turn dropout control on if the glyph is rotated providing
that it is also less than 0x10 pixels per em.  A glyph is considered stretched if
the X and Y resolutions are different either because of the device characteristics
or because of the transformation matrix.  If both X and Y are changed by the same factor
the glyph is not considered stretched.

 */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState)
{
	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) <= (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((usScanControl & SCANCTRL_SIZE_MASK) == SCANCTRL_DROPOUT_ALL_SIZES))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_ROTATED) &&
		(ulImageState & IMAGESTATE_ROTATED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_STRETCHED) &&
		(ulImageState & IMAGESTATE_STRETCHED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) > (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_ROTATED) &&
		! (ulImageState & IMAGESTATE_ROTATED))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_STRETCH) &&
		! (ulImageState & IMAGESTATE_STRETCHED))
	{
		return FALSE;
	}

	return FALSE;
}

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr) /* WorkSpace Address      */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	for(ulIndex = 0; ulIndex < ulGlyphDataCount; ulIndex++)
	{
		abyGlyphDataFreeBlocks[ulIndex] = TRUE;
	}
}

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address      */
	GlyphData **        ppGlyphData)      /* GlyphData pointer    */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ulIndex = 0;
	while((!abyGlyphDataFreeBlocks[ulIndex]) && ulIndex < ulGlyphDataCount)
	{
		ulIndex++;
	}

	if (ulIndex == ulGlyphDataCount)
	{
		return SFNT_RECURSIVE_COMPOSITE_ERR;
	}

	abyGlyphDataFreeBlocks[ulIndex] = FALSE;

	*ppGlyphData = (GlyphData *)&((GlyphData *)pWorkSpaceAddr->pvGlyphData)[ulIndex];
	return NO_ERR;
}

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData *         pGlyphData)     /* GlyphData pointer    */
{
	ptrdiff_t   ptIndex;
	boolean *   abyGlyphDataFreeBlocks;

	pGlyphData->acIdent[0] = '\0';
	pGlyphData->acIdent[1] = '\0';

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ptIndex = (ptrdiff_t)(pGlyphData - (GlyphData *)pWorkSpaceAddr->pvGlyphData);

	abyGlyphDataFreeBlocks[ptIndex] = TRUE;
}

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth)        /* Glyph depth          */
{
	pGlyphData->acIdent[0] = 'G';
	pGlyphData->acIdent[1] = 'D';
	pGlyphData->pSibling = NULL;
	pGlyphData->pChild = NULL;
	pGlyphData->pParent = NULL;
	pGlyphData->GlyphType = glyphUndefined;
	pGlyphData->hGlyph.pvGlyphBaseAddress = NULL;
	pGlyphData->hGlyph.pvGlyphNextAddress = NULL;
	pGlyphData->usDepth = usDepth;
	pGlyphData->bUseMyMetrics = FALSE;
	pGlyphData->bScaleCompositeOffset = FALSE;
	pGlyphData->bUseChildMetrics = FALSE;
	pGlyphData->bbox.xMin = SHRT_MAX;
	pGlyphData->bbox.yMin = SHRT_MAX;
	pGlyphData->bbox.xMax = SHRT_MIN;
	pGlyphData->bbox.yMax = SHRT_MIN;
	pGlyphData->usSizeOfInstructions = 0;
	pGlyphData->pbyInstructions = NULL;
	pGlyphData->usNonScaledAW = 0;
	pGlyphData->sNonScaledLSB = 0;
	pGlyphData->MultiplexingIndicator = Undefined;
	pGlyphData->bRoundXYToGrid = FALSE;
	pGlyphData->usGlyphIndex = usGlyphIndex;
	pGlyphData->sXOffset = 0;
	pGlyphData->sYOffset = 0;
	pGlyphData->usAnchorPoint1 = 0;
	pGlyphData->usAnchorPoint2 = 0;
	pGlyphData->mulT = IdentTransform;
	pGlyphData->usScanType = SCANTYPE_UNINITIALIZED;
	pGlyphData->ptDevLSB.x = 0L;
	pGlyphData->ptDevLSB.y = 0L;
	pGlyphData->ptDevRSB.x = 0L;
	pGlyphData->ptDevRSB.y = 0L;
	pGlyphData->pGlyphElement = &pWorkSpaceAddr->pGlyphElement[usDepth];
	pGlyphData->pGlyphElement->nc = 0;
	pGlyphData->currentTMatrix = IdentTransform;
	pGlyphData->bSameTransformAsMaster = TRUE;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void)
{
	itrp_InitializeData ();
}
#endif

/* definitions and prototype for functions used in emboldening */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

#define LEFTSIDEBEARING 0
#define RIGHTSIDEBEARING 1

#define TOPSIDEBEARING 2
#define BOTTOMSIDEBEARING 3

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define POSINFINITY               0x7FFFFFFFUL

#define NotSameKnot(a,b) ((a).x != (b).x || (a).y != (b).y)

/* used by QDiv2 and FQuadraticEqn */
#define places16 16
#define half16 (1 << (places16-1))

#define F32Dot32 int64

#ifndef	Sgn
	#define Sgn(a)		((a) < 0 ? -1 : ((a) > 0 ? 1 : 0))
#endif

typedef struct F26Dot6VECTOR {
	F26Dot6 x;
	F26Dot6 y;
} F26Dot6VECTOR;

typedef struct { long x,y; } Vector;

typedef enum { linkBlack, linkGrey, linkWhite } LinkColor;

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY);

int64 QDiv2(int64 a, int64 b);

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2);

F32Dot32 FSqrt(uint64 radicand);

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2);

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1);

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1);

void MinMax2Vectors (Vector A,Vector B,Vector *Min, Vector *Max);

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max);

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber);

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1,int16 extremumNumber);

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect);

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt);

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented, 
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement); 
 
boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement);

/* emboldening related code */

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect)
{
	VECTOR Vec;

	itrp_Normalize (pVect->x, pVect->y, &Vec);

	/* transform from ShortFract to 26.6 */
	pVect->x = Vec.x >> 8;
	pVect->y = Vec.y >> 8;	
}

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt)
{
	/* this procedure was inspired by itrp_ISECT */
	F26Dot6 N, D;
	F26Dot6VECTOR B, A;
	F26Dot6VECTOR dB, dA;

	  dA.x = Pt2.x - (A.x = Pt1.x);
	  dA.y = Pt2.y - (A.y = Pt1.y);

	  dB.x = Pt4.x - (B.x = Pt3.x);
	  dB.y = Pt4.y - (B.y = Pt3.y);

	  if (dA.y == 0) 
	  {
		if (dB.x == 0) 
		{
		  ResultPt->x = B.x;
		  ResultPt->y = A.y;
		  return;
		}
		N = B.y - A.y;
		D = -dB.y;
	  } 
	  else if (dA.x == 0) 
	  {
		if (dB.y == 0) 
		{
		  ResultPt->x = A.x;
		  ResultPt->y = B.y;
		  return;
		}
		N = B.x - A.x;
		D = -dB.x;
	  } 
	  else if (MABS (dA.x) >= MABS (dA.y))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (B.y - A.y) - MulDiv26Dot6 (B.x - A.x, dA.y, dA.x);
		D = MulDiv26Dot6 (dB.x, dA.y, dA.x) - dB.y;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (B.y - A.y, dA.x, dA.y) - (B.x - A.x);
		D = dB.x - MulDiv26Dot6 (dB.y, dA.x, dA.y);
	  }

	  if (MABS(D) > 16) /* this test used to be D != 0 but for very small D we get degenerescence */
	  {
		ResultPt->x = B.x + (F26Dot6) MulDiv26Dot6 (dB.x, N, D);
		ResultPt->y = B.y + (F26Dot6) MulDiv26Dot6 (dB.y, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, what make sence in this special case is to take the
		  middle point between Pt2 and Pt3 */
		ResultPt->x = (Pt2.x + Pt3.x) >> 1;
		ResultPt->y = (Pt2.y + Pt3.y) >> 1;
	  }

	
}

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented,
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement) 


{
	F26Dot6VECTOR dPrev, dNext, Shift, CurrPt1,  NewPt, Delta ;
	F26Dot6 fxTemp;
    int32 i;

	dPrev.x = CurrPt.x - PrevPt.x;
	dPrev.y = CurrPt.y - PrevPt.y;

	dNext.x = NextPt.x - CurrPt.x;
	dNext.y = NextPt.y - CurrPt.y;

	/* compute the orthogonal vectors */

	fxTemp = dPrev.x;
	dPrev.x = -dPrev.y;
	dPrev.y = fxTemp;

	fxTemp = dNext.x;
	dNext.x = -dNext.y;
	dNext.y = fxTemp;

    if (bMisoriented)
    {
	    dPrev.x = -dPrev.x;
	    dPrev.y = -dPrev.y;
	    dNext.x = -dNext.x;
	    dNext.y = -dNext.y;
    }

    /* copy of the current point */

	CurrPt1 = CurrPt;

    if (bUnderTheThreshold)
    {
        /* most common case, we are just moving control points one pixel horizontally */

 	    if (dPrev.x > 0)
	    {
            CurrPt1.x += fxRightShift;
	    }
	    if (dNext.x > 0)
	    {
            CurrPt.x += fxRightShift;
	    }
    } else 
    {
        /* generalization, move along the vector normal to the curve */

	    /* normalize the vectors */
	    NormalizeVector26Dot6 (&dPrev);
	    NormalizeVector26Dot6 (&dNext);


        /* apply the shift on the previous segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dPrev.x > 0)
	    {
		    Shift.x = Mul26Dot6(dPrev.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dPrev.x, fxLeftShift);
	    }

	    if (dPrev.y < 0)
	    {
		    Shift.y = Mul26Dot6(dPrev.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dPrev.y, fxTopShift);
	    }

	    PrevPt.x += Shift.x;
	    PrevPt.y += Shift.y;

	    CurrPt1.x += Shift.x;
	    CurrPt1.y += Shift.y;

	    /* second segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dNext.x > 0)
	    {
		    Shift.x = Mul26Dot6(dNext.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dNext.x, fxLeftShift);
	    }

	    if (dNext.y < 0)
	    {
		    Shift.y = Mul26Dot6(dNext.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dNext.y, fxTopShift);
	    }

	    NextPt.x += Shift.x;
	    NextPt.y += Shift.y;

	    CurrPt.x += Shift.x;
	    CurrPt.y += Shift.y;
    }

	if (CurrPt1.x == CurrPt.x && CurrPt1.y == CurrPt.y)
	{
		/* both points were moved by the same value, no need to intersect */
		pElement->x[iPt] = CurrPt.x;
		pElement->y[iPt] = CurrPt.y;
	} else
	{
	/* we need to reintersect */
		Intersect26Dot6(PrevPt, CurrPt1, CurrPt, NextPt, &NewPt);

		/* sanity check that we are not moving the point too far from it's original position,
			this happen at low ppem size when segment lenght get small compared to the shift 
			or when hinting caused outline overlapp */
		Delta.x = NewPt.x - pElement->x[iPt];
		Delta.y = NewPt.y - pElement->y[iPt];

		if (Delta.x > fxRightShift)
		{
			NewPt.x = pElement->x[iPt] + fxRightShift;
		}
		if (Delta.x < -fxLeftShift)
		{
			NewPt.x = pElement->x[iPt] - fxLeftShift;
		}
		if (Delta.y < -fxBottomShift)
		{
			NewPt.y = pElement->y[iPt] - fxBottomShift;
		} 
		if (Delta.y > fxTopShift)
		{
			NewPt.y = pElement->y[iPt] + fxBottomShift;
		} 

		pElement->x[iPt] = NewPt.x;
		pElement->y[iPt] = NewPt.y;

	}
	/* shift all points by fxLeftShift, fxTopShift */
	pElement->x[iPt] += fxLeftShift;
	pElement->y[iPt] += fxBottomShift;

	if (pElement->y[iPt] < fxScaledDescender)
	{
		/* clipping to prevent going below the descender and causing out of bounds problems */
		pElement->y[iPt] = fxScaledDescender;
	}

    if (iPt != iPt1)
    {
        /* duplicate points at the same coordinate, we need to move them all */
	    for(i= iPt + 1; i <= iPt1; i++)
        {
	        pElement->x[i] = pElement->x[iPt];
	        pElement->y[i] = pElement->y[iPt];
        }
    }

}

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	fnt_ElementType *pElement;
	fnt_GlobalGraphicStateType *globalGS;
	int32 iContour, iPt, iPt1, iStartPt, iEndPt;
	F26Dot6VECTOR FirstPt, PrevPt, NextPt, CurrPt;
	F26Dot6 fxRightShift, fxLeftShift; 
	F26Dot6 fxTopShift, fxBottomShift; 
    boolean bUnderTheThreshold;
    boolean bMisoriented;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pElement = pWorkSpaceAddr->pGlyphElement;

    bUnderTheThreshold = (globalGS->uBoldSimulHorShift == 1);

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
    {
        bUnderTheThreshold = (globalGS->uBoldSimulHorShift <= HINTING_HOR_OVERSCALE);
    }
#endif // FSCFG_SUBPIXEL

	/* adjust the right sidebearing */
    if (pElement->x[RSBPOINTNUM(pElement)] != pElement->x[LSBPOINTNUM(pElement)]) 
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
#ifdef FSCFG_SUBPIXEL
	    if (bSubPixel)
        {
    	    pElement->x[RSBPOINTNUM(pElement)] += ( ( 1 / HINTING_HOR_OVERSCALE) << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        } else {
#endif // FSCFG_SUBPIXEL
			pElement->x[RSBPOINTNUM(pElement)] += (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL
    }

	/* adjust the bottom sidebearing, this is done by the value of the HorShift and not the VertShift for backwards compatibility
	   in vertical writing */
    if (pElement->y[BOTTOMSBPOINTNUM(pElement)] != pElement->y[TOPSBPOINTNUM(pElement)])
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
    	pElement->y[BOTTOMSBPOINTNUM(pElement)] -= (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
    }

	if (!bBitmapEmboldening)
	{    

		if (bUseHints)
		{
			/* to preserve the hinting, we should move by an integer amount of pixel */
			/* divide by 2, round to pixel, convert to 26.6 */
#ifdef FSCFG_SUBPIXEL
	        if (bSubPixel)
            {
			    fxLeftShift = ((globalGS->uBoldSimulHorShift /HINTING_HOR_OVERSCALE) >> 1) * HINTING_HOR_OVERSCALE; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
            } else {
#endif // FSCFG_SUBPIXEL
			    fxLeftShift = globalGS->uBoldSimulHorShift >> 1; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
#ifdef FSCFG_SUBPIXEL
            }
#endif // FSCFG_SUBPIXEL
			fxTopShift = globalGS->uBoldSimulVertShift >> 1;
			fxBottomShift = (globalGS->uBoldSimulVertShift - fxTopShift) << 6;
			fxTopShift = fxTopShift << 6;
		} else {
			/* divide by 2, convert to 26.6 */
			fxRightShift = globalGS->uBoldSimulHorShift << 5;
			fxLeftShift = globalGS->uBoldSimulHorShift << 5; 
			fxTopShift = globalGS->uBoldSimulVertShift << 5;
			fxBottomShift = globalGS->uBoldSimulVertShift << 5;
		}

		for (iContour = 0; iContour < pElement->nc; iContour++)
		{
			iStartPt = pElement->sp[iContour];
			iEndPt = pElement->ep[iContour];

			if (iEndPt - iStartPt >= 2)
			/* contour with less than 3 points cannot be emboldened */
			{
                bMisoriented = FALSE;
                if (pElement->fc[iContour] & OUTLINE_MISORIENTED)
                {
                    bMisoriented = TRUE;
                }
				/* we need to save the original coordinate of the first point for the computation of the last point */
				/* to compute the new coordinate for a point, we need the original coordinate of the point, the previous point
				  and the next point */

				FirstPt.x = pElement->x[iStartPt];
				FirstPt.y = pElement->y[iStartPt];

				CurrPt = FirstPt;

				PrevPt.x = pElement->x[iEndPt];
				PrevPt.y = pElement->y[iEndPt];

				NextPt.x = pElement->x[iStartPt+1];
				NextPt.y = pElement->y[iStartPt+1];

				iPt = iStartPt;

				while (iPt <= iEndPt)
				{
					iPt1 = iPt;

					/* deal with the special case of two points at the same coordinate, current and next */
					while ((NextPt.x == CurrPt.x) && (NextPt.y == CurrPt.y) && (iPt1 < iEndPt))
					{
						iPt1++;

						 if (iPt1 >= iEndPt)
							 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
						{
							NextPt.x = FirstPt.x;
							NextPt.y = FirstPt.y;
						} else {
							NextPt.x = pElement->x[iPt1 +1];
							NextPt.y = pElement->y[iPt1 +1];
						}
					}

					/* we do the computation for the current point */

					EmboldPoint(iPt, iPt1, bUnderTheThreshold, bMisoriented, PrevPt, CurrPt, NextPt, 
							fxRightShift, fxLeftShift, fxTopShift, fxBottomShift, globalGS->fxScaledDescender, pElement); 
                
					iPt = iPt1;

					iPt++;
					/* we compute Prev, Next, Curr coordinate for the next point */

					PrevPt = CurrPt;

					CurrPt = NextPt;

					 if (iPt >= iEndPt)
						 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
					{
						NextPt.x = FirstPt.x;
						NextPt.y = FirstPt.y;
					} else {
						NextPt.x = pElement->x[iPt +1];
						NextPt.y = pElement->y[iPt +1];
					}
				}
			}
		}
    }
}

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY)
{
    int32 sgn;

	/* as our coordinates are in desing unit, they fit in 16 bits and we are not overflowing here */

    sgn = DeltaPrevX*DeltaNextY - DeltaPrevY*DeltaNextX;
	return (short)Sgn(sgn); // +1 => left turn, -1 => right turn, 0 => straight
}

Vector AddV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	return c;
} // AddV

Vector SubV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	return c;
} // SubV

Vector ShlV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x << by;
	b.y = a.y << by;
	return b;
} // ShlV

Vector ShrV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x >> by;
	b.y = a.y >> by;
	return b;
} // ShrV

int64 QDiv2(int64 a, int64 b) { // special version that replaces epsilons by 1, which is actually 1/65536 since we're actually returning F48Dot16
	int64 q;

	if (a < 0 != b < 0) {
		if (a < 0) a = -a; else b = -b;
		if (a < b) q = -1; else if (a > b << places16) q = -65536-1; else q = -((a + (b >> 1))/b);
	} else {
		if (a < 0) a = -a, b = -b;
		if (a < b) q = 1; else if (a > b << places16) q = 65536+1; else q = (a + (b >> 1))/b;
	}
	return q;
} // QDiv2

F32Dot32 FSqrt(uint64 radicand) {
	uint64 bit,root,s;

	root = 0;
	for (bit = (uint64)1 << 62; bit >= 0x8000 /* we don't need the last 16 bits */; bit >>= 1) {
		s = bit + root;
		if (s <= radicand) {
			radicand -= s;
			root |= (bit << 1);
		};
		radicand <<= 1;
	}
	return root;
} // FSqrt

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2) {
	// the usual method for solving quadratic equations
	// input is actually in 32bit, output is F48Dot16
	int64 radicand,root,b1,b2,c1;
	
	*solutions = 0;
	if (a == 0) {
		if (b != 0) {
			*solutions = 1;
			c1 = -(c << places16);
			*t1 = QDiv2(c1,b);
		} // else b == 0, no solutions
	} else {
		a *= 2;
		radicand = b*b - 2*a*c;
		if (radicand > 0) {
			*solutions = 2;

            root = (FSqrt(radicand) + half16) >> places16;
            b <<= places16;

			b1 = -(b - root);
			b2 = -(b + root);
			*t1 = QDiv2(b1,a);
			*t2 = QDiv2(b2,a);
		} else if (radicand == 0) {
			*solutions = 1;
			b1 = -(b << places16);
			*t1 = QDiv2(b1,a);
		} // else radicand < 0, no solutions
	}
} // FQuadraticEqn

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1) {

//	here we're intersecting a straight line (W0, W1) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u + B.x = C.x*v + D.x
//		A.y*u + B.y = C.y*v + D.y
//
//	a system of two "halfway" linear eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u + B.x - D.x)/C.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u + B.y - D.y = C.y*(A.x*u + B.x - D.x)/C.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*C.x - C.y*A.x)*u + B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x = 0
//
//	which is a single linear eqn. in u with 0 thru 1 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual segment
//	and we don't count start/end points twice by including them in adjacent segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D;
    int64 a, b;
	long transitions;
	int64 u,vd;

//	re-write Line in polynomial form
//	(W1 - W0)*u + W0, which follows immediately from the "first degree" Bzier "curve" W0*(1-u) + W1*u
	A = SubV(W1,W0);
	B = W0;


//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	C = SubV(V1,V0);
	D = V0;

    a = (A.y*C.x - C.y*A.x);

	transitions = 0;

    if (a != 0)
    {
        b = B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x;

    //  a*u + b = 0 => u = -b / a

	    b = -b << places16;
	    u = QDiv2(b,a); /* u stored in 48.16 */
	    
	    if (0 < u && u <= 0x10000) {
                /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(C.x) > MABS(C.y))
            {
			    vd = ((int64)A.x)*u  + ((int64)(B.x - D.x))*0x10000; // avoid division by 0 => multiply by C.x
		    //	transitions += 0 < vd && vd <= Abs(C.x);
			    if (C.x >= 0) {
				    if (0 < vd && vd <= ((int64)C.x)*0x10000) transitions++;
			    } else {
				    if (((int64)C.x)*0x10000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u  + ((int64)(B.y - D.y))*0x10000; // avoid division by 0 => multiply by C.y
		    //	transitions += 0 < vd && vd <= Abs(C.y);
			    if (C.y >= 0) {
				    if (0 < vd && vd <= ((int64)C.y)*0x10000) transitions++;
			    } else {
				    if (((int64)C.y)*0x10000 <= vd && vd < 0) transitions++;
			    }
            }
	    }
    }

	return transitions;
} // CurveTransitionsSegment

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2) {

//	here we're intersecting a quadratic Bzier curve (W0, W1, W2) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u^2 + B.x*u + C.x = D.x*v + E.x
//		A.y*u^2 + B.y*u + C.y = D.y*v + E.y
//
//	a system of two "halfway" quadratic eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u^2 + B.y*u + C.y - E.y = D.y*(A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*D.x - D.y*A.x)*u^2 + (B.y*D.x - D.y*B.x)*u + C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x = 0
//
//	which is a single quadratic eqn. in u with 0 thru 2 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual Bzier segment
//	and we don't count start/end points twice by including them in adjacent Bzier segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D,E;
	long i,solutions,transitions;
	int64 u[2],vd;

//	re-write Bzier curve in polynomial form
//	W0*(1-u)^2 + 2*W1*(1-u)*u + W2*u^2 = W0*(1 - 2*u + u^2) + 2*W1*(u - u^2) + W2*u^2 = 
//	(W0 - 2*W1 + W2)*u^2 + 2*(W1 - W0)*u + W0
	A = AddV(SubV(W0,ShlV(W1,1)),W2);
	B = ShlV(SubV(W1,W0),1);
	C = W0;

//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	D = SubV(V1,V0);
	E = V0;

	FQuadraticEqn(A.y*D.x - D.y*A.x,B.y*D.x - D.y*B.x,C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x,&solutions,&u[0],&u[1]);
	
	transitions = 0;
	for (i = 0; i < solutions; i++) {
		if (0 < u[i] && u[i] <= 0x10000) {
            /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(D.x) > MABS(D.y))
            {
			    vd = ((int64)A.x)*u[i]*u[i] + ((int64)B.x)*u[i]*0x10000 + ((int64)(C.x - E.x))*0x100000000; // avoid division by 0 => multiply by D.x
		    //	transitions += 0 < vd && vd <= Abs(D.x);
			    if (D.x >= 0) {
				    if (0 < vd && vd <= ((int64)D.x)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.x)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u[i]*u[i] + ((int64)B.y)*u[i]*0x10000 + ((int64)(C.y - E.y))*0x100000000; // avoid division by 0 => multiply by D.y
		    //	transitions += 0 < vd && vd <= Abs(D.y);
			    if (D.y >= 0) {
				    if (0 < vd && vd <= ((int64)D.y)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.y)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            }
		}
	}


	return transitions;
} // CurveTransitions

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber)
{
    Vector Min, Max;

    /* the curve is completely conatined in the triangle W0,W1,W2 */
    MinMax3Vectors (W0, W1, W2, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxCurve, illegal case");
        return TRUE;
    }

}

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1, int16 extremumNumber)
{
    Vector Min, Max;

    MinMax2Vectors (W0, W1, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxSegment, illegal case");
        return TRUE;
    }

}

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0X - 2*V1X + V2X;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0X - V1X;
		u1Num = V2X - V1X;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;
	//	if we're calculating the left extremal point, we floor the result for the probing line
	//	not to start inside the contour as a result of rounding. Starting on the contour should be fine,
	//	as this is handled in CurveTransitions, which does not include the lower end of the interval.
		*extrX = min ? (long)(xNum/uDen2) : (long)((xNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrY = yNum >= 0 ? (long)((yNum + uDen2)/uDen2) : -(long)((uDen2 - yNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateXExtremum

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0Y - 2*V1Y + V2Y;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0Y - V1Y;
		u1Num = V2Y - V1Y;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;

        *extrY = min ? (long)(yNum/uDen2) : (long)((yNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrX = xNum >= 0 ? (long)((xNum + uDen2)/uDen2) : -(long)((uDen2 - xNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateYExtremum

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1)
{
/* extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY,
    the coordinates returned in C0 and C1 are scaled by 2 */

    switch (extremumNumber) {
	case 0:
        /* line from minX to infinity */
	    C0->x = extremum.x+1;
	    C0->y = extremum.y;
	    C1->x = -32768;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 1:
        /* line from maxX to infinity */
	    C0->x = extremum.x-1;
	    C0->y = extremum.y;
	    C1->x = 32767;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 2:
        /* line from minY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y+1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = -32768;
        break;
	case 3:
        /* line from maxY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y-1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = 32767;
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, FindExtremaKnot, illegal case");
    }
}

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (C.x < Min->x) Min->x = C.x;
    if (B.y < Min->y) Min->y = B.y;
    if (C.y < Min->y) Min->y = C.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (C.x > Max->x) Max->x = C.x;
    if (B.y > Max->y) Max->y = B.y;
    if (C.y > Max->y) Max->y = C.y;
}

void MinMax2Vectors (Vector A,Vector B, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (B.y < Min->y) Min->y = B.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (B.y > Max->y) Max->y = B.y;
}

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement)
{
    int32 Contour;
    boolean bMisoriented;
    short knot, n, i, start, end, predKnot, succKnot;
    short extremumKnot[4];
	Vector extremum[4];
    long minX, maxX, minY, maxY;
    long distance0_1, distance0_2, distance0_3;
    uint16 extremaNumber2, extremaNumber3;

    for (Contour = 0; Contour < pElement->nc; Contour++)
	{
        pElement->fc[Contour] = 0;

        start = pElement->sp[Contour];
        end = pElement->ep[Contour];
        
        n = end - start + 1;

        if (n > 2) 
        {
            /* we are not interested in degenerated contours */

            /* look for exterma knots to decide which direction to look to increase our chance of getting the correct result even on bad fonts */

            /* we will look for the following extrema :
               extremumKnot = 0 : MinX
               extremumKnot = 1 : MaxX
               extremumKnot = 2 : MinY
               extremumKnot = 3 : MaxY */

            for (i = 0; i < 4; i++) extremumKnot[i] = -1;
            
            minX = minY = 0x7fffffff;
    	    maxX = maxY = 0x80000000;

	        for (knot = 0; knot < n; knot++) {
                /* look for Min X */
		        if (pElement->oox[start + knot] < minX || 
			        pElement->oox[start + knot] == minX && !pElement->onCurve[extremumKnot[0]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == minX && pElement->onCurve[extremumKnot[0]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] < pElement->ooy[extremumKnot[0]]) {
					extremumKnot[0] = start + knot;
					minX = pElement->oox[extremumKnot[0]];
					if (pElement->onCurve[extremumKnot[0]]) {
						extremum[0].x = pElement->oox[extremumKnot[0]] << 1;
						extremum[0].y = pElement->ooy[extremumKnot[0]] << 1;
					} else {
						predKnot = extremumKnot[0] == start ? end : extremumKnot[0] - 1;
						succKnot = extremumKnot[0] == end ? start : extremumKnot[0] + 1;
						CalculateXExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[0]],pElement->ooy[extremumKnot[0]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[0].x,&extremum[0].y);
					}
				}
                /* look for Max X */
		        if (pElement->oox[start + knot] > maxX || 
			        pElement->oox[start + knot] == maxX && !pElement->onCurve[extremumKnot[1]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == maxX && pElement->onCurve[extremumKnot[1]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] > pElement->ooy[extremumKnot[1]]) {
					extremumKnot[1] = start + knot;
					maxX = pElement->oox[extremumKnot[1]];
					if (pElement->onCurve[extremumKnot[1]]) {
						extremum[1].x = pElement->oox[extremumKnot[1]] << 1;
						extremum[1].y = pElement->ooy[extremumKnot[1]] << 1;
					} else {
						predKnot = extremumKnot[1] == start ? end : extremumKnot[1] - 1;
						succKnot = extremumKnot[1] == end ? start : extremumKnot[1] + 1;
						CalculateXExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[1]],pElement->ooy[extremumKnot[1]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[1].x,&extremum[1].y);
		        		}
				}
                /* look for Min Y */
		        if (pElement->ooy[start + knot] < minY || 
			        pElement->ooy[start + knot] == minY && !pElement->onCurve[extremumKnot[2]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == minY && pElement->onCurve[extremumKnot[2]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] > pElement->oox[extremumKnot[2]]) {
					extremumKnot[2] = start + knot;
					minY = pElement->ooy[extremumKnot[2]];
					if (pElement->onCurve[extremumKnot[2]]) {
						extremum[2].x = pElement->oox[extremumKnot[2]] << 1;
						extremum[2].y = pElement->ooy[extremumKnot[2]] << 1;
					} else {
						predKnot = extremumKnot[2] == start ? end : extremumKnot[2] - 1;
						succKnot = extremumKnot[2] == end ? start : extremumKnot[2] + 1;
						CalculateYExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[2]],pElement->ooy[extremumKnot[2]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[2].x,&extremum[2].y);
					}
				}
                /* look for Max Y */
		        if (pElement->ooy[start + knot] > maxY || 
			        pElement->ooy[start + knot] == maxY && !pElement->onCurve[extremumKnot[3]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == maxY && pElement->onCurve[extremumKnot[3]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] < pElement->oox[extremumKnot[3]]) {
					extremumKnot[3] = start + knot;
					maxY = pElement->ooy[extremumKnot[3]];
					if (pElement->onCurve[extremumKnot[3]]) {
						extremum[3].x = pElement->oox[extremumKnot[3]] << 1;
						extremum[3].y = pElement->ooy[extremumKnot[3]] << 1;
					} else {
						predKnot = extremumKnot[3] == start ? end : extremumKnot[3] - 1;
						succKnot = extremumKnot[3] == end ? start : extremumKnot[3] + 1;
						CalculateYExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[3]],pElement->ooy[extremumKnot[3]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[3].x,&extremum[3].y);
					}
				}
	        }

            /* diagonal distance, we don't need a precise distance */

            distance0_1 = MABS(pElement->oox[extremumKnot[1]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[1]] - pElement->ooy[extremumKnot[0]]);
            distance0_2 = MABS(pElement->oox[extremumKnot[2]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[2]] - pElement->ooy[extremumKnot[0]]);
            distance0_3 = MABS(pElement->oox[extremumKnot[3]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[3]] - pElement->ooy[extremumKnot[0]]);

            if (distance0_2 > distance0_3)
            {
                /* we will look at MinY */
                extremaNumber2 = 2;
                if (distance0_3 > distance0_1)
                {
                    /* we will look then at MaxY */
                    extremaNumber3 = 3;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            } else {
                /* we will look at MaxY */
                extremaNumber2 = 3;
                if (distance0_2 > distance0_1)
                {
                    /* we will look then at MinY */
                    extremaNumber3 = 2;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            }

            bMisoriented = Misoriented(Contour, 0 /* MinX */, extremumKnot[0], extremum[0], pElement);

            /* look in a second direction to check if same result 
               this additional work help weed out problems with bad fonts having self-intersecting
               or overlapping outlines */
            if (bMisoriented != Misoriented(Contour, extremaNumber2, extremumKnot[extremaNumber2], extremum[extremaNumber2], pElement))
            {
                /* we need to look in a third direction */
                bMisoriented = Misoriented(Contour, extremaNumber3, extremumKnot[extremaNumber3], extremum[extremaNumber3], pElement);
            }

                // at this point we store the orientation of the original component (original in the sense of before the composite code potentially
                // applies a mirroring), such that the concertina code can work on the component w/o having to know about composite transformations
                if (bMisoriented) pElement->fc[Contour] |= OUTLINE_MISORIENTED;
        }
    }
}

boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement)
/* we will check the coutour orientation at the following extrema :
   extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY */

{
	LinkColor color,orientation;
	short predKnot,cont,knot,start,iter,end,n;
	long parity;
	Vector V[3],D[2],C[2],W[3],Wi;
	boolean on[3];

    short dirChange = 0;      
    
	start = pElement->sp[contour];
	end = pElement->ep[contour];
	n = end - start + 1;

	// here we determine the straight line that runs from the extreme of the contour to infinity, to be used below.
    SetLineToInfinity(extremumNumber, extremum, &C[0], &C[1]);
	
	// find out the current orientation of the contour
	// to do so first determine what kinds of turns we make at each knot
	orientation = linkBlack; // assume as default

    knot = extremumKnot - start;
    predKnot = (knot+n-1)%n;

    V[0].x = pElement->oox[start+predKnot]; V[1].x = pElement->oox[start+knot];
	V[0].y = pElement->ooy[start+predKnot]; V[1].y = pElement->ooy[start+knot];
	D[0] = SubV(V[1],V[0]);
	for (iter = 0; iter < n && !dirChange; iter++) {
		V[2].x = pElement->oox[start + (knot + 1)%n];
		V[2].y = pElement->ooy[start + (knot + 1)%n];
		if (NotSameKnot(V[1],V[2])) {
    		D[1] = SubV(V[2],V[1]);
		    dirChange = ComputeSign(D[0].x, D[0].y, D[1].x, D[1].y);
		    V[0] = V[1]; V[1] = V[2]; D[0] = D[1];
        }
        knot = (knot + 1)%n;
	}

    if (iter < n && dirChange > 0)
    {
        orientation = linkWhite; /* counter clockwise */
    }
	
	// now find out what the orientation of the contour should really be
	// to do so we intersect the above probing line with all other contours.
	// If the number of intersections is odd, we have started inside, else outside.
	// if this doesn't correspond to the contour orientation determined above, then we're misoriented.
	// The loops below follow the same pattern used for Contour::Draw but are separate due to different underlying data structure.
	// Notice that this doesn't work for overlapping or self-intersecting contours. They're against the TT laws...
	parity = 0;
	for (cont = 0; cont < pElement->nc; cont++) {
        if (cont != contour) 
        /* we are not interested by the intersections of the contour with itself, optimization */
        {
		    start = pElement->sp[cont];
		    end = pElement->ep[cont];
		    n = end - start + 1;
		    W[1].x = pElement->oox[start] << 1;
		    W[1].y = pElement->ooy[start] << 1;
		    on[1] = pElement->onCurve[start];
		    if (!on[1]) { // we start amidst a curve => get curve start point
			    W[0].x = pElement->oox[end] << 1;
			    W[0].y = pElement->ooy[end] << 1;
			    on[0] = pElement->onCurve[end];
			    if (!on[0]) { // curve start point is implied on-curve point => compute
				    W[0] = ShrV(AddV(W[0],W[1]),1);
			    }
		    }
		    knot = start;
		    do {
			    knot = knot == end ? start : knot + 1;
			    W[2].x = pElement->oox[knot] << 1;
			    W[2].y = pElement->ooy[knot] << 1;
			    on[2] = pElement->onCurve[knot];
			    switch (on[1] << 1 | on[2]) {
				    case 3: // on---on => start and end a line => intersect with line
					    if (NotSameKnot(W[1],W[2]))
                        {
                        /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxSegment(C[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitionsSegment(C[0],C[1],W[1],W[2]); // repeating first vertex makes Bzier curve a line...
							}
                        }
					    break;
				    case 2: // on---off => start a curve => intersect with nothing
					    W[0] = W[1];
					    break;
				    case 1: // off---on => end a curve => intersect with the curve
					    if (NotSameKnot(W[0],W[2])) 
                        {
                            /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],W[2]);
							}
                        }
					    break;
				    case 0: // off---off => end a curve => intersect with the curve; then start a curve => intersect with nothing
					    Wi = ShrV(AddV(W[1],W[2]),1);
					    if (NotSameKnot(W[0],Wi))
                        {
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],Wi,extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],Wi);
							}
                        }
					    W[0] = Wi;
					    break;
			    }
			    W[1] = W[2]; on[1] = on[2];
		    } while (knot != start);
        }
	}
	color = parity & 1 ? linkBlack : linkWhite;

	return color == orientation; // cw (black) contours should have white to their left, and v.v., else they're oriented the wrong way round
} // Misoriented

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel)
{
	fnt_GlobalGraphicStateType *globalGS, *globalGSSubPixel;
	int32 i;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGSSubPixel = (fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel;

	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGSSubPixel->funcDef[i] = globalGS->funcDef[i];

	}

    globalGSSubPixel->instrDefCount = globalGS->instrDefCount;

	for (i = 0; i < globalGS->instrDefCount; i++)
	{
		globalGSSubPixel->instrDef[i] = globalGS->instrDef[i];

	}
	globalGSSubPixel->subPixelCompatibilityFlags = globalGS->subPixelCompatibilityFlags;

	globalGSSubPixel->numDeltaFunctionsDetected = globalGS->numDeltaFunctionsDetected;
	for (i = 0; i < globalGSSubPixel->numDeltaFunctionsDetected; i++)
		globalGSSubPixel->deltaFunction[i] = globalGS->deltaFunction[i];
}


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_ScaleToCompatibleWidth(pElement, fxCompatibleWidthScale);
}


FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_AdjustCompatibleMetrics(pElement, horTranslation, newDevAdvanceWidthX);
}

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX);

}

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevNatHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX, pNatAdvanceWidthX, pNatLeftSideBearingX, pNatRightSideBearingX);

}

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sbit.h ===
/*********************************************************************

      sbit.h -- Embedded Bitmap Module Export Definitions

      (c) Copyright 1993-1996  Microsoft Corp.  All rights reserved.

      01/12/96  claudebe    Vertical metrics support
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      01/05/94  deanb       Bitmap scaling state
      11/29/93  deanb       First cut 
 
**********************************************************************/

/*      SBIT Module State Definition    */

typedef struct
{
    uint32  ulStrikeOffset;         /* into bloc or bsca */
    uint32  ulMetricsOffset;        /* may be either table */
    uint32  ulBitmapOffset;         /* into bdat table */
    uint32  ulBitmapLength;         /* bytes of bdat data */
    uint32  ulOutMemSize;           /* bytes of bitmap output data */
    uint32  ulWorkMemSize;          /* bytes of pre-scaled,rotated bitmap data */
    uint32  ulReadMemSize;          /* bytes of extra memory, to read gray sbit under scaling or rotation */
    uint16  usTableState;           /* unsearched, bloc, bsca, or not found */
    uint16  usPpemX;                /* x pixels per Em */
    uint16  usPpemY;                /* y pixels per Em */
    uint16  usSubPpemX;             /* substitute x ppem for bitmap scaling */
    uint16  usSubPpemY;             /* substitute y ppem for bitmap scaling */
	uint16	usRotation;				/* 0=none; 1=90; 2=180; 3=270; 4=other */
    uint16  usMetricsType;          /* horiz, vert, or big */
    uint16  usMetricsTable;         /* bloc or bdat */
    uint16  usBitmapFormat;         /* bdat definitions */
    uint16  usHeight;               /* bitmap rows */
    uint16  usWidth;                /* bitmap columns */
    uint16  usAdvanceWidth;         /* advance width */
    uint16  usAdvanceHeight;        /* advance height */     /* NEW */
    uint16  usOriginalRowBytes;     /* bytes per row (padded long) */
    uint16  usExpandedRowBytes;     /* bytes per row after grayscale expansion (padded long) */
    uint16  usScaledHeight;         /* scaled bitmap rows */
    uint16  usScaledWidth;          /* scaled bitmap columns */
    uint16  usScaledRowBytes;       /* scaled bytes per row (padded long) */
    uint16  usOutRowBytes;          /* reported bytes per row (for rotation) */
    uint16  usShaveLeft;            /* white pixels on left of bbox in format 5 */
    uint16  usShaveRight;           /* white pixels on right of bbox in format 5 */
    uint16  usShaveTop;             /* white pixels on top of bbox in format 5 */   /* NEW */
    uint16  usShaveBottom;          /* white pixels on bottom of bbox in format 5 */  /* NEW */
	int16   sLSBearingX;            /* left side bearing */
	int16   sLSBearingY;            /* y coord of top left corner */ 
	int16   sTopSBearingX;          /* top side bearing X */ /* NEW */
	int16   sTopSBearingY;          /* top side bearing Y */ /* NEW */
    boolean bGlyphFound;            /* TRUE if glyph found in strike */
    boolean bMetricsValid;          /* TRUE when metrics have been read */
	uint16  usEmResolution;			/* needed when substituting missing metrics */ /* NEW */
	uint16	usBitDepth;				/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16	uBoldSimulHorShift;
	uint16	uBoldSimulVertShift;
} 
sbit_State;

/**********************************************************************/

/*      SBIT Export Prototypes      */

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16 	sBoldSimulHorShift,
    int16 	sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
);

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	uint16			usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode           /* 0 = not found, 1 = bloc, 2 = bsca */
);

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW 
);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (	/* NEW */
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH 
);

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvanceWidth,
    point           *pf26DevLeftSideBearing,
    point           *pf26LSB,
    point           *pf26DevAdvanceHeight, 	/* NEW */
    point           *pf26DevTopSideBearing,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize
);

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork
);


/**********************************************************************/

FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 suBoldSimulHorShift, int16 sBoldSimulVertShift);
#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\interp.c ===
/*********************************************************************

	  interp.c -- TT Rasterizer Interpreter Module

	  Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				  (c) 1989-1999. Microsoft Corporation, all rights reserved.

	   7/10/99  BeatS	 62 Add support for native SP fonts, vertical RGB
	   4/01/99  BeatS	 61 Implement alternative interpretation of TT instructions for SP
	  10/14/97  claudebe 60 ClaudeBe, allowing a trace function to know if in FontProgram
							access to unitialized data
	  04/29/97  claudebe 59 ClaudeBe, catching illegal recursion and infinite loops
	  02/21/97  claudebe 58 ClaudeBe, scaled component in composite glyphs
	   2/05/96  claudebe 57 compfont for itpr_MD, wrong zone pointer
	   2/05/96  claudebe 56 GetInfo return HintForGray information
	   8/12/94  deanb  55   orphan routine CHECK_STATE deleted
	   2/09/94  deanb  54   RASTERIZER_VERSION defined for GETINFO
	  12/17/93  deanb  53   CHECK_POINT zone corrected in MIRP
	  12/08/93  deanb  52   itrp_SCANTYPE enabled for smart dropout control
	   9/15/93  deanb  51   InnerTraceEx double call fixed; iOpCode -> lOpCode
	   7/29/93  deanb  50   ALIGNPTS, SHE fixed; InnerTraceExecute saves first
	   7/12/93  deanb  49   itrp_IllegalInstruction works
	   6/28/93  deanb  48   gbyPushTable made const
	   2/16/93  deanb  47   fxUnRounded set after check single width
	   2/15/93  deanb  46   fall back to MIRPG when using single width
	   2/15/93  deanb  45   vector defaults for FONTPROGRAM, stat back
	   2/12/93  deanb  44   delete stat code
	   2/12/93  deanb  43   cleanup MSIRP & itrp_Execute
	   2/12/93  deanb  42   branch itrp_IP on MovePoint
	   2/11/93  deanb  41   use c8 register calling convetions
	   2/11/93  deanb  40   switch to Microsoft C ver 8
	   2/09/93  deanb  39   skipPushData inline in itrp_IF
	   2/09/93  deanb  38   do fast MIRP's with if statments
	   2/09/93  deanb  37   remove fast MDRPX and MIRPY routines
	   2/09/93  deanb  36   fast MDRPX and MIRPY routines
	   2/08/93  deanb  35   cleanup MIRPs, combine if statments
	   2/08/93  deanb  34   dual rounding with 6 ptr init values
	   2/08/93  deanb  33   IUP inner loop pointer check
	   2/08/93  deanb  32   repair skipPushData for npushw
	   2/05/93  deanb  31   check for fxHintedDelta = 0
	   2/05/93  deanb  30   use roundFuncPtr in fast MIRP's
	   2/05/93  deanb  29   itrp_SWAP done in place
	   2/05/93  deanb  28   fntMirpFunc defined for MIRPG/X/Y
	   2/05/93  deanb  27   iOpCode passed in to all functions
	   2/05/93  deanb  26   use instr ptr for param and return
	   2/04/93  deanb  25   pull oldRange out of itrp_IP loops
	   2/04/93  deanb  24   movePoint check for proj.x/y = 1
	   2/03/93  deanb  23   table driven skipPushData
	   2/03/93  deanb  22   zero based Unary Operand pointers
	   2/01/93  deanb  21   split out SetRoundState
	   2/01/93  deanb  20   eliminate OpCode assignemnt, registers
	   2/01/93  deanb  19   bump Normalize limit up to 0x20000000L
	   1/29/93  deanb  18   add SuperRound MIRPG fallback
	   1/29/93  deanb  17   fast MIRPX and MIRPY routines
	   1/27/93  deanb  16   single rounding routines restored
	   1/27/93  deanb  15   innerExecute tune up
	   1/27/93  deanb  14   rounding routines for engine/no engine
	   1/27/93  deanb  13   repair itrp_Normalize for BIG vectors
	   1/26/93  deanb  12   split out SPVTCA and SFVTCA
	   1/26/93  deanb  11   clean up itrp_IP
	   1/26/93  deanb  10   return IUP to old start/end calc
	   1/25/93  deanb   9   use pointers in IUP loops
	   1/25/93  deanb   8   major rewrite of itrp_IUP
	   1/25/93  deanb   7   rewrite itrp_Normalize
	   1/22/93  deanb   6   split and do Unary Operands in place
	   1/22/93  deanb   5   do Binary Operands in place
	   1/22/93  deanb   4   split out BinaryOperand
	   1/22/93  deanb   3   split out PUSHB1 and PUSHW1
	   1/22/93  deanb   2   split out PushSomeBytes/Words
	   1/22/93  deanb   1   split out SRP0-2, LLOOP, POP
	   1/22/93  deanb   0   STAT card timing added
	   1/22/93  deanb       dead code/comments moved to history.fnt
 
**********************************************************************/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "interp.h"
#include "fserror.h"

#include "stat.h"                   /* for STAT card timing only */

#include <stdio.h>

#ifdef SEGMENT_LINK
#pragma segment FNT_C
#endif

/* perfect spot size (Fixed) */
#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

#ifdef FSCFG_SUBPIXEL
#define RASTERIZER_VERSION  37      /* MS reserved values 33 - 64 */
#else
#define RASTERIZER_VERSION  35      /* MS reserved values 33 - 64 */
#endif // FSCFG_SUBPIXEL
									/* 33 = Rasterizer v1.5 */
									/* 34 = Rasterizer v1.6 */
									/* 35 = Rasterizer v1.7 */
									/* 36 = Rasterizer v1.6+, Windows CE, SubPixel */
									/* 37 = Rasterizer v1.8, Windows XP (NT 5.1), SubPixel */

#ifdef FSCFG_SUBPIXEL
	// the following are 9 switches to avoid all kinds of "hinting techniques" that have adverse effects on SubPixel
	// they should be considered "band-aid" solutions, to avoid us the worst of the worst with existing fonts.
	// in the future, fonts that are optimized for SubPixel should be tagged as such.
	// This will permit to switch these switches off again.
	#define RDTGRoundsDownToGrid		// to avoid not aligning control points when Align translates to MDRP with RDTG preceded by SPVTL
	#define NoVirtRoundInPrep			// to avoid PMingLiU vertically misplacing strokes (vectors not set properly in prep for certain calculations)
	#define RoundOffRespectsCvtCutIn	// to avoid Palatino Italic's fractional grey-scale targetted cvts and unrounded MIRP (little r) which bypasses cvt cut-in
	#define MSIRPRespectsCvtCutIn		// to avoid fonts pre-calculating a distance and subsequently MSIRPing it (neither rounding nor cvt cut-in involved in MSIRP)
	#define InlineDeltasOnly			// to avoid all kinds of bumps, blops, or irregular weight gains
	#define BypassDandIStroke			// to avoid collapsing strokes in (partly) auto-hinted fonts using DStroke and IStroke commands
	#define BypassJellesSpacing			// to avoid bloated characters
	#define BypassVacuformRound			// to avoid diamond shaped characters
	#define AssistTomsDiagonal			// to avoid Georgia italic to become upright

	// values derived from the primary values in fscdefs.h
	#define CVT_CUT_IN_OVERSCALE	VIRTUAL_OVERSCALE	// high value to encourage MIRP to fall back on original distance to avoid stroke weight jumps in size ramp
	#define ENGINE_COMP_OVERSCALE	VISUAL_OVERSCALE	// value not particularly relevant as engine compensation is not currently used
	#define MIN_DIST_OVERSCALE		VISUAL_OVERSCALE	// value not terribly important as it basically affects the minimum stroke weight

	#define Tuned4SubPixel(globalGS) ((uint16)((globalGS)->localParBlock.instructControl & TUNED4SPFLAG))
#else
	#define Tuned4SubPixel(globalGS) (false)
#endif

#define MAX_ELEMENTS 2
#define TWILIGHTZONE 0 /* The point storage */
#define GLYPHELEMENT 1 /* The actual glyph */

/* those constant are used as default to catch illegal fonts */
#define INTERP_MAX_JUMPS			10000
#define INTERP_MAX_RECURSIVE_CALLS	100

#define MAXANGLES       20

#define ROTATEDGLYPH        0x0100
#define STRETCHEDGLYPH      0x0200
/* new Apple 1994 */
#define VARIATIONGLYPH      0x0400
#define VERTICALGLYPH       0x0800
/* new Microsoft 1996 */
#define HINTEDFORGRAYGLYPH  0x1000

#define VERSIONINTERPRETERQUERY          0x0001
#define ROTATEDINTERPRETERQUERY          0x0002
#define STRETCHEDINTERPRETERQUERY        0x0004
/* new Apple 1994 */
#define VARIATIONINTERPRETERQUERY        0x0008
#define VERTICALMETRICSINTERPRETERQUERY  0x0010
/* new Microsoft 1996 */
#define HINTFORGRAYINTERPRETERQUERY      0x0020

/* new Microsoft 1998
   moved out of FSCFG_SUBPIXEL to build debug version for non SP environment */
#define HINTFORSUBPIXELINTERPRETERQUERY						0x0040
#define HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY		0x0080
#define HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY	0x0100
#define HINTFORSUBPIXELBGRORDERINTERPRETERQUERY				0x0200

#ifdef FSCFG_SUBPIXEL
/* new Microsoft 1998 */
#define HINTEDFORSUBPIXELGLYPH								0x02000
#define HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH				0x04000
#define HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH				0x08000
#define HINTEDFORSUBPIXELBGRORDERGLYPH						0x10000
#endif // FSCFG_SUBPIXEL

// this includes all SP specific flags, since we don't want a SP enabled font to break on a non SP enabled rasterizer
#define SELECTOR_FLAGS (VERSIONINTERPRETERQUERY | ROTATEDINTERPRETERQUERY | STRETCHEDINTERPRETERQUERY |					\
						VARIATIONINTERPRETERQUERY | VERTICALMETRICSINTERPRETERQUERY | HINTFORGRAYINTERPRETERQUERY |		\
						HINTFORSUBPIXELINTERPRETERQUERY | HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY |			\
						HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY | HINTFORSUBPIXELBGRORDERINTERPRETERQUERY)

#define MAXBYTE_INSTRUCTIONS 256

#define ONEVECTOR                       ONESHORTFRAC
#define VECTORMUL(value, component)     ShortFracMul((F26Dot6)(value), (ShortFract)(component))
#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTORDIV(num,denum)            ShortFracDiv((ShortFract)(num),(ShortFract)(denum))
#define VECTORMULDIV(a,b,c)             ShortFracMulDiv((ShortFract)(a),(ShortFract)(b),(ShortFract)(c))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

#ifdef FSCFG_REENTRANT
#define GSP0    fnt_LocalGraphicStateType* pLocalGS
#define GSP     fnt_LocalGraphicStateType* pLocalGS,
#define GSA0    pLocalGS
#define GSA     pLocalGS,
#define LocalGS (*pLocalGS)
#else 
#define GSP0    void
#define GSP
#define GSA0
#define GSA
fnt_LocalGraphicStateType LocalGS
 #ifndef FSCFG_NO_INITIALIZED_DATA
  = {0}
 #endif 
;
#endif 


#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )


/* Common Interpreter Function Parameter */

#define IPARAM         GSP uint8 *pbyInst, int32 lOpCode

#define MIRPG          0
#define MIRPX          1
#define MIRPY          2
				  
// color compensation flags in ROUND, MDRP, and MIRP
#define	GREY	0
#define BLACK	1
#define WHITE	2
#define OTHER	3

// flags for UTP, IUP, MovePoint
#define XMOVED 0x01
#define YMOVED 0x02


#define NUM_PHANTOM_PTS   4L

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA // master switch

	#define NumRelationShips(elem) (elem->ep[elem->nc - 1] + 1 + NUM_PHANTOM_PTS)

	// Make an empty data structure (DAG)
	void InitPhaseControl(fnt_ElementType *elem) {
		long i;
		PhaseControlRelation *rel;

		for (i = 0; i < NumRelationShips(elem); i++) {
			rel = &elem->pcr[i];
			rel->parent0 = rel->parent1 = rel->child = -1;
			rel->flags = 0;
			rel->phaseShift = 0;
		}
		elem->phaseControlExecuted = false;
	} // InitPhaseControl

	//	Function to avert circular dependencies, whose traversal would cause endless recursion in
	//	"PhaseShift" further below.
	//
	//	In the trivial case (self dependency), a child would depend on itself. This scenario is ex-
	//	cluded by respective tests in the callers.
	//
	//	In the simplest non-trivial case (direct dependency), before linking from a parent to a child,
	//	we want to determine whether the child links back to the parent:
	//
	//		IndirectlyDependsOn(..., parent, child, ...) ?
	//
	//	If it does, then "self" (the parent) depends on "whom" (the child), and we'd get a circular
	//	dependency, because the child would depend on the parent as a result of "AddDistance":
	//
	//		rel->parent0 == whom ?
	//
	//	noting that "rel" points to self's phase control relation structure.
	//
	//	In the more general case (indirect dependency, which includes direct dependency via zero
	//	indirections), self's parent may depend on the child (and recursively), hence:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) ?
	//
	//	In the most general case, there may be two parents involved, hence we have to follow both
	//	lines of ancestry:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) || 
	//		rel->parent1 == whom || IndirectlyDependsOn(..., rel->parent1, whom, ...) ?
	//
	//	Notice that in the actual code the latter is re-arranged for efficiency.
	//	Notice also that we don't have a simple case of tail recursion, which could be replaced by
	//	an iteration easily.

	boolean IndirectlyDependsOn(fnt_ElementType *elem, long self, long whom, long level) {
		PhaseControlRelation *rel;

		level--;
		if (level < 0) return true; // safeguard against stack overflow, probably redundant

	//	here we assume that we're called only from within AddDistance or AddProportion, hence
	//	"self" and "whom" have been range checked initially. Every recursion changes the actual
	//	value of "self", but only to a value obtained from a "pcr", which only gets range checked
	//	values, hence we don't need to range check "self" again. "whom" is invariant anyhow.
	//	Additionally, we also assume that "self" and "whom" are not the same. Since the algorithm
	//	below terminates if "self"'s parent equals "whom", "self" never becomes "whom".

		rel = &elem->pcr[self];
		if (rel->parent0 == -1) // 0 parents (MDAP, MIAP)
			return false; // no dependencies
		else if (rel->parent1 == -1) // 1 parent (MDRP, MIRP, SHP, ALIGNRP, etc.)
			return rel->parent0 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1);
		else // 2 parents (IP)
			return rel->parent0 == whom || rel->parent1 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1) || IndirectlyDependsOn(elem,rel->parent1,whom,level-1);
		return false; // we shouldn't get down here, but the compiler thinks we do...
	} // IndirectlyDependsOn

	// Called from the TT interpreter whenever a MIRP, MDRP, SHP, ALIGNRP (etc.) is executed
	// Add a distance relationship to the DAG
	void AddDistance(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from, long to, long color) {
		long parent;

		if (0 <= from && from < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from != to) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1) { // we have no parent for this child
				while ((parent = elem->pcr[from].parent0) != -1 && elem->oox[from] == elem->oox[parent])
					from = parent; // simplify link structure in case of links to "align" vertical edges
				elem->pcr[to].parent0 = (int16)from; // first link wins, bad links may produce suboptimal phase control
				elem->pcr[to].parent1 = -1;
			}
			if (color == BLACK && elem->pcr[from].child == -1 && elem->pcr[to].child != from) { // first black link wins...
				if ((parent = elem->pcr[from].parent0) != -1 && elem->pcr[parent].child == from)
					elem->pcr[to].flags |= BADREL;
				else
					elem->pcr[from].child = (int16)to;
			}
		}
	} // AddDistance
	
	// Called from the TT interpreter when an IP is executed
	// Add a proportion relationship to the DAG
	void AddProportion(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from0, long to, long from1) {
		if (0 <= from0 && from0 < NumRelationShips(elem) && 0 <= from1 && from1 < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from0 != to && from1 != to && from0 != from1) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from0,to,INTERP_MAX_RECURSIVE_CALLS) || IndirectlyDependsOn(elem,from1,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1 && elem->pcr[to].parent1 == -1) {
				elem->pcr[to].parent0 = (int16)from0; // first interpolate wins, bad interpolates
				elem->pcr[to].parent1 = (int16)from1; // ...may produce suboptimal phase control
			}
		}
	} // AddProportion
	
	// Calculate the phase shift resulting from a child point that depends on two parent points by proportion (interpolation)
	F26Dot6 CalcAvgXPhaseShift(fnt_ElementType *elem, long parent0, long child, long parent1, F26Dot6 phase0, F26Dot6 phase1) {
		F26Dot6 leftX,childX,rightX,leftPhase,rightPhase;
		
		// the phase of child control points that are interpolated between a pair of parent control points depends on the phase
		// applied to both of these parent control points.
		// If both parents have the same phase, then the child point gets that phase
		if (phase0 == phase1) return phase0; // IPs "within" strokes

		// if the phase is different, we try to calculcate a weighted average.
		// In dubious cases, this may fail (divide-by-zero), in which case we fall back on an unweighted (plain) average.
		if (elem->ox[parent0] < elem->ox[parent1]) {
			leftX = elem->ox[parent0]; rightX = elem->ox[parent1];
			leftPhase = phase0; rightPhase = phase1;
		} else {
			leftX = elem->ox[parent1]; rightX = elem->ox[parent0];
			leftPhase = phase1; rightPhase = phase0;
		}
		childX = elem->ox[child];
		
		return leftX != rightX 
			? ((childX - leftX)*rightPhase + (rightX - childX)*leftPhase)/(rightX - leftX) // weighted average
			: (leftPhase + rightPhase) / 2; // unweighted average
	} // CalcAvgXPhaseShift
	
	// This is the part that (recursively) traverses the data structure to apply the above rules, called from ExecutePhaseControl below
	// Notice that it works much like the early prototype for the compiler that translates VTT's GUI into TMT
	F26Dot6 PhaseShift(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, short anyBadRelation, long child) {
		PhaseControlRelation *rel,*childRel;
		F26Dot6 phase;
		
		if (child == -1) return 0; // nothing, hence no phase shift
		
		rel = &elem->pcr[child];
		
		if (rel->flags & DOING) return 0; // prevent from endless recursion due to circular dependencies; probably redundant
		rel->flags |= DOING;

		if ((rel->flags & DONE) == 0) { // else been there already, know phase
			if (child > elem->ep[elem->nc-1]) { // LSB, RSB
				phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
			} else if (rel->parent0 == -1) { // MDAP, MIAP
				if (anyBadRelation) {
					phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
				} else {
					phase = 0;
				}
			} else if (rel->parent1 == -1) { // MDRP, MIRP, SHP, ALIGNRP, ...
				phase = PhaseShift(localGS,elem,anyBadRelation,rel->parent0);
			} else { // IP
				phase = CalcAvgXPhaseShift(elem,rel->parent0,child,rel->parent1,PhaseShift(localGS,elem,anyBadRelation,rel->parent0),PhaseShift(localGS,elem,anyBadRelation,rel->parent1));
			}
			
			if ((rel->flags & DONE) == 0) { // still not done, after above recursion
				if (rel->child != -1 && ((childRel = &elem->pcr[rel->child])->flags & DONE) == 0) {
					if (rel->parent0 == -1 || rel->parent1 == -1) { // not IP
						phase = LongMulDiv(elem->x[child] + elem->x[rel->child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x20000);
					}
					
					elem->x[child] += phase;
					elem->x[rel->child] += phase;
					
					childRel->phaseShift = phase;
					childRel->flags |= DONE;
				
				// else if we're linked to, and we're not a leaf, such as in a chain of links through a 'v',
				// do the proportional thing, in order not to twist the 'v'
				// additionally, we may want to make the decision, which "stroke" wins, a bit smarter,
				// by giving preference to the one with the lesser |dy|

				} else {
					if (anyBadRelation && rel->parent1 == -1 && (rel->parent0 == -1 || elem->ox[child] != elem->ox[rel->parent0])) {
					//	bad MDRP, MIRP, SHP, ALIGNRP, MDAP, or MIAP, but not in case aligned along vertical edge
						phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
					} // else IP
					if (rel->parent0 != -1) {
						elem->x[child] += phase;
					}
				}
				rel->phaseShift = phase;
				rel->flags |= DONE;
			}
		}

		rel->flags &= ~DOING;
		return rel->phaseShift;
	} // PhaseShift

	// This is a plain old loop
	// It is never to be executed in the twilight zone, hence all the guards upon calling it.
	void ExecutePhaseControl(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem) {
		long i,numRelationShips;
		short anyBadRelation;
		F26Dot6 phase;

		numRelationShips = NumRelationShips(elem);
		for (i = 0; i < numRelationShips && (elem->pcr[i].flags & BADREL) == 0; i++);
		anyBadRelation = i < numRelationShips;
		for (i = 0; i < numRelationShips; i++) {
			phase = PhaseShift(localGS,elem,anyBadRelation,i);
		}
		elem->phaseControlExecuted = true;
	} // ExecutePhaseControl

	// helper function
	long ContNum(fnt_ElementType *elem, long knot) {
		long i;

		for (i = 0; i < elem->nc && knot > elem->ep[i]; i++);
		return i < elem->nc ? i : -1;
	} // ContNum

	// The "concertina algorithm" uses the color flags in the MDRP and MIRP instructions to "determine" the existence
	// of stems. Most of the time, the color flags are set correctly; in fact, if the TT code is generated by the TMT
	// compiler, they should always be correct. However, there is a small number of cases where the flags are erroneous
	// (a black stroke which is not flagged as black) or misleading (the extent of a cross bar, which is a black link
	// as defined in the TMT compiler, but which for the purpose of this algorithm had rather not be flagged as black).
	// Not surprisingly, most of these cases (avoiding to say, all of them) happen on grotesque fonts, with the MDRP
	// or MIRP between two neighbouring points on the outline (cases in which a compiler generating TT code could ar-
	// gueably be undecided). Therefore we make a last ditch effort in this function to correct the colour flags for
	// this special class of problems.
	long DoubleCheckLinkColor(fnt_ElementType *elem, long from, long to, long color) {
		long fromCont,fromStart,fromEnd,fromSucc,fromPred,toCont,toSucc,toPred;
		boolean fromRightTurn,toRightTurn,properlyOriented;

		// first, determine whether we link between a pair of neighbours on one and the same contour
		// one of the knots is not on any contour (LSB, RSB), hence can't be neighbours
		if ((fromCont = ContNum(elem,from)) < 0 || // error
			(toCont   = ContNum(elem,to))   < 0)
			return GREY; // it's not a black stroke
		
		// if they belong to different contours, we don't attempt to improve color flag
		if (fromCont != toCont) return color;
		
		// if they belong to the same contour, but are not neighbours, we don't attempt to improve color flag, either
		fromStart = elem->sp[fromCont];
		fromEnd   = elem->ep[fromCont];
		fromSucc = from == fromEnd ? fromStart : from+1;
		fromPred = from == fromStart ? fromEnd : from-1;
		if (to != fromSucc && to != fromPred) return color;

		// if they are neighbours, but the link is along the arm of a T-junction, we call it a grey link.
		// we determine this by testing whether the link starts at a point where the outline makes a right
		// turn and ends at a point where the outline makes a left turn, or vice versa.
		toSucc = to == fromEnd ? fromStart : to+1;
		toPred = to == fromStart ? fromEnd : to-1;
		fromRightTurn = (elem->oox[from]-elem->oox[fromPred])*(elem->ooy[fromSucc]-elem->ooy[from]) <
						(elem->ooy[from]-elem->ooy[fromPred])*(elem->oox[fromSucc]-elem->oox[from]);
		toRightTurn   = (elem->oox[to]-elem->oox[toPred])*(elem->ooy[toSucc]-elem->ooy[to]) <
						(elem->ooy[to]-elem->ooy[toPred])*(elem->oox[toSucc]-elem->oox[to]);
		if (fromRightTurn != toRightTurn)
			return GREY;

		// a extraneous case encountered, a link along a diagonal stroke
		if (2*MABS(elem->oox[to]-elem->oox[from]) < MABS(elem->ooy[to]-elem->ooy[from]))
			return GREY;

		properlyOriented = (elem->fc[fromCont] & OUTLINE_MISORIENTED) == 0;

		return properlyOriented == fromRightTurn ? BLACK : WHITE;
	} // DoubleCheckLinkColor

	// Determine whether an interpolation is actually an interpolation, as opposed to an extrapolation.
	// For actual interpolations, child points are moved along proportionally to the parent points. For
	// extrapolations child points are shifted along with the parent point(s). Notice that we implement
	// a behaviour similar to IUP (points between extrema are interpolated, the others are shifted along)
	boolean InterAlign(fnt_ElementType *elem, long parent0, long child, long parent1) {
		long parent0x,childx,parent1x,temp;

		parent0x = elem->oox[parent0];
		parent1x = elem->oox[parent1];
		if (parent0x > parent1x) { temp = parent0x; parent0x = parent1x; parent1x = temp; }
		childx = elem->oox[child];
		return parent0x <= childx && childx <= parent1x;
	} // InterAlign

#endif // SUBPIXEL_BC_AW_STEM_CONCERTINA


/* Private function prototypes */

FS_PRIVATE F26Dot6 itrp_RoundToDoubleGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundDownToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundUpToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToHalfGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundOff(GSP F26Dot6 xin, F26Dot6 engine);

#ifdef FSCFG_SUBPIXEL
	// a duplicate set of rounding functions, with either the b/w (above) or the sp (below) version being installed
	FS_PRIVATE F26Dot6 itrp_RoundToDoubleGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundDownToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundUpToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToHalfGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundOffSP(GSP F26Dot6 xin, F26Dot6 engine);
#endif

FS_PRIVATE F26Dot6 itrp_SuperRound(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_Super45Round(GSP F26Dot6 xin, F26Dot6 engine);

FS_PRIVATE void itrp_MovePoint  (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0);
FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);
FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);

FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_InnerExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_Check_PF_Proj (GSP0);
FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0);
FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound);
FS_PRIVATE F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 value);
FS_PRIVATE fnt_instrDef*itrp_FindIDef (GSP uint8 opCode);
FS_PRIVATE uint8* itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 base, int16 shift);

/* Actual instructions for the jump table */
FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SDPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SFVTL (IPARAM);
FS_PRIVATE uint8* itrp_WPV (IPARAM);
FS_PRIVATE uint8* itrp_WFV (IPARAM);
FS_PRIVATE uint8* itrp_RPV (IPARAM);
FS_PRIVATE uint8* itrp_RFV (IPARAM);
FS_PRIVATE uint8* itrp_SFVTPV (IPARAM);
FS_PRIVATE uint8* itrp_ISECT (IPARAM);
FS_PRIVATE uint8* itrp_SRP0 (IPARAM);
FS_PRIVATE uint8* itrp_SRP1 (IPARAM);
FS_PRIVATE uint8* itrp_SRP2 (IPARAM);
FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM);
FS_PRIVATE uint8* itrp_LLOOP (IPARAM);
FS_PRIVATE uint8* itrp_RTG (IPARAM);
FS_PRIVATE uint8* itrp_RTHG (IPARAM);
FS_PRIVATE uint8* itrp_RTDG (IPARAM);
FS_PRIVATE uint8* itrp_ROFF (IPARAM);
FS_PRIVATE uint8* itrp_RUTG (IPARAM);
FS_PRIVATE uint8* itrp_RDTG (IPARAM);
FS_PRIVATE uint8* itrp_SROUND (IPARAM);
FS_PRIVATE uint8* itrp_S45ROUND (IPARAM);
FS_PRIVATE uint8* itrp_LMD (IPARAM);
FS_PRIVATE uint8* itrp_RAW (IPARAM);
FS_PRIVATE uint8* itrp_LWTCI (IPARAM);
FS_PRIVATE uint8* itrp_LSWCI (IPARAM);
FS_PRIVATE uint8* itrp_LSW (IPARAM);
FS_PRIVATE uint8* itrp_DUP (IPARAM);
FS_PRIVATE uint8* itrp_POP (IPARAM);
FS_PRIVATE uint8* itrp_CLEAR (IPARAM);
FS_PRIVATE uint8* itrp_SWAP (IPARAM);
FS_PRIVATE uint8* itrp_DEPTH (IPARAM);
FS_PRIVATE uint8* itrp_CINDEX (IPARAM);
FS_PRIVATE uint8* itrp_MINDEX (IPARAM);
FS_PRIVATE uint8* itrp_ROTATE (IPARAM);
FS_PRIVATE uint8* itrp_MDAP (IPARAM);
FS_PRIVATE uint8* itrp_MIAP (IPARAM);
FS_PRIVATE uint8* itrp_IUP (IPARAM);
FS_PRIVATE uint8* itrp_SHP (IPARAM);
FS_PRIVATE uint8* itrp_SHC (IPARAM);
FS_PRIVATE uint8* itrp_SHE (IPARAM);
FS_PRIVATE uint8* itrp_SHPIX (IPARAM);
FS_PRIVATE uint8* itrp_IP (IPARAM);
FS_PRIVATE uint8* itrp_MSIRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM);
FS_PRIVATE uint8* itrp_SANGW (IPARAM);
FS_PRIVATE uint8* itrp_FLIPPT (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM);
FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM);
FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM);
FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM);
FS_PRIVATE uint8* itrp_AA (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM);
FS_PRIVATE uint8* itrp_WS (IPARAM);
FS_PRIVATE uint8* itrp_RS (IPARAM);
FS_PRIVATE uint8* itrp_WCVT (IPARAM);
FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM);
FS_PRIVATE uint8* itrp_RCVT (IPARAM);
FS_PRIVATE uint8* itrp_RC (IPARAM);
FS_PRIVATE uint8* itrp_WC (IPARAM);
FS_PRIVATE uint8* itrp_MD (IPARAM);
FS_PRIVATE uint8* itrp_MPPEM (IPARAM);
FS_PRIVATE uint8* itrp_MPS (IPARAM);
FS_PRIVATE uint8* itrp_GETINFO (IPARAM);
FS_PRIVATE uint8* itrp_FLIPON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM);
FS_PRIVATE uint8* itrp_IF (IPARAM);
FS_PRIVATE uint8* itrp_ELSE (IPARAM);
FS_PRIVATE uint8* itrp_EIF (IPARAM);
FS_PRIVATE uint8* itrp_JMPR (IPARAM);
FS_PRIVATE uint8* itrp_JROT (IPARAM);
FS_PRIVATE uint8* itrp_JROF (IPARAM);
FS_PRIVATE uint8* itrp_ROUND (IPARAM);
FS_PRIVATE uint8* itrp_NROUND (IPARAM);
FS_PRIVATE uint8* itrp_PUSHB (IPARAM);
FS_PRIVATE uint8* itrp_PUSHW (IPARAM);
FS_PRIVATE uint8* itrp_MDRP (IPARAM);
FS_PRIVATE uint8* itrp_MIRP (IPARAM);
FS_PRIVATE uint8* itrp_CALL (IPARAM);
FS_PRIVATE uint8* itrp_FDEF (IPARAM);
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM);
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM);
FS_PRIVATE uint8* itrp_IDEF (IPARAM);
FS_PRIVATE uint8* itrp_UTP (IPARAM);
FS_PRIVATE uint8* itrp_SDB (IPARAM);
FS_PRIVATE uint8* itrp_SDS (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM);

FS_PRIVATE uint8*  itrp_PUSHB1 (IPARAM);
FS_PRIVATE uint8*  itrp_PUSHW1 (IPARAM);

FS_PRIVATE uint8*  itrp_LT  (IPARAM);
FS_PRIVATE uint8*  itrp_LTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_GT  (IPARAM);
FS_PRIVATE uint8*  itrp_GTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_EQ  (IPARAM);
FS_PRIVATE uint8*  itrp_NEQ (IPARAM);
FS_PRIVATE uint8*  itrp_AND (IPARAM);
FS_PRIVATE uint8*  itrp_OR  (IPARAM);
FS_PRIVATE uint8*  itrp_ADD (IPARAM);
FS_PRIVATE uint8*  itrp_SUB (IPARAM);
FS_PRIVATE uint8*  itrp_DIV (IPARAM);
FS_PRIVATE uint8*  itrp_MUL (IPARAM);
FS_PRIVATE uint8*  itrp_MAX (IPARAM);
FS_PRIVATE uint8*  itrp_MIN (IPARAM);

FS_PRIVATE uint8*  itrp_ODD (IPARAM);
FS_PRIVATE uint8*  itrp_EVEN (IPARAM);
FS_PRIVATE uint8*  itrp_NOT (IPARAM);
FS_PRIVATE uint8*  itrp_ABS (IPARAM);
FS_PRIVATE uint8*  itrp_NEG (IPARAM);
FS_PRIVATE uint8*  itrp_CEILING (IPARAM);
FS_PRIVATE uint8*  itrp_FLOOR (IPARAM);

FS_PRIVATE uint8*  itrp_IllegalInstruction (IPARAM);

FS_PRIVATE fnt_ElementType*itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode);
FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy);
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8*);

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
FS_PRIVATE void itrp_DDT (int8 c, int32 n);
#endif
#endif
FS_PRIVATE uint8* itrp_DEBUG (IPARAM);

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

FS_PRIVATE ErrorCode   itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc);

/* GLOBAL GS INITIALIZATION */

FS_PUBLIC void          itrp_UpdateGlobalGS(
	void *              pvGlobalGS, /* GlobalGS                             */
	void *              pvCVT,      /* Pointer to control value table       */
	void *              pvStore,    /* Pointer to storage                   */
	void *              pvFuncDef,  /* Pointer to function defintions       */
	void *              pvInstrDef, /* Pointer to instruction definitions   */
	void *              pvStack,    /* Pointer to the stack                 */
	LocalMaxProfile *       maxp,
	uint16              cvtCount,
	uint32              ulLengthFontProgram, /* Length of font program      */
	void *              pvFontProgram, /* Pointer to font program           */
	uint32              ulLengthPreProgram, /* Length of pre program        */
	void *              pvPreProgram,  /* Pointer to pre program            */
	ClientIDType        clientID)     /* User ID Number                     */
{
	fnt_GlobalGraphicStateType *    globalGS;
#ifdef FSCFG_SECURE
    uint16      maxStackElements = maxp->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
      maxStackElements = 1;
    }

#endif // FSCFG_EUDC_EDITOR_BUG
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->controlValueTable =   (F26Dot6 *)pvCVT;
	globalGS->store =               (F26Dot6 *)pvStore;
	globalGS->funcDef =             (fnt_funcDef *)pvFuncDef;
	globalGS->instrDef =            (fnt_instrDef *)pvInstrDef;
	globalGS->stackBase =           (F26Dot6 *)pvStack;
	globalGS->clientID =            clientID;
#ifdef FSCFG_SECURE
	globalGS->stackMax =             globalGS->stackBase + maxStackElements;
    globalGS->maxPointsIncludePhantom = MAX (maxp->maxPoints,maxp->maxCompositePoints) + NUM_PHANTOM_PTS;
#endif // FSCFG_SECURE

	if(ulLengthFontProgram)
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = (unsigned char *)pvFontProgram;
	}
	else
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = NULL;
	}
	if(ulLengthPreProgram)
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = (unsigned char *)pvPreProgram;
	}
	else
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = NULL;
	}

	globalGS->maxp = maxp;
	globalGS->cvtCount = cvtCount;
	globalGS->bCompositeGlyph = FALSE;
	globalGS->bSameTransformAsMaster = TRUE;
	globalGS->bOriginalPointIsInvalid = FALSE;

	globalGS->ulMaxJumpCounter = INTERP_MAX_JUMPS;
	globalGS->ulMaxRecursiveCall = INTERP_MAX_RECURSIVE_CALLS;
}

FS_PUBLIC boolean itrp_bApplyHints(
	void *      pvGlobalGS)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	return (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG));
}

FS_PUBLIC void  itrp_QueryScanInfo(
	void *      pvGlobalGS,
	uint16 *    pusScanType,
	uint16 *    pusScanControl)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
}

FS_PUBLIC void  itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8       bCompositeFlag)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bCompositeGlyph = bCompositeFlag;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bSameTransformAsMaster = (uint8)bSameTransformAsMaster;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

/*
*  function table
*/

FntFunc function [MAXBYTE_INSTRUCTIONS]
#ifndef FSCFG_NO_INITIALIZED_DATA
=
{
  itrp_SVTCA_0, itrp_SVTCA_1, itrp_SPVTCA_0, itrp_SPVTCA_1, itrp_SFVTCA_0, itrp_SFVTCA_1, itrp_SPVTL, itrp_SPVTL,
  itrp_SFVTL, itrp_SFVTL, itrp_WPV, itrp_WFV, itrp_RPV, itrp_RFV, itrp_SFVTPV, itrp_ISECT,
  itrp_SRP0, itrp_SRP1, itrp_SRP2, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_LLOOP,
  itrp_RTG, itrp_RTHG, itrp_LMD, itrp_ELSE, itrp_JMPR, itrp_LWTCI, itrp_LSWCI, itrp_LSW,
  itrp_DUP, itrp_POP, itrp_CLEAR, itrp_SWAP, itrp_DEPTH, itrp_CINDEX, itrp_MINDEX, itrp_ALIGNPTS,
  itrp_RAW, itrp_UTP, itrp_LOOPCALL, itrp_CALL, itrp_FDEF, itrp_IllegalInstruction, itrp_MDAP, itrp_MDAP,
  itrp_IUP, itrp_IUP, itrp_SHP, itrp_SHP, itrp_SHC, itrp_SHC, itrp_SHE, itrp_SHE,
  itrp_SHPIX, itrp_IP, itrp_MSIRP, itrp_MSIRP, itrp_ALIGNRP, itrp_RTDG, itrp_MIAP, itrp_MIAP,
  itrp_NPUSHB, itrp_NPUSHW, itrp_WS, itrp_RS, itrp_WCVT, itrp_RCVT, itrp_RC, itrp_RC,
  itrp_WC, itrp_MD, itrp_MD, itrp_MPPEM, itrp_MPS, itrp_FLIPON, itrp_FLIPOFF, itrp_DEBUG,
  itrp_LT, itrp_LTEQ, itrp_GT, itrp_GTEQ, itrp_EQ, itrp_NEQ, itrp_ODD, itrp_EVEN,
  itrp_IF, itrp_EIF, itrp_AND, itrp_OR, itrp_NOT, itrp_DELTAP1, itrp_SDB, itrp_SDS,
  itrp_ADD, itrp_SUB, itrp_DIV, itrp_MUL, itrp_ABS, itrp_NEG, itrp_FLOOR, itrp_CEILING,
  itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND,
  itrp_WCVTFOD, itrp_DELTAP2, itrp_DELTAP3, itrp_DELTAC1, itrp_DELTAC2, itrp_DELTAC3, itrp_SROUND, itrp_S45ROUND,
  itrp_JROT, itrp_JROF, itrp_ROFF, itrp_IllegalInstruction, itrp_RUTG, itrp_RDTG, itrp_SANGW, itrp_AA,

  itrp_FLIPPT, itrp_FLIPRGON, itrp_FLIPRGOFF, itrp_IDefPatch, itrp_IDefPatch, itrp_SCANCTRL, itrp_SDPVTL, itrp_SDPVTL,
  itrp_GETINFO, itrp_IDEF, itrp_ROTATE, itrp_MAX, itrp_MIN, itrp_SCANTYPE, itrp_INSTCTRL, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_PUSHB1, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB,
  itrp_PUSHW1, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP
}
#endif /* FSCFG_NO_INITIALIZED_DATA */
;

/* the old itrp_Init function and tables now live in history.fnt - deanb */


#ifdef  GET_STACKSPACE
  int32 MaxStackSize = 0;

  #define PUSH(p, x) \
	{ \
	  if (p - LocalGS.globalGS->stackBase > MaxStackSize) \
		MaxStackSize = p - LocalGS.globalGS->stackBase; \
	  (*(p)++ = (x)); \
	}

#else
  #define PUSH( p, x ) ( *(p)++ = (x) )
#endif
  #define POP( p )     ( *(--p) )

#define BADCOMPILER

#ifdef BADCOMPILER
#define BOOLEANPUSH( p, x ) PUSH( p, ((x) ? 1 : 0) ) /* MPW 3.0 */
#else
#define BOOLEANPUSH( p, x ) PUSH( p, x )
#endif

#ifdef FSCFG_DEBUG
void CHECK_RANGE (int32 n, int32 min, int32 max);
void CHECK_RANGE (int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
	ERR_REPORT (ERR_RANGE, n, min, max, 0);
}


void CHECK_ASSERTION (int32 expression);
void CHECK_ASSERTION (int32 expression)
{
  if (!expression)
	ERR_REPORT (ERR_ASSERTION, expression, 0, 0, 0);
}


void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt);
void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt)
{
  int32 cvtCount = (int32)(pGS->globalGS->cvtCount - 1L);

  if ((int32)cvt > cvtCount || (int32)cvt < 0L)
	ERR_REPORT (ERR_CVT, cvt, 0, cvtCount, 0);
}


void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef);
void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef)
{
  int32 maxFdef = (int32)(pGS->globalGS->maxp->maxFunctionDefs - 1L);

  if ((int32)fdef > maxFdef || (int32)fdef < 0L)
	ERR_REPORT (ERR_FDEF, fdef, 0, maxFdef, 0);
}

#define CHECK_PROGRAM(a)

void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem);
void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem)
{
  int32 maxElem = (int32)(pGS->globalGS->maxp->maxElements - 1L);

/*
  At least 1 maxElements will always be available
*/
  if (!maxElem)
	maxElem++;

  if ((int32)elem > maxElem || (int32)elem < 0L)
	ERR_REPORT (ERR_ELEMENT, elem, 0, maxElem, 0);
}

void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
  if (elem == &pGS->elements[1])
  {
	 int32 maxctrs, maxpts;

	maxctrs = MAX (pGS->globalGS->maxp->maxContours,
				   pGS->globalGS->maxp->maxCompositeContours);
	maxpts  = MAX (pGS->globalGS->maxp->maxPoints,
				   pGS->globalGS->maxp->maxCompositePoints);

	if ((int32)elem->nc > (int32)maxctrs || (int32)elem->nc < 1L)
	  ERR_REPORT (ERR_CONTOUR, elem->nc, 1, maxctrs, 0);

	if ((int32)elem->ep[elem->nc-1] > maxpts - 1L ||
		(int32)elem->ep[elem->nc-1] < 0L)
	  ERR_REPORT (ERR_POINT, elem->ep[elem->nc-1], 0, maxpts - 1L, 0);
  }
  else if (elem != &pGS->elements[0])
	ERR_REPORT (ERR_INDEX, elem, &pGS->elements[0], &pGS->elements[1], 0);
}

void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index);
void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index)
{
  int32 maxIndex = (int32)(pGS->globalGS->maxp->maxStorage - 1L);

  if ((int32)index > maxIndex || (int32)index < 0L)
	ERR_REPORT (ERR_STORAGE, index, 0, maxIndex, 0);
}

void CHECK_STACK (fnt_LocalGraphicStateType* pGS);
void CHECK_STACK (fnt_LocalGraphicStateType* pGS)
{
  int32 base = (int32)(pGS->stackPointer - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt);
void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if (pGS->elements == elem)
  {
	if ((int32)pt > pGS->globalGS->maxp->maxTwilightPoints - 1L ||
		(int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, pGS->globalGS->maxp->maxTwilightPoints - 1L, 0);
  }
  else                                                      /* phantom points */
  {
	if ((int32)pt > elem->ep[elem->nc-1] + 2L || (int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, elem->ep[elem->nc-1] + 2L, 0);
  }
}

void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr);
void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if ((int32)ctr > elem->nc - 1L || (int32)ctr < 0L)
	ERR_REPORT (ERR_CONTOUR, ctr, 0, elem->nc -1L, 0);
}

void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y);
void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y)
{
  if ( x == 0 && y == 0 )
	ERR_REPORT (ERR_VECTOR, x, y, 0, 0);
}

void CHECK_LARGER (int32 min, int32 n);
void CHECK_LARGER (int32 min, int32 n)
{
  if ( n <= min )
	ERR_REPORT (ERR_LARGER, min, n, 0, 0);
}

void CHECK_INT8 (int32 n);
void CHECK_INT8 (int32 n)
{
  if ( n & 0xFFFFFF00 )
	ERR_REPORT (ERR_INT8, n, 0, 0, 0);
}

void CHECK_INT16 (int32 n);
void CHECK_INT16 (int32 n)
{
  if ( n & 0xFFFF0000 )
	ERR_REPORT (ERR_INT16, n, 0, 0, 0);
}

void CHECK_SELECTOR (int32 n);
void CHECK_SELECTOR (int32 n)
{
  if ( n & ~((int32)SELECTOR_FLAGS) )
	ERR_REPORT (ERR_SELECTOR, n, 0, 0, 0);
}

void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt);
void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt)
{
  int32 base = (int32)(pt - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void POP_CHECK (F26Dot6*);
void POP_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr <= base)
	ERR_REPORT (ERR_STACK, (stackPtr - base - 1L), 0, (max - base), 0);
  return;
}

void PUSH_CHECK (F26Dot6*);
void PUSH_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr > max )
	ERR_REPORT (ERR_STACK, (stackPtr - base), 0, (max - base), 0);
  return;
}

#define CHECK_POP(s)                (POP_CHECK(s),POP(s))
#define CHECK_PUSH(s, v)            (PUSH_CHECK(s),PUSH(s, v))

#else
#define CHECK_RANGE(a,b,c)
#define CHECK_ASSERTION(a)
#define CHECK_CVT(pgs,b)
#define CHECK_POINT(pgs,b,c)
#define CHECK_CONTOUR(pgs,b,c)
#define CHECK_FDEF(pgs,b)
#define CHECK_PROGRAM(a)
#define CHECK_ELEMENT(pgs,b)
#define CHECK_ELEMENTPTR(pgs,b)
#define CHECK_STORAGE(pgs,b)
#define CHECK_STACK(pgs)
#define CHECK_VECTOR(a,b)
#define CHECK_LARGER(a,b)
#define CHECK_INT8(a)
#define CHECK_INT16(a)
#define CHECK_SELECTOR(a)
#define CHECK_SUBSTACK(pgs,a)
#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)            PUSH(s, v)
#endif

/*@@*/

/* ClaudeBe 4/15/98 new secure rasterizer testing of critical errors */
/* errors originally detected by the fstrace callback trace function */
/* moved inside the rasterizer for performance reason */

#ifdef FSCFG_SECURE

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) \
 \
  if (stackPtr - (int32)(lNumItems) < LocalGS.globalGS->stackBase) \
{ \
	LocalGS.ercReturn = SECURE_STACK_UNDERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) \
 \
  if (stackPtr + (int32)(lNumItems) > LocalGS.globalGS->stackMax) \
{ \
	LocalGS.ercReturn = SECURE_STACK_OVERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_SUBSTACK(stackPtr) \
 \
  if ((stackPtr < LocalGS.globalGS->stackBase) || (stackPtr >= LocalGS.globalGS->stackMax)) \
{ \
	LocalGS.ercReturn = SECURE_INVALID_STACK_ACCESS;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_POINT(elem, pt) \
{ \
    if (LocalGS.elements == elem) \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxp->maxTwilightPoints || \
		 (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
    else \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxPointsIncludePhantom || (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
}

#define SECURE_CHECK_FDEF(fdef) \
{ \
    if ((int32)fdef >= (LocalGS.globalGS->maxp->maxFunctionDefs) || (int32)fdef < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_FDEF_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_PROGRAM(pgmIndex) \
{ \
    if (pgmIndex >= MAXPREPROGRAMS) \
    { \
	  LocalGS.ercReturn = SECURE_ERR_FUNCTION_NOT_DEFINED;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_ZONE(elem) \
{ /* in theory we should compare with maxp->maxElements but the rasterizer always allocate for MAX_ELEMENTS zones */ \
    if ((int32)elem >= MAX_ELEMENTS || (int32)elem < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_INVALID_ZONE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) \
{ \
	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM) \
	/* in the glyph program, both zone (glyph and twilight are initialized */ \
	{ \
	    if (LocalGS.globalGS->pgmIndex != PREPROGRAM || LocalGS.elements != elem ) \
		/* in the pre-program, only the twilight zone is initialized, */ \
		/* in any other zone i.e. font program, none of the zones are initialized */ \
		{ \
	       LocalGS.ercReturn = SECURE_UNITIALIZED_ZONE;  /* error returned to client */ \
	       return LocalGS.pbyEndInst; \
		} \
    } \
}


#define SECURE_CHECK_IDEF_OPCODE(idef) \
{ \
    if ( idef & 0xFFFFFF00 ) \
    { \
	  LocalGS.ercReturn = SECURE_INST_OPCODE_TO_LARGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_IDEF_OVERFLOW() \
{ \
    if (LocalGS.globalGS->instrDefCount >= LocalGS.globalGS->maxp->maxInstructionDefs) \
    { \
	  LocalGS.ercReturn = SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_STORAGE(index) \
{ \
    if ((int32)index >= (LocalGS.globalGS->maxp->maxStorage) || (int32)index < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_STORAGE_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CONTOUR(elem, ctr) \
{ /* The reason in SECURE_CHECK_CONTOUR that we are checking against elem->nc instead of maxContours */ \
	/* is that we will access CE2->sp[contour] and we may try to access a point out of bounds */ \
    if ((int32)ctr < 0L || (int32)ctr >= (elem)->nc) \
    { \
	  LocalGS.ercReturn = SECURE_CONTOUR_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CVT(cvt) \
{ \
    if ((int32)cvt >= (LocalGS.globalGS->cvtCount) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) \
{ \
    if (((int32)cvt >= (LocalGS.globalGS->cvtCount) && cvt > 255) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}
#endif // FSCFG_FONTOGRAPHER_BUG

#else

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) 
#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) 
#define SECURE_CHECK_SUBSTACK(stackPtr) 
#define SECURE_CHECK_POINT(elem, pt) 
#define SECURE_CHECK_FDEF(fdef) 
#define SECURE_CHECK_PROGRAM(pgmIndex)
#define SECURE_CHECK_ZONE(elem)
#define SECURE_CHECK_IDEF_OPCODE(idef) 
#define SECURE_CHECK_IDEF_OVERFLOW() 
#define SECURE_CHECK_STORAGE(index) 
#define SECURE_CHECK_CONTOUR(elem, ctr) 
#define SECURE_CHECK_CVT(cvt) 
#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) 

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) 
#endif // FSCFG_FONTOGRAPHER_BUG

#endif


#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

/****** Element Codes *********/
#define SCE0_CODE       0x13
#define SCE1_CODE       0x14
#define SCE2_CODE       0x15
#define SCES_CODE       0x16

/****** Control Codes *********/
#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49

#ifdef FSCFG_SUBPIXEL
	// For SubPixel, rather than deciding within the rounding function whether we're currently
	// running SubPixel at all, and whether we're in the SubPixel-specific direction, we
	// install the appropriate version of the rounding function into the local ParameterBlock.
	// There are two parameters that determine this installation:
	// - a boolean "inSubPixelDirection" in LocalGS, set whenever the pv changes (eg. in SVTCA[X])
	// - an enum "roundState" in localParBlock, set whenever rounding state changes (eg. in RTG[])
	// It is necessary to have variables for these two parameters, because the states they
	// represent change independently, yet the round function depends on both parameters.
	// Whenever any of these two parameters change, we index the matrix "itrp_RoundFunction"
	// below to install the correct rounding function into the local ParameterBlock. 
	// Exception: itrp_RoundDownToGridSP, the SubPixel version of the RDTG function, inspects
	// the pv and actually rounds down to grid if pv == dpv. (cf. comments in itrp_RoundDownToGridSP)
	
	typedef enum { inRtdg = 0, inRdtg, inRutg, inRtg, inRthg, inRoff, inSRnd, inS45Rnd } RoundFunction;
	#ifndef FSCFG_NO_INITIALIZED_DATA
	const
	#endif
		  FntRoundFunc itrp_RoundFunction[2][8]
	#ifndef FSCFG_NO_INITIALIZED_DATA
												=  {{itrp_RoundToDoubleGrid,   itrp_RoundDownToGrid,   itrp_RoundUpToGrid,   itrp_RoundToGrid,   itrp_RoundToHalfGrid,   itrp_RoundOff,   itrp_SuperRound, itrp_Super45Round},
													{itrp_RoundToDoubleGridSP, itrp_RoundDownToGridSP, itrp_RoundUpToGridSP, itrp_RoundToGridSP, itrp_RoundToHalfGridSP, itrp_RoundOffSP, itrp_SuperRound, itrp_Super45Round}}
	#endif
	;
	// Following are two helper macros to update the aforementioned parameters "inSubPixelDirection"
	// and "roundState", along with installing the updated rounding function. The purpose of these
	// macros is to assert correspondence of the two parameters with the rounding function by system,
	// rather than by industriousness. The first helper macro is used whenever the projection vector
	// changes (eg. in SVTCA[X]) which changes whether or not we're in the SubPixel-specific direction.
	// The second helper macro is used whenever the round state changes (eg. in RTG[]).

	// Two versions of the first helper macro to update
	// - localGS.inSubPixelDirection (flag)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the projection vector.
	// We're using two different macros merely because VC wouldn't let us nest an #ifdef within a #define
	#ifdef NoVirtRoundInPrep
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection && (Tuned4SubPixel((localGS).globalGS) || (localGS).globalGS->pgmIndex != PREPROGRAM)][par->roundState];	\
			}
	#else
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
			}
	#endif

	// Second helper macro to update
	// - localParBlock.roundState (enum)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the round state.
	#define UpdateRoundFunctionByRoundState(localGS,state)											\
		{																							\
			fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																									\
			par->roundState = (state);																\
			par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
		}

	// Helper macro to used to determine whether or not to skip a delta instruction or function.
	// In backwardscompatibility mode, deltas are skipped if they are in SubPixel direction or
	// if they are applied to an untouched/unmoved point or if they are postIUP. Additionally,
	// deltas are skipped in composites if they are in SubPixel direction for proper centering
	// and vertical positioning of diacritical marks.
	// See also comments in itrp_SHP_Common.
	#ifdef InlineDeltasOnly
		#define AMovedPointInNonSPDirection(localGS,zonePtr,pointNum)							\
			((uint16)(!VerticalSPDirection((localGS).globalGS) ?								\
					  ProjVectInY((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & YMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupyCalled))) :	\
					  ProjVectInX((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & XMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupxCalled)))))
	#endif

#endif // FSCFG_SUBPIXEL

// Macros for rounding to grid etc. The purpose of these macros is to make the code more readable
// in cases such as MIRP, where rounding is performed inline for optimization reasons.
// - All rounding is applied to non-negative numbers only, negative numbers have their sign changed
//   before and after. 
// - Engine compensation is added to the unrounded number. Notice that substituting (literal) 0 for
//   engine will be optimized by the compiler
// - Rounding, in principle, follows the pattern in RTG:
//   - add half the "resolution" (this corresponds to adding 0.5)
//   - mask with the complement of "resolution"-minus-1 (this corresponds to a truncated division by
//	   "resolution", immediately followed by a multiplication by the same amount)
//	   Notice that masking only works with powers of two for the resolution

// for round-to-double-grid, we simply use half the resolution
#define RTDG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
		x = -x;						\
	}

// for round-down-to-grid, we skip the part that adds 0.5
#define RDTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-up-to-grid, we add "0.9999" instead of 0.5
#define RUTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

#define RTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-to-half-grid, we first round-down-to-grid, then add 0.5
#define RTHG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
		x = -x;						\
	}

// for round-off, we have to do the engine compensation part only
#define ROFF(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
	} else {						\
		x -= engine;				\
	}


// Macro for testing against cvt cut-in. The purpose of this macro is to make the code more readable
// in cases such as MIRP, where this test is performed in various places in accordance with #defines
// and flags. Notice that substituting (literal) 1 for overscale will be optimized by the compiler.
#define CVTCI(parameterBlock,distance,originalDistance,overscale)													\
	{																												\
		F26Dot6 difference = distance - originalDistance;															\
		difference *= overscale;																					\
		if (difference > parameterBlock->wTCI || difference < -parameterBlock->wTCI) /* not within cvt cut-in? */	\
			distance = originalDistance;																			\
	}

/* Set default values for all variables in globalGraphicsState DefaultParameterBlock
 *      Eventually, we should provide for a Default preprogram that could optionally be 
 *      run at this time to provide a different set of default values.
 */
ErrorCode itrp_SetDefaults (
	void *  pvGlobalGS,
	Fixed   fxPixelDiameter)
{
  fnt_ParameterBlock *par;
  fnt_GlobalGraphicStateType *  globalGS;

  globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

  par = &globalGS->defaultParBlock;

#ifdef FSCFG_SUBPIXEL
  par->roundState = inRtg;
  par->RoundValue = itrp_RoundFunction[RunningSubPixel(globalGS)
#ifdef NoVirtRoundInPrep
	// at this point, globalGS->pgmIndex is not defined. However, we may assume that we're called
	// exclusively from fsg_RunPreProgram, hence we assume that we're about to do the pre-program
	&& Tuned4SubPixel(globalGS)
#endif
	][par->roundState]; // at this point, LocalGS.inSubPixelDirection may not be defined
#else
  par->RoundValue = itrp_RoundToGrid;
#endif
  par->minimumDistance = FNT_PIXELSIZE;
  par->wTCI = FNT_PIXELSIZE * 17 / 16;
  par->sWCI = 0;
  par->sW   = 0;
  par->autoFlip = true;
  par->deltaBase = 9;
  par->deltaShift = 3;
  par->angleWeight = 128;
  par->scanControl = 0;
  par->instructControl = 0;

/* Set up the engine compensation array for the interpreter */
/* This will be indexed into by the booleans in some instructions */
  globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
  globalGS->engine[1] = FIXEDTODOT6 (FIXEDSQRT2 - fxPixelDiameter);  /* Black distance */
  globalGS->engine[2] = -globalGS->engine[1];                        /* White distance */

  return NO_ERR;
}

/************************************************************************/

/*
 * Illegal instruction trap
 */
FS_PRIVATE uint8* itrp_IllegalInstruction (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
	FS_UNUSED_PARAMETER(pbyInst);

	LocalGS.ercReturn = UNDEFINED_INSTRUCTION_ERR;  /* returned to client */
	return LocalGS.pbyEndInst;                      /* stops innerEx loop */
}

/************************************************************************/

/*  Scale vector (x,y) to unit length in 2.14   rewrite - 1/25/93 - deanb */

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec)
{
	Fract fLength;
	int32 lSumOfSquares;
	 int32 lShift;

	CHECK_RANGE (x, -32768L << 6, 32767L << 6);
	CHECK_RANGE (y, -32768L << 6, 32767L << 6);


	if ((x == 0L) && (y == 0L))             /* if null vector in */
	{
		pVec->x = ONEVECTOR;                /* default to unit x vector */
		pVec->y = 0;
	}
	else
	{
		if ((x < 32767L) && (x > -32768L) && (y < 32767L) && (y > -32768L))
		{
			lSumOfSquares = (x * x) + (y * y);  
			
				lShift = 8 * sizeof(Fract) - 17; /* to get x and y to 2.30 */
			while (lSumOfSquares < 0x20000000L)
			{
				lSumOfSquares <<= 2;        /* maximize precision */
					 lShift++;
			}
				x <<= lShift;
				y <<= lShift;                         /* keep x and y in step */
		}
		else
		{
			while ((x < 0x20000000L) && (x > -0x20000000L) && (y < 0x20000000L) && (y > -0x20000000L))
			{
				x <<= 1;
				y <<= 1;
			}
			lSumOfSquares = FracMul(x, x) + FracMul(y, y);
		}
		fLength = FracSqrt(lSumOfSquares);
		pVec->x = ROUNDFIXTOINT (FracDiv(x, fLength));
		pVec->y = ROUNDFIXTOINT (FracDiv(y, fLength));
	}
}


/******************** BEGIN Internal Rounding Routines ***************************/

F26Dot6 itrp_RoundToDoubleGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTDG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToDoubleGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTDG(x,engine,VIRTUAL_PIXELSIZE_RTDG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGridSP
#endif


F26Dot6 itrp_RoundDownToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RDTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundDownToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundDownToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
#ifdef RDTGRoundsDownToGrid
	// Historically, if a point to be aligned was away by 1.5 degrees or more from the line to which to align, the TypemanTalk
	// Align has translated to SPVTL, followed by RDTG and MDRP. This has a major problem: The MDRP instruction uses the set pv
	// to measure the original distance on the UNINSTRUCTED outline. This gives us an "original" distance which is more or less
	// wrong, depending on how far the reference point has moved already (notice that it is most likely that the reference point
	// has moved somewhat in x and in y before the alignee gets to be aligned). Subsequently, when MDRP gets to move the point,
	// it uses the same pv again, but this time around on the INSTRUCTED outline, in order to determine how far the point has to
	// be moved in the end. Luckily, this is used in connection with RDTG, which is applied to the "original" distance, and
	// thereby often reduces the "original" distance to 0, which often is closer the the correct original distance than the one
	// obtained by using the pv on the uninstructed outline.
	//   In SubPixel, however, these erroneous "original" distances would be rounded down to the nearest 1/16 of a pixel, and
	// with that become highly visible (a distance of just under 1 pixel, which is what gets rounded down to 0 in b/w, is too
	// large a distance to be ignored in SP). Therefore, we have to make an exception here. The recently introduced TypemanTalk
	// DAlign command, in contrast, uses the DUAL projection vector to measure the original distance on the UNINSTRUCTED outline,
	// which gives us the correct original distance. Therefore the exception is to test whether we're using the PV (in which case
	// we fall back onto the b/w rounding) or not (in which case we're using the SP rounding).
	if (Tuned4SubPixel(LocalGS.globalGS) || LocalGS.OldProject != itrp_Project) { // we're using the dual projection vector
#endif
		F26Dot6 x = xin;

		engine /= ENGINE_COMP_OVERSCALE;
		RDTG(x,engine,VIRTUAL_PIXELSIZE_RDTG);
		if (( (int32) (xin ^ x)) < 0 && xin) {
			x = 0; /* The sign flipped, make zero */
		}
		return x;
#ifdef RDTGRoundsDownToGrid
	} else { // we're using the "normal" projection vector
		return itrp_RoundDownToGrid(GSA xin,engine);
	}
#endif
} // itrp_RoundDownToGridSP
#endif


F26Dot6 itrp_RoundUpToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RUTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundUpToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RUTG(x,engine,VIRTUAL_PIXELSIZE_RUTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGridSP
#endif


F26Dot6 itrp_RoundToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTG(x,engine,VIRTUAL_PIXELSIZE_RTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGridSP
#endif


F26Dot6 itrp_RoundToHalfGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTHG(x,engine,FNT_PIXELSIZE);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? FNT_PIXELSIZE / 2 : -FNT_PIXELSIZE / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToHalfGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTHG(x,engine,VIRTUAL_PIXELSIZE_RTHG);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? VIRTUAL_PIXELSIZE_RTHG / 2 : -VIRTUAL_PIXELSIZE_RTHG / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGridSP
#endif


/*
 * Internal rounding routine
 */
F26Dot6 itrp_RoundOff (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	ROFF(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOff

/*
 * Internal rounding routine
 */
#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundOffSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	ROFF(x,engine,VIRTUAL_PIXELSIZE_ROFF);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOffSP
#endif


/************************************************************************/

/*
 * Internal rounding routine
 */
F26Dot6 itrp_SuperRound (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
	x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin) 
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 itrp_Super45Round (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
	x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/******************** END Rounding Routines ***************************/


/* 3-versions ************************************************************************/

/*
 * Moves the point in element by delta (measured against the projection vector)
 * along the freedom vector.
 */

FS_PRIVATE void itrp_MovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
	VECTORTYPE pfProj;
	VECTORTYPE fx;
	VECTORTYPE fy;
	  
	pfProj = LocalGS.pfProj;
	fx = LocalGS.free.x;
	fy = LocalGS.free.y;

	CHECK_POINT (&LocalGS, element, point);

	if (pfProj != ONEVECTOR)
	{
		if (fx) 
		{
			if (pfProj == fx)                   /* if proj.x = 1 */
			{
				element->x[point] += delta;
			}
			else
			{
				element->x[point] += LongMulDiv (delta, (int32)fx, (int32)pfProj);
			}
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			if (pfProj == fy)                   /* if proj.y = 1 */
			{
				element->y[point] += delta;
			}
			else
			{
				element->y[point] += LongMulDiv (delta, (int32)fy, (int32)pfProj);
			}
			element->f[point] |= YMOVED;
		}
	}
	else
	{
		if (fx) 
		{
			element->x[point] += VECTORMUL (delta, fx);
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			element->y[point] += VECTORMUL (delta, fy);
			element->f[point] |= YMOVED;
		}
	}
}


/*
 * For use when the projection and freedom vectors coincide along the x-axis.
 */

FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType*element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->x[point] += delta;
  element->f[point] |= XMOVED;
}


/*
 * For use when the projection and freedom vectors coincide along the y-axis.
 */
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->y[point] += delta;
  element->f[point] |= YMOVED;
}

/*
 * projects x and y into the projection vector.
 */
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.proj.x) + VECTORMUL (y, LocalGS.proj.y));
}


/*
 * projects x and y into the old projection vector.
 */
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.oldProj.x) + VECTORMUL (y, LocalGS.oldProj.y));
}


/*
 * Projects when the projection vector is along the x-axis
 */
F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(y);

  return (x);
}


/*
 * Projects when the projection vector is along the y-axis
 */
F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(x);

  return (y);
}


/*************************************************************************/

/*** Compensation for Transformations ***/

/*
* Internal support routine, keep this guy FAST!!!!!!!          <3>
*/
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0)
{
  VECTORTYPE pvx, pvy;
  fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
  Fixed sySq, sxSq, strSq;

/* Do as few Math routines as possible to gain speed */

  pvx = LocalGS.proj.x;
  pvy = LocalGS.proj.y;
  if (pvy) 
  {
	if (pvx)
	{
	  if (LocalGS.cvtDiagonalStretch == 0)    /* cache is now invalid */
	  {
		pvy = VECTORDOT (pvy, pvy);
		pvx = VECTORDOT (pvx, pvx);
		sySq = FixMul (globalGS->cvtStretchY, globalGS->cvtStretchY);
		sxSq = FixMul (globalGS->cvtStretchX, globalGS->cvtStretchX);

		strSq = FixMul (VECTOR2FIX(pvx),sxSq) + FixMul (VECTOR2FIX(pvy),sySq);
		if  (strSq > ONEFIX)      /* Never happens! */
		  return ONEFIX;

		/* Convert 16.16 to 2.30, compute square root, round to 16.16 */
		LocalGS.cvtDiagonalStretch = (FracSqrt (strSq<<14) + (1<<13)) >> 14;
	  }
	  return LocalGS.cvtDiagonalStretch;
	}
	else        /* pvy == +1 or -1 */
	  return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
	return globalGS->cvtStretchX;
}


/*      Functions for function pointer in local graphic state
*/

FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n)
{
  CHECK_CVT (&LocalGS, n);
  return LocalGS.globalGS->controlValueTable[ n ];
}


FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n)
{
  Fixed scale;

  CHECK_CVT (&LocalGS, n);
  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->controlValueTable[ n ], scale));
}


FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0)
{
  return LocalGS.globalGS->localParBlock.scaledSW;
}


/*
 *
 */
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0)
{
  Fixed scale;

  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->localParBlock.scaledSW, scale));
}


/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);
  CHECK_CVT (&LocalGS, number);
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}



/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);

  CHECK_CVT (&LocalGS, number);

  delta = FixDiv (delta, itrp_GetCVTScale(GSA0));
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}

/*************************************************************************/

/*
 * This is the tracing interpreter.
 */
FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */

	if (pbyInst < pbyEndInst)
	{
		ERR_START ();
		while ((pbyInst < pbyEndInst) && (LocalGS.TraceFunc != NULL))
		{
			LocalGS.insPtr = pbyInst;               /* save for client */
			LocalGS.opCode = *pbyInst;              /* save for client */
			ERR_RECORD (*pbyInst);
			LocalGS.TraceFunc (&LocalGS, pbyEndInst);
			if (LocalGS.TraceFunc == NULL)          /* allow client to break out */
			{
				break;
			}
			lOpCode = (int32)*pbyInst;
			pbyInst++;
			pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
			ERR_BREAK ();
		}
		ERR_END ();
	}
}

/*************************************************************************/

/*
 * This is the fast non-tracing interpreter inner loop.
 */

FS_PRIVATE void itrp_InnerExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	ERR_START ();
	
	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */
	
	while (pbyInst < pbyEndInst)
	{
		ERR_RECORD (*pbyInst);
			  
		lOpCode = (int32)*pbyInst;  /* opCode no longer saved in LocalGS */
		pbyInst++;

		pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
		ERR_BREAK ();
	}
	ERR_END ();
}

/*************************************************************************/


#ifdef FSCFG_DEBUG
FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n);

FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0)
{
  ERR_REPORT (ERR_GETSINGLEWIDTHNIL, 0, 0, 0, 0);
  return 0;
}

FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n)
{
  ERR_REPORT (ERR_GETCVTENTRYNIL, 0, 0, 0, 0);
  return 0;
}
#endif

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteFontPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	fnt_GlobalGraphicStateType *    globalGS;

#ifdef FSCFG_SECURE
	int32 i;
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->instrDefCount = 0;        /* none allocated yet, always do this, even if there's no fontProgram */
	globalGS->init          = TRUE;
	globalGS->pgmIndex = FONTPROGRAM;

	/* To avoid accessing unitialized memory when setting LocalGS.MIRPCode */
    globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
    globalGS->engine[1] = 0;  /* Black distance */
    globalGS->engine[2] = 0;                        /* White distance */

#ifdef FSCFG_SUBPIXEL
		// init since we don't do itrp_SetDefaults prior to executing the fpgm
    globalGS->localParBlock.roundState = inRtg;
    globalGS->localParBlock.RoundValue = itrp_RoundToGrid;

    globalGS->subPixelCompatibilityFlags = 0;
    globalGS->numDeltaFunctionsDetected = 0;
#endif

#ifdef FSCFG_SECURE
	/* initialize globalGS->funcDef[...].pgmIndex with MAXPREPROGRAMS to detect calls to undefined functions */
	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGS->funcDef[i].pgmIndex = MAXPREPROGRAMS;

	}
#endif // FSCFG_SECURE

	if (globalGS->pgmList[FONTPROGRAM].Instruction)
	{
		return itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[FONTPROGRAM].Instruction,
			globalGS->pgmList[FONTPROGRAM].Instruction +
				globalGS->pgmList[FONTPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	return NO_ERR;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecutePrePgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	ErrorCode   result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->init          = TRUE;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* copy gState parameters */

	globalGS->pgmIndex = PREPROGRAM;

	if (globalGS->pgmList[PREPROGRAM].Instruction)
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[PREPROGRAM].Instruction,
			globalGS->pgmList[PREPROGRAM].Instruction + globalGS->pgmList[PREPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	else
	{
		result = NO_ERR;
	}

	if (! (globalGS->localParBlock.instructControl & DEFAULTFLAG))
		globalGS->defaultParBlock = globalGS->localParBlock;    /* change default parameters */

	return result;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteGlyphPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	uint8 *             ptr,
	uint8 *    eptr,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode                       result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	result = NO_ERR;

	globalGS->init          = FALSE;
	globalGS->pgmIndex		= GLYPHPROGRAM;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* default parameters for glyphs */
	
	if (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG))
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			ptr,
			eptr,
			globalGS,
			TraceFunc);
	}
	*pbChangeScanControl = (globalGS->localParBlock.scanControl !=
						   globalGS->defaultParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);

	return result;
}

/*************************************************************************/

/*
 * Executes the font instructions.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *              local graphics state if TraceFunc is not null.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
FS_PRIVATE ErrorCode itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc)

{
#ifdef FSCFG_REENTRANT
	fnt_LocalGraphicStateType thisLocalGS;
	fnt_LocalGraphicStateType* pLocalGS = &thisLocalGS;
#endif
	fnt_ElementType       aElements[MAX_ELEMENTS];

	MEMCPY((void*)&(aElements[TWILIGHTZONE]), (void*)pTwilightElement, sizeof (fnt_ElementType));
	MEMCPY((void*)&(aElements[GLYPHELEMENT]), (void*)pGlyphElement, sizeof (fnt_ElementType));
	
	STAT_ON_FNTEXEC;                        /* start STAT timer */    
	
	LocalGS.globalGS = globalGS;            /* init Local Graphics State */
	LocalGS.elements = aElements;
	LocalGS.Pt0 = 0; 
	LocalGS.Pt1 = 0; 
	LocalGS.Pt2 = 0;
	LocalGS.CE0 = &aElements[GLYPHELEMENT];
	LocalGS.CE1 = &aElements[GLYPHELEMENT];
	LocalGS.CE2 = &aElements[GLYPHELEMENT];
	LocalGS.free.x = ONEVECTOR;
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.oldProj.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.proj.y = 0;
	LocalGS.oldProj.y = 0;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
	LocalGS.OldProject = itrp_XProject;
	LocalGS.loop = 0;           /* 1 less than count for faster loops. mrr */

	LocalGS.ulJumpCounter = globalGS->ulMaxJumpCounter;           /* counter used to catch infinite loops */
	LocalGS.ulRecursiveCall = globalGS->ulMaxRecursiveCall;           /* counter used to catch deep recrusion */

	if (globalGS->engine[1] == 0)           /* if engine compenstion turned off */
	{
		LocalGS.MIRPCode = MIRPX;           /* default to fast mirp */
	}
	else
	{
		LocalGS.MIRPCode = MIRPG;           /* fall back to general mirp */
	}

	if (globalGS->pgmIndex == FONTPROGRAM)
	{
#ifdef FSCFG_DEBUG
		LocalGS.GetCVTEntry = itrp_GetCVTEntryNil;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthNil;
#else
		LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
#endif
		LocalGS.ChangeCvt = itrp_ChangeCvtFast;
	}
	else
	{
#ifdef FSCFG_SUBPIXEL
		globalGS->subPixelCompatibilityFlags &= ~(SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound | SPCF_inSkippableDeltaFn);
		// can't do this when doing the font program, would try to access the localParBlock, which is still uninitialized at this point.
		UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif
		if (globalGS->pixelsPerEm <= 1)
			return NO_ERR;
		  
		if (globalGS->bSameStretch)
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
			LocalGS.ChangeCvt = itrp_ChangeCvtFast;
		} 
		else 
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntrySlow;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthSlow;
			LocalGS.ChangeCvt = itrp_ChangeCvtSlow;
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}

		if (globalGS->localParBlock.sW)     /* We need to scale the single width for this size  */
		{
			globalGS->localParBlock.scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)(globalGS->localParBlock.sW));
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}
	}
	
	LocalGS.stackPointer = globalGS->stackBase;
	LocalGS.TraceFunc = TraceFunc;
	LocalGS.ercReturn = NO_ERR;             /* default return value */

	if (TraceFunc != NULL)
	{
		LocalGS.Interpreter = itrp_InnerTraceExecute;
	}
	else
	{
		LocalGS.Interpreter = itrp_InnerExecute;
	}
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(globalGS) && CompatibleWidthSP(globalGS))
			InitPhaseControl(&LocalGS.elements[GLYPHELEMENT]); // beats
#endif

	(*LocalGS.Interpreter) (GSA ptr, eptr);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!LocalGS.elements[GLYPHELEMENT].phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,&LocalGS.elements[GLYPHELEMENT]); // beats
	//	phaseControlExecuted == true by now
	}
#endif
	STAT_OFF_FNTEXEC;                            /* stop STAT timer */
	
	return LocalGS.ercReturn;               /* NO_ERR unless illegal inst */
}


/*************************************************************************/

/*** 2 internal LocalGS.pfProj computation support routines ***/

/*
 * Only does the check of LocalGS.pfProj
 */
  FS_PRIVATE void itrp_Check_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj = LocalGS.pfProj;

	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  LocalGS.pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
  }


/*
 * Computes LocalGS.pfProj and then does the check
 */
  FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj;

	pfProj = (VECTORTYPE)(VECTORDOT (LocalGS.proj.x, LocalGS.free.x) + VECTORDOT (LocalGS.proj.y, LocalGS.free.y));
	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
	LocalGS.pfProj = pfProj;

	LocalGS.cvtDiagonalStretch = 0;      /* invalidate cache */ 
  }

/******************************************/
/******** The Actual Instructions *********/
/******************************************/

/*
 * Set Vectors To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = 0;
	LocalGS.free.y = LocalGS.proj.y = ONEVECTOR;
	LocalGS.MovePoint = itrp_YMovePoint;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_YProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPY;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Vectors To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = ONEVECTOR;
	LocalGS.free.y = LocalGS.proj.y = 0;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_XProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPX;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = 0;
	LocalGS.proj.y = ONEVECTOR;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.proj.y = 0;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Freedom Vector to Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = 0;
	LocalGS.free.y = ONEVECTOR;
	LocalGS.pfProj = LocalGS.proj.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector to Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.pfProj = LocalGS.proj.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SPVTL (IPARAM)
  {
	int32 arg1, arg2;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

	CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);
	}

	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Dual Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SDPVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

//	Do the current domain
	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);

//	Do the old domain
	itrp_Normalize (LocalGS.CE1->ox[arg1] - LocalGS.CE2->ox[arg2], LocalGS.CE1->oy[arg1] - LocalGS.CE2->oy[arg2], &LocalGS.oldProj);

	if (BIT0 (lOpCode))	{ // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);

	  tmp = LocalGS.oldProj.y;
	  LocalGS.oldProj.y = LocalGS.oldProj.x;
	  LocalGS.oldProj.x = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = itrp_OldProject;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector To Line
 */
  FS_PRIVATE uint8* itrp_SFVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.free);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp     = LocalGS.free.y;
	  LocalGS.free.y     = LocalGS.free.x;
	  LocalGS.free.x     = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Write Projection Vector
 */
  FS_PRIVATE uint8* itrp_WPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.proj.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.proj.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	CHECK_VECTOR (LocalGS.proj.x, LocalGS.proj.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Write Freedom vector
 */
  FS_PRIVATE uint8* itrp_WFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.free.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.free.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

	CHECK_VECTOR (LocalGS.free.x, LocalGS.free.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Read Projection Vector
 */
  FS_PRIVATE uint8* itrp_RPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.y);
	return pbyInst;
  }

/*
 * Read Freedom Vector
 */
  FS_PRIVATE uint8* itrp_RFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.y);
	return pbyInst;
  }

/*
 * Set Freedom Vector To Projection Vector
 */
  FS_PRIVATE uint8* itrp_SFVTPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free = LocalGS.proj;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * itrp_ISECT ()
 *
 * Computes the intersection of two lines without using floating point!!
 *
 * (1) Bx + dBx * t0 = Ax + dAx * t1
 * (2) By + dBy * t0 = Ay + dAy * t1
 *
 *  1  => (t1 = Bx - Ax + dBx * t0) / dAx
 *  +2 =>   By + dBy * t0 = Ay + dAy/dAx * [ Bx - Ax + dBx * t0 ]
 *     => t0 * [dAy/dAx * dBx - dBy] = By - Ay - dAy/dAx* (Bx-Ax)
 *     => t0 (dAy*DBx - dBy*dAx) = dAx (By - Ay) + dAy (Ax-Bx)
 *     => t0 = [dAx (By-Ay) + dAy (Ax-Bx)] / [dAy*dBx - dBy*dAx]
 *     => t0 = [dAx (By-Ay) - dAy (Bx-Ax)] / [dBx*dAy - dBy*dAx]
 *     t0 = N/D
 *     =>
 *          N = (By - Ay) * dAx - (Bx - Ax) * dAy;
 *              D = dBx * dAy - dBy * dAx;
 *      A simple floating point implementation would only need this, and
 *      the check to see if D is zero.
 *              But to gain speed we do some tricks and avoid floating point.
 *
 */
  FS_PRIVATE uint8* itrp_ISECT (IPARAM)
  {
	F26Dot6 N, D;
	int32   arg1, arg2;
	F26Dot6 Bx, By, Ax, Ay;
	F26Dot6 dBx, dBy, dAx, dAy;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int32 arg1p, arg2p;
#endif

	{
	  fnt_ElementType*element = LocalGS.CE0;
	  F26Dot6*stack = LocalGS.stackPointer;

	  FS_UNUSED_PARAMETER(lOpCode);

      SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 5);

	  arg2 = (int32)CHECK_POP (stack); /* get one line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg1);
	  dAx = element->x[arg2] - (Ax = element->x[arg1]);
	  dAy = element->y[arg2] - (Ay = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS)) {
		  arg2p = arg2;
		  arg1p = arg1;
	  }
#endif

	  element = LocalGS.CE1;
	  arg2 = (int32)CHECK_POP (stack); /* get the other line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);
	  dBx = element->x[arg2] - (Bx = element->x[arg1]);
	  dBy = element->y[arg2] - (By = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS) && MABS(Mul26Dot6(dBy,dAx)) > MABS(Mul26Dot6(dBx,dAy))) {
		  arg2p = arg2;	// pick the line which is closer to the y-axis
		  arg1p = arg1; // since aligning perpendicular to parent axis
	  }
#endif
	  arg1 = (int32)CHECK_POP (stack); /* get the point number */
	  SECURE_CHECK_POINT (LocalGS.CE2, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE2, arg1);
	  LocalGS.stackPointer = stack;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  // for our purposes, handle like a proportion (have intersected point follow proportional to parents)
	  // need no fv, pv set for ISECT, hence we don't test against LocalGS.inSubPixelDirection
	  if (LocalGS.CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS))
		AddProportion(&LocalGS,LocalGS.CE2,arg1p,arg1,arg2p);
#endif
				


	}
	LocalGS.CE2->f[arg1] |= XMOVED | YMOVED;
	{
	  F26Dot6*elementx = LocalGS.CE2->x;
	  F26Dot6*elementy = LocalGS.CE2->y;
	  if (dAy == 0) 
	  {
		if (dBx == 0) 
		{
		  elementx[arg1] = Bx;
		  elementy[arg1] = Ay;
		  return pbyInst;
		}
		N = By - Ay;
		D = -dBy;
	  } 
	  else if (dAx == 0) 
	  {
		if (dBy == 0) 
		{
		  elementx[arg1] = Ax;
		  elementy[arg1] = By;
		  return pbyInst;
		}
		N = Bx - Ax;
		D = -dBx;
	  } 
	  else if (MABS (dAx) >= MABS (dAy))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (By - Ay) - MulDiv26Dot6 (Bx - Ax, dAy, dAx);
		D = MulDiv26Dot6 (dBx, dAy, dAx) - dBy;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (By - Ay, dAx, dAy) - (Bx - Ax);
		D = dBx - MulDiv26Dot6 (dBy, dAx, dAy);
	  }

	  if (D) 
	  {
		elementx[arg1] = Bx + (F26Dot6) MulDiv26Dot6 (dBx, N, D);
		elementy[arg1] = By + (F26Dot6) MulDiv26Dot6 (dBy, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, put point in the middle */
		elementx[arg1] = (Bx + (dBx >> 1) + Ax + (dAx >> 1)) >> 1;
		elementy[arg1] = (By + (dBy >> 1) + Ay + (dAy >> 1)) >> 1;
	  }
	}
	return pbyInst;
  }

/*
 * Load Minimum Distance
 */
  FS_PRIVATE uint8* itrp_LMD (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.minimumDistance = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.minimumDistance);
	return pbyInst;
  }

/*
 * Load Control Value Table Cut In
 */
  FS_PRIVATE uint8* itrp_LWTCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.wTCI = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.wTCI);
	return pbyInst;
  }

/*
 * Load Single Width Cut In
 */
  FS_PRIVATE uint8* itrp_LSWCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.sWCI = CHECK_POP (LocalGS.stackPointer);
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.sWCI);
	return pbyInst;
  }

/*
 * Load Single Width , assumes value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_LSW (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->sW = (int16)arg;
	CHECK_LARGER (-1L, pb->sW);

	pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); /* measurement should not come from the outline */
	return pbyInst;
  }

/* these functions were split out from itrp_SetLocalGraphicState - deanb */
  
  FS_PRIVATE uint8* itrp_SRP0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt0 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt1 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP2 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_LLOOP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.loop = (int32)(CHECK_POP (LocalGS.stackPointer)) - 1;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_POP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }


  FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM)
  {
	int32             arg;
	fnt_ElementType * element;

	switch (lOpCode)
	{
	  case SCES_CODE: 
		ERR_OPC ("SCES");
		break;
	  case SCE0_CODE: 
		ERR_OPC ("SCE0");
		break;
	  case SCE1_CODE: 
		ERR_OPC ("SCE1");
		break;
	  case SCE2_CODE: 
		ERR_OPC ("SCE2");
		break;
	  default:
		ERR_OPC ("???");
		break;
	}

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg);
    CHECK_ELEMENT (&LocalGS, arg);
	element = &LocalGS.elements[ arg ];

	switch (lOpCode)
	{
	  case SCES_CODE: 
		LocalGS.CE2 = element;
		LocalGS.CE1 = element;
	  case SCE0_CODE: 
		LocalGS.CE0 = element;
		break;
	  case SCE1_CODE: 
		LocalGS.CE1 = element;
		break;
	  case SCE2_CODE: 
		LocalGS.CE2 = element;
		break;
#ifdef FSCFG_DEBUG
	  default:
		ERR_REPORT (ERR_INVOPC, lOpCode, 0, 0, 0);
		break;
#endif
	}
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_SROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, true);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inSRnd);
#else
	pb->RoundValue = itrp_SuperRound; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_S45ROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, false);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inS45Rnd);
#else
	pb->RoundValue = itrp_Super45Round; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*********************************************************************/

/*  These routines were split out from SetRoundState  */
/*  They set the current rounding state, and all but  */
/*  RoundToGrid cause MIRP to fall back to MIRPG      */


FS_PRIVATE uint8* itrp_RTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtg)
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToGrid;
#endif
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTHG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRthg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToHalfGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTDG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtdg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToDoubleGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_ROFF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRoff);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundOff;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RDTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRdtg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundDownToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RUTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRutg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundUpToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

/*********************************************************************/


#define FRACSQRT2DIV2   11591
/*
 * Internal support routine for the super rounding routines
 */
  FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound)
  {
	 int32       tmp;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

	tmp = arg1 & 0xC0;

	if (normalRound) 
	{
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period = FNT_PIXELSIZE / 2;
		break;
	  case 0x40:
		pb->period = FNT_PIXELSIZE;
		break;
	  case 0x80:
		pb->period = FNT_PIXELSIZE * 2;
		break;
	  default:
		pb->period = 999; /* Illegal */
	  }
	  pb->periodMask = ~ (pb->period - 1);
	} 
	else 
	{
	  pb->period45 = FRACSQRT2DIV2;
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period45 >>= 1;
		break;
	  case 0x40:
		break;
	  case 0x80:
		pb->period45 <<= 1;
		break;
	  default:
		pb->period45 = 999; /* Illegal */
	  }
	  tmp = (sizeof (pb->period45) * 8 - 2 - FNT_PIXELSHIFT);
	  pb->period = (int16) ((pb->period45 + (1L << (tmp - 1))) >> tmp); /*convert from 2.30 to 26.6 */
	}

	tmp = arg1 & 0x30;
	switch (tmp) 
	{
	case 0x00:
	  pb->phase = 0;
	  break;
	case 0x10:
	  pb->phase = (int16)((pb->period + 2) >> 2);
	  break;
	case 0x20:
	  pb->phase = (int16)((pb->period + 1) >> 1);
	  break;
	case 0x30:
	  pb->phase = (int16)((pb->period + pb->period + pb->period + 2) >> 2);
	  break;
	}
	tmp = arg1 & 0x0f;
	if (tmp == 0) 
	{
	  pb->threshold = (int16)(pb->period - 1);
	} 
	else 
	{
	  pb->threshold = (int16)(((tmp - 4) * pb->period + 4) >> 3);
	}
  }

/*
 * Read Advance Width
 */
  FS_PRIVATE uint8* itrp_RAW (IPARAM)
  {
	F26Dot6* ox;
	int32 index;  

	FS_UNUSED_PARAMETER(lOpCode);

	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM)
	{
		LocalGS.ercReturn = RAW_NOT_IN_GLYPHPGM_ERR;  /* returned to client, error RAW not in glyph program */
		return LocalGS.pbyEndInst;
	}

	ox = LocalGS.elements[GLYPHELEMENT].ox;
	index = LocalGS.elements[GLYPHELEMENT].ep[LocalGS.elements[GLYPHELEMENT].nc - 1] + 1;      /* lsb point */

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH( LocalGS.stackPointer, ox[index+1] - ox[index] );
	return pbyInst;
  }

/*
 * DUPlicate
 */
  FS_PRIVATE uint8* itrp_DUP (IPARAM)
  {
	F26Dot6 top;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	top = LocalGS.stackPointer[-1];
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, top);
	return pbyInst;
  }

/*
 * CLEAR stack
 */
  FS_PRIVATE uint8* itrp_CLEAR (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.stackPointer = LocalGS.globalGS->stackBase;
	return pbyInst;
  }

/*********************************************************************/

/*
 * SWAP
 */
FS_PRIVATE uint8* itrp_SWAP (IPARAM)
{
	F26Dot6 *pfxStack;
	F26Dot6 fxTemp;
		   
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxTemp = pfxStack[0];
	pfxStack[0] = pfxStack[-1];
	pfxStack[-1] = fxTemp;
	
	return pbyInst;
}

/*********************************************************************/

/*
 * DEPTH
 */
  FS_PRIVATE uint8* itrp_DEPTH (IPARAM)
  {
	F26Dot6 depth = (F26Dot6)(LocalGS.stackPointer - LocalGS.globalGS->stackBase);
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, depth);
	return pbyInst;
  }

/*
 * Copy INDEXed value
 */
  FS_PRIVATE uint8* itrp_CINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	CHECK_PUSH (stack , tmp);
	return pbyInst;
  }

/*
 * Move INDEXed value
 */
  FS_PRIVATE uint8* itrp_MINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	if (arg1 > 0) 
	{
	  do 
	  {
		*p = * (p + 1); 
		p++;
	  } while (--arg1);
	  CHECK_POP (stack);
	}
	CHECK_PUSH (stack, tmp);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 *      Rotate element 3 to the top of the stack                        <4>
 *      Thanks to Oliver for the obscure code.
 */
  FS_PRIVATE uint8* itrp_ROTATE (IPARAM)
  {
	F26Dot6 *stack = LocalGS.stackPointer;
	F26Dot6 element1;
	F26Dot6 element2;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 3);
	element1 = *--stack;
	element2 = *--stack;

    *stack = element1;
	element1 = *--stack;
	*stack = element2;
	* (stack + 2) = element1;
	return pbyInst;
  }

/*********************************************************************/

/*
 * Move Direct Absolute Point
 */
FS_PRIVATE uint8* itrp_MDAP (IPARAM) {
	F26Dot6 fxProj;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;
	int32 iPoint;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint; 
	LocalGS.Pt1 = iPoint;

	if (BIT0 (lOpCode)) { // round?
		fxProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);
		fxProj = pb->RoundValue (GSA fxProj, LocalGS.globalGS->engine[0]) - fxProj;
	} else {
		fxProj = 0;         /* mark the point as touched */
	}

	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxProj);
	return pbyInst;
} // itrp_MDAP

/*********************************************************************/

/*
 * Move Indirect Absolute Point
 */
FS_PRIVATE uint8* itrp_MIAP (IPARAM) {
	int32   iPoint;
	int32   iCVTIndex;
	F26Dot6 fxNewProj;
	F26Dot6 fxOrigProj;
	F26Dot6 fxProjDif;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	fxNewProj = LocalGS.GetCVTEntry (GSA iCVTIndex);

	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint;
	LocalGS.Pt1 = iPoint;

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE0->x[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.x);
		pCE0->ox[iPoint] = pCE0->x[iPoint];
		pCE0->y[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.y);
		pCE0->oy[iPoint] = pCE0->y[iPoint];
	}

	fxOrigProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);

	if (BIT0 (lOpCode)) { // round?
		fxProjDif = fxNewProj - fxOrigProj;
		if (fxProjDif < 0) {
			fxProjDif = -fxProjDif;
		}
		if (fxProjDif > pb->wTCI) {
			fxNewProj = fxOrigProj;
		}
		fxNewProj = pb->RoundValue (GSA fxNewProj, LocalGS.globalGS->engine[0]);
	}
	// Notice that unlike MIRP, here we don't have a switch that would require the round-off flag MIAP[r] to honour
	// the cvt cut-in. We assume that the context is a stroke placement with coordinates calculated to move a stroke
	// possibly from the origin to the targeted location such as in PMingLiU. See also comments in MSIRP and MIRP.
	
	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxNewProj - fxOrigProj);
	return pbyInst;
} // itrp_MIAP


/*********************************************************************/

FS_PRIVATE uint8* itrp_IUP (IPARAM)
{
	fnt_ElementType *pCE2;
	
	int32 *alOrig;                          /* original outline array */
	int32 *plOrig;
	int32 *plOrigTouch2;                    /* for loop stop */
	int32 *plOrigEnd;
	int32 lOrig1;                           /* touched point 1 */
	int32 lOrig2;                           /* touched point 2 */
	int32 lOrigMin;                         /* min coord touched point */
	int32 lOrigDelta;
	int32 lOrigCorr;
	
	F26Dot6 *afxScaled;                     /* scaled outline array */
	F26Dot6 *pfxScaled;
	F26Dot6 fxScaledMax;
	F26Dot6 fxScaledMin;
	F26Dot6 fxScaledCoord;
	
	F26Dot6 fxMovedMax;                     /* hint movement of max */
	F26Dot6 fxMovedMin;                     /* hint movement of min */

	F26Dot6 *afxHinted;                     /* hinted outline array */
	F26Dot6 *pfxHinted;
	F26Dot6 fxHintedMax;
	F26Dot6 fxHintedMin;
	F26Dot6 fxHintedDelta;

	uint8 *abyFlags;                        /* point flags array */
	uint8 byMask;
	
	int32 iPt;                         /* current point index */
	int32 iStartPt;                    /* start of contour */
	int32 iEndPt;                      /* end of contour */
	int32 iStopPt;                     /* touched point indicates completion */
	int32 iTouch1;
	int32 iTouch2;
	int32 iMin;
	int32 iMax;
			   
	int32 iContour;

	int32 lTemp;
	Fixed fRatio;

	STAT_ON_IUP;                        /* start STAT timer */    

	pCE2 = LocalGS.CE2;

	SECURE_CHECK_FOR_UNITIALIZED_ZONE(pCE2);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS,pCE2 != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		VerticalSPDirection(LocalGS.globalGS) != (lOpCode & 0x01) && !pCE2->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,pCE2);
	//	phaseControlExecuted == true by now
	}
#endif
	
	abyFlags = pCE2->f;

	if (lOpCode & 0x01)              /* use x coordinates */
	{
		afxHinted = pCE2->x;
		afxScaled = pCE2->ox;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->ox;
		}
		else
		{
			alOrig = pCE2->oox;
		}
		byMask = XMOVED;
	} 
	else                                    /* use y coordinates */
	{
		afxHinted = pCE2->y;
		afxScaled = pCE2->oy;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->oy;
		}
		else
		{
			alOrig = pCE2->ooy;
		}
		byMask = YMOVED;
	}

	for (iContour = 0; iContour < pCE2->nc; iContour++)
	{
		iStartPt = pCE2->sp[iContour];
		iEndPt = pCE2->ep[iContour];
		plOrigEnd = &alOrig[iEndPt];        /* for limit check */

		iPt = iStartPt;
		while (!(abyFlags[iPt] & byMask) && (iPt <= iEndPt))
		{
			iPt++;
		}
		if (iPt <= iEndPt)                  /* if any points are touched */
		{
			iStopPt = iPt;                  /* save for done condition */
			
			do                              /* for each contour segment */
			{
				do                          /* find next untouched point */
				{
					iTouch1 = iPt;
					iPt++;
					if (iPt > iEndPt)
					{
						iPt = iStartPt;
					}
				} while ((abyFlags[iPt] & byMask) && iPt != iStopPt);

				if (iPt != iStopPt)
				{
					iTouch2 = iPt;
					do                      /* find next touched point */
					{
						iTouch2++;
						if (iTouch2 > iEndPt)
						{
							iTouch2 = iStartPt;
						}
					} while (!(abyFlags[iTouch2] & byMask));

					lOrig1 = alOrig[iTouch1];
					lOrig2 = alOrig[iTouch2];
					if (lOrig1 < lOrig2)
					{
						lOrigMin = lOrig1;
						lOrigDelta = lOrig2 - lOrig1;
						iMin = iTouch1;
						iMax = iTouch2;
					}
					else
					{
						lOrigMin = lOrig2;
						lOrigDelta = lOrig1 - lOrig2;
						iMin = iTouch2;
						iMax = iTouch1;
					}
					
					fxHintedMin = afxHinted[iMin];
					fxScaledMin = afxScaled[iMin];
					fxMovedMin = fxHintedMin - fxScaledMin;

					if (lOrigDelta != 0L)
					{
						fxScaledMax = afxScaled[iMax];
						fxHintedMax = afxHinted[iMax];
						fxMovedMax = fxHintedMax - fxScaledMax;
						fxHintedDelta = fxHintedMax - fxHintedMin;

						if (lOrigDelta < 32768 && fxHintedDelta < 32768)
						{
							plOrig = &alOrig[iPt];          /* set up pointers */
							pfxScaled = &afxScaled[iPt];
							pfxHinted = &afxHinted[iPt];
							lOrigCorr = lOrigDelta >> 1;
							plOrigTouch2 = &alOrig[iTouch2];    /* set limits */
							
							while (plOrig < plOrigTouch2)   /* if not across start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
							}                               /* end of time critical loop */
															
							while (plOrig != plOrigTouch2)  /* if points span start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
								
								if (plOrig > plOrigEnd)
								{
									plOrig = &alOrig[iStartPt];
									pfxScaled = &afxScaled[iStartPt];
									pfxHinted = &afxHinted[iStartPt];
								}
							}
							iPt = iTouch2;              /* keep in step */
						}
						else                /* if too big for 32 bit product */
						{
							fRatio = FixDiv (fxHintedDelta, lOrigDelta);
							while (iPt != iTouch2)
							{
								lTemp = afxScaled[iPt];
								if (lTemp <= fxScaledMin)
								{
									lTemp += fxMovedMin;
								}
								else if (lTemp >= fxScaledMax)
								{
									lTemp += fxMovedMax;
								}
								else
								{
									lTemp = alOrig[iPt];
									lTemp -= lOrigMin;
									lTemp = FixMul (lTemp, fRatio);
									lTemp += fxHintedMin;
								}
								afxHinted[iPt] = (F26Dot6)lTemp;
								
								if (iPt < iEndPt)
									iPt++;
								else
									iPt = iStartPt;
							}
						}                   /* endif (lOrigDelta < 32768 && fxHintedDelta < 32768) */
					}
					else                    /* if (lOrigDelta == 0L) */
					{
						while (iPt != iTouch2)
						{
							afxHinted[iPt] += fxMovedMin;
							
							if (iPt < iEndPt)
								iPt++;
							else
								iPt = iStartPt;
						}
					}                       /* endif (lOrigDelta != 0L) */
				}                           /* endif (iPt != iStopPt) */
			} while (iPt != iStopPt);       /* until contour is closed */
		}                                   /* endif (iPt <= iEndPt) */
	 }
								  /* next contour */
	STAT_OFF_IUP;                           /* stop STAT timer */    

#ifdef FSCFG_SUBPIXEL
	LocalGS.globalGS->subPixelCompatibilityFlags |= (lOpCode & 0x01 ? SPCF_iupxCalled : SPCF_iupyCalled);
#endif

	return pbyInst;
} // itrp_IUP

/*********************************************************************/

boolean IsSideBearingPoint(fnt_ElementType *element, int32 point);
boolean IsSideBearingPoint(fnt_ElementType *element, int32 point) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point && point <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingPoint

boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1);
boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point0 && point0 <= numPoints + RIGHTSIDEBEARING || numPoints + LEFTSIDEBEARING <= point1 && point1 <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingLink


  FS_PRIVATE fnt_ElementType* itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode)
  {
	F26Dot6 proj;
	int32 pt;
	fnt_ElementType * element;

	if (BIT0 (lOpCode))
	{
	  pt = LocalGS.Pt1;
	  element = LocalGS.CE0;
	} 
	else 
	{
	  pt = LocalGS.Pt2;
	  element = LocalGS.CE1;
	}
	proj = (*LocalGS.Project) (GSA element->x[pt] - element->ox[pt], element->y[pt] - element->oy[pt]);

	*dx = *dy = 0; // silence prefix

	if (LocalGS.pfProj != ONEVECTOR)
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.x, (int32)LocalGS.pfProj);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.y, (int32)LocalGS.pfProj);
	}
	else
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	}
	*point = pt;
	return element;
  }

/*********************************************************************/

FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy)
{
	fnt_ElementType *CE2;
	int32 count;
	int32 point;
	
	CE2 = LocalGS.CE2;
	count = LocalGS.loop + 1;         /* faster for ms c8 */

	while (count != 0)
	{
		point = (int32)CHECK_POP (LocalGS.stackPointer);
		SECURE_CHECK_POINT (LocalGS.CE2, point);
		CHECK_POINT (&LocalGS, LocalGS.CE2, point);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			AddDistance(&LocalGS,CE2,refPoint,point,OTHER);
#endif

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// here we assume that if we're doing a SHPIX instruction, we're in the context of a function that implements delta instructions
		// for a range of ppem sizes. If such a delta occurs on an untouched point, regardless of whether it's in SP direction or not,
		// it creates a dent in the outline. While for b/w this is intended to flip one or more pixels, it distorts the stroke in SP.
		// If such a delta occurs on a touched point, it moves along the entire outline, such as to place strokes differently. If this
		// happens in SP direction, this distorts the natural spacing of the stroke(s). Therefore we keep only deltas on touched points
		// in non SP direction.
		//   Notice that strictly speaking, we should keep inline deltas (in non SP direction) only. However, since we do not have the
		// tree of instructions at this level, we don't know whether there are any dependant points that have been touched already,
		// prior to applying the delta (in which case it's a pre-IUP delta), or not (in which case it's an inline delta). In cases
		// where a pre-IUP delta was used to cleanup several pixels of the b/w bitmap, the SP result won't be optimal, but not nearly
		// as bad as it would be in grey-scaling. This is due to the oversampling, which in grey-scaling is done in both directions,
		// while only in one direction in SP. As a result, even the oversampled pixels (stripes) are typically "in".
		//   Notice also that we cannot use the fact whether IUP has happened already or not (even though this would be easy to track),
		// since some pre-IUP deltas are erroneously applied to untouched points, the result of which is unreliable in the sense that
		// the delta amount applies to the original (untouched) position of the point, which typically differs from its post-IUP
		// position. While this may lead to the desired result in b/w, in SP point positions likely will differ from those in b/w.
		// This has lead to irregularly spaced (and "angled") glyphs in fonts such as Palatino italic.
		//   Notice, finally, that for composites, the touched/untouched rule does not apply the same way. A point that is flagged as
		// untouched may have been previously touched while executing the code for the respective component. Yet a subsequent SHPIX or
		// possibly delta applied to that point will not create a(nother) dent in the outline, but move the entire outline, instead.
		// This is used in b/w e.g. to re-position diacritics to ensure a minimal distance of 1 pixel between the base character and
		// the diacritic. Hence we also keep deltas in composites.

		if (!shpix || (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_inSkippableDeltaFn) == 0 || AMovedPointInNonSPDirection(LocalGS,CE2,point)) {
#endif // InlineDeltasOnly
#endif // FSCFG_SUBPIXEL
		if (LocalGS.free.x) {
			CE2->x[point] += dx;
			CE2->f[point] |= XMOVED;
		}
		if (LocalGS.free.y) {
			CE2->y[point] += dy;
			CE2->f[point] |= YMOVED;
		}
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		}
#endif
#endif
		count--;
	}
	LocalGS.loop = 0;
    return pbyInst;
}

/*********************************************************************/

/*
 * SHift Point
 */
  FS_PRIVATE uint8* itrp_SHP (IPARAM)
  {
	F26Dot6 dx, dy;
	int32 point;

#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	itrp_SH_Common (GSA &dx, &dy, &point, lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

    return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		point,
#endif
#ifdef FSCFG_SUBPIXEL
		false, // we don't come from SHPIX
#endif
		dx, dy);
  }

/*
 * SHift Contour
 */
  FS_PRIVATE uint8* itrp_SHC (IPARAM)
  {
	fnt_ElementType *element;
	F26Dot6 dx, dy;
	int32 contour, point;

	{
	  F26Dot6 x, y;
	  int32 pt;

#ifdef FSCFG_SECURE
	  if (BIT0 (lOpCode))
	  {
	    SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	  } 
	  else 
	  {
	    SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	  }
#endif 
	  
	  element = itrp_SH_Common (GSA &x, &y, &pt, lOpCode);
	  point = pt;
	  dx = x;
	  dy = y;
	}
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	contour = (int32)CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (element != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!VerticalSPDirection(LocalGS.globalGS) && !element->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,element);
	//	phaseControlExecuted == true by now
		dx += element->pcr[point].phaseShift;
	}
#endif
	


	SECURE_CHECK_FOR_UNITIALIZED_ZONE(LocalGS.CE2);
	SECURE_CHECK_CONTOUR (LocalGS.CE2, contour);
	CHECK_CONTOUR (&LocalGS, LocalGS.CE2, contour);

	{
	  VECTORTYPE fvx = LocalGS.free.x;
	  VECTORTYPE fvy = LocalGS.free.y;
	  fnt_ElementType*CE2 = LocalGS.CE2;
	  int32 currPt = CE2->sp[contour];
	  int32 count = CE2->ep[contour] - currPt;
	  SECURE_CHECK_POINT (CE2, currPt + count);
	  CHECK_POINT (&LocalGS, CE2, currPt + count);
	  for (; count >= 0; --count)
	  {
		if (currPt != point || element != CE2)
		{
		  if (fvx) 
		  {
			CE2->x[currPt] += dx;
			CE2->f[currPt] |= XMOVED;
		  }
		  if (fvy) 
		  {
			CE2->y[currPt] += dy;
			CE2->f[currPt] |= YMOVED;
		  }
		}
		currPt++;
	  }
	}
	
	return pbyInst;
  }

/*********************************************************************/

/*
 * SHift Element                     rewritten 7/29/93 deanb
 *
 * Flags are no longer set to show touch in x or y direction
 */

FS_PRIVATE uint8* itrp_SHE (IPARAM)
{
	fnt_ElementType *element;
	F26Dot6 fxDX, fxDY;
	int32 lFirstPt, lRefPt, lLastPt, arg1;
	
	F26Dot6 fxSaveX;                    /* for ref point restoration */
	F26Dot6 fxSaveY;
	
	F26Dot6 *pfxX, *pfxStopX;           /* temporary element pointers */
	F26Dot6 *pfxY, *pfxStopY;
	
#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	element = itrp_SH_Common (GSA &fxDX, &fxDY, &lRefPt, lOpCode);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg1);
	CHECK_ELEMENT (&LocalGS, arg1);
	SECURE_CHECK_FOR_UNITIALIZED_ZONE(&LocalGS.elements[arg1]);

	lLastPt = LocalGS.elements[arg1].ep[LocalGS.elements[arg1].nc - 1];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lLastPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lLastPt);
	lFirstPt  = LocalGS.elements[arg1].sp[0];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lFirstPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lFirstPt);

	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		fxSaveX = LocalGS.elements[arg1].x[lRefPt];
		fxSaveY = LocalGS.elements[arg1].y[lRefPt];
	}
	
	if (LocalGS.free.x != 0) 
	{
		pfxX = &LocalGS.elements[arg1].x[lFirstPt];
		pfxStopX = &LocalGS.elements[arg1].x[lLastPt];

		while (pfxX <= pfxStopX)
		{
			*pfxX += fxDX;                      /* shift each point in x */
			pfxX++;
		}
	}

	if (LocalGS.free.y != 0) 
	{
		pfxY = &LocalGS.elements[arg1].y[lFirstPt];
		pfxStopY = &LocalGS.elements[arg1].y[lLastPt];

		while (pfxY <= pfxStopY)
		{
			*pfxY += fxDY;                      /* shift each point in y */
			pfxY++;
		}
	}
	
	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		LocalGS.elements[arg1].x[lRefPt] = fxSaveX;
		LocalGS.elements[arg1].y[lRefPt] = fxSaveY;
	}

	return pbyInst;
}

/*********************************************************************/

/*
 * SHift point by PIXel amount
 */
  FS_PRIVATE uint8* itrp_SHPIX (IPARAM)
  {
	F26Dot6 proj, dx, dy;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 2);
	proj = CHECK_POP (LocalGS.stackPointer);
	if (LocalGS.free.x)
	  dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	else
		dx = 0; // silence BC
	if (LocalGS.free.y)
	  dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	else
		dy = 0; // silence BC

	return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		-1,
#endif
#ifdef FSCFG_SUBPIXEL
		true, // we do come from SHPIX
#endif
		dx, dy);
  }

/*********************************************************************/

/*
 * Interpolate Point
 */

uint8* itrp_IP (IPARAM)
{
	int32 arg1;
	int32 RP1;
	int32 RP2;
	
	int32 cLoop;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_ElementType *pCE2;
	fnt_ElementType *pTwilight;
	
	F26Dot6 x_RP1;
	F26Dot6 ox_RP1;
	F26Dot6 *pCE1_ox;
	F26Dot6 *pCE2_ox;

	F26Dot6 y_RP1;
	F26Dot6 oy_RP1;
	F26Dot6 *pCE1_oy;
	F26Dot6 *pCE2_oy;

	F26Dot6 oldRange;
	F26Dot6 proj;
	F26Dot6 fxDelta;
	
	F26Dot6 *pfxStack;

	FntMoveFunc MovePoint;
	FntProject Project;
	

	FS_UNUSED_PARAMETER(lOpCode);

	cLoop = LocalGS.loop + 1;               /* faster for ms c8 */
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	pCE2 = LocalGS.CE2;
	pTwilight = &LocalGS.elements[TWILIGHTZONE];
	RP1 = LocalGS.Pt1;
	RP2 = LocalGS.Pt2;

	SECURE_CHECK_POINT (pCE0, RP1);
	SECURE_CHECK_POINT (pCE1, RP2);

	pfxStack = LocalGS.stackPointer;

	MovePoint = LocalGS.MovePoint;
	Project = LocalGS.Project;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, cLoop);
    
	if (pCE0 == pTwilight || pCE1 == pTwilight || pCE2 == pTwilight 
		|| LocalGS.globalGS->bOriginalPointIsInvalid)
	{
		ox_RP1 = pCE0->ox[RP1];
		oy_RP1 = pCE0->oy[RP1];
		pCE1_ox = pCE1->ox;
		pCE1_oy = pCE1->oy;
		pCE2_ox = pCE2->ox;
		pCE2_oy = pCE2->oy;
	}
	else
	{
		ox_RP1 = pCE0->oox[RP1];
		oy_RP1 = pCE0->ooy[RP1];
		pCE1_ox = pCE1->oox;
		pCE1_oy = pCE1->ooy;
		pCE2_ox = pCE2->oox;
		pCE2_oy = pCE2->ooy;
	}
	x_RP1 = pCE0->x[RP1];
	y_RP1 = pCE0->y[RP1];
		
	oldRange = LocalGS.OldProject (GSA pCE1_ox[RP2] - ox_RP1, pCE1_oy[RP2] - oy_RP1);
	
	if (oldRange != 0)                      /* this should always happen */
	{
		if (MovePoint == itrp_XMovePoint)   /* so project is also xproject */
		{
			proj = pCE1->x[RP2] - x_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_ox[arg1] - ox_RP1;
				fxDelta = (F26Dot6)MulDiv26Dot6 (proj, fxDelta, oldRange);
				
				pCE2->x[arg1] = fxDelta + x_RP1;
				pCE2->f[arg1] |= XMOVED;
				cLoop--;
			}
		}
		else if (MovePoint == itrp_YMovePoint)  /* so project is also yproject */
		{
			proj = pCE1->y[RP2] - y_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_oy[arg1] - oy_RP1; 
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				
				pCE2->y[arg1] = fxDelta + y_RP1;
				pCE2->f[arg1] |= YMOVED;
				cLoop--;
			}
		}
		else    /* if (MovePoint == itrp_MovePoint) */
		{
			proj = Project (GSA pCE1->x[RP2] - x_RP1, pCE1->y[RP2] - y_RP1);
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				MovePoint (GSA pCE2, arg1, fxDelta - 
					Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
				cLoop--;
			}
		}
	}
	else    /* if (oldRange == 0) */  
			/* this should never happen, but for safety's sake... */
	{
		while (cLoop != 0)
		{
			arg1 = (int32)CHECK_POP (pfxStack);
			SECURE_CHECK_POINT (pCE2, arg1);
			CHECK_POINT (&LocalGS, pCE2, arg1);
						
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
			if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
				AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
			fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
			MovePoint (GSA pCE2, arg1, fxDelta - 
				Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
			cLoop--;
		}
	}       /* endif (oldRange != 0) */
	
	LocalGS.stackPointer = pfxStack;
	LocalGS.loop = 0;
	return pbyInst;
}

/*********************************************************************/

/*
 * Move Stack Indirect Relative Point
 */

uint8* itrp_MSIRP (IPARAM) {
	int32 iPt0;
	int32 iPt2;                            // point #
	F26Dot6 fxDist;                        // distance
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	F26Dot6 fxOutlineDist;
	fnt_ParameterBlock *pb;
#endif
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	F26Dot6 fxPosition;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;

	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iPt0 = LocalGS.Pt0;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    fxDist = CHECK_POP (LocalGS.stackPointer);
	iPt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt2);
	CHECK_POINT (&LocalGS, pCE1, iPt2);
		
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPt2,BLACK); // don't really know any better
		AddDistance(&LocalGS,pCE1,iPt0,iPt2,color);
	}
#endif

	if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE1->ox[iPt2] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.x);
		pCE1->oy[iPt2] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.y);
		pCE1->x[iPt2] = pCE1->ox[iPt2];
		pCE1->y[iPt2] = pCE1->oy[iPt2];
	}
	
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	if (!Tuned4SubPixel(LocalGS.globalGS) && LocalGS.inSubPixelDirection) {
	// similarly to MIRP, here we honour a cvt cut-in in case there is a non-trivial outline distance between the
	// parent (reference) and the child (target) point involved, in which case we assume the context is a stroke weight,
	// else we assume the context is an accent placement function, in which case we use the actual distance as before
		fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt2] - pCE0->ox[iPt0], pCE1->oy[iPt2] - pCE0->oy[iPt0]);
		if (fxOutlineDist) { // else assume we're positioning accents with a calculated MSIRP, hence no cvt cut-in
			pb = &LocalGS.globalGS->localParBlock;
			// notice that unlike MIRP, we don't do the autoFlip since MSIRP is used with calculated distances that
			// would have the correct sign to begin with.
			CVTCI(pb,fxDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
		}
	}
#endif
#endif

	fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPt2] - pCE0->x[iPt0], pCE1->y[iPt2] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt2, fxDist - fxPosition);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt2;
	if (BIT0 (lOpCode)) {
		LocalGS.Pt0 = iPt2; // move the reference point
	}
	return pbyInst;
} // itrp_MSIRP

/*********************************************************************/

/*
 * Align Relative Point
 */

FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM)
  {
	fnt_ElementType*ce1 = LocalGS.CE1;
	F26Dot6 pt0x = LocalGS.CE0->x[LocalGS.Pt0];
	F26Dot6 pt0y = LocalGS.CE0->y[LocalGS.Pt0];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

	for (; LocalGS.loop >= 0; --LocalGS.loop)
	{
	  int32 ptNum = (int32)CHECK_POP (LocalGS.stackPointer);
	  F26Dot6 proj;

	  SECURE_CHECK_POINT (ce1, ptNum);
	  CHECK_POINT (&LocalGS, ce1, ptNum);
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (ce1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			// if we are aligning to some diagonal (pt0 and pt1 are set after SPVTL etc.), and if the child is between the parents
			// (InterAlign, cf. also comments there), we handle it as a proportion, else as a distance with non specific color.
			if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,ptNum,LocalGS.pt1))
				AddProportion(&LocalGS,ce1,LocalGS.pt0,ptNum,LocalGS.pt1);
			else
				AddDistance(&LocalGS,ce1,LocalGS.Pt0,ptNum,OTHER);
#endif
	  proj = -(* LocalGS.Project) (GSA ce1->x[ptNum] - pt0x, ce1->y[ptNum] - pt0y);
	  (*LocalGS.MovePoint) (GSA ce1, ptNum, proj);
	}
	LocalGS.loop = 0;
	return pbyInst;
  }


/*
 * Align Two Points (by moving both of them)
 */
  FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 move1, dist;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 2   */
	pt1  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 1   */
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
/* We do not have to check if we are in character element zero (the twilight zone)
		   since both points already have to have defined values before we execute this instruction */
	dist = LocalGS.CE1->x[pt2] - LocalGS.CE0->x[pt1];
	move1 = LocalGS.CE1->y[pt2] - LocalGS.CE0->y[pt1];
	if (LocalGS.Project != itrp_XProject)
	{
	  if (LocalGS.Project == itrp_YProject)
		dist = move1;
	  else
		dist = (*LocalGS.Project) (GSA dist, move1);
	}

	move1 = dist >> 1;
	(*LocalGS.MovePoint) (GSA LocalGS.CE0, pt1, move1);
	(*LocalGS.MovePoint) (GSA LocalGS.CE1, pt2, move1 - dist);
	return pbyInst;
  }

/*
 * Set Angle Weight
 */
  FS_PRIVATE uint8* itrp_SANGW (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.angleWeight = (int16)arg;
	return pbyInst;
  }

/*
 * Flip Point
 */
  FS_PRIVATE uint8* itrp_FLIPPT (IPARAM)
  {
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;
	int32 count = LocalGS.loop;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, count + 1);

    for (; count >= 0; --count)
	{
	  int32 point = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, point);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	  onCurve[ point ] ^= ONCURVE;
	}
	LocalGS.loop = 0;

	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip On a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ |= ONCURVE;
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip Off a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ &= ~ONCURVE;
	return pbyInst;
  }

/* 4/22/90 rwb - made more general
 * Sets lower 16 flag bits of ScanControl variable.  Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 *
 * stack: value => -;
 *
 */
  FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->scanControl = (pb->scanControl & 0xFFFF0000) | arg;
	return pbyInst;
  }

/* 5/24/90 rwb
 * Sets upper 16 bits of ScanControl variable. Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 */

  FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	int32 *scanPtr;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;
	scanPtr = (int32*)&(pb->scanControl);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);

/*  how it was:
	CHECK_SCANMODE (arg);
	if (arg == 0)  
	  *scanPtr &= 0xFFFF;
	else if (arg == 1)        
	  *scanPtr = (*scanPtr & 0xFFFF) | STUBCONTROL;
	else if (arg == 2)        
	  *scanPtr = (*scanPtr & 0xFFFF) | NODOCONTROL;
*/

/*  now any 8 bit value may be passed to the scan converter */
	
	*scanPtr = (*scanPtr & 0xFFFF) | (arg << 16);
	return pbyInst;
  }

/* 6/28/90 rwb
 * Sets instructControl flags in global graphic state.  Only legal in pre program.
 * A selector is used to choose the flag to be set.
 * Bit0 - NOGRIDFITFLAG - if set, then truetype instructions are not executed.
 *              A font may want to use the preprogram to check if the glyph is rotated or
 *              transformed in such a way that it is better to not gridfit the glyphs.
 * Bit1 - DEFAULTFLAG - if set, then changes in localParameterBlock variables in the
 *              globalGraphics state made in the CVT preprogram are not copied back into
 *              the defaultParameterBlock.  So, the original default values are the starting
 *              values for each glyph.
 * Bit2 - TUNED4SPFLAG - if set, a font will be rendered in native SP mode (as opposed to
 *              backwards compatible mode)
 *
 * stack: value, selector => -;
 *
 */
  FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM)  /* <13> */
  {
	fnt_GlobalGraphicStateType *globalGS;
	int32 *ic;
	int32 selector;
	int32 value;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;
	ic = (int32*)&globalGS->localParBlock.instructControl;
	arg = CHECK_POP (LocalGS.stackPointer);
	value = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (globalGS->init)
	{
	  if (selector == 1) 
		*ic &= ~NOGRIDFITFLAG;
	  else if (selector == 2) 
		*ic &= ~DEFAULTFLAG;
	  else if (selector == 3)
		*ic &= ~TUNED4SPFLAG;

	  *ic |= value;
	}
	return pbyInst;
  }

/*
 * AdjustAngle         <4>
 */
  FS_PRIVATE uint8* itrp_AA (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

	/* This is a NOP now. However, do pop the argument off the stack -amitc- 9/11/91. */
	/* Discard the popped value. -lenox- 11/11/91 */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	(void) CHECK_POP (LocalGS.stackPointer);
						 /* old code now lives in history.fnt - deanb */
	return pbyInst;
  }

/*********************************************************************/

/* Called by itrp_PUSHB and itrp_NPUSHB */

/* these functions were split out from itrp_PushSomeStuff - deanb */
  
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		CHECK_PUSH (stack, *pbyInst++);
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
	int16 word;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		word = *pbyInst++;
		CHECK_PUSH (stack, (int16) ((word << 8) + *pbyInst++));
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

/*********************************************************************/

/*
 * PUSH 1 Byte           the most commonly called pushb
 */
FS_PRIVATE uint8* itrp_PUSHB1 (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, *pbyInst++);
	return pbyInst;
}

/*
 * PUSH Bytes
 */
FS_PRIVATE uint8* itrp_PUSHB (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb0 + 1;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * N PUSH Bytes
 */
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * PUSH 1 Word           the most commonly called pushw
 */
FS_PRIVATE uint8* itrp_PUSHW1 (IPARAM)
{
	int16 word;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	word = *pbyInst++;
	CHECK_PUSH (LocalGS.stackPointer, (int16)((word << 8) + *pbyInst++));
	return pbyInst;
}

/*
 * PUSH Words           <3>
 */
FS_PRIVATE uint8* itrp_PUSHW (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb8 + 1;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*
 * N PUSH Words
 */
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*********************************************************************/

/*
 * Write Store
 */
  FS_PRIVATE uint8* itrp_WS (IPARAM)
  {
	F26Dot6 storage;
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	storage = CHECK_POP (LocalGS.stackPointer);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS,storeIndex);

	LocalGS.globalGS->store[ storeIndex ] = storage;
	return pbyInst;
  }

/*
 * Read Store
 */
  FS_PRIVATE uint8* itrp_RS (IPARAM) {
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS, storeIndex);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	if (storeIndex == 8 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedVacuformRound) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inVacuformRound;
		CHECK_PUSH (LocalGS.stackPointer, 0); // push 0 indicating we don't do vacuforming
	} else {
#endif
#endif
		CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->store[storeIndex]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	}
#endif
#endif
	return pbyInst;
  }

/*
 * Write Control Value Table from outLine, assumes the value comes form the outline domain
 */
  FS_PRIVATE uint8* itrp_WCVT (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);

	if (cvtValue != 0 && LocalGS.GetCVTEntry != itrp_GetCVTEntryFast)
	  cvtValue = FixDiv (cvtValue, itrp_GetCVTScale (GSA0));
	LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue;
	return pbyInst;
  }

/*
 * Write Control Value Table From Original Domain, assumes the value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);
	globalGS->controlValueTable[ cvtIndex ] = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, cvtValue);
	return pbyInst;
  }



/*
 * Read Control Value Table
 */
  FS_PRIVATE uint8* itrp_RCVT (IPARAM)
  {
	int32 cvtIndex;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

#ifndef FSCFG_FONTOGRAPHER_BUG
	SECURE_CHECK_CVT (cvtIndex);
#else
	SECURE_CHECK_CVT_READ_SPECIAL (cvtIndex);
#endif // FSCFG_FONTOGRAPHER_BUG

	CHECK_CVT (&LocalGS, cvtIndex);

	LocalGS.GetCVTEntry (GSA cvtIndex);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.GetCVTEntry (GSA cvtIndex));
	return pbyInst;
  }

/*
 * Read Coordinate
 */
  FS_PRIVATE uint8* itrp_RC (IPARAM)
  {
	int32 pt;
	fnt_ElementType * element;
	F26Dot6 proj;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pt = (int32)CHECK_POP (LocalGS.stackPointer);
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	if (BIT0 (lOpCode))
	  proj = (*LocalGS.OldProject) (GSA element->ox[pt], element->oy[pt]);
	else
	  proj = (*LocalGS.Project) (GSA element->x[pt], element->y[pt]);

	CHECK_PUSH (LocalGS.stackPointer, proj);
	return pbyInst;
  }

/*
 * Write Coordinate
 */
  FS_PRIVATE uint8* itrp_WC (IPARAM)
  {
	F26Dot6 proj, coord;
	int32 pt;
	fnt_ElementType *element;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	coord = CHECK_POP (LocalGS.stackPointer);/* value */
	pt = (int32)CHECK_POP (LocalGS.stackPointer);/* point */
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	proj = (*LocalGS.Project) (GSA element->x[pt],  element->y[pt]);
	proj = coord - proj;

	(*LocalGS.MovePoint) (GSA element, pt, proj);

	if (element == &LocalGS.elements[TWILIGHTZONE])
	{
	  element->ox[pt] = element->x[pt];
	  element->oy[pt] = element->y[pt];
	}
	return pbyInst;
  }


/*
 * Measure Distance
 */
  FS_PRIVATE uint8* itrp_MD (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 proj, *stack = LocalGS.stackPointer;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2 = (int32)CHECK_POP (stack);
	pt1 = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	if (BIT0 (lOpCode - MD_CODE)) { // MD[O] in original outline
		if (LocalGS.CE0 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.CE1 == &LocalGS.elements[TWILIGHTZONE] 
			|| LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->ox[pt1] - LocalGS.CE0->ox[pt2], LocalGS.CE1->oy[pt1] - LocalGS.CE0->oy[pt2]);
		}
		else if (globalGS->bSameStretch)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2], LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2] );
			proj = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, proj );
		}
		else
		{
			proj = (*LocalGS.OldProject) (GSA 
				globalGS->ScaleFuncX (&globalGS->scaleX, LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2]), 
				globalGS->ScaleFuncY (&globalGS->scaleY, LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2]) );
		}
	}

	/* old MS code, give different value than Apple :
	 * proj  = (*LocalGS.OldProject) (GSA LocalGS.CE0->ox[pt1] - LocalGS.CE1->ox[pt2], LocalGS.CE0->oy[pt1] - LocalGS.CE1->oy[pt2]);
	*/
	
	else { // MD[N] in grid-fitted outline
		proj  = (*LocalGS.Project) (GSA LocalGS.CE0->x[pt1] - LocalGS.CE1->x[pt2], LocalGS.CE0->y[pt1] - LocalGS.CE1->y[pt2]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
		if ((LocalGS.globalGS->subPixelCompatibilityFlags & (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound)) == (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound) && proj == FNT_PIXELSIZE)
			proj++; // increase by smallest possible amount to throw off type 2 vacuforms which are keyed off a distance being exacly 1 pixel
#endif
#endif
	}
	CHECK_PUSH (stack, proj);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Measure Pixels Per EM
 */
  FS_PRIVATE uint8* itrp_MPPEM (IPARAM)
  {
	uint16 ppem;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

	ppem = globalGS->pixelsPerEm;
	if (!globalGS->bSameStretch)
		ppem = (uint16)FixMul (ppem, itrp_GetCVTScale (GSA0));

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, ppem);
	return pbyInst;
  }

/*
 * Measure Point Size
 */
  FS_PRIVATE uint8* itrp_MPS (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->pointSize);
	return pbyInst;
  }

/*
 * Get Miscellaneous info: version number, rotated, stretched   <6>
 * Version number is 8 bits.  This is version 0x01 : 5/1/90
 *
 */

  FS_PRIVATE uint8* itrp_GETINFO (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	int32      info = 0;
	int32      selector;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (selector & VERSIONINTERPRETERQUERY)                            /* version */
	  info |= RASTERIZER_VERSION;
	if ((selector & ROTATEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
	  info |= ROTATEDGLYPH;
	if ((selector & STRETCHEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_STRETCH))
	  info |= STRETCHEDGLYPH;
	if ((selector & HINTFORGRAYINTERPRETERQUERY) && (globalGS->bHintForGray))
	  info |= HINTEDFORGRAYGLYPH;
#ifdef FSCFG_SUBPIXEL
	if ((selector & HINTFORSUBPIXELINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_SUB_PIXEL))
	  info |= HINTEDFORSUBPIXELGLYPH;
	if ((selector & HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
	  info |= HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH;
	if ((selector & HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
	  info |= HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH;
	if ((selector & HINTFORSUBPIXELBGRORDERINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_BGR_ORDER))
	  info |= HINTEDFORSUBPIXELBGRORDERGLYPH;
#endif // FSCFG_SUBPIXEL
	CHECK_PUSH (LocalGS.stackPointer, info);
	return pbyInst;
  } // itrp_GETINFO

/*
 * FLIP ON
 */
  FS_PRIVATE uint8* itrp_FLIPON (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = true;
	return pbyInst;
  }

/*
 * FLIP OFF
 */
  FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = false;
	return pbyInst;
  }

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
/*
 * DEBUG
 */
  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	int32 arg;
	int8 buffer[24];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);

	buffer[1] = 'D';
	buffer[2] = 'E';
	buffer[3] = 'B';
	buffer[4] = 'U';
	buffer[5] = 'G';
	buffer[6] = ' ';
	if (arg >= 0) 
	{
	  buffer[7] = '+';
	} 
	else 
	{
	  arg = -arg;
	  buffer[7] = '-';
	}

	buffer[13] = arg % 10 + '0'; 
	arg /= 10;
	buffer[12] = arg % 10 + '0'; 
	arg /= 10;
	buffer[11] = arg % 10 + '0'; 
	arg /= 10;
	buffer[10] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 9] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 8] = arg % 10 + '0'; 
	arg /= 10;

	buffer[14] = arg ? '*' : ' ';


	buffer[0] = 14; /* convert to pascal */
	DEBUGSTR (buffer);
	return pbyInst;
  }

#else           /* debug */

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* debug */
#else

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* ! not on the mac */


/* these functions were split out from itrp_BinaryOperand - deanb */

  FS_PRIVATE uint8* itrp_LT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] < pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_LTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] <= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] > pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] >= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] == pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] != pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_AND (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] && pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_OR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] || pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_ADD (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] += pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SUB (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] -= pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MUL (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] =  Mul26Dot6(pfxStack[-1], pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_DIV (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[0] == 0)
	{
		LocalGS.ercReturn = DIV_BY_0_IN_HINTING_ERR;  /* returned to client, error DIV by zero */
		return LocalGS.pbyEndInst;
	} 
	pfxStack[-1] = (int32)(((long)pfxStack[-1] << 6) / pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MAX (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] < pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_MIN (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] > pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

/**************************************************************************/

/* these functions were split out from itrp_UnaryOperand - deanb */

// for the ODD/EVEN pair, b/w, and no engine compensation case, we could
// essentially look at the two bits before and after the binary point of
// the F26Dot6 number:
//		1.100000 rounds to 2 (even)
//		1.000000 rounds to 1 (odd)
//		0.100000 rounds to 1 (odd)
//		0.000000 rounds to 0 (even)
// If the two bits are equal, then the number is even, else odd
// for engine compensation, we currently call the full itrp_RoundToGrid
// we'll allow tagged SP fonts to inquire about even/odd virtual pixels

  FS_PRIVATE uint8* itrp_ODD (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EVEN (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	fxArg++;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NOT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = !*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_ABS (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	if (*pfxStack < 0L)
	{
		*pfxStack = -*pfxStack;
	}
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_NEG (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = -*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_CEILING (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack += FNT_PIXELSIZE - 1;		// actually, this is not the pixel size, but the number 1 in 26.6
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// same here
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_FLOOR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// actually, this is not the pixel size, but the number 1 in 26.6
	return pbyInst;
  }
	  

/**************************************************************************/

/* This is called by itrp_IF, itrp_ELSE, itrp_FDEF, and itrp_IDEF         */
/* It is used to find the next TrueType instruction in the instruction    */
/* stream by skipping over push data.  It is table driven for speed.      */

static const uint8 gbyPushTable[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   21,22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 2, 3, 4, 5, 6, 7, 8, 2, 4, 6, 8,10,12,14,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8* pbyInst)
{
	int32 iDataCount;         /* count of data following push instruction */
	
	iDataCount = (int32)gbyPushTable[ pbyInst[-1] ];   /* opcode */
	
	if (iDataCount != 0)                        /* if a push instruction */
	{
		if (iDataCount == 21)                   /* special for npushb */
		{
			iDataCount = (int32)*pbyInst + 1;
		}
		else if (iDataCount == 22)              /* special for npushw */
		{
			iDataCount = ((int32)*pbyInst << 1) + 1;
		}
		pbyInst += iDataCount;

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * IF
 */
FS_PRIVATE uint8* itrp_IF (IPARAM)
{
	int32 iLevel;
	int32 iScanOpCode;
	int32 iDataCount;         /* count of data following push instruction */

	FS_UNUSED_PARAMETER(lOpCode);	
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	if (!CHECK_POP (LocalGS.stackPointer))
	{
		iLevel = 1;
		while ((iLevel != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
		{
			iScanOpCode = (int32)*pbyInst++;

			if (iScanOpCode == EIF_CODE)
			{
				ERR_IF (-1);
				iLevel--;
			} 
			else if (iScanOpCode == IF_CODE) 
			{
				ERR_IF (1);
				iLevel++;
			} 
			else if (iScanOpCode == ELSE_CODE) 
			{
				if (iLevel == 1) 
					break;
			} 
			else
			{
				iDataCount = (int32)gbyPushTable[iScanOpCode];
				
				if (iDataCount != 0)            /* if a push instruction */
				{
					if (iDataCount == 21)       /* special for npushb */
					{
						iDataCount = (int32)*pbyInst + 1;
					}
					else if (iDataCount == 22)  /* special for npushw */
					{
						iDataCount = ((int32)*pbyInst << 1) + 1;
					}
					pbyInst += iDataCount;
				}
			}
		}

		if ((pbyInst == LocalGS.pbyEndInst) && (iLevel != 0))
		{
			LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      ELSE for the IF
 */
FS_PRIVATE uint8* itrp_ELSE (IPARAM)
{
	int16 level;
	uint8 opCode;

	FS_UNUSED_PARAMETER(lOpCode);

	level = 1;
	while ((level != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
	{
		opCode = *pbyInst++;
		
		if (opCode == EIF_CODE)
		{
			ERR_IF (-1);
			level--;
		} 
		else if (opCode == IF_CODE) 
		{
			ERR_IF (1);
			level++;
		} 
		else
		{
			pbyInst = itrp_SkipPushData (GSA pbyInst);
		}
	}

	if (level != 0)
	{
		LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * End IF
 */
FS_PRIVATE uint8* itrp_EIF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);

	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative
 */
FS_PRIVATE uint8* itrp_JMPR (IPARAM)
{
	int32 offset;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);
	offset--;       /* since the interpreter post-increments the IP */
	pbyInst += offset;
	LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */

	if (LocalGS.ulJumpCounter == 0)
	{
		LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
    if (pbyInst < LocalGS.pbyStartInst)
	{
		LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
    }
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On True
 */
FS_PRIVATE uint8* itrp_JROT (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
		{
			LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On False
 */
FS_PRIVATE uint8* itrp_JROF (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (!bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
	    {
		    LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		    return LocalGS.pbyEndInst;
        }
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * ROUND
 */
  FS_PRIVATE uint8* itrp_ROUND (IPARAM)
  {
	F26Dot6 arg1;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x68, 0x6B);

	arg1 = pb->RoundValue (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x68]);
	
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/*
 * No ROUND
 */
  FS_PRIVATE uint8* itrp_NROUND (IPARAM)
  {
	F26Dot6 arg1;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x6C, 0x6F);

	arg1 = itrp_RoundOff (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x6c]);
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/**************************************************************************/

/*
 * An internal function used by MIRP an MDRP.
 */
  F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 fxValue) { // Single Width cut-in? B.St. to check
	F26Dot6 fxDelta;
	F26Dot6 fxScaledSW;
	fnt_ParameterBlock *pb;

	pb = &LocalGS.globalGS->localParBlock;
	fxScaledSW = LocalGS.GetSingleWidth (GSA0);

	if (fxValue >= 0) 
	{
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
	} 
	else 
	{
		fxValue = -fxValue;
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
		fxValue = -fxValue;
	}
	return fxValue;
}

/**************************************************************************/

/*
 * Move Direct Relative Point
 */
FS_PRIVATE uint8* itrp_MDRP (IPARAM)
{
	int32 iPt0;
	int32 iPt1;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	F26Dot6 fxMoveDist;
	F26Dot6 fxUnRounded;
	F26Dot6 fxMin;
	
	iPt0 = LocalGS.Pt0;
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPt1 = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt1);
	CHECK_POINT (&LocalGS, pCE0, iPt0);
	CHECK_POINT (&LocalGS, pCE1, iPt1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS))
		if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,iPt1,LocalGS.pt1))
			AddProportion(&LocalGS,pCE1,LocalGS.pt0,iPt1,LocalGS.pt1);
		else 
			AddDistance(&LocalGS,pCE1,iPt0,iPt1,OTHER); // strokes are hardly MDRPed, more likely to get black MDRPs that should be grey
#endif

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE] || pCE1 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.globalGS->bOriginalPointIsInvalid) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt1] - pCE0->ox[iPt0], pCE1->oy[iPt1] - pCE0->oy[iPt0]);
	} else if (globalGS->bSameStretch) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->oox[iPt1] - pCE0->oox[iPt0], pCE1->ooy[iPt1] - pCE0->ooy[iPt0]);
		fxMoveDist = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, fxMoveDist );
	} else {
		fxMoveDist = (*LocalGS.OldProject) (GSA 
			globalGS->ScaleFuncX (&globalGS->scaleX, pCE1->oox[iPt1] - pCE0->oox[iPt0]), 
			globalGS->ScaleFuncY (&globalGS->scaleY, pCE1->ooy[iPt1] - pCE0->ooy[iPt0]) );
	}

	if (pb->sWCI) { // Single Width cut-in? B.St. to check
		fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
	}

	fxUnRounded = fxMoveDist;

	if (BIT2 (lOpCode)) { // Round?
		fxMoveDist = pb->RoundValue (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	} else {
		fxMoveDist = itrp_RoundOff (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	}
	
	if (BIT3 (lOpCode)) { // Minimum distance?
		fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
		if (fxUnRounded >= 0) {
			if (fxMoveDist < fxMin)
				fxMoveDist = fxMin;
		} else {
			fxMin = -fxMin;
			if (fxMoveDist > fxMin)
				fxMoveDist = fxMin;
		}
	}

	fxMoveDist -= (*LocalGS.Project) (GSA pCE1->x[iPt1] - pCE0->x[iPt0], pCE1->y[iPt1] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt1, fxMoveDist);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt1;
	if (BIT4 (lOpCode))
	{
		LocalGS.Pt0 = iPt1;          /* move the reference point */
	}
	return pbyInst;
} // itrp_MDRP


/**************************************************************************/

/*
 * Move Indirect Relative Point     General
 */

/*    
 *  This routine branches to either the general MIRPG, or to the fast MIRPX 
 *  or MIRPY.  The MIRPCode is set to MIRPX at the beginning of each glyph, 
 *  and may be changed to MIRPY or to MIRPX by the SVTCA instructions.  
 *  Any other change in relevant state will cause the function vector to fall 
 *  back to MIRPG.
 *
 *  Conditions for fast MIRPX and MIRPY:
 *      fast cvt (identity transform)
 *      no single width cut in
 *      no twilight zone
 *      round to grid
 *      no engine compensation
 *      LocalGS.MovePoint = itrp_X[or Y]MovePoint;  
 */

FS_PRIVATE uint8* itrp_MIRP (IPARAM)
{
	int32 iPoint;
	int32 iPt0;
	int32 iCVTIndex;
	F26Dot6 fxMoveDist;
	F26Dot6 fxMin;
	F26Dot6 fxOutlineDist;
	F26Dot6 fxPosition;
	F26Dot6 fxEngine;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	
	fnt_ParameterBlock *pb;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;                /* common setup */
	pb = &globalGS->localParBlock;      
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE1, iPoint);
	CHECK_POINT (&LocalGS, LocalGS.CE1, iPoint);
	
	iPt0 = LocalGS.Pt0;
	SECURE_CHECK_POINT (LocalGS.CE0, iPt0);
	CHECK_POINT (&LocalGS, LocalGS.CE0, iPt0);
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPoint;
	
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPoint,lOpCode & 0x03);
		AddDistance(&LocalGS,pCE1,iPt0,iPoint,color);
	}
#endif

	if (LocalGS.MIRPCode == MIRPG)              /********* MIRPG *********/
	{
		fxMoveDist = LocalGS.GetCVTEntry (GSA iCVTIndex);

		if (pb->sWCI) { // Single Width cut-in? B.St. to check
			fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
		}

		if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
			pCE1->ox[iPoint] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.x);
			pCE1->x[iPoint] = pCE1->ox[iPoint];
			pCE1->oy[iPoint] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.y);
			pCE1->y[iPoint] = pCE1->oy[iPoint];
		}

		if (LocalGS.OldProject == itrp_XProject) {
			fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];
		} else if (LocalGS.OldProject == itrp_YProject) {
			fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];
		} else {
			fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPoint] - pCE0->ox[iPt0], pCE1->oy[iPoint] - pCE0->oy[iPt0]);
		}

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

		fxEngine = globalGS->engine[lOpCode & 0x03];

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// here we may honour a cvt cut-in even though the round-off flag would require not to do so. We assume that the
			// context is a stroke weight that has been tweaked for use with grey-scaling, and the only way to force MIRP
			// to use a particular distance is to round the cvt "by hand" and then turn off the rounding flag, which is
			// quite what we don't want to do in SubPixel, ie. to enforce an unnatural weight.
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif // RoundOffRespectsCvtCutIn
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else { // !Round
				fxMoveDist = itrp_RoundOffSP (GSA fxMoveDist, fxEngine);
			}
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL
			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else {
				fxMoveDist = itrp_RoundOff (GSA fxMoveDist, fxEngine);
			}
#ifdef FSCFG_SUBPIXEL
		}
#endif
		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}
		if (LocalGS.Project == itrp_XProject) {
			fxPosition = pCE1->x[iPoint] - pCE0->x[iPt0];
		} else if (LocalGS.Project == itrp_YProject) {
			fxPosition = pCE1->y[iPoint] - pCE0->y[iPt0];
		} else {
			fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPoint] - pCE0->x[iPt0], pCE1->y[iPoint] - pCE0->y[iPt0]);
		}

		(*LocalGS.MovePoint) (GSA pCE1, iPoint, fxMoveDist - fxPosition);
	
	} else if (LocalGS.MIRPCode == MIRPX) {        /********* MIRPX *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];  /* x direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->x[iPoint] = fxMoveDist + pCE0->x[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= XMOVED;
	
	} else { /* if (LocalGS.MIRPCode == MIRPY) */  /********* MIRPY *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];  /* y direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->y[iPoint] = fxMoveDist + pCE0->y[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= YMOVED;
	}
	
	if (BIT4 (lOpCode)) {
		LocalGS.Pt0 = iPoint;                   /* move the reference point */
	}
	return pbyInst;
} // itrp_MIRP

/**************************************************************************/

/*
 * CALL a function
 */
FS_PRIVATE uint8* itrp_CALL (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 *pbySubroutine;
	fnt_GlobalGraphicStateType *globalGS;
	int32 arg;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	uint8 patchedStore22 = false;
	F26Dot6 store22;
#endif
#ifdef BypassJellesSpacing
	uint8 patchedStore24 = false;
	F26Dot6 store24;
#endif
#ifdef AssistTomsDiagonal
	uint8 assistTomsDiagonal = false;
	F26Dot6 cvtCI = 0;
#endif
#ifdef InlineDeltasOnly
	uint16 i;
	uint8 inSkippableDeltaFn = false;
#endif
#endif

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);

	CHECK_PROGRAM (funcDef->pgmIndex);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);
	funcDef = &globalGS->funcDef[ arg ];

 	SECURE_CHECK_PROGRAM (funcDef->pgmIndex);

	pbySubroutine = globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (pbySubroutine != 0);

	pbySubroutine += funcDef->start;
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;        /* save for parent */

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	// here we're assuming that fns 64 through 66 are support functions for the TMT D/IStroke commands, which may make strokes collapse in SubPixel.
	// To determine whether we've actually run into the context of these fns, we look at the first couple of bytes only, as the exact implementation
	// of these functions may have changed over time, but hopefully, the preamble (to look at storage #22) hasn't. The easiest way to by-pass these
	// fns is to flag storage #22 with 0, indicating not to use D/IStrokes, else we'd have to cleanup the stack.
	// Admittedly a bit of a hack. If anybody can think of a "better bandaid", I'll be happy to consider it.
	//    The reason, by the way, why DStroke doesn't work, is the following. DStroke brings pairs of points to the same y (or x), MIRP[m<rBl] the
	// floating point, and the moves it back to the old y (or x). Now that we re-interpret little r, cvt cut in actually gets to cut in, the original
	// distance gets to apply, just that the original distance is taken prior to bringing points to same y (or x), meaning it's likely to be WAY off.
	// As a result, the diagonal stroke weight (in x) starts to depend heavily on the distance (in y) of the control points involved, which obviously
	// is not what we want. Notice that for non-square aspect ratios, the DStroke is a NOP, therefore was a NOP with 16x SubPixel, and hence we're
	// not doing any major harm by skipping it in SubPixel.
	if (64 <= arg && arg <= 66 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedDandIStroke) > 0) {
		store22 = LocalGS.globalGS->store[22];
		LocalGS.globalGS->store[22] = 0;
		patchedStore22 = true;
	}
#endif
#ifdef BypassJellesSpacing
	// here we're assuming that fns 0, 1, 2, 4, 7, and 8 are support functions for Monotype's Jelle Bosma's spacing functions, which may squish
	// characters or pull them left or right or in both directions at the same time. This has to do amongst other with using the twilight zone.
	// The spacing algorithm is meant to be turned off above a certain size, such as 30 ppem, hence we may argue that with the extra virtual re-
	// solution we should turn it off at a considerably smaller ppem size, or altogether. From there the logic is like bypassing D/IStroke.
	// (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedJellesSpacing) > 0) {
		store24 = LocalGS.globalGS->store[24];
		LocalGS.globalGS->store[24] = 0;
		patchedStore24 = true;
	}
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedTomsDiagonal) > 0) {
		cvtCI = LocalGS.globalGS->localParBlock.wTCI;
		LocalGS.globalGS->localParBlock.wTCI = 0x7fffffff;
		assistTomsDiagonal = true;
	}
#endif
#ifdef InlineDeltasOnly
	for (i = 0; i < LocalGS.globalGS->numDeltaFunctionsDetected && LocalGS.globalGS->deltaFunction[i] != (uint16)arg; i++);
	if (i < LocalGS.globalGS->numDeltaFunctionsDetected && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS)) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inSkippableDeltaFn;
		inSkippableDeltaFn = true;
	}
#endif
#endif


	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
	LocalGS.Interpreter (GSA pbySubroutine, pbySubroutine + funcDef->length);   /* recursion */
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
	if (inSkippableDeltaFn) {
		LocalGS.globalGS->subPixelCompatibilityFlags &= ~SPCF_inSkippableDeltaFn;
	}
#endif
#ifdef AssistTomsDiagonal
	if (assistTomsDiagonal) {
		LocalGS.globalGS->localParBlock.wTCI = cvtCI;
	}
#endif
#ifdef BypassJellesSpacing
	if (patchedStore24) {
		LocalGS.globalGS->store[24] = store24;
	}
#endif
#ifdef BypassDandIStroke
	if (patchedStore22) {
		LocalGS.globalGS->store[22] = store22;
	}
#endif
#endif

	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
			
	return pbyInst;
}

/**************************************************************************/

/*
 * Function DEFinition
 */
FS_PRIVATE uint8* itrp_FDEF (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 * program, *funcStart;
	static const uint8 funcFragment[8][16] ={
								{0x01,0x20,0xB0,0x03,0x25},				// SVTCA[X] DUP[] #PUSH 3 CINDEX[] (DiagEndCtrl)
								{0xB0,0x16,0x43,0x58},					// #PUSH 22 RS[] IF[] (D/IStroke)
								{0x01,0xB0,0x18,0x43,0x58},				// SVTCA[X] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #1)
								{0x01,0x18,0xB0,0x18,0x43,0x58},		// SVTCA[X] RTG[] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #2)
								{0x45,0x23,0x46,0x60,0x20,0xB0,0x26},	// RCVT[] SWAP[] GC[N] ADD[] DUP[] #PUSH 38 (VacuFormRound)
								{0x20,0x20,0xB0,0x01,0x60,0x46,0xB0,0x40,0x23,0x42}, // DUP[] DUP[] #PUSH[] 1 ADD[] GC[N] #PUSH[] 64 SWAP[] WS[] (Tom's Diagonal)
								{0x4B,0x53,0x23,0x4B,0x51,0x5A,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}, // MPPEM[] GTEQ[] SWAP[] MPPEM[] LTEQ[] AND[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Range of deltas)
								{0x4B,0x54,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}}; // MPPEM[] EQ[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Delta)

	// extend here for two variants of delta fn

	fnt_GlobalGraphicStateType * globalGS;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	if (LocalGS.globalGS->pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = FDEF_IN_GLYPHPGM_ERR;  /* returned to client, error FDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	funcDef = &globalGS->funcDef[ arg ];
	program = globalGS->pgmList[ funcDef->pgmIndex = LocalGS.globalGS->pgmIndex ].Instruction;

	CHECK_PROGRAM (funcDef->pgmIndex);
	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (globalGS->pgmList[funcDef->pgmIndex].Instruction != 0);

	funcDef->start = (int32)(pbyInst - program);

	funcStart = pbyInst;

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	if (64 <= arg && arg <= 66 && memcmp(funcStart,funcFragment[1],4) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedDandIStroke;
#endif
#ifdef BypassJellesSpacing // (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && (memcmp(funcStart,funcFragment[2],5) == 0 || memcmp(funcStart,funcFragment[3],6) == 0))
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedJellesSpacing;
#endif
#ifdef BypassVacuformRound
	if (arg == 0 && memcmp(funcStart,funcFragment[4],7) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedVacuformRound;
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && memcmp(funcStart,funcFragment[5],10) == 0) 
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedTomsDiagonal;
#endif
#ifdef InlineDeltasOnly
	if (*funcStart == funcFragment[6][0] && (memcmp(funcStart,funcFragment[7],9) == 0 || memcmp(funcStart,funcFragment[6],13) == 0) && LocalGS.globalGS->numDeltaFunctionsDetected < maxDeltaFunctions)
		LocalGS.globalGS->deltaFunction[LocalGS.globalGS->numDeltaFunctionsDetected++] = (uint16)arg;
	// if we have too many delta fns, we'll end up executing a delta fn; this may not look optimal, but we don't expect to get to this point in the first place.
#endif
#endif
	while ( ((*pbyInst++) != ENDF_CODE)  && (pbyInst < LocalGS.pbyEndInst) )
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	funcDef->length = (uint16)(pbyInst - funcStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * LOOP while CALLing a function
 */
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM)
{
	uint8 *start, *stop;
	InterpreterFunc Interpreter;
	fnt_funcDef *funcDef;
	int32 arg;
	int32 loop;
	uint8 * ins;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	funcDef = & (LocalGS.globalGS->funcDef[ arg ]);
	{
		SECURE_CHECK_PROGRAM (funcDef->pgmIndex);
		CHECK_PROGRAM (funcDef->pgmIndex);
		ins = LocalGS.globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

		start = &ins[funcDef->start];
		stop = &ins[funcDef->start + funcDef->length];  /* funcDef->end -> funcDef->length <4> */
	}
	Interpreter = LocalGS.Interpreter;
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	CHECK_LARGER (-1L, arg);
	loop = (int32)arg;
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}

	for (--loop; ((loop >= 0) && (LocalGS.ercReturn == NO_ERR)); --loop)
	{
		Interpreter (GSA start, stop);
	}
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      This guy returns the index of the given opCode, or 0 if not found <4>
 */
FS_PRIVATE fnt_instrDef *itrp_FindIDef (GSP uint8 opCode)
{
	fnt_GlobalGraphicStateType *globalGS;
	int32 count;
	fnt_instrDef*instrDef;
	
	globalGS = LocalGS.globalGS;
	count = globalGS->instrDefCount;
	instrDef = globalGS->instrDef;
		
	for (--count; count >= 0; instrDef++, --count)
	{
		if (instrDef->opCode == opCode)
		{
			return instrDef;
		}
	}
	return 0;
}

/**************************************************************************/

/*
 *      This guy gets called for opCodes that has been patch by the font's IDEF <4>
 *      or if they have never been defined.  If there is no corresponding IDEF,
 *      flag it as an illegal instruction.
 */
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM)
{
	fnt_instrDef *instrDef;
	uint8 *program;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	
	instrDef = itrp_FindIDef (GSA (uint8)lOpCode);
	if (instrDef == 0)
	{
		return itrp_IllegalInstruction (GSA pbyInst, lOpCode);
	}
	else
	{
		SECURE_CHECK_PROGRAM (instrDef->pgmIndex);
		CHECK_PROGRAM (instrDef->pgmIndex);
		program = LocalGS.globalGS->pgmList[ instrDef->pgmIndex ].Instruction;
		program += instrDef->start;
		
		LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
		if (LocalGS.ulRecursiveCall == 0)
		{
			LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}

		LocalGS.Interpreter (GSA program, program + instrDef->length);
	
		LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */

		LocalGS.pbyEndInst = pbyEndInst;    /* restore for parent */
		LocalGS.pbyStartInst = pbyStartInst;/* restore for parent */
		
		if (LocalGS.ercReturn != NO_ERR)    /* if illegal inst has been hit */
		{
			return pbyEndInst;              /* exit parent's loop */
		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 * Instruction DEFinition       <4>
 */
FS_PRIVATE uint8* itrp_IDEF (IPARAM)
{
	int32 arg;
	uint8 opCode;
	fnt_instrDef *instrDef;
	int32 pgmIndex;
	uint8 * program;
	uint8 * instrStart;

	FS_UNUSED_PARAMETER(lOpCode);

	pgmIndex = (int32)LocalGS.globalGS->pgmIndex;

	if (pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = IDEF_IN_GLYPHPGM_ERR;  /* returned to client, error IDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	program = LocalGS.globalGS->pgmList[ pgmIndex ].Instruction;
	instrStart = pbyInst;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_IDEF_OPCODE(arg);
    CHECK_INT8 (arg);
	opCode = (uint8)arg;
	CHECK_PROGRAM (pgmIndex);

	instrDef = itrp_FindIDef (GSA opCode);
	if (!instrDef)
	{
        SECURE_CHECK_IDEF_OVERFLOW();
		instrDef = LocalGS.globalGS->instrDef + LocalGS.globalGS->instrDefCount++;
	}

	instrDef->pgmIndex = (uint8) pgmIndex;
	instrDef->opCode = opCode;          /* this may or may not have been set */
	instrDef->start = (int32)(pbyInst - program);

	while (((*pbyInst++) != ENDF_CODE) && (pbyInst < LocalGS.pbyEndInst))
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	instrDef->length = (uint16)(pbyInst - instrStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * UnTouch Point
 */
  FS_PRIVATE uint8* itrp_UTP (IPARAM)
  {
	uint8*f = LocalGS.CE0->f;
	int32 point;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	point = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, point);
	CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	if (LocalGS.free.x)
	{
	  f[point] &= ~XMOVED;
	}
	if (LocalGS.free.y)
	{
	  f[point] &= ~YMOVED;
	}
	return pbyInst;
  }

/*
 * Set Delta Base
 */
  FS_PRIVATE uint8* itrp_SDB (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaBase = (int16)arg;
	return pbyInst;
  }

/*
 * Set Delta Shift
 */
  FS_PRIVATE uint8* itrp_SDS (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaShift = (int16)arg;
	return pbyInst;
  }

/**************************************************************************/

/*
 * DeltaEngine, internal support routine
 */
FS_PRIVATE uint8*  itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 sBase, int16 sShift)
{
	int32 iRange;
	int32 iAim;
	int32 iHigh;
	int32 iFakePPEM;
	int32 iPPEM;
	F26Dot6 fxDelta;

		/* Find the beginning of data pairs for this particular size */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iHigh = CHECK_POP (LocalGS.stackPointer) << 1;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, iHigh);
	LocalGS.stackPointer -= iHigh;              /* -= number of pops required */
	CHECK_STACK (&LocalGS);

	iRange = LocalGS.globalGS->pixelsPerEm;     /* same as itrp_MPPEM () */
	if (!LocalGS.globalGS->bSameStretch)
		iRange = (int32)FixMul(iRange, itrp_GetCVTScale (GSA0));
	iFakePPEM = iRange - (int32)sBase;

	if ((iFakePPEM >= 16) || (iFakePPEM < 0))
	{
		return pbyInst;                                 /* Not within exception range */
	}
	iFakePPEM = iFakePPEM << 4;

	iAim = 0;
	iRange = iHigh >> 1; 
	iRange &= ~1;
	while (iRange > 2)                          /* binary search for first data */
	{
		iPPEM = LocalGS.stackPointer[ iAim + iRange ]; /* [ iPPEM << 4 | exception ] */
		if ((iPPEM & ~0x0f) < iFakePPEM) 
		{
			iAim += iRange;                     /* approach the starting point */
		}
		iRange >>= 1; 
		iRange &= ~1;                           /* iRange must stay even */
	}

	while (iAim < iHigh) 
	{
		iPPEM = LocalGS.stackPointer[ iAim ];   /* [ iPPEM << 4 | exception ] */
		fxDelta = iPPEM & ~0x0f;
		if (fxDelta == iFakePPEM)
		{                                       /* We found an exception, go ahead and apply it */
			fxDelta = iPPEM & 0xf;              /* 0 ... 15 */
			fxDelta -= fxDelta >= 8 ? 7 : 8;    /* -8 ... -1, 1 ... 8 */
			fxDelta <<= FNT_PIXELSHIFT;        /* convert to pixels */
			fxDelta >>= sShift;                 /* scale to right size */
            
#ifdef FSCFG_SECURE
            if (doIt == LocalGS.MovePoint)
            {
                SECURE_CHECK_POINT(LocalGS.CE0,(int32)LocalGS.stackPointer[iAim+1]);
            } else
			{
				FS_ASSERT( (doIt == LocalGS.ChangeCvt), "itrp_DeltaEngine called with wrong doIt.")
                SECURE_CHECK_CVT((int32)LocalGS.stackPointer[iAim+1]);
			}
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// similar to itrp_SHP_Common above
		// main difference: we don't distinguish between SHPIX and SHP, but between CVT deltas and ordinary deltas
			if (doIt == LocalGS.ChangeCvt || !RunningSubPixel(LocalGS.globalGS) || Tuned4SubPixel(LocalGS.globalGS) || AMovedPointInNonSPDirection(LocalGS,CE0,(int16)LocalGS.stackPointer[iAim+1]))
#endif
#endif
				doIt (GSA LocalGS.CE0, (int32)LocalGS.stackPointer[iAim+1], (F26Dot6) fxDelta);
		} 
		else if (fxDelta > iFakePPEM)
		{
			break;                              /* we passed the data */
		}
		iAim += 2;
	}
    return pbyInst;
}

/**************************************************************************/

/*
 * DELTAP1
 */
  FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAP2
 */
  FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAP3
 */
  FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAC1
 */
  FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAC2
 */
  FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }

/*
 * DELTAC3
 */
  FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }


#ifdef FSCFG_NO_INITIALIZED_DATA
	
	void itrp_InitializeData (void)
	{
		int32 i;

		/***** 0x00 - 0x0f *****/
		function[0x00] = itrp_SVTCA_0;
		function[0x01] = itrp_SVTCA_1;
		function[0x02] = itrp_SPVTCA_0;
		function[0x03] = itrp_SPVTCA_1;
		function[0x04] = itrp_SFVTCA_0;
		function[0x05] = itrp_SFVTCA_1;
		function[0x06] = itrp_SPVTL;
		function[0x07] = itrp_SPVTL;
		function[0x08] = itrp_SFVTL;
		function[0x09] = itrp_SFVTL;
		function[0x0A] = itrp_WPV;
		function[0x0B] = itrp_WFV;
		function[0x0C] = itrp_RPV;
		function[0x0D] = itrp_RFV;
		function[0x0E] = itrp_SFVTPV;
		function[0x0F] = itrp_ISECT;

		/***** 0x10 - 0x1f *****/
		function[0x10] = itrp_SRP0;
		function[0x11] = itrp_SRP1;
		function[0x12] = itrp_SRP2;
		function[0x13] = itrp_SetElementPtr;
		function[0x14] = itrp_SetElementPtr;
		function[0x15] = itrp_SetElementPtr;
		function[0x16] = itrp_SetElementPtr;
		function[0x17] = itrp_LLOOP;
		function[0x18] = itrp_RTG;
		function[0x19] = itrp_RTHG;
		function[0x1A] = itrp_LMD;
		function[0x1B] = itrp_ELSE;
		function[0x1C] = itrp_JMPR;
		function[0x1D] = itrp_LWTCI;
		function[0x1E] = itrp_LSWCI;
		function[0x1F] = itrp_LSW;

		/***** 0x20 - 0x2f *****/
		function[0x20] = itrp_DUP;
		function[0x21] = itrp_POP;
		function[0x22] = itrp_CLEAR;
		function[0x23] = itrp_SWAP;
		function[0x24] = itrp_DEPTH;
		function[0x25] = itrp_CINDEX;
		function[0x26] = itrp_MINDEX;
		function[0x27] = itrp_ALIGNPTS;
		function[0x28] = itrp_RAW;
		function[0x29] = itrp_UTP;
		function[0x2A] = itrp_LOOPCALL;
		function[0x2B] = itrp_CALL;
		function[0x2C] = itrp_FDEF;
		function[0x2D] = itrp_IllegalInstruction;
		function[0x2E] = itrp_MDAP;
		function[0x2F] = itrp_MDAP;

		/***** 0x30 - 0x3f *****/
		function[0x30] = itrp_IUP;
		function[0x31] = itrp_IUP;
		function[0x32] = itrp_SHP;
		function[0x33] = itrp_SHP;
		function[0x34] = itrp_SHC;
		function[0x35] = itrp_SHC;
		function[0x36] = itrp_SHE;
		function[0x37] = itrp_SHE;
		function[0x38] = itrp_SHPIX;
		function[0x39] = itrp_IP;
		function[0x3A] = itrp_MSIRP;
		function[0x3B] = itrp_MSIRP;
		function[0x3C] = itrp_ALIGNRP;
		function[0x3D] = itrp_RTDG;
		function[0x3E] = itrp_MIAP;
		function[0x3F] = itrp_MIAP;

		/***** 0x40 - 0x4f *****/
		function[0x40] = itrp_NPUSHB;
		function[0x41] = itrp_NPUSHW;
		function[0x42] = itrp_WS;
		function[0x43] = itrp_RS;
		function[0x44] = itrp_WCVT;
		function[0x45] = itrp_RCVT;
		function[0x46] = itrp_RC;
		function[0x47] = itrp_RC;
		function[0x48] = itrp_WC;
		function[0x49] = itrp_MD;
		function[0x4A] = itrp_MD;
		function[0x4B] = itrp_MPPEM;
		function[0x4C] = itrp_MPS;
		function[0x4D] = itrp_FLIPON;
		function[0x4E] = itrp_FLIPOFF;
		function[0x4F] = itrp_DEBUG;

		/***** 0x50 - 0x5f *****/
		function[0x50] = itrp_LT;
		function[0x51] = itrp_LTEQ;
		function[0x52] = itrp_GT;
		function[0x53] = itrp_GTEQ;
		function[0x54] = itrp_EQ;
		function[0x55] = itrp_NEQ;
		function[0x56] = itrp_ODD;
		function[0x57] = itrp_EVEN;
		function[0x58] = itrp_IF;
		function[0x59] = itrp_EIF;
		function[0x5A] = itrp_AND;
		function[0x5B] = itrp_OR;
		function[0x5C] = itrp_NOT;
		function[0x5D] = itrp_DELTAP1;
		function[0x5E] = itrp_SDB;
		function[0x5F] = itrp_SDS;

		/***** 0x60 - 0x6f *****/
		function[0x60] = itrp_ADD;
		function[0x61] = itrp_SUB;
		function[0x62] = itrp_DIV;
		function[0x63] = itrp_MUL;
		function[0x64] = itrp_ABS;
		function[0x65] = itrp_NEG;
		function[0x66] = itrp_FLOOR;
		function[0x67] = itrp_CEILING;
		function[0x68] = itrp_ROUND;
		function[0x69] = itrp_ROUND;
		function[0x6A] = itrp_ROUND;
		function[0x6B] = itrp_ROUND;
		function[0x6C] = itrp_NROUND;
		function[0x6D] = itrp_NROUND;
		function[0x6E] = itrp_NROUND;
		function[0x6F] = itrp_NROUND;

		/***** 0x70 - 0x7f *****/
		function[0x70] = itrp_WCVTFOD;
		function[0x71] = itrp_DELTAP2;
		function[0x72] = itrp_DELTAP3;
		function[0x73] = itrp_DELTAC1;
		function[0x74] = itrp_DELTAC2;
		function[0x75] = itrp_DELTAC3;
		function[0x76] = itrp_SROUND;
		function[0x77] = itrp_S45ROUND;
		function[0x78] = itrp_JROT;
		function[0x79] = itrp_JROF;
		function[0x7A] = itrp_ROFF;
		function[0x7B] = itrp_IllegalInstruction;
		function[0x7C] = itrp_RUTG;
		function[0x7D] = itrp_RDTG;
		function[0x7E] = itrp_SANGW;
		function[0x7F] = itrp_AA;

		/***** 0x80 - 0x8d *****/
		function[0x80] = itrp_FLIPPT;
		function[0x81] = itrp_FLIPRGON;
		function[0x82] = itrp_FLIPRGOFF;
		function[0x83] = itrp_IDefPatch;
		function[0x84] = itrp_IDefPatch;
		function[0x85] = itrp_SCANCTRL;
		function[0x86] = itrp_SDPVTL;
		function[0x87] = itrp_SDPVTL;
		function[0x88] = itrp_GETINFO;
		function[0x89] = itrp_IDEF;
		function[0x8A] = itrp_ROTATE;
		function[0x8B] = itrp_MAX;
		function[0x8C] = itrp_MIN;
		function[0x8D] = itrp_SCANTYPE;
		function[0x8E] = itrp_INSTCTRL;

		/***** 0x8f - 0xaf *****/
		for ( i = 0x8F; i <= 0xAF;  ++i )
			function[i] = itrp_IDefPatch;

		/***** 0xb0 - 0xb7 *****/
		function[0xB0] = itrp_PUSHB1;
		function[0xB1] = itrp_PUSHB;
		function[0xB2] = itrp_PUSHB;
		function[0xB3] = itrp_PUSHB;
		function[0xB4] = itrp_PUSHB;
		function[0xB5] = itrp_PUSHB;
		function[0xB6] = itrp_PUSHB;
		function[0xB7] = itrp_PUSHB;

		/***** 0xb8 - 0xbf *****/
		function[0xB8] = itrp_PUSHW1;
		function[0xB9] = itrp_PUSHW;
		function[0xBA] = itrp_PUSHW;
		function[0xBB] = itrp_PUSHW;
		function[0xBC] = itrp_PUSHW;
		function[0xBD] = itrp_PUSHW;
		function[0xBE] = itrp_PUSHW;
		function[0xBF] = itrp_PUSHW;

		/***** 0xc0 - 0xdf *****/
		for ( i = 0xC0; i <= 0xDF;  i++ )
			function[i] = itrp_MDRP;

		/***** 0xe0 - 0xff *****/
		for ( i = 0xE0; i <= 0xFF;  i++ )
			function[i] = itrp_MIRP;
		
#ifdef FSCFG_SUBPIXEL
		// initialize round function table for SP
		itrp_RoundFunction[0][0] = itrp_RoundToDoubleGrid;
		itrp_RoundFunction[0][1] = itrp_RoundDownToGrid;
		itrp_RoundFunction[0][2] = itrp_RoundUpToGrid;
		itrp_RoundFunction[0][3] = itrp_RoundToGrid;
		itrp_RoundFunction[0][4] = itrp_RoundToHalfGrid;
		itrp_RoundFunction[0][5] = itrp_RoundOff;
		itrp_RoundFunction[0][6] = itrp_SuperRound;
		itrp_RoundFunction[0][7] = itrp_Super45Round;
		itrp_RoundFunction[1][0] = itrp_RoundToDoubleGridSP;
		itrp_RoundFunction[1][1] = itrp_RoundDownToGridSP;
		itrp_RoundFunction[1][2] = itrp_RoundUpToGridSP;
		itrp_RoundFunction[1][3] = itrp_RoundToGridSP;
		itrp_RoundFunction[1][4] = itrp_RoundToHalfGridSP;
		itrp_RoundFunction[1][5] = itrp_RoundOffSP;
		itrp_RoundFunction[1][6] = itrp_SuperRound;
		itrp_RoundFunction[1][7] = itrp_Super45Round;
#endif
	}

#endif /* FSCFG_NO_INITIALIZED_DATA */

/* END OF interp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sbit.c ===
/*********************************************************************

      sbit.c -- Embedded Bitmap Module

      (c) Copyright 1993-96  Microsoft Corp.  All rights reserved.

      04/01/96  claudebe    adding support for embedded grayscale bitmap
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/31/95  deanb       memset unrotated bitmap to zero
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      12/21/94  deanb       rotation and vertical metrics support
      08/02/94  deanb       pf26DevLSB->y calculated correctly
      01/05/94  deanb       Bitmap scaling added
      11/29/93  deanb       First cut 
 
**********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for inttodot6 macro */
        
#include    "sfntaccs.h"            /* sfnt access functions */
#include    "sbit.h"                /* own function prototypes */

/**********************************************************************/

#define MAX_BIT_INDEX	8			/* maximum bit index in a byte */

/*  Local structure */

typedef struct
{
    uint8*  pbySrc;                 /* unrotated source bitmap (as read) */
    uint8*  pbyDst;                 /* rotated destination bitmap (as returned) */
    uint16  usSrcBytesPerRow;       /* source bitmap width */
    uint16  usDstBytesPerRow;       /* destination bitmap width */
    uint16  usSrcX;                 /* source horiz pixel index */
    uint16  usSrcY;                 /* destination horiz pixel index */
    uint16  usDstX;                 /* source vert pixel index */
    uint16  usDstY;                 /* destination vert pixel index */
	uint16	usBitDepth;				/* bit depth of source/destination bitmap */
} 
CopyBlock;

/**********************************************************************/

/*  Local prototypes  */

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead, 
    uint8           *pbyExpand 
);

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap );

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
);

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
);

FS_PRIVATE void CopyBit(
    CopyBlock* pcb );

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);



/**********************************************************************/
/***                                                                ***/
/***                       SBIT Functions                           ***/
/***                                                                ***/
/**********************************************************************/

/*  reset sbit state structure to default values */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16		sBoldSimulHorShift,
     int16		sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
	)
{
    pSbit->usPpemX = usPpemX;                       /* save requested ppem */
    pSbit->usPpemY = usPpemY;
    pSbit->usRotation = usRotation;                 /* used later on */

    pSbit->bGlyphFound = FALSE;
    pSbit->usTableState = SBIT_UN_SEARCHED;
    pSbit->usEmResolution = usEmResolution;

    /* with embedded bitmap, the emboldement is done before the rotation */
    pSbit->uBoldSimulHorShift = MABS(sBoldSimulHorShift); 
    pSbit->uBoldSimulVertShift = MABS(sBoldSimulVertShift); 
    if ((pSbit->usRotation == 1) || (pSbit->usRotation == 3))
    {
        /* with embedded bitmap, the emboldement is done before the rotation */
        uint16 temp;
        temp = pSbit->uBoldSimulHorShift;
        pSbit->uBoldSimulHorShift = pSbit->uBoldSimulVertShift;
        pSbit->uBoldSimulVertShift = temp;
    }
    return NO_ERR;
}

/**********************************************************************/

/*  Determine whether a glyph bitmap exists */

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint16          usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode )         /* 0 = not found, 1 = bloc, 2 = bsca */
{    
    ErrorCode   ReturnCode;

    *pusFoundCode = 0;                              /* default */
    if (pSbit->usRotation > 3)
    {
        return NO_ERR;                              /* can't match a general rotation */
    }


    if (pSbit->usTableState == SBIT_UN_SEARCHED)    /* new trans - 1st glyph */
    {
        ReturnCode = sfac_SearchForStrike (         /* look for a strike */
            pClientInfo,
            pSbit->usPpemX, 
            pSbit->usPpemY, 
			usOverScale,            /* outline magnification requested */
			&pSbit->usBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
            &pSbit->usTableState,                   /* may set to BLOC or BSCA */
            &pSbit->usSubPpemX,                     /* if BSCA us this ppem */
            &pSbit->usSubPpemY,
            &pSbit->ulStrikeOffset );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
    }

	*pusBitDepth = pSbit->usBitDepth;

    if ((pSbit->usTableState == SBIT_BLOC_FOUND) || 
        (pSbit->usTableState == SBIT_BSCA_FOUND))
    {
        ReturnCode = sfac_SearchForBitmap (         /* now look for this glyph */
            pClientInfo,
            usGlyphCode,
            pSbit->ulStrikeOffset,
            &pSbit->bGlyphFound,                    /* return values */
            &pSbit->usMetricsType,
            &pSbit->usMetricsTable,
            &pSbit->ulMetricsOffset,
            &pSbit->usBitmapFormat,
            &pSbit->ulBitmapOffset,
            &pSbit->ulBitmapLength );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
        
        if (pSbit->bGlyphFound)
        {
            if (pSbit->usTableState == SBIT_BLOC_FOUND)
            {
                *pusFoundCode = 1;
            }
            else
            {
                *pusFoundCode = 2;
            }
            pSbit->bMetricsValid = FALSE;
        }
    }
    return NO_ERR;
}


/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW )
{
    point       ptDevAdvW;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceWidth */
	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ptDevAdvW.x = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    ptDevAdvW.y = 0L;                           /* always zero for horizontal metrics */

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pf26DevAdvW->x = ptDevAdvW.x;
        pf26DevAdvW->y = ptDevAdvW.y;
		break;
	case 1:                                     /* 90 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.y;
        pf26DevAdvW->y = ptDevAdvW.x;
		break;
	case 2:                                     /* 180 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.x;
        pf26DevAdvW->y = -ptDevAdvW.y;
		break;
	case 3:                                     /* 270 degree rotation */
        pf26DevAdvW->x = ptDevAdvW.y;
        pf26DevAdvW->y = -ptDevAdvW.x;
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

	/* metrics without rotation */
    FS_ASSERT(((pSbit->usRotation == 0) || (pSbit->usRotation == 2)), "sbit_CalcDevHorMetrics called under rotation\n");

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        *pDevAdvanceWidthX = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX - INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	case 2:                                     /* 180 degree rotation */
        *pDevAdvanceWidthX = -INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = -INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX + INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
    

    return NO_ERR;
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH )
{
    point       ptDevAdvH;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceHeight */
	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

/* set x components to zero */

    ptDevAdvH.x = 0L;
    ptDevAdvH.y = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
        
     switch(pSbit->usRotation)                   /* handle 90 degree rotations */
    {
    case 0:                                     /* no rotation */
           pf26DevAdvH->x = ptDevAdvH.x;
           pf26DevAdvH->y = ptDevAdvH.y;
    	break;
    case 1:                                     /* 90 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.y;
           pf26DevAdvH->y = ptDevAdvH.x;
    	break;
    case 2:                                     /* 180 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.x;
           pf26DevAdvH->y = -ptDevAdvH.y;
    	break;
    case 3:                                     /* 270 degree rotation */
           pf26DevAdvH->x = ptDevAdvH.y;
           pf26DevAdvH->y = -ptDevAdvH.x;
    	break;
    default:                                    /* non 90 degree rotation */
    	return SBIT_ROTATION_ERR;
    }
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW,
    point           *pf26DevLSB,
    point           *pf26LSB,
    point           *pf26DevAdvH, 	/* NEW */
    point           *pf26DevTopSB,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize )
{
    ErrorCode   ReturnCode;
    uint32      ulOrgMemSize;               /* size of unscaled bitmap */
    uint32      ulExpMemSize;               /* size of unscaled bitmap after gray expansion */
    uint32      ulScaMemSize;               /* size of scaled bitmap */
    uint32      ulMaxMemSize;               /* size of larger of scaled, unscaled */
    
    F26Dot6     f26DevAdvWx;                /* unrotated metrics */
    F26Dot6     f26DevAdvWy;
    F26Dot6     f26DevLSBx;
    F26Dot6     f26DevLSBy;
    F26Dot6     f26DevAdvHx;                /* unrotated metrics */
    F26Dot6     f26DevAdvHy;
    F26Dot6     f26DevTopSBx;
    F26Dot6     f26DevTopSBy;
    int16       sTop;                       /* unrotated bounds */
    int16       sLeft;
    int16       sBottom;
    int16       sRight;
	uint16		usOutBitDepth;				/* number of bit per pixel in the output */

	if (pSbit->usBitDepth == 1)
	{
		usOutBitDepth = 1;
	} else {
		usOutBitDepth = 8;
	}

    ReturnCode = GetSbitMetrics(pSbit, pClientInfo);
    if (ReturnCode != NO_ERR) return ReturnCode;
    
    pSbit->usScaledWidth = UScaleX(pSbit, pSbit->usWidth);
    pSbit->usScaledHeight = UScaleY(pSbit, pSbit->usHeight);


    
    sTop = SScaleY(pSbit, pSbit->sLSBearingY);            /* calc scaled metrics */
    sLeft = SScaleX(pSbit, pSbit->sLSBearingX);
    sBottom = sTop - (int16)pSbit->usScaledHeight;
    sRight = sLeft + (int16)pSbit->usScaledWidth;

    f26DevAdvWx = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    f26DevAdvWy = 0L;                   /* always zero for horizontal metrics */
    f26DevAdvHx = 0L;                   /* always zero for vertical metrics */
    f26DevAdvHy = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
    f26DevLSBx = INTTODOT6(SScaleX(pSbit, pSbit->sLSBearingX));
    f26DevLSBy = INTTODOT6(SScaleY(pSbit, pSbit->sLSBearingY));
    f26DevTopSBx = INTTODOT6(SScaleX(pSbit, pSbit->sTopSBearingX));
    f26DevTopSBy = INTTODOT6(SScaleY(pSbit, pSbit->sTopSBearingY));

    pSbit->usOriginalRowBytes = ROWBYTESLONG(pSbit->usWidth * pSbit->usBitDepth);   /* keep unscaled */
    pSbit->usExpandedRowBytes = ROWBYTESLONG(pSbit->usWidth * usOutBitDepth);   /* keep unscaled */
    pSbit->usScaledRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);

	pSbit->ulReadMemSize = 0; /* size of extra memory, to read gray sbit under scaling or rotation */

    ulOrgMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usOriginalRowBytes;
    ulExpMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usExpandedRowBytes;
    ulScaMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usScaledRowBytes;
    if (ulExpMemSize >= ulScaMemSize)
    {
         ulMaxMemSize = ulExpMemSize;
    }
    else
    {
         ulMaxMemSize = ulScaMemSize;
    }

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pRect->top = sTop;                      /* return scaled metrics */
        pRect->left = sLeft;
        pRect->bottom = sBottom;
        pRect->right = sRight;

        pf26DevAdvW->x = f26DevAdvWx;
        pf26DevAdvW->y = f26DevAdvWy;
        pf26DevLSB->x = f26DevLSBx;
        pf26DevLSB->y = f26DevLSBy;
        pf26LSB->x = f26DevLSBx;
        pf26LSB->y = INTTODOT6(sTop);

        pf26DevAdvH->x = f26DevAdvHx;
        pf26DevAdvH->y = f26DevAdvHy;
        pf26DevTopSB->x = f26DevTopSBx;
        pf26DevTopSB->y = f26DevTopSBy;
        pf26TopSB->x = f26DevTopSBx;
        pf26TopSB->y = f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;

        if ((pSbit->usTableState == SBIT_BSCA_FOUND) || (pSbit->usBitDepth != 1))
        {
            pSbit->ulWorkMemSize = ulMaxMemSize;  /* room to read & scale or expand gray pixels */
			if (pSbit->usBitDepth != 1)
			{
				pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
				pSbit->ulReadMemSize = ulOrgMemSize;
			}
        }
        else
        {
            pSbit->ulWorkMemSize = 0L;
        }
		break;
	case 1:                                     /* 90 degree rotation */
        pRect->top = sRight;
        pRect->left = -sTop;
        pRect->bottom = sLeft;
        pRect->right = -sBottom;
        
        pf26DevAdvW->x = -f26DevAdvWy;
        pf26DevAdvW->y = f26DevAdvWx;
        pf26DevLSB->x = -f26DevLSBy;
        pf26DevLSB->y = f26DevLSBx + INTTODOT6(sRight - sLeft);
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(sRight) - f26DevLSBx;

        pf26DevAdvH->x = -f26DevAdvHy;
        pf26DevAdvH->y = f26DevAdvHx;
        pf26DevTopSB->x = -f26DevTopSBy;
        pf26DevTopSB->y = f26DevTopSBx + INTTODOT6(sRight - sLeft);

        pf26TopSB->x = INTTODOT6(-sTop) - f26DevTopSBy; 
        pf26TopSB->y = 0L; 	

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes; 
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 2:                                     /* 180 degree rotation */
        pRect->top = -sBottom;
        pRect->left = -sRight;
        pRect->bottom = -sTop;
        pRect->right = -sLeft;

        pf26DevAdvW->x = -f26DevAdvWx;
        pf26DevAdvW->y = -f26DevAdvWy;
        pf26DevLSB->x = -f26DevLSBx + INTTODOT6(sLeft - sRight);
        pf26DevLSB->y = -f26DevLSBy + INTTODOT6(sTop - sBottom);
        pf26LSB->x = -f26DevLSBx;
        pf26LSB->y = INTTODOT6(-sBottom);

        pf26DevAdvH->x = -f26DevAdvHx;
        pf26DevAdvH->y = -f26DevAdvHy;
        pf26DevTopSB->x = -f26DevTopSBx + INTTODOT6(sLeft - sRight);
        pf26DevTopSB->y = -f26DevTopSBy + INTTODOT6(sTop - sBottom);

		pf26TopSB->x = INTTODOT6(-sRight);	
        pf26TopSB->y = -f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 3:                                     /* 270 degree rotation */
        pRect->top = -sLeft;
        pRect->left = sBottom;
        pRect->bottom = -sRight;
        pRect->right = sTop;
        
        pf26DevAdvW->x = f26DevAdvWy;
        pf26DevAdvW->y = -f26DevAdvWx;
        pf26DevLSB->x = f26DevLSBy + INTTODOT6(sBottom - sTop);
        pf26DevLSB->y = -f26DevLSBx;
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(-sLeft) + f26DevLSBx;

        pf26DevAdvH->x = f26DevAdvHy;
        pf26DevAdvH->y = -f26DevAdvHx;
        pf26DevTopSB->x = f26DevTopSBy + INTTODOT6(sBottom - sTop);
        pf26DevTopSB->y = -f26DevTopSBx;

        pf26TopSB->x = INTTODOT6(sBottom) -INTTODOT6(sTop) -INTTODOT6(sTop) + f26DevTopSBy;
        pf26TopSB->y = 0L;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
        
    *pusRowBytes = pSbit->usOutRowBytes;
    *pulOutSize = pSbit->ulOutMemSize;          /* return mem requirement */
    *pulWorkSize = pSbit->ulWorkMemSize;
    return NO_ERR;
}

/******************************Public*Routine******************************\
*
* sbit_Embolden adapted from vTtfdEmboldenX
*
* Does emboldening in the x direction
*
* History:
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  24-Jun-1997 -by- Bodin Dresevic [BodinD]
* Stole from YungT
\**************************************************************************/

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)

/* embold only one pixel in the x direction */
#define DXABSBOLD 1

// array of masks for the last byte in a row

static uint8 gjMaskLeft[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static uint8 gjMaskRight[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1f, 0X3f, 0X7f };

//FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8   *pCur, *pyCur, *pyCurEnd, *pAdd, newByte;	

    uint8    beginMask, endMask;
    int32    i, j;
    int32    noOfValidBitsAtEndBold;
    int32    noOfValidBitsAtEndNormal;
    int32    noOfBytesForOneLineNormal;
    int32    noOfBytesForOneLineBold;
    int32   nBytesMore;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	// we want to embolden by sBoldSimulHorShift pixels horizontally(if sBoldSimulHorShift>0 then to the right; else to the left) along the base line 
    // and by sBoldSimulVertShift vertically(if sBoldSimulVertShift>0 then to the bottom; else to the top) )

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}


    noOfValidBitsAtEndBold = usBitmapWidth & 7; // styoo: same as noOfValidBitsAtEndBold = usBitmapWidth % 8

    // Before emboldening,the origninal image had scans of width
    // usBitmapWidth - sBoldSimulHorShift.

    noOfBytesForOneLineBold = CJ_MONOCHROME_SCAN(usBitmapWidth);
    if( sBoldSimulHorShift >= 0 ){
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - sBoldSimulHorShift);
        noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }
    else{
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - (-sBoldSimulHorShift));
        noOfValidBitsAtEndNormal = (usBitmapWidth - (-sBoldSimulHorShift)) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

//=============================================================================================================
	//Horizontal To Right
    if( sBoldSimulHorShift > 0){
        endMask = gjMaskLeft[noOfValidBitsAtEndNormal];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/
            

            pCur = &pyCur[noOfBytesForOneLineNormal - 1];
            *pCur &= endMask;

            pCur++;
            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = &pyCur[noOfBytesForOneLineBold - 1];

            while( pCur >= pyCur)
            {
                newByte = *pCur;
                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is 8, we need to borrow 2 bytes(current byte(0) and previous byte(-1))
                // if if sBoldSimulHorShift is 9, we need to borrow 3 bytes(current byte(0) and 2 previous bytes(-1,-2)
                nBytesMore = (sBoldSimulHorShift+7)/8;

                for(i = 1; i <= sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur-j < pyCur then out of bound
                        if(pCur-j < pyCur)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[-j] >> (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[-j] << (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur--;
            }

        // Special implementation for the last byte, styoo: don't need to borrow from previous byte

        }
    }

    //Horizontal To Left
    else if( sBoldSimulHorShift < 0){
        beginMask = gjMaskRight[8-(-sBoldSimulHorShift)];
        endMask = gjMaskLeft[noOfValidBitsAtEndBold];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
            *pCur &= beginMask;

            pCur = &pyCur[noOfBytesForOneLineBold-1];
            *pCur &= endMask;
            pCur++;

            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = pyCur;
            pyCurEnd = pyCur+(noOfBytesForOneLineBold-1);

            while( pCur <= pyCurEnd)
            {
                newByte = *pCur;

                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is -8, we need to borrow 2 bytes(current byte(0) and next byte(+1))
                // if if sBoldSimulHorShift is -9, we need to borrow 3 bytes(current byte(0) and 2 next bytes(+1,+2)
                nBytesMore = (-sBoldSimulHorShift+7)/8;

                for(i = 1; i <= -sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur+j > pyCur+usRowBytes then out of bound
                        if(pCur+j > pyCurEnd)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[j] << (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[j] >> (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur++;
            }

            // Special implementation for the last byte, styoo: don't need to borrow from previous byte


        }
    }
    // Vertical To the Bottom
	if( sBoldSimulVertShift > 0 ){
		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }

        //
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur -= usRowBytes;
		}

	}
    // Vertical To the Top
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur += usRowBytes;
		}
	}
}

/******************************Public*Routine******************************\
* sbit_EmboldenGray adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 newPix;
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels

            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur )
                    {
					  newPix += *(pCur-i);
                      if (newPix >= usGrayLevels){
                          newPix = (uint8)(usGrayLevels -1);
                          break;
                      }
                    }
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the leftt edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
				    if( (pCur+i) < pyCur+usBitmapWidth )
                    {
					    newPix += *(pCur+i);
                        if (newPix >= usGrayLevels){
                            newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
			    }


                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}

    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}
}

#ifdef FSCFG_SUBPIXEL

#define MAX(a,b)    ((a) > (b) ? (a) : (b))

/******************************Public*Routine******************************\
* sbit_EmboldenSubPixel adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
	uint8 newPix;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }


	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the right side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur && *(pCur-i) )
                    {
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur-i);
					}
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the left side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the left edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
                    if( (pCur+i) < pyCur+usBitmapWidth && *(pCur+i) ){
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur+i);
                    }
			    }

                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
                    if(pAdd >= pyTopNormal){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
					else 
						break;
				}

                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}
    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
                    if(pAdd < pyBottomNormal+usRowBytes){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
                    else 
						break;
				}

                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}

    // Second Pass to modify non edge pixel to MaxIndex
    if( MABS(sBoldSimulVertShift) > 1 ){ // If adding 2 or more pix vertically
        pyCur = pyTopBold+usRowBytes;
        while(pyCur < pyBottomBold){
            uint8 *pEndOfLine = pyCur+usBitmapWidth-1;

            pCur = pyCur+1;
            while(pCur < pEndOfLine){
                if( *pCur > (uint8)0 && *pCur < (uint8)MAX_RGB_INDEX){  // If it's color pix
                    if( *(pCur-1) && *(pCur+1) && *(pCur-usRowBytes) && *(pCur+usRowBytes)){  // If it's not edge pix
                        *pCur = (uint8)MAX_RGB_INDEX;
                    }
                }
                pCur++;
            }
            pyCur += usRowBytes;
        }
    }
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/
/*  if scaling or rotating, read bitmap into workspace,               */
/*  fix it up and copy it to the output map                           */

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork )
{
    ErrorCode   ReturnCode;
    uint8       *pbyRead;
    uint8       *pbyExpand;
    CopyBlock   cb;                                 /* for bitmap rotations */
    uint16      usSrcXMax;
    uint16      usSrcYMax;

    MEMSET(pbyOut, 0, pSbit->ulOutMemSize);         /* always clear the output map */

    if ((pSbit->usRotation == 0) &&                 /* if no rotation */
        (pSbit->usTableState != SBIT_BSCA_FOUND))   /* and no scaling */
    {
		if (pSbit->usBitDepth != 1)
		{
			MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyOut;						 /* expand in the output */
		} else {
			pbyRead = pbyOut;                           /* read straight to output map */
			pbyExpand = NULL;							/* expansion memory not used in that case */
		}
    } else                                            /* if any rotation or scaling */
    {
        MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
		if (pSbit->usBitDepth != 1)
		{
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyWork + pSbit->ulReadMemSize;	/* expand in the work memory */
		} else {
			pbyRead = pbyWork;                          /* read into workspace */
			pbyExpand = pbyWork;						/* scaling done in pbyExpand */
		}
    }

    ReturnCode = GetSbitComponent (                 /* fetch the bitmap */
        pClientInfo,
        pSbit->ulStrikeOffset,
        pSbit->usBitmapFormat,                      /* root data only in state */
        pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
        pSbit->usHeight,
        pSbit->usWidth,
        pSbit->usShaveLeft,
        pSbit->usShaveRight,
        pSbit->usShaveTop,
        pSbit->usShaveBottom,
        0,                                          /* no offset for the root */
        0,
        pSbit->usOriginalRowBytes,
        pSbit->usExpandedRowBytes,
		pSbit->usBitDepth,
        pbyRead,
		pbyExpand);
            
    if (ReturnCode != NO_ERR) return ReturnCode;

    
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        ScaleVertical (
            pbyExpand, 
            pSbit->usExpandedRowBytes, 
            pSbit->usHeight, 
            pSbit->usScaledHeight );

        ScaleHorizontal (
            pbyExpand, 
            pSbit->usExpandedRowBytes,
            pSbit->usScaledRowBytes,
            pSbit->usBitDepth, 
            pSbit->usWidth, 
            pSbit->usScaledWidth,
            pSbit->usScaledHeight );
            
        if (pSbit->usRotation == 0)                         /* if no rotation */
        {
            MEMCPY (pbyOut, pbyExpand, pSbit->ulOutMemSize);  /* keep this one */
        }
		/* in the SBIT_BSCA_FOUND the bitmap was already scaled to the final usScaledWidth, no need for additional emboldment */
	} else {
		if ((pSbit->uBoldSimulHorShift != 0) || (pSbit->uBoldSimulVertShift != 0))
		{
			if (pSbit->usRotation == 0)                             /* if no rotation */
			{
				cb.pbySrc = pbyOut;
			} else 
			{
				cb.pbySrc = pbyExpand;
			}
    
			if (pSbit->usBitDepth == 1)
			{
				sbit_Embolden(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			} else {
				uint16 usGrayLevels = (0x01 << pSbit->usBitDepth) ; /* Max gray level index */
				sbit_EmboldenGray(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, usGrayLevels, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			}

		}
    }

    if (pSbit->usRotation == 0)                             /* if no rotation */
    {
        return NO_ERR;                                      /* done */
    }
    
    cb.pbySrc = pbyExpand;
    cb.pbyDst = pbyOut;
    cb.usSrcBytesPerRow = pSbit->usScaledRowBytes;
    cb.usDstBytesPerRow = pSbit->usOutRowBytes;

	cb.usBitDepth = 1;
	if (pSbit->usBitDepth != 1)
		cb.usBitDepth = 8;

    usSrcXMax = pSbit->usScaledWidth;
    usSrcYMax = pSbit->usScaledHeight;

   	switch(pSbit->usRotation)
	{
	case 1:                                     /* 90 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = cb.usSrcY;                          /* x' = y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = usSrcXMax - cb.usSrcX - 1;      /* y' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 2:                                     /* 180 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstY = usSrcYMax - cb.usSrcY - 1;          /* y' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstX = usSrcXMax - cb.usSrcX - 1;      /* x' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 3:                                     /* 270 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = usSrcYMax - cb.usSrcY - 1;          /* x' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = cb.usSrcX;                      /* y' = x */
                CopyBit(&cb);
            }
        }
		break;
	default:                                    /* shouldn't happen */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}


/**********************************************************************/

/*      Private Functions                                             */

/**********************************************************************/

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo
)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    if (pSbit->bMetricsValid)
    {
        return NO_ERR;                      /* already got 'em */
    }

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    {
	    int16	sDescender = pClientInfo->sDefaultDescender;
	    int16	sBoxSize = pClientInfo->sDefaultAscender - pClientInfo->sDefaultDescender;
	    ErrorCode   ReturnCode;
	    uint16	usAdvanceWidth;
	    int16	sNonScaledLSB;

	    ReturnCode = sfac_ReadGlyphHorMetrics (
		    pClientInfo,
		    pClientInfo->usGlyphIndex,
		    &usAdvanceWidth,
		    &sNonScaledLSB);
	    if (ReturnCode != NO_ERR) return ReturnCode;

	    usAdvanceWidth = UEmScaleX(pSbit, usAdvanceWidth);
        
        sBoxSize = SEmScaleX(pSbit, sBoxSize);
        sDescender = SEmScaleX(pSbit, sDescender);

        /* for glyph that are meant to be used for sideways vertical writing, we cannot trust 
           pSbit->sTopSBearingX or pSbit->usAdvanceWidth from the embedded bitmaps metrics 
           since those metrics are not used by GDI many fonts have those metrics wrong MSMincho, MSPMincho, Gulim,...*/

        /* for characters whose adwance width equal the box size, we want to have this origin shifted by the descender so that
           the baseline of non sideways glyphs will align correctely. If the advance width is different we want to adjust to keep the optical center 
           of the character aligned */
        pSbit->sTopSBearingX = pSbit->sLSBearingX +sDescender +((sBoxSize - usAdvanceWidth) /2);

    }

    ReturnCode = sfac_ShaveSbitMetrics (
	    pClientInfo,
        pSbit->usBitmapFormat,
	    pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
		pSbit->usBitDepth,
    	&pSbit->usHeight,
    	&pSbit->usWidth,
        &pSbit->usShaveLeft,
        &pSbit->usShaveRight,
        &pSbit->usShaveTop,
        &pSbit->usShaveBottom,
    	&pSbit->sLSBearingX,
    	&pSbit->sLSBearingY,
    	&pSbit->sTopSBearingX,
    	&pSbit->sTopSBearingY);

    if (ReturnCode != NO_ERR) return ReturnCode;
        
    pSbit->bMetricsValid = TRUE;
    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAH;
	int16	sNonScaledTSB;

	ReturnCode = sfac_ReadGlyphVertMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAH,
		&sNonScaledTSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceHeight = UEmScaleY(pSbit, usNonScaledAH);

	pSbit->sTopSBearingX = pSbit->sLSBearingX;
	pSbit->sTopSBearingY = - SEmScaleY(pSbit, sNonScaledTSB);

    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAW;
	int16	sNonScaledLSB;

	ReturnCode = sfac_ReadGlyphHorMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAW,
		&sNonScaledLSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceWidth = UEmScaleX(pSbit, usNonScaledAW);

	pSbit->sLSBearingX = pSbit->sTopSBearingX;
	pSbit->sLSBearingY = SEmScaleY(pSbit, sNonScaledLSB);
	
    return NO_ERR;
}

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap )
{
	uint16          usCount;
	uint16			usBitIndex, usOriginalBitIndex;
	uint8			*pbyDstBitRow;
	uint8			*pbySrcBitRow;
	uint16			usMask, usShift, usMaxLevel;

	usMaxLevel = (0x01 << usBitDepth) -1; /* Max gray level index */

	if (usBitDepth == 2)
	{
		usMask = 0x03;
		usShift = 0x02;
		usOriginalBitIndex = ((usWidth -1) & 0x03) << 0x01;
	} else if (usBitDepth == 4)
	{
		usMask = 0x0F;
		usShift = 0x01;
		usOriginalBitIndex = ((usWidth -1) & 0x01) << 0x02;
	} else if (usBitDepth == 8)
	{
		usMask = 0xFF;
		usShift = 0x00;
		usOriginalBitIndex = 0; /* ((usWidth -1) & 0x00) << 0x03 */
	} else
	{
		return;
	}

	/* start from the end to be able to use overlapping memories */
	pbyDstBitRow = pbyDstBitMap + (long) (usHeight-1) * (long) usExpandedRowBytes;
	pbySrcBitRow = pbySrcBitMap + (long) (usHeight-1) * (long) usOriginalRowBytes;
	
	while (usHeight > 0)
	{
		pbyDstBitMap = pbyDstBitRow + (long)(usWidth -1);
		pbySrcBitMap = pbySrcBitRow + (long)((usWidth -1) >> usShift);
		usBitIndex = usOriginalBitIndex;

		*pbySrcBitMap = *pbySrcBitMap >> (MAX_BIT_INDEX - usBitDepth - usBitIndex);

		for (usCount = usWidth; usCount > 0; usCount--)
		{
			if (*pbyDstBitMap == 0)
			{
				/* 99.9% of the case */
				*pbyDstBitMap = *pbySrcBitMap & usMask;
			} else {
				*pbyDstBitMap = usMaxLevel - 
						(usMaxLevel - *pbyDstBitMap) * (usMaxLevel - *pbySrcBitMap & usMask) / usMaxLevel;
			}
			*pbySrcBitMap = *pbySrcBitMap >> usBitDepth;

			pbyDstBitMap--;
			if (usBitIndex == 0)
			{
				usBitIndex = MAX_BIT_INDEX;
				pbySrcBitMap--;
			}
			usBitIndex = usBitIndex - usBitDepth;

		}
		pbyDstBitRow -= usExpandedRowBytes;
		pbySrcBitRow -= usOriginalRowBytes;
		usHeight--;
	}
}
/**********************************************************************/

/*  This is the recursive composite routine */

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead,
    uint8           *pbyExpand )
{
    uint32          ulCompMetricsOffset;            /* component params */
    uint32          ulCompBitmapOffset;
    uint32          ulCompBitmapLength;
    uint16          usComponent;                    /* index counter */
    uint16          usCompCount;
    uint16          usCompGlyphCode;
    uint16          usCompXOff;
    uint16          usCompYOff;
    uint16          usCompMetricsType;
    uint16          usCompMetricsTable;
    uint16          usCompBitmapFormat;
    uint16          usCompHeight;
    uint16          usCompWidth;
    uint16          usCompShaveLeft;
    uint16          usCompShaveRight;
    uint16          usCompShaveTop;
    uint16          usCompShaveBottom;
    uint16          usCompAdvanceWidth;
    uint16          usCompAdvanceHeight;
    int16           sCompLSBearingX;
    int16           sCompLSBearingY;
    int16           sCompTopSBearingX;
    int16           sCompTopSBearingY;
    boolean         bCompGlyphFound;
   	boolean         bCompHorMetricsFound;
   	boolean         bCompVertMetricsFound;
    ErrorCode       ReturnCode;

		ReturnCode = sfac_GetSbitBitmap (               /* fetch the bitmap */
        pClientInfo,
        usBitmapFormat,
        ulBitmapOffset,
        ulBitmapLength,
        usHeight,
        usWidth,
        usShaveLeft,
        usShaveRight,
        usShaveTop,
        usShaveBottom,
        usXOffset,
        usYOffset,
        usOriginalRowBytes,
		usBitDepth,
        pbyRead,
        &usCompCount );                             /* zero for simple glyph */
            
    if (ReturnCode != NO_ERR) return ReturnCode;
    
	/* we expand after handling composite glyphs and before scaling and applying rotation */	
	if (usBitDepth != 1 && usCompCount == 0)
		ExpandSbitToBytePerPixel (
			usHeight,
			usWidth,
			usOriginalRowBytes,
			usExpandedRowBytes,
			usBitDepth,
			pbyRead,
			pbyExpand );

    if (usCompCount > 0)                            /* if composite glyph */
    {
        for (usComponent = 0; usComponent < usCompCount; usComponent++)
        {
			if (usBitDepth != 1)
			{
				/* for grayscale, the composition is done during expansion, I need to
				   clean the memory used to read between each component */
				MEMSET(pbyRead, 0, usOriginalRowBytes*usHeight);
			}
            ReturnCode = sfac_GetSbitComponentInfo (
                pClientInfo,
                usComponent,                        /* component index */
                ulBitmapOffset,
                ulBitmapLength,
                &usCompGlyphCode,                   /* return values */
                &usCompXOff,
                &usCompYOff );
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_SearchForBitmap (     /* look for component glyph */
                pClientInfo,
                usCompGlyphCode,
                ulStrikeOffset,                     /* same strike for all */
                &bCompGlyphFound,                   /* return values */
                &usCompMetricsType,
                &usCompMetricsTable,
                &ulCompMetricsOffset,
                &usCompBitmapFormat,
                &ulCompBitmapOffset,
                &ulCompBitmapLength );
            
            if (ReturnCode != NO_ERR) return ReturnCode;
            
            if (bCompGlyphFound == FALSE)           /* should be there! */
            {
                return SBIT_COMPONENT_MISSING_ERR;
            }

            ReturnCode = sfac_GetSbitMetrics (      /* get component's metrics */
                pClientInfo,
                usCompMetricsType,
                usCompMetricsTable,
                ulCompMetricsOffset,
                &usCompHeight,                      /* these matter */
                &usCompWidth,
                &sCompLSBearingX,                     /* these don't */
                &sCompLSBearingY,
                &sCompTopSBearingX,                     
                &sCompTopSBearingY,
                &usCompAdvanceWidth,
                &usCompAdvanceHeight,
   				&bCompHorMetricsFound,
   				&bCompVertMetricsFound	);
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_ShaveSbitMetrics (    /* shave white space for const metrics */
        	    pClientInfo,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
				usBitDepth,
            	&usCompHeight,
            	&usCompWidth,
                &usCompShaveLeft,
                &usCompShaveRight,
                &usCompShaveTop,
                &usCompShaveBottom,
            	&sCompLSBearingX,
            	&sCompLSBearingY,
            	&sCompTopSBearingX,
             	&sCompTopSBearingY );

            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = GetSbitComponent (         /* recurse here */
                pClientInfo,
                ulStrikeOffset,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
                usCompHeight,
                usCompWidth,
                usCompShaveLeft,
                usCompShaveRight,
                usCompShaveTop,
                usCompShaveBottom,
                (uint16)(usCompXOff + usXOffset + usCompShaveLeft),   /* for nesting */
                (uint16)(usCompYOff + usYOffset + usCompShaveTop),
                usOriginalRowBytes,                         /* same for all */
                usExpandedRowBytes,                         /* same for all */
				usBitDepth,
                pbyRead,
				pbyExpand);
            
            if (ReturnCode != NO_ERR) return ReturnCode;
        }
    }
    return NO_ERR;
}

/********************************************************************/

/*                  Bitmap Scaling Routines                         */

/********************************************************************/

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemX << 1; 
        ulValue += (uint32)pSbit->usSubPpemX;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemX << 1;
        usValue = (uint16)ulValue;
    }
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemY << 1; 
        ulValue += (uint32)pSbit->usSubPpemY;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemY << 1;
        usValue = (uint16)ulValue;
    }
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleX(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleX(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}

/********************************************************************/

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleY(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleY(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}


FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemX;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemX = pSbit->usSubPpemX;
    } else {
		usPpemX = pSbit->usPpemX;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemX << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemY;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemY = pSbit->usSubPpemY;
    } else {
		usPpemY = pSbit->usPpemY;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemY << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleX(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleX(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleY(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleY(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
)
{
    uint8 *pbyOrgRow;                   /* original data pointer */
    uint8 *pbyNewRow;                   /* new data pointer */
    uint16 usErrorTerm;                 /* for 'Bresenham' calculation */
    uint16 usLine;                      /* loop counter */

    usErrorTerm = usOrgHeight >> 1;                 /* used by both comp and exp */

    if (usOrgHeight > usNewHeight)                  /* Compress Vertical */
    {
        pbyOrgRow = pbyBitmap;
        pbyNewRow = pbyBitmap;

        for (usLine = 0; usLine < usNewHeight; usLine++)
        {
            while (usErrorTerm >= usNewHeight)
            {
                pbyOrgRow += usBytesPerRow;         /* skip a row */
                usErrorTerm -= usNewHeight;
            }
            if (pbyOrgRow != pbyNewRow)
            {
                MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
            }
            pbyNewRow += usBytesPerRow;
            usErrorTerm += usOrgHeight;
        }
        for (usLine = usNewHeight; usLine < usOrgHeight; usLine++)
        {
            MEMSET(pbyNewRow, 0, usBytesPerRow);    /* erase the leftover */
            pbyNewRow += usBytesPerRow;
        }
    }
    else if (usNewHeight > usOrgHeight)             /* Expand Vertical */
    {
        pbyOrgRow = pbyBitmap + (usOrgHeight - 1) * usBytesPerRow;
        pbyNewRow = pbyBitmap + (usNewHeight - 1) * usBytesPerRow;

        for (usLine = 0; usLine < usOrgHeight; usLine++)
        {
            usErrorTerm += usNewHeight;
            
            while (usErrorTerm >= usOrgHeight)      /* executes at least once */
            {
                if (pbyOrgRow != pbyNewRow)
                {
                    MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
                }
                pbyNewRow -= usBytesPerRow;
                usErrorTerm -= usOrgHeight;
            }
            pbyOrgRow -= usBytesPerRow;
        }
    }
}

/********************************************************************/

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
)
{
    uint8 *pbyOrgRow;               /* points to original row beginning */
    uint8 *pbyNewRow;               /* points to new row beginning */
    uint8 *pbyOrg;                  /* original data pointer */
    uint8 *pbyNew;                  /* new data pointer */
    uint8 byOrgData;                /* original data read 1 byte at a time */
    uint8 byNewData;                /* new data assembled bit by bit */

    uint16 usErrorTerm;             /* for 'Bresenham' calculation */
    uint16 usByte;                  /* to byte counter */
    uint16 usOrgBytes;              /* from width rounded up in bytes */
    uint16 usNewBytes;              /* to width rounded up in bytes */
    
    int16 sOrgBits;                 /* counts valid bits of from data */
    int16 sNewBits;                 /* counts valid bits of to data */
    int16 sOrgBitsInit;             /* valid original bits at row begin */
    int16 sNewBitsInit;             /* valid new bits at row begin */

    
	if (usBitDepth == 1)
	{
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;
			usNewBytes = (usNewWidth + 7) >> 3;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = 0;                           /* start at left edge */
				sNewBits = 0;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)
				{
					while (usErrorTerm >= usNewWidth)
					{
						sOrgBits--;                     /* skip a bit */
						usErrorTerm -= usNewWidth;
					}
					while (sOrgBits <= 0)               /* if out of data */
					{
						byOrgData = *pbyOrg++;          /*   then get some fresh */
						sOrgBits += 8;
					}
					byNewData <<= 1;                    /* new bit to lsb */
					byNewData |= (byOrgData >> (sOrgBits - 1)) & 1;
                
					sNewBits++;
					if (sNewBits == 8)                  /* if to data byte is full */
					{
						*pbyNew++ = byNewData;          /*   then write it out */
						sNewBits = 0;
						usByte++;                       /* loop counter */
					}
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = (usOrgWidth + 7) >> 3;
			sOrgBitsInit = (int16)((usOrgWidth + 7) & 0x07) - 7;
        
			usNewBytes = (usNewWidth + 7) >> 3;
			sNewBitsInit = 7 - (int16)((usNewWidth + 7) & 0x07);

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytes - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = sOrgBitsInit;                /* initially unaligned */
				sNewBits = sNewBitsInit;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)             /* for each output byte */
				{
					if (sOrgBits <= 0)                  /* if out of data */
					{
						byOrgData = *pbyOrg--;          /*   then get some fresh */
						sOrgBits += 8;
					}
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						byNewData >>= 1;                /* use the msb of byte */
						byNewData |= (byOrgData << (sOrgBits - 1)) & 0x80;
                    
						sNewBits++;
						if (sNewBits == 8)              /* if to data byte is full */
						{
							*pbyNew-- = byNewData;      /*   then write it out */
							sNewBits = 0;
							usByte++;                   /* loop counter */
						}
						usErrorTerm -= usOrgWidth;
					}
					sOrgBits--;                         /* get next bit */
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
    } else {											/* one byte per pixel */
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = 0;
				while (usByte < usNewWidth)
				{
					while (usErrorTerm >= usNewWidth)
					{
						pbyOrg++;                     /* skip a byte */
						usErrorTerm -= usNewWidth;
					}
					*pbyNew++ = *pbyOrg;
					usByte++;                       /* loop counter */
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = usOrgWidth;        
			usNewBytes = usNewWidth ;

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytesPerRow - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = usNewBytesPerRow;
				while (usByte > usNewBytes)
				{
					*pbyNew-- = 0;                      /* blank out the extra bytes on the right */
					usByte--;
				}
				while (usByte > 0)             /* for each output byte */
				{
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						*pbyNew-- = *pbyOrg;

						usByte--;                   /* loop counter */
						usErrorTerm -= usOrgWidth;
					}
					pbyOrg--;
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
	}
}

/********************************************************************/

FS_PRIVATE void CopyBit(
    CopyBlock* pcb )
{
    uint16  usSrcOffset;
    uint16  usSrcShift;
    uint16  usDstOffset;
    uint16  usDstShift;
    
    static  uint16 usByteMask[8] = 
        { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/*  if speed becomes an issue, this next multiply could be moved up */
/*  to the calling routine, and placed outside the 'x' loop */

/*  if speed becomes an issue, the test between 1 bit and 1 byte per pixel */
/*  could be moved up to the calling routine */

	if (pcb->usBitDepth == 1)
	{
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + (pcb->usSrcX >> 3);
		usSrcShift = pcb->usSrcX & 0x0007;

		if (pcb->pbySrc[usSrcOffset] & usByteMask[usSrcShift])
		{
			usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + (pcb->usDstX >> 3);
			usDstShift = pcb->usDstX & 0x0007;
			pcb->pbyDst[usDstOffset] |= usByteMask[usDstShift];
		}
	} else {
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + pcb->usSrcX;
		usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + pcb->usDstX;
		pcb->pbyDst[usDstOffset] = pcb->pbySrc[usSrcOffset];
	}

}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scale.c ===
/****************************** Module Header ******************************\
* Module Name: Scale.c
*
* Created: 16-Oct-1992
*
* Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
*             (c) 1989-1999. Microsoft Corporation.
*
* All Rights Reserved
*
* History:
*  Tue 16-Oct-1992 09:53:51 -by-  Greg Hitchcock [gregh]
* Created.
*   
*	 7/10/99	BeatS	   Add support for native SP fonts, vertical RGB
*	 4/01/99	BeatS	   Implement alternative interpretation of TT instructions for SP
*	02/21/97    claudebe   scaled component in composite glyphs
*	12/14/95    claudebe   adding two private phantom points for vertical positionning
* .
\***************************************************************************/

#define FSCFG_INTERNAL

/* INCLUDES */

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "scale.h"

#include "stat.h"

/* Constants    */

/* use the lower ones for public phantom points */

// public phantom points moved to fnt.h more global use

/* private phantom points start here */

#define ORIGINPOINT 4
#define LEFTEDGEPOINT 5

#define TOPORIGINPOINT 6
#define TOPEDGEPOINT 7

#define CANTAKESHIFT    0x02000000

/* MACROS   */

/* d is half of the denumerator */
#define FROUND( x, n, d, s ) \
		((SHORTMUL (x, n) + (d)) >> s)

#define SROUND( x, n, d, halfd ) \
	(x < 0 ? -((SHORTMUL (-(x), (n)) + (halfd)) / (d)) : ((SHORTMUL ((x), (n)) + (halfd)) / (d)))

#define NUMBEROFCHARPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1)
#define NUMBEROFTOTALPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1 + PHANTOMCOUNT)

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define ORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + ORIGINPOINT)
#define LEFTEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTEDGEPOINT)

#define TOPORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPORIGINPOINT)
#define TOPEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPEDGEPOINT)

/* PROTOTYPES   */

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D);
FS_PRIVATE F26Dot6 scl_FRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_SRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_FixRound (fnt_ScaleRecord* rec, F26Dot6 value);

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints);

FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);
/* FUNCTIONS    */

#define BOLD_FACTOR 0x51e
#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )
#define POINTSPERINCH               72

void  multiplyForEmbold(long a, long b, long *highRes, long *lowRes)
{
    long lowA, highA, lowB, highB, temp1, temp2;

    lowA = a & 0xffff;
    highA = (a & 0xffff0000) >> 16;
    lowB = b & 0xffff;
    highB = (b & 0xffff0000) >> 16;

    *highRes = highA*highB;
    *lowRes = lowA*lowB;

    temp1 = highA*lowB;
    temp2 = lowA*highB;

    *highRes += (temp1 & 0xffff0000) >> 16;
    *highRes += (temp2 & 0xffff0000) >> 16;

    *lowRes += (temp1 & 0xffff) << 16;
    *lowRes += (temp2 & 0xffff) << 16;
}

void  adjustTrans(transMatrix *trans)   //Adjust matrix for Emboldening
{
    int i,j;
    int  bNegative;
    long tmp, highRes, lowRes;

    for(i=0; i<2; i++)
        for(j=0; j<2; j++){
        
        	tmp = (long) trans->transform[i][j];

            bNegative = tmp < 0 ? TRUE: FALSE;
            tmp = MABS(tmp);

            multiplyForEmbold(tmp, BOLD_FACTOR, &highRes, &lowRes);

            highRes <<= 16;
            tmp -= highRes;

            if(bNegative)
	            tmp = -tmp;

            trans->transform[i][j] = tmp;
        }
}

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm)         /* OUT: Pixels Per Em       */
{
	Fixed        maxScale;
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	transMatrix   origTrans = *trans;
	uint16		usRotation;
	boolean			non90degreeRotation,nonUniformStretching;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	mth_FoldPointSizeResolution(fxPointSize, sXResolution, sYResolution, trans);

	if ( ( (usEmboldWeightx != 0) || (usEmboldWeighty != 0))  && 							// Adjust matrix for Emboldening
		 (uint16)ROUNDFIXTOINT(ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH)) > 50 )// when bigger than 50 ppem
	{
        adjustTrans(trans);
    }

	mth_ReduceMatrix (trans);

	fxUpem = INTTOFIX(usUpem);

/*
 *  First set up the scalars...
 */

	/*save the flag for use in composite glyphs */
	globalGS->bHintAtEmSquare = bHintAtEmSquare;

	if (bHintAtEmSquare)
	{
		globalGS->interpScalarX = fxUpem;
		globalGS->interpScalarY = fxUpem;
		globalGS->fxMetricScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->fxMetricScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);

		/* we don't want to round the interpScalar */
	}
	else
	{
		globalGS->interpScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->interpScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);
		globalGS->fxMetricScalarX = globalGS->interpScalarX;
		globalGS->fxMetricScalarY = globalGS->interpScalarY;

		if (bIntegerScaling)
		{
			globalGS->interpScalarX = (Fixed)ROUNDFIXED(globalGS->interpScalarX);
			globalGS->interpScalarY = (Fixed)ROUNDFIXED(globalGS->interpScalarY);
		}
	}

	globalGS->ScaleFuncX = scl_ComputeScaling(&globalGS->scaleX, globalGS->interpScalarX, fxUpem);
	globalGS->ScaleFuncY = scl_ComputeScaling(&globalGS->scaleY, globalGS->interpScalarY, fxUpem);

	if ((globalGS->interpScalarX == 0) && (globalGS->interpScalarY == 0))
	{
		return TRAN_NULL_TRANSFORM_ERR;
	}
	if (globalGS->interpScalarX >= globalGS->interpScalarY)
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncX;
		globalGS->scaleCVT = globalGS->scaleX;
		globalGS->cvtStretchX = ONEFIX;
		globalGS->cvtStretchY = FixDiv(globalGS->interpScalarY, globalGS->interpScalarX);;
		maxScale = globalGS->interpScalarX;
	}
	else
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncY;
		globalGS->scaleCVT = globalGS->scaleY;
		globalGS->cvtStretchX = FixDiv(globalGS->interpScalarX, globalGS->interpScalarY);
		globalGS->cvtStretchY = ONEFIX;
		maxScale = globalGS->interpScalarY;
	}

	*pulPixelsPerEm = (uint32)ROUNDFIXTOINT (globalGS->interpScalarY);

	globalGS->bSameStretch  = (uint8)mth_SameStretch( globalGS->interpScalarX, globalGS->interpScalarY );
	globalGS->pixelsPerEm   = (uint16)ROUNDFIXTOINT(maxScale);
	globalGS->pointSize     = (uint16)ROUNDFIXTOINT( fxPointSize );
	globalGS->fpem          = maxScale;
	globalGS->identityTransformation = (int8)mth_PositiveSquare( trans );

	/* Use bit 1 of non90degreeTransformation to signify stretching.  stretch = 2 */

	mth_Non90DegreeTransformation(&origTrans,&non90degreeRotation,&nonUniformStretching);

	globalGS->non90DegreeTransformation = 0;

	if (non90degreeRotation)  globalGS->non90DegreeTransformation |= NON90DEGTRANS_ROTATED;
	if (nonUniformStretching) globalGS->non90DegreeTransformation |= NON90DEGTRANS_STRETCH;


	*psBoldSimulHorShift = 0;
	*psBoldSimulVertShift = 0;

	if ((usEmboldWeightx != 0) || (usEmboldWeighty != 0))
	{
		/* we cannot use globalGS->pixelsPerEm because it s incorrect under non 90degree rotation */
		uint16 ppemY;
		Fixed fxBoldSimulHorShift,fxBoldSimulVertShift;
		F26Dot6	fxDefaultDescender;
        transMatrix reverseTrans;
        Fixed   fxDeterminant;
		Fixed fxScale;

		fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
		ppemY = (uint16)ROUNDFIXTOINT(fxScale);  
		usRotation = mth_90degRotationFactorForEmboldening(trans);
		if( usRotation == 8 )   // Consider Italic/Bold case
            usRotation = mth_90degClosestRotationFactor(trans);

		if (bHintAtEmSquare)
		{
            *psBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000; /* save the number of pixels for bitmap emboldening */
			ppemY = usUpem;
		}

		/* this computation is intended to give backwards compatible results with the
			bitmap emboldening simulation done in Windows NT 4.0
		    The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
			for an emboldening factor of 2% (usEmboldWeight = 20)
		*/

		globalGS->uBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000;
		globalGS->uBoldSimulHorShift = (ppemY * usEmboldWeightx - 10) /1000 + 1;

		if (!bHintAtEmSquare)
		    *psBoldSimulVertShift = globalGS->uBoldSimulVertShift; /* save the number of pixels for bitmap emboldening */

 		switch(usRotation)                   /* handle 90 degree rotations */
		{
		case 0:                                     // 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift);
 			break;
		case 1:                                     // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift);
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 2:                                     // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = *psBoldSimulVertShift;
			break;
		case 3:                                     // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		case 4:                                     // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = *psBoldSimulVertShift;
 			break;
		case 5:                                     // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 6:                                     // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = -*psBoldSimulVertShift;
			break;
		case 7:                                     // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -*psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		default:                                    /* non 90 degree rotation */
			*psBoldSimulHorShift = 0;
			*psBoldSimulVertShift = 0;
		}

		if (!bHintAtEmSquare && (sYResolution != sXResolution))
		{
			fxBoldSimulHorShift = globalGS->uBoldSimulHorShift << 16;
			fxBoldSimulVertShift = globalGS->uBoldSimulVertShift << 16;
            fxDeterminant = MABS( FixMul(origTrans.transform[0][0],origTrans.transform[1][1]) - FixMul(origTrans.transform[0][1],origTrans.transform[1][0]) );

			if (fxDeterminant == 0)
			{
				globalGS->uBoldSimulHorShift = 0;  
				globalGS->uBoldSimulVertShift = 0;  
			}
			else
			{
				origTrans.transform[0][0] = FixDiv(origTrans.transform[0][0], fxDeterminant);
				origTrans.transform[0][1] = FixDiv(origTrans.transform[0][1], fxDeterminant);
				origTrans.transform[1][0] = FixDiv(origTrans.transform[1][0], fxDeterminant);
				origTrans.transform[1][1] = FixDiv(origTrans.transform[1][1], fxDeterminant);
				reverseTrans = origTrans;
				reverseTrans.transform[0][1] = - reverseTrans.transform[0][1];
				reverseTrans.transform[1][0] = - reverseTrans.transform[1][0];

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&origTrans,
					ONEFIX,
					ONEFIX);

				fxBoldSimulHorShift = ShortMulDiv(fxBoldSimulHorShift, sXResolution, sYResolution);

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&reverseTrans,
					ONEFIX,
					ONEFIX);

				globalGS->uBoldSimulHorShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulHorShift));  
				globalGS->uBoldSimulVertShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulVertShift));  
			}

        }

		if (!bHintAtEmSquare && !(globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
		{
			/* 90 degree rotation, convert the device value into 26.6 */
			globalGS->fxScaledDescender = -lDescDev << 6;
		} else 
		{
			/* under rotation, we use the value from head-Descender and scale it */
			fxDefaultDescender = sWinDescender;

			scl_Scale (&globalGS->scaleY,
					globalGS->ScaleFuncY,
					&fxDefaultDescender,
					&globalGS->fxScaledDescender,
					1);

			/* add the uBoldSimulVertShift and round to the next pixel */
			globalGS->fxScaledDescender = globalGS->fxScaledDescender & ~(LOWSIXBITS);
		}
	} else {
		globalGS->uBoldSimulHorShift = 0;
		globalGS->uBoldSimulVertShift = 0;
		globalGS->fxScaledDescender = 0;
	}
	return NO_ERR;
}

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem)                 /* Current units per Em     */
{
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed           interpScalarX;    
	Fixed           interpScalarY;    

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	fxUpem = INTTOFIX(usUpem);

/* 
 * This procedure is a subset from scl_InitializeScaling. 
 * There is no perfect solution here, we decided that the best, in the case of a
 * component that is not at the same transformation as the master glyph,
 * is to scale this child glyph to the user grid for hinting, without re-running
 * the pre-program, without rescaling the cvt or changing other GloblaGS information (pointSize, pixelPerEm,...)
 */

/*
 *  First set up the scalars...
 */
	if (globalGS->bHintAtEmSquare)
	{
		interpScalarX = fxUpem;
		interpScalarY = fxUpem;
	}
	else
	{
		interpScalarX = mth_max_abs (CurrentTMatrix.transform[0][0], CurrentTMatrix.transform[0][1]);
		interpScalarY = mth_max_abs (CurrentTMatrix.transform[1][0], CurrentTMatrix.transform[1][1]);
	}

	globalGS->ScaleFuncXChild = scl_ComputeScaling(&globalGS->scaleXChild, interpScalarX, fxUpem);
	globalGS->ScaleFuncYChild = scl_ComputeScaling(&globalGS->scaleYChild, interpScalarY, fxUpem);

}

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->bHintForGray = bHintForGray;

#ifdef FSCFG_SUBPIXEL
	globalGS->flHintForSubPixel = flHintForSubPixel;
#endif // FSCFG_SUBPIXEL
}

/******************** These three scale 26.6 to 26.6 ********************/
/*
 * Fast (scaling)
 */
FS_PRIVATE F26Dot6 scl_FRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FROUND (value, rec->numer, rec->denom >> 1, rec->shift);
}

/*
 * Medium (scaling)
 */
FS_PRIVATE F26Dot6 scl_SRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	int32 D;

	D = rec->denom;
	return (F26Dot6) SROUND (value, rec->numer, D, D >> 1);
}

/*
 * Fixed Rounding (scaling), really slow
 */
FS_PRIVATE F26Dot6 scl_FixRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FixMul ((Fixed)value, rec->fixedScale);
}

/********************************* End scaling utilities ************************/

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D)
{
	int32     lShift;

	lShift = mth_CountLowZeros((uint32)(N | D) ) - 1;

	if (lShift > 0)
	{
		N >>= lShift;
		D >>= lShift;
	}


	if ( N < CANTAKESHIFT )
	{
		N <<= FNT_PIXELSHIFT;
	}
	else
	{
		D >>= FNT_PIXELSHIFT;
	}

	/* fixedScale is now set in every case for the scale back in scaled composites */
	rec->fixedScale = FixDiv(N, D);

	if (N <= SHRT_MAX)   /* Check to see if N fits in a short    */
	{
		lShift = mth_GetShift ((uint32) D);
		rec->numer = (int32)N;
		rec->denom = (int32)D;

		if ( lShift >= 0 )                  /* FAST SCALE */
		{
			rec->shift = (int32)lShift;
			return (GlobalGSScaleFunc)scl_FRound;
		}
		else                                /* MEDIUM SCALE */
		{
			return (GlobalGSScaleFunc)scl_SRound;
		}
	}
	else                                    /* SLOW SCALE */
	{
		return (GlobalGSScaleFunc)scl_FixRound;
	}
}


FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	if (ScaleFunc == scl_FRound)
	{
		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, sr->shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], sr->numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], sr->fixedScale);
			}
		}
	}
}


FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	Scale;
	int32	Shift;
	int32	Numer;

	/* we are now multiplying a 26.6 by sr->numer, we could overflow if (sr->numer >= SHRT_MAX >> FNT_PIXELSHIFT) */
	if ((ScaleFunc == scl_FRound) && (sr->numer < (SHRT_MAX >> FNT_PIXELSHIFT) ))
	{
		
		Shift = sr->shift + FNT_PIXELSHIFT;

		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, Shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			Numer = sr->numer >> FNT_PIXELSHIFT;

			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], Numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			Scale = sr->fixedScale >> FNT_PIXELSHIFT;
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], Scale);
			}
		}
	}
}

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	ScaleBack;

	ScaleBack = sr->fixedScale >> FNT_PIXELSHIFT;
	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (F26Dot6) FixDiv ((Fixed)oop[Index], ScaleBack);
	}
}

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (Fixed)oop[Index] << FNT_PIXELSHIFT;
	}
}

/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleOldCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}
/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleOldPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}

}

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;


	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	Assert(globalGS->bSameTransformAsMaster);

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ScaleFromFixedFUnits (&globalGS->scaleX,
			   globalGS->ScaleFuncX,
			   &(pElement->x[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ScaleFromFixedFUnits (&globalGS->scaleY,
			   globalGS->ScaleFuncY,
			   &(pElement->y[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

}

/*
 *  scl_ScaleBackCurrentCharPoints                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
}

/*
 *  scl_OriginalCharPointsToCurrentFixedFUnits                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{

	scl_ConvertToFixedFUnits (
			   pElement->oox,
			   pElement->x,
			   (int32)NUMBEROFCHARPOINTS(pElement));

	scl_ConvertToFixedFUnits (
			   pElement->ooy,
			   pElement->y,
			   (int32)NUMBEROFCHARPOINTS(pElement));
}

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{
	uint16                    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ConvertToFixedFUnits (
			   &(pElement->oox[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ConvertToFixedFUnits (
			   &(pElement->ooy[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);
}

/*
 * scl_ScaleCVT
 */

FS_PUBLIC void  scl_ScaleCVT(
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if(globalGS->cvtCount > 0)
	{
		scl_Scale (
			&globalGS->scaleCVT,
			globalGS->ScaleFuncCVT,
			pfxCVT,
			globalGS->controlValueTable,
			(int32)globalGS->cvtCount);
	}
}

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pfxCVT = globalGS->controlValueTable;

}

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH, /* Non-scaled Advance Height    */
	int16               sNonScaledTopOriginX) /* Non-scaled Top Origin X  */
{

	F26Dot6             fxXMinMinusLSB;
	F26Dot6             fxYMaxPlusTSB;

	MEMSET (&(pElement->ooy[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->ooy[0]));

	MEMSET (&(pElement->oox[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->oox[0]));

	fxXMinMinusLSB = ((F26Dot6)bbox->xMin - (F26Dot6)sNonScaledLSB);

	pElement->oox[LSBPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[RSBPOINTNUM(pElement)] = fxXMinMinusLSB + (F26Dot6)usNonScaledAW;
	pElement->oox[ORIGINPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[LEFTEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->xMin;

	fxYMaxPlusTSB = ((F26Dot6)bbox->yMax + (F26Dot6)sNonScaledTSB);

	pElement->ooy[TOPSBPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[BOTTOMSBPOINTNUM(pElement)] = fxYMaxPlusTSB - (F26Dot6)usNonScaledAH;
	pElement->ooy[TOPORIGINPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->yMax;

	pElement->oox[TOPSBPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
	pElement->oox[BOTTOMSBPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
	pElement->oox[TOPORIGINPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
	pElement->oox[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
}

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
	uint16      cNumCharPoints;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	cNumCharPoints = NUMBEROFCHARPOINTS(pElement);

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		0,
		cNumCharPoints);

}

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		LSBPOINTNUM(pElement),
		PHANTOMCOUNT);
}

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6 fxOldLeftOrigin;
	F26Dot6 fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	pElement->ox[LSBPOINTNUM(pElement)]  = fxNewLeftOrigin;
	pElement->ox[RSBPOINTNUM(pElement)] += fxNewLeftOrigin - fxOldLeftOrigin;
}

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->ox, pElement->x, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->oy, pElement->y, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->x, pElement->ox, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->y, pElement->oy, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	uint16    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);
	MEMCPY(&pElement->x[usFirstPhantomPoint],
		   &pElement->ox[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));

	MEMCPY(&pElement->y[usFirstPhantomPoint],
		   &pElement->oy[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution)
{
	F26Dot6     fxWidth;
	F26Dot6     fxHeight;
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	/* autoround the right side bearing */

	fxWidth = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarX,
		(int16)(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxWidth = globalGS->ScaleFuncX(&globalGS->scaleX,
		(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]));
*/

#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)  ) {
		fxWidth += VIRTUAL_PIXELSIZE_RTG / 2;
		fxWidth &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else { // for SubPixel in compatible width mode, always round to full pixel to get full pixel advance width
#endif
		fxWidth += FNT_PIXELSIZE / 2;
		fxWidth &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif
	pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + fxWidth;

	/* autoround the top side bearing */

	fxHeight = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarY,
		(int16)(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxHeight = globalGS->ScaleFuncY(&globalGS->scaleY,
		(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]));
*/

	/* in the vertical direction, as we don't round the old TOPSBPOINT 
	    and do scl_ShiftOldPoints, we need to round TOPSBPOINT here */
	pElement->y[TOPSBPOINTNUM(pElement)] =
		(pElement->y[TOPSBPOINTNUM(pElement)] + DOT6ONEHALF) & ~(LOWSIXBITS);

	pElement->y[BOTTOMSBPOINTNUM(pElement)] =
		pElement->y[TOPSBPOINTNUM(pElement)] + (fxHeight + DOT6ONEHALF) & ~(LOWSIXBITS);
}

/*
 *  scl_ShiftChar
 *
 *  Shifts a character          <3>
 */
FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift)

{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->x[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->y[ulCharIndex] += fxYShift;
		}
	}
}

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints)
{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->ox[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->oy[ulCharIndex] += fxYShift;
		}
	}
}

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset)         /* Y Offset             */
{
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed     scalarX;
	Fixed     scalarY;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (bSameTransformAsMaster) {
		*pfxXOffset = globalGS->ScaleFuncX(&globalGS->scaleX,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncY(&globalGS->scaleY,(F26Dot6)sYOffset);
	} else {
		*pfxXOffset = globalGS->ScaleFuncXChild(&globalGS->scaleXChild,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncYChild(&globalGS->scaleYChild,(F26Dot6)sYOffset);
	}

	if (bScaleCompositeOffset)
	/* the composite is designed to have its offset scaled (designed for Apple) */
	{
		/* Apple use a 45 degree special case that they are dropping on their GX rasterizer,
		   I'm not implementing this special rule here */
		scalarX = mth_max_abs (mulT.transform[0][0], mulT.transform[0][1]);
		scalarY = mth_max_abs (mulT.transform[1][0], mulT.transform[1][1]);
		if ((scalarX != ONEFIX) || (scalarY != ONEFIX)) {
			*pfxXOffset = (F26Dot6) FixMul ((Fixed)*pfxXOffset, scalarX);
			*pfxYOffset = (F26Dot6) FixMul ((Fixed)*pfxYOffset, scalarY);
		}
	}

	if (bRounding) {
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) != VerticalSPDirection(globalGS)))) {
			*pfxXOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxXOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxXOffset += FNT_PIXELSIZE / 2;
			*pfxXOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) == VerticalSPDirection(globalGS)))) {
			*pfxYOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxYOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxYOffset += FNT_PIXELSIZE / 2;
			*pfxYOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}
	if (!bSameTransformAsMaster)
	/* we need to scale back the offset in fixed FUnits */
	{
		scl_ScaleBack (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pfxXOffset,
				pfxXOffset,
				1 /* only one value to scale */);
		scl_ScaleBack (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pfxYOffset,
				pfxYOffset,
				1 /* only one value to scale */);
	}
}

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset)         /* Y Offset             */
{
	*pfxXOffset = pParentElement->x[usAnchorPoint1] - pChildElement->x[usAnchorPoint2];
	*pfxYOffset = pParentElement->y[usAnchorPoint1] - pChildElement->y[usAnchorPoint2];
}



FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pElement->x[usPhantomPointNumber] = pptLSB->x;
	pElement->y[usPhantomPointNumber] = pptLSB->y;
	usPhantomPointNumber++;
	pElement->x[usPhantomPointNumber] = pptRSB->x;
	pElement->y[usPhantomPointNumber] = pptRSB->y;
}

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pptLSB->x = pElement->x[usPhantomPointNumber];
	pptLSB->y = pElement->y[usPhantomPointNumber];
	usPhantomPointNumber++;
	pptRSB->x = pElement->x[usPhantomPointNumber];
	pptRSB->y = pElement->y[usPhantomPointNumber];
}

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,       /* Element  */
	int16               sMaxPoints,
	int16               sMaxContours)
{
	pElement->sp[0] = 0;
	pElement->ep[0] = sMaxPoints - 1;
	pElement->nc = sMaxContours;
}

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType * pElement,     /* Element pointer  */
	uint16      usNumberOfPoints,
	uint16      usNumberOfContours)
{

	MEMSET (&pElement->x[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->y[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ooy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->onCurve[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));
	MEMSET (&pElement->f[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));

	MEMSET (&pElement->sp[0], 0, (size_t)usNumberOfContours * sizeof(int16));
	MEMSET (&pElement->ep[0], 0, (size_t)usNumberOfContours * sizeof(int16));
}

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement)     /* Element pointer  */
{
	MEMSET (&pElement->f[0], 0, (size_t)NUMBEROFTOTALPOINTS(pElement) * sizeof(uint8));
}

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usParentNewStartPoint;

	if(pParentElement->nc != 0)
	{
		usParentNewStartPoint = LSBPOINTNUM(pParentElement);

		pChildElement->x = &pParentElement->x[usParentNewStartPoint];
		pChildElement->y = &pParentElement->y[usParentNewStartPoint];

		pChildElement->ox = &pParentElement->ox[usParentNewStartPoint];
		pChildElement->oy = &pParentElement->oy[usParentNewStartPoint];

		pChildElement->oox = &pParentElement->oox[usParentNewStartPoint];
		pChildElement->ooy = &pParentElement->ooy[usParentNewStartPoint];

		pChildElement->onCurve = &pParentElement->onCurve[usParentNewStartPoint];
		pChildElement->f = &pParentElement->f[usParentNewStartPoint];

		pChildElement->fc = &pParentElement->fc[pParentElement->nc];

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		pChildElement->pcr = &pParentElement->pcr[usParentNewStartPoint];
#endif

		pChildElement->sp = &pParentElement->sp[pParentElement->nc];
		pChildElement->ep = &pParentElement->ep[pParentElement->nc];

		pChildElement->nc = 0;
	}
	else
	{
		MEMCPY(pChildElement, pParentElement, sizeof(fnt_ElementType));
	}
}

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usNumberOfParentPoints;
	uint32          ulPointIndex;

	if(pParentElement->nc != 0)
	{
		usNumberOfParentPoints = NUMBEROFCHARPOINTS(pParentElement);

		for(ulPointIndex = (uint32)(uint16)pParentElement->nc;
			ulPointIndex < (uint32)(uint16)pParentElement->nc + (uint32)(uint16)pChildElement->nc;
			ulPointIndex++)
		{
			pParentElement->sp[ulPointIndex] += (int16)usNumberOfParentPoints;
			pParentElement->ep[ulPointIndex] += (int16)usNumberOfParentPoints;
		}
	}

	pParentElement->nc += pChildElement->nc;
}

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement)
{
	 uint16 usNumberOfPoints;
	 uint32 ulSize;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 ulSize =  sizeof( pElement->nc );
	 ulSize += sizeof( *pElement->sp ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->ep ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->x ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->y ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->onCurve ) * (size_t)usNumberOfPoints;

	 return( ulSize );
}

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 *((int16 *)*ppbyOutline) = pElement->nc;
	 *ppbyOutline += sizeof( pElement->nc   );

	 MEMCPY(*ppbyOutline, pElement->sp, (size_t)pElement->nc * sizeof( *pElement->sp ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->ep, (size_t)pElement->nc * sizeof( *pElement->ep ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->x, (size_t)usNumberOfPoints * sizeof(*pElement->x));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->x );

	 MEMCPY(*ppbyOutline, pElement->y, (size_t)usNumberOfPoints * sizeof(*pElement->y));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->y );

	 MEMCPY(*ppbyOutline, pElement->onCurve, (size_t)usNumberOfPoints * sizeof(*pElement->onCurve));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->onCurve );

}

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 pElement->nc = *((int16 *)(*ppbyOutline));
	 *ppbyOutline += sizeof( int16 );

	 pElement->sp = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 pElement->ep = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 pElement->x = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->y = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->onCurve = (uint8 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( uint8 );
}

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceWidth->x = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarX, (int16)usNonScaledAW, (int16)usEmResolution );
        if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceWidth->x = FixRatio( (int16)usNonScaledAW, (int16)usEmResolution );
        if ((globalGS->fxMetricScalarX != ONEFIX) && (globalGS->uBoldSimulHorShift != 0))
        {
            AdvanceWidth->x = FixMul(AdvanceWidth->x, globalGS->fxMetricScalarX);
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
            AdvanceWidth->x = FixDiv(AdvanceWidth->x, globalGS->fxMetricScalarX);
        }
        else
        {
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        }
		mth_FixXYMul( &AdvanceWidth->x, &AdvanceWidth->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceHeight->y = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarY, (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
		mth_FixXYMul( &AdvanceHeight->x, &AdvanceHeight->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing
)
{
	fnt_GlobalGraphicStateType *    globalGS;

	if ( bPositiveSquare )
	{
	    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
		pvecAdvanceHeight->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    (int16)usNonScaledAH, 
		    (int16)usEmResolution );
		
		pvecTopSideBearing->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    sNonScaledTSB, 
		    (int16)usEmResolution );
	}
	else
	{
		pvecAdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
		mth_FixXYMul( &pvecAdvanceHeight->x, &pvecAdvanceHeight->y, trans );

		pvecTopSideBearing->y = FixRatio( sNonScaledTSB, (int16)usEmResolution );
		mth_FixXYMul( &pvecTopSideBearing->x, &pvecTopSideBearing->y, trans );
	}
}


FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine)
{
	scl_CalcDevAdvanceWidth(pElement, devAdvanceWidth);

	devLeftSideBearing->x = f26XMin - pElement->x[LSBPOINTNUM(pElement)];
	devLeftSideBearing->y = f26YMax - pElement->y[LSBPOINTNUM(pElement)];

	LeftSideBearing->x = pElement->x[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->x -= pElement->x[ORIGINPOINTNUM(pElement)];
	LeftSideBearing->y = f26YMax - pElement->y[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->y -= pElement->y[ORIGINPOINTNUM(pElement)];

	*devLeftSideBearingLine = *devLeftSideBearing;
	*LeftSideBearingLine = *LeftSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth)

{
	devAdvanceWidth->x = pElement->x[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->x -= pElement->x[LSBPOINTNUM(pElement)];
	devAdvanceWidth->y = pElement->y[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->y -= pElement->y[LSBPOINTNUM(pElement)];
}

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine)
{
	scl_CalcDevAdvanceHeight(pElement, devAdvanceHeight);

	devTopSideBearing->x = f26XMin - pElement->x[TOPSBPOINTNUM(pElement)];
	devTopSideBearing->y = f26YMax - pElement->y[TOPSBPOINTNUM(pElement)];

	TopSideBearing->x = f26XMin - pElement->x[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->x -= pElement->x[TOPORIGINPOINTNUM(pElement)];
	TopSideBearing->y = pElement->y[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->y -= pElement->y[TOPORIGINPOINTNUM(pElement)];

	*devTopSideBearingLine = *devTopSideBearing;
	*TopSideBearingLine = *TopSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight)

{
	devAdvanceHeight->x = pElement->x[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->x -= pElement->x[BOTTOMSBPOINTNUM(pElement)];
	devAdvanceHeight->y = pElement->y[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->y -= pElement->y[BOTTOMSBPOINTNUM(pElement)];
}


FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEM = globalGS->pixelsPerEm;
}

/*  Return ppem in X and Y directions for sbits */

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEMX = (uint16)ROUNDFIXTOINT(globalGS->interpScalarX);
	*pusPPEMY = (uint16)ROUNDFIXTOINT(globalGS->interpScalarY);
}


FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement)
{
  F26Dot6 * x;
  int16     count;

  x = pElement->x;
  count = (int16)NUMBEROFCHARPOINTS(pElement) - 1;
  for (; count >= 0; --count)
  {
	(*x)++;
	++x;
  }
}

/*
 *  scl_PostTransformGlyph              <3>
 */
FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bHintAtEmSquare)
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
			globalGS->interpScalarX,
			globalGS->interpScalarY); 
	}
	else
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
	/*        globalGS->interpScalarX,
			globalGS->interpScalarY); */
			globalGS->fxMetricScalarX,
			globalGS->fxMetricScalarY);
	}
}

/*
 *  scl_ApplyTranslation              
 */
FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
   )
{
	int32 ulPointIndex;
	F26Dot6 xShift, yShift;

	/* transform from 16.16 to 26.6 */
	xShift = (trans->transform[0][2] + 0x200) >> 10;
	yShift = (trans->transform[1][2] + 0x200) >> 10;

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		xShift = xShift * RGB_OVERSCALE;
    }
#endif

	/* lsb point should be moved to (0,0) so that we can get correct bitmap bounding box when overscaling */
	xShift -= pElement->x[LSBPOINTNUM(pElement)];
	yShift -= pElement->y[LSBPOINTNUM(pElement)];

	
	if (bUseHints && !bHintAtEmSquare) {
#ifdef FSCFG_SUBPIXEL
		if (bSubPixel) {
			/* We want to round to a virtual pixel boundary when hinted */ 
			xShift += VIRTUAL_PIXELSIZE_RTG/2; 
			xShift &= ~(VIRTUAL_PIXELSIZE_RTG - 1); 
		} else {
#endif
			/* We want to round to a pixel boundary when hinted */ 
			xShift += FNT_PIXELSIZE/2; 
			xShift &= ~(FNT_PIXELSIZE - 1); 
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}

	if (xShift != 0 || yShift != 0)
	{
		for(ulPointIndex = 0;
				ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
				ulPointIndex++)
		{
			pElement->x[ulPointIndex] += xShift;
			pElement->y[ulPointIndex] += yShift;
		}
	}

}
/*
 *      scl_LocalPostTransformGlyph                             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans)
{
	int32 lCount;

	lCount = (int32)NUMBEROFTOTALPOINTS(pElement);

	mth_IntelMul (lCount, pElement->x, pElement->y, trans, ONEFIX, ONEFIX);
}

#ifdef FSCFG_SUBPIXEL

FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement)   /* Element  */
{
	int32 ulPointIndex;
	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->ox[ulPointIndex] = ROUND_RGB_OVERSCALE(pElement->x[ulPointIndex]);
	}
}

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale)  
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] = FixMul(pElement->x[ulPointIndex], fxCompatibleWidthScale);
	}
}


FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] += horTranslation;
	}
    pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + newDevAdvanceWidthX;
}


FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
	int32 ulPointIndex;
	F26Dot6 fxMaxX;             /* for bounding box left, right */

	*pDevLeftSideBearingX = LONG_MAX;     /* default bounds limits */
	fxMaxX = LONG_MIN;

	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]; 
	*pDevAdvanceWidthX -= pElement->x[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		if (pElement->x[ulPointIndex] > fxMaxX)
			fxMaxX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex] < *pDevLeftSideBearingX)
			*pDevLeftSideBearingX = pElement->x[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - fxMaxX;

}

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
	int32 ulPointIndex;

	*pDevLeftSideBearingX = LONG_MAX; *pDevRightSideBearingX = LONG_MIN;
	*pNatLeftSideBearingX = LONG_MAX; *pNatRightSideBearingX = LONG_MIN;
	
	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]  - pElement->x[LSBPOINTNUM(pElement)];
	*pNatAdvanceWidthX = pElement->ox[RSBPOINTNUM(pElement)] - pElement->ox[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0; ulPointIndex < NUMBEROFCHARPOINTS(pElement); ulPointIndex++) {
		if (pElement->x[ulPointIndex]  > *pDevRightSideBearingX) *pDevRightSideBearingX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex]  < *pDevLeftSideBearingX)  *pDevLeftSideBearingX  = pElement->x[ulPointIndex];
		if (pElement->ox[ulPointIndex] > *pNatRightSideBearingX) *pNatRightSideBearingX = pElement->ox[ulPointIndex];
		if (pElement->ox[ulPointIndex] < *pNatLeftSideBearingX)  *pNatLeftSideBearingX  = pElement->ox[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevRightSideBearingX;
    *pNatRightSideBearingX = *pNatAdvanceWidthX - *pNatRightSideBearingX;
} // scl_CalcDevNatHorMetrics

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\interp.h ===
/*
	 File:		 interp.h

	 Contains:	 Exports and constants used by TrueType Interpreter

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):
*/

#include 	"fnterr.h"

#define NOGRIDFITFLAG   1
#define DEFAULTFLAG     2
#define TUNED4SPFLAG	4

FS_PUBLIC ErrorCode itrp_SetDefaults (
    void *  pvGlobalGS,
    Fixed   fxPixelDiameter);

FS_PUBLIC void  itrp_UpdateGlobalGS(
    void *              pvGlobalGS, /* GlobalGS                             */
    void *              pvCVT,      /* Pointer to control value table       */
    void *              pvStore,    /* Pointer to storage                   */
    void *              pvFuncDef,  /* Pointer to function defintions       */
    void *              pvInstrDef, /* Pointer to instruction definitions   */
    void *              pvStack,    /* Pointer to the stack                 */
	 LocalMaxProfile *	maxp,
    uint16              cvtCount,
    uint32              ulLengthFontProgram, /* Length of font program      */
    void *              pvFontProgram, /* Pointer to font program           */
    uint32              ulLengthPreProgram, /* Length of pre program        */
    void *              pvPreProgram, /* Pointer to pre program             */
	ClientIDType        clientID);    /* User ID Number                     */

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void itrp_InitializeData (void);
#endif

FS_PUBLIC ErrorCode   itrp_ExecuteFontPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecutePrePgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecuteGlyphPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    uint8 *             ptr,
    uint8 *             eptr,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PUBLIC boolean itrp_bApplyHints(
    void *      pvGlobalGS);

FS_PUBLIC void  itrp_QueryScanInfo(
    void *      pvGlobalGS,
    uint16 *    pusScanType,
    uint16 *    pusScanControl);

FS_PUBLIC void	itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8		bCompositeFlag);

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster);

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scale.h ===
/*

	Copyright:  (c) 1992-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				7/10/99  BeatS	Add support for native SP fonts, vertical RGB
	   <1>     02/21/97    CB   claudebe, scaled component in composite glyphs
	   <1>     12/14/95    CB   add private phantom points for vertical positionning
*/

/* total number of phantom points */

typedef enum { evenMult90DRotation = 0, oddMult90DRotation, arbitraryRotation } RotationParity;

#define PHANTOMCOUNT 8

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm);        /* OUT: Pixels Per Em       */

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem);                 /* Current units per Em     */

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT);

FS_PUBLIC void  scl_ScaleCVT (
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT);

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH, /* Non-scaled Advance Height    */
	int16               sNonScaledTopOriginX); /* Non-scaled Top Origin X  */

FS_PUBLIC void  scl_ScaleOldCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleOldPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution);

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParityParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset);        /* Y Offset             */

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset);        /* Y Offset             */


FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             xShift,
	F26Dot6             yShift);

FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,
	int16               sMaxPoints,
	int16               sMaxContours);

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType *   pElement,           /* Element              */
	uint16              usNumberOfPoints,   /* Number of Points     */
	uint16              usNumberOfContours);/* Number of Contours   */

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement);            /* Element pointer  */

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement);

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               pbyOutline);

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline);

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing);

FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine);

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine);

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth);

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight);

FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY);

FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement);

FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans);

FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement);   /* Element  */

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scanlist.c ===
/*********************************************************************

	  scanlist.c -- New Scan Converter ScanList Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/22/93  deanb   all dropouts confined to bounding box
	   6/10/93  deanb   fsc_InitializeScanlist added, stdio & assert gone
	   4/26/93  deanb   fix pointers now works with segmented memory
	   4/19/93  deanb   banding added
	   4/07/93  deanb   sorting is now done on the fly
	   4/01/93  deanb   intersection arrays replace linked lists
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   memory requirements reworked
	  10/19/92  deanb   smart dropout tiebreak left & down
	  10/14/92  deanb   delete usScanKind from state
	  10/09/92  deanb   reentrant
	  10/08/92  deanb   reworked for split workspace
	  10/02/92  deanb   correct AddVertDropoutScan assertions
	   9/25/92  deanb   separate nodrop/dropout entry points
	   9/22/92  deanb   smart dropout control
	   9/17/92  deanb   stub control
	   9/15/92  deanb   simple dropout control
	   9/11/92  deanb   setupscan handles scankind
	   9/09/92  deanb   dropout / nodropout begun
	   8/17/92  deanb   include struc.h scconst.h
	   8/07/92  deanb   initial dropout control
	   8/06/92  deanb   assertions reinstated
	   7/27/92  deanb   bitmap clear added
	   7/16/92  deanb   gulBytesRemaining -> gulIntersectRemaining
	   6/18/92  deanb   int x coord for HorizScanAdd
	   6/01/92  deanb   incorporate bitmap functions
	   5/08/92  deanb   reordered includes for precompiled headers
	   5/04/92  deanb   Array tags added
	   4/28/92  deanb   list array sentinels added
	   4/21/92  deanb   single HorizScanAdd routine
	   4/15/92  deanb   calls to BitMap
	   4/13/92  deanb   uiY to iY for HorizScanOn/Off
	   4/09/92  deanb   New types
	   4/03/92  deanb   HorizScan On/Off coded
	   3/31/92  deanb   InitScanArray begun
	   3/25/92  deanb   GetWorkSizes and local types
	   3/23/92  deanb   First cut

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scbitmap.h"            /* bit blt operations */
#include    "scmemory.h"            /* for allocations */

/*********************************************************************/

/*      Contour reversal list structures                             */

/*********************************************************************/

typedef struct Rev                  /* Reversal list entry */
{
	int16 sScan;                    /* scan line */
	int16 sCross;                   /* direction +1 or -1 */
	struct Rev *prevLink;           /* link to next reversal */
}
Reversal;

struct RevRoots                     /* Reversal list roots */
{
	Reversal *prevYRoot;            /* Y direction contour reversals */
	Reversal *prevXRoot;            /* X direction contour reversals */
	Reversal *prevNext;             /* Next available list item */
	Reversal *prevEnd;              /* End of buffer (for overflow check) */
	struct RevRoots *prrSelf;       /* to check for moved memory */
};

#include    "scanlist.h"            /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void AddReversal (Reversal**, Reversal*, F26Dot6, int16);
FS_PRIVATE int32 GetIxEstimate(Reversal*);
FS_PRIVATE void FixPointers(PRevRoot);

FS_PRIVATE void AddHorizSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSimpleBand(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartBand(PSTATE int32, int32);

FS_PRIVATE int32 LookForDropouts(PSTATE char*, uint16);
FS_PRIVATE int32 DoHorizDropout(PSTATE int16*, int16*, int32, char*, uint16);
FS_PRIVATE int32 DoVertDropout(PSTATE int16*, int16*, int32, char*, uint16);

FS_PRIVATE int32 HorizCrossings(PSTATE int32, int32);
FS_PRIVATE int32 VertCrossings(PSTATE int32, int32);

FS_PRIVATE uint32 GetBitAbs(PSTATE char*, int32, int32);
FS_PRIVATE int32 SetBitAbs(PSTATE char*, int32, int32);


/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_InitializeScanlist()
{
	fsc_InitializeBitMasks();
}


/*********************************************************************/

/*      Contour Reversal Functions                                   */

/*********************************************************************/

/* setup the contour reversal list roots structure */

FS_PUBLIC PRevRoot  fsc_SetupRevRoots (
		char* pchRevBuf,
		int32 lRevBufSize )
{
	PRevRoot prrRoots;
	Reversal *prevSentinel;
	
	prrRoots = (PRevRoot) pchRevBuf;                /* workspace begin */
	prevSentinel = (Reversal*) (prrRoots + 1);      /* just past the roots */

	prrRoots->prevYRoot = prevSentinel;             /* point to sentinel */
	prrRoots->prevXRoot = prevSentinel;             /* for both lists */
	prevSentinel->sScan = HUGEINT;                  /* stop value */
	prevSentinel->sCross = 0;
	prevSentinel->prevLink = NULL;
	prrRoots->prevNext = prevSentinel + 1;          /* to next free record */
	
	prrRoots->prevEnd = (Reversal*)(pchRevBuf + lRevBufSize);
	prrRoots->prrSelf = prrRoots;                   /* for address validation */
	
	return prrRoots;
}

/*********************************************************************/

/* insert into y list one countour reversal structure */

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevYRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x list one countour reversal structure */

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevXRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x or y list one countour reversal structure */

FS_PRIVATE void AddReversal (
		Reversal **pprevList,
		Reversal *prevNext,
		F26Dot6 fxCoord,
		int16 sDir )
{
	int16 sScan;

	sScan = (int16)((fxCoord + SUBHALF + (sDir >> 1)) >> SUBSHFT);

	while(sScan > (*pprevList)->sScan)          /* will stop before sentinel */
	{
		pprevList = &((*pprevList)->prevLink);  /* else link to next */
	}
	prevNext->sScan = sScan;                    /* save scanline */
	prevNext->sCross = -sDir;                   /* count up from bottom */
	prevNext->prevLink = *pprevList;            /* link rest of list */

	*pprevList = prevNext;                      /* insert new item */
}

/*********************************************************************/

/* return the total number of reversals in the lists */

FS_PUBLIC int32 fsc_GetReversalCount (PRevRoot prrRoots)
{
	return (int32)(( prrRoots->prevNext - 1 -           /* don't count sentinel */
			 (Reversal*)((char*)prrRoots + sizeof(struct RevRoots))) );
}

/*********************************************************************/

/* calculate anticipated horizontal intersections */

FS_PUBLIC int32 fsc_GetHIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevYRoot ) );
}

/*********************************************************************/

/* calculate anticipated vertical intersections */

FS_PUBLIC int32 fsc_GetVIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevXRoot ) );
}

/*********************************************************************/

/* calculate anticipated intersections */

FS_PRIVATE int32 GetIxEstimate(Reversal *prevList)
{
	int32 lTotalIx;
	
	lTotalIx = 0L;
	while (prevList->sScan < HUGEINT)       /* look through list */
	{
		if (prevList->sCross == 1)          /* adding up columns! */
		{
			lTotalIx -= (int32)prevList->sScan;
		}
		else
		{
			lTotalIx += (int32)prevList->sScan;
		}
		prevList = prevList->prevLink;
	}
	return(lTotalIx);
}

/*********************************************************************/

/* calculate horizontal intersections for banding */

FS_PUBLIC int32 fsc_GetHIxBandEst(
		PRevRoot prrRoots,
		Rect* prectBox,
		  int32 lBandWidth
)
{
	Reversal *prevHiList;               /* high band reversal pointer */
	Reversal *prevLoList;               /* low band reversal pointer */
	int16 sHiScan;                      /* current top of band */
	int16 sLoScan;                      /* current bottom of band */
	int16 sHiCross;                     /* top of band's crossings */
	int16 sLoCross;                     /* bottom of band's crossings*/
	int32 lTotalIx;                     /* intersection count for each band */
	int32 lBiggestIx;                   /* largest intersection count */

	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	lTotalIx = 0;
	prevHiList = prrRoots->prevYRoot;
	sHiScan = prectBox->bottom;
	sHiCross = 0;
	while (lBandWidth > 0)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in this line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)sHiCross;            /* add up first band's crossings */
		sHiScan++;
		lBandWidth--;
	}
	lBiggestIx = lTotalIx;

	prevLoList = prrRoots->prevYRoot;
	sLoScan = prectBox->bottom;
	sLoCross = 0;
	while (sHiScan < prectBox->top)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in high line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		while (prevLoList->sScan <= sLoScan)
		{
			sLoCross += prevLoList->sCross;     /* add in low line's crossings */
			prevLoList = prevLoList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)(sHiCross - sLoCross);
		if (lTotalIx > lBiggestIx)
		{
			lBiggestIx = lTotalIx;              /* save the largest value */
		}
		sHiScan++;
		sLoScan++;
	}
	return(lBiggestIx);
}

/*********************************************************************/

/*      return number of bytes used by reversal lists                */

FS_PUBLIC int32 fsc_GetRevMemSize(PRevRoot prrRoots)
{
	return (int32)((char*)(prrRoots->prevNext) - (char*)prrRoots);
}

/*********************************************************************/

/*  when reversal list has moved, recalculate the pointers           */

FS_PRIVATE void FixPointers(PRevRoot prrRoots)
{
	char *pchNewBase;
	char *pchOldBase;
	Reversal *prevList;

	pchNewBase = (char*)prrRoots;
	pchOldBase = (char*)prrRoots->prrSelf;          /* pre-move base addr */

	prrRoots->prevYRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevYRoot - pchOldBase));
	prrRoots->prevXRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevXRoot - pchOldBase));
	prrRoots->prevNext = (Reversal*)(pchNewBase + ((char*)prrRoots->prevNext - pchOldBase));
	prrRoots->prevEnd = (Reversal*)(pchNewBase + ((char*)prrRoots->prevEnd - pchOldBase));
	
	prevList = prrRoots->prevYRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prevList = prrRoots->prevXRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prrRoots->prrSelf = prrRoots;                   /* for next time */
}

/*********************************************************************/

/*      Workspace Calcluation Functions                              */

/*********************************************************************/

/* calculate horizontal scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanHMem(
		uint16 usScanKind,      /* scan type */
		int32 lHScan,           /* number of horiz scanlines */
		int32 lHInter )         /* number of horiz intersections */
{
	ALIGN(voidPtr, lHScan); 
	ALIGN(voidPtr, lHInter ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (4 * sizeof(int16)));     /* for ix/code arrays */
	}
}


/*********************************************************************/

/* calculate vertical scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanVMem(
		uint16 usScanKind,      /* scan type */
		int32 lVScan,           /* number of vert scanlines */
		int32 lVInter,          /* number of vert intersections */
		int32 lElemPts )        /* number of contour element points */
{
	ALIGN(voidPtr, lVScan); 
	ALIGN(voidPtr, lVInter); 
	ALIGN(voidPtr, lElemPts ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (4 * sizeof(int16)) +     /* for ix/code arrays */
				lElemPts * (2 * sizeof(F26Dot6)));  /* for element (x, y) */
	}
}

/*********************************************************************/

/*      Scan Conversion Preparation Functions                        */

/*********************************************************************/

/*  Line, Spline, and Endpoint register their callbacks here */

FS_PUBLIC void fsc_SetupCallBacks(
		PSTATE                       /* pointer to state variables */
		int16 sCode,                 /* element code (line, spline, endpoint) */
		F26Dot6 (*pfnHoriz)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*pfnVert)(int32, F26Dot6*, F26Dot6*)     /* vert callback */
)
{
	STATE.pfnHCallBack[sCode] = pfnHoriz;
	STATE.pfnVCallBack[sCode] = pfnVert;
}


/*********************************************************************/

/*  Allocate scan workspace memory and set up pointer arrays */

FS_PUBLIC int32 fsc_SetupScan(
		PSTATE                      /* pointer to state variables */
		Rect* prectBox,             /* bounding box */
		uint16 usScanKind,          /* dropout control value */
		int32 lHiBand,              /* top scan limit */
		int32 lLoBand,              /* bottom scan limit */
		boolean bSaveRow,           /* save last bitmap row for dropout */
		int32 lRowBytes,            /* for last row alloc */
		int32 lHInterCount,         /* estimate of horiz intersections */
		int32 lVInterCount,         /* estimate of vert intersections */
		int32 lElemCount,           /* estimate of element points */
		PRevRoot prrRoots           /* reversal list roots */
)
{
	int32 lHorizBandCount;          /* number of horizontal scan lines */
	int32 lVertScanCount;           /* number of vertical scan lines */
	int32 lPointerArraySize;        /* bytes per pointer array */

	int16 sScan;                    /* current scan line */
	int16 sCross;                   /* crossings on this line */
	int16 *psScanIx;                /* temp scan intersection array */
	Reversal *prevList;             /* pointer to reversal list */
	
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
	int16 **ppsHOffEnd;
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffBegin;
	int16 **ppsVOffEnd;


	STATE.lBoxTop = (int32)prectBox->top;   /* copy the bounding box */
	STATE.lBoxBottom = (int32)prectBox->bottom;
	STATE.lBoxLeft = (int32)prectBox->left;
	STATE.lBoxRight = (int32)prectBox->right;
	
	STATE.lHiScanBand = lHiBand;    /* copy scan band limits */
	STATE.lLoScanBand = lLoBand;
	
/*  set STATE according to dropout and banding requirements */

	if ((usScanKind & SK_NODROPOUT) || !(usScanKind & SK_SMART))
	{
		STATE.sIxSize = 1;          /* one int16 per intersection */
		STATE.sIxShift = 0;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSimpleScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSimpleBand;
		}
		STATE.pfnAddVert = AddVertSimpleScan;
	}
	else        /* if smart dropout */
	{
		STATE.sIxSize = 2;          /* two int16's per intersection */
		STATE.sIxShift = 1;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSmartScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSmartBand;
		}
		STATE.pfnAddVert = AddVertSmartScan;
	}

/* setup horizontal intersection array for all cases */
	
	lHorizBandCount = STATE.lHiScanBand - STATE.lLoScanBand;
	Assert(lHorizBandCount > 0);
	
	lPointerArraySize = lHorizBandCount * sizeof(int16*);
	STATE.apsHOnBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOnEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	
	STATE.lPoint = 0L;                      /* initial element index */
	STATE.lElementPoints = lElemCount;

	psScanIx = (int16*) fsc_AllocHMem(ASTATE lHInterCount << (STATE.sIxShift + 2));
			
	if (prrRoots != prrRoots->prrSelf)      /* if reversals have moved */
	{
		FixPointers(prrRoots);              /* then patch up the pointers */
	}
	prevList = prrRoots->prevYRoot;         /* root of y list reversals */
	sCross = 0;
	
	ppsHOnBegin = STATE.apsHOnBegin;        /* for init speed */
	ppsHOnEnd = STATE.apsHOnEnd;
	ppsHOffBegin = STATE.apsHOffBegin;
	ppsHOffEnd = STATE.apsHOffEnd;

/* initialize horizontal scan arrays */
	
	for (sScan = (int16)STATE.lLoScanBand; sScan < (int16)STATE.lHiScanBand; sScan++)
	{
		while (prevList->sScan <= sScan)
		{
			sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
			prevList = prevList->prevLink;                  /* link to next reversal */
		}
		*ppsHOnBegin = psScanIx;
		ppsHOnBegin++;
		*ppsHOnEnd = psScanIx;
		ppsHOnEnd++;
		psScanIx += sCross;
				
		*ppsHOffBegin = psScanIx;
		ppsHOffBegin++;
		*ppsHOffEnd = psScanIx;
		ppsHOffEnd++;
		psScanIx += sCross;
	}
	
/* if doing dropout control, setup X intersection array */

	if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
	{
		lVertScanCount = (int32)(prectBox->right - prectBox->left);
		Assert(lVertScanCount > 0);

		lPointerArraySize = lVertScanCount * sizeof(int16*);
		STATE.apsVOnBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOnEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);

		if (bSaveRow)                           /* if fast banding & dropout */
		{
			STATE.pulLastRow = (uint32*) fsc_AllocVMem(ASTATE lRowBytes);
			STATE.lLastRowIndex = HUGEFIX;      /* impossible value => uninitialized */
		}
		psScanIx = (int16*) fsc_AllocVMem(ASTATE lVInterCount << (STATE.sIxShift + 2));
				
		prevList = prrRoots->prevXRoot;         /* root of x list reversals */
		sCross = 0;
		sScan = prectBox->left;
	
		ppsVOnBegin = STATE.apsVOnBegin;        /* for init speed */
		ppsVOnEnd = STATE.apsVOnEnd;
		ppsVOffBegin = STATE.apsVOffBegin;
		ppsVOffEnd = STATE.apsVOffEnd;
	
		for (sScan = prectBox->left; sScan < prectBox->right; sScan++)
		{
			while (prevList->sScan <= sScan)
			{
				sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
				prevList = prevList->prevLink;                  /* link to next reversal */
			}
			*ppsVOnBegin = psScanIx;
			ppsVOnBegin++;
			*ppsVOnEnd = psScanIx;
			ppsVOnEnd++;
			psScanIx += sCross;
					
			*ppsVOffBegin = psScanIx;
			ppsVOffBegin++;
			*ppsVOffEnd = psScanIx;
			ppsVOffEnd++;
			psScanIx += sCross;
		}
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
			STATE.afxXPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
			STATE.afxYPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/* This function saves the first contour point for smart dropout calcs */

FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                              /* pointer to state variables */
		uint16 usScanKind,                  /* scan type */
		F26Dot6 fxX1,                       /* starting point x coordinate */
		F26Dot6 fxY1                        /* starting point y coordinate */
)
{
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART)) /* if smart dropout */
	{
		STATE.afxXPoints[STATE.lPoint] = fxX1;
		STATE.afxYPoints[STATE.lPoint] = fxY1;
		STATE.lPoint++;
		Assert (STATE.lPoint <= STATE.lElementPoints);
	}
}

/*********************************************************************/
	
/* This function is called at the beginning of each line, subdivided */
/* spline, or endpoint-on-scanline.  It sets scanline state variables, */
/* save control points (for smart dropout control), and return the */
/* appropriate AddScan function pointers */

FS_PUBLIC void fsc_BeginElement(
	PSTATE                                      /* pointer to state variables */
	uint16 usScanKind,                          /* type of dropout control */
	int32 lQuadrant,                            /* determines scan on/off */
	int32 lElementCode,                         /* element (line, spline, ep) */
	int32 lPts,                                 /* number of points to store */
	F26Dot6 *pfxX,                              /* next x control point(s) */
	F26Dot6 *pfxY,                              /* next y control point(s) */
	void (**ppfnAddHorizScan)(PSTATE int32, int32),  /* horiz add scan return */
	void (**ppfnAddVertScan)(PSTATE int32, int32)    /* vert add scan return */
)
{
	*ppfnAddHorizScan = STATE.pfnAddHoriz;      /* set horiz add scan func */
	*ppfnAddVertScan = STATE.pfnAddVert;        /* set vert add scan func */

	
	if ((lQuadrant == 1) || (lQuadrant == 2))
	{
		STATE.apsHorizBegin = STATE.apsHOnBegin;    /* add 'on' interscections */
		STATE.apsHorizEnd = STATE.apsHOnEnd;
	}
	else
	{
		STATE.apsHorizBegin = STATE.apsHOffBegin;   /* add 'off' interscections */
		STATE.apsHorizEnd = STATE.apsHOffEnd;
	}
	
	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		if ((lQuadrant == 2) || (lQuadrant == 3))
		{
			STATE.apsVertBegin = STATE.apsVOnBegin; /* add 'on' interscections */
			STATE.apsVertEnd = STATE.apsVOnEnd;
		}
		else
		{
			STATE.apsVertBegin = STATE.apsVOffBegin; /* add 'off' interscections */
			STATE.apsVertEnd = STATE.apsVOffEnd;
		}
		
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
            Assert((STATE.lPoint - 1) <= (0xFFFF >> SC_CODESHFT));
			STATE.usScanTag = (uint16)(((STATE.lPoint - 1) << SC_CODESHFT) | lElementCode);

			while (lPts > 0)                    /* save control points */
			{
				STATE.afxXPoints[STATE.lPoint] = *pfxX;
				pfxX++;
				STATE.afxYPoints[STATE.lPoint] = *pfxY;
				pfxY++;
				STATE.lPoint++;
				lPts--;
				Assert (STATE.lPoint <= STATE.lElementPoints);
			}
		}
	}
}


/*********************************************************************/

/*      Add Scanline Intersection Functions                          */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

/* printf("H(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	lY -= STATE.lBoxBottom;         /* normalize */
	psBegin = STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */
	
	psLead = psEnd - 1;
	sX = (int16)lX;
	
	while((psLead >= psBegin) && (*psLead > sX))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sX;                    /* store new value */
}

/*********************************************************************/

/*  Sort a simple intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sY;

/* printf("V(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);

	lX -= STATE.lBoxLeft;           /* normalize */
	psBegin = STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */

	psLead = psEnd - 1;
	sY = (int16)lY;
	
	while((psLead >= psBegin) && (*psLead > sY))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sY;                    /* store new value */
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);
	
	lY -= STATE.lBoxBottom;         /* normalize */
	pulBegin = (uint32*)STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sX = (int16)lX;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sX;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Sort a smart intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sY;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);
	
	lX -= STATE.lBoxLeft;         /* normalize */
	pulBegin = (uint32*)STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sY = (int16)lY;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sY))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sY;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Add an intersection with banding                                 */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSimpleBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		psBegin = STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		psEnd = *ppsEnd;
		(*ppsEnd)++;                /* bump ptr for next time */
		
		psLead = psEnd - 1;
		sX = (int16)lX;

		while((psLead >= psBegin) && (*psLead > sX))
		{
			*psEnd-- = *psLead--;   /* make room */
		}
		*psEnd = sX;                /* store new value */
	}
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSmartBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;               /* pts to first array element */
	uint32 *pulEnd;                 /* pts past last element */
	uint32 *pulLead;                /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		pulBegin = (uint32*)STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		pulEnd = (uint32*)*ppsEnd;
		(*ppsEnd) += 2;             /* value & tag */

		pulLead = pulEnd - 1;
		sX = (int16)lX;

		while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
		{
			*pulEnd-- = *pulLead--;  /* make room */
		}
		psInsert = (int16*)pulEnd;
		*psInsert = sX;              /* store new value */
		psInsert++;
		*psInsert = STATE.usScanTag; /* keep tag too */
	}
}


/*********************************************************************/

/*  When all contours have been scanned, fill in the bitmap          */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap(
		PSTATE                          /* pointer to state variables */
		char *pchBitMap,                /* target memory */
		int32 lHiBand,                  /* top bitmap limit */
		int32 lLoBand,                  /* bottom bitmap limit */
		int32 lRowBytes,                /* bitmap bytes per row */
		int32 lOrgLoBand,               /* original low band row */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lHeight;                      /* of scan band in pixels */
	int32 lIndex;                       /* array index */
	int32 lFirstScan;                   /* first scanline index */

	int16 sXOffset;                     /* bitmap box shift */
	int16 sXStart;                      /* on transition */
	int16 sXStop;                       /* off transition */
	
	uint32 *pulRow;                     /* row beginning pointer */
	uint32 ulBMPLongs;                  /* longs per bitmap */
	int32 lRowLongs;                    /* long words per row */
	int32 lErrCode;
	
	int16 **ppsHOnBegin;                /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	

/*  printf("%li : %li\n", lHiBand, lLoBand); */
	
	STATE.lHiBitBand = lHiBand;                 /* copy bit band limits */
	STATE.lLoBitBand = lLoBand;
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	
	STATE.lRowBytes = lRowBytes;                /* save bytes per row */
	lRowLongs = lRowBytes >> 2;                 /* long words per row */
	
	ulBMPLongs = (uint32)(lRowLongs * (int32)lHeight);
	pulRow = (uint32*)pchBitMap;                /* start at glyph top */
	lErrCode = fsc_ClearBitMap(ulBMPLongs, pulRow);
	if (lErrCode != NO_ERR) return lErrCode;

	sXOffset = (int16)STATE.lBoxLeft;
	
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
						
/*  now go through the bitmap from top to bottom */

	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
				
		Assert(psHorizOnEnd <= psHorizOff);
		Assert(psHorizOnEnd - psHorizOn == STATE.apsHOffEnd[lFirstScan - lIndex] - psHorizOff);

		while (psHorizOn < psHorizOnEnd)
		{
			sXStart = *psHorizOn - sXOffset;
			psHorizOn += STATE.sIxSize;
			sXStop = *psHorizOff - sXOffset;
			psHorizOff += STATE.sIxSize;

			if (sXStart < sXStop)                   /* positive run */
			{
				lErrCode = fsc_BLTHoriz(sXStart, sXStop - 1, pulRow);
			}
			else if (sXStart > sXStop)              /* negative run */
			{
				lErrCode = fsc_BLTHoriz(sXStop, sXStart - 1, pulRow);
			}
			if (lErrCode != NO_ERR) return lErrCode;
		}
		pulRow += lRowLongs;                        /* next row */
	}
	
/* if doing dropout control, do it now */

	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lErrCode = LookForDropouts(ASTATE pchBitMap, usScanKind);
		if (lErrCode != NO_ERR) return lErrCode;
		
		if (lOrgLoBand != STATE.lLoScanBand)        /* if fast banding & dropout */
		{
			pulRow -= lRowLongs;                    /* back to overscan row */
			pulRow -= lRowLongs;                    /* back to low row */
			lErrCode = fsc_BLTCopy (pulRow, STATE.pulLastRow, lRowLongs);
			if (lErrCode != NO_ERR) return lErrCode;

			STATE.lLastRowIndex = STATE.lLoBitBand + 1; /* save row ID */
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Dropout Control Functions                                    */

/*********************************************************************/
	
FS_PRIVATE int32 LookForDropouts(
		PSTATE                      /* pointer to state variables  */
		char *pchBitMap,
		uint16 usScanKind )         /* dropout control value */
{
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffEnd;
			
	int16 *psVertOn;
	int16 *psVertOff;
	int16 *psVertOnBegin;

	int32 lHeight;
	int32 lWidth;
	int32 lIndex;                   /* array index */
	int32 lFirstScan;               /* first scanline index */
	
	int32 lErrCode;

/*  Check horizontal scan lines for dropouts  */
	
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
		
	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
		
		while (psHorizOn < psHorizOnEnd)
		{
			if (*psHorizOn == *psHorizOff)  /* zero length run */
			{
				lErrCode = DoHorizDropout(ASTATE psHorizOn, psHorizOff,
										 STATE.lHiBitBand - lIndex - 1,
										 pchBitMap,
										 usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psHorizOn += STATE.sIxSize;
			psHorizOff += STATE.sIxSize;
		}
	}
		
/*  Check vertical scan lines for dropouts  */
	
	lWidth = STATE.lBoxRight - STATE.lBoxLeft;
	ppsVOnBegin = STATE.apsVOnBegin;
	ppsVOnEnd = STATE.apsVOnEnd;
	ppsVOffEnd = STATE.apsVOffEnd;
	
	for (lIndex = 0; lIndex < lWidth; lIndex++)
	{
		psVertOnBegin = *ppsVOnBegin;
		ppsVOnBegin++;
		psVertOn = *ppsVOnEnd - STATE.sIxSize;  /* start at end (glyph top) */
		ppsVOnEnd++;
		psVertOff = *ppsVOffEnd - STATE.sIxSize;
		ppsVOffEnd++;
		
		while (psVertOn >= psVertOnBegin)       /* from top to bottom */
		{
			if (*psVertOn == *psVertOff)        /* zero length run */
			{
				lErrCode = DoVertDropout(ASTATE psVertOn, psVertOff,
										 STATE.lBoxLeft + lIndex,
										 pchBitMap, usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psVertOn -= STATE.sIxSize;
			psVertOff -= STATE.sIxSize;
		}
	}
	return NO_ERR;
}


/*********************************************************************/

FS_PRIVATE int32 DoHorizDropout(
		PSTATE                  /* pointer to state variables */
		int16 *psOn,            /* pointer to on intersection */
		int16 *psOff,           /* pointer to off intersection */
		int32 lYDrop,           /* y coord of dropout */
		char *pchBitMap,        /* target memory */
		uint16 usScanKind )     /* dropout control value */
{
	int32 lXDrop;                                   /* x coord of dropout */
	int32 lCross;                                   /* scanline crossings */
	F26Dot6 fxX1, fxX2;                             /* for smart dropout */
	uint16 usOnTag, usOffTag;                       /* element info */
	int16 sOnPt, sOffPt;                            /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);    /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*);   /* off callback */

	lXDrop = (int32)*psOn;
	
/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop + 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation above */
		}
		
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation below */
		}
	}

/*  passed stub control, now check pixels left and right  */

	if (lXDrop > STATE.lBoxLeft)                /* if pixel to left */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop - 1, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}
	if (lXDrop < STATE.lBoxRight)               /* if pixel to right */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}

/*  no pixels left or right, now determine bit placement  */

	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnHCallBack[usOnTag & SC_CODEMASK];
		fxX1 = pfnOn(lYDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnHCallBack[usOffTag & SC_CODEMASK];
		fxX2 = pfnOff(lYDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lXDrop = (int32)((fxX1 + fxX2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lXDrop--;                               /* always to the left */
	}
	
	if (lXDrop < STATE.lBoxLeft)                /* confine to bounding box */
	{
		lXDrop = STATE.lBoxLeft;
	}
	if (lXDrop >= STATE.lBoxRight)
	{
		lXDrop = STATE.lBoxRight - 1L;
	}

	return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
}


/*********************************************************************/

FS_PRIVATE int32 DoVertDropout(
		PSTATE                      /* pointer to state variables */
		int16 *psOn,                /* pointer to on intersection */
		int16 *psOff,               /* pointer to off intersection */
		int32 lXDrop,               /* x coord of dropout */
		char *pchBitMap,            /* target memory descriptor */
		uint16 usScanKind )         /* dropout control value */
{
	int32 lYDrop;                                 /* y coord of dropout */
	int32 lCross;                                 /* scanline crossings */
	F26Dot6 fxY1, fxY2;                           /* for smart dropout */
	uint16 usOnTag, usOffTag;                     /* element info */
	int16 sOnPt, sOffPt;                          /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);  /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*); /* off callback */
	
	lYDrop = (int32)*psOn;

	if ((lYDrop < STATE.lLoBitBand) || (lYDrop > STATE.lHiBitBand))
	{
		return NO_ERR;                          /* quick return for outside band */
	}

/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to left */
		}
		
		lCross = VertCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to right */
		}
	}

/*  passed stub control, now check pixels below and above  */

	if (lYDrop > STATE.lBoxBottom)                  /* if pixel below */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop - 1) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}
	if (lYDrop < STATE.lBoxTop)                     /* if pixel above */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}

/*  no pixels above or below, now determine bit placement  */
	
	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnVCallBack[usOnTag & SC_CODEMASK];
		fxY1 = pfnOn(lXDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnVCallBack[usOffTag & SC_CODEMASK];
		fxY2 = pfnOff(lXDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lYDrop = (int32)((fxY1 + fxY2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lYDrop--;                               /* always below */
	}
	
	if (lYDrop < STATE.lBoxBottom)              /* confine to bounding box */
	{
		lYDrop = STATE.lBoxBottom;
	}
	if (lYDrop >= STATE.lBoxTop)
	{
		lYDrop = STATE.lBoxTop - 1L;
	}
		
	if ((lYDrop >= STATE.lLoBitBand) && (lYDrop < STATE.lHiBitBand))
	{
		return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Count contour crossings of a horizontal scan line segment  */

FS_PRIVATE int32 HorizCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sX;
	
	if ((lY < STATE.lLoScanBand) || (lY >= STATE.lHiScanBand))
	{
		return 0;                       /* if outside the scan region */
	}
	
	lCrossings = 0;
	lIndex = lY - STATE.lLoScanBand;
	psOn = STATE.apsHOnBegin[lIndex];
	psOff = STATE.apsHOffBegin[lIndex];
	psOnEnd = STATE.apsHOnEnd[lIndex];
	sX = (int16)lX;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sX)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sX)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}


/*********************************************************************/

/*  Count contour crossings of a vertical scan line segment  */

FS_PRIVATE int32 VertCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sY;
	
	if ((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight))
	{
		return 0;                       /* if outside the bitmap */
	}
	
	lCrossings = 0;
	lIndex = lX - STATE.lBoxLeft;
	psOn = STATE.apsVOnBegin[lIndex];
	psOff = STATE.apsVOffBegin[lIndex];
	psOnEnd = STATE.apsVOnEnd[lIndex];
	sY = (int16)lY;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sY)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sY)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}
		

/****************************************************************************/

/*              Get a pixel using absolute coordinates                      */

/*  When banding with dropout control, this routine uses the last low row   */
/*  of the previous bitmap when possible.                                   */

FS_PRIVATE uint32 GetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */

	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	if ((lY < STATE.lHiBitBand) && (lY >= STATE.lLoBitBand))  /* if within the bitmap */
	{
		pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
		return fsc_GetBit(lX - STATE.lBoxLeft, pulRow);       /* read the bitmap */
	}
	if (lY == STATE.lLastRowIndex)          /* if saved from last band */
	{
		return fsc_GetBit(lX - STATE.lBoxLeft, STATE.pulLastRow);
	}
	return(0L);                             /* outside bitmap doesn't matter */
}


/*********************************************************************/

/*  Set a pixel using absolute coordinates  */

FS_PRIVATE int32 SetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */
	
	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lLoBitBand);
	Assert(lY < STATE.lHiBitBand);
	
	pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
	
	return fsc_SetBit(lX - STATE.lBoxLeft, pulRow);
}


/*********************************************************************/

/*      Gray Scale Pass Through Functions                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap (
		uint32 ulCount,                     /* longs per bmp */
		uint32* pulBitMap                   /* bitmap ptr caste long */
)
{
	return fsc_ClearBitMap(ulCount, pulBitMap);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam* pGSP                /* pointer to param block */
)
{
	return fsc_CalcGrayRow(pGSP);
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scanlist.h ===
/*********************************************************************

	  scanlist.h -- ScanList Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/10/93  deanb   fsc_InitializeScanlist added
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   uiRowBytes moved from setup to fillbitmap
	  10/09/92  deanb   PSTP added
	  10/08/92  deanb   reworked for split workspace
	   9/25/92  deanb   separate entry for nodrop/dropout 
	   9/10/92  deanb   horiz & vert callbacks 
	   9/09/92  deanb   size_t changes 
	   9/08/92  deanb   SetElemGlobals added 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   6/01/92  deanb   New/Old FillBitMap for debug comparisons 
	   4/21/92  deanb   Single HorizScan with flag 
	   4/13/92  deanb   unsigned int to int for HorizScanOn/Off 
	   3/31/92  deanb   InitScanArray Rectangle param 
	   3/23/92  deanb   GetWorkSize added 
	   3/16/92  deanb   New types 
	   1/31/92  deanb   HorizScan[On/Off] export functions 
	   1/14/92  deanb   First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */
#include "scgray.h"                 /* for gray param definition */


typedef struct RevRoots *PRevRoot;  /* opaque type */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeScanlist (
		void
);

FS_PUBLIC PRevRoot fsc_SetupRevRoots (
		char*,                      /* reversal list buffer space */
		int32                       /* size of buffer space */
);

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC int32 fsc_GetReversalCount (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxEstimate  (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetVIxEstimate (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxBandEst  (
		PRevRoot,                   /* pointer to reversal roots */
		Rect*,                      /* bitmap bounding box */
		int32                                /* band width in scan lines */
);

FS_PUBLIC int32 fsc_GetRevMemSize(
		PRevRoot                    /* pointer to reversal roots */
);


/*********************************************************************/

FS_PUBLIC int32 fsc_GetScanHMem( 
		uint16,                     /* scan type */
		int32,                      /* number of horiz scanlines */
		int32                       /* number of horiz intersections */
);

FS_PUBLIC int32 fsc_GetScanVMem( 
		uint16,                     /* scan type */
		int32,                      /* number of vert scanlines */
		int32,                      /* number of vert intersections */
		int32                       /* number of contour element points */
);

/*********************************************************************/

FS_PUBLIC void fsc_SetupCallBacks( 
		PSTATE                      /* pointer to state variables */
		int16,                      /* element code (line, spline, endpoint) */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*)    /* vert callback */
);

FS_PUBLIC int32 fsc_SetupScan( 
		PSTATE                      /* pointer to state variables */
		Rect*,                      /* bitmap bounding box */
		uint16,                     /* scan type */
		int32,                      /* band scan upper limit */
		int32,                      /* band scan lower limit */
		boolean,                    /* save over scan bitmap row */
		int32,                      /* bytes per bitmap row */
		int32,                      /* estimate of horiz intersections */
		int32,                      /* estimate of vert intersections */
		int32,                      /* estimate of element points */
		PRevRoot                    /* reversal list Roots */ 
);


FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                      /* pointer to state variables */
		uint16,                     /* scan type */
		F26Dot6,                    /* starting point x coordinate */
		F26Dot6                     /* starting point y coordinate */
);


FS_PUBLIC void fsc_BeginElement( 
		PSTATE                      /* pointer to state variables */
		uint16,                     /* type of dropout control */
		int32,                      /* determines scan on/off */   
		int32,                      /* element (line, spline, ep) */
		int32,                      /* number of points to store */
		F26Dot6*,                   /* next x control point(s) */
		F26Dot6*,                   /* next y control point(s) */
		void (**)(PSTATE int32, int32),    /* horiz add scan return */
		void (**)(PSTATE int32, int32)     /* vert add scan return */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap( 
		PSTATE                      /* pointer to state variables */
		char*,                      /* target memory */
		int32,                      /* bitmap upper limit */
		int32,                      /* bitmap lower limit */
		int32,                      /* bitmap bytes per row */
		int32,                      /* original low band row */
		uint16                      /* scan type */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap ( 
		uint32,                     /* longs per bmp */
		uint32*                     /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam*             /* pointer to param block */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scbitmap.h ===
/*********************************************************************

	  scbitmap.h -- BitMap Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/19/93 deanb    fsc_CalcGrayRow added
	   6/10/93 deanb    fsc_InitializeBitMasks added
	   4/29/93 deanb    BLTCopy routine added
	   9/15/92 deanb    GetBit returns uint32 
	   8/17/92 deanb    GetBit, SetBit added 
	   7/27/92 deanb    ClearBitMap call added 
	   6/02/92 deanb    Row pointer, integer limits, no descriptor 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/15/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeBitMasks (
		void
);

FS_PUBLIC int32 fsc_ClearBitMap ( 
		uint32,             /* longs per bmp */
		uint32*             /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_BLTHoriz ( 
		int32,              /* x start */
		int32,              /* x stop */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_BLTCopy ( 
		uint32*,            /* source row pointer */
		uint32*,            /* destination row pointer */
		int32               /* long word counter */
);

FS_PUBLIC uint32 fsc_GetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_SetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_CalcGrayRow(
		GrayScaleParam*     /* pointer to param block */
);


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scbitmap.c ===
/*********************************************************************

      scbitmap.c -- New Scan Converter BitMap Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

      10/03/93  deanb   use (x) in bitmask shift macros
       8/23/93  deanb   gray scale functions
       6/11/93  deanb   use MEMSET macro, string & stddef removed
       6/10/93  deanb   Start/Stop/Bit mask macros
       6/10/93  deanb   InitializeBitMasks added, stdio & assert removed
       4/29/93  deanb   BLTCopy routine added
       3/19/93  deanb   size_t caste checked
      10/14/92  deanb   memset for fsc_ClearBitMap
       9/15/92  deanb   Set bit coded 
       8/18/92  deanb   include scconst.h 
       6/02/92  deanb   Row pointer, integer limits, no descriptor 
       5/08/92  deanb   reordered includes for precompiled headers 
       5/04/92  deanb   Array tags added 
       4/27/92  deanb   Negative runs handled 
       4/16/92  deanb   Coding 
       3/23/92  deanb   First cut 

**********************************************************************/

#define FSCFG_INTERNAL

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/


#include    "fscdefs.h"             /* shared data types */
#include    "scgray.h"              /* gray scale param block */
#include    "fserror.h"             /* error codes */
#include    "scbitmap.h"            /* for own function prototypes */


/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     MASKSIZE    32              /* bits per bitmap masks */
#define     MASKSHIFT   5               /* log2 of MASKSIZE */
#define     MASKBITS    0x0000001FL     /* masks pix loc of long word */

#define     ALL_ONES    ((uint32)0xFFFFFFFFL)
#define     HIGH_ONE    ((uint32)0x80000000L)


/*********************************************************************/

/*      Bitmask definitions                                          */

/*********************************************************************/
    
#ifndef FSCFG_USE_MASK_SHIFT    /* if using bitmask tables */

#define START_MASK(x)   aulStartBits[x]
#define STOP_MASK(x)    aulStopBits[x]
#define BIT_MASK(x)     aulBitMask[x]

/*  bitmask tables */

FS_PRIVATE uint32 aulStartBits[MASKSIZE];       /* such as:  0000111 */
FS_PRIVATE uint32 aulStopBits[MASKSIZE];        /* such as:  1110000 */
FS_PRIVATE uint32 aulBitMask[MASKSIZE];         /* such as:  0001000 */


#else                           /* if using bitmask shift */

#define START_MASK(x)   (ALL_ONES >> (x))
#define STOP_MASK(x)    (ALL_ONES << ((MASKSIZE - 1) - (x)))
#define BIT_MASK(x)     (HIGH_ONE >> (x))

#endif


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*      fsc_InitializeBitMasks() loads the arrays of 32-bit masks at 
 *      runtime to create CPU independent bitmap masks.
 *
 *      It is conditionally compiled because the arrays are unused
 *      in a "USE_MASK_SHIFT" (e.g. Apple, HP) configuration. 
 *
 *      We load the arrays by converting the Big-Endian value of
 *      the mask to the "native" representation of that mask.  The
 *      "native" representation can be applied to a "native" byte
 *      array to manipulate more than 8 bits at a time of an output
 *      bitmap.
 */

FS_PUBLIC void fsc_InitializeBitMasks (void)
{
#ifndef FSCFG_USE_MASK_SHIFT

    int32 lIdx;
    uint32 ulStartMask;
    uint32 ulStopMask;
    uint32 ulBitMask;

    ulStartMask = ALL_ONES;
    ulStopMask = ALL_ONES;
    ulBitMask = HIGH_ONE;
    
    for (lIdx = 0; lIdx < MASKSIZE; lIdx++)
    {
        aulStartBits[lIdx] = (uint32) SWAPL(ulStartMask);
        aulStopBits[MASKSIZE - lIdx - 1] = (uint32) SWAPL(ulStopMask);
        aulBitMask[lIdx] = (uint32) SWAPL(ulBitMask);

        ulStartMask >>= 1;
        ulStopMask <<= 1;
        ulBitMask >>= 1;
    }
#endif
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ClearBitMap (
        uint32 ulBMPLongs, 
        uint32 *pulMap )
{
    size_t stBytes;

    stBytes = (size_t)ulBMPLongs << 2;

    Assert((uint32)stBytes == (ulBMPLongs << 2));

    MEMSET((void*)pulMap, 0, stBytes);
    
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTHoriz (
        int32 lXStart, 
        int32 lXStop, 
        uint32 *pulMap )                 
{
    int32 lSkip;

    lSkip = (lXStart >> MASKSHIFT);         /* longwords to first black */
    pulMap += lSkip;
    lXStart -= lSkip << MASKSHIFT;          /* correct start/stop */
    lXStop -= lSkip << MASKSHIFT;
    while (lXStop >= MASKSIZE)
    {
        *pulMap |= START_MASK(lXStart);
        pulMap++;
        lXStart = 0;
        lXStop -= MASKSIZE;
    }
    *pulMap |= START_MASK(lXStart) & STOP_MASK(lXStop);
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTCopy ( 
        uint32 *pulSource,         /* source row pointer */
        uint32 *pulDestination,    /* destination row pointer */
        int32 lCount )             /* long word counter */
{
    while (lCount)
    {
        *pulDestination = *pulSource;
        pulDestination++;
        pulSource++;
        lCount--;
    }
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC uint32 fsc_GetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    return(pulMap[lXCoord >> MASKSHIFT] & BIT_MASK(lXCoord & MASKBITS));
}


/*********************************************************************/

FS_PUBLIC int32 fsc_SetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    pulMap[lXCoord >> MASKSHIFT] |= BIT_MASK(lXCoord & MASKBITS);
    
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale row bitmap calculation                                */
/*  Count one row of over scale pixels into gray scale row           */

/*********************************************************************/
                
FS_PUBLIC int32 fsc_CalcGrayRow(
        GrayScaleParam* pGSP
)
{            
    char        *pchOver;               /* pointer to overscaled bitmap */
    char        *pchGray;               /* pointer to gray scale bitmap */
    uint16      usShiftMask;            /* masks off over scaled bits of interest */
    uint16      usGoodBits;             /* number of valid bits in usOverBits */
    uint16      usOverBits;             /* a byte of overscaled bitmap */
    int16       sGrayColumns;           /* number of gray columns to calc */
    
    static char chCount[256] = {        /* count of one bits */    
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    pchGray = pGSP->pchGray;
    pchOver = pGSP->pchOver;
    sGrayColumns = pGSP->sGrayCol;
    usShiftMask = 0x00FF >> (8 - pGSP->usOverScale);  /* over bits per gray pix */
    usGoodBits = 8 - pGSP->usFirstShift;
    usOverBits = ((uint16)*pchOver) >> pGSP->usFirstShift;
                
    Assert (pchGray >= pGSP->pchGrayLo);
    Assert (pchGray < pGSP->pchGrayHi);
    
    *pchGray += chCount[usOverBits & usShiftMask];
    pchGray--;                              /* move backwards through both bitmaps! */
    sGrayColumns--;

    while (sGrayColumns > 0)                /* for each gray column (after 1st) */
    {
        usGoodBits -= pGSP->usOverScale;
        if (usGoodBits > 0)                 /* if bits remain in over byte */
        {
            usOverBits >>= pGSP->usOverScale;
        }
        else                                /* if we've looked at everything */
        {
            pchOver--;

            Assert (pchOver >= pGSP->pchOverLo);
            Assert (pchOver < pGSP->pchOverHi);

            usOverBits = (uint16)*pchOver;
            usGoodBits = 8;
        }

        Assert (pchGray >= pGSP->pchGrayLo);
        Assert (pchGray < pGSP->pchGrayHi);

        *pchGray += chCount[usOverBits & usShiftMask];  /* accumulate count */
        pchGray--;
        sGrayColumns--;
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scendpt.c ===
/*********************************************************************

	  scendpt.c -- New Scan Converter EndPoint Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  10/28/92  deanb   reentrant params renamed
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/14/92  deanb   check vert topology written 
	   9/10/92  deanb   first dropout code 
	   8/18/92  deanb   include struc.h, scconst.h 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   5/08/92  deanb   reordered includes for precompiled headers 
	   4/21/92  deanb   Single HorizScanAdd 
	   4/09/92  deanb   New types 
	   4/06/92  deanb   Check Topology corrected 
	   4/02/92  deanb   Coded 
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scendpt.h"             /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void CheckHorizTopology( PSTATE F26Dot6, F26Dot6, uint16 );
FS_PRIVATE void CheckVertTopology( PSTATE F26Dot6, F26Dot6, uint16 );

FS_PRIVATE void AddHorizOn( PSTATE uint16 );
FS_PRIVATE void AddHorizOff( PSTATE uint16 );
FS_PRIVATE void AddVertOn( PSTATE uint16 );
FS_PRIVATE void AddVertOff( PSTATE uint16 );

FS_PRIVATE F26Dot6 CalcHorizEpSubpix( int32, F26Dot6*, F26Dot6* );
FS_PRIVATE F26Dot6 CalcVertEpSubpix( int32, F26Dot6*, F26Dot6* );


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupEndPt (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_ENDPTCODE, CalcHorizEpSubpix, CalcVertEpSubpix);
}

/*********************************************************************/

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX,         /* starting point x coordinate */
		F26Dot6 fxY )        /* starting point y coordinate */
{
	STATE.fxX1 = fxX;                   /* last = contour start point */
	STATE.fxY1 = fxY;
	STATE.fxX0 = HUGEFIX;               /* contour begin alert */
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX2,        /* x coordinate */
		F26Dot6 fxY2,        /* y coordinate */
		uint16 usScanKind )  /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
		{
			return NO_ERR;                  /*   and just ignore them   */
		}
				
		if (STATE.fxX0 == HUGEFIX)          /* if contour begin */
		{
			STATE.fxX2Save = fxX2;          /*   keep for contour end   */
			STATE.fxY2Save = fxY2;          
		}
		else                                /* if mid contour */
		{
			CheckHorizTopology(ASTATE fxX2, fxY2, usScanKind);
		}               
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
			{
				return NO_ERR;              /*   and just ignore them   */
			}
				
			if (STATE.fxX0 == HUGEFIX)      /* if contour begin */
			{
				STATE.fxX2Save = fxX2;      /*   keep for contour end   */
				STATE.fxY2Save = fxY2;
			}
			else                            /* if mid contour */
			{
				CheckVertTopology(ASTATE fxX2, fxY2, usScanKind);
			}               
		}
	}

	STATE.fxX0 = STATE.fxX1;                /* old = last */
	STATE.fxY0 = STATE.fxY1;
	STATE.fxX1 = fxX2;                      /* last = current */
	STATE.fxY1 = fxY2;
	
	return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE                          /* pointer to state variables */
		uint16 usScanKind )             /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		CheckHorizTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			CheckVertTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Private Functions      */

/*********************************************************************/

/*      Implement the endpoint-on-horiz-scanline case table    */

FS_PRIVATE void CheckHorizTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{

/* printf("(%li, %li)", fxX2, fxY2); */

	if (fxY2 > STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 < STATE.fxX0)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxY2 < STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 > STATE.fxX0)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxY2 == STATE.fxY1) */
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			if (fxX2 > STATE.fxX1)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			if (fxX2 < STATE.fxX1)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if ((STATE.fxX1 > STATE.fxX0) && (fxX2 < STATE.fxX1))
			{
				AddHorizOff(ASTATE usScanKind);
			}
			else if ((STATE.fxX1 < STATE.fxX0) && (fxX2 > STATE.fxX1))
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/

/*      Implement the endpoint-on-vert-scanline case table      */

FS_PRIVATE void CheckVertTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{
	if (fxX2 < STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 < STATE.fxY0)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxX2 > STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 > STATE.fxY0)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxX2 == STATE.fxX1) */
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			if (fxY2 > STATE.fxY1)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			if (fxY2 < STATE.fxY1)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if ((STATE.fxY1 > STATE.fxY0) && (fxY2 < STATE.fxY1))
			{
				AddVertOff(ASTATE usScanKind);
			}
			else if ((STATE.fxY1 < STATE.fxY0) && (fxY2 > STATE.fxY1))
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */
	
	lXScan = (int32)((STATE.fxX1 + SUBHALF - 1) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 4, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lXScan = (int32)((STATE.fxX1 + SUBHALF) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 2, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF - 1) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizEpSubpix(int32 lYScan, 
									 F26Dot6 *pfxX, 
									 F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lYScan);
	FS_UNUSED_PARAMETER(pfxY);

/* printf("HorizEndpt(%li %li)\n", *pfxX, *pfxY); */

	return *pfxX;                           /* exact intersection */
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertEpSubpix(int32 lXScan, 
									F26Dot6 *pfxX, 
									F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lXScan);
	FS_UNUSED_PARAMETER(pfxX);

/* printf("VertEndpt (%li %li)\n", *pfxX, *pfxY); */

	return *pfxY;                           /* exact intersection */
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scglobal.h ===
/*********************************************************************

      scglobal.h -- Information shared by all scan converter modules

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       7/09/93 deanb    include fsconfig.h removed (fscdefs does it)
       4/19/93 deanb    banding limits added
       4/12/93 deanb    from old scconst.h + scstate.h

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */

/********************************************************************/

/*      Internal Constant Values                                    */

/********************************************************************/

#define HUGEINT         0x7FFF          /* impossibly large int16 value */
#define HUGEFIX         0x7FFFFFFFL     /* impossibly large fx value */

#define SUBPIX          64L             /* sub pixels per pix */
#define SUBHALF         32L             /* one half of SUBPIX */
#define SUBSHFT         6               /* log base two of SUBPIX */
    
#define ONSCANLINE(y)   ((y) & (SUBPIX - 1L)) == SUBHALF
#define SCANABOVE(y)    ((((y) + SUBHALF) & (-SUBPIX)) + SUBHALF)
#define SCANBELOW(y)    ((((y) - SUBHALF - 1L) & (-SUBPIX)) + SUBHALF)

/*      Math macros      */

#define FXABS(x)  ((x) >= 0L ? (x) : -(x))

/*      Module codes for subpix callbacks   */

#define SC_LINECODE     0
#define SC_SPLINECODE   1
#define SC_ENDPTCODE    2

#define SC_MAXCODES     3               /* number of codes above */
#define SC_CODESHFT     2               /* bits needed to store codes */
#define SC_CODEMASK     0x0003          /* to mask off codes */


/**********************************************************************

    The following structure defines all of the state variables for the 
    scan converter.  This structure is allocated statically for a non-
    reentrant implementation, or as an automatic variable to permit 
    reentrancy.  There are three sets of variables: one for the endpoint 
    module, one for scanlist, and one for memory.  Rules of the game are 
    that each module accesses ONLY its own variables for reading AND 
    writing.  It is possible for one module to read another's variables, 
    BUT IT WOULD BE WRONG.

**********************************************************************/

typedef struct statevar
{

/* endpoint state variables */

    F26Dot6 fxX0, fxY0;             /* point from call before last */
    F26Dot6 fxX1, fxY1;             /* point from previous call */
    F26Dot6 fxX2Save, fxY2Save;     /* for closing the contour */
                 
/* scanlist state variables */

    int32 lBoxLeft;                 /* bounding box xmin */
    int32 lBoxRight;                /* bounding box xmax */
    int32 lBoxTop;                  /* bounding box ymax */
    int32 lBoxBottom;               /* bounding box ymin */
    int32 lRowBytes;                /* bitmap bytes per row */
    int32 lHiScanBand;              /* banding upper scan limit */
    int32 lLoScanBand;              /* banding lower scan limit */
    int32 lHiBitBand;               /* banding upper bitmap limit */
    int32 lLoBitBand;               /* banding lower bitmap limit */
    int32 lLastRowIndex;            /* last row scan line index */
    uint32* pulLastRow;             /* for dropout banding */

    int16 **apsHOnBegin;            /* beginning of on pointers array */
    int16 **apsHOffBegin;           /* beginning of off pointers array */
    int16 **apsHOnEnd;              /* end of on pointers array */
    int16 **apsHOffEnd;             /* end of off pointers array */
    int16 **apsHorizBegin;          /* current pointer array */
    int16 **apsHorizEnd;            /* current pointer array */

    int16 **apsVOnBegin;            /* beginning of on pointers array */
    int16 **apsVOffBegin;           /* beginning of off pointers array */
    int16 **apsVOnEnd;              /* end of on pointers array */
    int16 **apsVOffEnd;             /* end of off pointers array */
    int16 **apsVertBegin;           /* current pointer array */
    int16 **apsVertEnd;             /* current pointer array */
              
#ifdef FSCFG_REENTRANT              /* needed to avoid circular PSTATE */
    void (*pfnAddHoriz)(struct statevar*, int32, int32);
    void (*pfnAddVert)(struct statevar*, int32, int32);
#else
    void (*pfnAddHoriz)(int32, int32);
    void (*pfnAddVert)(int32, int32);
#endif

    F26Dot6 (*pfnHCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
    F26Dot6 (*pfnVCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
        
    F26Dot6 *afxXPoints;            /* x element control points */
    F26Dot6 *afxYPoints;            /* y element control points */
    int32 lElementPoints;           /* estimate of element points */
    int32 lPoint;                   /* index to element control points */
    uint16 usScanTag;               /* stores point index, element code */
    int16 sIxSize;                  /* int16's per intersection */
    int16 sIxShift;                 /* log2 of size */

/* memory state variables */

    char *pchHNextAvailable;        /* horizontal memory pointer */
    char *pchVNextAvailable;        /* vertical memory pointer */
    char *pchHWorkSpaceEnd;         /* horizontal memory overflow */
    char *pchVWorkSpaceEnd;         /* vertical memory overflow */
}
StateVars;

/********************************************************************/

/*              Reentrancy parameters                               */

/********************************************************************/

#ifdef FSCFG_REENTRANT

#define PSTATE      StateVars *pState,
#define PSTATE0     StateVars *pState
#define ASTATE      pState,
#define ASTATE0     pState
#define STATE       (*pState)

#else 

#define PSTATE
#define PSTATE0     void
#define ASTATE
#define ASTATE0
#define STATE       State

extern  StateVars   State;              /* statically alloc'd in NewScan */

#endif 

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scgray.h ===
/*********************************************************************

	  scgray.h -- Gray Scale Parameter Block Definition

	  (c) Copyright 1993  Microsoft Corp.  All rights reserved.

	   8/23/93 deanb    First cut 

**********************************************************************/

#ifndef FSCGRAY_DEFINED
#define FSCGRAY_DEFINED


#include "fscdefs.h"                /* for type definitions */

/*********************************************************************/

/*      Gray scale calculation parameters                            */

/*********************************************************************/

typedef struct
{
	char* pchOver;                  /* pointer to overscaled bitmap */
	char* pchGray;                  /* pointer to gray scale bitmap */
	int16 sGrayCol;                 /* number of gray columns to calc */
	uint16 usOverScale;             /* outline magnification factor */
	uint16 usFirstShift;            /* first byte's shift */
	char* pchOverLo;                /* low limit of overscaled bitmap */
	char* pchOverHi;                /* high limit of overscaled bitmap */
	char* pchGrayLo;                /* low limit of gray scale bitmap */
	char* pchGrayHi;                /* high limit of gray scale bitmap */
}
GrayScaleParam;


/*********************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scentry.c ===
/*********************************************************************

      scentry.c -- New Scan Converter NewScan Module

      (c) Copyright 1992-1997  Microsoft Corp.  All rights reserved.

      10/14/97  claudebe    accessing unitialized memory
       1/31/95  deanb       added fsc_GetCoords function
       8/04/94  deanb       State initialized to more it out of bss
       8/24/93  deanb       flatcount fix to reversal detection
       8/10/93  deanb       gray scale support routines added
       6/22/93  deanb       all black bounding box, (0,0) for null glyph
       6/11/93  gregh       Removed ONCURVE definition
       6/11/93  deanb       if HiBand <= LoBand do entire bitmap
       6/10/93  deanb       fsc_Initialize added, stdio & assert gone
       4/06/92  deanb       CheckContour removed
       3/19/92  deanb       ScanArrays rather than lists
      12/22/92  deanb       MultDivide -> LongMulDiv; Rectangle -> Rect
      12/21/92  deanb       interface types aligned with rasterizer
      12/11/92  deanb       fserror.h imported, new error codes
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/04/92  deanb       remove duplicate points function added
      10/28/92  deanb       memory requirement calculation reworked
      10/19/92  deanb       bad contours ignored rather than error'd
      10/16/92  deanb       first contour point off curve fix
      10/13/92  deanb       rect.bounds correction
      10/12/92  deanb       reentrant State implemented
      10/08/92  deanb       reworked for split workspace
      10/05/92  deanb       global ListMemory replace with stListSize 
       9/25/92  deanb       scankind included in line/spline/endpoint calls 
       9/10/92  deanb       dropout coding begun 
       9/08/92  deanb       MAXSPLINELENGTH now imported from scspline.h 
       8/18/92  deanb       New i/f for dropout control, contour elems 
       7/28/92  deanb       Recursive calls for up/down & left/right 
       7/23/92  deanb       EvaluateSpline included 
       7/17/92  deanb       Included EvaluateLine 
       7/13/92  deanb       Start/End point made SHORT 
       6/01/92  deanb       fsc_FillBitMap debug switch added 
       5/08/92  deanb       reordered includes for precompiled headers 
       4/27/92  deanb       Splines coded 
       4/09/92  deanb       New types 
       4/06/92  deanb       rectBounds calc corrected 
       3/30/92  deanb       MinMax calc added to MeasureContour 
       3/24/92  deanb       GetWorkspaceSize coded 
       3/23/92  deanb       First cut 
 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for LongMulDiv */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scspline.h"            /* spline evaluation */
#include    "scline.h"              /* line evaluation */
#include    "scendpt.h"             /* for init and contour list */
#include    "scanlist.h"            /* for init and bitmap */
#include    "scmemory.h"            /* for setup mem */
#include    "scentry.h"             /* for own function prototypes */

/*********************************************************************/
                                             
/*      Global state structure                                       */

/*********************************************************************/

#ifndef FSCFG_REENTRANT
    
FS_PUBLIC StateVars   State = {0};  /* global static:  available to all */

#endif

/*********************************************************************/
                                             
/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema(ContourList*, GlyphBitMap*);

FS_PRIVATE int32 EvaluateSpline(PSTATE F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, uint16 );


/*********************************************************************/
                                             
/*      Function Exports                                             */

/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_Initialize()
{
    fsc_InitializeScanlist();               /* scanlist calls to bitmap */
}


/*********************************************************************/

/*  Remove duplicated points from contour data                       */

/*  This was previously done in sc_FindExtrema of sc.c,              */
/*  but was pulled out to avoid having fsc_MeasureGlyph              */
/*  make changes to the contour list data structure.                 */

/*********************************************************************/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList* pclContour )           /* glyph outline */
{
    uint16 usContour;                       /* contour limit */
    int16 sStartPt, sEndPt;                 /* coutour index limits */
    int16 sPt;                              /* point index */
    int16 s;                                /* index for list collapse */
    F26Dot6 *pfxX1, *pfxY1;                 /* leading point */
    F26Dot6 fxX2, fxY2;                     /* trailing point */

    for (usContour = 0; usContour < pclContour->usContourCount; usContour++)
    {
        sStartPt = pclContour->asStartPoint[usContour];
        sEndPt = pclContour->asEndPoint[usContour];
        
        pfxX1 = &(pclContour->afxXCoord[sStartPt]); 
        pfxY1 = &(pclContour->afxYCoord[sStartPt]); 
                    
        for (sPt = sStartPt; sPt < sEndPt; ++sPt)
        {
            fxX2 = *pfxX1;                          /* check next pair */
            pfxX1++;
            fxY2 = *pfxY1;
            pfxY1++;
            
            if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if duplicate */
            {
                for(s = sPt; s > sStartPt; s--)     /* s = index of point to be removed */
                {
                    pclContour->afxXCoord[s] = pclContour->afxXCoord[s - 1];
                    pclContour->afxYCoord[s] = pclContour->afxYCoord[s - 1];
                    pclContour->abyOnCurve[s] = pclContour->abyOnCurve[s - 1];
                }
                sStartPt++;                         /* advance start past dup */
                pclContour->asStartPoint[usContour] = sStartPt;
                pclContour->abyOnCurve[sPt + 1] |= ONCURVE; /* dup'd pt must be on curve */
            }
        }
        
        /* now pfxX1 and pfxY1 point to end point coordinates */

        if (sStartPt != sEndPt)                     /* finished if single point */
        {
            fxX2 = pclContour->afxXCoord[sStartPt];
            fxY2 = pclContour->afxYCoord[sStartPt];
                                
            if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if start = end */
            {
                pclContour->asStartPoint[usContour]++;
                pclContour->abyOnCurve[sEndPt] |= ONCURVE;  /* dup'd pt must be on curve */
            }
        }
    }
    return NO_ERR;
}


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given glyph into a given bitmap.  Get per intersection and     */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureGlyph( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pbmpBitMap,        /* to return bounds */
        WorkScan* pwsWork,              /* to return values */
        uint16 usScanKind,              /* dropout control value */
        uint16 usRoundXMin,              /* for gray scale alignment */
        int16 sBitmapEmboldeningHorExtra,
        int16 sBitmapEmboldeningVertExtra )
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int16 sOrgDir;                      /* original contour direction */
    int16 sDir;                         /* current contour direction */
    int16 sFlatCount;                   /* for contours starting flat */
    int32 lVScanCount;                  /* total vertical scan lines */
    int32 lHScanCount;                  /* total horizontal scan lines */
    int32 lTotalHIx;
    int32 lTotalVIx;
    int32 lElementCount;                /* total element point estimate */
    int32 lDivide;                      /* spline element point counter */
    int32 lErrCode;    
    
    F26Dot6 fxX1, fxX2;                 /* x coord endpoints */
    F26Dot6 fxY1, fxY2;                 /* y coord endpoints */
    F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
    F26Dot6 fxAbsDelta;                 /* for element count check */
    uint8 byF1, byF2;                   /* oncurve flag values */
    uint8 *pbyFlags;                    /* for element count check */

    PRevRoot prrRoots;                  /* reversal list roots structure */

    
    lErrCode = FindExtrema(pclContour, pbmpBitMap); /* calc bounding box */
    if (lErrCode != NO_ERR) return lErrCode;

    pbmpBitMap->rectBounds.left &= -((int32)usRoundXMin);   /* mask off low n bits */

    /* bitmap emboldening by 2% + 1 pixel horizontally, 2% vertically */
    if ((pbmpBitMap->rectBounds.top != pbmpBitMap->rectBounds.bottom) && (pbmpBitMap->rectBounds.left != pbmpBitMap->rectBounds.right))
    {
         // we don't want to increase the size of the bitmap on a empty glyph
        if (sBitmapEmboldeningHorExtra > 0)
        {
            pbmpBitMap->rectBounds.right += sBitmapEmboldeningHorExtra;
        }
        else
        {
            pbmpBitMap->rectBounds.left += sBitmapEmboldeningHorExtra;
        }
        if (sBitmapEmboldeningVertExtra > 0)
        {
            pbmpBitMap->rectBounds.bottom -= (sBitmapEmboldeningVertExtra);
        }
        else
        {
            pbmpBitMap->rectBounds.top -= (sBitmapEmboldeningVertExtra);
        }
    }

    prrRoots = fsc_SetupRevRoots(pwsWork->pchRBuffer, pwsWork->lRMemSize);
    lElementCount = 0;                  /* smart point counter */
    
    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
        if (sStart == sEnd)
        {
            continue;                               /* for anchor points */
        }

/* check contour Y values for direction reversals */

        fxY1 = pclContour->afxYCoord[sEnd];         /* start by closing */
        pfxYCoord = &pclContour->afxYCoord[sStart];

        sPt = sStart;
        sDir = 0;                                   /* starting dir unknown */
        sFlatCount = 0;
        while ((sDir == 0) && (sPt <= sEnd))
        {
            fxY2 = *pfxYCoord++;
            if (fxY2 > fxY1)                        /* find first up or down */
            {
                sDir = 1;
            }
            else if (fxY2 < fxY1)
            {
                sDir = -1;
            }
            else
            {
                sFlatCount++;                       /* countour starts flat */
            }
            fxY1 = fxY2;
            sPt++;
        }
        sOrgDir = sDir;                             /* save original ep check */

        while (sPt <= sEnd)
        {
            fxY2 = *pfxYCoord++;
            if (sDir == 1)
            {
                if (fxY2 <= fxY1)                   /* = is for endpoint cases */
                {
                    fsc_AddYReversal (prrRoots, fxY1, 1);
                    sDir = -1;
                }
            }
            else    /* if sDir == -1 */
            {
                if (fxY2 >= fxY1)                   /* = is for endpoint cases */
                {
                    fsc_AddYReversal (prrRoots, fxY1, -1);
                    sDir = 1;
                }
            }
            fxY1 = fxY2;                            /* next segment */
            sPt++;
        }
                                
        while (sFlatCount > 0)                      /* if contour started flat */
        {
            if (sDir == 0)                          /* if completely flat */
            {
                sDir = 1;                           /* then pick a direction */
                sOrgDir = 1;
            }
            fsc_AddYReversal (prrRoots, fxY1, sDir); /* add one per point */
            sDir = -sDir;
            sFlatCount--;
        }
        if (sOrgDir != sDir)                        /* if endpoint reverses */
        {
            fsc_AddYReversal (prrRoots, fxY1, sDir); /* then balance up/down */
        }

/* if doing dropout control, check contour X values for direction reversals */

        if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
        {
            fxX1 = pclContour->afxXCoord[sEnd];     /* start by closing */
            pfxXCoord = &pclContour->afxXCoord[sStart];

            sPt = sStart;
            sDir = 0;                               /* starting dir unknown */
            sFlatCount = 0;
            while ((sDir == 0) && (sPt <= sEnd))
            {
                fxX2 = *pfxXCoord++;
                if (fxX2 > fxX1)                    /* find first up or down */
                {
                    sDir = 1;
                }
                else if (fxX2 < fxX1)
                {
                    sDir = -1;
                }
                else
                {
                    sFlatCount++;                   /* countour starts flat */
                }
                fxX1 = fxX2;
                sPt++;
            }
            sOrgDir = sDir;                         /* save original ep check */

            while (sPt <= sEnd)
            {
                fxX2 = *pfxXCoord++;
                if (sDir == 1)
                {
                    if (fxX2 <= fxX1)               /* = is for endpoint cases */
                    {
                        fsc_AddXReversal (prrRoots, fxX1, 1);
                        sDir = -1;
                    }
                }
                else    /* if sDir == -1 */
                {
                    if (fxX2 >= fxX1)               /* = is for endpoint cases */
                    {
                        fsc_AddXReversal (prrRoots, fxX1, -1);
                        sDir = 1;
                    }
                }
                fxX1 = fxX2;                        /* next segment */
                sPt++;
            }
                                    
            while (sFlatCount > 0)                  /* if contour started flat */
            {
                if (sDir == 0)                      /* if completely flat */
                {
                    sDir = 1;                       /* then pick a direction */
                    sOrgDir = 1;
                }
                fsc_AddXReversal (prrRoots, fxX1, sDir); /* add one per point */
                sDir = -sDir;
                sFlatCount--;
            }
            if (sOrgDir != sDir)                    /* if endpoint reverses */
            {
                fsc_AddXReversal (prrRoots, fxX1, sDir); /* then balance up/down */
            }

            if (usScanKind & SK_SMART)              /* if smart dropout control */
            {                                       /* estimate the elem point count */
                fxX1 = pclContour->afxXCoord[sEnd];
                fxY1 = pclContour->afxYCoord[sEnd];
                byF1 = pclContour->abyOnCurve[sEnd];
                pfxXCoord = &pclContour->afxXCoord[sStart];
                pfxYCoord = &pclContour->afxYCoord[sStart];
                pbyFlags = &pclContour->abyOnCurve[sStart];

                lElementCount += (uint32)(sEnd - sStart) + 2L;  /* 1/pt + 1/contour */

                for (sPt = sStart; sPt <= sEnd; sPt++)
                {
                    fxX2 = *pfxXCoord++;
                    fxY2 = *pfxYCoord++;
                    byF2 = *pbyFlags++;

                    if (((byF1 & byF2) & ONCURVE) == 0) /* if this is a spline */
                    {
                        if (((byF1 | byF2) & ONCURVE) == 0)
                        {
                            lElementCount++;            /* +1 for midpoint */
                        }
                                
                        if (FXABS(fxX2 - fxX1) > FXABS(fxY2 - fxY1))
                        {
                            fxAbsDelta = FXABS(fxX2 - fxX1);
                        }
                        else
                        {
                            fxAbsDelta = FXABS(fxY2 - fxY1);
                        }
                        lDivide = 0;
                        while (fxAbsDelta > (MAXSPLINELENGTH / 2))
                        {
                            lDivide++;
                            lDivide <<= 1;
                            fxAbsDelta >>= 1;
                        }
                        lElementCount += lDivide;   /* for subdivision */
                    }
                    fxX1 = fxX2;
                    fxY1 = fxY2;
                    byF1 = byF2;
                }
            }
        }
    }
    if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART))  /* if smart dropout */
    {
        lElementCount += fsc_GetReversalCount(prrRoots) << 1;  /* add in 2 * reversals */
        if (lElementCount > (0xFFFF >> SC_CODESHFT))
        {
            return SMART_DROP_OVERFLOW_ERR;
        }
    }

        
/*  set horiz workspace return values */

    lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
    lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
    
    pbmpBitMap->sRowBytes = (int16)ROWBYTESLONG(lVScanCount);
    pbmpBitMap->lMMemSize = (lHScanCount * (int32)pbmpBitMap->sRowBytes);
    
    lTotalHIx = fsc_GetHIxEstimate(prrRoots);   /* intersection count */
    pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

/*  set vertical workspace return values */
    
    if (usScanKind & SK_NODROPOUT)                  /* if no dropout */
    {
        pwsWork->lVMemSize = 0L;
        lTotalVIx = 0;
    }
    else
    {
        lTotalVIx = fsc_GetVIxEstimate(prrRoots);   /* estimate intersection count */
        pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, lTotalVIx, lElementCount);
    }
    
    pwsWork->lHInterCount = lTotalHIx;              /* save for SetupScan */
    pwsWork->lVInterCount = lTotalVIx;
    pwsWork->lElementCount = lElementCount;
    pwsWork->lRMemSize = fsc_GetRevMemSize(prrRoots);

#ifdef FSCFG_REENTRANT
    
    pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif

    return NO_ERR;
} 


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given band into a given bitmap.  Get per intersection and      */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap* pbmpBitMap,        /* computed by MeasureGlyph */
        WorkScan* pwsWork,              /* to return new values */
        uint16 usBandType,              /* small or fast */
        uint16 usBandWidth,             /* scanline count */
        uint16 usScanKind )             /* dropout control value */
{
    int32 lBandWidth;                   /* max scanline count */
    int32 lTotalHIx;                    /* est of horiz intersections in band */
    int32 lVScanCount;                  /* total vertical scan lines */
    int32 lHScanCount;                  /* total horizontal scan lines */

    lBandWidth = (int32)usBandWidth;
    pbmpBitMap->lMMemSize = (lBandWidth * (int32)pbmpBitMap->sRowBytes);
    
    if (usBandType == FS_BANDINGSMALL) 
    {
        lTotalHIx = fsc_GetHIxBandEst((PRevRoot)pwsWork->pchRBuffer, &pbmpBitMap->rectBounds, lBandWidth);
        pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
        pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lBandWidth, lTotalHIx);
        pwsWork->lVMemSize = 0L;            /* force dropout control off */
    }
    else if (usBandType == FS_BANDINGFAST) 
    {
        lTotalHIx = fsc_GetHIxEstimate((PRevRoot)pwsWork->pchRBuffer);  /* intersection count */
        pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
        
        lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
        pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

        if (usScanKind & SK_NODROPOUT)      /* if no dropout */
        {
            pwsWork->lVMemSize = 0L;
        }
        else                                /* if any kind of dropout */
        {
            pbmpBitMap->lMMemSize += (int32)pbmpBitMap->sRowBytes;  /* to save below row */
            
            lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
            pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, pwsWork->lVInterCount, pwsWork->lElementCount);
            pwsWork->lVMemSize += (int32)pbmpBitMap->sRowBytes;     /* to save above row */
            ALIGN(voidPtr, pwsWork->lVMemSize ); 
        }
    }
    
#ifdef FSCFG_REENTRANT
    
    pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif
    
    return NO_ERR;
}


/*********************************************************************/

/*  Scan Conversion Routine                                          */
/*  Trace the contour, passing out lines and splines,                */
/*  then call ScanList to fill the bitmap                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pgbBitMap,         /* target */
        WorkScan* pwsWork,              /* for scan array */
        uint16 usBandType,              /* old, small, fast or faster */
        uint16 usScanKind )             /* dropout control value */
{
    uint16 usCont;                      /* contour index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int32 lStateSpace;                  /* HMem used by state structure */
    int32 lErrCode;                     /* function return code */
    F26Dot6 *pfxXCoord;                 /* next x coord ptr */
    F26Dot6 *pfxYCoord;                 /* next y coord ptr */
    uint8 *pbyOnCurve;                  /* next flag ptr */
    F26Dot6 *pfxXStop;                  /* contour trace end condition */
    F26Dot6 fxX1, fxX2, fxX3;           /* x coord endpoints */
    F26Dot6 fxY1, fxY2, fxY3;           /* y coord endpoints */
    uint8 byOnCurve;                    /* point 2 flag variable */
    int32 lHiScanBand;                  /* top scan limit */ 
    int32 lLoScanBand;                  /* bottom scan limit */
    int32 lHiBitBand;                   /* top bitmap limit */
    int32 lLoBitBand;                   /* bottom bitmap limit */
    int32 lOrgLoBand;                   /* save for overscan fill check */
    F26Dot6 fxYHiBand, fxYLoBand;       /* limits in f26.6 */
    boolean bSaveRow;                   /* for dropout over scanning */
    boolean bBandCheck;                 /* eliminate out of band elements */

#ifdef FSCFG_REENTRANT
    
    StateVars *pState;                  /* reentrant State is accessed via pointer */

    pState = (StateVars*)pwsWork->pchHBuffer;  /* and lives in HMem (memoryBase[6]) */ 
    lStateSpace = sizeof(StateVars);

#else
    
    lStateSpace = 0L;                   /* no HMem needed if not reentrant */

#endif
    
    if (pgbBitMap->rectBounds.top <= pgbBitMap->rectBounds.bottom)
    {
        return NO_ERR;                              /* quick out for null glyph */
    }

    if (pgbBitMap->bZeroDimension)                  /* if no height or width */
    {
        usScanKind &= (~SK_STUBS);                  /* force no-stub dropout */
    }

    lHiBitBand = (int32)pgbBitMap->sHiBand, 
    lLoBitBand = (int32)pgbBitMap->sLoBand;
    lOrgLoBand = lLoBitBand;                        /* save for fill call */    
    
    Assert (lHiBitBand > lLoBitBand);               /* should be handled above */
    
    if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
    {
        lLoBitBand--;                               /* leave room below line */
    }
    if (lHiBitBand > pgbBitMap->rectBounds.top)
    {
        lHiBitBand = pgbBitMap->rectBounds.top;     /* clip to top */
    }
    if (lLoBitBand < pgbBitMap->rectBounds.bottom)
    {
        lLoBitBand = pgbBitMap->rectBounds.bottom;  /* clip to bottom */
    }
    if (usBandType == FS_BANDINGFAST)               /* if fast banding */
    {
        lHiScanBand = pgbBitMap->rectBounds.top;    /* render everything */
        lLoScanBand = pgbBitMap->rectBounds.bottom;
        bSaveRow = TRUE;                            /* keep last row for dropout */
    }
    else                                            /* if old or small banding */
    {
        lHiScanBand = lHiBitBand;                   /* just take the band */
        lLoScanBand = lLoBitBand;
        bSaveRow = FALSE;                           /* last row not needed */
    }
    
/*  if fast banding has already renderend elements, skip to FillBitMap */

    if (usBandType != FS_BANDINGFASTER)             /* if rendering required */
    {
        fsc_SetupMem(ASTATE                         /* init workspace */
                pwsWork->pchHBuffer + lStateSpace, 
                pwsWork->lHMemSize - lStateSpace,
                pwsWork->pchVBuffer, 
                pwsWork->lVMemSize);
        
        fsc_SetupLine(ASTATE0);             /* passes line callback to scanlist */
        fsc_SetupSpline(ASTATE0);           /* passes spline callback to scanlist */
        fsc_SetupEndPt(ASTATE0);            /* passes endpoint callback to scanlist */

/*  Eliminate out of band lines and splines, unless fast banding */

        bBandCheck = ((lHiScanBand < pgbBitMap->rectBounds.top) || (lLoScanBand > pgbBitMap->rectBounds.bottom));

        fxYHiBand = (F26Dot6)((lHiScanBand << SUBSHFT) - SUBHALF);  /* may be too wide */
        fxYLoBand = (F26Dot6)((lLoScanBand << SUBSHFT) + SUBHALF);

        lErrCode = fsc_SetupScan(ASTATE &(pgbBitMap->rectBounds), usScanKind, 
                             lHiScanBand, lLoScanBand, bSaveRow, (int32)pgbBitMap->sRowBytes,
                             pwsWork->lHInterCount, pwsWork->lVInterCount,
                             pwsWork->lElementCount, (PRevRoot)pwsWork->pchRBuffer );

        if (lErrCode != NO_ERR) return lErrCode;
        
        for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
        {
            sStart = pclContour->asStartPoint[usCont];
            sEnd = pclContour->asEndPoint[usCont];

            if (sStart == sEnd)
            {
                continue;                               /* for compatibilty */
            }
/*
    For efficiency in tracing the contour, we start by assigning (x1,y1)
    to the last oncurve point.  This is found by starting with the End
    point and backing up if necessary.  The pfxCoord pointers can then
    be used to trace the entire contour without being reset across the
    Start/End gap. 
*/
            pfxXCoord = &pclContour->afxXCoord[sStart];
            pfxYCoord = &pclContour->afxYCoord[sStart];
            pbyOnCurve = &pclContour->abyOnCurve[sStart];
            pfxXStop = &pclContour->afxXCoord[sEnd];

            if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
            {
                fxX1 = pclContour->afxXCoord[sEnd];
                fxY1 = pclContour->afxYCoord[sEnd];
                fxX2 = *pfxXCoord;
                fxY2 = *pfxYCoord;
                byOnCurve = *pbyOnCurve;                /* 1st pt might be off */
                pfxXStop++;                             /* stops at endpoint */
            }
            else                                        /* if endpoint offcurve */
            {
                fxX1 = pclContour->afxXCoord[sEnd - 1];
                fxY1 = pclContour->afxYCoord[sEnd - 1];
                fxX2 = pclContour->afxXCoord[sEnd];
                fxY2 = pclContour->afxYCoord[sEnd];
                if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
                {
                    fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
                    fxY1 = (fxY1 + fxY2 + 1) >> 1;
                }
                byOnCurve = 0;
                pfxXCoord--;                            /* pre decrement */
                pfxYCoord--;
                pbyOnCurve--;
            }
            fsc_BeginContourEndpoint(ASTATE fxX1, fxY1);          /* 1st oncurve pt -> ep module */
            fsc_BeginContourScan(ASTATE usScanKind, fxX1, fxY1);  /* to scanlist module too */
/*
    At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
    point (on or off); and the pointers are ready to be incremented to the
    point following (x2,y2).  
        
    Throughout this loop (x1,y1) is always an oncurve point (it may be the 
    midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
    have a line; if offcurve, we have a spline, and (x3,y3) will be the 
    next oncurve point.
*/
            if (!bBandCheck)
            {
                while (pfxXCoord < pfxXStop)
                {
                    if (byOnCurve & ONCURVE)                /* if next point oncurve */
                    {
                        lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        fxX1 = fxX2;                        /* next oncurve point */
                        fxY1 = fxY2;
                                
                        pfxXCoord++;
                        pfxYCoord++;
                        pbyOnCurve++;
                    }
                    else
                    {
                        pfxXCoord++;                        /* check next point */
                        fxX3 = *pfxXCoord;
                        pfxYCoord++;
                        fxY3 = *pfxYCoord;
                        pbyOnCurve++;
                                
                        if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
                        {
                            pfxXCoord++;
                            pfxYCoord++;
                            pbyOnCurve++;
                        }
                        else                                /* if not, calc next on */
                        {
                            fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                            fxY3 = (fxY2 + fxY3 + 1) >> 1;
                        }
                        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        fxX1 = fxX3;                        /* next oncurve point */
                        fxY1 = fxY3;
                    }

                    /* test to avoid reading past the end of memory on the last line */
                    if (pfxXCoord != pfxXStop)
                    {
                        fxX2 = *pfxXCoord;                      /* next contour point */
                        fxY2 = *pfxYCoord;
                        byOnCurve = *pbyOnCurve;
                    }
                }
            }
            else    /* if band checking */
            {
                while (pfxXCoord < pfxXStop)
                {
                    if (byOnCurve & ONCURVE)                /* if next point oncurve */
                    {
                        lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand)) ||
                              ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand))))
                        {
                            lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }

                        fxX1 = fxX2;                        /* next oncurve point */
                        fxY1 = fxY2;
                                
                        pfxXCoord++;
                        pfxYCoord++;
                        pbyOnCurve++;
                    }
                    else
                    {
                        pfxXCoord++;                        /* check next point */
                        fxX3 = *pfxXCoord;
                        pfxYCoord++;
                        fxY3 = *pfxYCoord;
                        pbyOnCurve++;
                                
                        if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
                        {
                            pfxXCoord++;
                            pfxYCoord++;
                            pbyOnCurve++;
                        }
                        else                                /* if not, calc next on */
                        {
                            fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                            fxY3 = (fxY2 + fxY3 + 1) >> 1;
                        }

                        if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand) && (fxY3 > fxYHiBand)) ||
                              ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand) && (fxY3 < fxYLoBand))))
                        {
                            lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }
                        else    /* if entirely outside of the band */
                        {
                            lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }

                        fxX1 = fxX3;                        /* next oncurve point */
                        fxY1 = fxY3;
                    }

                    /* test to avoid reading past the end of memory on the last line */
                    if (pfxXCoord != pfxXStop)
                    {
                        fxX2 = *pfxXCoord;                      /* next contour point */
                        fxY2 = *pfxYCoord;
                        byOnCurve = *pbyOnCurve;
                    }
                }
            }
            lErrCode = fsc_EndContourEndpoint(ASTATE usScanKind);
            if (lErrCode != NO_ERR) return lErrCode;
        }
    }
    
    lErrCode = fsc_FillBitMap(
            ASTATE 
            pgbBitMap->pchBitMap, 
            lHiBitBand, 
            lLoBitBand,
            (int32)pgbBitMap->sRowBytes, 
            lOrgLoBand,
            usScanKind
    );

    if (lErrCode != NO_ERR) return lErrCode;
    
    return NO_ERR;
}


#ifndef FSCFG_DISABLE_GRAYSCALE

/*********************************************************************/

/*  This routine scales up an outline for gray scale scan conversion */

/*********************************************************************/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList* pclContour,        /* glyph outline */
        uint16 usOverScale              /* over scale factor */
)
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int16 sShift;                       /* for power of two multiply */
    F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
    
    
    switch (usOverScale)                /* look for power of two */
    {
    case 1:
        sShift = 0;
        break;
    case 2:
        sShift = 1;
        break;
    case 4:
        sShift = 2;
        break;
    case 8:
        sShift = 3;
        break;
    default:
        sShift = -1;
        break;
    }

    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
                
        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
            
        if (sShift >= 0)                    /* if power of two */
        {
            for (sPt = sStart; sPt <= sEnd; sPt++)
            {
                *pfxXCoord <<= sShift;
                pfxXCoord++;
                *pfxYCoord <<= sShift;
                pfxYCoord++;
            }
        }
        else                                /* if not a power of two */
        {
            for (sPt = sStart; sPt <= sEnd; sPt++)
            {
                *pfxXCoord *= (int32)usOverScale;
                pfxXCoord++;
                *pfxYCoord *= (int32)usOverScale;
                pfxYCoord++;
            }
        }
    }
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale bitmap calculation                                    */
/*  Count over scale pixels into gray scale byte array               */
/*  Be sure that Hi/LoBand are set correctly for both Over & Gray!   */

/*********************************************************************/

#ifdef FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+

/*==============================================================*\

    The following tables help increase the contrast of the
    generated anti-alias glyphs:

\*==============================================================*/

static const int weightTable[36] =
{
    0,  0,  3,  3,  0,  0,
    0,  7, 12, 12,  7,  0,
    3, 12, 18, 18, 12,  3,
    3, 12, 18, 18, 12,  3,
    0,  7, 12, 12,  7,  0,
    0,  0,  3,  3,  0,  0
};

/*==============================================================*\

    The following code generates the scaleTable:

    double divisor = 220.0; // total of the values in the weightTable

    for(i=0;i<256;i++)
    {
        double value = 0.0;

        // Apply the non-linearity to the alpha value...
        value = i / divisor;
        value = (value * 2.0) / (value + 1.0);

        scaleTable[i] = (int)(value * 16);
    }

\*==============================================================*/

static const unsigned char scaleTable[256] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
    0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x09, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 
    0x0A, 0x0A, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 
    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 
    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0E, 0x0E, 
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 
    0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
};

/*==============================================================*\

    The following code generates the maskTable:

    int i, j;

    for(j=0;j<6;j++)
    {
        for(i=0;i<64;i++)
        {
            maskTable[j][i] = 
                ((i & 0x20) ? weightTable[(j*6)+0] : 0) +
                ((i & 0x10) ? weightTable[(j*6)+1] : 0) +
                ((i & 0x08) ? weightTable[(j*6)+2] : 0) +
                ((i & 0x04) ? weightTable[(j*6)+3] : 0) +
                ((i & 0x02) ? weightTable[(j*6)+4] : 0) +
                ((i & 0x01) ? weightTable[(j*6)+5] : 0);
        }
    }

\*==============================================================*/

static const unsigned char maskTable[6][64] =
{
    {
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06
    },
    {
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26, 
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26
    },
    {
        0x00, 0x03, 0x0C, 0x0F, 0x12, 0x15, 0x1E, 0x21, 0x12, 0x15, 0x1E, 0x21, 0x24, 0x27, 0x30, 0x33, 
        0x0C, 0x0F, 0x18, 0x1B, 0x1E, 0x21, 0x2A, 0x2D, 0x1E, 0x21, 0x2A, 0x2D, 0x30, 0x33, 0x3C, 0x3F, 
        0x03, 0x06, 0x0F, 0x12, 0x15, 0x18, 0x21, 0x24, 0x15, 0x18, 0x21, 0x24, 0x27, 0x2A, 0x33, 0x36, 
        0x0F, 0x12, 0x1B, 0x1E, 0x21, 0x24, 0x2D, 0x30, 0x21, 0x24, 0x2D, 0x30, 0x33, 0x36, 0x3F, 0x42
    },
    {
        0x00, 0x03, 0x0C, 0x0F, 0x12, 0x15, 0x1E, 0x21, 0x12, 0x15, 0x1E, 0x21, 0x24, 0x27, 0x30, 0x33, 
        0x0C, 0x0F, 0x18, 0x1B, 0x1E, 0x21, 0x2A, 0x2D, 0x1E, 0x21, 0x2A, 0x2D, 0x30, 0x33, 0x3C, 0x3F, 
        0x03, 0x06, 0x0F, 0x12, 0x15, 0x18, 0x21, 0x24, 0x15, 0x18, 0x21, 0x24, 0x27, 0x2A, 0x33, 0x36, 
        0x0F, 0x12, 0x1B, 0x1E, 0x21, 0x24, 0x2D, 0x30, 0x21, 0x24, 0x2D, 0x30, 0x33, 0x36, 0x3F, 0x42
    },
    {
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26, 
        0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x13, 0x13, 0x0C, 0x0C, 0x13, 0x13, 0x18, 0x18, 0x1F, 0x1F, 
        0x07, 0x07, 0x0E, 0x0E, 0x13, 0x13, 0x1A, 0x1A, 0x13, 0x13, 0x1A, 0x1A, 0x1F, 0x1F, 0x26, 0x26
    },
    {
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06
    }
};

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap* pOverGBMap,        /* over scaled source */
        GlyphBitMap* pGrayGBMap,        /* gray scale target */
        uint16 usOverScale              /* over scale factor */
)
{
    // The pOverGBMap structure needs to have weighted sampling
    // applied as well as the overscale factor so that the resulting
    // pGrayGBMap has correct 0-16 values.

    unsigned char *srcRowPtr = NULL;
    unsigned char *dstRowPtr = NULL;
    int srcRow;
    int dstRow;
    int srcRowCount;
    int dstRowCount;
    int srcRowBytes;
    int dstRowBytes;
    int vOffset;
    int hOffset;
    int srcBitOffsetMax;
    int srcRowOffsetMax;
    int col;
    int srcRowOffset = 0;
    unsigned char *dstPtr = NULL;

    // This only handles overscale values of 4!
    Assert (usOverScale == 4);

    // Get the row counts...
    srcRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
    dstRowCount = pGrayGBMap->sHiBand - pGrayGBMap->sLoBand;

    // Get the row byte counts...
    srcRowBytes = pOverGBMap->sRowBytes;
    dstRowBytes = pGrayGBMap->sRowBytes;

    // Setup our row pointers...
    srcRowPtr = pOverGBMap->pchBitMap;
    dstRowPtr = pGrayGBMap->pchBitMap;

    // Calculate the offsets...
    vOffset = pOverGBMap->sHiBand - (usOverScale * pGrayGBMap->sHiBand);
    hOffset = (pGrayGBMap->rectBounds.left * usOverScale) - pOverGBMap->rectBounds.left;

    // Calculate the limits...
    srcBitOffsetMax = srcRowBytes << 3;
    srcRowOffsetMax = srcRowCount * srcRowBytes;

    // Make sure that we account for the case where srcRowBytes was rounded up to 32 bit
    // quantity! (and the dstRowBytes was not calculated as an exact multiple of this!)
    if (srcBitOffsetMax > (dstRowBytes * 4))
        srcBitOffsetMax = dstRowBytes * 4;

    // Set up our destination pointer...
    dstPtr = dstRowPtr;

    // Loop through the scanlines and calculate the destination values...
    for(dstRow = 0;dstRow<dstRowCount;dstRow++)
    {
        int tblRow;
        int srcBitOffset;

        // The -1 here is so that the 6x6 table is centered
        // properly over the 4x4 grid location.
        srcRowOffset = (vOffset - 1) * srcRowBytes;

        // Clear the destination so we can add into it...
        memset(dstPtr, 0, dstRowBytes);

        for(tblRow = 0;tblRow<6;tblRow++)
        {
            if ((srcRowOffset >= 0) && (srcRowOffset < srcRowOffsetMax))
            {
                const unsigned char *tableRow = maskTable[tblRow];
                unsigned char *srcPtr = srcRowPtr + srcRowOffset;

                // -1 so that this is centered...
                srcBitOffset = hOffset - 1;

                col = 0;

                // Handle start of line clipping...
                while(srcBitOffset < 0)
                {
                    unsigned int index = 0;
                    int offset = srcBitOffset;
                    unsigned int mask = 0x8080 >> (offset & 7);

                    // read the proper number of bits...
                    while(offset < (srcBitOffset + 6))
                    {
                        index <<= 1;

                        if ((offset >= 0) && (srcPtr[(offset >> 3)] & mask))
                            index |= 1;

                        mask >>= 1;
                        offset++;
                    }

                    // index now contains the proper 6-bit value
                    // for the lookup table for this scanline...
                    Assert(col < dstRowBytes);
                    dstPtr[col] += tableRow[index];
                    col++;

                    // move on to the next pixel (overscale is 4 pixels)
                    srcBitOffset += 4;
                }

                // General-case line processing...
                while(srcBitOffset < (srcBitOffsetMax-8))
                {
                    unsigned int index = 0;

                    // Read 6 bits from srcPtr and use them as an index
                    index = srcPtr[(srcBitOffset >> 3)] << 8;
                    index |= srcPtr[(srcBitOffset >> 3) + 1];

                    index >>= 10 - (srcBitOffset&7);
                    index &= 0x3F;

                    // index now contains the proper 6-bit value
                    // for the lookup table for this scanline...
                    Assert(col < dstRowBytes);
                    dstPtr[col] += tableRow[index];
                    col++;

                    // move on to the next pixel (overscale is 4 pixels)
                    srcBitOffset += 4;
                }

                // Handle end of line clipping (only output a pixel if we still have 4
                // or more source pixels remaining! (overscale value is 4)
                while(srcBitOffset < (srcBitOffsetMax-4))
                {
                    unsigned int index = 0;
                    int offset = srcBitOffset;
                    unsigned int mask = 0x8080 >> (offset & 7);

                    // read the proper number of bits...
                    while(offset < (srcBitOffset + 6))
                    {
                        index <<= 1;

                        if ((offset < srcBitOffsetMax) && (srcPtr[(offset >> 3)] & mask))
                            index |= 1;

                        mask >>= 1;
                        offset++;
                    }

                    // index now contains the proper 6-bit value
                    // for the lookup table for this scanline...
                    Assert(col < dstRowBytes);
                    dstPtr[col] += tableRow[index];
                    col++;

                    // move on to the next pixel (overscale is 4 pixels)
                    srcBitOffset += 4;
                }
            }

            srcRowOffset += srcRowBytes;
        }

        for(col=0;col<dstRowBytes;col++)
            dstPtr[col] = scaleTable[dstPtr[col]];

        // Increment the destination pointer...
        dstPtr += dstRowBytes;

        // Increment by our overscale multiplier...
        vOffset += usOverScale;
    }

    return NO_ERR;
}

#else // !FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+

FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	char        *pchOverRow;            /* over scaled bitmap row pointer */
	char        *pchGrayRow;            /* gray scale bitmap row pointer */

	int16       sVOffset;               /* over scaled rows to skip */
	int16       sRightPix;              /* right edge of used over pix's */
		
	int16       sGrayRow;               /* gray scale row loop counter */
	uint16      usOverRowCount;         /* over scaled row loop counter */
	int16       sTotalRowCount;         /* over scaled whole band counter */
	
	uint32      ulBytes;                /* gray scale count for clear */
	int32       lErrCode;               /* function return code */
	
	GrayScaleParam  GSP;                /* param block for CalcGrayRow */


	Assert ((usOverScale == 1) || (usOverScale == 2) || (usOverScale == 4) || (usOverScale == 8));

	ulBytes = (uint32)pGrayGBMap->sRowBytes * (uint32)(pGrayGBMap->sHiBand - pGrayGBMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);
	fsc_ScanClearBitMap (ulBytes >> 2, (uint32*)pGrayGBMap->pchBitMap);
	
	GSP.usOverScale = usOverScale;
	GSP.pchOverLo = pOverGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchOverHi = pOverGBMap->pchBitMap + pOverGBMap->lMMemSize;
	GSP.pchGrayLo = pGrayGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchGrayHi = pGrayGBMap->pchBitMap + pGrayGBMap->lMMemSize;

	pchOverRow = pOverGBMap->pchBitMap;
	usOverRowCount = usOverScale;
	sTotalRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
	sVOffset = pOverGBMap->sHiBand - usOverScale * pGrayGBMap->sHiBand;
	if (sVOffset < 0)                                   /* if mapped above over's bitmap */
	{
		usOverRowCount -= (uint16)(-sVOffset);          /* correct first band count */
	}
	else
	{
		pchOverRow += sVOffset * pOverGBMap->sRowBytes; /* point into bitmap */
		sTotalRowCount -= sVOffset;                     /* adjust for skipped rows */
	}
	
	sRightPix = pGrayGBMap->rectBounds.right * (int16)usOverScale - pOverGBMap->rectBounds.left;
	pchOverRow += (sRightPix - 1) >> 3;
	GSP.usFirstShift = (uint16)(7 - ((sRightPix-1) & 0x0007));

	GSP.sGrayCol = pGrayGBMap->rectBounds.right - pGrayGBMap->rectBounds.left;
	pchGrayRow = pGrayGBMap->pchBitMap + (GSP.sGrayCol - 1);

	for (sGrayRow = pGrayGBMap->sHiBand - 1; sGrayRow >= pGrayGBMap->sLoBand; sGrayRow--)
	{
		GSP.pchGray = pchGrayRow;
		while ((usOverRowCount > 0) && (sTotalRowCount > 0))
		{
			GSP.pchOver = pchOverRow;
			lErrCode = fsc_ScanCalcGrayRow( &GSP );
			if (lErrCode != NO_ERR) return lErrCode;
			
			pchOverRow += pOverGBMap->sRowBytes;
			usOverRowCount--;
			sTotalRowCount--;
		}                               
		pchGrayRow += pGrayGBMap->sRowBytes;
		usOverRowCount = usOverScale;
	}
	return NO_ERR;
}
#endif // !FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+

#else                                   /* if grayscale is disabled */

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList* pclContour,        /* glyph outline */
        uint16 usOverScale              /* over scale factor */
)
{
    FS_UNUSED_PARAMETER(pclContour);
    FS_UNUSED_PARAMETER(usOverScale);
    
    return BAD_GRAY_LEVEL_ERR;
}


FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap* pOverGBMap,        /* over scaled source */
        GlyphBitMap* pGrayGBMap,        /* gray scale target */
        uint16 usOverScale              /* over scale factor */
)
{
    FS_UNUSED_PARAMETER(pOverGBMap);
    FS_UNUSED_PARAMETER(pGrayGBMap);
    FS_UNUSED_PARAMETER(usOverScale);
    
    return BAD_GRAY_LEVEL_ERR;
}

#endif

/*********************************************************************/
                                             
/*      Local Functions                                              */

/*********************************************************************/

/*********************************************************************/

/*  This routine examines a glyph contour by contour and calculates  */
/*  its bounding box.                                                */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pbmpBitMap         /* to return bounds */
)
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int32 lMaxX, lMinX;                 /* for bounding box left, right */
    int32 lMaxY, lMinY;                 /* for bounding box top, bottom */
    
    F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
    F26Dot6 fxMaxX, fxMinX;             /* for bounding box left, right */
    F26Dot6 fxMaxY, fxMinY;             /* for bounding box top, bottom */
    boolean bFirstContour;              /* set false after min/max set */


    fxMaxX = 0L;                        /* default bounds limits */
    fxMinX = 0L;
    fxMaxY = 0L;
    fxMinY = 0L;
    bFirstContour = TRUE;               /* first time only */
    
    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
        if (sStart == sEnd)
        {
            continue;                               /* for anchor points */
        }
        
        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
                
        if (bFirstContour)            
        {
            fxMaxX = *pfxXCoord;                    /* init bounds limits */
            fxMinX = *pfxXCoord;
            fxMaxY = *pfxYCoord;
            fxMinY = *pfxYCoord;
            bFirstContour = FALSE;                  /* just once */
        }

        for (sPt = sStart; sPt <= sEnd; sPt++)      /* find the min & max */
        {
            if (*pfxXCoord > fxMaxX)
                fxMaxX = *pfxXCoord;
            if (*pfxXCoord < fxMinX)
                fxMinX = *pfxXCoord;
                    
            if (*pfxYCoord > fxMaxY)
                fxMaxY = *pfxYCoord;
            if (*pfxYCoord < fxMinY)
                fxMinY = *pfxYCoord;

            pfxXCoord++;
            pfxYCoord++;
        }
    }
    
    pbmpBitMap->fxMinX = fxMinX;                    /* save full precision bounds */
    pbmpBitMap->fxMinY = fxMinY;
    pbmpBitMap->fxMaxX = fxMaxX;                    /* save full precision bounds */
    pbmpBitMap->fxMaxY = fxMaxY;

    lMinX = (fxMinX + SUBHALF - 1) >> SUBSHFT;      /* pixel black box */
    lMinY = (fxMinY + SUBHALF - 1) >> SUBSHFT;
    lMaxX = (fxMaxX + SUBHALF) >> SUBSHFT;
    lMaxY = (fxMaxY + SUBHALF) >> SUBSHFT;
            
    if ((F26Dot6)(int16)lMinX != lMinX ||           /* check overflow */
        (F26Dot6)(int16)lMinY != lMinY ||
        (F26Dot6)(int16)lMaxX != lMaxX ||
        (F26Dot6)(int16)lMaxY != lMaxY )
    {
        return POINT_MIGRATION_ERR;
    }

    pbmpBitMap->bZeroDimension = FALSE;             /* assume some size */
    
    if (bFirstContour == FALSE)                     /* if contours present */
    {                                               /* then force a non-zero bitmap */
        if (lMinX == lMaxX)
        {
            lMaxX++;                                /* force 1 pixel wide */
            pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
        }
        if (lMinY == lMaxY)
        {
            lMaxY++;                                /* force 1 pixel high */
            pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
        }
    }
    
/*  set bitmap structure return values */

    pbmpBitMap->rectBounds.left   = (int16)lMinX;
    pbmpBitMap->rectBounds.right  = (int16)lMaxX;
    pbmpBitMap->rectBounds.bottom = (int16)lMinY;
    pbmpBitMap->rectBounds.top    = (int16)lMaxY;

    return NO_ERR;
}

/*********************************************************************/

/* This recursive routine subdivides splines that are non-monotonic or   */
/* too big into splines that fsc_CalcSpline can handle.  It also         */
/* filters out degenerate (linear) splines, passing off to fsc_CalcLine. */


FS_PRIVATE int32 EvaluateSpline( 
        PSTATE                      /* pointer to state vars */
        F26Dot6 fxX1,               /* start point x coordinate */
        F26Dot6 fxY1,               /* start point y coordinate */
        F26Dot6 fxX2,               /* control point x coordinate */
        F26Dot6 fxY2,               /* control point y coordinate */
        F26Dot6 fxX3,               /* ending x coordinate */
        F26Dot6 fxY3,               /* ending y coordinate */
        uint16 usScanKind           /* scan control type */
)
{
    F26Dot6 fxDX21, fxDX32, fxDX31;     /* delta x's */
    F26Dot6 fxDY21, fxDY32, fxDY31;     /* delta y's */
    
    F26Dot6 fxDenom;                    /* ratio denominator  */
    F26Dot6 fxX4, fxY4;                 /* first mid point */
    F26Dot6 fxX5, fxY5;                 /* mid mid point */
    F26Dot6 fxX6, fxY6;                 /* second mid point */
    F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */
    F26Dot6 fxAbsDX, fxAbsDY;           /* abs of DX31, DY31 */
    
    int32 lErrCode;


    fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
    fxDX32 = fxX3 - fxX2;
    fxDY21 = fxY2 - fxY1;
    fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

    if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
    {
        fxDenom = fxDY21 - fxDY32;              /* total y span */
        fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
        fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
        fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
        fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);
        
        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY456, fxX5, fxY456, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX5, fxY456, fxX6, fxY456, fxX3, fxY3, usScanKind);
    }
    
/*  If spline goes left and right, then subdivide it  */
    
    if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
    {
        fxDenom = fxDX21 - fxDX32;              /* total x span */
        fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
        fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
        fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
        fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);

        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX456, fxY4, fxX456, fxY5, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX456, fxY5, fxX456, fxY6, fxX3, fxY3, usScanKind);
    }

/*  By now the spline must be monotonic  */

    fxDX31 = fxX3 - fxX1;                       /* check overall size */
    fxDY31 = fxY3 - fxY1;
    fxAbsDX = FXABS(fxDX31);
    fxAbsDY = FXABS(fxDY31);

/*  If spline is too big to calculate, then subdivide it  */

    if ((fxAbsDX > MAXSPLINELENGTH) || (fxAbsDY > MAXSPLINELENGTH))
    {
        fxX4 = (fxX1 + fxX2) >> 1;              /* first segment mid point */
        fxY4 = (fxY1 + fxY2) >> 1;
        fxX6 = (fxX2 + fxX3) >> 1;              /* second segment mid point */
        fxY6 = (fxY2 + fxY3) >> 1;
        fxX5 = (fxX4 + fxX6) >> 1;              /* mid segment mid point */
        fxY5 = (fxY4 + fxY6) >> 1;

        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY4, fxX5, fxY5, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX5, fxY5, fxX6, fxY6, fxX3, fxY3, usScanKind);
    }

/*  The spline is now montonic and small enough  */

    lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);  /* first check endpoint */
    if (lErrCode != NO_ERR)  return lErrCode;

    if (fxDX21 * fxDY32 == fxDY21 * fxDX32)     /* if spline is degenerate (linear) */
    {                                           /* treat as a line */
        return fsc_CalcLine(ASTATE fxX1, fxY1, fxX3, fxY3, usScanKind);
    }
    else        
    {
        return fsc_CalcSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
    }
}


/*********************************************************************/

/*  Return an array of coordinates for outline points */

FS_PUBLIC int32 fsc_GetCoords(
        ContourList* pclContour,        /* glyph outline */
        uint16 usPointCount,            /* point count */
        uint16* pusPointIndex,          /* point indices */
        PixCoord* ppcCoordinate         /* point coordinates */
)
{
    uint16  usMaxIndex;                 /* last defined point */
    int32  lX;                          /* integer x coord */
    int32  lY;                          /* integer y coord */

    if (pclContour->usContourCount == 0)
    {
        return BAD_POINT_INDEX_ERR;     /* can't have a point without a contour */
    }
     
    usMaxIndex = pclContour->asEndPoint[pclContour->usContourCount - 1] + 2;    /* allow 2 phantoms */

    while (usPointCount > 0)
    {
        if (*pusPointIndex > usMaxIndex)
        {
            return BAD_POINT_INDEX_ERR;     /* beyond the last contour */
        }

        lX = (pclContour->afxXCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;
        lY = (pclContour->afxYCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;

        if ( ((int32)(int16)lX != lX) || ((int32)(int16)lY != lY) )
        {
            return POINT_MIGRATION_ERR;    /* catch overflow */
        }

        ppcCoordinate->x = (int16)lX;
        ppcCoordinate->y = (int16)lY;

        pusPointIndex++;
        ppcCoordinate++;
        usPointCount--;                     /* loop through all points */
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scentry.h ===
/*********************************************************************

      scentry.h -- NewScan Module Exports

      (c) Copyright 1992-95  Microsoft Corp.  All rights reserved.

       1/23/95  deanb       added fsc_GetCoords helper function
       9/07/93  deanb       F26Dot6 min/max added to gbmp structure
       8/10/93  deanb       expand interface for gray scale
       6/10/93  deanb       fsc_Initialize added
       4/21/93  deanb       banding params for MeasureGlyph
       3/29/93  deanb       reversal memory added to WorkScan
       3/19/93  deanb       size_t replaced with int32
      12/22/92  deanb       Rectangle -> Rect
      12/21/92  deanb       Interface types aligned with rasterizer
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/05/92  deanb       ulPointCount removed from ContourList
      11/04/92  deanb       RemoveDups function added
      10/14/92  deanb       Exported data structures added
       8/18/92  deanb       Scan type param added 
       8/17/92  deanb       Functions renamed to ..Glyph 
       7/24/92  deanb       Polyline functions deleted 
       4/09/92  deanb       New types 
       3/30/92  deanb       WorkspaceSize renamed MeasureContour 
       3/24/92  deanb       BitMap back to WorkspaceSize 
       3/20/92  deanb       Structs moved to fscdefs.h, params trimmed 
       3/17/92  deanb       Add ulPointCount, rework fcn params 
       3/05/92  deanb       Add data structures 
       3/04/92  deanb       Size reports added 
       2/21/92  deanb       First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/********************************************************************/

/*      Exported Data Structures                                    */

/********************************************************************/

typedef struct
{
    uint16 usContourCount;          /* number of contours */
    int16 *asStartPoint;            /* contour startpoint index array */
    int16 *asEndPoint;              /* contour endpoint index array */
    F26Dot6 *afxXCoord;             /* contour x coordinate array */
    F26Dot6 *afxYCoord;             /* contour y coordinate array */
    uint8 *abyOnCurve;              /* on curve / off curve array */
    uint8 *abyFc;					/* contour flags, one byte for every contour */
}
ContourList;

typedef struct
{
    int16 sRowBytes;                /* bit map width in bytes */
    int16 sHiBand;                  /* upper banding limit */
    int16 sLoBand;                  /* lower banding limit */
    Rect rectBounds;                /* bit map border */
    boolean bZeroDimension;         /* flags zero width or height */
    F26Dot6 fxMinX;                 /* full precision x minimum */
    F26Dot6 fxMaxX;                 /* full precision x maximum */
    F26Dot6 fxMinY;                 /* full precision y minimum */
    F26Dot6 fxMaxY;                 /* full precision y maximum */
    int32 lMMemSize;                /* size of bitmap in bytes */
    char *pchBitMap;                /* pixel bit map */
}
GlyphBitMap;

typedef struct
{
    int32 lRMemSize;                /* workspace bytes for reversal lists */
    int32 lHMemSize;                /* workspace bytes needed for horiz scan */
    int32 lVMemSize;                /* additional workspace for vert scan */
    int32 lHInterCount;             /* estimate of horiz scan intersections */
    int32 lVInterCount;             /* estimate of vert scan intersections */
    int32 lElementCount;            /* estimate of element control points */
    char *pchRBuffer;               /* reversal workspace byte pointer */
    char *pchHBuffer;               /* horiz workspace byte pointer */
    char *pchVBuffer;               /* vert workspace byte pointer */
}
WorkScan;

typedef struct
{
    int16 x;                        /* x pixel value */
    int16 y;                        /* y pixel value */
}
PixCoord;

/*********************************************************************/

/*      Function Exports                                             */

/*********************************************************************

  fsc_Initialize

    This routine calls down to the bitmap module to initialize the
    bitmap masks.  It should be called once, before and scan conversion
    is done.  No harm will be done if it is called more than once.

*/

FS_PUBLIC void fsc_Initialize (
        void
);


/*********************************************************************

  fsc_RemoveDups

    This routine examines a glyph contour by contour and removes any
    duplicated points.  Two subtlties here:  1) following a call to
    this routine, the relation of End[i] + 1 = Start[i + 1] may no
    longer hold (in other words, the contours may not be tightly
    packed);  and 2) two duplicate off curve points will become a
    single ON curve point (this makes sense when you remember that
    between any two offs there must be an on).

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

  Returned Values:
    
    ContourList -   Start, X, Y, and OnCurve arrays may be modified

*/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList*        /* glyph outline */
);

/*********************************************************************

  fsc_OverScaleOutline(&Clist, inputPtr->param.gray.usOverScale);

    This routine scales up an outline for gray scale scan conversion

  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usOverScale     Multiplier

  Returned Values:
    
    ContourList -   X and Y arrays will be multiplied by usOverScale

*/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList*,       /* glyph outline */
        uint16              /* over scale factor */
);

/*********************************************************************

  fsc_MeasureGlyph

    This routine examines a glyph contour by contour and calculates 
    its size and the amount of workspace needed to scan convert it.

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Points to MeasureGlyph workspace used to
                                    store contour reversals.
                    lRMemSize       Size of RBuffer in bytes.  This should be
                                    2 * sizeof(Reversal) * NumberOfPoints to
                                    handle the worst case.
    
    uint16      -   usScanKind      Dropout control code

    uint16      -   usRoundXMin     Allows alignment of XMin for gray scale
                                    XMin modulo usRoundXMin will be zero

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Amount of RBuffer actually used.  This will
                                    typically be much less than the worst case.
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz scan intersections
                    lVInterCount    Estimate of vert scan intersections
                    lElementCount   Estimate of element control points

    GlyphBitMap -   sRowBytes       Bytes per row in bitmap (padded to 0 mod 4).
                    rectBounds      Worst case black bounding box.
                    lMMemSize       Size of bitmap in bytes
*/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra );
    
/*********************************************************************

  fsc_MeasureBand

    This routine calculates the amount of workspace needed to scan 
    convert a glyph using banding.

  Input Values:

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    lHMemSize       Size of horizontal memory from MeasureGlyph
                    lVMemSize       Size of vertical memory from MeasureGlyph
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph
    
    uint16      -   usBandType      FS_BANDINGSMALL or FS_BANDINGFAST
    
    uint16      -   usBandWidth     Number of scan lines of maximum band

    uint16      -   usScanKind      Dropout control code

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Unchanged
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz band intersections
                    lVInterCount    Unchanged
                    lElementCount   Unchanged

    GlyphBitMap -   sRowBytes       Unchanged
                    rectBounds      Unchanged
                    lMMemSize       Size of bitmap in bytes

*/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap*,        /* computed by MeasureGlyph */
        WorkScan*,           /* to return new values */
        uint16,              /* usBandType = small or fast */
        uint16,              /* usBandWidth = scanline count */
        uint16               /* usScanKind = dropout control value */
);


/*********************************************************************

  fsc_FillGlyph

    This routine is responsible for the actual creation of a bitmap
    from the outline.
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    pchHBuffer      Pointer to horizontal workspace memory
                    pchVBuffer      Pointer to vertical workspace memory
                    lHMemSize       Size of horizontal memory (for assertion checks)
                    lVMemSize       Size of vertical memory (for assertion checks)
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph

    GlyphBitMap -   pchBitMap       Pointer to bit map output buffer
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
  
    uint16      -   usBandType      Old, Small, or Fast banding code
    
    uint16      -   usScanKind      Dropout control code

  Returned Values:

    GlyphBitMap -   Bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList*,       /* glyph outline */
        GlyphBitMap*,       /* target */
        WorkScan*,          /* for scan array */
        uint16,             /* banding type */
        uint16              /* scan type */
);

/*********************************************************************

  fsc_CalcGrayMap

    This routine calculates a gray scale bitmap from an overscaled bitmap
    
  Input Values:

    GlyphBitMap1 -  pchBitMap       Pointer to over scaled bit map
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
    
    GlyphBitMap2 -  pchBitMap       Pointer to gray scale bit map output buffer
                    sRowBytes       1 byte per pixel
                    rectBounds      Same value as returned from fsc_MeasureExtrema
    
    uint16       -  usOverScale     Gray scale contour multiplier
  
  Returned Values:

    GlyphBitMap2 -  Gray scale bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap*,       /* over scaled source */
        GlyphBitMap*,       /* gray scale target */
        uint16              /* over scale factor */
);


/*********************************************************************

  fsc_GetCoords

    This routine returns an array of coordinates for outline points
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usPointCount    Number of points to look up

    uint16*     -   pusPointIndex   Array of point indices
  
  Returned Values:

    pxyCoords   -   Array of (x,y) integer (pixel) coordinates

*/

FS_PUBLIC int32 fsc_GetCoords(
        ContourList*,       /* glyph outline */
        uint16,             /* point count */
        uint16*,            /* point indices */
        PixCoord*           /* point coordinates */
);

 /*********************************************************************/

#ifdef FSCFG_SUBPIXEL

/*********************************************************************

  fsc_OverscaleToSubPixel

    This routine is the heart of the RGB striping algorithm
    
  Input Values:

    OverscaledBitmap
  
  Returned Values:

    SubPixelBitMap

*/

FS_PUBLIC void fsc_OverscaleToSubPixel (
    GlyphBitMap * OverscaledBitmap, 
	boolean bgrOrder, 
    GlyphBitMap * SubPixelBitMap
);

 /*********************************************************************/

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scendpt.h ===
/*********************************************************************

	  scendpt.h -- EndPoint Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetEndpointElemSize returns size_t 
	   9/08/92 deanb    GetEndpointElemSize added 
	   7/24/92 deanb    ContourSave functions deleted 
	   4/09/92 deanb    New types again 
	   3/20/92 deanb    New types, save contour functions 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupEndPt ( PSTATE0 );

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* starting point x coordinate */
		F26Dot6             /* starting point y coordinate */
);

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* x coordinate */
		F26Dot6,            /* y coordinate */
		uint16              /* scan control type */
);

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE              /* pointer to state variables */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scmemory.h ===
/*********************************************************************

      scmemory.h -- Memory Module Exports

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       3/19/93 deanb    size_t replaced with int32
      10/14/92 deanb    New SetupMem parameters
      10/09/92 deanb    PSTP added
      10/08/92 deanb    Horiz/Vert memory alloc's
       9/09/92 deanb    Alloc param int32  
       9/08/92 deanb    Setup with WorkSpace pointer 
       8/21/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE              /* pointer to state variables */
        char*,              /* pointer to horiz workspace */
        int32 ,             /* size of horiz workspace */
        char*,              /* pointer to vert workspace */
        int32               /* size of vert workspace */
);

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from horiz memory pool */
);

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from vert memory pool */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scspline.h ===
/*********************************************************************

	  scspline.h -- Spline Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTATE added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetSplineElemSize returns size_t 
	   9/08/92 deanb    MAXSPLINELENGTH added 
	   8/17/92 deanb    PowerOf2 moved to math 
	   7/23/92 deanb    EvaluateSpline replaced with CalcSpline + PowerOf2 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/14/92 deanb    First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupSpline ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcSpline( 
		PSTATE          /* pointer to state varables */
		F26Dot6,        /* start point x coordinate */
		F26Dot6,        /* start point y coordinate */
		F26Dot6,        /* control point x coordinate */
		F26Dot6,        /* control point y coordinate */
		F26Dot6,        /* ending x coordinate */
		F26Dot6,        /* ending y coordinate */
		uint16          /* scan control type */
);

/********************************************************************/

/*              Export Definitions                                  */

/********************************************************************/

#define MAXSPLINELENGTH     3200        /* calculation overflow limit */

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scspline.c ===
/*********************************************************************

      scspline.c -- New Scan Converter Spline Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
       3/19/93  deanb   size_t replaced with int32
      10/28/92  deanb   memory requirements reworked
      10/09/92  deanb   reentrant
       9/28/92  deanb   quick out for nearly vert/horiz splines 
       9/25/92  deanb   branch on scan kind 
       9/22/92  deanb   subpix calculation using subdivision 
       9/14/92  deanb   reflection correction with iX/YOffset 
       9/10/92  deanb   first dropout code 
       9/02/92  deanb   Precision reduction by shifting control points 
       7/24/92  deanb   Initial Q set for perfect symmetry 
       7/23/92  deanb   EvaluateSpline split out and moved to NewScan 
       7/20/92  deanb   removed unreachable case 
       7/16/92  deanb   faster power of 2 
       7/06/92  deanb   Cleanups 
       7/01/92  deanb   Reinstate a single spline routine 
       6/30/92  deanb   Implicit spline rendering 
       3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for power of 2 calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* for direct horizscan add call */
#include    "scspline.h"            /* for own function prototypes */
                
/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     QMAXSHIFT      7            /* shift limit q precision */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/
 
FS_PRIVATE F26Dot6 CalcHorizSpSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertSpSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
    
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupSpline (PSTATE0) 
{
    fsc_SetupCallBacks(ASTATE SC_SPLINECODE, CalcHorizSpSubpix, CalcVertSpSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcSpline( 
        PSTATE                  /* pointer to state variables */
        F26Dot6 fxX1,           /* start point x coordinate */
        F26Dot6 fxY1,           /* start point y coordinate */
        F26Dot6 fxX2,           /* control point x coordinate */
        F26Dot6 fxY2,           /* control point y coordinate */
        F26Dot6 fxX3,           /* ending x coordinate */
        F26Dot6 fxY3,           /* ending y coordinate */
        uint16 usScanKind )     /* dropout control type */
{
    F26Dot6 fxXInit, fxYInit;           /* initial step values */
    F26Dot6 fxXScan, fxYScan;           /* set to first crossings */
    F26Dot6 fxXX2, fxYY2;               /* translated reflected control point */
    F26Dot6 fxXX3, fxYY3;               /* translated reflected end point */
    
    F26Dot6 afxXControl[2];             /* params for BeginElement call */
    F26Dot6 afxYControl[2];

    void (*pfnAddHorizScan)(PSTATE int32, int32);
    void (*pfnAddVertScan)(PSTATE int32, int32);
    
    int32 lABits;                       /* 1+int(log2(alpha)) */
    int32 lXYBits;                      /* 1+int(log2(max(x3,y3))) */
    int32 lZBits;                       /* 6, 5, 4 log2(subpixels per pix) */
    int32 lZShift;                      /* 0, 1, 2 shift to minipixel */
    F26Dot6 fxZRound;                   /* rounding factor for minipix shift */
    F26Dot6 fxZSubpix;                  /* 64, 32, 16 subpixels per pix */
    int32 lQuadrant;                    /* 1, 2, 3, or 4 */

    F26Dot6 fxAx, fxAy;                 /* parametric 2nd order terms */
    F26Dot6 lAlpha;                     /* cross product measures curvature */

    int32 lR, lT;                       /* quadratic coefficients for xx, yy */
    int32 lS2, lU2, lV2;                /* half coefficients for xy, x, y */
    int32 lRz, lSz, lTz;                /* coeff's times subpix size */
        
    int32 lQ;                           /* cross product value */
    int32 lDQx, lDQy;                   /* first order derivative */
    int32 lDDQx, lDDQy;                 /* second order derivative */

    int32 lYScan;                       /* scan line counter */
    int32 lYStop;                       /* scan line end */
    int32 lYIncr;                       /* scan line direction */
    int32 lYOffset;                     /* reflection correction */
    int32 lXScan;                       /* horiz pix position */
    int32 lXStop;                       /* pix end */
    int32 lXIncr;                       /* pix increment direction */
    int32 lXOffset;                     /* reflection correction */

    static const int32 lZShiftTable[] = { /* for precision adjustment */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*  0 -  9  */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 10 - 19 */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 20 - 29 */
        1, 1, 1, 2, 2, 2, 3, 3          /* 30 - 34 */
    };


/* printf("(%li, %li) - (%li, %li) -(%li, %li)\n", fxX1, fxY1, fxX2, fxY2, fxX3, fxY3 ); */


/*  Translate spline point 1 to (0,0) and reflect into the first quadrant  */
    
    if (fxY3 > fxY1)                            /* if going up */
    {
        lQ = 0L;
        lQuadrant = 1;

        fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
        fxYInit = fxYScan - fxY1;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANBELOW(fxY3)) >> SUBSHFT) + 1;
        lYIncr = 1;        
        lYOffset = 0;                           /* no reflection */
        fxYY2 = fxY2 - fxY1;                    /* translate */
        fxYY3 = fxY3 - fxY1;
    }
    else                                        /* if going down */
    {
        lQ = 1L;                                /* to include pixel centers */
        lQuadrant = 4;
        
        fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
        fxYInit = fxY1 - fxYScan;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANABOVE(fxY3)) >> SUBSHFT) - 1;
        lYIncr = -1;        
        lYOffset = 1;                           /* reflection correction */
        fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
        fxYY3 = fxY1 - fxY3;
    }
    
    if (fxX3 > fxX1)                            /* if going right */
    {
        fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
        fxXInit = fxXScan - fxX1;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANBELOW(fxX3)) >> SUBSHFT) + 1;
        lXIncr = 1;        
        lXOffset = 0;                           /* no reflection */
        fxXX2 = fxX2 - fxX1;                    /* translate */
        fxXX3 = fxX3 - fxX1;
    }
    else                                        /* if going left or straight */
    {
        lQ = 1L - lQ;                           /* to include pixel centers */
        lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

        fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
        fxXInit = fxX1 - fxXScan;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANABOVE(fxX3)) >> SUBSHFT) - 1;
        lXIncr = -1;        
        lXOffset = 1;                           /* reflection correction */
        fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
        fxXX3 = fxX1 - fxX3;
    }

/*-------------------------------------------------------------------*/
    
    afxXControl[0] = fxX2;
    afxYControl[0] = fxY2;
    afxXControl[1] = fxX3;
    afxYControl[1] = fxY3;

    fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_SPLINECODE,  /* where and what */
                      2, afxXControl, afxYControl,                  /* number of pts */
                      &pfnAddHorizScan, &pfnAddVertScan );          /* what to call */

/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        if (lYScan == lYStop)                   /* and if no scan crossings */
        {
            return NO_ERR;                      /* then quick exit */
        }
        
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }
    }
        
/*-------------------------------------------------------------------*/

    else                                        /* if smart dropout control on */
    {
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }

        if (lYScan == lYStop)                   /* if nearly horizontal */
        {
            lYScan += lYOffset;
            while (lXScan != lXStop)
            {
                pfnAddVertScan(ASTATE lXScan, lYScan);
                lXScan += lXIncr;               /* advance x scan + or - */
            }        
            return NO_ERR;                      /* quick out */
        }
    }

/*-------------------------------------------------------------------*/

/*  Now calculate parametric term precision      */

    Assert(fxXX3 <= MAXSPLINELENGTH);
    Assert(fxYY3 <= MAXSPLINELENGTH);

    lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;      /* curvature term */
    
    lABits = PowerOf2(lAlpha);
    lXYBits = fxXX3 > fxYY3 ? PowerOf2((int32)fxXX3) : PowerOf2((int32)fxYY3);
    
    Assert(lXYBits <= 12);                      /* max allowed spline bits */
    Assert(lABits <= 25);

    lZShift = lZShiftTable[lABits + lXYBits];   /* look up precision fix */
    lZBits = SUBSHFT - lZShift;

    if (lZShift > 0)                            /* if precision fix is needed */
    {
        fxZRound = 1L << (lZShift - 1);
        
        fxXX2 = (fxXX2 + fxZRound) >> lZShift;  /* shift to 32 or 16 subpix grid */
        fxXX3 = (fxXX3 + fxZRound) >> lZShift;
        fxYY2 = (fxYY2 + fxZRound) >> lZShift;
        fxYY3 = (fxYY3 + fxZRound) >> lZShift;
        
        fxXInit = (fxXInit + fxZRound) >> lZShift;
        fxYInit = (fxYInit + fxZRound) >> lZShift;

        lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;  /* recompute curvature */
    }

    Assert (FXABS(lAlpha * fxXX3) < (1L << 29) + (3L << 24));
    Assert (FXABS(lAlpha * fxYY3) < (1L << 29) + (3L << 24));

/*  Calculate terms for Q = Rxx + Sxy + Tyy + Ux + Vy  */

    fxAx = fxXX3 - (fxXX2 << 1);
    fxAy = fxYY3 - (fxYY2 << 1);

    lR = fxAy * fxAy;
    lS2 = -fxAx * fxAy;
    lT = fxAx * fxAx;
    lU2 = fxYY2 * lAlpha;
    lV2 = -fxXX2 * lAlpha;

/*  
    Calculate starting forward difference terms:

    lQ = Q(x,y) = Rxx + Sxy + Tyy + Ux + Vy
    lDQx = Q(x+z, y) - Q(x, y) = R(2xz + zz) + Syz + Uz
    lDQy = Q(x, y+z) - Q(x, y) = T(2yz + zz) + Sxz + Vz 

*/
    fxZSubpix = 1L << lZBits;                   /* adjusted subpix per pix */

    if (lXYBits <= QMAXSHIFT)                   /* if small enough use full Q */
    {
        lQ += (lR * fxXInit + (lS2 << 1) * fxYInit + (lU2 << 1)) * fxXInit + 
              (lT * fxYInit + (lV2 << 1)) * fxYInit;
        lDQx = (lR * ((fxXInit << 1) + fxZSubpix) + (lS2 << 1) * fxYInit + (lU2 << 1)) << lZBits;
        lDQy = (lT * ((fxYInit << 1) + fxZSubpix) + (lS2 << 1) * fxXInit + (lV2 << 1)) << lZBits;
        
        lRz = lR << (lZBits << 1);              /* needed in the loop */
        lSz = (lS2 << 1) << (lZBits << 1);
        lTz = lT << (lZBits << 1);
    }
    else                                        /* if too big take out a 2 * Z */
    {
        lQ += (((lR >> 1) * fxXInit + lS2 * fxYInit + lU2) >> lZBits) * fxXInit + 
              (((lT >> 1) * fxYInit + lV2) >> lZBits) * fxYInit;
        
        lDQx = lR * (fxXInit + (fxZSubpix >> 1)) + lS2 * fxYInit + lU2;
        lDQy = lT * (fxYInit + (fxZSubpix >> 1)) + lS2 * fxXInit + lV2;
        
        lRz = lR << (lZBits - 1);               /* needed in the loop */
        lSz = lS2 << lZBits;
        lTz = lT << (lZBits - 1);
    }
    lDDQx = lRz << 1;                           /* 2nd derivative terms */
    lDDQy = lTz << 1;
                
/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        lXScan += lXOffset;                     /* pre increment */
        lXStop += lXOffset;                     /* limit too */

/*  Branch to appropriate inner loop  */

        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if past bounding box, finish up */

        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }        

/*-------------------------------------------------------------------*/

    else                                        /* if dropout control on */
    {
        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if outside the bounding box, finish up */

        while (lXScan != lXStop)
        {
            pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
            lXScan += lXIncr;                   /* advance x scan + or - */
        }        
        
        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }

/*-------------------------------------------------------------------*/

    return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions      */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizSpSubpix(
    int32 lYScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxYDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/

    fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+2))) ||
           ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+2))));

    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);
    
    if (*pfxY < *(pfxY+2))                      /* if spline goes up */
    {
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes down */
    {
        fxX1 = *(pfxX+2);                       /* flip it upside down */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do                                          /* midpoint subdivision */
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxYMid > fxYDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide down */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxYMid < fxYDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide up */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxYMid != fxYDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */

    return fxXMid;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertSpSubpix(
    int32 lXScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxXDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/
    
    fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+2))) ||
           ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+2))));
    
    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);

    if (*pfxX < *(pfxX+2))                      /* if spline goes right */
    {                                                                  
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes left */
    {                                                                  
        fxX1 = *(pfxX+2);                       /* flip it around */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxXMid > fxXDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide left */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxXMid < fxXDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide right */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxXMid != fxXDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */
    
    return fxYMid;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfnt.h ===
/*
	File:       sfnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	            (c) 1989-1999 by Microsoft Corporation.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <3>    02/21/97    CB      ClaudeBe, add flags for scaled composite offset compatibility
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Remove unneeded tables from sfnt_tableIndex. [rb]
		<12>     7/18/90    MR      platform and specific should always be unsigned
		<11>     7/14/90    MR      removed duplicate definitions of int[8,16,32] etc.
		<10>     7/13/90    MR      Minor type changes, for Ansi-C
		 <9>     6/29/90    RB      revise postscriptinfo struct
		 <7>      6/4/90    MR      Remove MVT
		 <6>      6/1/90    MR      pad postscriptinfo to long word aligned
		 <5>     5/15/90    MR      Add definition of PostScript table
		 <4>      5/3/90    RB      mrr     Added tag for font program 'fpgm'
		 <3>     3/20/90    CL      chucked old change comments from EASE
		 <2>     2/27/90    CL      getting bbs headers
	   <3.1>    11/14/89    CEL     Instructions are legal in components.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
		<3+>     3/20/90    mrr     Added tag for font program 'fpgm'
*/

#pragma pack(1)

#ifndef SFNT_DEFINED
#define SFNT_DEFINED

#include "fscdefs.h" // DO NOT REMOVE
#include "sfnt_en.h"

typedef struct {
	uint32 bc;
	uint32 ad;
} BigDate;

typedef struct {
	sfnt_TableTag   tag;
	uint32          checkSum;
	uint32          offset;
	uint32          length;
} sfnt_DirectoryEntry;

/*
 *  The search fields limits numOffsets to 4096.
 */
typedef struct {
	int32 version;                  /* 0x10000 (1.0) */
	uint16 numOffsets;              /* number of tables */
	uint16 searchRange;             /* (max2 <= numOffsets)*16 */
	uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
	uint16 rangeShift;              /* numOffsets*16-searchRange*/
	sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;
#define OFFSETTABLESIZE     12  /* not including any entries */

/*
 *  for the flags field
 */
#define Y_POS_SPECS_BASELINE            0x0001
#define X_POS_SPECS_LSB                 0x0002
#define HINTS_USE_POINTSIZE             0x0004
#define USE_INTEGER_SCALING             0x0008
#define INSTRUCTED_ADVANCE_WIDTH        0x0010

/* flags 5-10 defined by Apple */
#define APPLE_VERTICAL_LAYOUT           0x0020
#define APPLE_RESERVED                  0x0040
#define APPLE_LINGUISTIC_LAYOUT         0x0080
#define APPLE_GX_METAMORPHOSIS          0x0100
#define APPLE_STRONG_RIGHT_TO_LEFT      0x0200
#define APPLE_INDIC_EFFECT              0x0400

#define FONT_COMPRESSED                 0x0800
#define FONT_CONVERTED                  0x1000

#define OUTLINE_CORRECT_ORIENTATION     0x4000
#define SFNT_MAGIC 0x5F0F3CF5

#define SHORT_INDEX_TO_LOC_FORMAT       0
#define LONG_INDEX_TO_LOC_FORMAT        1
#define GLYPH_DATA_FORMAT               0

typedef struct {
	Fixed       version;            /* for this table, set to 1.0 */
	Fixed       fontRevision;       /* For Font Manufacturer */
	uint32      checkSumAdjustment;
	uint32      magicNumber;        /* signature, should always be 0x5F0F3CF5  == MAGIC */
	uint16      flags;
	uint16      unitsPerEm;         /* Specifies how many in Font Units we have per EM */

	BigDate     created;
	BigDate     modified;

	/** This is the font wide bounding box in ideal space
 (baselines and metrics are NOT worked into these numbers) **/
	FUnit       xMin;
	FUnit       yMin;
	FUnit       xMax;
	FUnit       yMax;

	uint16      macStyle;               /* macintosh style word */
	uint16      lowestRecPPEM;          /* lowest recommended pixels per Em */

	/* 0: fully mixed directional glyphs, 1: only strongly L->R or T->B glyphs, 
	   -1: only strongly R->L or B->T glyphs, 2: like 1 but also contains neutrals,
	   -2: like -1 but also contains neutrals */
	int16       fontDirectionHint;

	int16       indexToLocFormat;
	int16       glyphDataFormat;
} sfnt_FontHeader;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */

	FUnit       yAscender;
	FUnit       yDescender;
	FUnit       yLineGap;       /* Recommended linespacing = ascender - descender + linegap */
	uFUnit      advanceWidthMax;
	FUnit       minLeftSideBearing;
	FUnit       minRightSideBearing;
	FUnit       xMaxExtent; /* Max of (LSBi + (XMAXi - XMINi)), i loops through all glyphs */

	int16       horizontalCaretSlopeNumerator;
	int16       horizontalCaretSlopeDenominator;

	uint16      reserved0;
	uint16      reserved1;
	uint16      reserved2;
	uint16      reserved3;
	uint16      reserved4;

	int16       metricDataFormat;           /* set to 0 for current format */
	uint16      numberOf_LongHorMetrics;    /* if format == 0 */
} sfnt_HorizontalHeader;

typedef struct {
	uint16      advanceWidth;
	int16       leftSideBearing;
} sfnt_HorizontalMetrics;

typedef struct {
	uint16      advanceHeight;
	int16       topSideBearing;
} sfnt_VerticalMetrics;

/*
 *  CVT is just a bunch of int16s
 */
typedef int16 sfnt_ControlValue;

/*
 *  Char2Index structures, including platform IDs
 */
typedef struct {
	uint16  format;
	uint16  length;
	uint16  version;
} sfnt_mappingTable;

typedef struct {
	uint16  platformID;
	uint16  specificID;
	uint32  offset;
} sfnt_platformEntry;

typedef struct {
	uint16  version;
	uint16  numTables;
	sfnt_platformEntry platform[1]; /* platform[numTables] */
} sfnt_char2IndexDirectory;
#define SIZEOFCHAR2INDEXDIR     4

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  int16   idDelta;
  uint16  idRangeOffset;
} sfnt_subHeader2;

typedef struct {
  uint16            subHeadersKeys [256];
  sfnt_subHeader2   subHeaders [1];
} sfnt_mappingTable2;

typedef struct {
  uint16  segCountX2;
  uint16  searchRange;
  uint16  entrySelector;
  uint16  rangeShift;
  uint16  endCount[1];
} sfnt_mappingTable4;

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  uint16  glyphIdArray [1];
} sfnt_mappingTable6;

typedef struct {
	uint16 platformID;
	uint16 specificID;
	uint16 languageID;
	uint16 nameID;
	uint16 length;
	uint16 offset;
} sfnt_NameRecord;

typedef struct {
	uint16 format;
	uint16 count;
	uint16 stringOffset;
/*  sfnt_NameRecord[count]  */
} sfnt_NamingTable;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} sfnt_maxProfileTable;

typedef struct {
  int16       numberOfContours;
  BBOX        bbox;
  int16       endPoints[1];
} sfnt_PackedSplineFormat;

#define DEVEXTRA    2   /* size + max */
/*
 *  Each record is n+2 bytes, padded to long word alignment.
 *  First byte is ppem, second is maxWidth, rest are widths for each glyph
 */
typedef struct {
	int16               version;
	int16               numRecords;
	int32               recordSize;
	/* Byte widths[numGlyphs+2] * numRecords */
} sfnt_DeviceMetrics;

#ifdef UNNAMED_UNION        /* Anonymous unions are supported */
#define postScriptNameIndices   /* by some C implementations,  */
#endif              /* but they are not portable. */

typedef struct {
	Fixed   version;                /* 1.0 */
	Fixed   italicAngle;
	FUnit   underlinePosition;
	FUnit   underlineThickness;
	uint32  isFixedPitch;
	uint32  minMemType42;
	uint32  maxMemType42;
	uint32  minMemType1;
	uint32  maxMemType1;

	uint16  numberGlyphs;
	union
	{
	  uint16  glyphNameIndex[1];   /* version == 2.0 */
	  int8    glyphNameIndex25[1]; /* version == 2.5 */
	} postScriptNameIndices;
} sfnt_PostScriptInfo;

#ifdef postScriptNameIndices
#undef postScriptNameIndices
#endif 

typedef struct {
	uint16  Version;
	int16   xAvgCharWidth;
	uint16  usWeightClass;
	uint16  usWidthClass;
	int16   fsType;
	int16   ySubscriptXSize;
	int16   ySubscriptYSize;
	int16   ySubscriptXOffset;
	int16   ySubscriptYOffset;
	int16   ySuperScriptXSize;
	int16   ySuperScriptYSize;
	int16   ySuperScriptXOffset;
	int16   ySuperScriptYOffset;
	int16   yStrikeOutSize;
	int16   yStrikeOutPosition;
	int16   sFamilyClass;
	uint8   Panose [10];
	uint32  ulCharRange [4];
	char    achVendID [4];
	uint16  usSelection;
	uint16  usFirstChar;
	uint16  usLastChar;
	int16   sTypoAscender;
	 int16  sTypoDescender;
	int16   sTypoLineGap;
	int16   sWinAscent;
	int16   sWinDescent;
	uint32  ulCodePageRange[2];
} sfnt_OS2;

typedef struct
{
	uint8   bEmY;
	uint8   bEmX;
	uint8   abInc[1];
} sfnt_hdmxRecord;

typedef struct
{
	uint16          Version;
	int16           sNumRecords;
	int32           lSizeRecord;
	sfnt_hdmxRecord HdmxTable;
} sfnt_hdmx;

typedef struct
{
	uint16    Version;
	uint16    usNumGlyphs;
	uint8     ubyPelsHeight;
} sfnt_LTSH;

typedef struct
{
	uint16          rangeMaxPPEM;
	uint16          rangeGaspBehavior;
} sfnt_gaspRange;

typedef struct
{
	uint16          version;
	uint16          numRanges;
	sfnt_gaspRange  gaspRange[1];
} sfnt_gasp;

/* various typedef to access to the sfnt data */

typedef sfnt_OffsetTable          *sfnt_OffsetTablePtr;
typedef sfnt_FontHeader           *sfnt_FontHeaderPtr;
typedef sfnt_HorizontalHeader     *sfnt_HorizontalHeaderPtr;
typedef sfnt_maxProfileTable      *sfnt_maxProfileTablePtr;
typedef sfnt_ControlValue         *sfnt_ControlValuePtr;
typedef sfnt_char2IndexDirectory  *sfnt_char2IndexDirectoryPtr;
typedef sfnt_HorizontalMetrics    *sfnt_HorizontalMetricsPtr;
typedef sfnt_VerticalMetrics      *sfnt_VerticalMetricsPtr;
typedef sfnt_platformEntry        *sfnt_platformEntryPtr;
typedef sfnt_NamingTable          *sfnt_NamingTablePtr;
typedef sfnt_OS2                  *sfnt_OS2Ptr;
typedef sfnt_DirectoryEntry       *sfnt_DirectoryEntryPtr;
typedef sfnt_PostScriptInfo       *sfnt_PostScriptInfoPtr;
typedef sfnt_gasp                 *sfnt_gaspPtr;

/*
 * 'gasp' Table Constants
*/

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/*
 * UNPACKING Constants
*/
/*define ONCURVE                 0x01   defined in FSCDEFS.H    */
#define XSHORT              0x02
#define YSHORT              0x04
#define REPEAT_FLAGS        0x08 /* repeat flag n times */
/* IF XSHORT */
#define SHORT_X_IS_POS      0x10 /* the short vector is positive */
/* ELSE */
#define NEXT_X_IS_ZERO      0x10 /* the relative x coordinate is zero */
/* ENDIF */
/* IF YSHORT */
#define SHORT_Y_IS_POS      0x20 /* the short vector is positive */
/* ELSE */
#define NEXT_Y_IS_ZERO      0x20 /* the relative y coordinate is zero */
/* ENDIF */
/* 0x40 & 0x80              RESERVED
** Set to Zero
**
*/

/*
 * Composite glyph constants
 */
#define COMPONENTCTRCOUNT           -1      /* ctrCount == -1 for composite */
#define ARG_1_AND_2_ARE_WORDS       0x0001  /* if set args are words otherwise they are bytes */
#define ARGS_ARE_XY_VALUES          0x0002  /* if set args are xy values, otherwise they are points */
#define ROUND_XY_TO_GRID            0x0004  /* for the xy values if above is true */
#define WE_HAVE_A_SCALE             0x0008  /* Sx = Sy, otherwise scale == 1.0 */
#define NON_OVERLAPPING             0x0010  /* set to same value for all components */
#define MORE_COMPONENTS             0x0020  /* indicates at least one more glyph after this one */
#define WE_HAVE_AN_X_AND_Y_SCALE    0x0040  /* Sx, Sy */
#define WE_HAVE_A_TWO_BY_TWO        0x0080  /* t00, t01, t10, t11 */
#define WE_HAVE_INSTRUCTIONS        0x0100  /* instructions follow */
#define USE_MY_METRICS              0x0200  /* apply these metrics to parent glyph */
#define OVERLAP_COMPOUND			0x0400  /* used by Apple in GX fonts */
#define SCALED_COMPONENT_OFFSET     0x0800  /* composite designed to have the component offset scaled (designed for Apple) */
#define UNSCALED_COMPONENT_OFFSET   0x1000  /* composite designed not to have the component offset scaled (designed for MS) */

/*
 *  Private enums for tables used by the scaler.  See sfnt_Classify
 */
typedef enum {
	sfnt_fontHeader,
	sfnt_horiHeader,
	sfnt_indexToLoc,
	sfnt_maxProfile,
	sfnt_controlValue,
	sfnt_preProgram,
	sfnt_glyphData,
	sfnt_horizontalMetrics,
	sfnt_charToIndexMap,
	sfnt_fontProgram,
	sfnt_Postscript,
	sfnt_HoriDeviceMetrics,
	sfnt_LinearThreshold,
	sfnt_Names,
	sfnt_OS_2,
	sfnt_GlyphDirectory,
	sfnt_BitmapData,
	sfnt_BitmapLocation,
	sfnt_BitmapScale,
	sfnt_vertHeader,
	sfnt_verticalMetrics,
	sfnt_BeginningOfFont,       /* References the beginning of memory   */
	sfnt_NUMTABLEINDEX
} sfnt_tableIndex;

#endif
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scline.h ===
/*********************************************************************

	  scline.h -- Line Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetLineElemSize returns size_t 
	   8/21/92 deanb    GetLineElemSize added 
	   7/23/92 deanb    Back to x2,y2 again 
	   7/17/92 deanb    Changed from longline to line 
	   4/21/92 deanb    Scan lines and on/off added 
	   4/09/92 deanb    New types 
	   4/01/92 deanb    Back to x2,y2 
	   3/20/92 deanb    Reintroduced 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupLine ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* point 1  x coordinate */
		F26Dot6,            /* point 1  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scmemory.c ===
/*********************************************************************

      scmemory.c -- New Scan Converter Memory Managment Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
      10/28/92  deanb   reentrant params renamed
      10/14/92  deanb   New fsc_SetupMem parameters
      10/09/92  deanb   Reentrant
      10/08/92  deanb   Separate Horiz/Vert memory pools
       9/10/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "scglobal.h"            /* structures & constants */
#include    "scmemory.h"            /* for own function prototypes */


/**********************************************************************

    Workspace memory is divided into two pools, identified here as
    HMem (horizontal memory) and VMem (vertical memory).  HMem is
    always used, and contains horizontal scan array lists.  VMem is 
    used only when dropout control is enabled, and contains the 
    vertical scan array lists and the contour elements used to compute 
    subpixel intersections for smart dropout control.  This division 
    into two pools was done, in part, for backward compatiblity with 
    the Apple rasterizer.  It allows a client to force dropout control
    off by setting the allocated size of VMem to zero.

**********************************************************************/
    
/*********************************************************************/

/*      Export Functions      */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE                           /* pointer to state variables */
        char* pchHBuffer,                /* pointer to horiz workspace */
        int32 lHMemSize,                 /* size of horiz workspace */
        char* pchVBuffer,                /* pointer to vert workspace */
        int32 lVMemSize )                /* size of vert workspace */
{
    STATE.pchHNextAvailable = pchHBuffer;
    STATE.pchHWorkSpaceEnd = pchHBuffer + lHMemSize;
    
    STATE.pchVNextAvailable = pchVBuffer;
    STATE.pchVWorkSpaceEnd = pchVBuffer + lVMemSize;
}


/********************************************************************/

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE                         /* pointer to state variables  */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;
    
/* printf("H: %ui   ", lSize); */

    pvTemp = (void*)STATE.pchHNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchHNextAvailable += lSize;
    
    Assert(STATE.pchHNextAvailable <= STATE.pchHWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE                         /* pointer to state variables */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;

/* printf("V: %ui   ", lSize); */
    
    pvTemp = (void*)STATE.pchVNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchVNextAvailable += lSize;
    
    Assert(STATE.pchVNextAvailable <= STATE.pchVWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scline.c ===
/*********************************************************************

	  scline.c -- New Scan Converter Line Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   MultDivide replaced with LongMulDiv
	  10/28/92  deanb   mem requirement reworked
	  10/13/92  deanb   horiz / vert line rework
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/21/92  deanb   rework horiz & vert lines 
	   9/14/92  deanb   reflection correction with iX/YOffset 
	   9/10/92  deanb   first dropout code 
	   9/08/92  deanb   quickstep deleted 
	   8/18/92  deanb   include struc.h, scconst.h 
	   7/23/92  deanb   Back to x1,y1,x2,y2 input params 
	   7/17/92  deanb   Changed from longline to line 
	   6/18/92  deanb   Cross product line rendering  
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for subpix calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scline.h"              /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
	
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupLine (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_LINECODE, CalcHorizLineSubpix, CalcVertLineSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE                /* pointer to state variables */
		F26Dot6 fxX1,         /* point 1  x coordinate */
		F26Dot6 fxY1,         /* point 1  y coordinate */
		F26Dot6 fxX2,         /* point 2  x coordinate */
		F26Dot6 fxY2,         /* point 2  y coordinate */
		uint16 usScanKind     /* dropout control type */
)
{
	int32 lXScan;                           /* current x pixel index */
	int32 lXSteps;                          /* vert scanline index count */
	int32 lXIncr;                           /* x pixel increment */
	int32 lXOffset;                         /* reflection correction */
	
	int32 lYScan;                           /* current scanline index */
	int32 lYSteps;                          /* horiz scanline index count */
	int32 lYIncr;                           /* y pixel increment */
	int32 lYOffset;                         /* reflection correction */

	F26Dot6 fxXInit, fxYInit;               /* sub steps to first pixel */
	F26Dot6 fxXScan, fxYScan;               /* x,y pixel center coords */
	F26Dot6 fxXX2, fxYY2;                   /* absolute value of DX, DY */
	F26Dot6 fxXTemp, fxYTemp;               /* for horiz/vert line calc */
	
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	int32 lQuadrant;                        /* 1, 2, 3, or 4 */
	int32 lQ;                               /* cross product */
	int32 lDQy, lDQx;                       /* cross product increments */
	int32 i;                                /* loop counter */


/* printf("(%li, %li) - (%li, %li)\n", fxX1, fxY1, fxX2, fxY2); */
	
/*  check y coordinates  */

	if (fxY2 >= fxY1)                           /* if going up or flat */
	{
		lQuadrant = 1;
		lQ = 0L;
		
		fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
		fxYInit = fxYScan - fxY1;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = (int32)((SCANBELOW(fxY2)) >> SUBSHFT) - lYScan + 1;
		lYIncr = 1;        
		lYOffset = 0;                           /* no reflection */
		fxYY2 = fxY2 - fxY1;                    /* translate */
	}
	else                                        /* if going down */
	{
		lQuadrant = 4;
		lQ = 1L;                                /* to include pixel centers */
		
		fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
		fxYInit = fxY1 - fxYScan;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = lYScan - (int32)((SCANABOVE(fxY2)) >> SUBSHFT) + 1;
		lYIncr = -1;        
		lYOffset = 1;                           /* reflection correction */
		fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
	}
	
	if (fxY2 == fxY1)                           /* if horizontal line */
	{
		if (usScanKind & SK_NODROPOUT)          /* if no dropout control */
		{
			return NO_ERR;                      /* if only horiz scan, done */
		}
		if (fxX2 < fxX1)                        /* if going left  */
		{
			fxYTemp = fxY1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going right */
		{
			fxYTemp = fxY1;          
		}
		lYScan = (int32)(SCANABOVE(fxYTemp) >> SUBSHFT);
		lYSteps = 0;
	}

/*  check x coordinates  */
	
	if (fxX2 >= fxX1)                           /* if going right or vertical */
	{
		fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
		fxXInit = fxXScan - fxX1;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = (int32)((SCANBELOW(fxX2)) >> SUBSHFT) - lXScan + 1;
		lXIncr = 1;        
		lXOffset = 0;                           /* no reflection */
		fxXX2 = fxX2 - fxX1;                    /* translate */
	}
	else                                        /* if going left */
	{
		lQ = 1L - lQ;                           /* reverse it */
		lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

		fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
		fxXInit = fxX1 - fxXScan;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = lXScan - (int32)((SCANABOVE(fxX2)) >> SUBSHFT) + 1;
		lXIncr = -1;        
		lXOffset = 1;                           /* reflection correction */
		fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
	}
	
	if (fxX2 == fxX1)                           /* if vertical line       */
	{
		if (fxY2 > fxY1)                        /* if going up  */
		{
			fxXTemp = fxX1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going down */
		{
			fxXTemp = fxX1;          
		}
		lXScan = (int32)(SCANABOVE(fxXTemp) >> SUBSHFT);
		lXSteps = 0;
	}

/*-------------------------------------------------------------------*/
	
	fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_LINECODE, /* where and what */
					  1, &fxX2, &fxY2,                           /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );       /* what to call */

/*-------------------------------------------------------------------*/

	if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
	{
		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		lXScan += lXOffset;

		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
/*-------------------------------------------------------------------*/
	
	else  /* if dropout control */
	{                                           /* handle special case lines  */
		if (fxY1 == fxY2)                       /* if horizontal line */
		{
			for (i = 0; i < lXSteps; i++)       /*   then blast a row   */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan);
				lXScan += lXIncr;               /* advance x scan + or - */
			}
			return NO_ERR;
		}

		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32 lYScan, 
									   F26Dot6 *pfxX, 
									   F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+1))) ||
		   ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+1))));

	fxXDrop = *pfxX + LongMulDiv(*(pfxX+1) - *pfxX, fxYDrop - *pfxY, *(pfxY+1) - *pfxY);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxXDrop;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32 lXScan, 
									  F26Dot6 *pfxX, 
									  F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+1))) ||
		   ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+1))));

	fxYDrop = *pfxY + LongMulDiv(*(pfxY+1) - *pfxY, fxXDrop - *pfxX, *(pfxX+1) - *pfxX);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxYDrop;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfntaccs.c ===
/*
	File:       sfnt.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
	   <17+>     10/9/90    MR,rb   Remove classification of unused tables in sfnt_Classify
		<17>     8/10/90    MR      Pass nil for textLength parameter to MapString2, checked in
									other files to their precious little system will BUILD.  Talk
									about touchy!
		<16>     8/10/90    gbm     rolling out Mike's textLength change, because he hasn't checked
									in all the relevant files, and the build is BROKEN!
		<15>     8/10/90    MR      Add textLength arg to MapString2
		<14>     7/26/90    MR      don't include toolutil.h
		<13>     7/23/90    MR      Change computeindex routines to call functins in MapString.c
		<12>     7/18/90    MR      Add SWAPW macro for INTEL
		<11>     7/13/90    MR      Lots of Ansi-C stuff, change behavior of ComputeMapping to take
									platform and script
		 <9>     6/27/90    MR      Changes for modified format 4: range is now times two, loose pad
									word between first two arrays.  Eric Mader
		 <8>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vector mapping functions
		 <6>      6/4/90    MR      Remove MVT
		 <5>      5/3/90    RB      simplified decryption.
		 <4>     4/10/90    CL      Fixed mapping table routines for double byte codes.
		 <3>     3/20/90    CL      Joe found bug in mappingtable format 6 Added vector mapping
									functions use pointer-loops in sfnt_UnfoldCurve, changed z from
									int32 to int16
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)  New
									CharToIndexMap Table format.
									Assume subtablenumber zero for old sfnt format.  Fixed
									transformed component bug.
	   <3.2>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Glyph-length 0
									bug in sfnt.c is fixed. Now it is legal to pass in zero as the
									address of memory when a piece of the sfnt is requested by the
									scaler. If this happens the scaler will simply exit with an
									error code ! Fixed bug with instructions in components.
	   <3.1>     9/27/89    CEL     Removed phantom points.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
		<3+>     3/20/90    mrr     Fixed mapping table routines for double byte codes.
									Added support for font program.
									Changed count from uint16 to int16 in vector char2index routines.
*/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/

#include "fserror.h"
#include "fscdefs.h"
#include "sfntaccs.h"
#include "sfntoff.h"
/*#include "MapString.h" */

#include "stat.h"                   /* STAT timing card prototypes */

/*  CONSTANTS   */

#define MISSING_GLYPH_INDEX     0
#define MAX_FORMAT0_CHAR_INDEX  256
#define MAX_LINEAR_X2           16
static  const   transMatrix   IdentTransform =
   {{{ONEFIX,      0,      0},
	 {     0, ONEFIX,      0},
	 {     0,      0, ONEFIX}}};

/*  MACROS  */
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define GETSFNTFRAG(ClientInfo,lOffset,lLength) (ClientInfo)->GetSfntFragmentPtr(ClientInfo->lClientID, lOffset, lLength)
#define RELEASESFNTFRAG(ClientInfo,data)        (ClientInfo)->ReleaseSfntFrag((voidPtr)data)

#define SFAC_BINARYITERATION \
	  newP = (uint16 *) ((char *)tableP + (usSearchRange >>= 1)); \
		if (charCode > (uint16) SWAPW (*newP)) tableP = newP;

#define SFAC_GETUNSIGNEDBYTEINC( p ) ((uint8)(*p++))

/* PRIVATE PROTOTYES */

FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir);

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);

FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*  pGlyphTableIndex);

FS_PRIVATE ErrorCode    sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
    const void * *     ppvTablePtr);

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,		/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);         /* Output glyph ID array        */

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift);		/* OUTPUT */

FS_PRIVATE ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	BBOX *              pbbox);             /* Glyph Bounding box           */

/*
 * Internal routine (make this an array and do a look up?)
 */
FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir)
{
	int32 Index;

	switch ((uint32)SWAPL(*((sfnt_TableTag *)&dir[SFNT_DIRECTORYENTRY_TAG])))
	{
		case tag_FontHeader:
			Index = (int32)sfnt_fontHeader;
			break;
		case tag_HoriHeader:
			Index = (int32)sfnt_horiHeader;
			break;
		case tag_IndexToLoc:
			Index = (int32)sfnt_indexToLoc;
			break;
		case tag_MaxProfile:
			Index = (int32)sfnt_maxProfile;
			break;
		case tag_ControlValue:
			Index = (int32)sfnt_controlValue;
			break;
		case tag_PreProgram:
			Index = (int32)sfnt_preProgram;
			break;
		case tag_GlyphData:
			Index = (int32)sfnt_glyphData;
			break;
		case tag_HorizontalMetrics:
			Index = (int32)sfnt_horizontalMetrics;
			break;
		case tag_CharToIndexMap:
			Index = (int32)sfnt_charToIndexMap;
			break;
		case tag_FontProgram:
			Index = (int32)sfnt_fontProgram;   /* <4> */
			break;
		case tag_GlyphDirectory:         /* Used for GlyphDirectory Download */
			Index = (int32)sfnt_GlyphDirectory;
			break;
		case tag_HoriDeviceMetrics:
			Index = (int32)sfnt_HoriDeviceMetrics;
			break;
		case tag_LinearThreshold:
			Index = (int32)sfnt_LinearThreshold;
			break;
		case tag_BitmapData:
			Index = (int32)sfnt_BitmapData;
			break;
		case tag_BitmapLocation:
			Index = (int32)sfnt_BitmapLocation;
			break;
		case tag_BitmapScale:
			Index = (int32)sfnt_BitmapScale;
			break;
		case tag_VertHeader:
			Index = (int32)sfnt_vertHeader;
			break;
		case tag_VerticalMetrics:
			Index = (int32)sfnt_verticalMetrics;
			break;
		case tag_OS_2:
			Index = (int32)sfnt_OS_2;
			break;
		default:
			Index = -1;
			break;
	}
	if (Index >= 0)
	{
		  TableDirectory[Index].ulOffset = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLEOFFSET]));
		  TableDirectory[Index].ulLength = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLELENGTH]));
	}
}


/*
 * Creates mapping for finding offset table     <4>
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *  ClientInfo)    /* Sfnt Client information */

{
	int32        i;
	uint8 *      sfntDirectory;
	int32        cTables;
	uint8 *      dir;

	STAT_OFF_CALLBACK;                  /* pause STAT timer */

	sfntDirectory = (uint8 *) GETSFNTFRAG (ClientInfo, 0L, (int32)SIZEOF_SFNT_OFFSETTABLE);

	STAT_ON_CALLBACK;                /* restart STAT timer */

	if (sfntDirectory != NULL)
	{
		cTables = (int32) SWAPW (*((uint16 *)&sfntDirectory[SFNT_OFFSETTABLE_NUMOFFSETS]));
		RELEASESFNTFRAG(ClientInfo, sfntDirectory);

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		sfntDirectory = (uint8 *) GETSFNTFRAG (
			ClientInfo,
			0L,
			((int32)SIZEOF_SFNT_OFFSETTABLE + (int32)SIZEOF_SFNT_DIRECTORYENTRY * (int32)(cTables)));

		STAT_ON_CALLBACK;             /* restart STAT timer */


		if (sfntDirectory == NULL)
		{
			return(CLIENT_RETURNED_NULL);
		}
	}
	else
	{
		return(NULL_SFNT_DIR_ERR);
	}

	/* Initialize */

	MEMSET (ClientInfo->TableDirectory, 0, sizeof (ClientInfo->TableDirectory));

	dir = &sfntDirectory[SFNT_OFFSETTABLE_TABLE];

	for (i = 0; i < cTables; i++)
	{
		sfac_Classify (ClientInfo->TableDirectory, dir);
		dir += SIZEOF_SFNT_DIRECTORYENTRY;
	}

	/* Used when glyphs are accessed from the base of memory */

	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulOffset = 0U;
	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulLength = ~0U;

	RELEASESFNTFRAG(ClientInfo, sfntDirectory);

	return NO_ERR;
}

/*
 * Use this function when only part of the table is needed.
 *
 * n is the table number.
 * offset is within table.
 * length is length of data needed.
 * To get an entire table, pass length = ULONG_MAX     <4>
 */

FS_PRIVATE ErrorCode sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
	const void **       ppvTablePtr)
{
	uint32      ulTableLength;

	ulTableLength = SFAC_LENGTH(ClientInfo, TableRef);

	if (ulTableLength > 0)
	{
		if(ulLength == ULONG_MAX)
		{
			ulLength = ulTableLength;
		}

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		*ppvTablePtr = (void *)GETSFNTFRAG (
			ClientInfo,
			(int32)(ulOffset + ClientInfo->TableDirectory[(int32)TableRef].ulOffset),
			(int32)ulLength);

		STAT_ON_CALLBACK;             /* restart STAT timer */

		if (*ppvTablePtr == NULL)
		{
			return CLIENT_RETURNED_NULL; /* Do a gracefull recovery   */
		}
	}
	else
	{
		*ppvTablePtr = (void *)NULL;

		if (bMustHaveTable)
		{
			return MISSING_SFNT_TABLE; /* Do a gracefull recovery  */
		}
	}

	return NO_ERR;
}


/*
 * This, is when we don't know what is going on
 */

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(mapping);
	FS_UNUSED_PARAMETER(charCode);
	FS_UNUSED_PARAMETER(ClientInfo);
	return MISSING_GLYPH_INDEX;
}


/*
 * Byte Table Mapping 256->256          <4>
 */
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(ClientInfo);
	if (charCode < MAX_FORMAT0_CHAR_INDEX)
	{
		return (uint16)mapping[charCode];
	}
	else
	{
		return MISSING_GLYPH_INDEX;
	}
}

/*
 * High byte mapping through table
 *
 * Useful for the national standards for Japanese, Chinese, and Korean characters.
 *
 * Dedicated in spirit and logic to Mark Davis and the International group.
 *
 *  Algorithm: (I think)
 *      First byte indexes into KeyOffset table.  If the offset is 0, keep going, else use second byte.
 *      That offset is from beginning of data into subHeader, which has 4 words per entry.
 *          entry, extent, delta, range
 *
 */

FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	uint16          usIndex;
	uint16          usMapMe;
	uint16          usHighByte;
	uint16          usGlyph;
	const uint8 *   Table2;
	const uint8 *   subHeader;

	FS_UNUSED_PARAMETER(ClientInfo);
	Table2 = (const uint8 *) mapping;

	usHighByte = (uint16)(charCode >> 8);

	if (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte])
	{
		usMapMe = (uint16)(charCode & 0xFF); /* We also need the low byte. */
	}
	else
	{
#ifdef  FSCFG_MICROSOFT_KK
		if(usHighByte != 0)
		{
			usMapMe = usHighByte;
		}
		else
		{
				usMapMe = (uint16)(charCode & 0xFF);
		}
#else
		usMapMe = usHighByte;
#endif
	}

	subHeader = (const uint8 *) ((char *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERS] +
		(uint16)SWAPW (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte]));

	usMapMe -= (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_FIRSTCODE]));    /* Subtract first code. */

	if (usMapMe < (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_ENTRYCOUNT])))
	{  /* See if within range. */

		usGlyph = (uint16)(* ((uint16 *) ((char *) &subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET] +
			(uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET]))) + usMapMe));

		if (usGlyph != 0) /* Note: usGlyph has not been swapped yet */
		{
			usIndex = (uint16)((int32)(uint32)(uint16)SWAPW(usGlyph) + (int32)SWAPW (*((int16 *)&subHeader[SFNT_SUBHEADER2_IDDELTA])));
		}
		else
		{
			usIndex = MISSING_GLYPH_INDEX;
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}

/*
 * Segment mapping to delta values, Yack.. !
 *
 * In memory of Peter Edberg. Initial code taken from code example supplied by Peter.
 */
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint16 *  tableP;
	const uint8 *   Table4;
	uint16          usIdDelta;
	uint16          usOffset;
	uint16          usIndex;
	uint16          usSegCountX2;
	uint16			usSearchRange;
	uint16			usEntrySelector;
	uint16			usRangeShift;
	const uint16 *  newP;    /* temporary pointer for binary iteration   */
	uint16          usStartCount;

	Table4 = (const uint8 *)mapping;

	usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));
	tableP = (const uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENDCOUNT];

	/* If there are just a few segments, skip straight to the linear search */

	if (usSegCountX2 >= MAX_LINEAR_X2 && charCode > 0xFF)
	{
		/* start with unrolled binary search */

		/* tableP points at endCount[] */
		if( ClientInfo == NULL )
		{
			sfac_ComputeBinarySearchParams(
				(uint16)(usSegCountX2 / 2),
				&usSearchRange,
				&usEntrySelector,
				&usRangeShift);
		}
		else
		{
			usSearchRange = ClientInfo->usFormat4SearchRange;

			/* Assert(SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_RANGESHIFT])) == ClientInfo->usFormat4RangeShift); */
			usRangeShift = ClientInfo->usFormat4RangeShift;

			/* Assert((uint16)SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENTRYSELECTOR])) == ClientInfo->usFormat4EntrySelector); */
			usEntrySelector = ClientInfo->usFormat4EntrySelector;
		}

		if (charCode >= (uint16) SWAPW (* ((uint16 *) ((char *)tableP + usSearchRange))))
		{
			tableP = (uint16 *) ((char *)tableP + usRangeShift); /* range to low shift it up */
		}


		switch( usEntrySelector )
		{
		case 15:
			SFAC_BINARYITERATION;
			/* fall through */
		case 14:
			SFAC_BINARYITERATION;
			/* fall through */
		case 13:
			SFAC_BINARYITERATION;
			/* fall through */
		case 12:
			SFAC_BINARYITERATION;
			/* fall through */
		case 11:
			SFAC_BINARYITERATION;
			/* fall through */
		case 10:
			SFAC_BINARYITERATION;
			/* fall through */
		case 9:
			SFAC_BINARYITERATION;
			/* fall through */
		case 8:
			SFAC_BINARYITERATION;
			/* fall through */
		case 7:
			SFAC_BINARYITERATION;
			/* fall through */
		case 6:
			SFAC_BINARYITERATION;
			/* fall through */
		case 5:
			SFAC_BINARYITERATION;
			/* fall through */
		case 4:
			SFAC_BINARYITERATION;
			/* fall through */
		case 3:
		case 2:   /* drop through */
		case 1:
		case 0:
			break;
		default:
			Assert(FALSE);
			break;
		}
	}

	/*  Now do linear search */

	while(charCode > (uint16) SWAPW(*tableP))
	{
		tableP++;
	}

	tableP++;                  /*  Skip Past reservedPad word    */

	/* End of search, now do mapping */

	tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point at startCount[] */
	usStartCount = (uint16) SWAPW (*tableP);

	if (charCode >= usStartCount)
	{
		  usOffset = (uint16)(charCode - (uint16) SWAPW (*tableP));
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idDelta[] */
		usIdDelta = (uint16) SWAPW (*tableP);
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idRangeOffset[] */

		if ((uint16) SWAPW (*tableP) == 0)
		{
				usIndex   = (uint16)(charCode + usIdDelta);
		}
		else
		{
			/* Use glyphIdArray to access index */

			usOffset += usOffset; /* make word offset */
			tableP   = (uint16 *) ((char *)tableP + (uint16) SWAPW (*tableP) + usOffset); /* point to glyphIndexArray[] */

			if((uint16)SWAPW (*tableP) != MISSING_GLYPH_INDEX)
			{
					 usIndex    = (uint16)((uint16) SWAPW (*tableP) + usIdDelta);
			}
			else
			{
				usIndex = MISSING_GLYPH_INDEX;
			}
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}


/*
 * Trimmed Table Mapping
 */

FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint8 *Table6;

	FS_UNUSED_PARAMETER(ClientInfo);

	Table6 = (const uint8 *) mapping;

	charCode  -= (uint16)SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_FIRSTCODE]));

	if (charCode < (uint16) SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_ENTRYCOUNT])))
	{
		return ((uint16) SWAPW (((uint16 *)&Table6[SFNT_MAPPINGTABLE6_GLYPHIDARRAY]) [charCode]));
	}
	else
	{
		return   MISSING_GLYPH_INDEX;
	}
}


/*
 * Sets up our mapping function pointer.
 */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *  ClientInfo,
	uint16            usPlatformID,
	uint16            usSpecificID)

{
	const uint8 *   table;
	const uint8 *   MappingTable;
	const uint8 *   Table4;
	boolean         bFound;
	ErrorCode       Ret;
	const uint8 *	plat;
	uint16			usSegCountX2;

	bFound = FALSE;

	/* the following code allow a client that is only interested by glyph indices to
               call fs_NewSfnt with -1 for PlatformID and SpecificID */
	if(usPlatformID == 0xFFFF)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}


	Ret = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, FALSE, (const void **)&table);

	if(Ret != NO_ERR)
	{
		return Ret;
	}


	if (table == NULL)
	{
		/* If no "cmap" is present, permits access to characters by glyph index */

		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}

	/* APPLE Code
	if(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_VERSION]) != 0)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	*/

	/* mapping */

	plat = (uint8 *) &table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM]; /* <4> */

	while(plat < (uint8 *)&table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM + ((uint16)SWAPW(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_NUMTABLES])) *
		  SIZEOF_SFNT_PLATFORMENTRY)] && !bFound)
	{
		if (((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_PLATFORMID])) == usPlatformID) &&
			((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_SPECIFICID])) == usSpecificID))
		{
			bFound = TRUE;
			ClientInfo->ulMapOffset = (uint32) SWAPL (*((uint32 *)&plat[SFNT_PLATFORMENTRY_PLATFORMOFFSET]));   /* skip header */
		}
		plat += SIZEOF_SFNT_PLATFORMENTRY;
	}


	if (!bFound)
	{
		ClientInfo->ulMapOffset = 0;
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	else
	{
		Assert(Ret == NO_ERR);
		MappingTable = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);  /* back up for header */
		ClientInfo->ulMapOffset += (uint32)SIZEOF_SFNT_MAPPINGTABLE;
	}

    ClientInfo->usMappingFormat = (uint16)SWAPW (*((uint16 *)&MappingTable[SFNT_MAPPINGTABLE_FORMAT]));

	switch (ClientInfo->usMappingFormat)
	{
	case 0:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex0;
		break;
	case 2:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex2;
		break;
	case 4:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex4;

		/* Pre-compute several values used for Index 4 lookups */
		/* This becomes necessary because of several font vendors who */
		/* have placed incorrect values in the TrueType font file. */

		Table4 = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);
		usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));

		sfac_ComputeBinarySearchParams(
			(uint16)(usSegCountX2 / 2),
			&ClientInfo->usFormat4SearchRange,
			&ClientInfo->usFormat4EntrySelector,
			&ClientInfo->usFormat4RangeShift);

		break;
	case 6:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex6;
		break;
	default:
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		Ret = UNKNOWN_CMAP_FORMAT;
		break;
	}
	RELEASESFNTFRAG(ClientInfo, table);

	return Ret;
}

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift)		/* OUTPUT */
{
	uint16			usLog;
	uint16			usPowerOf2;

	usLog = 0;
	usPowerOf2 = 1;

	while((2 * usPowerOf2) <= usSegCount )
	{
		usPowerOf2 *= 2;
		usLog++;
	}

	*pusSearchRange = 2 * usPowerOf2;
	*pusEntrySelector = usLog;
	*pusRangeShift = (2 * usSegCount) - (2 * usPowerOf2);
}

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *  ClientInfo,
	uint16            usCharacterCode)
{
	 const uint8 *   mappingPtr;
	ErrorCode   error;

	 error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	ClientInfo->usGlyphIndex = ClientInfo->GlyphMappingF (mappingPtr + ClientInfo->ulMapOffset, usCharacterCode, ClientInfo);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return NO_ERR;
}

/*  return glyph ID's for a range or for an array of character codes */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*  special version for Win95 doesn't require a font context */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,       /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
   	uint16              usMappingFormat;    /* cmap subtable format code    */
   	MappingFunc			pfnGlyphMapping;	/* mapping func char to glyph   */
    const uint8 *       pbyCmapData;        /* past subtable header         */
 	ErrorCode           errCode;

    usMappingFormat = (uint16)SWAPW (*((uint16 *)&pbyCmapSubTable[SFNT_MAPPINGTABLE_FORMAT]));
	switch (usMappingFormat)
	{
	case 0:
		pfnGlyphMapping = sfac_ComputeIndex0;
		break;
	case 2:
		pfnGlyphMapping = sfac_ComputeIndex2;
        break;
	case 4:
		pfnGlyphMapping = sfac_ComputeIndex4;
        break;
	case 6:
		pfnGlyphMapping = sfac_ComputeIndex6;
		break;
    default:
        return UNKNOWN_CMAP_FORMAT;
    }
    pbyCmapData = pbyCmapSubTable + SIZEOF_SFNT_MAPPINGTABLE;


    errCode = sfac_GetGlyphIDs (
   	    pfnGlyphMapping,
        pbyCmapData,
        NULL,                               /* ClientInfo */
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID );

	return errCode;
}

/* special helper function for NT
   - an offset usCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)        /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetLongGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
		ulCharCodeOffset,
	    pulCharCode,
	    pulGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*      common code for the two get glyph ID helper routines */

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	if (pusCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pusGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
            if (*pusCharCode == 0xFFFF)     /* trap illegal char code */
            {
                return INVALID_CHARCODE_ERR;
            }
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, *pusCharCode, ClientInfo);
            pusGlyphID++;
            pusCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*      special for NT */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)         /* Output glyph ID array        */
{
	if (pulCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
			if ((*pulCharCode + ulCharCodeOffset) > 0x0000FFFFL)
            {
                return INVALID_CHARCODE_ERR;   /* trap an illegal range */
            }
			usCharCode = (uint16) (*pulCharCode + ulCharCodeOffset);
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            pulCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusEmResolution,
	boolean *               pbIntegerScaling,
	LocalMaxProfile *       pMaxProfile)
{
	ErrorCode       error;
	const uint8 *   fontHead;
	const uint8 *   horiHead;
	const uint8 *   pTempMaxProfile;
	const uint8 *   pTempOS_2;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontHeader, TRUE, (const void **)&fontHead);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horiHeader, TRUE, (const void **)&horiHead);

	if(error != NO_ERR)
	{
		return error;
	}

	if ((uint32)SWAPL (*((uint32 *)&fontHead[SFNT_FONTHEADER_MAGICNUMBER])) != SFNT_MAGIC)
	{
		return BAD_MAGIC_ERR;
	}

	*pusEmResolution     = (uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_UNITSPEREM]));
	if(*pusEmResolution < 16 || *pusEmResolution > 16384)
		return BAD_UNITSPEREM_ERR;
		
	*pbIntegerScaling    = (((uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_FLAGS]))& USE_INTEGER_SCALING) ==
									 USE_INTEGER_SCALING);

	ClientInfo->usNumberOf_LongHorMetrics = (uint16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS]));
	if(ClientInfo->usNumberOf_LongHorMetrics == 0)
		return BAD_NUMLONGHORMETRICS_ERR;

	ClientInfo->sIndexToLocFormat       = SWAPW (*((int16 *)&fontHead[SFNT_FONTHEADER_INDEXTOLOCFORMAT]));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_OS_2, FALSE, (const void **)&pTempOS_2); /* not a mandatory table */

	if(error != NO_ERR)
	{
		return error;
	}

	if(pTempOS_2 != NULL)
	{
		/* get TypoAscender and TypoDescender from the OS/2 table */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPOASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPODESCENDER]));
		RELEASESFNTFRAG(ClientInfo, pTempOS_2);
	} else {
		/* if OS/2 is not there get the values from horizontal header */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));
	}
	ClientInfo->sWinDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));

	RELEASESFNTFRAG(ClientInfo, horiHead);
	RELEASESFNTFRAG(ClientInfo, fontHead);

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_maxProfile, TRUE, (const void **)&pTempMaxProfile);

	if(error != NO_ERR)
	{
		return error;
	}

	pMaxProfile->version =              (Fixed)SWAPL(*((Fixed *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_VERSION]));
	pMaxProfile->numGlyphs =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_NUMGLYPHS]));
	pMaxProfile->maxPoints =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXPOINTS]));
	pMaxProfile->maxContours =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCONTOURS]));
	pMaxProfile->maxCompositePoints =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS]));
	pMaxProfile->maxCompositeContours = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS]));
	pMaxProfile->maxElements =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXELEMENTS]));
	pMaxProfile->maxTwilightPoints =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS]));
	pMaxProfile->maxStorage =           (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTORAGE]));
	pMaxProfile->maxFunctionDefs =      (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS]));
	pMaxProfile->maxInstructionDefs =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS]));
	pMaxProfile->maxStackElements =     (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS]));
	pMaxProfile->maxSizeOfInstructions =(uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS]));
	pMaxProfile->maxComponentElements = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS]));
	pMaxProfile->maxComponentDepth =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH]));

	RELEASESFNTFRAG(ClientInfo, pTempMaxProfile);

	error = sfac_ReadNumLongVertMetrics(ClientInfo, &ClientInfo->usNumLongVertMetrics,&ClientInfo->bValidNumLongVertMetrics);

	return error;
}



/*
 *
 */

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	int16 *             psNonScaledLSB)
{
	const uint8 *   horizMetricPtr;
	uint16          numberOf_LongHorMetrics;
	ErrorCode       error;
	int16 *         lsb;

	numberOf_LongHorMetrics = ClientInfo->usNumberOf_LongHorMetrics;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horizontalMetrics, TRUE, (const void **)&horizMetricPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	if (glyphIndex < numberOf_LongHorMetrics)
	{
		*pusNonScaledAW     = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB     = SWAPW (*((int16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING]));
	}
	else
	{
		lsb = (int16 *) (char *)& horizMetricPtr[numberOf_LongHorMetrics * SIZEOF_SFNT_HORIZONTALMETRICS]; /* first entry after[AW,LSB] array */

		*pusNonScaledAW       = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[((numberOf_LongHorMetrics-1) * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB      = SWAPW (lsb[glyphIndex - numberOf_LongHorMetrics]);
	}

	RELEASESFNTFRAG(ClientInfo, horizMetricPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledTSB)
{
	const uint8 *   vertMetricPtr;
	uint16          usNumLongVertMetrics;       /* number of entries with AH */
	ErrorCode       error;
	int16 *         psTSB;
	BBOX            bbox;           


	usNumLongVertMetrics = ClientInfo->usNumLongVertMetrics;
	if(ClientInfo->bValidNumLongVertMetrics)
	{

		error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_verticalMetrics, FALSE, (const void **)&vertMetricPtr);  /* not a mandatory table */

		if(error != NO_ERR)
		{
			return error;
		}
	}

	if (ClientInfo->bValidNumLongVertMetrics && (vertMetricPtr != NULL) )
	{
		if (glyphIndex < usNumLongVertMetrics)
		{
			*pusNonScaledAH     = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB     = SWAPW (*((int16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_TOPSIDEBEARING]));
		}
		else
		{
			psTSB = (int16 *) (char *)& vertMetricPtr[usNumLongVertMetrics * SIZEOF_SFNT_VERTICALMETRICS]; /* first entry after[AW,TSB] array */

			*pusNonScaledAH       = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[((usNumLongVertMetrics-1) * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB      = SWAPW (psTSB[glyphIndex - usNumLongVertMetrics]);
		}

		RELEASESFNTFRAG(ClientInfo, vertMetricPtr);
	} else {

		/* We don't have vertical metrics, let's set to default values */

		/* to get the glyph bbox for the defalut value of the vertical metrics */
		error = sfac_ReadGlyphBbox(ClientInfo,ClientInfo->usGlyphIndex, &bbox);

		if(error != NO_ERR)
		{
			return error;
		}		

		/* default if no vertical metrics found */
		*pusNonScaledAH = ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender;   
		*psNonScaledTSB = ClientInfo->sDefaultAscender - bbox.yMax;
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB,
    int16 *             psNonScaledTopOriginX)
{
	ErrorCode       error;

	error = sfac_ReadGlyphHorMetrics (ClientInfo, glyphIndex, pusNonScaledAW, psNonScaledLSB);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_ReadGlyphVertMetrics (ClientInfo, glyphIndex, pusNonScaledAH, psNonScaledTSB);

    /* for characters whose adwance width equal the box size, we want to have this origin shifted by the descender so that
       the baseline of non sideways glyphs will align correctely. If the advance width is different we want to adjust to keep the optical center 
       of the character aligned */
    * psNonScaledTopOriginX = -ClientInfo->sDefaultDescender -((ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender - *pusNonScaledAW) /2);

	return error;
}

/*
 *  Read Number of Long Vertical Metrics from vhea table
 */

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusNumLongVertMetrics,
	boolean *               pbValidNumLongVertMetrics )
{
	ErrorCode       error;
	const uint8 *   vertHead;

	*pbValidNumLongVertMetrics = FALSE;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_vertHeader, FALSE, (const void **)&vertHead);

	if(error != NO_ERR)
	{
		return error;
	}		
	
	if(vertHead != NULL)
	{
		*pusNumLongVertMetrics = (uint16)SWAPW (*((uint16 *)&vertHead[SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS]));
		*pbValidNumLongVertMetrics = TRUE;

		RELEASESFNTFRAG(ClientInfo, vertHead);
	}

	return NO_ERR;
}


FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*    pGlyphTableIndex)

{
	const void *    indexPtr;
	ErrorCode       error;
	uint16 *        shortIndexToLoc;
	uint32 *        longIndexToLoc;
	uint32 *        offsetPtr;
	uint16 *        lengthPtr;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_GlyphDirectory, FALSE, (const void **)&indexPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	/* If there is a glyph directory, first check for the glyph there.  */

	if (indexPtr != NULL)
	{
		offsetPtr = (uint32 *)((char *)indexPtr+((int32)gIndex*(int32)(sizeof(int32)+sizeof(uint16))));
		lengthPtr = (uint16 *)(char *)(offsetPtr+1);

		*ulOffset = (uint32)SWAPL(*offsetPtr);

		if(*ulOffset == 0L)
		{
			*ulLength =  0L;
		}
		else
		{
			*ulLength =  (uint32) (uint16)SWAPW(*lengthPtr);
		}

		/* sfnt_BeginningOfFont references the beginning of memory  */

		*pGlyphTableIndex = sfnt_BeginningOfFont;

		RELEASESFNTFRAG(ClientInfo, indexPtr);
		return NO_ERR;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_indexToLoc, TRUE, (const void **)&indexPtr);
	if(error != NO_ERR)
	{
		return error;
	}

	if (ClientInfo->sIndexToLocFormat == SHORT_INDEX_TO_LOC_FORMAT)
	{
		shortIndexToLoc = (uint16 *)indexPtr + gIndex;
		*ulOffset = (uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1;
		shortIndexToLoc++;
		*ulLength =  (((uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1) - *ulOffset);
	}
	else
	{
		longIndexToLoc = (uint32 *)indexPtr + gIndex;
		*ulOffset = (uint32) SWAPL (*longIndexToLoc);
		longIndexToLoc++;
		*ulLength = ((uint32)SWAPL (*longIndexToLoc) - *ulOffset);
	}

	*pGlyphTableIndex = sfnt_glyphData;

	RELEASESFNTFRAG(ClientInfo, indexPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,    /* Client Information         */
	char *              pFontProgram,  /* pointer to Font Program    */
	char *              pPreProgram)   /* pointer to Pre Program     */
{
	uint32              ulLength;
	const char *        pFragment;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_fontProgram);
	if (ulLength)
	{
		MEMCPY (pFontProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_preProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	if (ulLength)
	{
		MEMCPY (pPreProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,    /* Client Information   */
	F26Dot6 *           pCVT)       /* pointer to CVT    */
{
	uint32              ulLength;
	const int16 *       pFragment;
	int32               lNumCVT;
	int32               lCVTCount;
	const int16 *       psSrcCVT;
	F26Dot6 *           pfxDstCVT;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_controlValue, FALSE, (const void **)&pFragment);

	if(error)
	{
		return error;
	}

	ulLength = SFAC_LENGTH (ClientInfo, sfnt_controlValue);

	if (ulLength)
	{
		psSrcCVT = pFragment;
		pfxDstCVT = pCVT;

		lNumCVT = ((int32)ulLength / (int32)sizeof( sfnt_ControlValue));

		for(lCVTCount = 0L; lCVTCount < lNumCVT; lCVTCount++)
		{
			pfxDstCVT[lCVTCount] = (F26Dot6)SWAPW(psSrcCVT[lCVTCount]);
		}

		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           pbFound,        /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pHdmx;
	const uint8 *       pCurrentHdmxRecord;
	uint32              ulHdmxRecordSize;
	uint16              usRecordIndex;
	uint16              usGlyphIndex;
	ErrorCode           error;

	Assert( usFirstGlyph <= usLastGlyph );
	Assert( psBuffer != NULL );

	*pbFound = FALSE;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_HoriDeviceMetrics, FALSE, (const void **)&pHdmx);

	if(error)
	{
		return error;
	}

	/* If no 'hdmx' return success and not found    */

	if( pHdmx == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pHdmx[SFNT_HDMX_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		ulHdmxRecordSize = (uint32)SWAPL(*((uint32 *)&pHdmx[SFNT_HDMX_LSIZERECORD]));

		usRecordIndex = 0;
		pCurrentHdmxRecord = &pHdmx[SFNT_HDMX_HDMXTABLE];
		while (  (usRecordIndex < (uint16)SWAPW(*((uint16 *)&pHdmx[SFNT_HDMX_SNUMRECORDS]))) && !*pbFound )
		{
			if( usPixelsPerEm == (uint16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BEMY] )
			{
				*pbFound = TRUE;
			}
			else
			{
				pCurrentHdmxRecord += ulHdmxRecordSize;
			}
			usRecordIndex++;
		}

		if ( *pbFound )
		{
			for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
			{
				*psBuffer = (int16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BWIDTHS + usGlyphIndex];
				psBuffer++;
			}
		}
	}

	RELEASESFNTFRAG(ClientInfo, pHdmx);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pLTSH;
	uint16              usGlyphIndex;
	ErrorCode           error;

	MEMSET(psBuffer, FALSE, ((usLastGlyph - usFirstGlyph) + 1) * sizeof(int16));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_LinearThreshold, FALSE, (const void **)&pLTSH);

	if(error)
	{
		return error;
	}
	
	if( pLTSH == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pLTSH[SFNT_LTSH_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++ )
		{
			if( usPixelsPerEm >= (uint16)pLTSH[SFNT_LTSH_UBYPELSHEIGHT + usGlyphIndex] )
			{
				*psBuffer = TRUE;
			}
			else
			{
				*psBuffer = FALSE;
			}
			psBuffer++;
		}
	}

	RELEASESFNTFRAG(ClientInfo, pLTSH);

	return NO_ERR;
}



/***************************** Public  Function ****************************\
* sfac_ReadGlyphHeader
*
* This routine sets up the glyph handle to a glyph, and returns the header
* information in the glyph.
*
* Effects:
*
* Error Returns:
*
* UNKNOWN_COMPOSITE_VERSION
*
* History:
* Wed 26-Aug-1992 09:55:19 -by-  Greg Hitchcock [gregh]
*      Added CodeReview fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	sfac_GHandle *      hGlyph,           /* Return glyph handle        */
	boolean *           pbCompositeGlyph, /* Is glyph a composite?      */
	boolean *           pbHasOutline,     /* Does glyph have outlines?  */
	int16 *             psNumberOfContours, /* Number of contours in glyph */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;

	hGlyph->pvGlyphBaseAddress = NULL;
	hGlyph->pvGlyphNextAddress = NULL;

	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		*psNumberOfContours = 1;
		MEMSET(pbbox, 0, sizeof(BBOX));
		*pbHasOutline = FALSE;
		*pbCompositeGlyph = FALSE;
	}
	else
	{
		if (ulLength < SFNT_PACKEDSPLINEFORMAT_ENDPOINTS)
		{
			return GLYF_TABLE_CORRUPTION_ERR;
		}

		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&hGlyph->pvGlyphBaseAddress);

		if(error)
		{
			return error;
		}

		hGlyph->pvGlyphEndAddress = (uint8 *)hGlyph->pvGlyphBaseAddress + ulLength;

		GlyphHeader = (uint8 *)hGlyph->pvGlyphBaseAddress;
		*psNumberOfContours = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS]));

		if( *psNumberOfContours < COMPONENTCTRCOUNT )
		{
			return UNKNOWN_COMPOSITE_VERSION;
		}

		if( *psNumberOfContours == COMPONENTCTRCOUNT )
		{
			*pbCompositeGlyph = TRUE;
			*psNumberOfContours = 0;
			*pbHasOutline = FALSE;
		}
		else
		{
			*pbCompositeGlyph = FALSE;
			*pbHasOutline = TRUE;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}

		if(pbHasOutline)
		{
			hGlyph->pvGlyphNextAddress = (voidPtr)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_ENDPOINTS];
		}
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadGlyphBbox
*
*
* Effects:
*         This function release the glyph memory immediately
*
* Error Returns:
*
* SFNT_DATA_ERR
*
* History:
* Wed 20-Dec-1996 18:42:51 -by-  Claude Betrisey [claudebe]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;


	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		MEMSET(pbbox, 0, sizeof(BBOX));
	}
	else
	{
		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&GlyphHeader);

		if(error)
		{
			return error;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		RELEASESFNTFRAG(ClientInfo, GlyphHeader );

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}


	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadOutlineData
*
*   This routine reads the outline data from the font file. This information
*   includes x and y coordinates, and on-curve indicators as well as start/end
*   points, flags, and instruction data.
*
* Effects:
*   hGlyph
*
* Error Returns:
*   CONTOUR_DATA_ERR
*
* History:
* Wed 26-Aug-1992 09:55:49 -by-  Greg Hitchcock [gregh]
*      Added Code Review fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/


FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	uint8 *             abyOnCurve,             /* Array of on curve indicators per point */
	F26Dot6 *           afxOoy,                 /* Array of ooy points for every point    */
	F26Dot6 *           afxOox,                 /* Array of oox points for every point    */
	sfac_GHandle *      hGlyph,
	LocalMaxProfile *   pMaxProfile,            /* copy of profile                        */
	boolean             bHasOutline,            /* Does glyph have outlines?              */
	int16               sNumberOfContours,      /* Number of contours in glyph            */
	int16 *             asStartPoints,          /* Array of start points for every contour   */
	int16 *             asEndPoints,            /* Array of end points for every contour    */
	uint16 *            pusSizeOfInstructions,  /* Size of instructions in bytes        */
	 uint8 **               pbyInstructions,    /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours) /* total number of contours for composites, to check for overflow */

{

	uint8 *     pbyCurrentSfntLocation;
	int16 *     psCurrentLocation;
	int16 *     asSfntEndPoints;
	uint8 *     pbySfntFlags;
	uint8       byRepeatFlag;

	int32       lNumPoints;
	int32       lContourIndex;
	int32       lPointCount;
	int32       lPointIndex;
	uint16      usRepeatCount;
	int16       sXValue;
	int16       sYValue;
	uint8 *     pbyFlags;
	F26Dot6 *   pf26OrigX;
	F26Dot6 *   pf26OrigY;

	/* Initialize Fields */

	asStartPoints[0] = 0;
	asEndPoints[0] = 0;

	abyOnCurve[0] = ONCURVE;
	afxOox[0] = 0;
	afxOoy[0] = 0;

	*pbyInstructions = NULL;
	*pusSizeOfInstructions = 0;

	/* If we don't have an outline, exit here   */

	if (!bHasOutline)
	{
		return NO_ERR;
	}

	if (sNumberOfContours <= 0 || sNumberOfContours > (int16)pMaxProfile->maxContours)
	{
		return CONTOUR_DATA_ERR;
	}

    /* Handle the case of outlines   */

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	asSfntEndPoints = psCurrentLocation;
	psCurrentLocation += sNumberOfContours;

	if ((voidPtr)psCurrentLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	pbySfntFlags = (uint8 *)((char *)psCurrentLocation + *pusSizeOfInstructions);

	if ((voidPtr)pbySfntFlags > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}


    *pCompositeContours += sNumberOfContours;
	if (*pCompositeContours > (uint32)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours))
	{
		return CONTOUR_DATA_ERR;
	}

	lContourIndex = 0;

	asStartPoints[lContourIndex] = 0;
	asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
	lNumPoints = (int32)asEndPoints[lContourIndex] + 1;

	for(lContourIndex = 1; lContourIndex < (int32)sNumberOfContours; lContourIndex++)
	{
		asStartPoints[lContourIndex] = (int16)(asEndPoints[lContourIndex - 1] + 1);
		asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
		if ((lNumPoints > asEndPoints[lContourIndex]) || (lNumPoints > (int32)pMaxProfile->maxPoints) || (lNumPoints <= 0))
		{
			/* array of end points is not in ascending order, or too many points */
			/* or negative, that mean overflow since it's signed int16 instead of unsigned int16, for example 0xcdab */
			return POINTS_DATA_ERR;
		}
		lNumPoints = (int32)asEndPoints[lContourIndex] + 1;
	}

	if (lNumPoints <= 0)
	{
		return POINTS_DATA_ERR;
	}

    *pCompositePoints += lNumPoints;
	if (*pCompositePoints > (uint32)MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints) )
	{
		return POINTS_DATA_ERR;
	}

	/* Do flags */

	usRepeatCount = 0;

	lPointCount = lNumPoints;
	pbyFlags = abyOnCurve;

	while(lPointCount > 0)
	{
		if(usRepeatCount == 0)
		{
			*pbyFlags = *pbySfntFlags;

			if(*pbyFlags & REPEAT_FLAGS)
			{
				pbySfntFlags++;
				usRepeatCount = (uint16)*pbySfntFlags;
			}
			pbySfntFlags++;
			pbyFlags++;
			lPointCount--;
		}
		else
		{
			byRepeatFlag = pbyFlags[-1];
			lPointCount -= (int32)usRepeatCount;

			if (lPointCount < 0)
			{
				return GLYF_TABLE_CORRUPTION_ERR;
			}

			while(usRepeatCount > 0)
			{
				*pbyFlags = byRepeatFlag;
				pbyFlags++;
				usRepeatCount--;
			}
		}
	}

	pbyCurrentSfntLocation = pbySfntFlags;

	if(usRepeatCount > 0)
	{
		return POINTS_DATA_ERR;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Do X first */

	sXValue = 0;
	pf26OrigX = afxOox;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & XSHORT)
		{
			if(*pbyFlags & SHORT_X_IS_POS)
			{
				sXValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sXValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_X_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sXValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigX = (F26Dot6)sXValue;
		pf26OrigX++;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Now Do Y */

	sYValue = 0;
	pf26OrigY = afxOoy;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & YSHORT)
		{
			if(*pbyFlags & SHORT_Y_IS_POS)
			{
				sYValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sYValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_Y_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sYValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigY = (F26Dot6)sYValue;
		pf26OrigY++;

		/* Clear out extraneous bits in OnCurve */

		*pbyFlags &= ONCURVE;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	hGlyph->pvGlyphNextAddress = (voidPtr)pbyCurrentSfntLocation;

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadComponentData
*
*   This routine reads information from the font file for positioning and
*   scaling a glyph component.
*
* Effects:
*
* Error Returns:
*   none
*
* History:
* Wed 26-Aug-1992 09:56:29 -by-  Greg Hitchcock [gregh]
*      Added Code Review Fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets  */
	boolean *               pbRoundXYToGrid,  /* Round composite offsets to grid     */
	boolean *               pbUseMyMetrics,   /* Use component metrics            */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions         */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component         */
	int16 *                 psXOffset,        /* X Offset of component (if app)      */
	int16 *                 psYOffset,        /* Y Offset of component (if app)      */
	uint16 *                pusAnchorPoint1,  /* Anchor point 1 of component (if app) */
	uint16 *                pusAnchorPoint2,  /* Anchor point 2 of component (if app) */
	transMatrix             *pMulT,           /* Transformation matrix for component */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent)   /* Is this the last component?                  */

{
	int16 *     psCurrentLocation;
	uint16      usComponentFlags;
	char *      byteP;

	Fixed       fMultiplier;


	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	/* Initialize values */

	/* Initialize transformation matrix to identity */

	*pMulT = IdentTransform;

	*psXOffset = 0;
	*psYOffset = 0;
	*pusAnchorPoint1 = 0;
	*pusAnchorPoint2 = 0;
	*pbWeHaveAScale = FALSE;

	usComponentFlags = (uint16)SWAPWINC(psCurrentLocation);

	*pbWeHaveInstructions = ((usComponentFlags & WE_HAVE_INSTRUCTIONS) == WE_HAVE_INSTRUCTIONS);
	*pbUseMyMetrics =    ((usComponentFlags & USE_MY_METRICS) == USE_MY_METRICS);
	*pbRoundXYToGrid =      ((usComponentFlags & ROUND_XY_TO_GRID) == ROUND_XY_TO_GRID);

	/* new flags that indicate if the glyph was designed to have the component offset scaled or not
	   Apple does scale the component offset, MS doesn't, those flags are supposed to be clear on old fonts
	   on new fonts, only one of these flags must be set,
	   default is set to false, MS behavior */
	if ((usComponentFlags & SCALED_COMPONENT_OFFSET) == SCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = TRUE;
	}
	if ((usComponentFlags & UNSCALED_COMPONENT_OFFSET) == UNSCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = FALSE;
	}

	*pusComponentGlyphIndex = (uint16)SWAPWINC(psCurrentLocation);

	if (usComponentFlags & ARGS_ARE_XY_VALUES)
	{
		*pMultiplexingIndicator = OffsetPoints;
	}
	else
	{
		*pMultiplexingIndicator = AnchorPoints;
	}


	/*
		!!!APPLEBUG The rasterizer did not handle Word Anchor Points. This
		!!!APPLEBUG has been corrected in our version of the rasterizer, but
		!!!APPLEBUG we need to verify with the Apple source code.  --GregH
	 */

	if (usComponentFlags & ARG_1_AND_2_ARE_WORDS)
	{
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
			*psXOffset    = SWAPWINC (psCurrentLocation);
			*psYOffset    = SWAPWINC (psCurrentLocation);
		}
		else
		{
			*pusAnchorPoint1 = (uint16) SWAPWINC (psCurrentLocation);
			*pusAnchorPoint2 = (uint16) SWAPWINC (psCurrentLocation);
		}
	}
	else
	{
		byteP = (char *)psCurrentLocation;
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
		/* offsets are signed */
			*psXOffset = (int16)(int8)*byteP++;
			*psYOffset = (int16)(int8)*byteP;
		}
		else
		{
		/* anchor points are unsigned */
			*pusAnchorPoint1 = (uint16)(uint8) * byteP++;
			*pusAnchorPoint2 = (uint16)(uint8) * byteP;
		}
		++psCurrentLocation;
	}


	if (usComponentFlags & (WE_HAVE_A_SCALE | WE_HAVE_AN_X_AND_Y_SCALE | WE_HAVE_A_TWO_BY_TWO))
	{

		*pbWeHaveAScale = TRUE;

		if (usComponentFlags & WE_HAVE_A_TWO_BY_TWO)
		{
			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][1] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][1] = (fMultiplier << 2); /* turn into 16.16 */

		}
		else
		{
			/* If we have a scale factor, build it into the transformation matrix   */

			pMulT->transform[0][1] = 0;
			pMulT->transform[1][0] = 0;

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier <<= 2); /* turn into 16.16 */

			if (usComponentFlags & WE_HAVE_AN_X_AND_Y_SCALE)
			{
				fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
				pMulT->transform[1][1] = (fMultiplier <<= 2); /* turn into 16.16 */
			}
			else
			{
				pMulT->transform[1][1] = pMulT->transform[0][0];
			}
		}
	}
	*pbLastComponent = !((usComponentFlags & MORE_COMPONENTS) == MORE_COMPONENTS);

	hGlyph->pvGlyphNextAddress = (voidPtr)psCurrentLocation;

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadCompositeInstructions
*
*   This routine returns the instructions for the composite
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle * hGlyph,
	uint8 **    pbyInstructions,     /* Pointer to start of glyph instructions */
	uint16 *    pusSizeOfInstructions) /* Size of instructions in bytes           */
{
	int16 *    psCurrentLocation;

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	hGlyph->pvGlyphNextAddress = (voidPtr)(*pbyInstructions + *pusSizeOfInstructions);

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReleaseGlyph
*
*   This routine releases the glyph handle for the font file
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *  ClientInfo,
	sfac_GHandle *    hGlyph)
{
	if(hGlyph->pvGlyphNextAddress)
	{
		RELEASESFNTFRAG(ClientInfo,(voidPtr)hGlyph->pvGlyphBaseAddress);

		hGlyph->pvGlyphNextAddress = NULL;
		hGlyph->pvGlyphBaseAddress = NULL;

	}

	return NO_ERR;
}

/***************************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

/*  Local constants  */

#define     SBIT_BLOC_TABLE         1       /* which table are metrics in */
#define     SBIT_BDAT_TABLE         2

#define     SBIT_HORIZ_METRICS      1       /* which kind of metrics */
#define     SBIT_VERT_METRICS       2
#define     SBIT_BIG_METRICS        3

typedef enum {                              /* metrics type */
	flgHorizontal = 0x01,
	flgVertical = 0x02
} bitmapFlags;

FS_PRIVATE boolean FindBlocStrike (         /* helper function prototype */
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset );

FS_PRIVATE boolean FindBscaStrike (         /* helper function prototype */
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset );

/*  byte size bitmap range masks */

static uint8    achStartMask[] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 };
static uint8    achStopMask[] =  { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };
					
/**********************************************************************/

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset )
{
	const uint8 *   pbyBloc;
	const uint8 *   pbyBsca;
	ErrorCode       ReturnCode;
	
	*pusTableState = SBIT_NOT_FOUND;                /* defaults */
	*pulStrikeOffset = 0L;
	*pusSubPpemX = 0;
	*pusSubPpemY = 0;

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		0L,                                         /* table start */
		ULONG_MAX,                                  /* read whole table */
		sfnt_BitmapLocation,                        /* registered tag */
		FALSE,                                      /* doesn't have to be there */
		(const void**)&pbyBloc );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
	
	if (pbyBloc != NULL)                            /* if bloc exists */
	{
		if (FindBlocStrike (pbyBloc, usPpemX, usPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
		{
			*pusTableState = SBIT_BLOC_FOUND;       /* exact match */
		}
		else                                        /* if bloc and NO match */
		{
			ReturnCode = sfac_GetDataPtr (
				pClientInfo,                        /* callback etc. */
				0L,                                 /* table start */
				ULONG_MAX,                          /* read whole table */
				sfnt_BitmapScale,                   /* registered tag */
				FALSE,                              /* doesn't have to be there */
				(const void**)&pbyBsca );           /* data pointer */
			
			if (ReturnCode != NO_ERR) return ReturnCode;
			
			if (pbyBsca != NULL)                    /* if bsca exists */
			{
				if (FindBscaStrike (pbyBsca, usPpemX, usPpemY, pulStrikeOffset))
				{
					*pusSubPpemX = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMX];
					*pusSubPpemY = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMY];
					
					if (FindBlocStrike (pbyBloc, *pusSubPpemX, *pusSubPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
					{
						*pusTableState = SBIT_BSCA_FOUND;
					}
				}
				RELEASESFNTFRAG(pClientInfo, pbyBsca );
			}
		}
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
	}
	return NO_ERR;
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bloc table */

FS_PRIVATE boolean FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	uint32          ulColorRefOffset;
	uint16			usPreferedBitDepth, usBestBitDepth, usCurrentBitDepth;
	uint16			usSbitBitDepthMask;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

	usBestBitDepth = 0;
	
	if (usOverScale == 0)
	{
		usPreferedBitDepth = 1;
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & 0x0002; /* accept only black/white bitmap */
	} else 
	{
		if (usOverScale == 2)
		{
			usPreferedBitDepth = 2;
		} else if (usOverScale == 4) 
		{
			usPreferedBitDepth = 4;
		} else
		{
			usPreferedBitDepth = 8;
		}
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & ~0x0002; /* accept only grayscale bitmap */
	} 

	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpemY == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
			ulColorRefOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_COLORREF]));
			usCurrentBitDepth = pbyBloc[ulStrikeOffset + SFNT_BLOC_BITDEPTH];

			if (((0x01 << usCurrentBitDepth) & usSbitBitDepthMask) && (ulColorRefOffset == 0L))
			{
				if (usCurrentBitDepth == usPreferedBitDepth)
				{
					/* perfect match */
					*pulStrikeOffset = ulStrikeOffset;
					*pusBitDepth = usPreferedBitDepth;
					return TRUE;      
				} else if (usCurrentBitDepth > usPreferedBitDepth)
				{
					/* above is better than below */
					if ((usCurrentBitDepth < usBestBitDepth) || (usBestBitDepth < usPreferedBitDepth))
					{
						/* above and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				} else /* if (usCurrentBitDepth < usPreferedBitDepth) */
				{
					/* we look below the prefered only if we don't have found anything above */
					if ((usBestBitDepth < usPreferedBitDepth) && (usCurrentBitDepth > usBestBitDepth))
					{
						/* below and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				}
			}
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	if (usBestBitDepth != 0)
	{
		*pusBitDepth = usBestBitDepth;
		return TRUE;                                   /* best match found */
	} 

	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bsca table */

FS_PRIVATE boolean FindBscaStrike (
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBsca[SFNT_BSCA_NUMSIZES]));
	ulStrikeOffset = SFNT_BSCA_FIRSTSTRIKE;
								
	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMX]) &&
			(usPpemY == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMY]))
		{
			*pulStrikeOffset = ulStrikeOffset;
			return TRUE;                            /* match found */
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BSCA_SIZESUBTABLE;
	}
	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Look for a glyph in a given strike */        

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,                   /* return values */
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength )
{
	const uint8 *   pbyBloc;
	ErrorCode       ReturnCode;

	uint32      ulNumIndexTables;
	uint32      ulIndexArrayTop;
	uint32      ulIndexArrayOffset;
	uint32      ulSubTableOffset;
	uint32      ulGlyphOffset;
	uint32      ulNextGlyphOffset;
	uint32      ulBitmapLength;
	uint32      ulImageDataOffset;
	uint32      ulNumGlyphs;
	uint32      ulTop;                      /* binary search ranges */
	uint32      ulBottom;
	uint32      ulHit;
	uint32      ulHitOffset;

	uint16      usStartGlyph;               /* for whole strike */
	uint16      usEndGlyph;
	uint16      usFirstGlyph;               /* for one sub table */
	uint16      usLastGlyph;
	uint16      usIndexFormat;
	uint16      usImageFormat;
	uint16      usHitCode;
	
	bitmapFlags bmfDirection;               /* horiz or vert */

	
	*pbGlyphFound = FALSE;                              /* default */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                    /* callback etc. */
		0L,                                             /* table start */
		ULONG_MAX,                                      /* read whole table */
		sfnt_BitmapLocation,                            /* registered tag */
		TRUE,                                           /* better be there now */
		(const void**)&pbyBloc );                       /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
		
	usStartGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_STARTGLYPH]));
	usEndGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_ENDGLYPH]));

	if ((usStartGlyph > usGlyphCode) || (usEndGlyph < usGlyphCode))
	{
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
		return NO_ERR;                                  /* glyph out of range */
	}

	ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
	ulIndexArrayTop = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
	ulIndexArrayOffset = ulIndexArrayTop;

	while ((ulNumIndexTables > 0) && (*pbGlyphFound == FALSE))
	{
		usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
		usLastGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
	
		if ((usFirstGlyph <= usGlyphCode) && (usLastGlyph >= usGlyphCode))
		{
			ulSubTableOffset = ulIndexArrayTop +
				(uint32)SWAPL(*((uint32*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_ADDITIONALOFFSET]));
			
			usIndexFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_INDEXFORMAT]));
			usImageFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEFORMAT]));
			ulImageDataOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEOFFSET]));

/* decode the individual index subtable formats */            

			switch(usIndexFormat)                       /* different search req's */
			{
			case 1:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint32) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint32);
				ulNextGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 2:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX2IMAGESIZE]));
				ulImageDataOffset += ulBitmapLength * (usGlyphCode - usFirstGlyph);
				*pulBitmapOffset = ulImageDataOffset;
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX2METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				break;
			
			case 3:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint16) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint16);
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 4:
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX4NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX4OFFSETARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					}
				}
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4OFFSET]));
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SIZEOF_CODEOFFSETPAIR + SFNT_BLOC_IDX4OFFSET]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;
				
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 5:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5IMAGESIZE]));
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX5METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX5CODEARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
					}
				}
				ulImageDataOffset += ulBitmapLength * ulHit;
				*pulBitmapOffset = ulImageDataOffset;
				break;
			
			
			default:
				
				RELEASESFNTFRAG(pClientInfo, pbyBloc);
				return NO_ERR;                          /* unknown format */
			}

/* use the glyph formats to calculate metrics type & data offsets */
				
			*pulBitmapLength = ulBitmapLength;
			*pusBitmapFormat = usImageFormat;           /* save for bitmap decoding */
			bmfDirection = (bitmapFlags)pbyBloc[ulStrikeOffset + SFNT_BLOC_FLAGS];

			switch(usImageFormat)                       /* different metrics sizes */
			{
			case 1:                                     /* small glyph metrics */
			case 2:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 3:
				break;
			
			case 4:
				break;
			
			case 5:             /* bitmap offset and metrics type set above */
				*pbGlyphFound = TRUE;
				break;
			
			case 6:
			case 7:
			case 9:
				*pusMetricsType = SBIT_BIG_METRICS;
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_BIGMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 8:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS + SIZEOF_SBIT_GLYPH8PAD;
				*pbGlyphFound = TRUE;
				break;

			default:
				break;
			}
		}
		ulNumIndexTables--;    
		ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
	}
	
	RELEASESFNTFRAG(pClientInfo, pbyBloc);
	return NO_ERR;
}


/**********************************************************************/

/* fetch the horizontal metrics */

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound ) /* NEW */
{
	const uint8     *pbyTable;
	uint32          ulTableLength;
	sfnt_tableIndex TableIndex;
	ErrorCode       ReturnCode;

	*pbHorMetricsFound = FALSE;                        /* default */
	*pbVertMetricsFound = FALSE;                        /* default */

	if (usMetricsTable == SBIT_BDAT_TABLE)          /* if metrics in bdat */
	{
		TableIndex = sfnt_BitmapData;
	}
	else                                            /* if metrics in bloc */
	{
		TableIndex = sfnt_BitmapLocation;
	}
	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
		ulTableLength = SIZEOF_SBIT_BIGMETRICS;
	}
	else                                            /* if only h or v metrics */
	{
		ulTableLength = SIZEOF_SBIT_SMALLMETRICS;
	}

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulMetricsOffset,                            /* metrics start */
		ulTableLength,                              /* read just metrics */
		TableIndex,                                 /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

/*  for horizontal metrics, offsets could be different for big & small */

	*pusHeight = (uint16)pbyTable[SFNT_SBIT_HEIGHT];
	*pusWidth = (uint16)pbyTable[SFNT_SBIT_WIDTH];

	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_VERTADVANCE];
		*pbHorMetricsFound = TRUE;                        
		*pbVertMetricsFound = TRUE;                     
	}
	else if (usMetricsType == SBIT_HORIZ_METRICS)   
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbHorMetricsFound = TRUE;                        
	}
	else /* if (usMetricsType == SBIT_VERT_METRICS) */  
	{
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbVertMetricsFound = TRUE;                     
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

	return NO_ERR;
}

/**********************************************************************/

/* shave the white space from horizontal metrics for bitmap format 5 */

#define     ROWSIZE     16                      /* 16 bytes = 128 bits max */

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY) /* NEW */
{
    uint8           abyBitRow[ROWSIZE];         /* or bitmap into one row */
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
    uint8           *pbyBitMap;
    uint8           byMask;
    uint8           byUpMask;
    uint8           byLowMask;
	uint16          usBitData;
	uint16          usFreshBits;
	uint16       	usOutBits;
	uint16       	usRow;
	uint16       	usStopBit;
    uint16          usShaveLeft;
    uint16          usShaveRight;
    uint16          usShaveTop;
    uint16          usShaveBottom;
	uint16          usStart;
	ErrorCode       ReturnCode;
	boolean			bWeGotBlackPixels;				/* used in vertical shaving */
	uint8			byBlackPixelsInCurrentRaw;		/* used in vertical shaving */
	uint8			byTempBuffer;		/* temporary buffer used to detect the first/last row containing black pixels */

    *pusShaveLeft = 0;                          /* defaults */
    *pusShaveRight = 0;
    *pusShaveTop = 0;                          /* defaults */
    *pusShaveBottom = 0;

    if (usBitmapFormat != 5)                    /* if not constant metrics data */
    {
        return NO_ERR;
    }

    if ((*pusWidth * usBitDepth) > (ROWSIZE << 3))
    {
    	return NO_ERR;                          /* punt huge bitmaps */
    }
    
    MEMSET(abyBitRow, 0, ROWSIZE);              /* clear to zeros */

/*      read the bitmap data    */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                            /* callback etc. */
		ulBitmapOffset,                         /* metrics start */
		ulBitmapLength,                         /* read bitmap data */
		sfnt_BitmapData,                        /* registered tag */
		TRUE,                                   /* should be there */
		(const void**)&pbyTable );              /* data pointer */

	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	usBitData = 0;                              /* up to 16 bits of bdat */
	usFreshBits = 0;                            /* read & unwritten */

	bWeGotBlackPixels = FALSE;					/* used for vertical shaving */
	usShaveTop = 0;
	usShaveBottom = 0;


/*      'or' the bitmap data into a single row    */    
	usRow = *pusHeight;

    while (usRow > 0)
	{
		pbyBitMap = abyBitRow;
		usOutBits = *pusWidth * usBitDepth;
		usStopBit = 8;
		byBlackPixelsInCurrentRaw = 0;

		while (usOutBits > 0)                   /* if more to do */
		{
			if (usFreshBits < 8)                /* if room for fresh data */
			{
				usBitData <<= 8;
                if (ulBitmapLength > 0)         /* prevent read past data end */
                {
                    usBitData |= (uint16)*pbyBdat++;
                    ulBitmapLength--;
                }
				usFreshBits += 8;
			}
			
			if (usStopBit > usOutBits)
			{
				usStopBit = usOutBits;
			}
			byMask = achStopMask[usStopBit];
			
			byTempBuffer = (uint8)((usBitData >> (usFreshBits - 8)) & byMask);

			byBlackPixelsInCurrentRaw |= byTempBuffer;

			*pbyBitMap++ |= byTempBuffer;

			usFreshBits -= usStopBit;
			usOutBits -= usStopBit;
		}
		if (byBlackPixelsInCurrentRaw != 0)
		{
			bWeGotBlackPixels = TRUE;
			usShaveBottom = usRow-1;
		}
		if (!bWeGotBlackPixels) usShaveTop ++;
        usRow--;
	}

	if (usShaveTop == *pusHeight)
	{
		/* the bitmap is completely white */
		usShaveTop = 0;
		usShaveBottom = 0;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

/*      calculate white space on the left    */
    
    pbyBitMap = abyBitRow;
	if (usBitDepth == 1)
	{
		byUpMask = 0x80;
		byLowMask = 0x01;
	} else if (usBitDepth == 2)
	{
		byUpMask = 0xC0;
		byLowMask = 0x03;
	} else if (usBitDepth == 4)
	{
		byUpMask = 0xF0;
		byLowMask = 0x0F;
	} else /* usBitDepth == 8 */
	{
		byUpMask = 0xFF;
		byLowMask = 0xFF;
	}
	byMask = byUpMask;
    usShaveLeft = 0;

    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveLeft++;
        if (usShaveLeft == *pusWidth)
        {
            return NO_ERR;          /* no black found, don't shave */
        }
        byMask >>= usBitDepth;
        if (byMask == 0)
        {
            byMask = byUpMask;
            pbyBitMap++;
        }
    }

/*      calculate white space on the right    */
    
    usStart = (*pusWidth - 1) * usBitDepth;
    pbyBitMap = &abyBitRow[usStart >> 3];
    byMask = byUpMask >> (usStart & 0x0007);
    usShaveRight = 0;
    
    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveRight++;
        if (byMask == byUpMask)
        {
            byMask = byLowMask;
            pbyBitMap--;
        }
        else
        {
            byMask <<= usBitDepth;
        }
    }

/*      correct the width and sidebearing    */

    *pusShaveLeft = usShaveLeft;
    *pusShaveRight = usShaveRight;
    *pusWidth -= usShaveLeft + usShaveRight;
    *psLSBearingX += (int16)usShaveLeft;
    *psTopSBearingX += (int16)usShaveLeft;

	*pusShaveTop = usShaveTop;
    *pusShaveBottom = usShaveBottom;
    *pusHeight -= usShaveTop + usShaveBottom;
    *psLSBearingY -= (int16)usShaveTop;
    *psTopSBearingY -= (int16)usShaveTop;

	return NO_ERR;
}


/**********************************************************************/


/* fetch the bitmap */

/*  Currently supporting the following bdat formats:
	
	1 - Small metrics;  Byte aligned data
	2 - Small metrics;  Bit aligned data
	5 - Const metrics;  Bit aligned data
	6 - Big metrics;    Byte aligned data
	7 - Big metrics;    Bit aligned data
	8 - Small metrics;  Composite data
	9 - Big metrics;    Composite data
*/

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,                             /* for white space in fmt 5 */
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usDstRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount )
{
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
	uint8           *pbyBitRow;                     /* start of bitmap row */

	uint16          usSrcRowBytes;                  /* bytes per row in bdat */
	ErrorCode       ReturnCode;

	uint16          usBitData;                      /* bdat data read into 16 bits */
	uint16          usOutBits;                      /* num of bits to put to bitmap */
	uint16          usCount;
	uint16          usXOffBytes;
	uint16          usXOffBits;
	uint16          usStartBit;
	uint16          usStopBit;
	int16           sFreshBits;                     /* num of bits read not written */
	uint8           byMask;                         /* for partial bytes */
	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	*pusCompCount = 0;                              /* usual case */
	
	pbyBitRow = pbyBitMap + (usDstRowBytes * usYOffset);
	usXOffBytes = (usXOffset * usBitDepth) >> 3;
	usXOffBits = (usXOffset * usBitDepth) & 0x07;

	switch(usBitmapFormat)
	{
	case 1:                                         /* byte aligned */
	case 6:
		
		usSrcRowBytes = ((usWidth * usBitDepth) + 7) / 8;

		if (usXOffBits == 0)                         /* if byte aligned */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					*pbyBitMap++ |= *pbyBdat++;
				}
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		else                                        /* if offset in x */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
				usBitData = 0;

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					usBitData |= (uint16)*pbyBdat++;
					*pbyBitMap++ |= (usBitData >> usXOffBits) & 0x00FF;
					usBitData <<= 8;
				}
				*pbyBitMap |= (usBitData >> usXOffBits) & 0x00FF;
							 
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		break;
	
	case 2:                                         /* bit aligned data */
	case 5:
	case 7:
		
		usBitData = 0;                              /* up to 16 bits of bdat */
		sFreshBits = 0;                             /* read & unwritten */
	
		usHeight += usShaveTop;

		while (usHeight > 0)                        /* for each row */
		{
			pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
			usOutBits = usWidth * usBitDepth;
			usStartBit = usXOffBits;
			usStopBit = 8;
			sFreshBits -= (int16)usShaveLeft * usBitDepth;       /* skip the left white bits */

			while (usOutBits > 0)                   /* if more to do */
			{
				while (sFreshBits < 8)              /* if room for fresh data */
				{
					usBitData <<= 8;
					if (ulBitmapLength > 0)         /* prevent read past data end */
					{
						usBitData |= (uint16)*pbyBdat++;
						ulBitmapLength--;
					}
					sFreshBits += 8;
				}
				
				if (usStopBit > usOutBits + usStartBit)
				{
					usStopBit = usStartBit + usOutBits;
				}
				byMask = achStartMask[usStartBit] & achStopMask[usStopBit];
				
				*pbyBitMap++ |= (uint8)((usBitData >> (sFreshBits + (int16)usStartBit - 8)) & byMask);

				sFreshBits -= (int16)(usStopBit - usStartBit);
				usOutBits -= usStopBit - usStartBit;
				usStartBit = 0;
			}
			sFreshBits -= (int16)usShaveRight*usBitDepth;      /* skip the right white bits */

			if (usShaveTop == 0)
			{
				pbyBitRow += usDstRowBytes;             /* next row */
			} else {
				usShaveTop --;
			}
			usHeight--;
		}
		break;
	
	case 3:                                         /* various */
	case 4:
		break;
	
	case 8:                                         /* composites */
	case 9:                                         /* just return count */
		
		*pusCompCount = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPCOUNT]));
		break;
	
	default:
		Assert(FALSE);
		break;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
)
{
	const uint8 *   pbyBdat;
	ErrorCode       ReturnCode;

	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyBdat );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat += SFNT_BDAT_FIRSTCOMP + (SIZEOF_SBIT_BDATCOMPONENT * usComponent);
		
	*pusCompGlyphCode = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPGLYPH]));
	*pusCompXOffset = (uint16)pbyBdat[SFNT_BDAT_COMPXOFF];
	*pusCompYOffset = (uint16)pbyBdat[SFNT_BDAT_COMPYOFF];

	RELEASESFNTFRAG(pClientInfo, pbyBdat);

	return NO_ERR;
}

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfnt_en.h ===
/*
	File:       sfnt_en.h

	Written by: Mike Reed

	Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		<8+>     7/16/90    MR      Fixed INTEL version of tag_GlyphData
		 <8>     7/16/90    MR      Conditionalize redefinition of script codes
		 <7>     7/13/90    MR      Conditionalize enums to allow for byte-reversal on INTEL chips
		 <6>     6/30/90    MR      Remove tag reference to 'mvt ' and 'cryp'
		 <4>     6/26/90    MR      Add all script codes, with SM naming conventions
		 <3>     6/20/90    MR      Change tag enums to #defines to be ansi-correct
		 <2>      6/1/90    MR      Add postscript name to sfnt_NameIndex and 'post' to tags.
	To Do:
*/

#ifndef SFNT_ENUMS

#define SFNT_ENUMS

typedef enum {
	plat_Unicode,
	plat_Macintosh,
	plat_ISO,
	plat_MS
} sfnt_PlatformEnum;

#ifndef __SCRIPT__
typedef enum {
	smRoman,
	smJapanese,
	smTradChinese,
	smChinese = smTradChinese,
	smKorean,
	smArabic,
	smHebrew,
	smGreek,
	smCyrillic,
	smRussian = smCyrillic,
	smRSymbol,
	smDevanagari,
	smGurmukhi,
	smGujarati,
	smOriya,
	smBengali,
	smTamil,
	smTelugu,
	smKannada,
	smMalayalam,
	smSinhalese,
	smBurmese,
	smKhmer,
	smThai,
	smLaotian,
	smGeorgian,
	smArmenian,
	smSimpChinese,
	smTibetan,
	smMongolian,
	smGeez,
	smEthiopic = smGeez,
	smAmharic = smGeez,
	smSlavic,
	smEastEurRoman = smSlavic,
	smVietnamese,
	smExtArabic,
	smSindhi = smExtArabic,
	smUninterp
} sfnt_ScriptEnum;
#endif

typedef enum {
	lang_English,
	lang_French,
	lang_German,
	lang_Italian,
	lang_Dutch,
	lang_Swedish,
	lang_Spanish,
	lang_Danish,
	lang_Portuguese,
	lang_Norwegian,
	lang_Hebrew,
	lang_Japanese,
	lang_Arabic,
	lang_Finnish,
	lang_Greek,
	lang_Icelandic,
	lang_Maltese,
	lang_Turkish,
	lang_Yugoslavian,
	lang_Chinese,
	lang_Urdu,
	lang_Hindi,
	lang_Thai
} sfnt_LanguageEnum;

typedef enum {
	name_Copyright,
	name_Family,
	name_Subfamily,
	name_UniqueName,
	name_FullName,
	name_Version,
	name_Postscript
} sfnt_NameIndex;

typedef uint32 sfnt_TableTag;

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */
#define tag_ControlValue        0x63767420        /* 'cvt ' */
#define tag_BitmapData          0x45424454        /* 'EBDT' */
#define tag_BitmapLocation      0x45424c43        /* 'EBLC' */
#define tag_BitmapScale         0x45425343        /* 'EBSC' */
#define tag_Editor0             0x65647430        /* 'edt0' */
#define tag_Editor1             0x65647431        /* 'edt1' */
#define tag_Encryption          0x63727970        /* 'cryp' */
#define tag_FontHeader          0x68656164        /* 'head' */
#define tag_FontProgram         0x6670676d        /* 'fpgm' */
#define tag_GridfitAndScanProc	0x67617370		  /* 'gasp' */
#define tag_GlyphDirectory      0x67646972        /* 'gdir' */
#define tag_GlyphData           0x676c7966        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x68646d78        /* 'hdmx' */
#define tag_HoriHeader          0x68686561        /* 'hhea' */
#define tag_HorizontalMetrics   0x686d7478        /* 'hmtx' */
#define tag_IndexToLoc          0x6c6f6361        /* 'loca' */
#define tag_Kerning             0x6b65726e        /* 'kern' */
#define tag_LinearThreshold     0x4c545348        /* 'LTSH' */
#define tag_MaxProfile          0x6d617870        /* 'maxp' */
#define tag_NamingTable         0x6e616d65        /* 'name' */
#define tag_OS_2                0x4f532f32        /* 'OS/2' */
#define tag_Postscript          0x706f7374        /* 'post' */
#define tag_PreProgram          0x70726570        /* 'prep' */
#define tag_VertDeviceMetrics	0x56444d58		  /* 'VDMX' */
#define tag_VertHeader	        0x76686561		  /* 'vhea' */
#define tag_VerticalMetrics     0x766d7478		  /* 'vmtx' */

#define tag_TTO_GSUB     		0x47535542		  /* 'GSUB' */
#define tag_TTO_GPOS     		0x47504F53		  /* 'GPOS' */
#define tag_TTO_GDEF     		0x47444546		  /* 'GDEF' */
#define tag_TTO_BASE     		0x42415345		  /* 'BASE' */
#define tag_TTO_JSTF     		0x4A535446		  /* 'JSTF' */

#endif      /* not sfnt_enums */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\stat.h ===
/*********************************************************************/
/*                                                                   */
/*    stat.h -- stat.asm exports                                     */
/*                                                                   */
/*    (c) Copyright 1992  Microsoft Corp.  All rights reserved.      */
/*                                                                   */
/*     4/9/96  claudebe adding profiling with IceCAP                 */
/*     2/26/93 deanb    macros come back                             */
/*     2/22/93 deanb    timing switch moved to fsconfig.h macros     */
/*     2/11/93 deanb    __cdecl's for ms C8                          */
/*    12/22/92 deanb    Apple types                                  */
/*    11/20/92 deanb    Timing switches revised                      */
/*    11/17/92 deanb    First cut                                    */
/*                                                                   */
/*********************************************************************/

/* STAT Card Timing Switches */

#ifdef FSCFG_USESTATCARD         /* compile option for profiling */
  #define STAT_ON               gbTimer = TRUE; StartSample();
  #define STAT_OFF              StopSample(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) StartSample();
  #define STAT_OFF_CALLBACK     if (gbTimer) StopSample();
#elif FSCFG_USEICECAP          /* compile option for profiling with IceCAP */
//#include <ICAPExp.h>
  #define STAT_ON               gbTimer = TRUE; StartCAP();
  #define STAT_OFF              StopCAP(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) ResumeCAP();
  #define STAT_OFF_CALLBACK     if (gbTimer) SuspendCAP();
#else
  #define STAT_ON
  #define STAT_OFF
  #define STAT_ON_CALLBACK
  #define STAT_OFF_CALLBACK
#endif

#if 1

#define STAT_ON_NEWSFNT         STAT_ON
#define STAT_OFF_NEWSFNT        STAT_OFF
#define STAT_ON_NEWTRAN         STAT_ON
#define STAT_OFF_NEWTRAN        STAT_OFF
#define STAT_ON_NEWGLYPH        STAT_ON
#define STAT_OFF_NEWGLYPH       STAT_OFF
#define STAT_ON_GRIDFIT         STAT_ON
#define STAT_OFF_GRIDFIT        STAT_OFF
#define STAT_ON_FINDBMS         STAT_ON
#define STAT_OFF_FINDBMS        STAT_OFF
#define STAT_ON_SCAN            STAT_ON
#define STAT_OFF_SCAN           STAT_OFF
#define STAT_ON_FNTEXEC         
#define STAT_OFF_FNTEXEC        
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#else

#define STAT_ON_NEWSFNT
#define STAT_OFF_NEWSFNT
#define STAT_ON_NEWTRAN
#define STAT_OFF_NEWTRAN
#define STAT_ON_NEWGLYPH
#define STAT_OFF_NEWGLYPH
#define STAT_ON_GRIDFIT         STAT_ON         
#define STAT_OFF_GRIDFIT        STAT_OFF         
#define STAT_ON_FINDBMS   
#define STAT_OFF_FINDBMS  
#define STAT_ON_SCAN            
#define STAT_OFF_SCAN           
#define STAT_ON_FNTEXEC
#define STAT_OFF_FNTEXEC
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#endif

/*********************************************************************/

/*              Global timing variable                               */

/*********************************************************************/

extern boolean gbTimer;                /* set true when timer running */

/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


#ifdef FSCFG_USESTATCARD         /* compile option for profiling */

uint16 __cdecl  InitStat( void );

uint16 __cdecl  ConfigElapsed( void );

uint16 __cdecl  ConfigSample( void );

uint16 __cdecl  StartElapsed( void );

uint16 __cdecl  StartSample( void );

uint32 __cdecl  ReadElapsed( void );

uint32 __cdecl  ReadSample( void );

uint16 __cdecl  ReadSample_Count( void );

uint16 __cdecl  StopElapsed( void );

uint16 __cdecl  StopSample( void );

uint16 __cdecl  ResetElapsed( void );

uint16 __cdecl  ResetSample( void );

#endif  /* FSCFG_USESTATCARD */

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfntaccs.h ===
/*
	File:       private sfnt.h

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
		<3+>     7/17/90    MR      Change return types to in for computemapping and readsfnt
		 <3>     7/14/90    MR      changed SQRT to conditional FIXEDSQRT2
		 <2>     7/13/90    MR      Change parameters to ReadSFNT and ComputeMapping
		<1+>     4/18/90    CL      
		 <1>     3/21/90    EMT     First checked in with Mike Reed's blessing.

	To Do:
*/

#include    "sfnt.h"

/* EXPORTED DATA TYPES */

typedef struct {
  uint32    ulOffset;
  uint32    ulLength;
} sfac_OffsetLength;

typedef struct sfac_ClientRec *sfac_ClientRecPtr;

typedef uint16 (*MappingFunc) (const uint8 *, uint16 , sfac_ClientRecPtr);

typedef struct sfac_ClientRec {
	ClientIDType        lClientID;          /* User ID Number                           */
	GetSFNTFunc         GetSfntFragmentPtr; /* User function to eat sfnt                */
	ReleaseSFNTFunc     ReleaseSfntFrag;    /* User function to relase sfnt             */
	int16               sIndexToLocFormat;  /* Format of loca table                     */
	uint32              ulMapOffset;        /* Offset to platform mapping data          */
	sfac_OffsetLength   TableDirectory[sfnt_NUMTABLEINDEX]; /* Table offsets/lengths    */
	uint16              usNumberOf_LongHorMetrics; /* Number of entries in hmtx table   */
	uint16              usNumLongVertMetrics;      /* number of entries with AH         */
	boolean				bValidNumLongVertMetrics; /* true if 'vhea' table exist         */
    uint16              usMappingFormat;    /* format code (0,2,4,6) for mapping func   */
	MappingFunc			GlyphMappingF;		/* mapping function char to glyph			*/
	uint16              usGlyphIndex;       /* Current glyph index                      */
	uint16				usFormat4SearchRange; /* Format 4 cached SearchRange			*/
	uint16				usFormat4EntrySelector; /* Format 4 cached EntrySelector		*/
	uint16				usFormat4RangeShift;/* Format 4 cached Range Shift				*/
	/* value for sDefaultAscender and sDefaultDescender comes from TypoAscender and     */
	/* TypoDescender from 'OS/2', if the 'OS/2' is missing, alternate values comes from */
	/* the horizontal header Ascender and Descender                                     */
	int16				sDefaultAscender;
	int16				sDefaultDescender;
	int16				sWinDescender;
} sfac_ClientRec;


/* It would be great if we could make this an opaque data type
// But in this case, the ownership of the memory for the data is the
// responsibility of the owner module. (i.e. sfntaccs.c) This adds
// complications to our model (read: it is much easier to allocate the
// data off the stack of the caller) so we won't implement this for now.
*/

/*  Glyph Handle -- Used for access to glyph data in 'glyf' table   */

typedef struct {
	 const void *     pvGlyphBaseAddress; /* Base address of glyph, needed for Release */
	 const void *     pvGlyphNextAddress; /* Current position in glyph                    */
	 const void *     pvGlyphEndAddress; /* End address of glyph, used to catch glyph corruption */
} sfac_GHandle;

/*  ComponentTypes -- Method used for positioning component in composite    */

typedef enum {
	AnchorPoints,
	OffsetPoints,
	Undefined
} sfac_ComponentTypes;

/* MACROS */

#define SFAC_LENGTH(ClientInfo,Table)  ClientInfo->TableDirectory[(int)Table].ulLength

/* PUBLIC PROTOTYPE CALLS */

/*
 * Creates mapping for finding offset table
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *    ClientInfo);    /* Sfnt Client information  */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information      */
	uint16              usPlatformID,   /* Platform Id used for mapping */
	uint16              usSpecificID);  /* Specific Id used for mapping */

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16              usCharacterCode);   /* Character code to be mapped  */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,    /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	 sfac_ClientRec *   ClientInfo,      /* Sfnt Client information     */
	 uint16 *               pusEmResolution,/* Sfnt Em Resolution               */
	 boolean *              pbIntegerScaling,/* Sfnt flag for int scaling   */
	 LocalMaxProfile *  pMaxProfile);    /* Sfnt Max Profile table      */

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB,
    int16 *             psNonScaledTopOriginX);

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	int16 *             psNonScaledLSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information           */
	uint16 *            pusNumLongVertMetrics, /* Entries for which AH exists */
	boolean *           pbValidNumLongVertMetrics ); /* true if 'vhea' table exist  */

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client Information  */
	char *              pFontProgram,   /* pointer to Font Program  */
	char *              pPreProgram);   /* pointer to Pre Program   */

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,     /* Client Information       */
	F26Dot6 *           pCVT);          /* pointer to CVT           */

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           bFound,         /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	sfac_GHandle *      hGlyph,             /* Return glyph handle          */
	boolean *           pbCompositeGlyph,   /* Is glyph a composite?        */
	boolean *           pbHasOutline,       /* Does glyph have outlines?    */
	int16 *             psNumberOfContours, /* Number of contours in glyph  */
	BBOX *              pbbox);             /* Glyph Bounding box           */

FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	 uint8 *                abyOnCurve,           /* Array of on curve indicators per point  */
	 F26Dot6 *              afxOoy,               /* Array of ooy points for every point         */
	 F26Dot6 *              afxOox,               /* Array of oox points for every point         */
	 sfac_GHandle *     hGlyph,
	 LocalMaxProfile *  maxProfile,       /* MaxProfile Table                                */
	 boolean                bHasOutline,          /* Does glyph have outlines?                   */
	 int16                  sNumberOfContours,  /* Number of contours in glyph               */
	 int16 *                asStartPoints,    /* Array of start points for every contour  */
	 int16 *                asEndPoints,          /* Array of end points for every contour   */
	 uint16 *               pusSizeOfInstructions, /* Size of instructions in bytes          */
	 uint8 **               pbyInstructions,   /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours);    /* total number of contours for composites, to check for overflow */

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets    */
	boolean *               pbRoundXYToGrid,    /* Round composite offsets to grid              */
	boolean *               pbUseMyMetrics,     /* Use component metrics                        */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions                 */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component                 */
	int16 *                 psXOffset,          /* X Offset of component (if app)               */
	int16 *                 psYOffset,          /* Y Offset of component (if app)               */
	uint16 *                pusAnchorPoint1,    /* Anchor point 1 of component (if app)         */
	uint16 *                pusAnchorPoint2,    /* Anchor point 2 of component (if app)         */
	transMatrix             *pMulT,             /* Transformation matrix for component          */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent);   /* Is this the last component?                  */

/*  sfac_ReadCompositeInstructions

	Returns pointer to TrueType instructions for composites.

 */

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle *  hGlyph,
	uint8 **        pbyInstructions,    /* Pointer to start of glyph instructions   */
	uint16 *        pusSizeOfInstructions); /* Size of instructions in bytes        */


/*  sfac_ReleaseGlyph

	Called when access to glyph in 'glyf' table is finished.

 */

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *    ClientInfo, /* Sfnt Client Information  */
	sfac_GHandle *      hGlyph);    /* Glyph Handle Information */


/**********************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

#ifndef FSCFG_DISABLE_GRAYSCALE
#define SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#else

#define SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#endif


/*      SFNTACCS Export Prototypes for SBIT      */

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset 
);

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength
);

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound /* NEW */
);

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY /* NEW */
);

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount
);

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
);


/**********************************************************************/

/*  Results of search for strike's bitmapSizeSubtable   */

#define     SBIT_UN_SEARCHED    0
#define     SBIT_NOT_FOUND      1
#define     SBIT_BLOC_FOUND     2
#define     SBIT_BSCA_FOUND     3

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\subpixel.c ===
/*********************************************************************

	  subpixel.c -- sub pixel rendering

	  (c) Copyright 1999-2000  Microsoft Corp.  All rights reserved.

 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "scentry.h"             /* for own function prototypes */

#ifdef FSCFG_SUBPIXEL

#ifdef FSCFG_SUBPIXEL_STANDALONE

// this should be considered a temporary solution. currently, the rasterizer is plumbed for 8 bpp output in SubPixel,
// and appears to have John Platt's filter hard-wired in. In the future, we would rather have the overscaled b/w bitmap
// as output, such that we can do any color filtering and gamma correction outside and independent of the rasterizer

// Index values for wRGBColors and awColorIndexTable

#define RED_INDEX	0
#define GREEN_INDEX	1
#define	BLUE_INDEX	2

// The abColorIndexTable datastructure contains one entry for each virtual subpixel.
// We index into this table to determine which color is assigned to that subpixel.
// To create the table, we set the first number of subpixels assigned to red to the red index,
// and likewise for green and blue.

static const uint8 abColorIndexTable[2][RGB_OVERSCALE] = // 2 Tables to indicate color for each subpixel, 0 = RGB striping order, 1 = BGR striping order
	{{RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,														// R_Subpixels, hard-wired
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,	// G_Subpixels, hard-wired
	  BLUE_INDEX, BLUE_INDEX},																						// B_Subpixels, hard-wired
	 {BLUE_INDEX, BLUE_INDEX,
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,
	  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX}};

#define PIXEL_ON	1
#define PIXEL_OFF	0
#define CHAR_BIT	8         /* number of bits in a char */

char GetInputPixel( char *pbyInputRowData, uint32 ulWidthIndex )
{
	uint32	ulRowIndex;
	char	byPixelMask;
	
	ulRowIndex = ulWidthIndex / CHAR_BIT;			// Determines which byte to check out
	byPixelMask = 0x80 >> ulWidthIndex % CHAR_BIT; // Determine offset within byte
	return ( (pbyInputRowData[ ulRowIndex ] & byPixelMask)?PIXEL_ON:PIXEL_OFF );
}


FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
	char byPixel;						// Contents of one pixel from the rasterizer
	uint16 usRGBColors[ 3 ];				// Contains sum of each color based on number of subpixels
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;
    uint32 ulBytes;
	
	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = ulOverscaledBitmapWidth + sBitmapSubPixelStart;

    /* clear the resulting bitmap */
	ulBytes = (uint32)SubPixelBitMap->sRowBytes * (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				
		// Initialize RGBColors

		usRGBColors[RED_INDEX] = 0;
		usRGBColors[GREEN_INDEX] = 0;
		usRGBColors[BLUE_INDEX] = 0;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = sBitmapSubPixelStart; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            byPixel = GetInputPixel( pbyInputRowData, ulWidthIndex - sBitmapSubPixelStart );
			FS_ASSERT((byPixel <= 1),"Input Pixel greater than one");
			usRGBColors[abColorIndexTable[bgrOrder][ulWidthIndex % RGB_OVERSCALE]] += byPixel;

			// If we've finished one pixel or the scanline, write out pixel 

			if((( ulWidthIndex % RGB_OVERSCALE ) == (uint32)(RGB_OVERSCALE - 1)) || // Finish one pixel
				ulWidthIndex == ( ulOverscaledBitmapWidth + sBitmapSubPixelStart - 1) ) // Finish row
			{
                /* write out current pixel, 8 bits in range 0 through 179 = (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) */

                usColorIndex = usRGBColors[RED_INDEX]   * (G_Subpixels + 1) * (B_Subpixels + 1) +
                               usRGBColors[GREEN_INDEX] * (B_Subpixels + 1) +
                               usRGBColors[BLUE_INDEX];

                        FS_ASSERT((usColorIndex < 256),"Resulting pixel doesn't fit in a byte");

                *pbyOutputRowData = (char) usColorIndex;
                pbyOutputRowData++;
				usRGBColors[RED_INDEX] = 0;
				usRGBColors[GREEN_INDEX] = 0;
				usRGBColors[BLUE_INDEX] = 0;
            }
		}
	}
}

#else // !FSCFG_SUBPIXEL_STANDALONE


#define CHAR_BIT      8         /* number of bits in a char */

unsigned char ajRGBToWeight222[64] = {
    0,1,1,2,4,5,5,6,4,5,5,6,8,9,9,10,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    32,33,33,34,36,37,37,38,36,37,37,38,40,41,41,42};

    unsigned char ajRGBToWeightMask[CHAR_BIT] = { 
        0xFC, 0x7E, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};

FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;

    uint16 usSubPixelIndex;
    int16 uSubPixelRightShift, uSubPixelLeftShift;
    char * pbyInputEndRowData;


	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = (uint32)(SubPixelBitMap->rectBounds.right - SubPixelBitMap->rectBounds.left);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
        pbyInputEndRowData = pbyInputRowData + OverscaledBitmap->sRowBytes;
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				

        /* do the first partial byte : */

        usColorIndex = (unsigned char)(*pbyInputRowData) >> (sBitmapSubPixelStart + (8 - RGB_OVERSCALE));
        usColorIndex = ajRGBToWeight222[usColorIndex];

        *pbyOutputRowData = (char) usColorIndex;

        pbyOutputRowData++;

        usSubPixelIndex = (CHAR_BIT + RGB_OVERSCALE - sBitmapSubPixelStart) % CHAR_BIT;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = 1; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            uSubPixelLeftShift = 0;
            uSubPixelRightShift = CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;
            if (uSubPixelRightShift < 0) 
            {
                uSubPixelLeftShift = - uSubPixelRightShift;
                uSubPixelRightShift = 0;
            }

            usColorIndex = ((unsigned char)(*pbyInputRowData) & ajRGBToWeightMask[usSubPixelIndex]) >> uSubPixelRightShift << uSubPixelLeftShift;

            if (pbyInputRowData+1 < pbyInputEndRowData)
            {
                /* avoid reading too far for the partial pixel at the end */
                uSubPixelRightShift = CHAR_BIT + CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;

                usColorIndex += (unsigned char)(*(pbyInputRowData+1)) >> uSubPixelRightShift;
            }
            usColorIndex = ajRGBToWeight222[usColorIndex];

            *pbyOutputRowData = (char) usColorIndex;

            pbyOutputRowData++;

            usSubPixelIndex = (usSubPixelIndex + RGB_OVERSCALE);
            if (usSubPixelIndex >= CHAR_BIT)
            {
                usSubPixelIndex = usSubPixelIndex % CHAR_BIT;
                pbyInputRowData ++;
            }
		}
	}
}

#endif // FSCFG_SUBPIXEL_STANDALONE

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\cvt.h ===
/******************************Module*Header*******************************\
* Module Name: cvt.h
*
* function declarations that are private to cvt.c
*
* Created: 26-Nov-1990 17:39:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
\**************************************************************************/


BOOL bGetTagIndex
(
    ULONG   ulTag,      // tag
    INT   * piTable,    // index into a table
    BOOL  * pbRequired  // requred or optional table
);

BOOL bGrabXform
(
    PFONTCONTEXT    pfc,
    USHORT          usOverScale,
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
);


typedef struct _GMC  // Glyph Metrics Corrections
{

    ULONG cxCor;
    ULONG cyCor;


} GMC, *PGMC;

#define FL_SKIP_IF_BITMAP  1
#define FL_FORCE_UNHINTED  2

// iMode is used in the case the user select a specific overScale (QFD_TT_GRAY1_BITMAP to QFD_TT_GRAY8_BITMAP)
// to be able to set the overScale in the font context correctely

FONTCONTEXT *ttfdOpenFontContext (
    FONTOBJ *pfo
    );

#if DBG
#define IS_GRAY(p) ((((p)->flFontType & FO_CHOSE_DEPTH) ? \
    0 : TtfdDbgPrint("Level Not chosen yet\n")) ,(p)->flFontType & FO_GRAYSCALE)
#else
#define IS_GRAY(p) ((p)->flFontType & FO_GRAYSCALE)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\dbg.c ===
/******************************Module*Header*******************************\
* Module Name: dbg.c
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#if DBG


VOID
TtfdDbgPrint(
    PCHAR DebugMessage,
    ...
    )
{

  /*TERSE*/ VERBOSE((DebugMessage));

}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sfntoff.h ===
#define BIGDATE_BC      0
#define BIGDATE_AD      4
#define SIZEOF_BIGDATE  8

#define BBOX_XMIN   0
#define BBOX_YMIN   2
#define BBOX_XMAX   4
#define BBOX_YMAX   6
#define SIZEOF_BBOX 8

#define SFNT_DIRECTORYENTRY_TAG         0
#define SFNT_DIRECTORYENTRY_CHECKSUM    4
#define SFNT_DIRECTORYENTRY_TABLEOFFSET 8
#define SFNT_DIRECTORYENTRY_TABLELENGTH 12
#define SIZEOF_SFNT_DIRECTORYENTRY      16

#define SFNT_OFFSETTABLE_VERSION        0
#define SFNT_OFFSETTABLE_NUMOFFSETS     4
#define SFNT_OFFSETTABLE_SEARCHRANGE    6
#define SFNT_OFFSETTABLE_ENTRYSELECTOR  8
#define SFNT_OFFSETTABLE_RANGESHIFT     10
#define SFNT_OFFSETTABLE_TABLE          12
#define SIZEOF_SFNT_OFFSETTABLE         12

#define SFNT_FONTHEADER_VERSION             0
#define SFNT_FONTHEADER_FONTREVISION        4
#define SFNT_FONTHEADER_CHECKSUMADJUSTMENT  8
#define SFNT_FONTHEADER_MAGICNUMBER         12
#define SFNT_FONTHEADER_FLAGS               16
#define SFNT_FONTHEADER_UNITSPEREM          18
#define SFNT_FONTHEADER_CREATED             20
#define SFNT_FONTHEADER_MODIFIED            28
#define SFNT_FONTHEADER_XMIN                36
#define SFNT_FONTHEADER_YMIN                38
#define SFNT_FONTHEADER_XMAX                40
#define SFNT_FONTHEADER_YMAX                42
#define SFNT_FONTHEADER_MACSTYLE            44
#define SFNT_FONTHEADER_LOWESTRECPPEM       46
#define SFNT_FONTHEADER_FONTDIRECTIONHINT   48
#define SFNT_FONTHEADER_INDEXTOLOCFORMAT    50
#define SFNT_FONTHEADER_GLYPHDATAFORMAT     52
#define SIZEOF_SFNT_FONTHEADER              54

#define SFNT_HORIZONTALHEADER_VERSION                           0
#define SFNT_HORIZONTALHEADER_YASCENDER                         4
#define SFNT_HORIZONTALHEADER_YDESCENDER                        6
#define SFNT_HORIZONTALHEADER_YLINEGAP                          8
#define SFNT_HORIZONTALHEADER_ADVANCEWIDTHMAX                   10
#define SFNT_HORIZONTALHEADER_MINLEFTSIDEBEARING                12
#define SFNT_HORIZONTALHEADER_MINRIGHTSIDEBEARING               14
#define SFNT_HORIZONTALHEADER_XMAXEXTENT                        16
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPENUMERATOR     18
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPEDENOMINATOR   20
#define SFNT_HORIZONTALHEADER_RESERVED0                         22
#define SFNT_HORIZONTALHEADER_RESERVED1                         24
#define SFNT_HORIZONTALHEADER_RESERVED2                         26
#define SFNT_HORIZONTALHEADER_RESERVED3                         28
#define SFNT_HORIZONTALHEADER_RESERVED4                         30
#define SFNT_HORIZONTALHEADER_METRICDATAFORMAT                  32
#define SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS           34
#define SIZEOF_SFNT_HORIZONTALHEADER                            36

#define SFNT_HORIZONTALMETRICS_ADVANCEWIDTH     0
#define SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING  2
#define SIZEOF_SFNT_HORIZONTALMETRICS           4

#define SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS            34

#define SFNT_VERTICALMETRICS_ADVANCEHEIGHT      0
#define SFNT_VERTICALMETRICS_TOPSIDEBEARING     2
#define SIZEOF_SFNT_VERTICALMETRICS             4



#define SFNT_CONTROLVALUE 2

#define SFNT_MAPPINGTABLE_FORMAT            0
#define SFNT_MAPPINGTABLE_MAPTABLELENGTH    2
#define SFNT_MAPPINGTABLE_VERSION           4
#define SIZEOF_SFNT_MAPPINGTABLE            6

#define SFNT_PLATFORMENTRY_PLATFORMID       0
#define SFNT_PLATFORMENTRY_SPECIFICID       2
#define SFNT_PLATFORMENTRY_PLATFORMOFFSET   4
#define SIZEOF_SFNT_PLATFORMENTRY           8

#define SFNT_CHAR2INDEXDIRECTORY_VERSION    0
#define SFNT_CHAR2INDEXDIRECTORY_NUMTABLES  2
#define SFNT_CHAR2INDEXDIRECTORY_PLATFORM   4
#define SIZEOF_SFNT_CHAR2INDEXDIRECTORY     4

#define SFNT_SUBHEADER2_FIRSTCODE       0
#define SFNT_SUBHEADER2_ENTRYCOUNT      2
#define SFNT_SUBHEADER2_IDDELTA         4
#define SFNT_SUBHEADER2_IDRANGEOFFSET   6
#define SIZEOF_SFNT_SUBHEADER2          8

#define SFNT_MAPPINGTABLE2_SUBHEADERSKEYS   0
#define SFNT_MAPPINGTABLE2_SUBHEADERS       512
#define SIZEOF_SFNT_MAPPINGTABLE2           512

#define SFNT_MAPPINGTABLE4_SEGCOUNTX2       0
#define SFNT_MAPPINGTABLE4_SEARCHRANGE      2
#define SFNT_MAPPINGTABLE4_ENTRYSELECTOR    4
#define SFNT_MAPPINGTABLE4_RANGESHIFT       6
#define SFNT_MAPPINGTABLE4_ENDCOUNT         8
#define SIZEOF_SFNT_MAPPINGTABLE4           8

#define SFNT_MAPPINGTABLE6_FIRSTCODE    0
#define SFNT_MAPPINGTABLE6_ENTRYCOUNT   2
#define SFNT_MAPPINGTABLE6_GLYPHIDARRAY 4
#define SIZEOF_SFNT_MAPPINGTABLE6       4

#define SFNT_NAMERECORD_PLATFORMID  0
#define SFNT_NAMERECORD_SPECIFICID  2
#define SFNT_NAMERECORD_LANGUAGEID  4
#define SFNT_NAMERECORD_NAMEID      6
#define SFNT_NAMERECORD_NAMELENGTH  8
#define SFNT_NAMERECORD_NAMEOFFSET  10
#define SIZEOF_SFNT_NAMERECORD      12

#define SFNT_NAMINGTABLE_FORMAT         0
#define SFNT_NAMINGTABLE_COUNT          2
#define SFNT_NAMINGTABLE_STRINGOFFSET   4
/*  SFNT_NAMERECORD[COUNT]  */
#define SIZEOF_SFNT_NAMINGTABLE         6

#define SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS    0
#define SFNT_PACKEDSPLINEFORMAT_BBOX                2
#define SFNT_PACKEDSPLINEFORMAT_ENDPOINTS           10
#define SIZEOF_SFNT_PACKEDSPLINEFORMAT              10

#define SFNT_DEVICEMETRICS_VERSION      0
#define SFNT_DEVICEMETRICS_NUMRECORDS   2
#define SFNT_DEVICEMETRICS_RECORDSIZE   4
/* BYTE WIDTHS[NUMGLYPHS+2] * NUMRECORDS */
#define SIZEOF_SFNT_DEVICEMETRICS       8

#define POSTSCRIPTNAMEINDICES_VERSION               0
#define POSTSCRIPTNAMEINDICES_ITALICANGLE           4
#define POSTSCRIPTNAMEINDICES_UNDERLINEPOSITION     8
#define POSTSCRIPTNAMEINDICES_UNDERLINETHICKNESS    10
#define POSTSCRIPTNAMEINDICES_ISFIXEDPITCH          12
#define POSTSCRIPTNAMEINDICES_PAD                   14
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE42          16
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE42          20
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE1           24
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE1           28
#define POSTSCRIPTNAMEINDICES_NUMBERGLYPHS          32
#define GLYPHNAMEINDEX                              34
#define GLYPHNAMEINDEX25                            34
#define SIZEOF_SFNT_POSTSCRIPTINFO                  36

#define SFNT_OS2_VERSION                0
#define SFNT_OS2_XAVGCHARWIDTH          2
#define SFNT_OS2_USWEIGHTCLASS          4
#define SFNT_OS2_USWIDTHCLASS           6
#define SFNT_OS2_FSTYPE                 8
#define SFNT_OS2_YSUBSCRIPTXSIZE        10
#define SFNT_OS2_YSUBSCRIPTYSIZE        12
#define SFNT_OS2_YSUBSCRIPTXOFFSET      14
#define SFNT_OS2_YSUBSCRIPTYOFFSET      16
#define SFNT_OS2_YSUPERSCRIPTXSIZE      18
#define SFNT_OS2_YSUPERSCRIPTYSIZE      20
#define SFNT_OS2_YSUPERSCRIPTXOFFSET    22
#define SFNT_OS2_YSUPERSCRIPTYOFFSET    24
#define SFNT_OS2_YSTRIKEOUTSIZE         26
#define SFNT_OS2_YSTRIKEOUTPOSITION     28
#define SFNT_OS2_SFAMILYCLASS           30
#define SFNT_OS2_PANOSE                 32
#define SFNT_OS2_ULCHARRANGE            42
#define SFNT_OS2_ACHVENDID              58
#define SFNT_OS2_USSELECTION            62
#define SFNT_OS2_USFIRSTCHAR            64
#define SFNT_OS2_USLASTCHAR             66
#define SFNT_OS2_STYPOASCENDER          68
#define SFNT_OS2_STYPODESCENDER         70
#define SFNT_OS2_STYPOLINEGAP           72
#define SFNT_OS2_SWINASCENT             74
#define SFNT_OS2_SWINDESCENT            76
#define SIZEOF_SFNT_OS2                 78

#define SFNT_HDMX_VERSION               0
#define SFNT_HDMX_SNUMRECORDS           2
#define SFNT_HDMX_LSIZERECORD           4
#define SFNT_HDMX_HDMXTABLE             8
#define SIZEOF_SFNT_HDMX                8

#define SFNT_HDMXRECORD_BEMY            0
#define SFNT_HDMXRECORD_BEMX            1
#define SFNT_HDMXRECORD_BWIDTHS         2
#define SIZEOF_SFNT_HDMXRECORD          2

#define SFNT_LTSH_VERSION               0
#define SFNT_LTSH_NUMGLYPHS             2
#define SFNT_LTSH_UBYPELSHEIGHT         4
#define SIZEOF_SFNT_LTSH                4

#define SFNT_MAXPROFILETABLE_VERSION                0
#define SFNT_MAXPROFILETABLE_NUMGLYPHS              4
#define SFNT_MAXPROFILETABLE_MAXPOINTS              6
#define SFNT_MAXPROFILETABLE_MAXCONTOURS            8
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS     10
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS   12
#define SFNT_MAXPROFILETABLE_MAXELEMENTS            14
#define SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS      16
#define SFNT_MAXPROFILETABLE_MAXSTORAGE             18
#define SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS        20
#define SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS     22
#define SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS       24
#define SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS  26
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS   28
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH      30
#define SIZEOF_SFNT_MAXPROFILETABLE 				32

#define SFNT_GASPRANGE_RANGEMAXPPEM 		0
#define SFNT_GASPRANGE_RANGEGASPBEHAVIOR	2
#define SIZEOF_SFNT_GASPRANGE				4

#define SFNT_GASP_VERSION					0
#define SFNT_GASP_NUMRANGES 				2
#define SFNT_GASP_GASPRANGE 				4
#define SIZEOF_SFNT_GASP					4

/**********************************************************************/

/*      Embedded Bitmap (sbit) Table Offsets      */

/**********************************************************************/

/*  Bloc, Bdat and Bsca file constants    */

/*  This first bloc is common to both bloc and bsca tables */

#define     SFNT_BLOC_NUMSIZES               4
#define     SFNT_BLOC_FIRSTSTRIKE            8

#define     SFNT_BLOC_INDEXARRAYOFFSET       0
#define     SFNT_BLOC_NUMINDEXTABLES         8
#define     SFNT_BLOC_COLORREF              12
#define     SFNT_BLOC_STARTGLYPH            40
#define     SFNT_BLOC_ENDGLYPH              42
#define     SFNT_BLOC_PPEMX                 44
#define     SFNT_BLOC_PPEMY                 45
#define     SFNT_BLOC_BITDEPTH              46
#define     SFNT_BLOC_FLAGS                 47
#define     SIZEOF_BLOC_SIZESUBTABLE        48

#define     SFNT_BLOC_FIRSTGLYPH             0
#define     SFNT_BLOC_LASTGLYPH              2
#define     SFNT_BLOC_ADDITIONALOFFSET       4
#define     SIZEOF_BLOC_INDEXARRAY           8

#define     SFNT_BLOC_INDEXFORMAT            0
#define     SFNT_BLOC_IMAGEFORMAT            2
#define     SFNT_BLOC_IMAGEOFFSET            4
#define     SFNT_BLOC_OFFSETARRAY            8

#define     SFNT_BLOC_IDX2IMAGESIZE          8
#define     SFNT_BLOC_IDX2METRICS           12

#define     SFNT_BLOC_IDX4NUMGLYPHS          8
#define     SFNT_BLOC_IDX4OFFSETARRAY       12

#define     SFNT_BLOC_IDX4CODE               0
#define     SFNT_BLOC_IDX4OFFSET             2
#define     SIZEOF_CODEOFFSETPAIR            4
                
#define     SFNT_BLOC_IDX5IMAGESIZE          8
#define     SFNT_BLOC_IDX5METRICS           12
#define     SFNT_BLOC_IDX5NUMGLYPHS         20
#define     SFNT_BLOC_IDX5CODEARRAY         24

#define     SFNT_SBIT_HEIGHT                 0
#define     SFNT_SBIT_WIDTH                  1
#define     SFNT_SBIT_BEARINGX               2
#define     SFNT_SBIT_BEARINGY               3
#define     SFNT_SBIT_ADVANCE                4
#define     SFNT_SBIT_VERTBEARINGX           5
#define     SFNT_SBIT_VERTBEARINGY           6
#define     SFNT_SBIT_VERTADVANCE            7
#define     SIZEOF_SBIT_SMALLMETRICS         5
#define     SIZEOF_SBIT_BIGMETRICS           8

#define     SFNT_BDAT_COMPCOUNT              0
#define     SIZEOF_SBIT_GLYPH8PAD            1
#define     SFNT_BDAT_FIRSTCOMP              2

#define     SFNT_BDAT_COMPGLYPH              0
#define     SFNT_BDAT_COMPXOFF               2
#define     SFNT_BDAT_COMPYOFF               3
#define     SIZEOF_SBIT_BDATCOMPONENT        4

#define     SFNT_BSCA_NUMSIZES               4
#define     SFNT_BSCA_FIRSTSTRIKE            8

#define     SFNT_BSCA_PPEMX                 24
#define     SFNT_BSCA_PPEMY                 25
#define     SFNT_BSCA_SUBPPEMX              26
#define     SFNT_BSCA_SUBPPEMY              27
#define     SIZEOF_BSCA_SIZESUBTABLE        28

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\crthack.h ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   CRT replacement hack
*
* Abstract:
*
*   We're not allowed to use the C runtimes. Some code, like the font
*   code here, is hard to fix, because:
*
*   1) It's C code, and our runtimes use C++.
*   2) It's dropped code, so we don't want to modify it explicitly.
*
*   Actually, this is what I heard about the font code, but there seems
*   to have been a lot of hacking directly at the source files. This file
*   is a cleaner way to fix references to CRT functions.
* 
*   It can be included in every .c file using the /FI compiler option in
*   the sources file.
*
* Created:
*
*   10/20/1999 agodfrey
*
\**************************************************************************/

#ifndef _CRTHACK_H
#define _CRTHACK_H

#define wcscpy HackUnicodeStringCopy
#define strncmp HackStrncmp

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\dbg.h ===
/******************************Module*Header*******************************\
* Module Name: dbg.h
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/




// all the routines in this file MUST BE under DBG


#if DBG


VOID TtfdDbgPrint(PCHAR DebugMessage,...);


#define ASSERTDD(x,y) { if (!(x)) { TtfdDbgPrint(y); EngDebugBreak();} }

#else

#define ASSERTDD(x,y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Created: 22-Oct-1990 15:23:44
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#define  IFI_PRIVATE

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <excpt.h>
#include <windef.h>
#include <wingdi.h>
#include "fontddi.h"   // modified subset of winddi.h

typedef ULONG W32PID;

#include "mapfile.h"

#include "service.h"     // string service routines
#include "tt.h"          // interface to the font scaler
//#include "common.h"

#include "fontfile.h"
#include "cvt.h"
#include "dbg.h"
#include "..\..\..\runtime\debug.h"

#define RETURN(x,y)   {WARNING((x)); return(y);}
#define RET_FALSE(x)  {WARNING((x)); return(FALSE);}

#define ALIGN4(X) (((X) + 3) & ~3)

#if defined(_AMD64_) || defined(_IA64_)

#define  vLToE(pe,l)           (*(pe) = (FLOATL)(l))

#else   // i386

ULONG  ulLToE (LONG l);
VOID   vLToE(FLOATL * pe, LONG l);

#endif

#define STATIC
#define DWORD_ALIGN(x) (((x) + 3L) & ~3L)
#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#if defined(i386)
// natural alignment for x86 is on 32 bit boundary

#define NATURAL           DWORD
#define NATURAL_ALIGN(x)  DWORD_ALIGN(x)

#else
// for mips and alpha we want 64 bit alignment

#define NATURAL           DWORDLONG
#define NATURAL_ALIGN(x)  QWORD_ALIGN(x)

#endif

#define ULONG_SIZE(x)  (((x) + sizeof(ULONG) - 1) / sizeof(ULONG))


// MACROS FOR converting 16.16 BIT fixed numbers to LONG's


#define F16_16TOL(fx)            ((fx) >> 16)
#define F16_16TOLFLOOR(fx)       F16_16TOL(fx)
#define F16_16TOLCEILING(fx)     F16_16TOL((fx) + (Fixed)0x0000FFFF)
#define F16_16TOLROUND(fx)       ((((fx) >> 15) + 1) >> 1)


// MACROS FOR GOING THE OTHER WAY ARROUND

#define LTOF16_16(l)   (((LONG)(l)) << 16)
#define BLTOF16_16OK(l)  (((l) < 0x00007fff) && ((l) > -0x00007fff))

// 16.16 --> 28.4

#define F16_16TO28_4(X)   ((X) >> 12)

// going back is not always legal

#define F28_4TO16_16(X)   ((X) << 12)
#define B28_4TO16_16OK(X) (((X) < 0x0007ffff) && ((X) > -0x0007ffff))

// 26.6 --> 16.16, never go the other way

#define F26_6TO16_16(X)   ((X) << 10)
#define B26_6TO16_16OK(X) (((X) < 0x003fffff) && ((X) > -0x003fffff))

#define F26_6TO28_4(X)   ((X) >> 2)

// sin of 20 degrees in 16.16 notation, however computed only with
// 8.8 presission to be fully win31 compatible, SEE gdifeng.inc, SIM_ITALIC
// SIM_ITALIC equ 57h

#define FX_SIN20 0x5700
#define FX_COS20 0xF08F

// CARET_Y/CARET_X = tan 12
// these are the values for arial italic from hhead table

#define CARET_X  0X07
#define CARET_Y  0X21


#if DBG
VOID vFSError(FS_ENTRY iRet);
#define V_FSERROR(iRet) vFSError((iRet))
#else
#define V_FSERROR(iRet)
#endif


BOOL
ttfdUnloadFontFile (
    HFF hff
    );

BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    );

LONG
ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       subX,
    ULONG       subY
    );

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    );

LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifyint the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in otf file
    ULONG  *cjTable  // size of table
    );


LONG
ttfdQueryTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // glyph for which info is wanted
    BOOL       bMetricsOnly,   // only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // this is where the metrics should be returned
    ULONG      cjBuf,          // size in bytes of the ppoly buffer
    TTPOLYGONHEADER *ppoly
    );


BOOL bLoadFontFile (
    ULONG_PTR iFile,
    PVOID pvView,
    ULONG cjView,
    ULONG ulLangId,
    HFF   *phttc
    );

typedef struct _NOT_GM  // ngm, notional glyph metrics
{
    SHORT xMin;
    SHORT xMax;
    SHORT yMin;   // char box in notional
    SHORT yMax;
    SHORT sA;     // a space in notional
    SHORT sD;     // char inc in notional
    SHORT sA_Sideways;     // a space in notional, for sideways characters in vertical writing
    SHORT sD_Sideways;     // char inc in notional, for sideways characters in vertical writing

} NOT_GM, *PNOT_GM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c                                                      *
*                                                                          *
* Open,Close,Reset Font Context                                            *
*                                                                          *
* Created: 18-Nov-1991 11:55:38                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/


#include "fd.h"
//#include "winfont.h"

extern INT UnicodeStringCompareCI(const WCHAR* str1, const WCHAR* str2);

BOOL bSetXform
(
    PFONTCONTEXT    pfc,             // OUT
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
);

STATIC BOOL bNewXform
(
    FONTOBJ      *pfo,            // IN
    PFONTCONTEXT  pfc             // OUT
);

STATIC BOOL bComputeMaxGlyph(PFONTCONTEXT pfc);

#define CVT_TRUNCATE  0x00000001
#define CVT_TO_FIX    0X00000002

STATIC BOOL bFloatToL(FLOATL e, PLONG pl);
STATIC Fixed fxPtSize(PFONTCONTEXT pfc);
STATIC BOOL ttfdCloseFontContext(FONTCONTEXT *pfc);
STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc);
STATIC ULONG iHipot(LONG x, LONG y);
LONG lFFF(LONG l);


#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

#define MAX_BOLD 56

/******************************Public*Routine******************************\
*
* PVOID Pv_Realloc
*
*
* History:
*  10-14-1997 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/
PVOID   Pv_Realloc(PVOID pv, LONG newSize, LONG oldSize)
{
// This function will only used by
// fst_CallBackFSTraceFunction() for robust rasterizer
// There is an assumption, the input parameter will be
// alwys correct and there is no need to do value checking.
// If other function need to use it, please be aware of that.
    PVOID   pvNew;

    ASSERTDD(newSize > oldSize, "Pv_Realloc wrong input parameters \n");

    pvNew = PV_ALLOC(newSize);

    if (pvNew == NULL)
    {
        V_FREE(pv);
        return NULL;
    }

    RtlCopyMemory(pvNew, pv, oldSize);
    V_FREE(pv);

    return pvNew;
}

/******************************Public*Routine******************************\
*
* BOOL bInitInAndOut
*
*
* History:
*  18-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bInitInAndOut(FONTFILE *pff)
{
    FS_ENTRY           iRet;
    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    ASSERTDD(pff->pj034 != NULL, "pff->pj3 IS null\n");

    pgin  = (fs_GlyphInputType *)pff->pj034;
    pgout = (fs_GlyphInfoType  *)(pff->pj034 + CJ_IN);

    if ((iRet = fs_OpenFonts(pgin, pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return (FALSE);
    }

    pgin->memoryBases[0] = (char *)(pff->pj034 + CJ_IN + CJ_OUT);
    pgin->memoryBases[1] = NULL;
    pgin->memoryBases[2] = NULL;

// initialize the font scaler, notice no fields of pfc->gin are initialized [BodinD]

    if ((iRet = fs_Initialize(pgin, pgout)) != NO_ERR)
    {
    // clean up and return:

        V_FSERROR(iRet);
    RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
    }

// initialize info needed by NewSfnt function

    pgin->sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of the ttf file

    pgin->clientID = (ULONG_PTR)pff; // pointer to FONTFILE.

    pgin->GetSfntFragmentPtr = pvGetPointerCallback;
    pgin->ReleaseSfntFrag  = vReleasePointerCallback;

    pgin->param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
    pgin->param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

    if ((iRet = fs_NewSfnt(pgin, pgout)) != NO_ERR)
    {
    // clean up and exit

        V_FSERROR(iRet);
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
    }

// sizes 3 and 4 returned

    ASSERTDD(pff->ffca.cj3 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[3]), "cj3\n");
    ASSERTDD(pff->ffca.cj4 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[4]), "cj4\n");

// pj3 should  be shareable, but unfortunately there are fonts that
// use it to store some info there which they expect to find there at
// later times, so we have to make pj3 private as well

    pgin->memoryBases[3] = pff->pj034 + (CJ_IN + CJ_OUT + CJ_0);

// not shared, private

    pgin->memoryBases[4] = pgin->memoryBases[3] + pff->ffca.cj3;

    return TRUE;
}


#define LGINT_TO_LL(X)                                       \
((LONGLONG)(((LONGLONG)((X).HighPart) << 32) | (LONGLONG)((X).LowPart)))


VOID vLONG_X_POINTQF(LONG lIn, POINTQF *ptqIn, POINTQF *ptqOut)
{
    LONGLONG dx, dy;

    dx = LGINT_TO_LL(ptqIn->x);
    dy = LGINT_TO_LL(ptqIn->y);

    dx *= lIn;
    dy *= lIn;

    ptqOut->x = *((LARGE_INTEGER*)(&dx));
    ptqOut->y = *((LARGE_INTEGER*)(&dy));
}




/******************************Public*Routine******************************\
*
* void vCalcEmboldSize
*
* We only support embold enhancemet in FE font.
* The basic rule is 2% extended from normal font.
*
* History:
*  14-May-1997 -by- Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/


void vCalcEmboldSize(FONTCONTEXT * pfc)
{
    USHORT dDesc;

// we always shift glyphs in the direction of baseline and then in
// the direction opposite from ascender direction.
// That is the full shift vector is
//
// we shall use the win95-J compatible algorithm where
// we will shift bitmpas (((2%+1) right X 2% down)) algorithm
//
// The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
// for an emboldening factor of 2%

    dDesc = (USHORT)((pfc->lEmHtDev * 2 - 1) / 100);

// dBase is always at least 1, we do not compute it based on width

    pfc->dBase = dDesc + 1;

}


/******************************Public*Routine******************************\
* ttfdOpenFontContext                                                      *
*                                                                          *
* History:                                                                 *
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/


FONTCONTEXT *ttfdOpenFontContextInternal(FONTOBJ *pfo)
{
    PFONTCONTEXT  pfc   = PFC(NULL);
    PTTC_FONTFILE pttc  = (PTTC_FONTFILE)pfo->iFile;
    ULONG         iFace = pfo->iFace;
    ULONG_PTR     iFile;
    PFONTFILE     pff;

    if (!pttc)
        return((FONTCONTEXT *) NULL);

    ASSERTDD(
        iFace <= pttc->ulNumEntry,
        "gdisrv!ttfdOpenFontContextTTC(): ulFont out of range\n"
        );

    iFile = PFF(pttc->ahffEntry[0].hff)->iFile;

    if (pttc->cRef == 0)
    {
    // have to remap the file

        if
        (
            !EngMapFontFileFD(
                iFile,
                (PULONG*)&pttc->pvView,
                &pttc->cjView
                )
        )
        {
            RETURN("TTFD!_bMapTTF, somebody removed a ttf file\n",NULL);
        }
    }

    // Get FONTFILE structure.

    pff = PFF(pttc->ahffEntry[iFace-1].hff);

    if (pff->cRef == 0)
    {
    // Update FILEVIEW structure in FONTFILE

        pttc->pvView = ((FONTFILEVIEW *)iFile)->pvView;
        pttc->cjView = ((FONTFILEVIEW *)iFile)->cjView;

        pff->pvView = pttc->pvView;
        pff->cjView = pttc->cjView;

    // We have precomputed all sizes and we are allocating all memory at once:

        ASSERTDD(pff->pj034 == NULL, "TTFD, pff->pj034 should be null\n");

        if
        (
            !(pff->pj034 = (PBYTE)PV_ALLOC(
                                    CJ_IN    +
                                    CJ_OUT   +
                                    CJ_0     +
                                    pff->ffca.cj3 +
                                    pff->ffca.cj4
                                    ))
        )
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            RETURN("ttfd, MEM Alloc  failed for pj034\n", NULL);
        }

        if (!bInitInAndOut(pff)) // could cause the exception
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
            RETURN("ttfd, bInitInAndOut failed for \n", NULL);
        }

    }

// allocate memory for the font context and get the pointer to font context

    ASSERTDD(!pff->pfcToBeFreed, "TTFD!ttfdOpenFontContext, pfcToBeFreed NOT null\n");

    if ((pff->pfcToBeFreed = pfc = pfcAlloc(sizeof(FONTCONTEXT))) ==
        (FONTCONTEXT *) NULL )
    {
        //WARNING("TTFD!_ttfdOpenFontContext, hfcAlloc failed\n");
        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }

// state that the hff passed to this function is the FF selected in
// this font context

    pfc->pfo = pfo;
    pfc->pff = pff;
    pfc->ptp = &pff->ffca.tp;

// parts of FONTOBJ that are important

    pfc->flFontType   = pfo->flFontType  ;
    pfc->sizLogResPpi = pfo->sizLogResPpi;
    pfc->ulStyleSize  = pfo->ulPointSize ;

// tt strucs

    pfc->pgin  = (fs_GlyphInputType *) pfc->pff->pj034;
    pfc->pgout = (fs_GlyphInfoType  *) (pfc->pff->pj034 + CJ_IN);


// given the values in the context info store the transform matrix:



    if (!bNewXform(pfo,pfc))
    {
    // clean up and exit

        //WARNING("TTFD!_ttfdOpenFontContext, bNewXform\n");

        vFreeFC(pfc);
        pff->pfcToBeFreed = NULL;

        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }


// setting up of the overScale to a default value

    pfc->overScale = FF_UNDEFINED_OVERSCALE;

// increase the reference count of the font file, WE DO THIS ONLY WHEN
// WE ARE SURE that can not fail any more
// we have pfc, no exceptions any more

// now that we have pfc, we do not want to delete it

    pff->pfcToBeFreed = NULL;

    (pff->cRef)++;
    (pttc->cRef)++;

    return(pfc);
}

/**************************Public*Routine****************************\
* ttfdOpenFontContext                                                *
*                                                                    *
* History:                                                           *
*  07-Jan-1999 -by- Xudong Wu [tessiew]                              *
* Wrote it.                                                          *
\********************************************************************/
FONTCONTEXT *ttfdOpenFontContext(FONTOBJ *pfo)
{
    FONTCONTEXT *pfc;

    VOID vMarkFontGone(TTC_FONTFILE*, DWORD);
    DWORD iExcCode;
    TTC_FONTFILE *pttc = (TTC_FONTFILE *)pfo->iFile;

    try
    {
        pfc = ttfdOpenFontContextInternal(pfo);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        //WARNING("TTFD!_ exception in ttfdOpenFontContext\n");

        vMarkFontGone(pttc, iExcCode = GetExceptionCode());
        if (pttc && (pttc->cRef == 0) && (iExcCode == STATUS_IN_PAGE_ERROR))
        {
            EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
        }
        pfc = NULL;
    }

    return pfc;
}

/******************************Public*Routine******************************\
*
* ttfdCloseFontContext
*
*
* Effects:
*
*
* History:
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdCloseFontContext (
    FONTCONTEXT *pfc
    )
{
    PTTC_FONTFILE pttc;
    PFONTFILE     pff;

    if (pfc == (FONTCONTEXT *) NULL)
        return(FALSE);

    pff  = pfc->pff;
    pttc = pfc->pff->pttc;

// decrement the reference count for the corresponding FONTFILE

    ASSERTDD(pff->cRef > 0L, "TTFD!_CloseFontContext: cRef <= 0 \n");

    pff->cRef--;
    pttc->cRef--;

// if this was the last fc that last used the buffer at pj3, invalidate
// the associated pfcLast

    if (pff->pfcLast == pfc)
        pff->pfcLast = PFC(NULL);

// in case that this is happening after the exception, make sure to release
// any memory that may have possibly been allocated to perform queries
// on per character basis:

    if (pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // if exception this memory has already been freed

        ASSERTDD(!pff->pj034, "\n TTFD! pff->pj3 is NOT null\n");

        if (pfc->gstat.pv) // this may or may have not been allocated
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
    }
    else
    {
        ASSERTDD(pff->pj034, "\n TTFD! pff->pj3 is null\n");
    }

    if (pff->cRef == 0)
    {
    // there are no fc's  around to use memory at pff->pj3, release it.

        if (!(pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR))
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
    }

    if (pttc->cRef == 0)
    {
    // file will not be used for a while,

        EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
    }

// free the memory associated with hfc

    vFreeFC(pfc);
    return(TRUE);
}

/******************************Public*Routine******************************\
* ttfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  27-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    )
{
// For the ttfd, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.

// pfo->pvProducer COULD BE null if exception occured while trying to create fc

    if (pfo->pvProducer)
    {
        ttfdCloseFontContext((FONTCONTEXT *) pfo->pvProducer);
        pfo->pvProducer = NULL;
    }
}


/******************************Public*Routine******************************\
*
* bSetXform
*
* the only reason this funcion can fail is if fs_NewTransformation has failed
* Needs to be called when the transform has changed relative to the
* transform stored in this fc
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bSetXform (
    PFONTCONTEXT    pfc,
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
    )
{
    FS_ENTRY    iRet;
    transMatrix mx = pfc->mx;
    Fixed       fxScale;
    LONG        ptSize;

// no previous glyph metric computation can be used

    vInitGlyphState(&pfc->gstat);

// if an illegal junk is passed for style size replace by reasonable default

    if (pfc->ulStyleSize > SHRT_MAX)
        pfc->ulStyleSize = 0;


    pfc->subPosX = subPosX;
    pfc->subPosY = subPosY;

    mx.transform[0][2] = subPosX;
    mx.transform[1][2] = subPosY;

    if (UNHINTED_MODE(pfc))
    {
        pfc->pgin->param.newtrans.bHintAtEmSquare = TRUE;
    }
    else
    {
        pfc->pgin->param.newtrans.bHintAtEmSquare = FALSE;
    }

    pfc->pgin->param.newtrans.xResolution = (int16)pfc->sizLogResPpi.cx;
    pfc->pgin->param.newtrans.yResolution = (int16)pfc->sizLogResPpi.cy;

    if (pfc->flXform & XFORM_SINGULAR)
    {
    // just put in some junk so that the preprogram does not explode

        pfc->pgin->param.newtrans.pointSize = LTOF16_16(12);

        mx.transform[0][0] = LTOF16_16(1);
        mx.transform[1][0] = 0;
        mx.transform[1][1] = LTOF16_16(1);
        mx.transform[0][1] = 0;
    }
    else
    {
        if (pfc->flXform & XFORM_HORIZ)
        {
            if (pfc->ulStyleSize == 0)
            {
            // hinting is determined by ptSize that corresponds to the
            // actual height in points of the font

                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;

            // factor out pointSize from the xform:

                if (pfc->mx.transform[1][1] > 0)
                    mx.transform[1][1] = LTOF16_16(1);
                else
                    mx.transform[1][1] = LTOF16_16(-1);

                if
                (
                    (pfc->mx.transform[1][1] == pfc->mx.transform[0][0])
                    &&
                    (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
                )
                {
                // important special case, simplify computation

                    mx.transform[0][0] = mx.transform[1][1];
                }
                else // general case
                {
                    fxScale = LongMulDiv(
                                 LTOF16_16(pfc->pff->ffca.ui16EmHt),pfc->sizLogResPpi.cy,
                                 pfc->lEmHtDev * pfc->sizLogResPpi.cx
                                 );

                    mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                }
            }
            else
            {
            // This is the support for new optical scaling feature.
            // Hint the font as determined by the style point size from
            // ExtLogFont,  but possibly zoom the font to a different
            // physical size

                pfc->pgin->param.newtrans.pointSize =
                    (Fixed)LTOF16_16(pfc->ulStyleSize);

            // factor out pointSize from the xform:

                fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                             pfc->ulStyleSize * pfc->sizLogResPpi.cx
                             );

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                  pfc->ulStyleSize * pfc->sizLogResPpi.cy
                                  );
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
            }
        }
        else
        {
            if (pfc->ulStyleSize == 0)
            {
            // compute the physical point size

                ptSize = F16_16TOLROUND(pfc->fxPtSize);
                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;
            }
            else // use style size from logfont, the support for optical scaling
            {
                ptSize = pfc->ulStyleSize;
                pfc->pgin->param.newtrans.pointSize = LTOF16_16(pfc->ulStyleSize);
            }

        // factor out pointSize from the xform:

            if
            (
                (pfc->flXform & XFORM_VERT) &&
                (pfc->mx.transform[1][0] == -pfc->mx.transform[0][1])
                &&
                (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
            )
            {
            // important special case, simplify computation
            // and avoid rounding error

                if (pfc->mx.transform[0][1] > 0)
                    mx.transform[0][1] = LTOF16_16(1);
                else
                    mx.transform[0][1] = LTOF16_16(-1);

                mx.transform[1][0] = -mx.transform[0][1];
                mx.transform[0][0] = 0;
                mx.transform[1][1] = 0;
            }
            else
            {

                if (((ptSize + 1) * pfc->sizLogResPpi.cx) > 0x8000)
                {
                    /* keep the old computation to avoid overflow */
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                 ptSize * pfc->sizLogResPpi.cx
                                 );
                } else {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                 pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cx
                                 );
                }

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                mx.transform[1][0] = FixMul(mx.transform[1][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    if (((ptSize + 1) * pfc->sizLogResPpi.cy) > 0x8000)
                    {
                    /* keep the old computation to avoid overflow */
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                      ptSize * pfc->sizLogResPpi.cy
                                      );
                    } else {
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                      pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cy
                                      );
                    }
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
                mx.transform[0][1] = FixMul(mx.transform[0][1], fxScale);
            }
        }

    }

// last minute modification to the matrix if italicization is present:

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // the result of multiplying arbitrary matrix with italicization matrix
    // We are multiplying from the left because the italicization matrix
    // acts first on the notional space vectors on the left
    //
    // |1      0|   |m00    m01|   |m00                 m01              |
    // |        | * |          | = |                                     |
    // |sin20  1|   |m10    m11|   |m10 + m00 * sin20   m11 + m01 * sin20|
    //

        mx.transform[1][0] += FixMul(mx.transform[0][0], FX_SIN20);
        mx.transform[1][1] += FixMul(mx.transform[0][1], FX_SIN20);

    } else if (pfc->flFontType & FO_SIM_ITALIC_SIDEWAYS)
    {
    // the result of multiplying arbitrary matrix with italicization matrix
    // We are multiplying from the left because the italicization matrix
    // acts first on the notional space vectors on the left
    //
    // |1  -sin20|   |m00    m01|   |m00 - m10 * sin20   m01 - m11 * sin20|
    // |         | * |          | = |                                     |
    // |0       1|   |m10    m11|   |m10                 m11              |
    //

        mx.transform[0][0] -= FixMul(mx.transform[1][0], FX_SIN20);
        mx.transform[0][1] -= FixMul(mx.transform[1][1], FX_SIN20);
    }

    pfc->pgin->param.newtrans.transformMatrix = &mx;

// FIXEDSQRT2 is good as pixel diameter for all practical purposes
// according to EliK, LenoxB and JeanP [bodind]

    pfc->pgin->param.newtrans.pixelDiameter = FIXEDSQRT2;

    pfc->pgin->param.newtrans.usOverScale = pfc->overScale;
    ASSERTDD( pfc->overScale != FF_UNDEFINED_OVERSCALE , "Undefined Overscale\n" );

    if (pfc->flFontType & FO_CLEARTYPE_GRID)
    {
		if (pfc->flFontType & FO_COMPATIBLE_WIDTH)
		{
			pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH;
		} else {
			pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL;
		}
    } else {
        pfc->pgin->param.newtrans.flSubPixel = 0;
    }

    pfc->pgin->param.newtrans.traceFunc = (FntTraceFunc)NULL;

    if (pfc->flFontType & FO_SIM_BOLD)
    {
	/* 2% + 1 pixel along baseline, 2% along descender line */
	    pfc->pgin->param.newtrans.usEmboldWeightx = 20;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 20;
	    pfc->pgin->param.newtrans.lDescDev = pfc->lDescDev;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = bBitmapEmboldening;
    }
    else
    {
	    pfc->pgin->param.newtrans.usEmboldWeightx = 0;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 0;
	    pfc->pgin->param.newtrans.lDescDev = 0;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
    }

// now call the rasterizer to acknowledge the new transform

    if ((iRet = fs_NewTransformation(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        if ((iRet = fs_NewTransformNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
           V_FSERROR(iRet);
            return(FALSE);
        }
    }

    if (bBitmapEmboldening && (pfc->flFontType & FO_SIM_BOLD))
    {
        pfc->flXform |= XFORM_BITMAP_SIM_BOLD;
    } else {
        pfc->flXform &= ~XFORM_BITMAP_SIM_BOLD;
    }
    return(TRUE);
}


VOID vQuantizeXform
(
PFONTCONTEXT pfc
);


/******************************Public*Routine******************************\
*
* STATIC bComputeMaxGlyph
*
*
* Effects:
*
* Warnings:
*
* History:
*  04-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeMaxGlyph (
    PFONTCONTEXT   pfc
    )
{
    VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *);
    VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *);

    LONG              cxMax,cyMax;

    LONG              yMinN, yMaxN;
    LONG              xMinN, xMaxN;

    LONG              lTmp;
    Fixed             fxMxx,fxMyy;
    BYTE             *pjView = (BYTE *)pfc->pff->pvView;

    sfnt_FontHeader * phead = (sfnt_FontHeader *) (
                      pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp
                      );

    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)          ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp) :
                   NULL                                       ;

    ASSERTDD(pjView, "bComputeMaxGlyph, pjView\n");

// get the notional space values

    if (pjOS2 && (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
    {
    // win 31 compatibility: we only take the max over win 31 char set.
    // All the glyphs outside this set, if they stand out will get shaved
    // off to match the height of the win31 char subset. Also notice that
    // for nonhorizontal cases we do not use os2 values because shaving
    // only applies to horizontal case, otherwise our bounding box values
    // will not be computed properly for nonhorizontal cases.

        yMinN =  - BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        yMaxN =    BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
    }
    else
    {
        yMinN = - BE_INT16(&phead->yMax);
        yMaxN = - BE_INT16(&phead->yMin);
    }

    ASSERTDD(yMinN < yMaxN, "yMinN >= yMaxN\n");

    xMinN = BE_INT16(&phead->xMin);
    xMaxN = BE_INT16(&phead->xMax);

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation
    //     xMin -> xMin - yMaxN * sin20
    //     xMax -> xMax - yMinN * sin20

        xMinN -= FixMul(yMaxN, FX_SIN20);
        xMaxN -= FixMul(yMinN, FX_SIN20);
    } else if (pfc->flFontType & FO_SIM_ITALIC_SIDEWAYS)
    {
    // IF there is italic simulation
    //     yMin -> yMin + xMinN * sin20
    //     yMax -> yMax + xMaxN * sin20

        yMinN += FixMul(xMinN, FX_SIN20);
        yMaxN += FixMul(xMaxN, FX_SIN20);
    }

    ASSERTDD(xMinN < xMaxN, "xMinN >= xMaxN\n");

    pfc->lEmHtDev = 0; // flag that it has not been computed
    pfc->fxPtSize = 0; // flag that it has not been computed
    pfc->phdmx = NULL; // NULL unless computed otherwise

    if ((pfc->flXform & XFORM_HORIZ) &&
        !(pfc->flXform & XFORM_SINGULAR))  // XX AND YY Only
    {
        sfnt_HorizontalHeader  *phhea;
        ULONG  cHMTX;

        fxMxx = pfc->mx.transform[0][0];
        fxMyy = pfc->mx.transform[1][1];

    // ascender, round up

        yMinN = FixMul(fxMyy, yMinN);
        yMaxN = FixMul(fxMyy, yMaxN);

        if (fxMyy > 0)
        {
        // vdmx table should be consulted if present and used to compute
        // ascender and descender. If this computation can not be done
        // based on vdmx table or if vdmx table is not present simple
        // linear scaling will suffice [bodind].

            if (!UNHINTED_MODE(pfc))
            {
                /* we ignore VDMX if we are in an unhinted mode */
                vQuantizeXform(pfc);
            }

            if (!(pfc->flXform & XFORM_VDMXEXTENTS)) // COMPUTED FROM VDMX
            {
                pfc->yMin = yMinN;
                pfc->yMax = yMaxN;
            }
            else
            {
                /* take the biggest between the VDMX metrics and the linearly scaled metrics
                   the font Lucida Sans Unicode is an exemple of font that have VDMX metrics
                    10% smaller than linearly scaled metrics */
                if (yMinN < pfc->yMin)
                    pfc->yMin = yMinN;

                if (yMaxN > pfc->yMax)
                    pfc->yMax = yMaxN;
            }

            pfc->lAscDev  = - pfc->yMin;
            pfc->lDescDev =   pfc->yMax;
        }
        else // fxMyy < 0
        {
            pfc->lAscDev =    yMinN;
            pfc->lDescDev = - yMaxN;

        // swap yMin and yMax for when the xform flips y coord

            lTmp  = yMinN;
            yMinN = yMaxN;
            yMaxN = lTmp;

            pfc->yMin = yMinN;
            pfc->yMax = yMaxN;

        }

        if (pfc->lEmHtDev == 0)
        {
        // if this value has not been computed in vQuantizeXform routine

            pfc->lEmHtDev = FixMul(fxMyy, pfc->pff->ifi.fwdUnitsPerEm);
            if (pfc->lEmHtDev < 0)
                pfc->lEmHtDev = - pfc->lEmHtDev;
        }

        ASSERTDD(pfc->lEmHtDev >= 0, "lEmHt negative\n");

    // now that em height has been computed, we can compute the
    // pt size on the rendering device. This value will be fed to
    // fs_NewTransformation

        pfc->fxPtSize = LongMulDiv(
                            LTOF16_16(pfc->lEmHtDev), 72,
                            pfc->sizLogResPpi.cy);

        cyMax = pfc->yMax - pfc->yMin;

        phhea = (sfnt_HorizontalHeader *)(
                (BYTE *)pfc->pff->pvView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp
                );
        cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);


    // scale xMin,xMax to device, 28.4 format

        xMinN = FixMul(LTOFX(xMinN), fxMxx);
        xMaxN = FixMul(LTOFX(xMaxN), fxMxx);

        if (fxMxx < 0)
        {
            lTmp  = xMinN;
            xMinN = xMaxN;
            xMaxN = lTmp;
        }

    // I run the experiment on 400 fonts at several sizes. I found
    // that subtracting 2 from xMin and adding 1 to xMax suffices
    // in all situations to prevent any columns from being shaved off.
    // [bodind]

        xMinN = FXTOLFLOOR(xMinN) - 2;
        xMaxN = FXTOLCEILING(xMaxN) + 1;

        pfc->xMin = xMinN;
        pfc->xMax = xMaxN;

        cxMax = xMaxN - xMinN;

    }
    else // nontrivial transformation
    {
        POINTL   aptl[4];
        POINTFIX aptfx[4];
        BOOL     bOk;
        INT      i;
        FIX      xMinD, xMaxD, yMinD, yMaxD; // device space values;

    // add little extra space to be safe

        i = (INT)(pfc->pff->ffca.ui16EmHt / 64);
        yMaxN +=  i; // adds about 1.7% to ht
        yMinN -=  i; // adds about 1.7% to ht

    // set up the input array, the four corners of the maximal bounding
    // box in the notional coords

        aptl[0].x = xMinN;       //  tl.x
        aptl[0].y = yMinN;       //  tl.y

        aptl[1].x = xMaxN;       //  tr.x
        aptl[1].y = yMinN;       //  tr.y

        aptl[2].x = xMinN;       //  bl.x
        aptl[2].y = yMaxN;       //  bl.y

        aptl[3].x = xMaxN;       //  br.x
        aptl[3].y = yMaxN;       //  br.y

    // xform to device coords with 28.4 precision:

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bFDXform(&pfc->xfm, aptfx, aptl, 4);

        if (!bOk) { RETURN("TTFD!_:bFDXform\n", FALSE); }

        xMaxD = xMinD = aptfx[0].x;
        yMaxD = yMinD = aptfx[0].y;

        for (i = 1; i < 4; i++)
        {
            if (aptfx[i].x < xMinD)
                xMinD = aptfx[i].x;
            if (aptfx[i].x > xMaxD)
                xMaxD = aptfx[i].x;
            if (aptfx[i].y < yMinD)
                yMinD = aptfx[i].y;
            if (aptfx[i].y > yMaxD)
                yMaxD = aptfx[i].y;
        }

        yMinD = FXTOLFLOOR(yMinD)   ;
        yMaxD = FXTOLCEILING(yMaxD) ;
        xMinD = FXTOLFLOOR(xMinD)   ;
        xMaxD = FXTOLCEILING(xMaxD) ;

        cxMax = xMaxD - xMinD;
        cyMax = yMaxD - yMinD;

    // now re-use aptl to store e1 and -e2, base and side unit
    // vectors in the notional space.
    //!!! This may be wrong if have font for
    //!!! right to left or vert writing [bodind]

        aptl[0].x = 1;    // base.x
        aptl[0].y = 0;    // base.y

        aptl[1].x =  0;   // side.x
        aptl[1].y = -1;   // side.y

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bXformUnitVector (
                  &aptl[0],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->efBase       // OUT, |*pptqXormed|
                  );

        bOk &= bXformUnitVector (
                  &aptl[1],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->efSide       // OUT, |*pptqXormed|
                  );

        if (!bOk) { RETURN("TTFD!_:bXformUnitVector\n", FALSE); }

        pfc->lAscDev  = -fxLTimesEf(&pfc->efSide,yMinN);
        pfc->lDescDev =  fxLTimesEf(&pfc->efSide,yMaxN);

        pfc->lAscDev  = FXTOLCEILING(pfc->lAscDev) ;
        pfc->lDescDev = FXTOLCEILING(pfc->lDescDev);

        // finally store the results:

        pfc->xMin        = xMinD;
        pfc->xMax        = xMaxD;
        pfc->yMin        = yMinD;
        pfc->yMax        = yMaxD;

    // compute em ht in pixels and points


        pfc->fxPtSize = fxPtSize(pfc);

        /* compute pfc->lEmHtDev from pfc->fxPtSize to make sure values are coherent */

        {
            Fixed fxScale;

            fxScale = LongMulDiv(pfc->fxPtSize, pfc->sizLogResPpi.cy, 72);
            pfc->lEmHtDev = (uint16)ROUNDFIXTOINT(fxScale);
        }

    }

    if ((pfc->flXform & (XFORM_HORIZ | XFORM_VERT)) && 
        ((pfc->mx.transform[0][0] == pfc->mx.transform[1][1]) || (pfc->mx.transform[0][0] == -pfc->mx.transform[1][1]) ) &&
        ((pfc->mx.transform[0][1] == pfc->mx.transform[1][0]) || (pfc->mx.transform[0][1] == -pfc->mx.transform[1][0])) )
    {
    // find the hdmx table, in case of the console fixed pitch font this
    // table may be useful in determining if cxMax needs to be cut off
    // to the advance width of this font
    // we can use this table for rotations that are a multiple of 90 degree and mirror flips as long as we have a square transform

        vFindHdmxTable(pfc); 
    }

// compute corrections

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        vCalcEmboldSize(pfc);
    }
    else
    {
        pfc->dBase = 0;
    }

// if this is one of the almost singular transforms, reject this

    if ((cxMax == 0) || (cyMax == 0))
    {
        RETURN("TTFD! almost singular xform, must fail\n", FALSE);
    }


    if (pfc->flFontType & FO_SIM_BOLD)
    {
        /* we are on the safe side by adding dBase to both cxMax and cyMax */
        cxMax += pfc->dBase;
        cyMax += pfc->dBase;
    }

// we can liberally extend cxMax to the byte boundary, this is not
// going to change memory requirements of the system.

    cxMax = ((cxMax + 7) & ~7);
    pfc->cxMax = cxMax;
    pfc->cyMax = cyMax;

// now we have to determine how big in memory is the biggest glyph.
// let us remember that the rasterizer needs little more storage than the
// the engine does, because rasterizer will want dword aligned rows rather
// than byte aligned rows

    {
        DWORDLONG lrg;

    // why am I dword instead byte extending cxMax? because that is
    // how much rasterizer will want for this bitmap

        ULONG          cjMaxScan = ((cxMax + 31) & ~31) / 8;
        lrg =  UInt32x32To64(cjMaxScan, cyMax);
        if (lrg > ULONG_MAX)
        {
        // the result does not fit in 32 bits, alloc memory will fail
        // this is too big to digest, we fail to open fc

            RETURN("TTFD! huge pt size, must fail\n", FALSE);
        }
    }

// We now have all the informaiton to set the gray bit
// appropriately.

    if (pfc->flFontType & FO_CLEARTYPE_GRID || pfc->flFontType & FO_CLEARTYPE)
    {
        vSetClearTypeState__FONTCONTEXT(pfc);
    }
    else
    {
        vSetGrayState__FONTCONTEXT(pfc);
    }

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );

    pfc->cjGlyphMax = CJGD(cxMax,cyMax,pfc);

    return TRUE;
}

//--------------------------------------------------------------------
// LONG iHipot(x, y)
//
// This routine returns the hypoteneous of a right triangle.
//
// FORMULA:
//          use sq(x) + sq(y) = sq(hypo);
//          start with MAX(x, y),
//          use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the
//          target hypotenouse.
//
// History:
//  Mon 07-Feb-1994 -by- Bodin Dresevic [BodinD]
//  update:   update to use Fixed 16.16
//   10-Feb-1993    -by-    Kent Settle     (kentse)
//  Stole from RASDD.
//   21-Aug-1991    -by-    Lindsay Harris  (lindsayh)
//  Cleaned up UniDrive version, added comments etc.
//--------------------------------------------------------------------


/*

      Algorithm analysis by DChinn :

      After a bit of incorrect attempts, I figured it all out.  It turns out that
    the if h is the correct hypotenuse, then the routine returns the
    ceiling of h.  Here's the analysis:


    Let h = the correct hypotenuse
        h = sqrt{x^2 + y^2}

        x and y are integers.

    Let h' = the value returned by the algorithm

                      { d-1                        }
        h' = y +  min { sum [ 2(y+i) + 1 ]  >= x^2 }
                  d>0 { i=0                        }

                 { d-1                        }
    Let d' = min { sum [ 2(y+i) + 1 ]  >= x^2 }
             d>0 { i=0                        }

    Consider the smallest d for which

            d-1
            sum [ 2(y+i) + 1 ]  >= x^2  .
            i=0

            d-1                d-1
            sum (2y + 1)  +  2 sum i   >= x^2
            i=0                i=0

               2yd + d    + (d-1)d   - x^2 >= 0

            d^2 + 2yd - x^2 >= 0        (solve this equation as if it were an equality)

                  -2y +/- sqrt{ (2y)^2 - 4 * 1 * (-x^2) }
            d  =  ---------------------------------------
                                    2
            d' =  ceiling (d)

            d' =  ceiling (  -y +/- sqrt{ y^2 + x^2 }  )

               =  -y + ceiling ( sqrt{ y^2 + x^2 } )     (the minus in +/- is impossible)

    So, h' = y +  (-y) + ceiling ( sqrt{ y^2 + x^2 } )
           = ceiling ( sqrt{ y^2 + x^2 } )

    The loop invariant: Since delta is incremented by 2*hypo+1 in each iteration and
    (hypo+1)^2 = hypo^2 + (2*hypo + 1), then at the end of each iteration, a
    triangle with sides y, sqrt{delta}, and hypo is always a right triangle.

    Note that there is no assumption in the above that y >= x, so
    that assumption is for performance reasons only.

  */

STATIC ULONG iHipot(LONG x, LONG y)
{
    ULONG  hypo;         /* Value to calculate */
    ULONG  delta;        /* Used in the calculation loop */
    ULONG  target;       /* Loop limit factor */
	USHORT  shift = 0;

// quick exit for frequent trivial cases [bodind]

    if (x < 0)
        x = -x;

    if (y < 0)
        y = -y;

    if (x == 0)
        return y;

    if (y == 0)
        return x;

    /* avoid overflow */
    while ((x > 0x8000L) || (y > 0x8000L))
    {
        x >>= 1;
        y >>= 1;
        shift ++;
    }

    if (x > y)
    {
        hypo = x;
        target = y * y;
    }
    else
    {
        hypo = y;
        target = x * x;
    }

    for (delta = 0; delta < target; hypo++)
        delta += ((hypo << 1) + 1);

    return (hypo << shift);
}


/******************************Public*Routine******************************\
*
* bSingularXform
*
* Checks whether this is one of the xforms that the rasterizer is known
* to choke on. Those are the transforms that generate very
* narrow fonts (less than 0.5 pixels/em wide or tall). For fonts that
* allow only integer widths/em and heights/em this number will get rounded
* down to zero and generate divide by zero exception in the preprogram.
* We will flag such transforms as XFORM_SINGULAR and return empty bitmaps
* and outlines for them shortcircuiting the rasterizer which would die on
* us.
*
* Actually, for compatibility reasons we will have to change
* this plan a little bit. It turns out that
* win 31 does not allow for the rasterization of a font that is less
* than 2 pixels tall (ie. the Em Ht of the font in device space must be
* >= 2 pixels). If a request comes down to realize a font that is tall less
* than 2 pixels we will simply have to substitute the transform by a scaled
* transform that will produce a font of height two pixels. We will still keep
* our singular transform code in case a font is requested that is singular in
* X direction, that is, too narrow.
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// smallest ppem allowed under  win31:

#define WIN31_PPEM_CUTOFF 2

STATIC VOID vCheckForSingularXform (PFONTCONTEXT  pfc) // OUT
{

    register LONG  lEmHtDev;

    Fixed fxEmHtDev;
    Fixed fxEmHtNot = LTOF16_16(pfc->pff->ffca.ui16EmHt);
    Fixed fxScale;
    Fixed fxEmWidthDev;

// xforms are conforming left multiplication rule v' = v * M i.e.:
//
// (x,0) -> x(m00,m01)
// (0,y) -> y(m10,m11)
//
// compute length of (0,Em) after it gets transformed to device space:
// We need to have fxEmHtDev computed with high precission, for we
// shall be using it to divide the original transform by.
// We want to avoid division by zero when that is not neccessary.

    fxEmHtDev = FixMul(
                   iHipot(pfc->mx.transform[1][1],pfc->mx.transform[1][0]),
                   fxEmHtNot
                   );

    lEmHtDev = F16_16TOLROUND(fxEmHtDev);
    if (lEmHtDev < WIN31_PPEM_CUTOFF) // too small a transform:
    {
        pfc->flXform |= XFORM_2PPEM;

    // according to win31 algorithm, we must scale this xform so that the
    // resulting xform will produce font that is 2 pels tall.
    // That is, the new transform M' is going to be
    //
    // M' = (WIN31_PPEM_CUTOFF / lEmHtDev) * M
    //
    // so that the following equation is satisfied:
    //
    // |(0,EmNotional) * M'| == WIN31_PPEM_CUTOFF == 2;

        if (pfc->flXform & XFORM_HORIZ)
        {
        // in this special case the above formula for M' becomes:
        //
        //                                         | m00/|m11|     0     |
        // M' = (WIN31_PPEM_CUTOFF / EmNotional) * |                     |
        //                                         |   0        sgn(m11) |

#define LABS(x) ((x)<0)?(-x):(x)

            Fixed fxAbsM11 = LABS(pfc->mx.transform[1][1]);
            Fixed fxAbsM00 = LABS(pfc->mx.transform[0][0]);

            LONG lSgn11 = (pfc->mx.transform[1][1] >= 0) ? 1 : -1;
            LONG lSgn00 = (pfc->mx.transform[0][0] >= 0) ? 1 : -1;

            fxScale = FixDiv(WIN31_PPEM_CUTOFF,pfc->pff->ffca.ui16EmHt);

            pfc->mx.transform[1][1] = fxScale;
            if (fxAbsM00 != fxAbsM11)
            {
                pfc->mx.transform[0][0] = LongMulDiv(fxScale,fxAbsM00,fxAbsM11);
            }
            else
            {
                pfc->mx.transform[0][0] = fxScale;
            }

        // fix the signs if needed:

            if (lSgn11 < 0)
                pfc->mx.transform[1][1] = - pfc->mx.transform[1][1];

            if (lSgn00 < 0)
                pfc->mx.transform[0][0] = - pfc->mx.transform[0][0];
        }
        else
        {
        // general case, compute scale (which involves division) once,
        // and use it for all four members of the matrix:

            fxScale = FixDiv(LTOF16_16(WIN31_PPEM_CUTOFF),fxEmHtDev);

            pfc->mx.transform[0][0] = FixMul(pfc->mx.transform[0][0],fxScale);
            pfc->mx.transform[0][1] = FixMul(pfc->mx.transform[0][1],fxScale);
            pfc->mx.transform[1][0] = FixMul(pfc->mx.transform[1][0],fxScale);
            pfc->mx.transform[1][1] = FixMul(pfc->mx.transform[1][1],fxScale);

        // In general case must also fix the original EFLOAT xform because
        // it is going to be used for computation of extents, max glyphs etc.

            FFF(pfc->xfm.eM11, +pfc->mx.transform[0][0]);
            FFF(pfc->xfm.eM22, +pfc->mx.transform[1][1]);
            FFF(pfc->xfm.eM12, -pfc->mx.transform[0][1]);
            FFF(pfc->xfm.eM21, -pfc->mx.transform[1][0]);
        }
    }

// Now check if the transform is singular in x. To do this
// compute length of (Em,0) after it gets transformed to device space:

    fxEmWidthDev = FixMul(
                   iHipot(pfc->mx.transform[0][0],pfc->mx.transform[0][1]),
                   fxEmHtNot
                   );

    if (fxEmWidthDev <= ONEHALFFIX)
    {
    // We are in trouble, we shall have to lie to the engine:

        pfc->flXform |= XFORM_SINGULAR;
    }
}




/******************************Public*Routine******************************\
*
* bNewXform:
*
* converts the transform matrix to the form the rasterizer likes
* and computes the global (per font) sizes that are relevant for this
* transform.
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC BOOL
bNewXform (
    FONTOBJ      *pfo,
    PFONTCONTEXT pfc             // OUT
    )
{
// do not write immediately to pfc->mx until sure that all bFloatToL
// have succeeded. You do not want to leave this function and leave
// fc in a dirty state

    Fixed fx00, fx01, fx10, fx11;

// Get the transform elements.

    pfc->xfm.eM11 = pfo->fdx.eXX;
    pfc->xfm.eM12 = pfo->fdx.eXY;
    pfc->xfm.eM21 = pfo->fdx.eYX;
    pfc->xfm.eM22 = pfo->fdx.eYY;
    pfc->xfm.eDx = 0;
    pfc->xfm.eDy = 0;

    if (
        !bFloatToL(pfc->xfm.eM11, &fx00) ||
        !bFloatToL(pfc->xfm.eM22, &fx11) ||
        !bFloatToL(pfc->xfm.eM12, &fx01) ||
        !bFloatToL(pfc->xfm.eM21, &fx10)
       )
        RET_FALSE("TTFD!_bFloatToL failed\n");

// we are fine now, can not fail after this:

    pfc->mx.transform[0][0]  = fx00;
    pfc->mx.transform[1][1]  = fx11;
    pfc->mx.transform[0][1]  = -fx01;
    pfc->mx.transform[1][0]  = -fx10;

// check if this is one of the sing xform where one row or column is zero:
// It is important to do this after bFloatToL, some floating numbers can be
// so small that can only be represented as zeros in 16.16 format

    if
    (
        !(fx00 | fx01) ||
        !(fx00 | fx10) ||
        !(fx11 | fx10) ||
        !(fx11 | fx01)
    )
    {
        ASSERTDD(1, "We are messed up by this xform\n");
        return FALSE;
    }

// components in the projective space are zero

// ClaudeBe, from the client interface Doc :
// Please note that although the third column of the matrix is defined as Fixed numbers
// you will actually need to use  Fract numbers in that column. The higher resolution provided
// by Fracts is required to change the perspective of a glyph. Fracts are 2.30 fixed point numbers.

    pfc->mx.transform[2][2] = ONEFRAC;
    pfc->mx.transform[0][2] = (Fixed)0;
    pfc->mx.transform[1][2] = (Fixed)0;
    pfc->mx.transform[2][0] = (Fixed)0;
    pfc->mx.transform[2][1] = (Fixed)0;

// set the flags for the transform:

    pfc->flXform = 0;

    if ((fx01 == 0) && (fx10 == 0))
        pfc->flXform |= XFORM_HORIZ;

    if ((fx00 == 0) && (fx11 == 0))
        pfc->flXform |= XFORM_VERT;

// important to check for "singular transform"
// (ie. request for too small a font realization) after flags have been set

    vCheckForSingularXform(pfc);

// no glyph metrics computation is valid yet

    vInitGlyphState(&pfc->gstat);

// no memory to rasterize a glyph or produce glyph outline has been allocated

    pfc->gstat.pv = NULL;

// now get the sizes for this transform

    return bComputeMaxGlyph(pfc);
}


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Convert an IEEE floating point number to a long integer.                 *
*                                                                          *
* History:                                                                 *
*
*  Thu 29-Mar-2001 -by- Mikhail Leonov [MLeonov]
* update:
*   changed <= 23 to < 23, otherwise numbers like 142.5 get converted to 0
*
*  Sun 17-Nov-1991 -by- Bodin Dresevic [BodinD]
* update:
*
* changed the line
*    if (flType & CVT_TO_FIX) lExp += 4;
* to
*    if (flType & CVT_TO_FIX) lExp += 16;
* to reflect that we are converting to 16.16 format rather than to 28.4
*
*
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

STATIC BOOL bFloatToL(FLOATL e, PLONG pl)
{
    LONG lEf, lExp;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then convert to 0 and return true

    lExp = ((lEf >> 23) & 0xff) -127;

    lExp += 16; // this is the only line I changed [bodind]

    if (lExp < 0)
    {
        *pl = 0;
        return(TRUE);
    }

// if exponent < 23 then
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//         l = ((lMantissa >> (23 - lExponent -1)) + 1) >> 1;

    if (lExp < 23)
    {
        *pl = (lEf & 0x80000000) ?
             -(((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1) :
             ((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1;
        return(TRUE);
    }

// if exponent <= 30 then
// lMantissa = (lEf & 0x7fffff) | 0x800000;
// l = lMantissa << (lExponent - 23);

    if (lExp <= 30)
    {
        *pl = (lEf & 0x80000000) ?
            -(((lEf & 0x7fffff) | 0x800000) << (lExp - 23)) :
            ((lEf & 0x7fffff) | 0x800000) << (lExp - 23);
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* lFFF = long-float-from-fixed
*
* input: 16.16 representation
* output: LONG that is bit equivalent of the 32-bit ieee float
*         equal to the fix point number. To recover the float
*   the FLOAT representation you simply cast the bits as a float
*   that is
*
*   FLOAT e;
*
*       *(LONG*)&e = lFFF(n16Dot16)
*
* History:
*  Tue 03-Jan-1995 14:33:35 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

LONG lFFF(LONG l)
{
#if defined(_AMD64_) || defined(_IA64_)
    FLOAT e = ((FLOATL) l)/((FLOATL) 65536);
    return(*(LONG*)&e);
#elif defined(_X86_)
    int i;                              // shift count
    unsigned k;                         // significand

    if (k = (unsigned) l)
    {
        if (l < 0)
            k = (unsigned) -l;          // significand is positive, sign
                                        // bit accounted for later
        i = 0;
        if (k < (1 << 16)) {            // put the number in the
            k <<= 16;                   // range 2^31 <= k < 2^32
            i += 16;                    // by shifting to left, put
        }                               // shift count in i
        if (k < (1 << 24)) {
            k <<= 8;
            i += 8;
        }
        if (k < (1 << 28)) {
            k <<= 4;
            i += 4;
        }
        if (k < (1 << 30)) {
            k <<= 2;
            i += 2;
        }
        if (k < (1 << 31)) {
            k <<= 1;
            i += 1;
        }
                                        // at this point
                                        // i = 31-floor(log2(abs(l)))

        k += (1 << 7);                  // about to shift out
                                        // the lowest 8-bits
                                        // account for their effect by
                                        // rounding. This has the effect
                                        // that numbers are rounded away
                                        // from zero as opposed to rounding
                                        // stricktly up
        k >>= 8;                        // shift out the lowest 8 bits

        k &= ((1<<23) - 1);             // 2^23 bit is implicit so mask it out
        k |= (0xff & (142 - i)) << 23;  // set exponent at correct place
        if (l < 0)                      // if original number was negative
            k |= (1<<31);               // then set the sign bit
    }
    return((LONG) k);
#endif
}


#if DBG

/******************************Public*Routine******************************\
*
* VOID vFSError(FS_ENTRY iRet);
*
*
* Effects:
*
* Warnings:
*
* History:
*  25-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFSError(FS_ENTRY iRet)
{
    PCHAR psz;

    switch (iRet)
    {
        case BAD_CALL_ERR:
            psz =  "BAD_CALL_ERR";
            break;
        case BAD_CLIENT_ID_ERR:
            psz =  "BAD_CLIENT_ID_ERR";
            break;
        case BAD_MAGIC_ERR:
            psz =  "BAD_MAGIC_ERR";
            break;
        case BAD_START_POINT_ERR:
            psz =  "BAD_START_POINT_ERR";
            break;
        case CLIENT_RETURNED_NULL:
            psz =  "CLIENT_RETURNED_NULL";
            break;
        case CONTOUR_DATA_ERR:
            psz =  "CONTOUR_DATA_ERR";
            break;
        case GLYPH_INDEX_ERR:
            psz =  "GLYPH_INDEX_ERR";
            break;
        case INSTRUCTION_SIZE_ERR:
            psz =  "INSTRUCTION_SIZE_ERR";
            break;
        case INVALID_GLYPH_INDEX:
            psz =  "INVALID_GLYPH_INDEX";
            break;
        case MISSING_SFNT_TABLE:
            psz =  "MISSING_SFNT_TABLE";
            break;
        case NULL_INPUT_PTR_ERR:
            psz =  "NULL_INPUT_PTR_ERR";
            break;
        case NULL_KEY_ERR:
            psz =  "NULL_KEY_ERR";
            break;
        case NULL_MEMORY_BASES_ERR:
            psz =  "NULL_MEMORY_BASES_ERR";
            break;
        case NULL_OUTPUT_PTR_ERR:
            psz =  "NULL_OUTPUT_PTR_ERR";
            break;
        case NULL_SFNT_DIR_ERR:
            psz =  "NULL_SFNT_DIR_ERR";
            break;
        case NULL_SFNT_FRAG_PTR_ERR:
            psz =  "NULL_SFNT_FRAG_PTR_ERR";
            break;
        case OUT_OFF_SEQUENCE_CALL_ERR:
            psz =  "OUT_OFF_SEQUENCE_CALL_ERR";
            break;
        case OUT_OF_RANGE_SUBTABLE:
            psz =  "OUT_OF_RANGE_SUBTABLE";
            break;
        case POINTS_DATA_ERR:
            psz =  "POINTS_DATA_ERR";
            break;
        case POINT_MIGRATION_ERR:
            psz =  "POINT_MIGRATION_ERR";
            break;
        case SCAN_ERR:
            psz =  "SCAN_ERR";
            break;
        case SFNT_DATA_ERR:
            psz =  "SFNT_DATA_ERR";
            break;
        case TRASHED_MEM_ERR:
            psz =  "TRASHED_MEM_ERR";
            break;
        case TRASHED_OUTLINE_CACHE:
            psz =  "TRASHED_OUTLINE_CACHE";
            break;
        case UNDEFINED_INSTRUCTION_ERR:
            psz =  "UNDEFINED_INSTRUCTION_ERR";
            break;
        case UNKNOWN_CMAP_FORMAT:
            psz =  "UNKNOWN_CMAP_FORMAT";
            break;
        case UNKNOWN_COMPOSITE_VERSION:
            psz =  "UNKNOWN_COMPOSITE_VERSION";
            break;
        case VOID_FUNC_PTR_BASE_ERR:
            psz =  "VOID_FUNC_PTR_BASE_ERR";
            break;
        case SBIT_COMPONENT_MISSING_ERR:
            psz =  "SBIT_COMPONENT_MISSING_ERR";
            break;
        case TRACE_FAILURE_ERR:
            psz = "Trace_Failure_Error";
            break;
        case DIV_BY_0_IN_HINTING_ERR:
            psz = "DIV_BY_0_IN_HINTING_ERR";
            break;
        case MISSING_ENDF_ERR:
            psz = "MISSING_ENDF_ERR";
            break;
        case MISSING_EIF_ERR:
            psz = "MISSING_EIF_ERR";
            break;
        case INFINITE_RECURSION_ERR:
            psz = "INFINITE_RECURSION_ERR";
            break;
        case INFINITE_LOOP_ERR:
            psz = "INFINITE_LOOP_ERR";
            break;
        case FDEF_IN_GLYPHPGM_ERR:
            psz = "FDEF_IN_GLYPHPGM_ERR";
            break;
        case IDEF_IN_GLYPHPGM_ERR:
            psz = "IDEF_IN_GLYPHPGM_ERR";
            break;
        case JUMP_BEFORE_START_ERR:
            psz = "JUMP_BEFORE_START_ERR";
            break;
        case RAW_NOT_IN_GLYPHPGM_ERR:
            psz = "RAW_NOT_IN_GLYPHPGM_ERR";
            break;	
        case INSTRUCTION_ERR:
            psz = "INSTRUCTION_ERR";
            break;
        case SECURE_STACK_UNDERFLOW:
            psz = "SECURE_STACK_UNDERFLOW";
            break;
        case SECURE_STACK_OVERFLOW:
            psz = "SECURE_STACK_OVERFLOW";
            break;
        case SECURE_POINT_OUT_OF_RANGE:
            psz = "SECURE_POINT_OUT_OF_RANGE";
            break;
        case SECURE_INVALID_STACK_ACCESS:
            psz = "SECURE_INVALID_STACK_ACCESS";
            break;
        case SECURE_FDEF_OUT_OF_RANGE:
            psz = "SECURE_FDEF_OUT_OF_RANGE";
            break;
        case SECURE_ERR_FUNCTION_NOT_DEFINED:
            psz = "SECURE_ERR_FUNCTION_NOT_DEFINED";
            break;
        case SECURE_INVALID_ZONE:
            psz = "SECURE_INVALID_ZONE";
            break;
        case SECURE_INST_OPCODE_TO_LARGE:
            psz = "SECURE_INST_OPCODE_TO_LARGE";
            break;
        case SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP:
            psz = "SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP";
            break;
        case SECURE_STORAGE_OUT_OF_RANGE:
            psz = "SECURE_STORAGE_OUT_OF_RANGE";
            break;
        case SECURE_CONTOUR_OUT_OF_RANGE:
            psz = "SECURE_CONTOUR_OUT_OF_RANGE";
            break;
        case SECURE_CVT_OUT_OF_RANGE:
            psz = "SECURE_CVT_OUT_OF_RANGE";
            break;
        case SECURE_UNITIALIZED_ZONE:
            psz = "SECURE_UNITIALIZED_ZONE";
            break;	
        default:
            psz = "UNKNOWN FONT SCALER ERROR";
                break;
    }
    TtfdDbgPrint ("\n Rasterizer Error: 0x%lx, %s \n", iRet, psz);

}


#endif


/******************************Public*Routine******************************\
*
* fxPtSize
*
* Effects: computes the size in points for this font realization
*
* History:
*  06-Aug-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC LONG fxPtSize(PFONTCONTEXT pfc)
{
// This is done as follows:
//
// Transform
// (0, ui16EmHt) to device (pixel) space.
// Let us say that the vector obtained is (xEm, yEm).
// Then, ptSize should be computed as
// ptSize =  72 * sqrt((xEm/xRes)^2 + (yEm/yRes)^2);

// expanding here a bit we get:
// ptSize =  72 * ui16EmHt * sqrt((mx10/xRes)^2 + (mx11/yRes)^2);

	Fixed x,y;
    LONG  lEmHtX72 = (LONG)(72 * pfc->pff->ffca.ui16EmHt);

    x = LongMulDiv(lEmHtX72,pfc->mx.transform[1][0],pfc->sizLogResPpi.cx);
    y = LongMulDiv(lEmHtX72,pfc->mx.transform[1][1],pfc->sizLogResPpi.cy);
    return iHipot(x,y);
}


//
// this is win31 code intended as a comment for our code:
//

#ifdef THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

      // Find out if a width Table is available
    if (pfnt->ulHdmxPos && !(pfc->fStatus & FD_MORE_THAN_STRETCH) && pfc->Mx11 == pfc->Mx00)
    {
      unsigned    i;
      HDMXHEADER  FAR *pHdmx;
      HDMXTABLE   FAR *pHdmxTable;

      if (pHdmx = (HDMXHEADER  FAR *) SfntReadFragment (pfc->fgi.clientID, pfnt->ulHdmxPos, pfnt->uHdmxSize))
      {
        if (pHdmx->Version == 0)
        {
          pHdmxTable = pHdmx->HdmxTable;

            // Init the the glyph count
          pfc->cHdmxRecord = (unsigned) SWAPL (pHdmx->cbSizeRecord);

           // look through the table if the size is available
          for (i = 0; i < (unsigned) SWAPW (pHdmx->cbRecord); i++, pHdmxTable = (HDMXTABLE FAR *)((char FAR *) pHdmxTable + pfc->cHdmxRecord))
            if (pfc->Mx11 == (int) pHdmxTable->ucEmY)
            {
              pfc->ulHdmxPosTable = pfnt->ulHdmxPos + (i * pfc->cHdmxRecord + sizeof (HDMXHEADER));
              break;
            }
        }
        ReleaseSFNT (pHdmx);
      }
    }

#endif // THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc)
{
    HDMXHEADER  *phdr = (HDMXHEADER  *)(
        (pfc->ptp->ateOpt[IT_OPT_HDMX].dp)                                   ?
        ((BYTE *)pfc->pff->pvView + pfc->ptp->ateOpt[IT_OPT_HDMX].dp) :
        NULL
        );

    UINT         cRecords;
    ULONG        cjRecord;

    HDMXTABLE    *phdmx, *phdmxEnd;
    LONG         yEmHt = pfc->lEmHtDev;

// assume failure, no hdmx table can be used:

    pfc->phdmx = NULL;

// first see if hdmx table is there at all:

    if (!phdr || !pfc->ptp->ateOpt[IT_OPT_HDMX].cj)
        return;

// if table is there but not necessary since the whole font scales
// linearly at all sizes, we will ignore it:

    //(phead->flags & SWAP(2))
    //    return;

// if transform is not such as to allow the use of hdmx table, return;

    ASSERTDD(pfc->flXform & (XFORM_HORIZ | XFORM_VERT),
        "vFindHdmxTable, bogus xform\n");

// if this is the version that we do not understand, return

    if (phdr->Version != 0)
        return;

    cRecords = BE_UINT16(&phdr->cRecords);
    cjRecord = (ULONG)SWAPL(phdr->cjRecord);

    ASSERTDD((cjRecord & 3) == 0, "cjRecord\n");

// if yEmHt > 255, can not fit in the byte, so there is no need to
// to search for the hdmx entry:

    if (yEmHt > 255)
        return;

// Finally, find out if there is something useful there.  Note that the
// table is sorted by size, so we can take an early out.

    phdmx = (HDMXTABLE *)(phdr + 1);
    phdmxEnd = (HDMXTABLE *)((PBYTE)phdmx + cRecords * cjRecord);

    for
    (
        ;
        phdmx < phdmxEnd;
        phdmx = (HDMXTABLE *)((PBYTE)phdmx + cjRecord)
    )
    {
        if (((BYTE) yEmHt) <= phdmx->ucEmY)
        {
            if (((BYTE) yEmHt) == phdmx->ucEmY)
                pfc->phdmx = phdmx; // We found it.
            break;
        }
    }
}

/******************************Public*Routine******************************\
*
* bGrabXform
*
*  updates buffers 0 and 4, those that save the state of the transform.
*  also for "buggy" fonts (URW FONTS) some of the transform dependent
*  info (twightlight points) may be stored in the buffer 3, which otherwise would be shareable
*  this is unfortunate, more memory is required
*
*
* History:
*  24-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL
bGrabXform (
    PFONTCONTEXT    pfc,
	USHORT          usOverScale,
    BOOL            bBitmapEmboldening,
    Fixed           subPosX,
    Fixed           subPosY
)
{
    BOOL bOk = TRUE;
    if ((pfc->pff->pfcLast != pfc) || (pfc->overScale != usOverScale) ||
        (pfc->subPosX != subPosX) || (pfc->subPosY != subPosY) ||
        ( (BOOL)(!!(pfc->flFontType & FO_CLEARTYPE_GRID)) != (BOOL)(!!(pfc->pgin->param.newtrans.flSubPixel & SP_SUB_PIXEL))) ||
        ( (BOOL)(!!(pfc->flFontType & FO_COMPATIBLE_WIDTH)) != (BOOL)(!!(pfc->pgin->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH))) ||
        (bBitmapEmboldening != (BOOL)(!!(pfc->flXform & XFORM_BITMAP_SIM_BOLD)) ) )
    {

		/* set the overscale to the current one */
		pfc->overScale = usOverScale;

    // have to refresh the transform, somebody has changed it on us

        if (bOk = bSetXform(pfc, bBitmapEmboldening, subPosX, subPosY))
        {
        // affirm that we are the ones who have set the transform last

            pfc->pff->pfcLast = pfc;
        }
        else // make sure to restore the old current transform
        {
            if (pfc->pff->pfcLast)
            {
            #if DBG
                BOOL bOkXform =
            #endif
                bSetXform(pfc->pff->pfcLast, (pfc->flXform & XFORM_BITMAP_SIM_BOLD),
                    pfc->pff->pfcLast->subPosX, pfc->pff->pfcLast->subPosY);
                ASSERTDD(bOkXform, "bOkXform\n");
            }
        }

    }
    return (bOk);
}

/******************************Public*Routine******************************\
* vSetGrayState__FONTCONTEXT                                               *
*                                                                          *
* This routine set the FO_GRAYSCALE bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
* then, later on, we shall make calls to the fs_FindGraySize and           *
* fs_ContourGrayScan pair instead of the usual monochrome pair of          *
* calls, fs_FindBitmapSize and fs_ContourScan.                             *
*                                                                          *
* The only effect that this routine could have is to clear                 *
* the FO_GRAYSCALE flags in pfc->flFontType and pfc->pfo->flFontType.         *
*                                                                          *
* The only way in which this clearing could occur is if all of the         *
* following conditions are met: 1) the caller has not set the              *
* FO_NO_CHOICE bit; 2) the font has a 'gasp' table; 3) the 'gasp'          *
* table indicates that for the requested number of pixels per em           *
* the 'gasp' table indicates that the font should not be grayed; 4)        *
* the glyphs of the font are not acted upon by a simple scaling            *
* transformation.                                                          *
*                                                                          *
* On Entry                                                                 *
*                                                                          *
*   pfc->flFontType & FO_GRAYSCALE      != 0                                  *
*   pfc->pfo->flFontType & FO_GRAYSCALE != 0                                  *
*                                                                          *
* Procedure                                                                *
*                                                                          *
*   1. if the force bit is on then go to 6.                                *
*   2. if the transformation is not axial then go to 6.                    *
*   3. if the font does not gave a 'gasp' table then go to 6.              *
*   4. if the gasp table says that this size is ok for graying then        *
*      go to 6.                                                            *
*   5. clear the FO_GRAYSCALE flags in both places                            *
*   6. return                                                              *
*                                                                          *
* History:                                                                 *
*  Fri 10-Feb-1995 14:02:51 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *this)
{
    #if DBG
        void vPrintGASPTABLE(GASPTABLE*);
    #endif

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'gasp' table
    GASPTABLE *pgasp;           // pointer to the 'gasp' table
    GASPRANGE *pgr, *pgrOut;

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;
    if (this->flFontType & FO_GRAYSCALE)
    {
        if (this->flFontType & FO_SUBPIXEL_4)
            return;

        this->flFontType &= ~(FO_GRAYSCALE);
        if (this->flFontType & FO_NO_CHOICE)
        {
            this->flFontType |= FO_GRAYSCALE;
        }
        else
        {
            if (!(dp = (ptrdiff_t) (this->ptp->ateOpt[IT_OPT_GASP].dp)))
            {
                USHORT fs;

                // Win95 lifts the default GASP tables from the registry
                // We should have the same behavior. Bug #11755

                #define US2BE(x)     ((((x) >> 8) | ((x) << 8)) & 0xFFFF)
                static CONST USHORT gaspDefaultRegular[] = {
                    US2BE(0)    // version
                  , US2BE(3)    // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(17)        , US2BE(GASP_GRIDFIT)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT gaspDefaultBold[] = {
                    US2BE(0)     // version
                  , US2BE(2)     // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT *gaspDefaultItalic = gaspDefaultRegular;

                fs = this->pff->ifi.fsSelection;
                if (fs & FM_SEL_ITALIC)
                {
                    pgasp = (GASPTABLE*) gaspDefaultItalic;
                }
                else if (fs & FM_SEL_BOLD)
                {
                    pgasp = (GASPTABLE*) gaspDefaultBold;
                }
                else
                {
                    pgasp = (GASPTABLE*) gaspDefaultRegular;
                }
            }
            else
            {
                pgasp = (GASPTABLE*) (((BYTE *)(this->pff->pvView)) + dp);
            }

            if (this->lEmHtDev > USHRT_MAX)
            {
                //WARNING("vSetGrayScale: lEmHtDev > USHRT_MAX\n");
            }
            else
            {
                size_t cRanges;
                int iLow, iHt, iHigh;

                // Search the gasp table for the instructions
                // for this particular em height. I have assumed that there
                // are not too many GASP tables (typically 3 or less) so
                // I use a linear search.

                pgr     = pgasp->gaspRange;
                cRanges = BE_UINT16(&(pgasp->numRanges));
                if (cRanges > 8)
                {
                    //WARNING("Unusual GASPTABLE : cRanges > 8\n");
                    cRanges = 8;
                }
                pgrOut = pgr + cRanges;
                iLow = -1;
                iHt  = this->lEmHtDev;
                for ( ; pgr < pgrOut; pgr++)
                {
                    iHigh = (int) BE_UINT16(&(pgr->rangeMaxPPEM));
                    if (iLow < iHt && iHt <= iHigh)
                    {
                        if (GASP_DOGRAY & BE_UINT16(&(pgr->rangeGaspBehavior)))
                        {
                            this->flFontType |= FO_GRAYSCALE;
                        }
                        break;
                    }
                    iLow = iHigh;
                }
            }
        }

        if (!(this->flFontType & FO_GRAYSCALE))
        {
            this->flFontType |= FO_NOGRAY16;
            this->pfo->flFontType = this->flFontType;
        }
    }

}

/******************************Public*Routine******************************\
* vSetClearTypeState__FONTCONTEXT                                          *
*                                                                          *
* This routine set the FO_GRAYSCALE bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
*                                                                          *
* History:                                                                 *
*  15-Nov-1999 by Claude Betrisey [claudebe]                               *
* Wrote it.                                                                *
\**************************************************************************/
/**********************************************************************/

/*  Find a strike that matches ppem in the bloc table, simplified from scaler\sfntaccs.c */

static
BOOL fd_FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpem)
{
	uint32 ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	uint32 ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

    uint16 usNumberBitmaps = 0;
    /* we want to turn off ClearType only if font has a significant number of embedded bitmaps, e.g. >100 */

	while (ulNumStrikes > 0)
	{
		if ((usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
	        uint32 ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
	        uint32 ulIndexArrayTop  = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
	        uint32 ulIndexArrayOffset = ulIndexArrayTop;

	        while (ulNumIndexTables > 0)
            {
		        uint16 usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
		        uint16 usLastGlyph  = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
                usNumberBitmaps += (usLastGlyph - usFirstGlyph + 1);
                if (usNumberBitmaps > 100)
                    return TRUE;

		        ulNumIndexTables--;    
		        ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
            }
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	return FALSE;                                   /* match not found */
}

VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *this)
{

    /* we want to turn off ClearType only if font has a significant number of embedded bitmaps, e.g. >100 */

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'EBLC' table
    uint8 *pEBLC;           // pointer to the 'EBLC' table

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;

    if ((this->flXform & (XFORM_HORIZ | XFORM_VERT)) && 
        ((this->mx.transform[0][0] == this->mx.transform[1][1]) || (this->mx.transform[0][0] == -this->mx.transform[1][1]) ) &&
        ((this->mx.transform[0][1] == this->mx.transform[1][0]) || (this->mx.transform[0][1] == -this->mx.transform[1][0])) )
    {
        /* we only want to look for embedded bitmap if we are in a square transformation that is a multiple of 90 degree rotation */
        /* we want to turn off ClearType only if font has a significant number of embedded bitmaps, e.g. >100 */
        if ((dp = (ptrdiff_t)(this->ptp->ateOpt[IT_OPT_EBLC].dp)))
        {
            pEBLC = (uint8*) (((BYTE *)(this->pff->pvView)) + dp);

		    if (fd_FindBlocStrike (pEBLC, (uint16)this->lEmHtDev))
		    {
	            this->flFontType &= ~(FO_GRAYSCALE | FO_CLEARTYPE_GRID);
	            this->flFontType |= FO_NOCLEARTYPE;
	            this->pfo->flFontType = this->flFontType;
	        }
        }
    }

    // we want to disable ClearType for the Marlett font
    if (!UnicodeStringCompareCI((PWSTR)((BYTE*)&this->pff->ifi + this->pff->ifi.dpwszFamilyName),L"Marlett"))
    {
	        this->flFontType &= ~(FO_GRAYSCALE | FO_CLEARTYPE_GRID);
	        this->flFontType |= FO_NOCLEARTYPE;
	        this->pfo->flFontType = this->flFontType;
    }

}

#if DBG
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGASPTABLE                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps a GASPTABLE to the debug screen                                  *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgasp   --  pointer to a big endian GASPTABLE                          *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGASPTABLE(GASPTABLE *pgasp)
{
    GASPRANGE *pgr, *pgrOut;

    TtfdDbgPrint(
        "\n"
        "-------------------------------------\n"
        "GASPTABLE HEADER\n"
        "-------------------------------------\n"
        "pgasp     = %-#x\n"
        "version   = %d\n"
        "numRanges = %d\n"
        "-------------------------------------\n"
        "    rangeMaxPPEM    rangeGaspBehavior\n"
        "-------------------------------------\n"
       , pgasp
       , BE_UINT16(&(pgasp->version))
       , BE_UINT16(&(pgasp->numRanges))
    );
    pgr     = pgasp->gaspRange;
    pgrOut  = pgr + BE_UINT16(&(pgasp->numRanges));
    for (pgr = pgasp->gaspRange; pgr < pgrOut; pgr++)
    {
        char *psz;
        USHORT us = BE_UINT16(&(pgr->rangeGaspBehavior));
        us &= (GASP_GRIDFIT | GASP_DOGRAY);
        switch (us)
        {
        case 0:
            psz = "";
            break;
        case GASP_GRIDFIT:
            psz = "GASP_GRIDFIT";
            break;
        case GASP_DOGRAY:
            psz = "GASP_DOGRAY";
            break;
        case GASP_GRIDFIT | GASP_DOGRAY:
            psz = "GASP_GRIDFIT | GASP_DOGRAY";
            break;
        }
        TtfdDbgPrint(
            "    %12d    %s\n"
          , BE_UINT16(&(pgr->rangeMaxPPEM))
          , psz
        );
    }
    TtfdDbgPrint(
        "-------------------------------------\n\n\n"
    );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fd_poly.c ===
/******************************Module*Header*******************************\
* Module Name: fd_poly.c
*
* stolen from win31 tt code
*
* Created: 10-Feb-1992 17:10:39
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/

#include "fd.h"
#include "winerror.h"

STATIC VOID vQsplineToPolyBezier (
    ULONG      cBez,          // IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   // IN  starting point on the first curve
    POINTFIX * pptfixSpline,  // IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      // OUT buffer to be filled with 3 * cBez poly bezier control points
    );


BOOL bGeneratePath (
    PVOID           * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN     pointer to the buffer with outline data
    ULONG             cj,         // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    );

#if DBG

// #define DBG_POLYGON

#endif

VOID vFillSingularGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,GLYPHDATA*);
VOID vFillGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,fs_GlyphInfoType*,GLYPHDATA*,GMC*);
BOOL bGetGlyphMetrics(FONTCONTEXT*,HGLYPH,FLONG,FS_ENTRY*);

/******************************Public*Routine******************************\
*
* void Scale_16DOT16
*
*
* Effects: 26.6 -> 16.16
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* stole it from jeanp and modified for nt
\**************************************************************************/

//!!! some checks should be put in so as to verify that 26.6 -> 16.16
//!!! conversion can be done without loosing information [bodind]

void Scale_16DOT16 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

#ifdef  DBG_POLYGON

    xLsb2Org;
    yLsb2Org;

    lTmp = (LONG)x;
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG)y;
    ppfx->y = * (FIXED *) &lTmp;

#else // true version

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "_Scale 16.16 \n");

    lTmp = (LONG) ((x - xLsb2Org) << 10);
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG) ((y - yLsb2Org) << 10);
    ppfx->y = * (FIXED *) &lTmp;

#endif //  DBG_POLYGON
}


/******************************Public*Routine******************************\
*
* void Scale_28Dot4
*
*
* Effects: 26.6 -> 28.4
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* wrote it
\**************************************************************************/

void Scale_28DOT4 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "Scale, 28.4\n");

    lTmp = (LONG) ((x - xLsb2Org) >> 2);
    ppfx->x = * (FIXED *) &lTmp;

// note that the sign of y coordinate differs from the 16.16 case

    lTmp = - (LONG) ((y - yLsb2Org) >> 2);
    ppfx->y = * (FIXED *) &lTmp;
}


/******************************Public*Routine******************************\
*
* Scale_None
*
* Called when only the size of the ppoly buffer is wanted
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void Scale_None (POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
  ppfx;
  x;
  y;
  xLsb2Org;
  yLsb2Org;

  return;
}


/******************************Public*Routine******************************\
*
* cjFillPolygon
*
* Effects: fills in the array of structures that describe glyph's
*          outline. There is one polygonheader stuct for every closed contour
*          that composes the glyph. A polygon headed structure is followed
*          by an array of polycurve structure that describe composite curves
*          of a closed contour.
*
* Note: if pBuffer is NULL or cb is 0, then it is assumed that the caller
*       only wants the size of the buffer required.
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it. (stole it from JeanP's win31 code and addapted for NT)
\**************************************************************************/

UINT cjFillPolygon(
    PFONTCONTEXT pfc,
    BOOL         b16Dot16,  // FORMAT of the points, 16.16 or 28.4
    PBYTE        pBuffer,
    UINT         cb
    )
{
  BOOL            bGetLength = ( (pBuffer == (PBYTE)NULL) || (cb == 0) );
  uint16          nc = pfc->pgout->numberOfContours;
  uint8           *pbOnCurve = pfc->pgout->onCurve;
  uint8           *pbFc = pfc->pgout->fc;
  int16           *sp = pfc->pgout->startPtr;
  int16           *ep = pfc->pgout->endPtr;
  F26Dot6         *x = pfc->pgout->xPtr;
  F26Dot6         *y = pfc->pgout->yPtr;
  BYTE            *pBuf = pBuffer;
  BYTE            *pStart = pBuf;
  BYTE            *pEnd = pStart + (bGetLength ? -1 : cb);
  TTPOLYGONHEADER *pPoly;
  TTPOLYCURVE     *pCurve;
  POINTFX         *ppfxStart;
  POINTFX         *pptfx;

  uint16      iContour;   //  index into a contour
  int16       iptEnd, cpt;
  int16       ipt = 0; // follows the points on the contour

  uint8        ucMask;
  void        (*Scale)(POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xlsb, int ylsb);

  int       xLsb2Org;
  int       yLsb2Org;

  if (!pfc->pgout->outlinesExist)
    return 0;

  if (!bGetLength) // we are actually filling in the information
  {

    if (b16Dot16)
    {
      Scale = Scale_16DOT16;
    }
    else  // scale to 28.4 format
    {
      Scale = Scale_28DOT4;
    }
  }
  else // just computing the size of the buffer needed to store the information
  {
    Scale = Scale_None;
  }

// Compute the delta between the referencial origin and dev left bearing

  cpt = (int16)(ep[nc - 1] + 1);  // total number of points in a contour

  xLsb2Org = x [cpt];  // LEFTSIDEBEARING == 0
  yLsb2Org = y [cpt];  // LEFTSIDEBEARING == 0

  for (iContour = 0; iContour < nc; iContour++)
  {
     // make sure that ipt points to the firts point on a contour upon entry
     // to the loop

    ipt    = sp [iContour];
    iptEnd = ep [iContour];

      // skip contour made of one point
    if (ipt == iptEnd)
    {
      continue; // go to the starting point of the next contour,
    }

    if (!bGetLength)
    {
      pPoly = (TTPOLYGONHEADER *) pBuf; //!!! dangerous, alignment [bodind]
      pPoly->dwType = TT_POLYGON_TYPE;
      ppfxStart = &pPoly->pfxStart;

    #ifdef  DBG_POLYGON
      TtfdDbgPrint("Begin Polygon\n\n");
    #endif //  DBG_POLYGON
    }

    pBuf += sizeof (TTPOLYGONHEADER);

    if (pbFc[iContour] & OUTLINE_MISORIENTED)
    {
	    // we need to change the orientation of the contour
        x = &pfc->pgout->xPtr[iptEnd];
        y = &pfc->pgout->yPtr[iptEnd];

          // The last point on the curve
        if (pbOnCurve[iptEnd] & 1)
        {
            //Easy case
          (*Scale) (ppfxStart, *x--, *y--, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          --iptEnd;
        }
        else
        {
            // Is first contour point on the curve
          if (pbOnCurve[ipt] & 1)
          {
              //Make the first point the last point and decrement the first point
            (*Scale) (ppfxStart, x[ipt - iptEnd], y[ipt - iptEnd], xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          }
          else
          {
              //last and first point are off the countour, fake a mid point
            (*Scale) (ppfxStart, (x[ipt - iptEnd] + *x) >> 1, (y[ipt - iptEnd] + *y) >> 1, xLsb2Org, yLsb2Org);
          }
        }

        while (ipt <= iptEnd)
        {
          pCurve = (TTPOLYCURVE *) pBuf;
          pptfx = pCurve->apfx;
          ucMask = (int8) (1 & (~pbOnCurve[iptEnd]));
          if (!bGetLength)
          {
              // if mid point not on the curve this is qspline, this is midpoint
              // because the starting point is in the previous record [bodind]
            pCurve->wType = (WORD)((ucMask == 0) ? TT_PRIM_LINE : TT_PRIM_QSPLINE);
          }
            // Set up the POLYCURVE
          while ((ipt <= iptEnd) && ((pbOnCurve[iptEnd] & 1) ^ ucMask))
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

            (*Scale) (pptfx++, *x--, *y--, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
            iptEnd --;
          }

          if (ucMask == 1) // if this curve is a qspline
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

             // Set up the end point
            if (ipt <= iptEnd)
            {
              ASSERTDD(pbOnCurve[iptEnd] & 1, " end point not on the curve\n");
              (*Scale) (pptfx, *x--, *y--, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
              iptEnd--;
            }
            else
            {
               // close the contour
              if (!bGetLength)
                 *pptfx = *ppfxStart;
            }
            pptfx++;
          }
          if (!bGetLength)
          {
            pCurve->cpfx = (WORD)(pptfx - pCurve->apfx);
          }

          pBuf = (BYTE *) pptfx;
        }
    } 
    else
    {
        x = &pfc->pgout->xPtr[ipt];
        y = &pfc->pgout->yPtr[ipt];

          // The first point on the curve
        if (pbOnCurve[ipt] & 1)
        {
            //Easy case
          (*Scale) (ppfxStart, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          ++ipt;
        }
        else
        {
            // Is last contour point on the curve
          if (pbOnCurve[iptEnd] & 1)
          {
              //Make the last point the first point and decrement the last point
            (*Scale) (ppfxStart, x[iptEnd - ipt], y[iptEnd - ipt], xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          }
          else
          {
              //First and last point are off the countour, fake a mid point
            (*Scale) (ppfxStart, (x[iptEnd - ipt] + *x) >> 1, (y[iptEnd - ipt] + *y) >> 1, xLsb2Org, yLsb2Org);
          }
        }

        while (ipt <= iptEnd)
        {
          pCurve = (TTPOLYCURVE *) pBuf;
          pptfx = pCurve->apfx;
          ucMask = (int8) (1 & (~pbOnCurve[ipt]));
          if (!bGetLength)
          {
              // if mid point not on the curve this is qspline, this is midpoint
              // because the starting point is in the previous record [bodind]
            pCurve->wType = (WORD)((ucMask == 0) ? TT_PRIM_LINE : TT_PRIM_QSPLINE);
          }
            // Set up the POLYCURVE
          while ((ipt <= iptEnd) && ((pbOnCurve[ipt] & 1) ^ ucMask))
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

            (*Scale) (pptfx++, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
            ipt++;
          }

          if (ucMask == 1) // if this curve is a qspline
          {
              // Check overflow
            if (pEnd < (BYTE *)(pptfx + 1))
              return FD_ERROR;

             // Set up the end point
            if (ipt <= iptEnd)
            {
              ASSERTDD(pbOnCurve[ipt] & 1, " end point not on the curve\n");
              (*Scale) (pptfx, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
              ipt++;
            }
            else
            {
               // close the contour
              if (!bGetLength)
                 *pptfx = *ppfxStart;
            }
            pptfx++;
          }
          if (!bGetLength)
          {
            pCurve->cpfx = (WORD)(pptfx - pCurve->apfx);
          }

          pBuf = (BYTE *) pptfx;
        }
    }
    if (!bGetLength)
    {
      pPoly->cb = (DWORD) (pBuf - (BYTE *) pPoly);
      #ifdef DBG_POLYGON
        TtfdDbgPrint("\n end polygon, pPoly->cb = %ld\n\n", pPoly->cb);
      #endif // DBG_POLYGON
    }
  }
  #ifdef  DBG_POLYGON
    if (!bGetLength)
        TtfdDbgPrint("\n END NEW GLYPH \n\n");
  #endif //  DBG_POLYGON

  return (UINT) (pBuf - pStart);
}


/******************************Public*Routine******************************\
*
* lQuerySingularTrueTypeOutline
*
* Effects:
*
* Warnings:
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




LONG lQuerySingularTrueTypeOutline(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *   pgldt,         // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph

// hglyph is valid, either asking about the size for that particular
// glyph bitmap, or want the bitmap itself

    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

// compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        RET_FALSE("TTFD!_lQuerySingularTrueTypeOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        vFillSingularGLYPHDATA(hglyph,ig,pfc,pgldt);
    }

// now check whether the caller is asking about the size of the buffer
// needed to store the array of POLYGONHEADER structures:

    return 0; // nothing written to the ppoly buffer
}


/******************************Public*Routine******************************\
*
* LONG lQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryTTOutline(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    BOOL         bUnhinted,      //     unhinted
    GLYPHDATA *   pgldt,          // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    FS_ENTRY     iRet;
    LONG         cjRet;
    ULONG        ig = pfc->gstat.igLast;

// check if the rasterizer would behave unpolitely for this xform:

    if (pfc->flXform & XFORM_SINGULAR)
        return lQuerySingularTrueTypeOutline(
                    pfc,
                    b16Dot16,
                    hglyph,
                    bMetricsOnly,
                    pgldt,
                    cjBuf,
                    ppoly);

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if ((pfc->gstat.hgLast != hglyph) || bUnhinted)
    {
        extern BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH,ULONG*,FLONG,FS_ENTRY*);

        FLONG flOutline = bUnhinted ? FL_FORCE_UNHINTED : 0;

        // DO NOT skip grid fitting even if embedded bitmpas are found,
        // for we will be interested in outlines -+
        //                                        |
        //                                        |
        if ( !bGetGlyphOutline(pfc, hglyph , &ig, flOutline, &iRet) )
        {
            V_FSERROR(iRet);
            RETURN("lQueryTTOutline: bGetGlyphOutline failed\n", FD_ERROR);
        }

        // in order to be compatible with older applications we must
        // call the monochrome version we do not call fs_FindGraySize
        // even if the FONTOBJ suggests that it be anti-aliased

        if ((iRet = fs_FindBitMapSize(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            RETURN("lQueryTTOutline: fs_FindBitMapSize failed\n", FD_ERROR);
        }

        // now that everything is computed sucessfully, we can update
        // glyphstate (hg data stored in pj3) and return

        if (!bUnhinted)
        {
            pfc->gstat.hgLast = hglyph;
            pfc->gstat.igLast = ig;
        }
        else
        {
            vInitGlyphState(&pfc->gstat);
        }
    }

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

    if (!(bMetricsOnly & TTO_METRICS_ONLY))
    {
        if ((cjRet = cjFillPolygon(pfc, b16Dot16, (PBYTE)ppoly, cjBuf)) == FD_ERROR)
            RETURN("TTFD!_cjFillPolygon failed\n", FD_ERROR);
    }
    else // nothing will be written to ppoly buffer
    {
        cjRet = 0;
    }

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        // Normal case
        vFillGLYPHDATA(
                hglyph,
                ig,
                pfc,
                pfc->pgout,
                pgldt,
                (PGMC)NULL);
    }

// now check whether the caller is asking about the size of the buffer
// needed to store the array of POLYGONHEADER structures:

    return cjRet;
}


/******************************Public*Routine******************************\
*
* LONG ttfdQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryQuadTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // IN  glyph for which info is wanted
    BOOL       bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // OUT this is where the metrics should be returned
    ULONG      cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly    // IN OUT  output buffer
    )
{
    FONTCONTEXT *pfc;
	USHORT usOverScale;
    BOOL     bUnhinted = (bMetricsOnly & TTO_UNHINTED) ? TRUE : FALSE;

    bMetricsOnly = (bMetricsOnly & ~TTO_UNHINTED);

    ASSERTDD(pfo->iFile, "ttfdQueryTrueTypeOutline, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        //WARNING("ttfd, ttfdQueryTrueTypeOutline: file is gone\n");
        return FD_ERROR;
    }
//
// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        //WARNING("gdisrv!ttfdQueryTrueTypeOutline(): cannot create font context\n");
        return FD_ERROR;
    }
    pfc->pfo = pfo;

// call fs_NewTransformation if needed:

// ClaudeBe 1/22/98 :
//
// for backwards compatibility, we always return the BW version of the outline
// (TrueType rasterizer 1.7 allow specific grayscale hinting)
//
// the code could be :
//
//	if (IS_GRAY(pfc))
//	{
//		usOverScale = 4;
//	}
//	else
//	{
//		usOverScale = 0;
//	}
//
// but then we would need to copy the outline from gout, before calling fs_FindBitmapSize
// to avoid getting an overscaled outline

	usOverScale = 0;

/* outline code path, no bitmap emboldening simulation */
    if (!bGrabXform(pfc, usOverScale, FALSE, 0, 0))
        RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);

       return  lQueryTTOutline(pfc,
                               TRUE, // b16Dot16 is true, this is the desired
                                     // format
                               hglyph,
                               bMetricsOnly, bUnhinted,
                               pgldt,
                               cjBuf,
                               ppoly);
}




/******************************Public*Routine******************************\
*
* ttfdQueryGlyphOutline
*
*
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL ttfdQueryGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgldt,
    PVOID       *ppo        // pointer to path to be built
    )
{
    LONG             cjAllPolygons, cjAllPolygons2;
    BOOL             bOk;

    if (ppo == NULL)
    {
    // if ppo == NULL, the caller wants metrics only:

        ASSERTDD(pgldt, "ttfdQueryGlyphOutline, pgldt NULL\n");

        cjAllPolygons =
              lQueryTTOutline
                (
                 pfc,              // lpMat2 is incorporated into this fc
                 FALSE,            // NOT 16.16 i.e. 28.4
                 hglyph,           // glyph for which info is wanted
                 TTO_METRICS_ONLY, // DO just metrics, do NOT do outline
                 FALSE,            // hinted
                 pgldt,            // STORE the result here
                 0,                // size in bytes of the ppoly buffer
                 (TTPOLYGONHEADER *)NULL // do not need it
                 );

    // interpret the result, if zero for polygons, we succeded
    // glyph data was filled in and no polygon computation has been
    // performed.
    // if FD_ERROR we did not, no other result should be possible

        if (cjAllPolygons == 0)
            return TRUE;
        else
        {
            ASSERTDD(cjAllPolygons == FD_ERROR,
                     "ttfdQueryGlyphOutline, pgldt == NULL\n");
            return FALSE;
        }

    }

// first learn how big a buffer we need for all polygons:

    cjAllPolygons = lQueryTTOutline
          (
           pfc,              // lpMat2 is incorporated into this fc
           FALSE,            // NOT 16.16 i.e. 28.4
           hglyph,           // glyph for which info is wanted
           FALSE,            //  DO more than just metrics
           FALSE,            // hinted
           (GLYPHDATA *)NULL,// do not need glyphdata
           0,                // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)NULL
           );
    if (cjAllPolygons == FD_ERROR)
        RET_FALSE("TTFD! cjAllPolygons\n");

    if (cjAllPolygons != 0)
    {
        if ((pfc->gstat.pv = PV_ALLOC(cjAllPolygons)) == NULL)
        {
            RET_FALSE("TTFD_cjAllPolygons or ppoly\n");
        }
    }
    else
    {
        pfc->gstat.pv = NULL;
    }

// get all the polygons in the buffer we just allocated:

    cjAllPolygons2 = lQueryTTOutline
          (
           pfc,            // lpMat2 is incorporated into this fc
           FALSE,          // NOT 16.16 i.e. 28.4
           hglyph,         // glyph for which info is wanted
           FALSE,          //  DO more than just metrics
           FALSE,            // hinted
           pgldt,          // this is where the metrics should be returned
           cjAllPolygons,  // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)pfc->gstat.pv
           );

    if (cjAllPolygons2 == FD_ERROR)
    {
        if (pfc->gstat.pv)
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
        RET_FALSE("TTFD_ QueryTrueTypeOutline failed\n");
    }

    ASSERTDD(cjAllPolygons == cjAllPolygons2,
              "cjAllPolygons PROBLEM\n");

// now that we have all the info in ppoly buffer we can generate the path

    bOk = bGeneratePath(
            ppo,
            (TTPOLYGONHEADER *)pfc->gstat.pv,
            cjAllPolygons, NULL, NULL
            );

    if (pfc->gstat.pv)
    {
        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return (bOk);
}


/******************************Public*Routine******************************\
*
* bGeneratePath
*
* Effects: Adds control points of the glyph to the gluph path
*
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// macro that computes the size of the polycurve record:

#define CJ_CRV(pcrv)                                            \
(                                                               \
    offsetof(TTPOLYCURVE,apfx) + (pcrv)->cpfx * sizeof(POINTFX) \
)

#define CJ_BEZCRV(cBezPts)                                       \
(                                                                \
    offsetof(TTPOLYCURVE,apfx) + (cBezPts) * sizeof(POINTFX)     \
)


// reasonable guess that in most cases a contour will not consist of more
// than this many beziers

#define C_BEZIER 6


BOOL bGeneratePath(
    PVOID           * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN OUT pointer to the buffer with outline data
    ULONG             cjTotal,    // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    )
{
    TTPOLYGONHEADER * ppoly, * ppolyEnd, *ppolyBez;
    TTPOLYCURVE     * pcrv, * pcrvEnd, *pcrvBez;
    POINTFIX          aptfixBez[3 * C_BEZIER];  // 3 points per bezier
    POINTFIX        * pptfixBez;
    ULONG             cBez;
    POINTFIX        * pptfixStart;
    ULONG             cjPolyBez = 0;
    ULONG             cjCrv, cjCrvBez;

    if (pcjOut)
        *pcjOut = 0; // to begin with

    // The code is no problem with NULL.
    ppolyBez = NULL;
    
    if (ppolyBeziers)
        ppolyBez = ppolyBeziers;

    for (
         ppoly = ppolyStart, ppolyEnd = (TTPOLYGONHEADER *)((PBYTE)ppolyStart + cjTotal);
         ppoly < ppolyEnd;
         ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb),
         ppolyBez = (TTPOLYGONHEADER *)((PBYTE)ppolyBez + cjPolyBez)
        )
    {
        ASSERTDD(ppoly->dwType == TT_POLYGON_TYPE, "TT_POLYGON_TYPE\n");

    // begin new closed contour

        if (ppo && !PATHOBJ_bMoveTo(ppo, *(POINTFIX *)&ppoly->pfxStart))
            RET_FALSE("TTFD!_PATHOBJ_bMoveTo failed\n");

    // init a loop over curves


        pptfixStart = (POINTFIX *)&ppoly->pfxStart;
        pcrvEnd = (TTPOLYCURVE *)((PBYTE)ppoly + ppoly->cb);

        for (
             pcrv = (TTPOLYCURVE *)(ppoly + 1),
             pcrvBez = (TTPOLYCURVE *)(ppolyBez + 1),
             cjPolyBez = sizeof(TTPOLYGONHEADER);
             pcrv < pcrvEnd;
             pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + cjCrv),
             pcrvBez = (TTPOLYCURVE *)((PBYTE)pcrvBez + cjCrvBez),
             cjPolyBez += cjCrvBez
            )
        {
        // must compute the size of this curve first

            cjCrv = CJ_CRV(pcrv);

            if (pcrv->wType == TT_PRIM_LINE)
            {
                if (ppo && !PATHOBJ_bPolyLineTo(ppo,(POINTFIX *)pcrv->apfx, pcrv->cpfx))
                    RET_FALSE("TTFD!_bPolyLineTo()\n");

                cjCrvBez = cjCrv;

            // in the case of poly lines, we just copy the data out

                if (ppolyBeziers)
                    RtlCopyMemory(pcrvBez, pcrv, cjCrv);
            }
            else // qspline
            {
                BOOL bOk;
                ULONG cBezPts;

                ASSERTDD(pcrv->wType == TT_PRIM_QSPLINE, "TT_PRIM_QSPLINE\n");
                ASSERTDD(pcrv->cpfx > 1, "_TT_PRIM_QSPLINE, cpfx <= 1\n");
                cBez = pcrv->cpfx - 1;
                cBezPts = 3 * cBez;

                if (cBez > C_BEZIER) // must allocate buffer for the bezier points
                {
                    if ((pptfixBez = (POINTFIX *)PV_ALLOC(cBezPts * sizeof(POINTFIX))) == (POINTFIX *)NULL)
                    {
                        return (FALSE);
                    }
                }
                else // enough memory on the stack
                {
                    pptfixBez = aptfixBez;
                }

                vQsplineToPolyBezier (
                    cBez,                     // count of curves to convert to beziers format
                    pptfixStart,              // starting point on the first curve
                    (POINTFIX *)pcrv->apfx,   // array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
                    pptfixBez);               // buffer to be filled with 3 * cBez poly bezier control points

                bOk = !ppo || PATHOBJ_bPolyBezierTo(ppo, pptfixBez, cBezPts);

            // compute the size of the corresponding bezier curve

                cjCrvBez = CJ_BEZCRV(cBezPts);

            // may need to fill bezier data out

                if (ppolyBeziers)
                {
                    pcrvBez->wType = TT_PRIM_CSPLINE;
                    pcrvBez->cpfx  = (WORD) cBezPts;
                    RtlCopyMemory(pcrvBez->apfx, pptfixBez,
                                  cBezPts * sizeof(POINTFIX));
                }

            // free mem if needed

                if (cBez > C_BEZIER)
                    V_FREE(pptfixBez);

                if (!bOk)
                    RET_FALSE("TTFD!_bPolyBezierTo() failed\n");
            }

        // get to the next curve in this polygon

            pptfixStart = (POINTFIX *) &pcrv->apfx[pcrv->cpfx - 1];
        }
        ASSERTDD(pcrv == pcrvEnd, "pcrv problem\n");

    // close the path

        if (ppo && !PATHOBJ_bCloseFigure(ppo))
            RET_FALSE("TTFD!_bPolyLineTo()\n");

    // add the size of the bezier polygon to the total bezier buffer size

        if (pcjOut)
            *pcjOut += cjPolyBez;

    // write polygon header to the out buffer

        if (ppolyBeziers)
        {
            ppolyBez->dwType = TT_POLYGON_TYPE;
            ppolyBez->cb = cjPolyBez;
            ppolyBez->pfxStart = ppoly->pfxStart;
        }
    }                                             // loop over polygons

    ASSERTDD(ppoly == ppolyEnd, "poly problem\n");
    return (TRUE);
}


/******************************Public*Routine******************************\
*
*    vQsplineToPolyBezier
*
* Effects:
*
* Warnings:
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define DIV_BY_2(x) (((x) + 0x00000001) / 2)
#define DIV_BY_3(x) (((x) + 0x00000002) / 3)

STATIC VOID vQsplineToPolyBezier(
    ULONG      cBez,          //IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   //IN  starting point on the first curve
    POINTFIX * pptfixSpline,  //IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      //OUT buffer to be filled with 3 * cBez poly bezier control points
    )
{
    ULONG    iBez,cMidBez;
    POINTFIX ptfixA;

// cMidBez == # of beziers for whom the last point on the bezier is computed
// as a mid point of the two consecutive points in the input array. Only the
// last bezier is not a mid bezier, the last point for that bezier is equal
// to the last point in the input array

    ASSERTDD(cBez > 0, "cBez == 0\n");

    cMidBez = cBez - 1;
    ptfixA = *pptfixStart;

    for (iBez = 0; iBez < cMidBez; iBez++, pptfixSpline++)
    {
    // let us call the three spline points
    // A,B,C;
    // B = *pptfix;
    // C = (pptfix[0] + pptfix[1]) / 2; // mid point, unless at the end
    //
    // if we decide to call the two intermediate control points for the
    // bezier M,N (i.e. full set of control points for the bezier is
    // A,M,N,C), the points M,N are determined by following formulas:
    //
    // M = (2*B + A) / 3  ; two thirds along the segment AB
    // N = (2*B + C) / 3  ; two thirds along the segment CB
    //
    // this is the computation we are doing in this loop:

    // M point for this bezier

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // compute C point for this bezier, which is also the A point for the next
    // bezier

        ptfixA.x = DIV_BY_2(pptfixSpline[0].x + pptfixSpline[1].x);
        ptfixA.y = DIV_BY_2(pptfixSpline[0].y + pptfixSpline[1].y);

    // now compute N point for this bezier:

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // finally record the C point for this curve

        *pptfixBez++ = ptfixA;
    }

// finally do the last bezier. If the last bezier is the only one, the loop
// above has been skipped

// M point for this bezier

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// compute C point for this bezier, its end point is the last point
// in the input array

    ptfixA = pptfixSpline[1];

// now compute N point for this bezier:

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// finally record the C point for this curve, no need to increment pptfixBez

    *pptfixBez = ptfixA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fdfon.c ===
/******************************Module*Header*******************************\
* Module Name: fdfon.c
*
* basic file claim/load/unload font file functions
*
* Created: 08-Nov-1991 10:09:24
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/
#include "fd.h"
#include <stdlib.h>
#include <winerror.h>

BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff
    );

STATIC
ULONG CopyDBCSIFIName(
    CHAR *AnsiName,
    ULONG BufferLength,
    LPCSTR OriginalName,
    ULONG OriginalLength)
{
    ULONG AnsiLength = 0;

    for( ;OriginalLength; OriginalLength-=2 )
    {
        if (OriginalName[0])
        {
            if( BufferLength >= (AnsiLength+2) )
            {
                *AnsiName++ = OriginalName[0];
                *AnsiName++ = OriginalName[1];
                AnsiLength += 2;
            }
            else
            {
                break;
            }
        }
        else
        {
            if( BufferLength >= (AnsiLength+1) )
            {
                *AnsiName++ = OriginalName[1];
                AnsiLength++;
            }
            else
            {
                break;
            }
        }
        OriginalName += 2;
    }

    return (AnsiLength);
}

STATIC UINT GetCodePageFromSpecId( uint16 ui16SpecId )
{
    USHORT AnsiCodePage, OemCodePage;
    UINT iCodePage;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

    iCodePage = AnsiCodePage;

    switch( ui16SpecId )
    {
        case BE_SPEC_ID_SHIFTJIS :
            iCodePage = 932;
            break;

        case BE_SPEC_ID_GB :
            iCodePage = 936;
            break;

        case BE_SPEC_ID_BIG5 :
            iCodePage = 950;
            break;

        case BE_SPEC_ID_WANSUNG :
            iCodePage = 949;
            break;

        default :
            //WARNING("TTFD!:Unknown SPECIFIC ID\n");
            break;
    }

    return( iCodePage );
}


STATIC uint16 ui16BeLangId(ULONG ulPlatId, ULONG ulLangId)
{
    ulLangId = CV_LANG_ID(ulPlatId,ulLangId);
    return BE_UINT16(&ulLangId);
}


STATIC FSHORT  fsSelectionTTFD(BYTE *pjView, TABLE_POINTERS *ptp)
{
    PBYTE pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                  pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                  NULL                                ;

    sfnt_FontHeader * phead = (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

//
// fsSelection
//
    ASSERTDD(TT_SEL_ITALIC     == FM_SEL_ITALIC     , "ITALIC     \n");
    ASSERTDD(TT_SEL_UNDERSCORE == FM_SEL_UNDERSCORE , "UNDERSCORE \n");
    ASSERTDD(TT_SEL_NEGATIVE   == FM_SEL_NEGATIVE   , "NEGATIVE   \n");
    ASSERTDD(TT_SEL_OUTLINED   == FM_SEL_OUTLINED   , "OUTLINED   \n");
    ASSERTDD(TT_SEL_STRIKEOUT  == FM_SEL_STRIKEOUT  , "STRIKEOUT  \n");
    ASSERTDD(TT_SEL_BOLD       == FM_SEL_BOLD       , "BOLD       \n");

    if (pjOS2)
    {
        return((FSHORT)BE_UINT16(pjOS2 + OFF_OS2_usSelection));
    }
    else
    {
    #define  BE_MSTYLE_BOLD       0x0100
    #define  BE_MSTYLE_ITALIC     0x0200

        FSHORT fsSelection = 0;

        if (phead->macStyle & BE_MSTYLE_BOLD)
            fsSelection |= FM_SEL_BOLD;
        if (phead->macStyle & BE_MSTYLE_ITALIC)
            fsSelection |= FM_SEL_ITALIC;

        return fsSelection;
    }
}



STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz
);

STATIC BOOL  bCheckLocaTable
(
int16	indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16 	numGlyphs
);

STATIC BOOL  bCheckHdmxTable
(
sfnt_hdmx      *phdmx,
ULONG 			size
);

STATIC BOOL bCvtUnToMac(BYTE *pjView, TABLE_POINTERS *ptp, uint16 ui16PlatformID);

STATIC BOOL  bVerifyTTF
(
ULONG_PTR           iFile,
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
ULONG               ulLangId,
PTABLE_POINTERS     ptp,
PIFISIZE            pifisz,
uint16             *pui16PlatID,
uint16             *pui16SpecID,
sfnt_mappingTable **ppmap,
ULONG              *pulGsetType,
ULONG              *pul_wcBias
);

STATIC BOOL  bGetTablePointers
(
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
PTABLE_POINTERS  ptp
);

STATIC BOOL bComputeIDs
(
BYTE                     * pjView,
TABLE_POINTERS           * ptp,
uint16                   * pui16PlatID,
uint16                   * pui16SpecID,
sfnt_mappingTable       ** ppmap
);


STATIC VOID vFill_IFIMETRICS
(
PFONTFILE       pff,
GP_PIFIMETRICS     pifi,
PIFISIZE        pifisz,
fs_GlyphInputType     *pgin
);

BYTE jIFIMetricsToGdiFamily (GP_PIFIMETRICS pifi);


BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    )
{
    ULONG i;
    BOOL  bRet = TRUE;
    #if DBG
    ULONG ulTrueTypeResource = PTTC(hff)->ulTrueTypeResource;
    #endif

    // free hff for this ttc file.

    for( i = 0; i < PTTC(hff)->ulNumEntry; i++ )
    {
        if(PTTC(hff)->ahffEntry[i].iFace == 1)
        {
            if( !ttfdUnloadFontFile(PTTC(hff)->ahffEntry[i].hff) )
            {
                //WARNING("TTFD!ttfdUnloadFontFileTTC(): ttfdUnloadFontFile fail\n");
                bRet = FALSE;
            }

            #if DBG
            ulTrueTypeResource--;
            #endif
        }
    }


    // finally free the memory for the ttc itself

    vFreeTTC(PTTC(hff));

    ASSERTDD(ulTrueTypeResource == 0L,
              "TTFD!ttfdUnloadFontFileTTC(): ulTrueTypeResource != 0\n");

    return(bRet);
}

/******************************Public*Routine******************************\
*
* ttfdUnloadFontFile
*
*
* Effects: done with using this tt font file. Release all system resources
* associated with this font file
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdUnloadFontFile (
    HFF hff
    )
{
    if (hff == HFF_INVALID)
        return(FALSE);

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTDD(PFF(hff)->cRef == 0L, "ttfdUnloadFontFile: cRef\n");

// no need to unmap the file at this point
// it has been unmapped when cRef went down to zero

// assert that pff->pkp does not point to the allocated mem

// free the internal structure for the TrueType rasterizer

	if (PFF(hff)->pj034)
		V_FREE(PFF(hff)->pj034);

// free the pfc

	if (PFF(hff)->pfcToBeFreed)
		V_FREE(PFF(hff)->pfcToBeFreed);

// free vertical ifimetrics and the vertical glyphset that are allocated of the same chunk

    if (PFF(hff)->pifi_vertical)
        V_FREE(PFF(hff)->pifi_vertical);

// free memory associated with this FONTFILE object

    vFreeFF(hff);
    return(TRUE);
}

/******************************Public*Routine******************************\
*
* BOOL bVerifyTTF
*
*
* Effects: verifies that a ttf file contains consistent tt information
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyTTF (
    ULONG_PTR           iFile,
    PVOID               pvView,
    ULONG               cjView,
    PBYTE               pjOffsetTable,
    ULONG               ulLangId,
    PTABLE_POINTERS     ptp,
    PIFISIZE            pifisz,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap,
    ULONG              *pulGsetType,
    ULONG              *pul_wcBias
    )
{
    // extern BOOL bCheckSumOK( void *pvView, ULONG cjView, sfnt_FontHeader *phead );
    sfnt_FontHeader      *phead;

    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    sfnt_maxProfileTable   *pmaxp;
    sfnt_hdmx			   *phdmx;	
    ULONG  cHMTX;

// if attempted a bm *.fon file this will fail, so do not print
// warning, but if passes this, and then fails, something is wrong

    if (!bGetTablePointers(pvView,cjView,pjOffsetTable,ptp))
    {
        return( FALSE );
    }

    phead = (sfnt_FontHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HMTX].dp);
    pmaxp = (sfnt_maxProfileTable *)((BYTE *)pvView + ptp->ateReq[IT_REQ_MAXP].dp);
    phdmx = ptp->ateOpt[IT_OPT_HDMX].dp ? 
    	(sfnt_hdmx *)((BYTE *)pvView + ptp->ateOpt[IT_OPT_HDMX].dp) : NULL;

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);

    if (sizeof(sfnt_HorizontalMetrics) * cHMTX > ptp->ateReq[IT_REQ_HMTX].cj)
    {
        return FALSE;
    }

    /*
    if ( !bCheckSumOK( pvView, cjView, phead ))
    {
        RET_FALSE("TTFD!_bVerifyTTF, possible file corruption, checksums did not match\n");
    }
    */

#define SFNT_MAGIC   0x5F0F3CF5
    if (BE_UINT32((BYTE*)phead + SFNT_FONTHEADER_MAGICNUMBER) != SFNT_MAGIC)
        RET_FALSE("TTFD: bVerifyTTF: SFNT_MAGIC \n");

    if (!bComputeIDs(pvView,
                     ptp,
                     pui16PlatID,
                     pui16SpecID,
                     ppmap)
        )
        RET_FALSE("TTFD!_bVerifyTTF, bComputeIDs failed\n");


    if (!bComputeIFISIZE (
                    pvView,
                    ptp,
                    *pui16PlatID,
                    *pui16SpecID,
                    ui16BeLangId(*pui16PlatID,ulLangId),
                    pifisz)             // return results here
        )
        {
            RET_FALSE("TTFD!_bVerifyTTF, bComputeIFISIZE failed\n");
        }

    if (!bCheckLocaTable (
    				SWAPW(phead->indexToLocFormat),
    				pvView,
    				ptp,
    				(uint16) SWAPW(pmaxp->numGlyphs) )
    	)
        {
            RET_FALSE("TTFD!_bVerifyTTF, bCheckLocaTable failed\n");
        }

    if (phdmx && !bCheckHdmxTable (
    				phdmx,
    				ptp->ateOpt[IT_OPT_HDMX].cj )
    	)
        {
            RET_FALSE("TTFD!_bVerifyTTF, bCheckHdmxTable failed\n");
        }

// all checks passed

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bCheckSumOK
*
* Routine Description:
*
*   Check file for corruption by calculationg check sum
*   and comparing it against value in file.
*
*   Ref: TrueType 1.0 Font Files: Technical Specification,
*        Revision 1.64 beta, December 1994, p. 65,
*        'head' - Font Header".
*
* Arguments:
*
*   pvView              pointer to view of TrueType file
*
*   cjView              size of view in byte's
*
*   phead               pointer to sfnt_FontHeader table in view of
*                       TrueType file
*
* Return Value:
*
*   TRUE if check sum's match, FALSE if they don't
*
\**************************************************************************/
/*
BOOL bCheckSumOK( void *pvView, ULONG cjView, sfnt_FontHeader *phead )
{
    extern ULONG ttfdCheckSum( ULONG*, ULONG );
    ULONG ul, *pul, ulView;

    pul  = (ULONG*) ( (BYTE*) phead + SFNT_FONTHEADER_CHECKSUMADJUSTMENT );
                                    // pul now points to the
                                    // checkSumAdjustment field in the
                                    // 'head' table of the font file.
    if ( (ULONG) pul & 3 )          // Check that pul is DWORD aligned
    {
        RET_FALSE("bCheckSumOK: checkSumAdjustment is not DWORD aligned\n");
    }
    ul   = *pul;                    // Big endian representation
    *pul = 0;                       // required to calculate checksum
    ulView = ttfdCheckSum( (ULONG*) pvView, cjView );   // little endian value
    *pul = ul;                      // restore view
    ulView = 0xb1b0afba - ulView;   // magic subtraction as per spec
    ulView = BE_UINT32( &ulView );  // convert to big endian representation
    return( ul == ulView );         // compare with big endian number in file
}
*/
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ttfdCheckSum
*
* Routine Description:
*
*   Calculates check sum's of memory blocks according to TrueType
*   conventions.
*
*   Ref: TrueType 1.0 Font Files: Technical Specification,
*        Revision 1.64 beta, December 1994, p. 34, The Table
*        Directory
*
* Arguments:
*
*   pul                 pointer to DWORD aligned start of memory block
*
*   cj                  size of memory block in bytes. It is assumed
*                       that access of the last DWORD is allowed
*                       even if cj is not a multiple of 4.
*
* Return Value:
*
*   Little Endian representation of CheckSum.
*
\**************************************************************************/
/*
ULONG ttfdCheckSum( ULONG *pul, ULONG cj )
{
    ULONG *pulEnd, ul, Sum;
    pulEnd = (ULONG*) ((BYTE*) pul + ((cj + 3) & ~3) );
    for ( Sum = 0; pul < pulEnd; pul++)
    {
        ul = *pul;                  // ul is big endian
        Sum += BE_UINT32( &ul );    // do little endian sum
    }
    return( Sum );  // return little endian result
}
*/
/******************************Public*Routine******************************\
*
* PBYTE pjGetPointer(LONG clientID, LONG dp, LONG cjData)
*
* this function is required by scaler. It is very simple
* Returns a pointer to the position in a ttf file which is at
* offset dp from the top of the file:
*
* Effects:
*
* Warnings:
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! clientID should be uint32, just a set of bits
//!!! I hate to have this function defined like this [bodind]

voidPtr   FS_CALLBACK_PROTO
pvGetPointerCallback(
    ULONG_PTR clientID,
    long     dp,
    long     cjData
    )
{
    cjData;

// clientID is FONTFILE structure...

    if(dp)
    {
        if ((dp > 0) && (cjData >= 0) && (dp + cjData <= (long)PFF(clientID)->cjView))
        {
            return(voidPtr)((PBYTE)(PFF(clientID)->pvView) + dp);
        }
        else
        {
            return NULL;
        }
    }
     else
        return(voidPtr)((PBYTE)(PFF(clientID)->pvView) +
                               (PFF(clientID)->ffca.ulTableOffset));
}


/******************************Public*Routine******************************\
*
* void vReleasePointer(voidPtr pv)
*
*
* required by scaler, the type of this function is ReleaseSFNTFunc
*
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void FS_CALLBACK_PROTO
vReleasePointerCallback(
    voidPtr pv
    )
{
    pv;
}


/******************************Public*Routine******************************\
*
* PBYTE pjTable
*
* Given a table tag, get a pointer and a size for the table
*
* History:
*  11-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable)
{
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;

// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *) ((PBYTE) (pff->pvView) + pff->ffca.ulTableOffset);

    cTables = (INT) SWAPW(pofft->numOffsets);

// do linear search, this is usually small list and it is NOT always
// ordered by the tag as ttf spec says it should be.

    pdireEnd = &pofft->table[cTables];

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {

        if (ulTag == pdire->tag)
        {
            ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
            ULONG ulLength = (ULONG)SWAPL(pdire->length);

        // check if the ends of all tables are within the scope of the
        // tt file. If this is is not the case trying to access the field in the
        // table may result in an access violation, as is the case with the
        // spurious FONT.TTF that had the beginning of the cmap table below the
        // end of file, which was resulting in the system crash reported by beta
        // testers. [bodind]

            if
            (
             !ulLength ||
             ((ulOffset + ulLength) > pff->cjView)
            )
            {
                RETURN("TTFD: pjTable: table offset/length \n", NULL);
            }
            else // we found it
            {
                *pcjTable = ulLength;
                return ((PBYTE)(pff->pvView) + ulOffset);
            }
        }
    }

// if we are here, we did not find it.

    return NULL;
}

/******************************Public*Routine******************************\
*
* bGetTablePointers - cache the pointers to all the tt tables in a tt file
*
* IF a table is not present in the file, the corresponding pointer is
* set to NULL
*
*
* //   tag_CharToIndexMap              // 'cmap'    0
* //   tag_GlyphData                   // 'glyf'    1
* //   tag_FontHeader                  // 'head'    2
* //   tag_HoriHeader                  // 'hhea'    3
* //   tag_HorizontalMetrics           // 'hmtx'    4
* //   tag_IndexToLoc                  // 'loca'    5
* //   tag_MaxProfile                  // 'maxp'    6
* //   tag_NamingTable                 // 'name'    7
* //   tag_Postscript                  // 'post'    9
* //   tag_OS_2                        // 'OS/2'    10
*
* // optional
*
* //   tag_ControlValue                // 'cvt '    11
* //   tag_FontProgram                 // 'fpgm'    12
* //   tag_HoriDeviceMetrics           // 'hdmx'    13
* //   tag_Kerning                     // 'kern'    14
* //   tag_LSTH                        // 'LTSH'    15
* //   tag_PreProgram                  // 'prep'    16
* //   tag_GlyphDirectory              // 'gdir'    17
* //   tag_Editor0                     // 'edt0'    18
* //   tag_Editor1                     // 'edt1'    19
* //   tag_Encryption                  // 'cryp'    20
*
*
* returns false if all of required pointers are not present
*
* History:
*  05-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bGetTablePointers (
    PVOID            pvView,
    ULONG            cjView,
    PBYTE            pjOffsetTable,
    PTABLE_POINTERS  ptp
    )
{
    INT                 iTable;
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;
    ULONG                ulTag;
    BOOL                 bRequiredTable;

// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *)pjOffsetTable;

// check version number, if wrong exit before doing
// anything else. This line rejects bm FON files
// if they are attempted to be loaed as TTF files
// Version #'s are in big endian.

#define BE_VER1     0x00000100
#define BE_VER2     0x00000200

    if ((pofft->version != BE_VER1) && (pofft->version !=  BE_VER2))
        return (FALSE); // *.fon files fail this check, make this an early out

// clean up the pointers

    RtlZeroMemory((VOID *)ptp, sizeof(TABLE_POINTERS));

    cTables = (INT) SWAPW(pofft->numOffsets);
    ASSERTDD(cTables <= MAX_TABLES, "cTables\n");

    pdireEnd = &pofft->table[cTables];

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {
        ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
        ULONG ulLength = (ULONG)SWAPL(pdire->length);

        ulTag = (ULONG)SWAPL(pdire->tag);

    // check if the ends of all tables are within the scope of the
    // tt file. If this is is not the case trying to access the field in the
    // table may result in an access violation, as is the case with the
    // spurious FONT.TTF that had the beginning of the cmap table below the
    // end of file, which was resulting in the system crash reported by beta
    // testers. [bodind]

        if ((ulOffset + ulLength) > cjView)
            RET_FALSE("TTFD: bGetTablePointers : table offset/length \n");

        if (bGetTagIndex(ulTag, &iTable, &bRequiredTable))
        {
            if (bRequiredTable)
            {
                ptp->ateReq[iTable].dp = ulOffset;
                ptp->ateReq[iTable].cj = ulLength;
            }
            else // optional table
            {
                ptp->ateOpt[iTable].dp = ulOffset;
                ptp->ateOpt[iTable].cj = ulLength;

            // here we are fixing a possible bug in in the tt file.
            // In lucida sans font they claim that pj != 0 with cj == 0 for
            // vdmx table. Attempting to use this vdmx table was
            // resulting in an access violation in bSearchVdmxTable

                if (ptp->ateOpt[iTable].cj == 0)
                    ptp->ateOpt[iTable].dp = 0;
            }
        }

    }

// now check that all required tables are present

    for (iTable = 0; iTable < C_REQ_TABLES; iTable++)
    {
        if ((ptp->ateReq[iTable].dp == 0) || (ptp->ateReq[iTable].cj == 0))
            RET_FALSE("TTFD!_required table absent\n");
    }

    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bGetTagIndex
*
* Determines whether the table is required or optional, assiciates the index
* into TABLE_POINTERS  with the tag
*
* returns FALSE if ulTag is not one of the recognized tags
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bGetTagIndex (
    ULONG  ulTag,      // tag
    INT   *piTable,    // index into a table
    BOOL  *pbRequired  // requred or optional table
    )
{
    *pbRequired = FALSE;  // default set for optional tables, change the
                          // value if required table

    switch (ulTag)
    {
    // reqired tables:

    case tag_CharToIndexMap:
        *piTable = IT_REQ_CMAP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_GlyphData:
        *piTable = IT_REQ_GLYPH;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_FontHeader:
        *piTable = IT_REQ_HEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HoriHeader:
        *piTable = IT_REQ_HHEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HorizontalMetrics:
        *piTable = IT_REQ_HMTX;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_IndexToLoc:
        *piTable = IT_REQ_LOCA;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_MaxProfile:
        *piTable = IT_REQ_MAXP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_NamingTable:
        *piTable = IT_REQ_NAME;
        *pbRequired = TRUE;
        return (TRUE);

// optional tables

    case tag_OS_2:
        *piTable = IT_OPT_OS2;
        return (TRUE);
    case tag_HoriDeviceMetrics:
        *piTable = IT_OPT_HDMX;
        return (TRUE);
    case tag_Vdmx:
        *piTable = IT_OPT_VDMX;
        return (TRUE);
    case tag_Kerning:
        *piTable = IT_OPT_KERN;
        return (TRUE);
    case tag_LinearThreshold:
        *piTable = IT_OPT_LSTH;
        return (TRUE);
    case tag_Postscript:
        *piTable = IT_OPT_POST;
        return (TRUE);
    case tag_GridfitAndScanProc:
        *piTable = IT_OPT_GASP;
        return (TRUE);
    case tag_mort:
        *piTable = IT_OPT_MORT;
        return (TRUE);
    case tag_GSUB:
        *piTable = IT_OPT_GSUB;
        return (TRUE);
    case tag_VerticalMetrics:
        *piTable = IT_OPT_VMTX;
        return(TRUE);
    case tag_VertHeader:
        *piTable = IT_OPT_VHEA;
        return(TRUE);
    case tag_BitmapLocation:
        *piTable = IT_OPT_EBLC;
        return (TRUE);
    default:
        return (FALSE);
    }
}


/******************************Public*Routine******************************\
*
* STATIC BOOL  bComputeIFISIZE
*
* Effects:
*
* Warnings:
*
* History:
*  10-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// this function is particularly likely to break on MIPS, since
// NamingTable structure is three SHORTS so that

#define BE_NAME_ID_COPYRIGHT   0x0000
#define BE_NAME_ID_FAMILY      0x0100
#define BE_NAME_ID_SUBFAMILY   0x0200
#define BE_NAME_ID_UNIQNAME    0x0300
#define BE_NAME_ID_FULLNAME    0x0400
#define BE_NAME_ID_VERSION     0x0500
#define BE_NAME_ID_PSCRIPT     0x0600
#define BE_NAME_ID_TRADEMARK   0x0700

ULONG ConvertLangIDtoCodePage(uint16 uiLangID)
{
    uint16  uiCodePage;

    uiCodePage = 0;

    switch(uiLangID)
    {
        case 0x0404:   // Taiwan
        case 0x040c:   // Hongkong
        case 0x0414:   // mckou
            uiCodePage = 950; // CHINESEBIG5_CHARSET
            break;
        case 0x0408:    // PRC
        case 0x0410:    // Singapore
            uiCodePage = 936; // GB2312_CHARSET
            break;
        default:
            break;
    }

    return uiCodePage;
}

STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz
)
{

    sfnt_OS2 * pOS2;
    sfnt_NamingTable *pname = (sfnt_NamingTable *)(pjView + ptp->ateReq[IT_REQ_NAME].dp);
    BYTE  *pjStorage;

    sfnt_NameRecord * pnrecInit, *pnrec, *pnrecEnd;

    BOOL    bMatchLangId, bFoundAllNames;
    INT     iNameLoop;

    USHORT  AnsiCodePage, OemCodePage;


// pointers to name records for the four strings we are interested in:

    sfnt_NameRecord * pnrecFamily    = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecSubFamily = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecUnique    = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecFull      = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecVersion   = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecFamilyAlias = (sfnt_NameRecord *)NULL;

// get out if this is not one of the platID's we know what to do with

    if ((ui16PlatID != BE_PLAT_ID_MS) && (ui16PlatID != BE_PLAT_ID_MAC))
        RET_FALSE("ttfd!_ do not know how to handle this plat id\n");

// first clean the output structure:

    RtlZeroMemory((PVOID)pifisz, sizeof(IFISIZE));

// first name record is layed just below the naming table

    pnrecInit = (sfnt_NameRecord *)((PBYTE)pname + SIZE_NAMING_TABLE);
    pnrecEnd = &pnrecInit[BE_UINT16(&pname->count)];

// in the first iteration of the loop we want to match lang id to our
// favorite lang id. If we find all 4 strings in that language we are
// done. If we do not find all 4 string with matching lang id we will try to
// language only, but not sublanguage. For instance if Canadian French
// is requested, but the file only contains "French" French names, we will
// return the names in French French. If that does not work either
// we shall go over name records again and try to find
// the strings in English. If that does not work either we
// shall resort to total desperation and just pick any language.
// therefore we may go up to 4 times through the NAME_LOOP

    bFoundAllNames = FALSE;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

// find the name record with the desired ID's
// NAME_LOOP:

    for (iNameLoop = 0; (iNameLoop < 4) && !bFoundAllNames; iNameLoop++)
    {
        for
        (
          pnrec = pnrecInit;
          (pnrec < pnrecEnd) && !(bFoundAllNames && (pnrecVersion != NULL));
          pnrec++
        )
        {
            switch (iNameLoop)
            {
            case 0:
            // match BOTH language and sublanguage

                bMatchLangId = (pnrec->languageID == ui16LangID);
                break;

            case 1:
            // match language but not sublanguage
            // except if we are dealing with LANG_CHINESE then we need to see
            // the font code page is same as system defaul or not

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                }
                break;

            case 2:
            // try to find english names if desired language is not available

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                }
                break;

            case 3:
            // do not care to match language at all, just give us something

                bMatchLangId = TRUE;
                break;

            default:
                //RIP("ttfd! must not have more than 3 loop iterations\n");
                break;
            }

            if
            (
                (pnrec->platformID == ui16PlatID) &&
                (pnrec->specificID == ui16SpecID) &&
                bMatchLangId
            )
            {
                switch (pnrec->nameID)
                {
                case BE_NAME_ID_FAMILY:

                    if (!pnrecFamily) // if we did not find it before
                        pnrecFamily = pnrec;
                    break;

                case BE_NAME_ID_SUBFAMILY:

                    if (!pnrecSubFamily) // if we did not find it before
                        pnrecSubFamily = pnrec;
                    break;

                case BE_NAME_ID_UNIQNAME:

                    if (!pnrecUnique) // if we did not find it before
                        pnrecUnique = pnrec;
                    break;

                case BE_NAME_ID_FULLNAME:

                    if (!pnrecFull)    // if we did not find it before
                        pnrecFull = pnrec;
                    break;

                case BE_NAME_ID_VERSION  :

                    if (!pnrecVersion)    // if we did not find it before
                        pnrecVersion = pnrec;
                    break;

                case BE_NAME_ID_COPYRIGHT:
                case BE_NAME_ID_PSCRIPT  :
                case BE_NAME_ID_TRADEMARK:
                    break;

                default:
                    //RIP("ttfd!bogus name ID\n");
                    break;
                }

            }

            bFoundAllNames = (
                (pnrecFamily    != NULL)    &&
                (pnrecSubFamily != NULL)    &&
                (pnrecUnique    != NULL)    &&
                (pnrecFull      != NULL)
                );
        }


    } // end of iNameLoop

    if (!bFoundAllNames)
    {
    // we have gone through the all 3 iterations of the NAME loop
    // and still have not found all the names. We have singled out
    // pnrecVersion because it is not required for the font to be
    // loaded, we only need it to check if this a ttf converted from t1

        RETURN("ttfd!can not find all name strings in a file\n", FALSE);
    }

// let us check if there  is a family alias, usually only exists in
// FE tt fonts, where there might be a western and fe family name.

    for (pnrec = pnrecInit; pnrec < pnrecEnd; pnrec++)
    {
      if ((pnrec->platformID == ui16PlatID)   &&
           (pnrec->specificID == ui16SpecID)  &&
           (pnrec->nameID == BE_NAME_ID_FAMILY) &&
          (pnrecFamily != pnrec)
       )
            {
              pnrecFamilyAlias = pnrec;
              break;
            }
    }

// get the pointer to the beginning of the storage area for strings

    pjStorage = (PBYTE)pname + BE_UINT16(&pname->stringOffset);

    pifisz->aliasLangID = 0;

    if (ui16PlatID == BE_PLAT_ID_MS)
    {
    // offsets in the records are relative to the beginning of the storage

        pifisz->cjFamilyName = BE_UINT16(&pnrecFamily->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjFamilyName = pjStorage +
                               BE_UINT16(&pnrecFamily->offset);

        pifisz->langID = pnrecFamily->languageID;

        if(pnrecFamilyAlias)
        {
            pifisz->cjFamilyNameAlias = BE_UINT16(&pnrecFamilyAlias->length) +
                                                sizeof(WCHAR);
            pifisz->pjFamilyNameAlias = pjStorage + BE_UINT16(&pnrecFamilyAlias->offset);
            pifisz->aliasLangID = pnrecFamilyAlias->languageID;
        }
        else
        {
            pifisz->cjFamilyNameAlias = 0;
            pifisz->pjFamilyNameAlias = NULL;
        }

        pifisz->cjSubfamilyName = BE_UINT16(&pnrecSubFamily->length) +
                                  sizeof(WCHAR); // for terminating zero
        pifisz->pjSubfamilyName = pjStorage +
                                  BE_UINT16(&pnrecSubFamily->offset);

        pifisz->cjUniqueName = BE_UINT16(&pnrecUnique->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjUniqueName = pjStorage +
                               BE_UINT16(&pnrecUnique->offset);

        pifisz->cjFullName = BE_UINT16(&pnrecFull->length) +
                             sizeof(WCHAR); // for terminating zero
        pifisz->pjFullName = pjStorage +
                             BE_UINT16(&pnrecFull->offset);
    }
    else  // mac id
    {
    // offsets in the records are relative to the beginning of the storage

        pifisz->cjFamilyName = sizeof(WCHAR) * BE_UINT16(&pnrecFamily->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjFamilyName = pjStorage +
                               BE_UINT16(&pnrecFamily->offset);

    // In MAC case, we do not need to handle the FamilyNameAlias

        pifisz->cjFamilyNameAlias = 0;
        pifisz->pjFamilyNameAlias = NULL;

        pifisz->cjSubfamilyName = sizeof(WCHAR) * BE_UINT16(&pnrecSubFamily->length) +
                                  sizeof(WCHAR); // for terminating zero
        pifisz->pjSubfamilyName = pjStorage +
                                  BE_UINT16(&pnrecSubFamily->offset);

        pifisz->cjUniqueName = sizeof(WCHAR) * BE_UINT16(&pnrecUnique->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjUniqueName = pjStorage +
                               BE_UINT16(&pnrecUnique->offset);

        pifisz->cjFullName = sizeof(WCHAR) * BE_UINT16(&pnrecFull->length) +
                             sizeof(WCHAR); // for terminating zero
        pifisz->pjFullName = pjStorage +
                             BE_UINT16(&pnrecFull->offset);
    }


// lay the strings below the ifimetrics

    pifisz->cjIFI = sizeof(GP_IFIMETRICS)      +
                    pifisz->cjFamilyName        +
                    pifisz->cjFamilyNameAlias   +
                    pifisz->cjSubfamilyName     +
                    pifisz->cjUniqueName        +
                    pifisz->cjFullName          ;

    pifisz->cjIFI = DWORD_ALIGN(pifisz->cjIFI);

// we may need to add a '@' to facename and family name in case this
// font has a vertical face name

    pifisz->cjIFI += sizeof(WCHAR) * 2;
    if (pifisz->cjFamilyNameAlias)
    {
    // one WCHAR for @, the other one for double terminating zero L\'0'

        pifisz->cjIFI += 2 * sizeof(WCHAR);
    }

    {
        ULONG cSims = 0;

        switch (fsSelectionTTFD(pjView,ptp) & (FM_SEL_BOLD | FM_SEL_ITALIC))
        {
        case 0:
            cSims = 3;
            break;

        case FM_SEL_BOLD:
        case FM_SEL_ITALIC:
            cSims = 1;
            break;

        case (FM_SEL_ITALIC | FM_SEL_BOLD):
            cSims = 0;
            break;

        default:
            //RIP("TTFD!tampering with flags\n");
            break;
        }

        if (cSims)
        {
            pifisz->dpSims = pifisz->cjIFI;
            pifisz->cjIFI += (DWORD_ALIGN(sizeof(FONTSIM)) + cSims * DWORD_ALIGN(sizeof(FONTDIFF)));
        }
        else
        {
            pifisz->dpSims = 0;
        }
    }

    pifisz->cjIFI = NATURAL_ALIGN( pifisz->cjIFI );
    return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckLocaTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-June-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckLocaTable
(
int16	indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16 	numGlyphs
)
{
	int32	i;
	
	if(indexToLocFormat){	//For Long Offsets
		uint32* pLongOffSet;

		pLongOffSet = (uint32 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

		for(i=0; i<numGlyphs; i++)
			if( (uint32)SWAPL(pLongOffSet[i]) > (uint32)SWAPL(pLongOffSet[i+1]) )
				return (FALSE);
	}
	else{	//For Short Offsets
		uint16* pShortOffSet;

		pShortOffSet = (uint16 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

		for(i=0; i<numGlyphs; i++)
			if( (uint16)SWAPW(pShortOffSet[i]) > (uint16)SWAPW(pShortOffSet[i+1]) )
				return (FALSE);
	}

	return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckHdmxTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-Sep-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckHdmxTable
(
	sfnt_hdmx	   *phdmx,
	ULONG 			size
)
{
	return( size >= (ULONG) (SWAPW(phdmx->sNumRecords) * SWAPL(phdmx->lSizeRecord) + 8));
}

/******************************Public*Routine******************************\
*
* STATIC BOOL bComputeIDs
*
* Effects:
*
* Warnings:
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeIDs (
    BYTE              * pjView,
    TABLE_POINTERS     *ptp,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap)
{

    ULONG ul_startCount=0L;

    sfnt_char2IndexDirectory * pcmap =
            (sfnt_char2IndexDirectory *)(pjView + ptp->ateReq[IT_REQ_CMAP].dp);

    sfnt_platformEntry * pplat = &pcmap->platform[0];
    sfnt_platformEntry * pplatEnd = pplat + BE_UINT16(&pcmap->numTables);
    sfnt_platformEntry * pplatMac = (sfnt_platformEntry *)NULL;

	uint32 sizeOfCmap = ptp->ateReq[IT_REQ_CMAP].cj;

    *ppmap = (sfnt_mappingTable  *)NULL;

    if (pcmap->version != 0) // no need to swap bytes, 0 == be 0
        RET_FALSE("TTFD!_bComputeIDs: version number\n");
    if (BE_UINT16(&(pcmap->numTables)) > 30)
    {
        RET_FALSE("Number of cmap tables greater than 30 -- probably a bad font\n");
    }

// find the first sfnt_platformEntry with platformID == PLAT_ID_MS,
// if there was no MS mapping table, go for the mac one
    for (; pplat < pplatEnd; pplat++)
    {
        if (pplat->platformID == BE_PLAT_ID_MS)
        {
            BOOL bRet;
            uint32 offset = (uint32) SWAPL(pplat->offset);
            
            *pui16PlatID = BE_PLAT_ID_MS;
            *pui16SpecID = pplat->specificID;
            if( offset > sizeOfCmap )
            	RET_FALSE("Start position of cmap subtable is out of cmap size -- mustbe bad font\n");

            *ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

            switch((*ppmap)->format)
            {
              case BE_FORMAT_MSFT_UNICODE :

                switch(pplat->specificID)
                {
                  case BE_SPEC_ID_SHIFTJIS :
                  case BE_SPEC_ID_GB :
                  case BE_SPEC_ID_BIG5 :
                  case BE_SPEC_ID_WANSUNG :

                                        bRet = TRUE;
                    break;

                  case BE_SPEC_ID_UGL :
                  default :

                // this will set *pulGsetType to GSET_TYPE_GENERAL

                                        bRet = TRUE;
                    break;
                }
                break;

              case BE_FORMAT_HIGH_BYTE :

                                        bRet = TRUE;
                break;

                default :

                bRet = FALSE;
                break;
            }

            if(!bRet)
            {
                *ppmap = (sfnt_mappingTable  *)NULL;
                RET_FALSE("TTFD!_bComputeIDs: bVerifyMsftTable failed \n");
            }

            // keep specific ID in CMAPINFO

            if (pplat->specificID == BE_SPEC_ID_UNDEFINED)
            {
            // correct the value of the glyph set, we cheat here

                sfnt_OS2 * pOS2 = (sfnt_OS2 *)(
                               (ptp->ateOpt[IT_OPT_OS2].dp)    ?
                               pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                               NULL
                               );

                BOOL bSymbol = FALSE;
                if (pOS2)
                {
                    if (((pOS2->usSelection & 0x00ff) == ANSI_CHARSET) &&
                        (pOS2->Panose[0]==PAN_FAMILY_PICTORIAL)) // means symbol
                        bSymbol = TRUE;
                }

            // this code is put here because of the need to differentiate
            // between msicons2.ttf and bahamn1.ttf.
            // Both of them have Bias = 0, but msicons2 is a symbol font.

            }

            return (TRUE);
        }

        if ((pplat->platformID == BE_PLAT_ID_MAC)  &&
            (pplat->specificID == BE_SPEC_ID_UNDEFINED))
        {
            pplatMac = pplat;
        }
    }

    if (pplatMac != (sfnt_platformEntry *)NULL)
    {
        uint32 offset = (uint32) SWAPL(pplat->offset);
        *pui16PlatID = BE_PLAT_ID_MAC;
        *pui16SpecID = BE_SPEC_ID_UNDEFINED;
        if( offset > sizeOfCmap )
           	RET_FALSE("Offset of cmap subtable is out of cmap size -- mustbe bad font\n");

		*ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

        if( offset + (uint16) SWAPW((*ppmap)->length) > sizeOfCmap )
          	RET_FALSE("End position of cmap subtable is out of cmap size -- mustbe bad font\n");

    //!!! lang issues, what if not roman but thai mac char set ??? [bodind]

    // see if it is necessary to convert unicode to mac code points, or we
    // shall cheat in case of symbol char set for win31 compatiblity

        return(TRUE);
    }
    else
    {
        RET_FALSE("TTFD!_bComputeIDs: unknown platID\n");
    }

}

/******************************Public*Routine******************************\
*
* STATIC BOOL bVerifyMacTable(sfnt_mappingTable * pmap)
*
* just checking consistency of the format
*
* History:
*  23-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyMacTable(
    sfnt_mappingTable * pmap
    )
{
    if (pmap->format != BE_FORMAT_MAC_STANDARD)
        RET_FALSE("TTFD!_bVerifyMacTable, format \n");

// sfnt_mappingTable is followed by <= 256 byte glyphIdArray

    if (BE_UINT16(&pmap->length) > DWORD_ALIGN(SIZEOF_SFNT_MAPPINGTABLE + 256))
        RET_FALSE("TTFD!_bVerifyMacTable, length \n");

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bLoadTTF
*
* Effects:
*
* Warnings:
*
* History:
*  29-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! SHOUD BE RETURNING hff


#define OFF_TTC_Sign           0x0000
#define OFF_TTC_Version        0x0004
#define OFF_TTC_DirectoryCount 0x0008
#define OFF_TTC_DirectoryEntry 0x000C

#define DSIG_LONG_TAG          0x44534947

#define TTC_VERSION_1_0     0x00010000



ULONG GetUlong( PVOID pvView, ULONG ulOffset)
{
    ULONG ulReturn;

    ulReturn = (  (ULONG)*((PBYTE) pvView + ulOffset +3)              |
                (((ULONG)*((PBYTE) pvView + ulOffset +2)) << 8)  |
                (((ULONG)*((PBYTE) pvView + ulOffset +1)) << 16) |
                (((ULONG)*((PBYTE) pvView + ulOffset +0)) << 24)
               );
    return ( ulReturn );
}


BOOL bVerifyTTC (
    PVOID pvView
    )
{
    ULONG ulVersion;
// Check TTC ID.

    #define TTC_ID      0x66637474

    if(*((PULONG)((BYTE*) pvView + OFF_TTC_Sign)) != TTC_ID)
        return(FALSE);

// Check TTC verson.

    ulVersion = SWAPL(*((PULONG)((BYTE*) pvView + OFF_TTC_Version)));

    if (ulVersion < TTC_VERSION_1_0)
        RETURN("TTFD!ttfdLoadFontFileTTC(): wrong TTC version\n", FALSE);

    return(TRUE);
}

VOID vCopy_IFIV ( GP_PIFIMETRICS pifi, GP_PIFIMETRICS pifiv)
{
    PWCHAR pwchSrc, pwchDst;

    RtlCopyMemory(pifiv, pifi, pifi->cjThis);

//
// modify facename so that it has '@' at the beginning of facename.
//
    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFaceName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFaceName);

    *pwchSrc++ = L'@';
    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    // modify familyname so that it has '@' at the beginning of familyname

    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFamilyName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFamilyName);

    *pwchSrc++ = L'@';

    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    if(pifiv->flInfo & FM_INFO_FAMILY_EQUIV)
    {
        pwchSrc++;
        pwchDst++;

        *pwchSrc++ = L'@';

        while ( *pwchDst )
        {
            *pwchSrc++ = *pwchDst++;
        }

        *pwchSrc++ = L'\0';
        *pwchSrc = L'\0';
    }

}

BOOL bLoadFontFile (
    ULONG_PTR   iFile,
    PVOID       pvView,
    ULONG       cjView,
    ULONG       ulLangId,
    HFF   *     phttc
    )
{
    BOOL           bRet = FALSE;

    BOOL           bTTCFormat;
    PTTC_FONTFILE  pttc;
    ULONG          cjttc;
    ULONG          i;

    HFF hff;

    PTTC_CACHE      pCache_TTC;
    PTTF_CACHE      pCache_TTF;
    ULONG           ulSize;

    *phttc = (HFF)NULL; // Important for clean up in case of exception


// How mamy TrueType resources in this file if TTC file.

// Look up the fontcache for IFI metrices

    pCache_TTC = NULL;
    pCache_TTF = NULL;

// Check this is a TrueType collection format or not.
    bTTCFormat = bVerifyTTC(pvView);

    if(bTTCFormat)
    {
        ULONG     ulTrueTypeResource;
        ULONG     ulEntry;
        BOOL      bCanBeLoaded = TRUE;

    // Get Directory count
        ulTrueTypeResource = GetUlong(pvView,OFF_TTC_DirectoryCount);


   // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry);
        cjttc += sizeof(TTC_HFF_ENTRY) * ulTrueTypeResource * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc == (HFF)NULL)
            RETURN("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n", FALSE);


    // fill hff array in TTC_FONTFILE struture

        ulEntry = 0;

        for(i = 0; i < ulTrueTypeResource; i++ )
        {
            ULONG    ulOffset;


            pCache_TTF = NULL;
            ulOffset = GetUlong(pvView,(OFF_TTC_DirectoryEntry + (4 * i)));

        // load font..

            pttc->ahffEntry[ulEntry].iFace = 1; // start from 1.
            pttc->ahffEntry[ulEntry].ulOffsetTable = ulOffset;

            if (bLoadTTF(iFile,pvView,cjView,ulOffset,ulLangId,
                            &pttc->ahffEntry[ulEntry].hff))
            {
                hff = pttc->ahffEntry[ulEntry].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[ulEntry + 1].hff    = hff;
                    pttc->ahffEntry[ulEntry + 1].iFace  = 1; // start from 1.
                    pttc->ahffEntry[ulEntry + 1].ulOffsetTable = ulOffset;
                }

                ulEntry += PFF(hff)->ffca.ulNumFaces;
            }
            else
            {
                bCanBeLoaded = FALSE;
                break;
            }
        }

    // Is there a font that could be loaded ?

        if(bCanBeLoaded)
        {
            ASSERTDD(
                (ulTrueTypeResource * 2) >= ulEntry,
                "TTFD!ulTrueTypeResource * 2 < ulEntry\n"
                );

            pttc->ulTrueTypeResource = ulTrueTypeResource;
            pttc->ulNumEntry         = ulEntry;
            pttc->cRef               = 0;
            pttc->fl                 = 0;

            bRet = TRUE;
        }
        else
        {
            for (i = 0; i < ulEntry; i++)
            {
                if(pttc->ahffEntry[i].iFace == 1)
                    ttfdUnloadFontFile(pttc->ahffEntry[i].hff);
            }

            //WARNING("TTFD!No TrueType resource in this TTC file\n");
            vFreeTTC(*phttc);
            *phttc = (HFF)NULL;
        }
    }
    else
    {
    // This is the case of the single TTF being loaded (NOT TTC)
    // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry) + sizeof(TTC_HFF_ENTRY) * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc != (HFF)NULL)
        {
            pttc->ahffEntry[0].iFace = 1;
            pttc->ahffEntry[0].ulOffsetTable = 0;

            if(bLoadTTF(iFile,pvView,cjView,0,ulLangId,
                            &pttc->ahffEntry[0].hff))
            {
                hff = pttc->ahffEntry[0].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

            // fill hff array in TTC_FONTFILE struture

                pttc->ulTrueTypeResource = 1;
                pttc->ulNumEntry         = PFF(hff)->ffca.ulNumFaces;
                pttc->cRef               = 0;
                pttc->fl                 = 0;

            // fill up TTC_FONTFILE structure for each faces.

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[1].hff   = hff;
                    pttc->ahffEntry[1].iFace = 2;
                    pttc->ahffEntry[1].ulOffsetTable = 0;
                }

            // now, everything is o.k.

                bRet = TRUE;
            }
            else
            {
                vFreeTTC(*phttc);
                *phttc = (HFF)NULL;
            }
        }
        else
        {
            //WARNING("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n");
        }
    }

    return bRet;
}


STATIC BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff
    )
{
    PFONTFILE      pff;
    FS_ENTRY       iRet;
    TABLE_POINTERS tp;
    IFISIZE        ifisz;
    fs_GlyphInputType   gin;
    fs_GlyphInfoType    gout;

    sfnt_FontHeader * phead;

    uint16 ui16PlatID, ui16SpecID;
    sfnt_mappingTable *pmap;
    ULONG              ulGsetType;
    ULONG              cjff, dpwszTTF;
    ULONG              ul_wcBias;

// the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
// It is because of STAMPEXTRA that we are not just putting the strucuture
// on the stack such as fs_SplineKey sk; we do not want to overwrite the
// stack at the bottom when putting a stamp in the STAMPEXTRA field.
// [bodind]. The other way to obtain the correct alignment would be to use
// union of fs_SplineKey and the array of bytes of length CJ_0.

    NATURAL             anat0[CJ_0 / sizeof(NATURAL)];

    PBYTE pjOffsetTable = (BYTE*) pvView + ulTableOffset;
    GP_PIFIMETRICS        pifiv = NULL; // ifimetrics for the vertical face

    *phff = HFF_INVALID;

    {
        if(!bVerifyTTF(iFile,
                        pvView,
                        cjView,
                        pjOffsetTable,
                        ulLangId,
                        &tp,
                        &ifisz,
                        &ui16PlatID,
                        &ui16SpecID,
                        &pmap,
                        &ulGsetType,
                        &ul_wcBias
            ))
        {
            return(FALSE);
        }

        cjff = offsetof(FONTFILE,ifi) + ifisz.cjIFI;


    // at this point cjff is equal to the offset to the full path
    // name of the ttf file

        dpwszTTF = cjff;


        if ((pff = pffAlloc(cjff)) == PFF(NULL))
        {
            RET_FALSE("TTFD!ttfdLoadFontFile(): memory allocation error\n");
        }

        *phff = (HFF)pff;

    /* we need to clean the beginning of pff to ensure correct cleanup in case of error/exception */

        RtlZeroMemory((PVOID)pff, offsetof(FONTFILE,ifi));

    // init fields of pff structure
    // store the ttf file name at the bottom of the strucutre

        phead = (sfnt_FontHeader *)((BYTE *)pvView + tp.ateReq[IT_REQ_HEAD].dp);

    // remember which file this is

        pff->iFile = iFile;
        pff->pvView = pvView;
        pff->cjView = cjView;

        pff->ffca.ui16EmHt = BE_UINT16(&phead->unitsPerEm);
        if (pff->ffca.ui16EmHt < 16 || pff->ffca.ui16EmHt > 16384)
        {
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            RET_FALSE("TTFD!bLoadTTF(): invalid unitsPerEm value\n");
        }
        pff->ffca.ui16PlatformID = ui16PlatID;
        pff->ffca.ui16SpecificID = ui16SpecID;

    // so far no exception

        pff->pfcToBeFreed = NULL;

    // convert Language id to macintosh style if this is mac style file
    // else leave it alone, store it in be format, ready to be compared
    // with the values in the font files

        pff->ffca.ui16LanguageID = ui16BeLangId(ui16PlatID,ulLangId);
        pff->ffca.dpMappingTable = (ULONG)((BYTE*)pmap - (BYTE*)pvView);

    // initialize count of HFC's associated with this HFF

        pff->cRef    = 0L;

    // cache pointers to ttf tables and ifi metrics size info

        pff->ffca.tp    = tp;

    // used for TTC fonts

        pff->ffca.ulTableOffset = ulTableOffset;

    // Notice that this information is totaly independent
    // of the font file in question, seems to be right according to fsglue.h
    // and compfont code

        if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            return (FALSE);
        }

        ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
        ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");


    #if DBG
        if (gout.memorySizes[2] != 0)
            TtfdDbgPrint("TTFD!_mem size 2 = 0x%lx \n", gout.memorySizes[2]);
    #endif

        gin.memoryBases[0] = (char *)anat0;
        gin.memoryBases[1] = NULL;
        gin.memoryBases[2] = NULL;

    // initialize the font scaler, notice no fields of gin are initialized [BodinD]

        if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
        {
        // clean up and return:
    
            V_FSERROR(iRet);
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
        }

// initialize info needed by NewSfnt function

        gin.sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of
                                                   // the ttf file

        gin.clientID = (ULONG_PTR)pff;  // pointer to the top of the view of the ttf file

        gin.GetSfntFragmentPtr = pvGetPointerCallback;
        gin.ReleaseSfntFrag  = vReleasePointerCallback;

        gin.param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
        gin.param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

        if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
        {
        // clean up and exit

            V_FSERROR(iRet);
            vFreeFF(*phff);
            *phff = (HFF)NULL;
            RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
        }

        pff->pj034   = (PBYTE)NULL;
        pff->pfcLast = (FONTCONTEXT *)NULL;

        pff->ffca.cj3 = NATURAL_ALIGN(gout.memorySizes[3]);
        pff->ffca.cj4 = NATURAL_ALIGN(gout.memorySizes[4]);


        if(tp.ateOpt[IT_OPT_VHEA].dp != 0 &&
           tp.ateOpt[IT_OPT_VMTX].dp != 0 )
        {
            sfnt_vheaTable *pvheaTable;

            pvheaTable = (sfnt_vheaTable *)((BYTE *)(pff->pvView) +
                                           tp.ateOpt[IT_OPT_VHEA].dp);
            pff->ffca.uLongVerticalMetrics = (uint16) SWAPW(pvheaTable->numOfLongVerMetrics);
        }
        else
        {
            pff->ffca.uLongVerticalMetrics = 0;
        }

    // By default the number of faces is 1L.  The vert facename code may change this.

        pff->ffca.ulNumFaces = 1L;
        pff->pifi_vertical = NULL;

    // finally compute the ifimetrics for this font, this assumes that gset has
    // also been computed

    // if ifimetrics are stored in the boot cache, copy them out, else compute ifimetrics

        vFill_IFIMETRICS(pff,&pff->ifi,&ifisz, &gin);

        return (TRUE);
    }
}

/******************************Public*Routine******************************\
*
* STATIC BOOL bCvtUnToMac
*
* the following piece of code is stolen from JeanP and
* he claims that this piece of code is lousy and checks whether
* we the font is a SYMBOL font in which case unicode to mac conversion
* should be disabled, according to JeanP (??? who understands this???)
* This piece of code actually applies to symbol.ttf [bodind]
*
*
* History:
*  24-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bCvtUnToMac(
    BYTE           *pjView,
    TABLE_POINTERS *ptp,
    uint16 ui16PlatformID
    )
{
// Find out if we have a Mac font and if the Mac charset translation is needed

    BOOL bUnToMac = (ui16PlatformID == BE_PLAT_ID_MAC);

    if (bUnToMac) // change your mind if needed
    {
        sfnt_PostScriptInfo *ppost;

        ppost = (ptp->ateOpt[IT_OPT_POST].dp)                                ?
                (sfnt_PostScriptInfo *)(pjView + ptp->ateOpt[IT_OPT_POST].dp):
                NULL;

        if
        (
            ppost &&
            (BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_VERSION) == 0x00020000)
        )
        {
            INT i, cGlyphs;

            cGlyphs = (INT)BE_UINT16(&ppost->numberGlyphs);

            for (i = 0; i < cGlyphs; i++)
            {
                uint16 iNameIndex = ppost->postScriptNameIndices.glyphNameIndex[i];
                if ((int8)(iNameIndex & 0xff) && ((int8)(iNameIndex >> 8) > 1))
                    break;
            }

            if (i < cGlyphs)
                bUnToMac = FALSE;
        }
    }
    return bUnToMac;
}


// Weight (must convert from IFIMETRICS weight to Windows LOGFONT.lfWeight).

// !!! [Windows 3.1 compatibility]
//     Because of some fonts shipped with WinWord, if usWeightClass is 10
//     or above, then usWeightClass == lfWeight.  All other cases, use
//     the conversion table.

// pan wt -> Win weight converter:

STATIC USHORT ausIFIMetrics2WinWeight[10] = {
            0, 100, 200, 300, 350, 400, 600, 700, 800, 900
            };

STATIC BYTE
ajPanoseFamily[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_SWISS          //   11 (Normal Sans)
    ,FF_SWISS          //   12 (Obtuse Sans)
    ,FF_SWISS          //   13 (Perp Sans)
    ,FF_SWISS          //   14 (Flared)
    ,FF_SWISS          //   15 (Rounded)
    };


static BYTE
ajPanoseFamilyForJapanese[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_MODERN         //   11 (Normal Sans)
    ,FF_MODERN         //   12 (Obtuse Sans)
    ,FF_MODERN         //   13 (Perp Sans)
    ,FF_MODERN         //   14 (Flared)
    ,FF_MODERN         //   15 (Rounded)
    };


/******************************Public*Routine******************************\
*
* vFill_IFIMETRICS
*
* Effects: Looks into the font file and fills IFIMETRICS
*
* History:
*  Mon 09-Mar-1992 10:51:56 by Kirk Olynyk [kirko]
* Added Kerning Pair support.
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC VOID
vFill_IFIMETRICS(
    PFONTFILE       pff,
    GP_PIFIMETRICS     pifi,
    PIFISIZE        pifisz,
    fs_GlyphInputType     *pgin
    )
{
    BYTE           *pjView = (BYTE*)pff->pvView;
    PTABLE_POINTERS ptp = &pff->ffca.tp;

// ptrs to various tables of tt files

    PBYTE pjNameTable = pjView + ptp->ateReq[IT_REQ_NAME].dp;
    sfnt_FontHeader *phead =
        (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

    sfnt_maxProfileTable * pmaxp =
        (sfnt_maxProfileTable *)(pjView + ptp->ateReq[IT_REQ_MAXP].dp);

    sfnt_HorizontalHeader *phhea =
        (sfnt_HorizontalHeader *)(pjView + ptp->ateReq[IT_REQ_HHEAD].dp);

    sfnt_PostScriptInfo   *ppost = (sfnt_PostScriptInfo *) (
                           (ptp->ateOpt[IT_OPT_POST].dp)        ?
                           pjView + ptp->ateOpt[IT_OPT_POST].dp :
                           NULL
                           );

    PBYTE  pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                   pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                   NULL                                ;

    pifi->cjThis    = pifisz->cjIFI;
    
// enter the number of distinct font indicies

    pifi->cig = BE_UINT16(&pmaxp->numGlyphs);

// get name strings info

// For the 3.1 compatibility, GRE returns FamilyName rather than
// Facename for GetTextFace. We make a room for '@' in both
// familyname and facename.

    pifi->dpwszFamilyName = sizeof(GP_IFIMETRICS);

    if(pifisz->pjFamilyNameAlias)
    {
        pifi->dpwszUniqueName = pifi->dpwszFamilyName     + sizeof(WCHAR) + //for @
                                pifisz->cjFamilyName      + sizeof(WCHAR) + //for @
                                pifisz->cjFamilyNameAlias + 
                                sizeof(WCHAR);                              // for L'\0';
    }
    else
    {
      pifi->dpwszUniqueName = pifi->dpwszFamilyName + pifisz->cjFamilyName + sizeof(WCHAR);
    }

    pifi->dpwszFaceName   = pifi->dpwszUniqueName + pifisz->cjUniqueName;
    pifi->dpwszStyleName  = pifi->dpwszFaceName   + pifisz->cjFullName + sizeof(WCHAR);

// copy the strings to their new location. Here we assume that the
// sufficient memory has been allocated

    if (pff->ffca.ui16PlatformID == BE_PLAT_ID_MS)
    {

        if (pff->ffca.ui16SpecificID == BE_SPEC_ID_BIG5     ||
            pff->ffca.ui16SpecificID == BE_SPEC_ID_WANSUNG  ||
            pff->ffca.ui16SpecificID == BE_SPEC_ID_GB)
        {
            CHAR chConvertArea[128];
            UINT iCodePage = GetCodePageFromSpecId(pff->ffca.ui16SpecificID);

            //
            // Convert MBCS string to Unicode..
            //
            // Do for FamilyName....
            //
            RtlZeroMemory(chConvertArea,sizeof(chConvertArea));

            CopyDBCSIFIName(chConvertArea, sizeof(chConvertArea), (LPCSTR)pifisz->pjFamilyName,
                            pifisz->cjFamilyName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                                 // real length
            if(EngMultiByteToWideChar(iCodePage, (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName),
                                      pifisz->cjFamilyName, chConvertArea,
                                      strlen(chConvertArea)+1) == -1)
            {

                //WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                goto CopyUnicodeString;
            }

        // Do for FamilyNameAlias....

            if (pifisz->pjFamilyNameAlias)
            {
                WCHAR   *pwszFamilyNameAlias;

                pwszFamilyNameAlias = (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName + pifisz->cjFamilyName);

                RtlZeroMemory(chConvertArea,sizeof(chConvertArea));

                CopyDBCSIFIName(chConvertArea, sizeof(chConvertArea), (LPCSTR)pifisz->pjFamilyNameAlias,
                                pifisz->cjFamilyNameAlias-sizeof(WCHAR)); //double NULL in this case

            // this routine puts the first terminating zero

                if (EngMultiByteToWideChar(iCodePage, pwszFamilyNameAlias, pifisz->cjFamilyNameAlias,
                                            chConvertArea, strlen(chConvertArea)+1) == -1)
                {

                    //WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                    goto CopyUnicodeString;
                }

                // add the second terminating zero

                pwszFamilyNameAlias[pifisz->cjFamilyNameAlias/sizeof(WCHAR)] = L'\0';
            }

        // Do for FullName....

            RtlZeroMemory(chConvertArea,sizeof(chConvertArea));
            CopyDBCSIFIName(chConvertArea, sizeof(chConvertArea), (LPCSTR)pifisz->pjFullName,
                            pifisz->cjFullName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                               // real length

            if(EngMultiByteToWideChar(iCodePage, (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName),
                                      pifisz->cjFullName, chConvertArea,
                                      strlen(chConvertArea)+1) == -1)
            {
                //WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                goto CopyUnicodeString;
            }

            //
            // Do for UniqueName....
            //

            RtlZeroMemory(chConvertArea,sizeof(chConvertArea));
            CopyDBCSIFIName(chConvertArea,sizeof(chConvertArea), (LPCSTR)pifisz->pjUniqueName,
                            pifisz->cjUniqueName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                                 // real length

            if(EngMultiByteToWideChar(iCodePage, (LPWSTR)((PBYTE)pifi + pifi->dpwszUniqueName),
                                      pifisz->cjUniqueName, chConvertArea,
                                      strlen(chConvertArea)+1) == -1)
            {
                //WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                goto CopyUnicodeString;
            }

            if(pff->ffca.ui16SpecificID == BE_SPEC_ID_WANSUNG  ||
               pff->ffca.ui16SpecificID == BE_SPEC_ID_BIG5 )
            {
                // MingLi.TTF's bug, Style use Unicode encoding, not BIG5 encodingi, GB??

                vCpyBeToLeUnicodeString((LPWSTR)((PBYTE)pifi + pifi->dpwszStyleName),
                                        (LPWSTR)pifisz->pjSubfamilyName, pifisz->cjSubfamilyName / 2);
            }
            else
            {
                UINT iRet;
                RtlZeroMemory(chConvertArea,sizeof(chConvertArea));
                CopyDBCSIFIName(chConvertArea,sizeof(chConvertArea),
                                (LPCSTR)pifisz->pjSubfamilyName,
                                pifisz->cjSubfamilyName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                                 // real length

                iRet = EngMultiByteToWideChar(iCodePage,
                                              (LPWSTR)((PBYTE)pifi+pifi->dpwszStyleName),
                                              pifisz->cjSubfamilyName,
                                              chConvertArea,
                                              strlen(chConvertArea)+1);

                if( iRet == -1 )
                {
                    //WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode failed\n");
                    goto CopyUnicodeString;
                }
            }

        }
        else
        {
            CopyUnicodeString:

            vCpyBeToLeUnicodeString((LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName),
                                    (LPWSTR)pifisz->pjFamilyName, pifisz->cjFamilyName / 2);

        // Do for FamilyNameAlias....

            if(pifisz->pjFamilyNameAlias)
            {
                WCHAR   *pwszFamilyNameAlias;
                pwszFamilyNameAlias = (LPWSTR)((PBYTE)pifi + 
                                        pifi->dpwszFamilyName + pifisz->cjFamilyName);

                vCpyBeToLeUnicodeString(pwszFamilyNameAlias, (LPWSTR)pifisz->pjFamilyNameAlias, 
                                        pifisz->cjFamilyNameAlias / sizeof(WCHAR));

            // add second terminating zero

                pwszFamilyNameAlias[pifisz->cjFamilyNameAlias/sizeof(WCHAR)] = L'\0';
            }

            vCpyBeToLeUnicodeString((LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName), 
                                    (LPWSTR)pifisz->pjFullName, pifisz->cjFullName / 2);

            vCpyBeToLeUnicodeString((LPWSTR)((PBYTE)pifi + pifi->dpwszUniqueName),
                                   (LPWSTR)pifisz->pjUniqueName, pifisz->cjUniqueName / 2);

            vCpyBeToLeUnicodeString((LPWSTR)((PBYTE)pifi + pifi->dpwszStyleName),
                                    (LPWSTR)pifisz->pjSubfamilyName, pifisz->cjSubfamilyName / 2);
        }
    }
    else
    {
        ASSERTDD(pff->ffca.ui16PlatformID == BE_PLAT_ID_MAC, "bFillIFIMETRICS: not mac id \n");

        vCpyMacToLeUnicodeString(pff->ffca.ui16LanguageID, (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName),
                                 pifisz->pjFamilyName, pifisz->cjFamilyName / 2);

        vCpyMacToLeUnicodeString(pff->ffca.ui16LanguageID, (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName),
                                    pifisz->pjFullName, pifisz->cjFullName / 2);

        vCpyMacToLeUnicodeString(pff->ffca.ui16LanguageID, (LPWSTR)((PBYTE)pifi + pifi->dpwszUniqueName),
                                    pifisz->pjUniqueName, pifisz->cjUniqueName / 2);

        vCpyMacToLeUnicodeString(pff->ffca.ui16LanguageID, (LPWSTR)((PBYTE)pifi + pifi->dpwszStyleName),
                                    pifisz->pjSubfamilyName, pifisz->cjSubfamilyName / 2);
    }

//
// flInfo
//
    pifi->flInfo = (
                     FM_INFO_TECH_TRUETYPE    |
                     FM_INFO_ARB_XFORMS       |
                     FM_INFO_RETURNS_OUTLINES |
                     FM_INFO_RETURNS_BITMAPS  |
                     FM_INFO_1BPP             | // monochrome
                     FM_INFO_4BPP             | // anti-aliased too
                     FM_INFO_RIGHT_HANDED
                   );
    {
        ULONG cjDSIG;

        if (pff->ffca.ulTableOffset == 0)
        {
            if (pjTable('GISD', pff, &cjDSIG) && cjDSIG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
        else
        {
            ULONG     ulValue;
            ULONG     ulOffset;

            // Get Directory count.

            ulValue = GetUlong(pff->pvView,OFF_TTC_DirectoryCount);

            ulOffset = OFF_TTC_DirectoryEntry + (sizeof(ULONG) * ulValue);

            // Read the DSIG_LONG_TAG

            ulValue = GetUlong(pff->pvView,ulOffset);

            if (ulValue == DSIG_LONG_TAG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
    }

    pifi->familyNameLangID = pifisz->langID;
    pifi->familyAliasNameLangID = 0;

    if (pifisz->pjFamilyNameAlias )
    {
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;
        pifi->familyAliasNameLangID = pifisz->aliasLangID;
    }

    if (ppost && BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ISFIXEDPITCH))
    {
        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
    }

// fsSelection

    pifi->fsSelection = fsSelectionTTFD(pjView, ptp);

// em height

    pifi->fwdUnitsPerEm = (FWORD) BE_INT16(&phead->unitsPerEm);

// ascender, descender, linegap

    pifi->fwdMacAscender    = (FWORD) BE_INT16(&phhea->yAscender);
    pifi->fwdMacDescender   = (FWORD) BE_INT16(&phhea->yDescender);
    pifi->fwdMacLineGap     = (FWORD) BE_INT16(&phhea->yLineGap);

    if (pjOS2)
    {
        pifi->fwdWinAscender    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        pifi->fwdWinDescender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
        pifi->fwdTypoAscender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoAscender);
        pifi->fwdTypoDescender  = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoDescender);
        pifi->fwdTypoLineGap    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoLineGap);
    }
    else
    {
        pifi->fwdWinAscender    = pifi->fwdMacAscender;
        pifi->fwdWinDescender   = -(pifi->fwdMacDescender);
        pifi->fwdTypoAscender   = pifi->fwdMacAscender;
        pifi->fwdTypoDescender  = pifi->fwdMacDescender;
        pifi->fwdTypoLineGap    = pifi->fwdMacLineGap;
    }

// font box

    pifi->rclFontBox.left   = (LONG)((FWORD)BE_INT16(&phead->xMin));
    pifi->rclFontBox.top    = (LONG)((FWORD)BE_INT16(&phead->yMax));
    pifi->rclFontBox.right  = (LONG)((FWORD)BE_INT16(&phead->xMax));
    pifi->rclFontBox.bottom = (LONG)((FWORD)BE_INT16(&phead->yMin));

// fwdMaxCharInc -- really the maximum character width
//
// [Windows 3.1 compatibility]
// Note: Win3.1 calculates max char width to be equal to the width of the
// bounding box (Font Box).  This is actually wrong since the bounding box
// may pick up its left and right max extents from different glyphs,
// resulting in a bounding box that is wider than any single glyph.  But
// this is the way Windows 3.1 does it, so that's the way we'll do it.

    // pifi->fwdMaxCharInc = (FWORD) BE_INT16(&phhea->advanceWidthMax);

    pifi->fwdMaxCharInc = (FWORD) (pifi->rclFontBox.right - pifi->rclFontBox.left);

// fwdAveCharWidth

    if (pjOS2)
    {
        pifi->fwdAveCharWidth = (FWORD)BE_INT16(pjOS2 + OFF_OS2_xAvgCharWidth);

    // This is here for Win 3.1 compatibility since some apps expect non-
    // zero widths and Win 3.1 does the same in this case.

        if( pifi->fwdAveCharWidth == 0 )
            pifi->fwdAveCharWidth = (FWORD)(pifi->fwdMaxCharInc / 2);
    }
    else
    {
        pifi->fwdAveCharWidth = (FWORD)((pifi->fwdMaxCharInc * 2) / 3);
    }

// !!! New code needed [kirko]
// The following is done for Win 3.1 compatibility
// reasons. The correct thing to do would be to look for the
// existence of the 'PCLT'Z table and retieve the XHeight and CapHeight
// fields, otherwise use the default Win 3.1 behavior.

    pifi->fwdCapHeight   = pifi->fwdUnitsPerEm/2;
    pifi->fwdXHeight     = pifi->fwdUnitsPerEm/4;

// Underscore, Subscript, Superscript, Strikeout

    if (ppost)
    {
        pifi->fwdUnderscoreSize     = (FWORD)BE_INT16(&ppost->underlineThickness);
        pifi->fwdUnderscorePosition = (FWORD)BE_INT16(&ppost->underlinePosition);
    }
    else
    {
    // must provide reasonable defaults, when there is no ppost table,
    // win 31 sets these quantities to zero. This does not sound reasonable.
    // I will supply the (relative) values the same as for arial font. [bodind]

        pifi->fwdUnderscoreSize     = (pifi->fwdUnitsPerEm + 7)/14;
        pifi->fwdUnderscorePosition = -((pifi->fwdUnitsPerEm + 5)/10);
    }

    if (pjOS2)
    {
        pifi->fwdStrikeoutSize      = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutSize    );
        pifi->fwdStrikeoutPosition  = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutPosition);
    }
    else
    {
        pifi->fwdStrikeoutSize      = pifi->fwdUnderscoreSize;
        pifi->fwdStrikeoutPosition  = (FWORD)(pifi->fwdMacAscender / 3) ;
    }


//
// panose
//
    if (pjOS2)
    {
        pifi->usWinWeight = BE_INT16(pjOS2 + OFF_OS2_usWeightClass);

    // now comes a hack from win31. Here is the comment from fonteng2.asm:

    // MAXPMWEIGHT equ ($ - pPM2WinWeight)/2 - 1

    //; Because winword shipped early TT fonts, - only index usWeightClass
    //; if between 0 and 9.  If above 9 then treat as a normal Windows lfWeight.
    //
    //        cmp     bx,MAXPMWEIGHT
    //        ja      @f                      ;jmp if weight is ok as is
    //        shl     bx, 1                   ;make it an offset into table of WORDs
    //        mov     bx, cs:[bx].pPM2WinWeight
    //@@:     xchg    ax, bx
    //        stosw                           ;store font weight

    // we emulate this in NT:

#define MAXPMWEIGHT ( sizeof(ausIFIMetrics2WinWeight) / sizeof(ausIFIMetrics2WinWeight[0]) )

        if (pifi->usWinWeight < MAXPMWEIGHT)
            pifi->usWinWeight = ausIFIMetrics2WinWeight[pifi->usWinWeight];

        RtlCopyMemory((PVOID)&pifi->panose,
                      (PVOID)(pjOS2 + OFF_OS2_Panose), sizeof(PANOSE));


        if(pifi->panose.bProportion == PAN_PROP_MONOSPACED)
        {
            pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
        }

    }
    else  // os2 table is not present
    {
        pifi->panose.bFamilyType       = PAN_FAMILY_TEXT_DISPLAY;
        pifi->panose.bSerifStyle       = PAN_ANY;
        pifi->panose.bWeight           = (BYTE)
           ((phead->macStyle & BE_MSTYLE_BOLD) ?
            PAN_WEIGHT_BOLD                    :
            PAN_WEIGHT_BOOK
           );
        pifi->panose.bProportion       = (BYTE)
            ((pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH) ?
             PAN_PROP_MONOSPACED                     :
             PAN_ANY
            );
        pifi->panose.bContrast         = PAN_ANY;
        pifi->panose.bStrokeVariation  = PAN_ANY;
        pifi->panose.bArmStyle         = PAN_ANY;
        pifi->panose.bLetterform       = PAN_ANY;
        pifi->panose.bMidline          = PAN_ANY;
        pifi->panose.bXHeight          = PAN_ANY;

    // have to fake it up, cause we can not read it from the os2 table
    // really important to go through this table for compatibility reasons [bodind]

        pifi->usWinWeight =
            ausIFIMetrics2WinWeight[pifi->panose.bWeight];
    }



//!!! one should look into directional hints here, this is good for now

    pifi->ptlBaseline.x   = 1;
    pifi->ptlBaseline.y   = 0;

// this is what win 31 is doing, so we will do the same thing [bodind]

    pifi->ptlCaret.x = (LONG)BE_INT16(&phhea->horizontalCaretSlopeDenominator);
    pifi->ptlCaret.y = (LONG)BE_INT16(&phhea->horizontalCaretSlopeNumerator);

// We have to use one of the reserved fields to return the italic angle.

    if (ppost)
    {
    // The italic angle is stored in the POST table as a 16.16 fixed point
    // number.  We want the angle expressed in tenths of a degree.  What we
    // can do here is multiply the entire 16.16 number by 10.  The most
    // significant 16-bits of the result is the angle in tenths of a degree.
    //
    // In the conversion below, we don't care whether the right shift is
    // arithmetic or logical because we are only interested in the lower
    // 16-bits of the result.  When the 16-bit result is cast back to LONG,
    // the sign is restored.

        int16 iTmp;

        iTmp = (int16) ((BE_INT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ITALICANGLE) * 10) >> 16);
        pifi->lItalicAngle = (LONG) iTmp;
    }
    else
        pifi->lItalicAngle = 0;

// simulation information:

    if (pifi->dpFontSim = pifisz->dpSims)
    {
        FONTDIFF FontDiff;
        FONTSIM * pfsim = (FONTSIM *)((BYTE *)pifi + pifi->dpFontSim);
        FONTDIFF *pfdiffBold       = NULL;
        FONTDIFF *pfdiffItalic     = NULL;
        FONTDIFF *pfdiffBoldItalic = NULL;

        switch (pifi->fsSelection & (FM_SEL_ITALIC | FM_SEL_BOLD))
        {
        case 0:
        // all 3 simulations are present

            pfsim->dpBold       = DWORD_ALIGN(sizeof(FONTSIM));
            pfsim->dpItalic     = pfsim->dpBold + DWORD_ALIGN(sizeof(FONTDIFF));
            pfsim->dpBoldItalic = pfsim->dpItalic + DWORD_ALIGN(sizeof(FONTDIFF));

            pfdiffBold       = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBold);
            pfdiffItalic     = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpItalic);
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case FM_SEL_ITALIC:
        case FM_SEL_BOLD:

        // only bold italic variation is present:

            pfsim->dpBold       = 0;
            pfsim->dpItalic     = 0;

            pfsim->dpBoldItalic = DWORD_ALIGN(sizeof(FONTSIM));
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case (FM_SEL_ITALIC | FM_SEL_BOLD):
            //RIP("ttfd!another case when flags have been messed up\n");
            break;
        }

    // template reflecting a base font:
    // (note that the FM_SEL_REGULAR bit is masked off because none of
    // the simulations generated will want this flag turned on).

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection & ~FM_SEL_REGULAR;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

    //
    // Create FONTDIFFs from the base font template
    //
        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;

        // really only true if ntod transform is unity

            pfdiffBold->fwdAveCharWidth += 1;
            pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;

            pfdiffItalic->ptlCaret.x = CARET_X;
            pfdiffItalic->ptlCaret.y = CARET_Y;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;

            pfdiffBoldItalic->ptlCaret.x       = CARET_X;
            pfdiffBoldItalic->ptlCaret.y       = CARET_Y;

            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fdsem.h ===
/******************************Module*Header*******************************\
* Module Name: fdsem.h
*
* declarations for the wrappers that serialize access to the rasterizer
*
* Created: 11-Apr-1992 19:37:49
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


// EXPORTED FUNCTIONS OF THE IFI INTERFACE


HFF
ttfdSemLoadFontFile (
    //ULONG cFiles,
    ULONG_PTR *piFile,
    ULONG ulLangId
    );

BOOL
ttfdSemUnloadFontFile (
    HFF hff
    );

LONG
ttfdSemQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH   hg,
    GLYPHDATA *pgd,
    PVOID   pv
    );
    
LONG
ttfdSemQueryFontDataSubPos (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH   hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   subX,
    ULONG   subY
    );


VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    );


LONG
ttfdQueryFontFile (
    HFF     hff,
    ULONG   ulMode,
    ULONG   cjBuf,
    PULONG  pulBuf
    );
GP_IFIMETRICS *
ttfdQueryFont (
    HFF    hff,
    ULONG  iFace,
    ULONG *pid
    );

/* for GDI+ internal use, provide a pointer to the TrueType table, we need to call the
   release function for every Get function for the font file to get unmapped */

LONG
ttfdSemGetTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifyint the tt table
    PBYTE  *ppjTable,// ptr to table in the font file
    ULONG  *cjTable  // size of table
    );

void
ttfdSemReleaseTrueTypeTable (
    HFF     hff
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fd_query.c ===
/******************************Module*Header*******************************\
* Module Name: fd_query.c                                                  *
*                                                                          *
* QUERY functions.                                                         *
*                                                                          *
* Created: 18-Nov-1991 14:37:56                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
//#include "winfont.h"
#include "fdsem.h"
#include "winerror.h"

// extern HSEMAPHORE ghsemTTFD;

#ifdef _X86_
//
// For x86, FLOATL is actually DWORD, but the value is IEEE format floating
// point, then check sign bit.
//
#define IS_FLOATL_MINUS(x)   ((DWORD)(x) & 0x80000000)
#else
//
// For RISC, FLOATL is FLOAT.
//
#define IS_FLOATL_MINUS(x)   (((FLOATL)(x)) < 0.0f)
#endif // _X86_

//
// Monochrome: 1  bit per pixel
// Gray:       8 bits per pixel
// ClearType   8 bits per pixel also, no modification needed for CLEARTYPE
///            because FO_GRAYSCALE will be set along with FO_CLEARTYPE_GRID
//
// CJ_TT_SCAN rounds up to a 32-bit boundary
//
#define CJ_TT_SCAN(cx,p) \
    (4*((((((p)->flFontType & FO_GRAYSCALE)?(8):(1))*(cx))+31)/32))

// Each scan of a glyph bitmap is BYTE aligned (except for the
// top (first) scan which is DWORD aligned. The last scan is
// padded out with zeros to the nearest DWORD boundary. These
// statements apply to monochrome and 4-bpp gray glyphs images.
// The number of bytes per scan will depend upon the number of
// pixels in a scan and the depth of the image. For monochrome
// glyphs the number of bytes per scan is ceil(cx/8) = floor((cx+7)/8)
// For the case of 4-bpp bitmaps the count of bytes in a scan
// is ceil( 4*cx/8 ) = ceil(cx/2)

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)
#define CJ_4BIT_SCAN(cx)        (((cx)+1)/2)
#define CJ_8BIT_SCAN(cx)        (cx)

#define LABS(x) ((x)<0)?(-x):(x)

#if DBG
// #define  DEBUG_OUTLINE
// #define  DBG_CHARINC
#endif

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewContourGridFit(FONTCONTEXT *pfc)
{
    fs_GlyphInputType *gin  = pfc->pgin;          // used a lot
    fs_GlyphInfoType  *gout = pfc->pgout;         // used a lot
    FS_ENTRY iRet;


    iRet = fs_ContourGridFit(gin, gout);

    if (iRet != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        iRet = fs_ContourNoGridFit(gin, gout);
    }
    return iRet;
}



/******************************Public*Routine******************************\
* VOID vCharacterCode
*
* History:
*  07-Dec-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCharacterCode (
    FONTFILE          *pff,
    HGLYPH             hg,
    fs_GlyphInputType *pgin
    )
{
    ASSERTDD((hg & 0xffff0000) == 0, "hg not unicode\n");

    pgin->param.newglyph.characterCode = NONVALID;
    pgin->param.newglyph.glyphIndex = (uint16)hg;
    pgin->param.newglyph.bMatchBBox  = FALSE;
    pgin->param.newglyph.bNoEmbeddedBitmap = FALSE;
    return;
}



/******************************Public*Routine******************************\
* PIFIMETRICS ttfdQueryFont
*
* Return a pointer to the IFIMETRICS for the specified face of the font
* file.  Also returns an id (via the pid parameter) that is later used
* by ttfdFree.
*
* History:
*  21-Oct-1992 Gilman Wong [gilmanw]
* IFI/DDI merge
*
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

GP_IFIMETRICS *ttfdQueryFont (
    HFF    hff,
    ULONG  iFace,
    ULONG *pid
    )
{
    HFF    httc = hff;

// Validate handle.

    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(httc)->ahffEntry[iFace-1].hff;
    iFace = PTTC(httc)->ahffEntry[iFace-1].iFace;

//
// Validate handle.
//
    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PFF(hff)->ffca.ulNumFaces,
             "ttfdQueryFaces(): iFace out of range\n");

//
// ttfdFree can ignore this.  IFIMETRICS will be deleted with the FONTFILE
// structure.
//
    *pid = (ULONG_PTR) NULL;

//
// Return the pointer to the precomputed IFIMETRICS in the PFF.
//

    if ( iFace == 1L )
        return ( &(PFF(hff)->ifi) ); // Normal face
    else
      return ( PFF(hff)->pifi_vertical ); // Vertical face
}


/******************************Public*Routine******************************\
* vFillSingularGLYPHDATA
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillSingularGLYPHDATA (
    HGLYPH       hg,
    ULONG        ig,
    FONTCONTEXT *pfc,
    GLYPHDATA   *pgldt   // OUT
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    // may get changed by the calling routine if bits requested too
    pgldt->gdf.pgb = NULL;
    pgldt->hg = hg;

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;

// go on to compute the positioning info:

// here we will just xform the notional space data:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

// xforms are computed by simple multiplication

    pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
    pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
    pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

    pgldt->fxD_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sD_Sideways);
    pgldt->fxA_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sA_Sideways);
    pgldt->fxAB_Sideways = pgldt->fxA_Sideways + fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax - (LONG)ngm.yMin);

}


/******************************Public*Routine******************************\
* lGetSingularGlyphBitmap
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetSingularGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv
    )
{
    LONG         cjGlyphData;
    ULONG        ig;
    FS_ENTRY     iRet;


    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

// Compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

        //WARNING("gdisrv!lGetSingularGlyphBitmap(): fs_NewGlyph failed\n");
        return FD_ERROR;
    }

// Return the glyph index corresponding to this hglyph.

    ig = pfc->pgout->glyphIndex;

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(0,0,pfc);

// If prg is NULL, caller is requesting just the size.

// At this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.
// In either case we shall reject the caller if he did not
// provide sufficiently big buffer

// fill all of GLYPHDATA structure except for bitmap bits

    if ( pgd != (GLYPHDATA *)NULL )
    {
        vFillSingularGLYPHDATA( hglyph, ig, pfc, pgd );
    }

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

        // The corresponding GLYPHDATA structure has been modified
        // by vFillGlyphData. See the statement "pgldt->fxA = 0"
        // in vFillGlyphData.

        pgb->ptlUprightOrigin.x = 0;
        pgb->ptlUprightOrigin.y = 0;

        pgb->ptlSidewaysOrigin.x = 0;
        pgb->ptlSidewaysOrigin.y = 0;

        pgb->sizlBitmap.cx = 0;
        pgb->sizlBitmap.cy = 0;
    }

    if ( pgd != (GLYPHDATA *)NULL )
    {
        pgd->gdf.pgb = (GLYPHBITS *)pv;
    }


// Return the size.

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
* lGetGlyphBitmap
*
* History:
*  20-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv,
    FS_ENTRY    *piRet
)
{
    PVOID pvSetMemoryBases(fs_GlyphInfoType*, fs_GlyphInputType*, int);
    VOID vCopyAndZeroOutPaddingBits(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopy4BitsPerPixel(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopy8BitsPerPixel(FONTCONTEXT *, GLYPHBITS *, BYTE *, GMC *);
    VOID vCopyClearTypeBits(FONTCONTEXT *, GLYPHBITS *, BYTE *, GMC *);
    VOID vFillGLYPHDATA(HGLYPH, ULONG, FONTCONTEXT*, fs_GlyphInfoType*, GLYPHDATA*, GMC*);
    BOOL bGetGlyphMetrics(FONTCONTEXT*, HGLYPH, FLONG, FS_ENTRY*);

    LONG         cjGlyphData;
    ULONG        cx,cy;
    GMC          gmc;
    GLYPHDATA    gd;
    BOOL         bBlankGlyph = FALSE; // initialization essential;

    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

    *piRet = NO_ERR;

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if (pfc->gstat.hgLast != hglyph)
    {
    // DO skip grid fitting if embedded bitmpas are found,
    // for we will NOT be interested in outlines

        if (!bGetGlyphMetrics(pfc,hglyph,FL_SKIP_IF_BITMAP,piRet))
        {
            return(FD_ERROR);
        }
    }


    cx = pfc->pgout->bitMapInfo.bounds.right
       - pfc->pgout->bitMapInfo.bounds.left;
    cy = pfc->pgout->bitMapInfo.bounds.bottom
       - pfc->pgout->bitMapInfo.bounds.top;

    // don't cheat like GDI, just return cx = 0, cy = 0, cj = 0 for empty bitmap

    if ((cx == 0) || (cy == 0))
    {
        bBlankGlyph = TRUE;
    }

    if (bBlankGlyph)
    {
        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        cjGlyphData = CJGD(0,0,pfc);
    }
    else
    {
    // this is quick and dirty computation, the acutal culGlyphData
    // written to the buffer may be little smaller if we had to shave
    // off a few scans off the glyph bitmap that extended over
    // the pfc->yMin or pfc->yMax bounds. Notice that culGlyphData
    // computed this way may be somewhat bigger than pfc->culGlyphMax,
    // but the actual glyph written to the buffer will be smaller than
    // pfc->culGlyphMax

        // really win31 hack, shold not always be shifting right [bodind]
        // Win95 FE hack

        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,
            "Depth Not Chosen Yet!\n"
        );
        cjGlyphData = CJGD(cx,cy,pfc);

    // since we will shave off any extra rows if there are any,
    // we can fix culGlyphData so as not extend over the max value

        if ((ULONG)cjGlyphData > pfc->cjGlyphMax)
        {
            cjGlyphData = (LONG)pfc->cjGlyphMax;

            if (cy > pfc->cyMax)
                cy = pfc->cyMax;
            if (cx > pfc->cxMax)
                cx = pfc->cxMax;
        }
    }

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

// fill all of GLYPHDATA structure except for bitmap bits
// !!! Scummy hack - there appears to be no way to get just the
// !!! bitmap, without getting the metrics, since the origin for the
// !!! bitmap is computed from the rclink field in the glyphdata.
// !!! this is surely fixable but I have neither the time nor the
// !!! inclination to pursue it.
// !!!
// !!! We should fix this when we have time.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }


    // Normal case
    vFillGLYPHDATA(
            hglyph,
            pfc->gstat.igLast,
            pfc,
            pfc->pgout,
            pgd,
            &gmc);

    {   // fix the cjGlyphData, cause it might have been a bit more than we actually need
        LONG newcjGlyphData = CJGD(gmc.cxCor, gmc.cyCor, pfc);
        ASSERT(newcjGlyphData <= cjGlyphData);
        cjGlyphData = newcjGlyphData;
    }

    // the caller wants the bits too

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

    // allocate mem for the glyph, 5-7 are magic #s required by the spec
    // remember the pointer so that the memory can be freed later in case
    // of exception

        pfc->gstat.pv = pvSetMemoryBases(pfc->pgout, pfc->pgin, IS_GRAY(pfc));
        if (!pfc->gstat.pv)
           RETURN("TTFD!_ttfdQGB, mem allocation failed\n",FD_ERROR);

    // initialize the fields needed by fs_ContourScan,
    // the routine that fills the outline, do the whole
    // bitmap at once, do not want banding

        pfc->pgin->param.scan.bottomClip = pfc->pgout->bitMapInfo.bounds.top;
        pfc->pgin->param.scan.topClip = pfc->pgout->bitMapInfo.bounds.bottom;
        pfc->pgin->param.scan.outlineCache = (int32 *)NULL;


    // make sure that our state is ok: the ouline data in the shared buffer 3
    // must correspond to the glyph we are processing, and the last
    // font context that used the shared buffer pj3 to store glyph outlines
    // has to be the pfc passed to this function:

        ASSERTDD(hglyph == pfc->gstat.hgLast, "hgLast trashed \n");

        *piRet = fs_ContourScan(pfc->pgin,pfc->pgout);

        pfc->gstat.hgLast = HGLYPH_INVALID;


        if (*piRet != NO_ERR)
        {
        // just to be safe for the next time around, reset pfcLast to NULL

            V_FSERROR(*piRet);
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;

            return(FD_ERROR);
        }

        if (!bBlankGlyph && gmc.cxCor && gmc.cyCor)
        {
        // copy to the engine's buffer and zero out the bits
        // outside of the black box


        // Call either the monochrome or the gray level function
        // depending upon the gray bit in the font context

            if (IS_GRAY(pfc))
            {
                if (IS_CLEARTYPE(pfc))
                    vCopyClearTypeBits(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
                else if (pfc->flFontType & FO_SUBPIXEL_4)
                    vCopy8BitsPerPixel(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
                else
                    vCopy4BitsPerPixel(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
            }
            else
            {
                vCopyAndZeroOutPaddingBits(pfc, pgb, (BYTE*) pfc->pgout->bitMapInfo.baseAddr, &gmc);
            }

        // bitmap origin, i.e. the upper left corner of the bitmap, bitmap
        // is as big as its black box


            pgb->ptlUprightOrigin.x = pgd->rclInk.left;
            pgb->ptlUprightOrigin.y = pgd->rclInk.top;

            pgb->ptlSidewaysOrigin.x = F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.x);
            pgb->ptlSidewaysOrigin.y = -F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.y);
        }
        else // blank glyph, return a blank 0x0 bitmap
        {
            pgb->ptlUprightOrigin.x = 0;
            pgb->ptlUprightOrigin.y = 0;

            pgb->ptlSidewaysOrigin.x = 0;
            pgb->ptlSidewaysOrigin.y = 0;

            pgb->sizlBitmap.cx = 0;
            pgb->sizlBitmap.cy = 0;
        }

        pgd->gdf.pgb = pgb;


    // free memory and return

        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
*
* BOOL bGetGlyphOutline
*
* valid outline points are in pfc->gout after this call
*
* History:
*  19-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hg,
    ULONG       *pig,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
// new glyph coming in or the metric has to be recomputed
// because the contents of the gin,gout strucs have been destroyed

    vInitGlyphState(&pfc->gstat);

    ASSERTDD((hg != HGLYPH_INVALID) && ((hg & (HGLYPH)0xFFFF0000) == 0),
              "ttfdQueryGlyphBitmap: hg\n");

    vCharacterCode(pfc->pff,hg,pfc->pgin);

// compute the glyph index from the character code:

    if ((*piRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    *pig = pfc->pgout->glyphIndex;

// these two field must be initialized before calling fs_ContourGridFit

    pfc->pgin->param.gridfit.styleFunc = 0; //!!! do some casts here

    pfc->pgin->param.gridfit.traceFunc = (FntTraceFunc)NULL;

// if bitmap is found for this glyph and if we are ultimately interested
// in bitmaps only and do not care about intermedieate outline, then set the
// bit in the "in" structure to hint the rasterizer that grid fitting
// will not be necessary:

    if (!IS_GRAY(pfc) && pfc->pgout->usBitmapFound && (fl & FL_SKIP_IF_BITMAP))
        pfc->pgin->param.gridfit.bSkipIfBitmap = 0;
    else
        pfc->pgin->param.gridfit.bSkipIfBitmap = 0; // must do hinting

// fs_ContourGridFit hints the glyph (executes the instructions for the glyph)
// and converts the glyph data from the tt file into an outline for this glyph

    if (!(fl & FL_FORCE_UNHINTED) )
    {
        if ((*piRet = fs_NewContourGridFit(pfc)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewContourGridFit\n");
        }
    }
    else // unhinted glyphs are desired
    {
        if ((*piRet = fs_ContourNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_ContourNoGridFit\n");
        }
    }


    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bGetGlyphMetrics
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphMetrics (
    PFONTCONTEXT pfc,
    HGLYPH       hg,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
    ULONG  ig;
    FS_ENTRY i;

    if (!bGetGlyphOutline(pfc,hg,&ig,fl,piRet))
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, bGetGlyphOutline failed \n");
    }

// get the metric info for this glyph,

    i = fs_FindBitMapSize(pfc->pgin, pfc->pgout);

    if (i != NO_ERR)
    {
        *piRet = i;
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, fs_FindBitMapSize \n");
    }


// now that everything is computed sucessfully, we can update
// glyphstate (hg data stored in pj3) and return

    pfc->gstat.hgLast = hg;
    pfc->gstat.igLast = ig;

    return(TRUE);
}




/******************************Public*Routine******************************\
* VOID vFillGLYPHDATA
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillGLYPHDATA(
    HGLYPH            hg,
    ULONG             ig,
    FONTCONTEXT      *pfc,
    fs_GlyphInfoType *pgout,   // outputed from fsFind bitmap size
    GLYPHDATA        *pgldt,   // OUT
    GMC              *pgmc     // optional, not used if doing outline only
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);

    BOOL bOutOfBounds = FALSE;

    vectorType     * pvtD;  // 16.16 point
    vectorType     * pvtDv;  // 16.16 point

    LONG lA,lAB;      // *pvtA rounded to the closest integer value

    ULONG  cx = (ULONG)(pgout->bitMapInfo.bounds.right - pgout->bitMapInfo.bounds.left);
    ULONG  cy = (ULONG)(pgout->bitMapInfo.bounds.bottom - pgout->bitMapInfo.bounds.top);

    LONG lAdvanceHeight;
    LONG lTopSideBearing;

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;


// fs_FindBitMapSize returned  the the following information in gout:
//
//  1) gout.metricInfo // left side bearing and advance width
//
//  2) gout.bitMapInfo // black box info
//
//  3) memory requirement for the bitmap,
//     returned in gout.memorySizes[5] and gout.memorySizes[6]
//
// Notice that fs_FindBitMapSize is exceptional scaler interface routine
// in that it returns info in several rather than in a single
// substructures of gout

// Check if hinting produced totally unreasonable result:

    bOutOfBounds = ( (pgout->bitMapInfo.bounds.left > pfc->xMax)    ||
                     (pgout->bitMapInfo.bounds.right < pfc->xMin)   ||
                     (-pgout->bitMapInfo.bounds.bottom > pfc->yMax) ||
                     (-pgout->bitMapInfo.bounds.top < pfc->yMin)    );

    #if DBG
        if (bOutOfBounds)
            TtfdDbgPrint("TTFD! Glyph out of bounds: ppem = %ld, gi = %ld\n",
                pfc->lEmHtDev, hg);
    #endif


    if ((cx == 0) || (cy == 0) || bOutOfBounds)
    {
        pgldt->rclInk.left   = 0;
        pgldt->rclInk.top    = 0;
        pgldt->rclInk.right  = 0;
        pgldt->rclInk.bottom = 0;

        if (pgmc != (PGMC)NULL)
        {
            pgmc->cxCor = 0;  // forces blank glyph case when filling the bits
            pgmc->cyCor = 0;  // forces blank glyph case when filling the bits
        }

        pgldt->VerticalOrigin_X = 0;
        pgldt->VerticalOrigin_Y = 0;
    }
    else // non empty bitmap
    {

        // black box info, we have to transform y coords to ifi specifications

        pgldt->rclInk.bottom = - pgout->bitMapInfo.bounds.top;
        pgldt->rclInk.top    = - pgout->bitMapInfo.bounds.bottom;
        pgldt->rclInk.left = pgout->bitMapInfo.bounds.left;
        pgldt->rclInk.right = pgout->bitMapInfo.bounds.right;

        if (cy > pfc->cyMax)
        {
            #if DBG
                    TtfdDbgPrint("ttfdQueryGlyphBitmap, out of bounds, cy > pfc->cyMax \n");
            #endif // DBG
            // clip the bottom side
            pgldt->rclInk.bottom = pgldt->rclInk.bottom + pfc->cyMax - cy;
            cy = pfc->cyMax;
        }
        if (cx > pfc->cxMax)
        {
            #if DBG
                    TtfdDbgPrint("ttfdQueryGlyphBitmap, out of bounds, cx > pfc->cxMax \n");
            #endif // DBG
            // clip the right side
            pgldt->rclInk.right = pgldt->rclInk.right + pfc->cxMax - cx;
            cx = pfc->cxMax;
        }

        if (pgmc != (PGMC)NULL)
        {
            pgmc->cxCor    = cx;
            pgmc->cyCor    = cy;

        // only corrected values have to obey this condition:

            ASSERTDD(
                pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
            #if DBG
                if (CJGD(pgmc->cxCor,pgmc->cyCor,pfc) > pfc->cjGlyphMax)
                    TtfdDbgPrint("ttfdQueryGlyphBitmap, out of bounds, > cjGlyphMax \n");
            #endif // DBG
        }


        // Determine vertical origin

        if (UNHINTED_MODE(pfc))
        {
            pgldt->VerticalOrigin_X = F26_6TO28_4(pgout->xPtr[pgout->endPtr[
                                (unsigned)pgout->numberOfContours-1]+3]);

            pgldt->VerticalOrigin_Y = - F26_6TO28_4(pgout->yPtr[pgout->endPtr[
                                (unsigned)pgout->numberOfContours-1]+3]);
        }
        else
        {
            pgldt->VerticalOrigin_X = (   pgldt->rclInk.left
                                       -  F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.x)) << 4;
            pgldt->VerticalOrigin_Y = (   pgldt->rclInk.top
                                       +  F16_16TOLROUND(pfc->pgout->verticalMetricInfo.devTopSideBearing.y)) << 4;
        }

    } // end of the non empty bitmap clause


    // go on to compute the positioning info:

    pvtD = & pgout->metricInfo.devAdvanceWidth;
    pvtDv = & pgout->verticalMetricInfo.devAdvanceHeight;

    if (pfc->flXform & (XFORM_HORIZ | XFORM_VERT))  // scaling or 90 degree rotation
    {
        FIX fxTmp, horAdvance, vertAdvance;

        if (pfc->flXform & XFORM_HORIZ )
        {
            horAdvance = LABS(pvtD->x);
            vertAdvance = LABS(pvtDv->y);
            pgldt->fxA = LTOFX(pgldt->rclInk.left);
            pgldt->fxAB = LTOFX(pgldt->rclInk.right);
            pgldt->fxA_Sideways = LTOFX(pgldt->rclInk.top) - pgldt->VerticalOrigin_Y;
            pgldt->fxAB_Sideways = LTOFX(pgldt->rclInk.bottom) - pgldt->VerticalOrigin_Y;
        }
        else
        {
            horAdvance = LABS(pvtD->y);
            vertAdvance = LABS(pvtDv->x);
            pgldt->fxA = -LTOFX(pgldt->rclInk.bottom);
            pgldt->fxAB = -LTOFX(pgldt->rclInk.top);
            pgldt->fxA_Sideways = LTOFX(pgldt->rclInk.left) - pgldt->VerticalOrigin_X;
            pgldt->fxAB_Sideways = LTOFX(pgldt->rclInk.right) - pgldt->VerticalOrigin_X;
        }

        if ((pfc->mx.transform[0][0] < 0) || (pfc->mx.transform[0][1] < 0))
        {
            fxTmp = pgldt->fxA;
            pgldt->fxA = -pgldt->fxAB;
            pgldt->fxAB = -fxTmp;
            fxTmp = pgldt->fxA_Sideways;
            pgldt->fxA_Sideways = -pgldt->fxAB_Sideways;
            pgldt->fxAB_Sideways = -fxTmp;
        }

        if(UNHINTED_MODE(pfc))
        {
            pgldt->fxD = F16_16TO28_4(horAdvance);
            pgldt->fxD_Sideways = F16_16TO28_4(vertAdvance);
        }
        else if (IS_CLEARTYPE_NATURAL(pfc))
        {
            // in the cleartype natural width, we want to ignore the cached width, use the widths from the rasterizer
            // we we still need to round the widths to a pixel value
            pgldt->fxD = F16_16TOLROUND(horAdvance);
            pgldt->fxD = LTOFX(pgldt->fxD);
            pgldt->fxD_Sideways = F16_16TOLROUND(vertAdvance);
            pgldt->fxD_Sideways = LTOFX(pgldt->fxD_Sideways);
        }
        else
        {
            // bGetFastAdvanceWidth return the cached or linear width, we use the fast value to have the same result as GDI
           if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
            {
                // not possible to get the fast value, use the "slow" value
                // supplied by the rasterizer.
                pgldt->fxD = F16_16TOLROUND(horAdvance);
                pgldt->fxD = LTOFX(pgldt->fxD);
            }
            pgldt->fxD_Sideways = F16_16TOLROUND(vertAdvance);
            pgldt->fxD_Sideways = LTOFX(pgldt->fxD_Sideways);

        }
    }
    else // non trivial information
    {
        // here we will just xform the notional space data:

        NOT_GM ngm;  // notional glyph data
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0;

        vGetNotionalGlyphMetrics(pfc,ig,&ngm);

        // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);

        pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
        pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

        if (pfc->flFontType & FO_SIM_BOLD)
        {

            if (pgldt->fxD) /* we don't increase the width of a zero width glyph, problem with indic script */
            {
                pgldt->fxD += LTOFX(1);
            }
            pgldt->fxAB += LTOFX(pfc->dBase);
        }

        pgldt->fxD_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sD_Sideways);
        pgldt->fxA_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sA_Sideways);
        pgldt->fxAB_Sideways = pgldt->fxA_Sideways + fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax - (LONG)ngm.yMin);

        // just to be safe let us round these up and down appropriately

        #define ROUND_DOWN(X) ((X) & ~0xf)
        #define ROUND_UP(X)   (((X) + 15) & ~0xf)

        pgldt->fxA         = ROUND_DOWN(pgldt->fxA);
        pgldt->fxAB        = ROUND_UP(pgldt->fxAB);

        pgldt->fxA_Sideways   = ROUND_DOWN(pgldt->fxA_Sideways);
        pgldt->fxAB_Sideways  = ROUND_UP(pgldt->fxAB_Sideways);

    }

}


/******************************Public*Routine******************************\
*
* ttfdQueryTrueTypeTable
*
* copies cjBytes starting at dpStart from the beginning of the table
* into the buffer
*
* if pjBuf == NULL or cjBuf == 0, the caller is asking how big a buffer
* is needed to store the info from the offset dpStart to the table
* specified by ulTag to the end of the table
*
* if pjBuf != 0  the caller wants no more than cjBuf bytes from
* the offset dpStart into the table copied into the
* buffer.
*
* if table is not present or if dpScart >= cjTable 0 is returned
*
* tag 0 means that the data has to be retrieved from the offset dpStart
* from the beginning of the file. The lenght of the whole file
* is returned if pBuf == nULL
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable);

LONG ttfdQueryTrueTypeTable2 (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in the mapped file
    ULONG  *pcjTable // size of the whole table
    )
{
    PBYTE     pjBegin;  // ptr to the beginning of the table
    LONG      cjTable;
    HFF       hffTTC = hff;

    ASSERTDD(hff, "ttfdQueryTrueTypeTable\n");

    if (dpStart < 0)
        return (FD_ERROR);

// if this font file is gone we are not gonna be able to answer any questions
// about it

    if (PTTC(hffTTC)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        //WARNING("ttfd, ttfdQueryTrueTypeTable: file is gone\n");
        return FD_ERROR;
    }

    ASSERTDD(ulFont <= PTTC(hffTTC)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n"
             );

// get real hff from ttc array.

    hff    = PTTC(hffTTC)->ahffEntry[ulFont-1].hff;
    ulFont = PTTC(hffTTC)->ahffEntry[ulFont-1].iFace;

    ASSERTDD(ulFont <= PFF(hff)->ffca.ulNumFaces,
             "TTFD!_ttfdQueryTrueTypeTable: ulFont != 1\n");

// verify the tag, determine whether this is a required or an optional
// table:

#define tag_TTCF  0x66637474    // 'ttcf'

    if(ulTag == tag_TTCF)
    {
    // if the table offset is 0 it can't be a TTC and we should fail.

        if(PFF(hff)->ffca.ulTableOffset)
        {
            pjBegin = (PBYTE)PFF(hff)->pvView;
            cjTable = PFF(hff)->cjView;
        }
        else
        {
            return(FD_ERROR);
        }
    }
    else
    if (ulTag == 0)  // requesting the whole file
    {
        pjBegin = (PBYTE)PFF(hff)->pvView + PFF(hff)->ffca.ulTableOffset;
        cjTable = PFF(hff)->cjView - PFF(hff)->ffca.ulTableOffset; // cjView == cjFile
    }
    else // some specific table is requested
    {
        pjBegin = pjTable(ulTag, PFF(hff), &cjTable);

        if (pjBegin == (PBYTE)NULL)  // table not present
            return (FD_ERROR);
    }

// if we are succesfull now is the time to return
// the pointer to the whole table in the file and its size:

    if (ppjTable)
    {
        *ppjTable = pjBegin;
    }
    if (pcjTable)
    {
        *pcjTable = cjTable;
    }

// adjust pjBegin to point to location from where the data is to be copied

    pjBegin += dpStart;
    cjTable -= (LONG)dpStart;

    if (cjTable <= 0) // dpStart offsets into mem after the end of table
        return (FD_ERROR);

    if ( (pjBuf == (PBYTE)NULL) || (cjBuf == 0) )
    {
    // the caller is asking how big a buffer it needs to allocate to
    // store the bytes from the offset dpStart into the table to
    // the end of the table (or file if tag is zero)

        return (cjTable);
    }

// at this point we know that pjBuf != 0, the caller wants cjBuf bytes copied
// into his buffer:

    if ((ULONG)cjTable > cjBuf)
        cjTable = (LONG)cjBuf;

    if (pjBuf != NULL)
        RtlCopyMemory((PVOID)pjBuf, (PVOID)pjBegin, cjTable);

    return (cjTable);
}



LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// pointer in the file
    ULONG  *pcjTable // size of the whole table
    )
{
    LONG lRet;
    HFF hffTTF;

    // update the HFF with the remapped view

    hffTTF   = PTTC(hff)->ahffEntry[ulFont-1].hff;

    if (PFF(hffTTF)->cRef == 0)
    {

        PFF(hffTTF)->pvView = PTTC(hff)->pvView;
        PFF(hffTTF)->cjView = PTTC(hff)->cjView;
    }

    lRet = ttfdQueryTrueTypeTable2(
               hff, ulFont, ulTag, dpStart,
               cjBuf, pjBuf, ppjTable, pcjTable);

    return lRet;
}


/******************************Public*Routine******************************\
* ttfdQueryFontFile
*
* A function to query per font file information.
*
* Parameters:
*
*   hff         Handle to a font file.
*
*   ulMode      This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFF_DESCRIPTION -- copies a UNICODE string in the buffer
*                          that describes the contents of the font file.
*
*       QFF_NUMFACES   -- returns number of faces in the font file.
*
*   cjBuf       Maximum number of BYTEs to copy into the buffer.  The
*               driver will not copy more than this many BYTEs.
*
*               This should be zero if pulBuf is NULL.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
*   pulBuf      Pointer to the buffer to receive the data
*               If this is NULL, then the required buffer size
*               is returned as a count of BYTEs.  Notice that this
*               is a PULONG, to enforce 32-bit data alignment.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
* Returns:
*
*   If mode is QFF_DESCRIPTION, then the number of BYTEs copied into
*   the buffer is returned by the function.  If pulBuf is NULL,
*   then the required buffer size (as a count of BYTEs) is returned.
*
*   If mode is QFF_NUMFACES, then number of faces in font file is returned.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  22-Oct-1992 -by- Gilman Wong [gilmanw]
* Added QFF_NUMFACES mode (IFI/DDI merge).
*
*  09-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontFile (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    ULONG  *pulBuf      // return buffer (NULL if requesting size of data)
    )
{
    GP_PIFIMETRICS pifi;

    ASSERTDD(hff != HFF_INVALID, "ttfdQueryFontFile(): invalid HFF\n");

    switch (ulMode)
    {
      case QFF_DESCRIPTION:
      {
          ULONG ulIndex;
          LPWSTR  pwszDesc = (LPWSTR)pulBuf;
          LONG  lBuffer = 0;

          for( ulIndex = 0;
              ulIndex < PTTC(hff)->ulNumEntry;
              ulIndex++
              )
          {
              LONG wchlen;

          // if this is a entry for vertical face font, just skip it...

              if( !((PTTC(hff)->ahffEntry[ulIndex].iFace) & 0x1) )
                continue;

              pifi = &((PFF(PTTC(hff)->ahffEntry[ulIndex].hff))->ifi);

              wchlen = (LONG)(pifi->dpwszStyleName - pifi->dpwszFaceName) / sizeof(WCHAR);

              if (ulIndex != 0)
              {
                  if (pwszDesc != (LPWSTR) NULL)
                  {
                      wcscpy((LPWSTR)pwszDesc, (LPWSTR) L" & ");
                      pwszDesc += 3;
                  }
                  lBuffer += (3 * sizeof(WCHAR));
              }

              if (pwszDesc != (LPWSTR) NULL)
              {
                  wcscpy((LPWSTR)pwszDesc, (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName));
                  pwszDesc += (wchlen-2); // -2 for overwrite NULL at next time.
              }
              lBuffer += (wchlen * sizeof(WCHAR));
          }

          return( lBuffer );
      }

    case QFF_NUMFACES:
    //
    // Currently, only one face per TrueType file.  This may one day change!
    //

      return (PTTC(hff))->ulNumEntry;

    default:
        //WARNING("ttfd!ttfdQueryFontFile(): invalid mode\n");
        return FD_ERROR;
    }
}


/******************************Public*Routine******************************\
*
* vCopyAndZeroOutPaddingBits
*
* copies the bits of the bitmap and zeroes out padding bits
*
* History:
*  18-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// array of masks for the last byte in a row

static const BYTE gjMask[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static const BYTE gjMaskHighBit[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1F, 0X3F, 0X7F};

VOID vCopyAndZeroOutPaddingBits(
    FONTCONTEXT *pfc,
    GLYPHBITS   *pgb,
    BYTE        *pjSrc,
    GMC         *pgmc
    )
{
    BYTE   jMask = gjMask[pgmc->cxCor & 7];
    ULONG  cjScanSrc = CJ_TT_SCAN(pgmc->cxCor,pfc);
    ULONG  cxDst = pgmc->cxCor;
    ULONG  cjScanDst = CJ_MONOCHROME_SCAN(cxDst);      // includes emboldening if any
    ULONG  cjDst = CJ_MONOCHROME_SCAN(pgmc->cxCor);    // does not include emboldening
    BYTE   *pjScan, *pjScanEnd;
    ULONG  iByteLast = cjDst - 1;

// sanity checks

    ASSERTDD(!IS_GRAY(pfc),"Monochrome Images Only Please!\n");
    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cxCor\n");
    ASSERTDD(pgmc->cyCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cyCor\n");
    ASSERTDD(pgmc->cxCor > 0, "vCopyAndZeroOutPaddingBits, cxCor == 0\n");
    ASSERTDD(pgmc->cyCor > 0, "vCopyAndZeroOutPaddingBits, cyCor == 0\n");

    pgb->sizlBitmap.cx = cxDst;

    pgb->sizlBitmap.cy = pgmc->cyCor;

// if must chop off a few columns (on the right, this should almost
// never happen), put the warning for now to detect these
// situations and look at them, it does not matter if this is slow

    pjScan = pgb->aj;


    for (
         pjScanEnd = pjScan + (pgmc->cyCor * cjScanDst);
         pjScan < pjScanEnd;
         pjScan += cjScanDst, pjSrc += cjScanSrc
        )
    {
        RtlCopyMemory((PVOID)pjScan,(PVOID)pjSrc,cjDst);
        pjScan[iByteLast] &= jMask; // mask off the last byte
    }

}


/******************************Public*Routine******************************\
* vGetNotionalGlyphMetrics
*
*
\**************************************************************************/

// be values for the format of the indexToLocation table

#define BE_ITOLOCF_SHORT   0X0000
#define BE_ITOLOCF_LONG    0X0100

// offsets to the non scaled glyphdata

#define OFF_nc    0
#define OFF_xMin  2
#define OFF_yMin  4
#define OFF_xMax  6
#define OFF_yMax  8


VOID vGetNotionalGlyphMetrics(
    FONTCONTEXT *pfc,  // IN
    ULONG        ig,   // IN , glyph index
    NOT_GM      *pngm  // OUT, notional glyph metrics
    )
{
    sfnt_FontHeader        * phead;
    sfnt_HorizontalHeader  * phhea;
    sfnt_HorizontalMetrics * phmtx;
    PBYTE                    pjGlyph;
    PBYTE                    pjLoca;
    ULONG                    numberOf_LongHorMetrics;
    BYTE                   * pjView = pfc->pff->pvView;

    sfnt_VerticalMetrics   * pvmtx;
    ULONG                    numberOf_LongVerticalMetrics = pfc->pff->ffca.uLongVerticalMetrics;

#if DBG
    sfnt_maxProfileTable   * pmaxp;
    ULONG                    cig;

    pmaxp = (sfnt_maxProfileTable *)(pjView + pfc->ptp->ateReq[IT_REQ_MAXP].dp);
    cig = BE_UINT16(&pmaxp->numGlyphs) + 1;
    ASSERTDD(ig < cig, "ig >= numGlyphs\n");
#endif

// compute the relevant pointers:

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    pjGlyph = pjView + pfc->ptp->ateReq[IT_REQ_GLYPH].dp;
    pjLoca  = pjView + pfc->ptp->ateReq[IT_REQ_LOCA].dp;
    numberOf_LongHorMetrics = BE_UINT16(&phhea->numberOf_LongHorMetrics);


// get the pointer to the beginning of the glyphdata for this glyph
// if short format, offset divided by 2 is stored in the table, if long format,
// the actual offset is stored. Offsets are measured from the beginning
// of the glyph data table, i.e. from pjGlyph

    switch (phead->indexToLocFormat)
    {
    case BE_ITOLOCF_SHORT:
        pjGlyph += 2 * BE_UINT16(pjLoca + (sizeof(uint16) * ig));
        break;

    case BE_ITOLOCF_LONG :
        pjGlyph += BE_UINT32(pjLoca + (sizeof(uint32) * ig));
        break;

    default:
        //RIP("TTFD!_illegal phead->indexToLocFormat\n");
        break;
    }

// get the bounds, flip y

    pngm->xMin = BE_INT16(pjGlyph + OFF_xMin);
    pngm->xMax = BE_INT16(pjGlyph + OFF_xMax);
    pngm->yMin = - BE_INT16(pjGlyph + OFF_yMax);
    pngm->yMax = - BE_INT16(pjGlyph + OFF_yMin);

// get the adwance width and the lsb
// the piece of code stolen from the rasterizer [bodind]

    if (ig < numberOf_LongHorMetrics)
    {
        pngm->sD = BE_INT16(&phmtx[ig].advanceWidth);
        pngm->sA = BE_INT16(&phmtx[ig].leftSideBearing);
    }
    else
    {
    // first entry after[AW,LSB] array

        int16 * psA = (int16 *) &phmtx[numberOf_LongHorMetrics];

        pngm->sD = BE_INT16(&phmtx[numberOf_LongHorMetrics-1].advanceWidth);
        pngm->sA = BE_INT16(&psA[ig - numberOf_LongHorMetrics]);
    }

// redefine x coords so that they correspond to being measured relative to
// the real character origin

    pngm->xMax = pngm->xMax - pngm->xMin + pngm->sA;
    pngm->xMin = pngm->sA;

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation A,B,C spaces change

        pngm->sA   -= (SHORT)FixMul(pngm->yMax, FX_SIN20);
        pngm->xMax -= (SHORT)FixMul(pngm->yMin, FX_SIN20);
    }

// vertical sideways computation :

    if (numberOf_LongVerticalMetrics)  // the font has vmtx table
    {
        pvmtx = (sfnt_VerticalMetrics *)(pjView + pfc->ptp->ateOpt[IT_OPT_VMTX].dp);

        if (ig < numberOf_LongVerticalMetrics)
        {
            pngm->sD_Sideways  = BE_INT16(&pvmtx[ig].advanceHeight);
            pngm->sA_Sideways = BE_INT16(&pvmtx[ig].topSideBearing);
        }
        else
        {
    // first entry after[AH,TSB] array

            int16 * psTSB = (int16 *) &pvmtx[numberOf_LongVerticalMetrics];

            pngm->sD_Sideways  = BE_INT16(&pvmtx[numberOf_LongVerticalMetrics-1].advanceHeight);
            pngm->sA_Sideways = BE_INT16(&psTSB[ig - numberOf_LongVerticalMetrics]); 
        }
    }
    else // few buggy fonts do not have vmtx table
    {
    // default AdvanceHeight and TopSideBearing from Ascender and Descender

        pngm->sD_Sideways  = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        pngm->sA_Sideways = pfc->pff->ifi.fwdWinAscender + pngm->yMin; // y points down!!!

    // at this point sTSB should be bigger than 0. But because of the bugs in
    // our fonts, mingliu.ttc etc, it turns out that there are glyphs that
    // have their tops significanly above the descender so sTSB becomes
    // negative, even though it should not be. So we fix it now:

        if (pngm->sA_Sideways < 0)
            pngm->sA_Sideways = 0;
    }

    if (pfc->flFontType & FO_SIM_ITALIC_SIDEWAYS)
    {
    // IF there is italic simulation A,B,C spaces change
        SHORT TopOriginX = pfc->pff->ifi.fwdWinDescender -((pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender - pngm->sD) /2);

        pngm->yMin += (SHORT)FixMul(pngm->xMin, FX_SIN20);
        pngm->yMax += (SHORT)FixMul(pngm->xMax, FX_SIN20);
        pngm->sA_Sideways -= (SHORT)FixMul(TopOriginX, FX_SIN20);
    }

}

LONG lFFF(LONG l);
#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

/******************************Public*Routine******************************\
* lQueryDEVICEMETRICS
*
* History:
*  08-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryDEVICEMETRICS (
         FONTCONTEXT *pfc,
               ULONG  cjBuffer,
    FD_DEVICEMETRICS *pdevm
    )
{
    sfnt_FontHeader *phead;

    LONG  lTotalLeading;

    BYTE *pjView =  (BYTE *)pfc->pff->pvView;

    PBYTE pjOS2 = (pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp)         ?
                  (pjView + pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp):
                  NULL                                         ;

   Fixed fxXScale = pfc->mx.transform[0][0];
   if (fxXScale < 0)
       fxXScale = - fxXScale;

// actually requesting the data

    ASSERTDD (
        sizeof(FD_DEVICEMETRICS) <= cjBuffer,
        "FD_QUERY_DEVICEMETRICS: buffer too small\n");


    // get the pointers to needed tables in the tt file

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);


    // add new fields:

    pdevm->HorizontalTransform = pfc->flXform & XFORM_HORIZ;
    pdevm->VerticalTransform   = pfc->flXform & XFORM_VERT;

    if ( pfc->flXform & XFORM_SINGULAR )
    {
        ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        pdevm->cjGlyphMax  = CJGD(0,0,pfc);
        pdevm->xMin        = 0;
        pdevm->xMax        = 0;
        pdevm->yMin        = 0;
        pdevm->yMax        = 0;
        pdevm->cxMax       = 0;
        pdevm->cyMax       = 0;
    }
    else // Otherwise, the max glyph size is cached in the FONTCONTEXT.
    {
        pdevm->cjGlyphMax  = pfc->cjGlyphMax;
        pdevm->xMin        = pfc->xMin;
        pdevm->xMax        = pfc->xMax;
        pdevm->yMin        = pfc->yMin;
        pdevm->yMax        = pfc->yMax;
        pdevm->cxMax       = pfc->cxMax;
        pdevm->cyMax       = pfc->cyMax;
    }

// we are outa here

    return sizeof(FD_DEVICEMETRICS);
}



/******************************Public*Routine******************************\
* ttfdQueryFontData
*
*   dhpdev      Not used.
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*   pgd        Buffer to hold glyphdata structure, if any
*
*   pv         Output buffer to hold glyphbits or pathobj, if any.
*
* Returns:
*
*   Otherwise, returns the size of the glyphbits
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       subX,       // Fixed point for 16.16
    ULONG       subY        // Fixed point for 16.16
    )
{
extern LONG lGetSingularGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern STATIC LONG lQueryDEVICEMETRICS(FONTCONTEXT*, ULONG, FD_DEVICEMETRICS*);
extern LONG lGetGlyphBitmapErrRecover(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern LONG lGetGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID, FS_ENTRY*);
extern BOOL ttfdQueryGlyphOutline(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PATHOBJ*);

// declare the locals

    PFONTCONTEXT pfc;
    USHORT usOverScale;
    LONG cj = 0, cjDataRet = 0;

// if this font file is gone we are not gonna be able to answer any questions
// about it

    ASSERTDD(pfo->iFile, "ttfdQueryFontData, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        //WARNING("ttfd, ttfdQueryFontData(): file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        //WARNING("gdisrv!ttfdQueryFontData(): cannot create font context\n");
        return FD_ERROR;
    }

    pfc->pfo = pfo;

    switch ( iMode )
    {
        case QFD_TT_GRAY1_BITMAP: // monochrome

            usOverScale = 0;  /// !!! 0 for monochrome
            break;

        case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4

            usOverScale = 2;
            break;

        case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16

            usOverScale = 4;
            break;

        case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64

            usOverScale = 8;
            break;
        case QFD_MAXEXTENTS:
            if (pfc->flFontType & FO_GRAYSCALE)
            {
                if (IS_CLEARTYPE(pfc))
                    usOverScale = 0;
                else
                    usOverScale = 4;
            }
            else
                usOverScale = 0;
            break;
        case QFD_CT:
        case QFD_CT_GRID:
        case QFD_GLYPHANDBITMAP:
        case QFD_GLYPHANDBITMAP_SUBPIXEL:
        default:
            usOverScale = 0;
            break;
    }

// call fs_NewTransformation if needed:
    {
        BOOL bBitmapEmboldening = FALSE;

        if ( (pfc->flFontType & FO_SIM_BOLD) &&
            (pfc->flXform & (XFORM_HORIZ | XFORM_VERT) )
            && (iMode != QFD_GLYPHANDOUTLINE)
            && !( pfc->flFontType & FO_SUBPIXEL_4) )
        {
            /* for backwards compatibility and to get better bitmaps at screen resolution, we are doing
               bitmap emboldening simulation (as opposed to outline emboldening simulation) if we are
               emboldening only by one pixel and we are under no rotation or 90 degree rotation and not doing subxixel positionning
               or asking for the bitmap */
            bBitmapEmboldening = TRUE;
        }

        if (!bGrabXform(pfc, usOverScale, bBitmapEmboldening, subX, subY))
        {
            RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);
        }
    }

    switch ( iMode )
    {
    case QFD_TT_GRAY1_BITMAP: // monochrome
    case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4
    case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16
    case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64
    case QFD_GLYPHANDBITMAP:
    case QFD_GLYPHANDBITMAP_SUBPIXEL:
    case QFD_TT_GLYPHANDBITMAP:
    case QFD_CT:
    case QFD_CT_GRID:
        {
        // Engine should not be querying on the HGLYPH_INVALID.

            ASSERTDD (
                hg != HGLYPH_INVALID,
                "ttfdQueryFontData(QFD_GLYPHANDBITMAP): HGLYPH_INVALID \n"
                );

        // If singular transform, the TrueType driver will provide a blank
        // 0x0 bitmap.  This is so device drivers will not have to implement
        // special case code to handle singular transforms.
        //
        // So depending on the transform type, choose a function to retrieve
        // bitmaps.

            if (pfc->flXform & XFORM_SINGULAR)
            {
                cj = lGetSingularGlyphBitmap(pfc, hg, pgd, pv);
            }
            else
            {
                FS_ENTRY iRet;

                cj = lGetGlyphBitmap(pfc, hg, pgd, pv, &iRet);

                if ((cj == FD_ERROR) && (iRet == POINT_MIGRATION_ERR))
                {
                // this is buggy glyph where hinting has so severly distorted
                // the glyph that one of the points went out of range.
                // We will just return a blank glyph but with correct
                // advance width

                    cj = lGetGlyphBitmapErrRecover(pfc, hg, pgd, pv);
                }
            }

        #if DBG
            if (cj == FD_ERROR)
            {
                //WARNING("ttfdQueryFontData(QFD_GLYPHANDBITMAP): get bitmap failed\n");
            }
        #endif
        }
        return cj;

    case QFD_GLYPHANDOUTLINE:

        ASSERTDD (
            hg != HGLYPH_INVALID,
            "ttfdQueryFontData(QFD_GLYPHANDOUTLINE): HGLYPH_INVALID \n"
            );

        if (!ttfdQueryGlyphOutline(pfc, hg, pgd, (PATHOBJ *) pv))
        {
            //WARNING("ttfdQueryFontData(QFD_GLYPHANDOUTLINE): failed to get outline\n");
            return FD_ERROR;
        }
        return sizeof(GLYPHDATA);

    case QFD_MAXEXTENTS:

        return lQueryDEVICEMETRICS(
                   pfc,
                   sizeof(FD_DEVICEMETRICS),
                   (FD_DEVICEMETRICS *) pv
                   );


    default:

        //WARNING("gdisrv!ttfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}

/******************************Public*Routine******************************\
*
* pvSetMemoryBases
*
* To release this memory simply do vFreeMemoryBases(&pv); where pv is
* returned from bSetMemoryBases in ppv
*
* Looks into memory request in fs_GlyphInfoType and allocates this memory
* , than it fills memoryBases in fs_GlyphInputType with pointers to the
* requested memory
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


void *pvSetMemoryBases(fs_GlyphInfoType *pgout,fs_GlyphInputType *pgin,int isGray)
{
    FS_MEMORY_SIZE adp[MEMORYFRAGMENTS];
    FS_MEMORY_SIZE cjTotal;
    INT i;
    PBYTE pjMem;

#define I_LO 5
#define I_HI 7

    cjTotal = 0;    // total memory to allocate for all fragments


// unroll the loop:

//     for (i = I_LO; i <= I_HI; i++)
//     {
//         adp[i] = cjTotal;
//         cjTotal += NATURAL_ALIGN(pgin->memorySizes[i]);
//     }

    adp[5] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[5]);
    adp[6] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[6]);
    adp[7] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[7]);
    if (isGray)
    {
        adp[8] = cjTotal;
        cjTotal += NATURAL_ALIGN(pgout->memorySizes[8]);
    }


    if (cjTotal == 0)
    {
        cjTotal = 4;
    }

    if ((pjMem = (PBYTE)PV_ALLOC((ULONG)cjTotal)) == (PBYTE)NULL)
    {
        for (i = I_LO; i <= I_HI; i++)
            pgin->memoryBases[i] = (PBYTE)NULL;

        RETURN("TTFD!_bSetMemoryBases mem alloc failed\n",NULL);
    }

// unroll the loop:
// set the pointers

//    for (i = I_LO; i <= I_HI; i++)
//    {
//        if (pgin->memorySizes[i] != (FS_MEMORY_SIZE)0)
//        {
//            pgout->memoryBases[i] = pjMem + adp[i];
//        }
//        else
//        {
//        // if no mem was required set to NULL to prevent accidental use
//
//            pgout->memoryBases[i] = (PBYTE)NULL;
//        }
//    }

    if (pgout->memorySizes[5] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[5] = pjMem + adp[5];
    }
    else
    {
        pgin->memoryBases[5] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[6] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[6] = pjMem + adp[6];
    }
    else
    {
        pgin->memoryBases[6] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[7] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[7] = pjMem + adp[7];
    }
    else
    {
        pgin->memoryBases[7] = (PBYTE)NULL;
    }
    if (isGray)
    {
        if (pgout->memorySizes[8] != (FS_MEMORY_SIZE)0)
        {
            pgin->memoryBases[8] = pjMem + adp[8];
        }
        else
        {
            pgin->memoryBases[8] = (PBYTE)NULL;
        }
    }

    return pjMem;
}

/******************************Public*Routine******************************\
* VOID vFreeMemoryBases()                                                  *
*                                                                          *
* Releases the memory allocated by bSetMemoryBases.                        *
*                                                                          *
* History:                                                                 *
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

VOID vFreeMemoryBases(PVOID * ppv)
{
    if (*ppv != (PVOID) NULL)
    {
        V_FREE(*ppv);
        *ppv = (PVOID) NULL; // clean up the state and prevent accidental use
    }
}


typedef struct
{
  unsigned short  Version;
  unsigned short  cGlyphs;
  unsigned char   PelsHeight[1];
} LSTHHEADER;



/******************************Public*Routine******************************\
*
* BOOL bGetFastAdvanceWidth
*
*
* Effects: retrieves the same result as bQueryAdvanceWidth, except it
*          ignores adding 1 for EMBOLDENING and it does not do anything
*          for non horiz. xforms
*
* Warnings: !!! if a bug is found in bQueryAdvanceWidth this routine has to
*           !!! changed as well
*
* return a positive value that include the emboldening
*
* History:
*  25-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bGetFastAdvanceWidth(
    FONTCONTEXT *pfc,
    ULONG        ig,    // glyph index
    FIX         *pfxD   // result in 28.4
    )
{
    HDMXTABLE   *phdmx = pfc->phdmx;
    sfnt_FontHeader        *phead;
    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    LSTHHEADER             *plsth;
    ULONG  cHMTX;
    USHORT dxLastWidth;
    LONG   dx;
    BOOL   bRet;
    BOOL   bNonLinear = TRUE;
    BYTE  *pjView;
    Fixed   transform;

    ASSERTDD(pfc->flXform & (XFORM_HORIZ | XFORM_VERT), "bGetFastAdvanceWidth xform\n");

    if (phdmx != (HDMXTABLE *) NULL)
    {
        *pfxD = (((FIX) phdmx->aucInc[ig]) << 4);
        if ((pfc->flFontType & FO_SIM_BOLD) && (*pfxD != 0))
        {
            *pfxD += (1 << 4);
        }
        return(TRUE);
    }

// Otherwise, try to scale.  Pick up the tables.


    pjView = (BYTE *)pfc->pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD ].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    plsth = (LSTHHEADER *)(
              (pfc->ptp->ateOpt[IT_OPT_LSTH].dp && pfc->ptp->ateOpt[IT_OPT_LSTH].cj != 0) ?
              (pjView + pfc->ptp->ateOpt[IT_OPT_LSTH ].dp):
              NULL
              );

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
    dxLastWidth = BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

// See if there is cause for worry.

    if
    (
      (((BYTE *) &phead->flags)[1] & 0x14)==0 // Bits indicating nonlinearity.
    )
    {
        bNonLinear = FALSE; // we are linear regardless of the size
    }

    bRet = TRUE;

    if
    (
        bNonLinear &&
        ( (plsth == (LSTHHEADER *) NULL)
        || (pfc->lEmHtDev < plsth->PelsHeight[ig]) )
        )
    {
        *pfxD  = 0xFFFFFFFF;
        bRet = FALSE;
    }
    else
    {
    // OK, let's scale using the FIXED transform.

        if (ig < cHMTX)
            dx = (LONG) BE_UINT16(&phmtx[ig].advanceWidth);
        else
            dx = (LONG) dxLastWidth;

        if (pfc->flXform & XFORM_HORIZ )
        {
            transform = pfc->mx.transform[0][0];
        } else
        {
            transform = pfc->mx.transform[0][1];
        }

        if (transform < 0)
            transform = - transform;

        *pfxD = (FIX) (((transform * dx + 0x8000L) >> 12) & 0xFFFFFFF0);

        if ((pfc->flFontType & FO_SIM_BOLD) && (*pfxD != 0))
        {
            *pfxD += (1 << 4);
        }
    }
    return(bRet);
}


/******************************Public*Routine******************************\
*
*  vFillGLYPHDATA_ErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFillGLYPHDATA_ErrRecover(
    HGLYPH        hg,
    ULONG         ig,
    FONTCONTEXT  *pfc,
    GLYPHDATA    *pgldt    // OUT
    )
{

    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;

// this is a blank 0x0 bitmap, no ink

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;
    pgldt->VerticalOrigin_X = 0;
    pgldt->VerticalOrigin_Y = 0;


// go on to compute the positioning info:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

    if (pfc->flXform & XFORM_HORIZ)  // scaling only
    {
        Fixed fxMxx =  pfc->mx.transform[0][0];
        if (fxMxx < 0)
            fxMxx = -fxMxx;

    // bGetFastAdvanceWidth returns the same aw that would get
    // computed by bQueryAdvanceWidths and propagated to an api
    // level through GetTextExtent and GetCharWidths. We have to
    // fill in the same aw for consistency reasons.
    // This also has to be done for win31 compatibility.

        if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
        {
        // just provide something reasonable, force linear scaling
        // even if we would not normally do it.

            pgldt->fxD = FixMul(ngm.sD,pfc->mx.transform[0][0]) << 4;
        }

        if (pfc->mx.transform[0][0] < 0)
            pgldt->fxD = - pgldt->fxD;  // this is an absolute value

        pgldt->fxA   = FixMul(fxMxx, (LONG)ngm.sA) << 4;
        pgldt->fxAB  = FixMul(fxMxx, (LONG)ngm.xMax) << 4;

    }
    else // non trivial information
    {
    // here we will just xform the notional space data:

    // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
        pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
        pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

        pgldt->fxD_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sD_Sideways);
        pgldt->fxA_Sideways  = fxLTimesEf(&pfc->efSide, (LONG)ngm.sA_Sideways);
        pgldt->fxAB_Sideways = pgldt->fxA_Sideways + fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax - (LONG)ngm.yMin);
    }

// finally check if the glyphdata will need to get modified because of the
// emboldening simulation:

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                pgldt->fxD += LTOFX(1);  // this is the absolute value by def

    }
}



/******************************Public*Routine******************************\
*
* LONG lGetGlyphBitmapErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  Thu 24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmapErrRecover (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    PVOID        pv
    )
{
    LONG         cjGlyphData;
    GLYPHDATA    gd;      // Scummy hack
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph


    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(0,0,pfc);

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }

// compute the glyph index from the character code:

    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return FD_ERROR; // even backup funcion can fail
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

    vFillGLYPHDATA_ErrRecover(
        hglyph,
        ig,
        pfc,
        pgd
        );

// the caller wants the bits too

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

        // return blank 0x0 bitmap

        pgb->ptlUprightOrigin.x = 0;
        pgb->ptlUprightOrigin.y = 0;

        pgb->ptlSidewaysOrigin.x = 0;
        pgb->ptlSidewaysOrigin.y = 0;

        pgb->sizlBitmap.cx = 0;
        pgb->sizlBitmap.cy = 0;

        pgd->gdf.pgb = pgb;
    }

    return(cjGlyphData);
}


#if(WINVER < 0x0400)

typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE,FAR *LPFONTSIGNATURE;
#endif
/******************************Public*Routine******************************\
*
* VOID vGetFontSignature(HFF hff, FONTSIGNATURE *pfs);
*
*
* Effects: If font file contains the font signature,
*          it copies the data out, else computes it using win95 mechanism.
*
* History:
*  10-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vGetFontSignature(FONTFILE *pff, FONTSIGNATURE *pfs)
{
    pff;
    pfs;
}

/******************************Public*Routine******************************\
*
* DWORD ttfdQueryLpkInfo
*
*
* Effects: returns per font information needed to support various new
*          multilingual api's invented by DavidMS from Chicago team
*
* History:
*  10-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// called by GetFontLanguageInfo

#define LPK_GCP_FLAGS       1
#define LPK_FONTSIGNATURE   2

DWORD ttfdQueryLpkInfo(
    FONTFILE  *pff,
    ULONG      ulFont,
    ULONG      ulMode,
    ULONG      cj,
    BYTE      *pj
    )
{
    FONTSIGNATURE *pfs = (FONTSIGNATURE *)pj;

    switch (ulMode)
    {
    default:
    case LPK_GCP_FLAGS:
        return 0;
    case LPK_FONTSIGNATURE:
        if (pj)
        {
            vGetFontSignature(pff, pfs);
            return sizeof(FONTSIGNATURE);
        }
        else
        {
            return 0;
        }

    }
}

#if DBG
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGrayGLYPHBITS
*
* Routine Description:
*
*   Dumps a 4bpp gray glyph bitmap to the debugging screen
*
* Arguments:
*
*   pgb -- pointer to a gray GLYPHBITS structure
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void vDumpGrayGLYPHBITS(GLYPHBITS *pgb)
{
    #define CH_TOP_LEFT_CORNER '\xDA'
    #define CH_HORIZONTAL_BAR  '\xC4'
    #define CH_VERTICAL_BAR    '\xB3'
    #define CH_PIXEL_ON        '\x02'
    #define CH_PIXEL_OFF       '\xFA'

    BYTE *pj8, *pj, *pjNext, *pjEnd;
    int cjScan, i, k, c8, c4, cj;
    static const char achGray[16] = {
        CH_PIXEL_OFF,
        '1','2','3','4','5','6','7','8','9','a','b','c','d','e',
        CH_PIXEL_ON
    };

    TtfdDbgPrint(
        "\n\n"
        "ptlOrigin  = (%d,%d)\n"
        "sizlBitmap = (%d,%d)\n"
        "\n\n"
        , pgb->ptlUprightOrigin.x
        , pgb->ptlUprightOrigin.y
        , pgb->sizlBitmap.cx
        , pgb->sizlBitmap.cy
    );
    cjScan = (pgb->sizlBitmap.cx + 1)/2;
    cj = cjScan * pgb->sizlBitmap.cy;
    TtfdDbgPrint("\n\n  ");
    for (i = 0, k = 0; i < pgb->sizlBitmap.cx; i++, k++)
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d", k);
    }
    TtfdDbgPrint("\n %c",CH_TOP_LEFT_CORNER);
    for (i = 0; i < pgb->sizlBitmap.cx; i++)
    {
        TtfdDbgPrint("%c",CH_HORIZONTAL_BAR);
    }
    TtfdDbgPrint("\n");
    c8 = pgb->sizlBitmap.cx / 2;
    c4 = pgb->sizlBitmap.cx % 2;
    for (
        pj = pgb->aj, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0
        ; pjNext < pjEnd
        ; pj=pjNext , pjNext+=cjScan, k++
    )
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d%c",k,CH_VERTICAL_BAR);
        for (pj8 = pj+c8 ; pj < pj8; pj++)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        if (c4)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        TtfdDbgPrint("\n");
    }
}
#endif


/******************************Public*Routine******************************\
* vGCGB
*
* Called by: vCopyGrayBits, vMakeAFixedPitchGrayBitmap
*
* void General Copy Gray Bits
*
* History:
*  Wed 22-Feb-1995 13:14:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID vGCGB(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination GRAY GLYPHBITS structure
                        // In the case where dY is zero, all the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits; in
                        // the case where dY is non-zero, the
                        // sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT gray scale bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-16. In order to fit 17 levels in the 4 bit
                        // per pixel destination we reduce the level
                        // value by 1, except for zero which is left alone.
    GMC         *pgmc,  // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    LONG dY             // vertical offset into destination bitmap used
                        // for "special fixed pitch fonts" like Lucida
                        // Console.
    )
{
    unsigned cxDst;     // width of destination bitmap
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    static const BYTE ajGray[17] = {0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};


    ASSERTDD(
        pfc->flFontType & FO_CHOSE_DEPTH
       ,"We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX && pgmc->cyCor < LONG_MAX
     , "vCopyGrayBits -- bad gmc\n"
    );

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor,pfc);

    cxDst = pgmc->cxCor;

    cjDstScan = CJ_4BIT_SCAN(cxDst);

    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    // destination correction for special fixed pitch fonts

    if (dY)
    {
        // Console font
        // the size of the bitmap has been established already
        pjDstScan += dY * cjDstScan;
    }
    else
    {
        // Extended with Embold
        pgb->sizlBitmap.cx = cxDst;
        pgb->sizlBitmap.cy = pgmc->cyCor;
    }
    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for (
        ; pjDstScan < pjDstScanEnd                  // whole byte loop
        ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for (
            pjSrc = pjSrcScan, pjDst = pjDstScan
          ; pjDst < pjDstScan + (pgmc->cxCor  / 2)
          ; pjDst += 1
        )
        {
            *pjDst  = 16*ajGray[*pjSrc++];  // set high nyble
            *pjDst += ajGray[*pjSrc++];     // set low nyble
        }

        // The dxAbsBold has been enhanced >= 1

        if (pgmc->cxCor & 1)                // one more pixel in source?
        {                                   // yes
            *pjDst++  = 16*ajGray[*pjSrc];    // set high nyble
        }                                   // low nyble is cleared

        while ( pjDst < (pjDstScan + cjDstScan) )    // embodening is taken care of
            *pjDst++ = 0;                           // emboldened?
                                                    // yes; clear last byte
                                                    //
   }

}

VOID
vCopy4BitsPerPixel(
    FONTCONTEXT *pfc
  , GLYPHBITS *pgb
  , BYTE *pjSrc
  , GMC *pgmc
)
{
    vGCGB(pfc, pgb, pjSrc, pgmc, 0);
}

VOID vCopy8BitsPerPixel(
    FONTCONTEXT *pfc,
    GLYPHBITS   *pgb,
    BYTE        *pjSrc,
    GMC         *pgmc
)
{
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor,pfc);
    cjDstScan = CJ_8BIT_SCAN(pgmc->cxCor);  // should be the same as cxCor

    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    pgb->sizlBitmap.cx = pgmc->cxCor;
    pgb->sizlBitmap.cy = pgmc->cyCor;

    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for ( ; pjDstScan < pjDstScanEnd ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for
        (
          pjSrc = pjSrcScan, pjDst = pjDstScan;
          pjDst < (pjDstScan + pgmc->cxCor);
          pjDst++, pjSrc++
        )
        {
            if (*pjSrc)
                *pjDst  = *pjSrc - 1;
            else
                *pjDst = 0;
        }
    }
}

VOID vCopyClearTypeBits(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination CLEARTYPE GLYPHBITS structure
                        // All the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits;
                        // The sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT ClearType bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-252.
    GMC         *pgmc   // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    )
{
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor,pfc);
    cjDstScan = CJ_8BIT_SCAN(pgmc->cxCor);  // should be the same as cxCor

    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    pgb->sizlBitmap.cx = pgmc->cxCor;
    pgb->sizlBitmap.cy = pgmc->cyCor;

    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for ( ; pjDstScan < pjDstScanEnd ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for
        (
          pjSrc = pjSrcScan, pjDst = pjDstScan;
          pjDst < (pjDstScan + pgmc->cxCor);
          pjDst++, pjSrc++
        )
        {
            *pjDst  = *pjSrc;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fontddi.h ===
/*++

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:

    fontddi.h

Abstract:

    Private entry points, defines and types for Windows NT GDI device
    driver interface.

--*/

#ifndef _FONTDDI_
#define _FONTDDI_



#ifdef __cplusplus
extern "C" {
#endif

typedef ULONG       HGLYPH;
typedef LONG        FIX;

#define HGLYPH_INVALID ((HGLYPH)-1)

typedef struct  _POINTFIX
{
    FIX   x;
    FIX   y;
} POINTFIX, *PPOINTFIX;

typedef struct _POINTQF    // ptq
{
    LARGE_INTEGER x;
    LARGE_INTEGER y;
} POINTQF, *PPOINTQF;


typedef struct _PATHOBJ
{
    FLONG   fl;
    ULONG   curveCount;
} PATHOBJ;

typedef struct _GLYPHBITS
{
    POINTL      ptlUprightOrigin;
    POINTL      ptlSidewaysOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];
} GLYPHBITS;

typedef union _GLYPHDEF
{
    GLYPHBITS  *pgb;
    PATHOBJ    *ppo;
} GLYPHDEF;

typedef struct _GLYPHDATA {
        GLYPHDEF gdf;               // pointer to GLYPHBITS or to PATHOBJ
        HGLYPH   hg;                // glyhp handle
        FIX      fxD;               // Character increment amount: D*r.
        FIX      fxA;               // Prebearing amount: A*r.
        FIX      fxAB;              // Advancing edge of character: (A+B)*r.
        FIX      fxD_Sideways;      // Character increment amount: D*r. for sideways characters in vertical writing
        FIX      fxA_Sideways;      // Prebearing amount: A*r. for sideways characters in vertical writing
        FIX      fxAB_Sideways;     // Advancing edge of character: (A+B)*r. for sideways characters in vertical writing
        FIX      VerticalOrigin_X;
        FIX      VerticalOrigin_Y;
        RECTL    rclInk;            // Ink box with sides parallel to x,y axes
} GLYPHDATA;


typedef LONG        PTRDIFF;
typedef PTRDIFF    *PPTRDIFF;
typedef ULONG       ROP4;
typedef ULONG       MIX;

typedef ULONG           IDENT;
typedef FLOAT           FLOATL;

//
// handles for font file and font context objects
//

typedef ULONG_PTR HFF;

#define HFF_INVALID ((HFF) 0)

#define FD_ERROR  0xFFFFFFFF

typedef struct _POINTE      /* pte  */
{
    FLOATL x;
    FLOATL y;
} POINTE, *PPOINTE;

DECLARE_HANDLE(HDEV);

#define LTOFX(x)            ((x)<<4)

#define FXTOL(x)            ((x)>>4)
#define FXTOLFLOOR(x)       ((x)>>4)
#define FXTOLCEILING(x)     ((x + 0x0F)>>4)
#define FXTOLROUND(x)       ((((x) >> 3) + 1) >> 1)

// context information

typedef struct _FD_XFORM {
    FLOATL eXX;
    FLOATL eXY;
    FLOATL eYX;
    FLOATL eYY;
} FD_XFORM, *PFD_XFORM;


typedef struct _FD_DEVICEMETRICS {
    ULONG  cjGlyphMax;          // (cxMax + 7)/8 * cyMax, or at least it should be
    INT   xMin;                 // From FONTCONTEXT
    INT   xMax;                 // From FONTCONTEXT
    INT   yMin;                 // From FONTCONTEXT
    INT   yMax;                 // From FONTCONTEXT
    INT   cxMax;                // From FONTCONTEXT
    INT   cyMax;                // From FONTCONTEXT
    BOOL  HorizontalTransform;  // From FONTCONTEXT flXform & XFORM_HORIZ
    BOOL  VerticalTransform;    // From FONTCONTEXT flXform & XFORM_VERT
} FD_DEVICEMETRICS, *PFD_DEVICEMETRICS;

// signed 16 bit integer type denoting number of FUnit's

typedef SHORT FWORD;


// IFIMETRICS constants

#define FM_VERSION_NUMBER                   0x0

//
// IFIMETRICS::fsType flags
//
#define FM_TYPE_LICENSED                    0x2
#define FM_READONLY_EMBED                   0x4
#define FM_EDITABLE_EMBED                   0x8
#define FM_NO_EMBEDDING                     FM_TYPE_LICENSED

//
// IFIMETRICS::flInfo flags
//
#define FM_INFO_TECH_TRUETYPE               0x00000001
#define FM_INFO_TECH_BITMAP                 0x00000002
#define FM_INFO_TECH_STROKE                 0x00000004
#define FM_INFO_TECH_OUTLINE_NOT_TRUETYPE   0x00000008
#define FM_INFO_ARB_XFORMS                  0x00000010
#define FM_INFO_1BPP                        0x00000020
#define FM_INFO_4BPP                        0x00000040
#define FM_INFO_8BPP                        0x00000080
#define FM_INFO_16BPP                       0x00000100
#define FM_INFO_24BPP                       0x00000200
#define FM_INFO_32BPP                       0x00000400
#define FM_INFO_INTEGER_WIDTH               0x00000800
#define FM_INFO_CONSTANT_WIDTH              0x00001000
#define FM_INFO_NOT_CONTIGUOUS              0x00002000
#define FM_INFO_TECH_MM                     0x00004000
#define FM_INFO_RETURNS_OUTLINES            0x00008000
#define FM_INFO_RETURNS_STROKES             0x00010000
#define FM_INFO_RETURNS_BITMAPS             0x00020000
#define FM_INFO_DSIG                        0x00040000 // FM_INFO_UNICODE_COMPLIANT
#define FM_INFO_RIGHT_HANDED                0x00080000
#define FM_INFO_INTEGRAL_SCALING            0x00100000
#define FM_INFO_90DEGREE_ROTATIONS          0x00200000
#define FM_INFO_OPTICALLY_FIXED_PITCH       0x00400000
#define FM_INFO_DO_NOT_ENUMERATE            0x00800000
#define FM_INFO_ISOTROPIC_SCALING_ONLY      0x01000000
#define FM_INFO_ANISOTROPIC_SCALING_ONLY    0x02000000
#define FM_INFO_TECH_CFF                    0x04000000
#define FM_INFO_FAMILY_EQUIV                0x08000000
#define FM_INFO_IGNORE_TC_RA_ABLE           0x40000000
#define FM_INFO_TECH_TYPE1                  0x80000000

// max number of charsets supported in a tt font, 16 according to win95 guys

#define MAXCHARSETS 16

//
// IFMETRICS::fsSelection flags
//
#define  FM_SEL_ITALIC          0x0001
#define  FM_SEL_UNDERSCORE      0x0002
#define  FM_SEL_NEGATIVE        0x0004
#define  FM_SEL_OUTLINED        0x0008
#define  FM_SEL_STRIKEOUT       0x0010
#define  FM_SEL_BOLD            0x0020
#define  FM_SEL_REGULAR         0x0040

//
// The FONTDIFF structure contains all of the fields that could
// possibly change under simulation
//
typedef struct _FONTDIFF {
    BYTE   jReserved1;      // 0x0
    BYTE   jReserved2;      // 0x1
    BYTE   jReserved3;      // 0x2
    BYTE   bWeight;         // 0x3  Panose Weight
    USHORT usWinWeight;     // 0x4
    FSHORT fsSelection;     // 0x6
    FWORD  fwdAveCharWidth; // 0x8
    FWORD  fwdMaxCharInc;   // 0xA
    POINTL ptlCaret;        // 0xC
} FONTDIFF;

typedef struct _FONTSIM {
    PTRDIFF  dpBold;       // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpItalic;     // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpBoldItalic; // offset from beginning of FONTSIM to FONTDIFF
} FONTSIM;

typedef struct _GP_IFIMETRICS {
    ULONG    cjThis;           // includes attached information
    PTRDIFF  dpwszFamilyName;
    PTRDIFF  dpwszStyleName;
    PTRDIFF  dpwszFaceName;
    PTRDIFF  dpwszUniqueName;
    PTRDIFF  dpFontSim;
    LONG     lItalicAngle;

    USHORT   usWinWeight;           // as in LOGFONT::lfWeight
    ULONG    flInfo;                // see above
    USHORT   fsSelection;           // see above
    USHORT   familyNameLangID;
    USHORT   familyAliasNameLangID;
    FWORD    fwdUnitsPerEm;         // em height
    FWORD    fwdWinAscender;
    FWORD    fwdWinDescender;
    FWORD    fwdMacAscender;
    FWORD    fwdMacDescender;
    FWORD    fwdMacLineGap;
    FWORD    fwdTypoAscender;
    FWORD    fwdTypoDescender;
    FWORD    fwdTypoLineGap;
    FWORD    fwdAveCharWidth;
    FWORD    fwdMaxCharInc;
    FWORD    fwdCapHeight;
    FWORD    fwdXHeight;
    FWORD    fwdUnderscoreSize;
    FWORD    fwdUnderscorePosition;
    FWORD    fwdStrikeoutSize;
    FWORD    fwdStrikeoutPosition;
    POINTL   ptlBaseline;           //
    POINTL   ptlCaret;              // points along caret
    RECTL    rclFontBox;            // bounding box for all glyphs (font space)
    ULONG    cig;                   // maxp->numGlyphs, # of distinct glyph indicies
    PANOSE   panose;

#if defined(_WIN64)

    //
    // IFIMETRICS must begin on a 64-bit boundary
    //

    PVOID    Align;

#endif

} GP_IFIMETRICS, *GP_PIFIMETRICS;

typedef struct _XFORML {
    FLOATL  eM11;
    FLOATL  eM12;
    FLOATL  eM21;
    FLOATL  eM22;
    FLOATL  eDx;
    FLOATL  eDy;
} XFORML, *PXFORML;


typedef struct _FONTOBJ
{
    ULONG      iFace; /* face ID, font index within a ttc file */
    FLONG      flFontType;
    ULONG_PTR   iFile; /* (FONTFILEVIEW *) id used for mapping of the font file */
    SIZE       sizLogResPpi;
    ULONG      ulPointSize; /* pointSize */
    PVOID      pvProducer; /* (FONTCONTEXT *) */
    FD_XFORM   fdx;            // N->D transform used to realize font
} FONTOBJ;

//
// FONTOBJ::flFontType
//
//#define FO_TYPE_RASTER   RASTER_FONTTYPE     /* 0x1 */
//#define FO_TYPE_DEVICE   DEVICE_FONTTYPE     /* 0x2 */
#define FO_TYPE_TRUETYPE TRUETYPE_FONTTYPE   /* 0x4 */
//#define FO_TYPE_OPENTYPE OPENTYPE_FONTTYPE   /* 0X8 */

#define FO_SIM_BOLD                  0x00002000
#define FO_SIM_ITALIC                0x00004000
#define FO_EM_HEIGHT                 0x00008000  /* in gdi+ this flag is always set */
#define FO_GRAYSCALE                 0x00010000          /* [1] */
#define FO_NOGRAY16                  0x00020000          /* [1] */
#define FO_MONO_UNHINTED             0x00040000          /* [3] */
#define FO_NO_CHOICE                 0x00080000          /* [3] */
#define FO_SUBPIXEL_4                0x00100000          /* Indicates non-hinted alignment */
#define FO_CLEARTYPE                 0x00200000
#define FO_CLEARTYPE_GRID            0x00400000
#define FO_NOCLEARTYPE               0x00800000
#define FO_COMPATIBLE_WIDTH          0x01000000
#define FO_SIM_ITALIC_SIDEWAYS       0x04000000 /* for far east vertical vriting sideways glyphs */
#define FO_CHOSE_DEPTH               0x80000000

// new accelerators so that printer drivers  do not need to look to ifimetrics

//#define FO_CFF            0x00100000
//#define FO_POSTSCRIPT     0x00200000
//#define FO_MULTIPLEMASTER 0x00400000
//#define FO_VERT_FACE      0x00800000
//#define FO_DBCS_FONT      0X01000000

/**************************************************************************\
*
*   [1]
*
*   If the FO_GRAYSCALE flag is set then the bitmaps of the font
*   are 4-bit per pixel blending (alpha) values. A value of zero
*   means that the the resulting pixel should be equal to the
*   background color. If the value of the alpha value is k != 0
*   then the resulting pixel must be:
*
*       c0 = background color
*       c1 = foreground color
*       b  = blending value = (k+1)/16  // {k = 1,2,..,15}
*       b  = 0 (k = 0)
*       d0 = gamma[c0], d1 = gamma[c1]  // luminance components
*       d = (1 - b)*d0 + b*d1           // blended luminance
*       c = lambda[d]                   // blended device voltage
*
*   where gamma[] takes a color component from application space
*   to CIE space and labmda[] takes a color from CIE space to
*   device color space
*
*   GDI will set this bit if it request a font be gray scaled
*   to 16 values then GDI will set FO_GRAYSCALE upon entry to
*   DrvQueryFontData().  If the font driver cannot (or will
*   not) grayscale a particular realization of a font then the
*   font provider will zero out FO_GRAYSCALE  and set FO_NOGRAY16
*   to inform GDI that
*   the gray scaling request cannot (or should not) be
*   satisfied.
*
*   [2]
*
*   The FO_NOHINTS indicates that hints were not used in the formation
*   of the glyph images. GDI will set this bit to request that hinting
*   be supressed. The font provider will set this bit accroding to the
*   rendering scheme that it used in generating the glyph image.
*
*   [3]
*
*   The FO_NO_CHOICE flag indicates that the flags FO_GRAYSCALE and
*   FO_NOHINTS must be obeyed if at all possible.
*
\**************************************************************************/

typedef struct _XFORMOBJ
{
    ULONG ulReserved;
} XFORMOBJ;


BOOL APIENTRY PATHOBJ_bMoveTo(
    PVOID      *ppo,
    POINTFIX    ptfx
    );

BOOL APIENTRY PATHOBJ_bPolyLineTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    );

BOOL APIENTRY PATHOBJ_bPolyBezierTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    );

BOOL APIENTRY PATHOBJ_bCloseFigure(
    PVOID *ppo
    );

#define BMF_1BPP       1L
#define BMF_4BPP       2L
#define BMF_8BPP       3L
#define BMF_16BPP      4L
#define BMF_24BPP      5L
#define BMF_32BPP      6L
#define BMF_4RLE       7L
#define BMF_8RLE       8L
#define BMF_JPEG       9L
#define BMF_PNG       10L

#define QFD_GLYPHANDBITMAP                  1L
#define QFD_GLYPHANDOUTLINE                 2L
#define QFD_MAXEXTENTS                      3L
#define QFD_TT_GLYPHANDBITMAP               4L
#define QFD_TT_GRAY1_BITMAP                 5L
#define QFD_TT_GRAY2_BITMAP                 6L
#define QFD_TT_GRAY4_BITMAP                 8L
#define QFD_TT_GRAY8_BITMAP                 9L

#define QFD_TT_MONO_BITMAP QFD_TT_GRAY1_BITMAP
#define QFD_CT                              10L
#define QFD_CT_GRID                         11L
#define QFD_GLYPHANDBITMAP_SUBPIXEL         12L

// values for bMetricsOnly. even though declared as BOOL
// by adding TTO_QUBICS, this is becoming a flag field.
// For versions of NT 4.0 and earlier, this value is always
// set to zero by GDI.

#define TTO_METRICS_ONLY 1
#define TTO_QUBICS       2
#define TTO_UNHINTED     4

// values for ulMode:

#define QFF_DESCRIPTION     1L
#define QFF_NUMFACES        2L

//
// Kernel mode memory operations
//

#define FL_ZERO_MEMORY      0x00000001

VOID APIENTRY EngDebugBreak(
    VOID
    );


PVOID APIENTRY EngAllocMem(
    ULONG Flags,
    ULONG MemSize,
    ULONG Tag
    );

VOID APIENTRY EngFreeMem(
    PVOID Mem
    );

PVOID APIENTRY EngAllocUserMem(
    SIZE_T cj,
    ULONG tag
    );

VOID APIENTRY EngFreeUserMem(
    PVOID pv
    );

int APIENTRY EngMulDiv(
    int a,
    int b,
    int c
    );


VOID APIENTRY EngUnmapFontFileFD(
    ULONG_PTR iFile
    );


BOOL APIENTRY EngMapFontFileFD(
    ULONG_PTR  iFile,
    PULONG *ppjBuf,
    ULONG  *pcjBuf
    );

//
// Semaphores
//

DECLARE_HANDLE(HSEMAPHORE);

HSEMAPHORE APIENTRY EngCreateSemaphore(
    VOID
    );

VOID APIENTRY EngAcquireSemaphore(
    HSEMAPHORE hsem
    );

VOID APIENTRY EngReleaseSemaphore(
    HSEMAPHORE hsem
    );

VOID APIENTRY EngDeleteSemaphore(
    HSEMAPHORE hsem
    );


INT APIENTRY EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    );

VOID APIENTRY EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    );

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  //  _FONTDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c                                                  *
*                                                                          *
* "Methods" for operating on FONTCONTEXT and FONTFILE objects              *
*                                                                          *
* Created: 18-Nov-1990 15:23:10                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#define C_ANSI_CHAR_MAX 256

//HSEMAPHORE ghsemTTFD;



/******************************Public*Routine******************************\
*
* VOID vInitGlyphState(PGLYPHSTAT pgstat)
*
* Effects: resets the state of the new glyph
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vInitGlyphState(PGLYPHSTATUS pgstat)
{
    pgstat->hgLast  = HGLYPH_INVALID;
    pgstat->igLast  = 0xffffffff;
}



VOID vMarkFontGone(TTC_FONTFILE *pff, DWORD iExceptionCode)
{
    ULONG i;

    ASSERTDD(pff, "ttfd!vMarkFontGone, pff\n");

// this font has disappeared, probably net failure or somebody pulled the
// floppy with ttf file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;

        for( i = 0; i < pff->ulNumEntry ; i++ )
        {
            PFONTFILE pffReal;

        // get real pff.

            pffReal = PFF(pff->ahffEntry[i].hff);

        // if memoryBases 0,3,4 were allocated free the memory,
        // for they are not going to be used any more

            if (pffReal->pj034)
            {
                V_FREE(pffReal->pj034);
                pffReal->pj034 = NULL;
            }

        // if memory for font context was allocated and exception occured
        // after allocation but before completion of ttfdOpenFontContext,
        // we have to free it:

            if (pffReal->pfcToBeFreed)
            {
                V_FREE(pffReal->pfcToBeFreed);
                pffReal->pfcToBeFreed = NULL;
            }
        }
    }

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        //RIP("TTFD!this is probably a buggy ttf file\n");
    }
}

/**************************************************************************\
*
* These are semaphore grabbing wrapper functions for TT driver entry
* points that need protection.
*
*  Mon 29-Mar-1993 -by- Bodin Dresevic [BodinD]
* update: added try/except wrappers
*
*   !!! should we also do some unmap file clean up in case of exception?
*   !!! what are the resources to be freed in this case?
*   !!! I would think,if av files should be unmapped, if in_page exception
*   !!! nothing should be done
*
 *
\**************************************************************************/

HFF ttfdSemLoadFontFile (
    //ULONG cFiles,
    ULONG_PTR * piFile,
    ULONG       ulLangId
    )
{
    HFF       hff   = (HFF)NULL;
    ULONG_PTR iFile = *piFile;
    PVOID pvView;
    ULONG cjView;

    //  Remove hack that limits entries loaded to 1
    //if (cFiles != 1)
    //    return hff;

        if
        (!EngMapFontFileFD(
                iFile,
                (PULONG*)&pvView,
                &cjView
                )
        )
        return hff;

//    EngAcquireSemaphore(ghsemTTFD);

    try
    {
        BOOL bRet = bLoadFontFile(iFile, pvView, cjView, ulLangId, &hff);
        
        if (!bRet)
        {
            ASSERTDD(hff == (HFF)NULL, "LoadFontFile, hff not null\n");
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //WARNING("TTFD!_ exception in ttfdLoadFontFile\n");
        ASSERTDD(GetExceptionCode() == STATUS_IN_PAGE_ERROR,
                  "ttfdSemLoadFontFile, strange exception code\n");
        if (hff)
        {
            ttfdUnloadFontFileTTC(hff);
            hff = (HFF)NULL;
        }
    }

//    EngReleaseSemaphore(ghsemTTFD);

    EngUnmapFontFileFD(iFile);

    return hff;
}

BOOL ttfdSemUnloadFontFile(HFF hff)
{
    BOOL bRet;
//    EngAcquireSemaphore(ghsemTTFD);

    try
    {
        bRet = ttfdUnloadFontFileTTC(hff);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //WARNING("TTFD!_ exception in ttfdUnloadFontFile\n");
        bRet = FALSE;
    }

//    EngReleaseSemaphore(ghsemTTFD);
    return bRet;
}

BOOL bttfdMapFontFileFD(PTTC_FONTFILE pttc)
{
    return (pttc ? (EngMapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile,
                                     (PULONG*)&pttc->pvView,
                                     &pttc->cjView))
                 : FALSE);
}


LONG
ttfdSemQueryFontData (
    FONTOBJ     *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA   *pgd,
    PVOID       pv
    )
{
    LONG lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
//        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       0,
                       0
                       );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            //WARNING("TTFD!_ exception in ttfdQueryFontData\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
        
//        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}


LONG
ttfdSemQueryFontDataSubPos (
    FONTOBJ     *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA   *pgd,
    PVOID       pv,
    ULONG       subX,
    ULONG       subY
    )
{
    LONG lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
//        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       subX,
                       subY
                       );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            //WARNING("TTFD!_ exception in ttfdQueryFontData\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
        
//        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}



VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    )
{
//    EngAcquireSemaphore(ghsemTTFD);

    ttfdDestroyFont (
        pfo
        );

//   EngReleaseSemaphore(ghsemTTFD);
}




LONG
ttfdSemGetTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PBYTE  *ppjTable,// ptr to table in mapped font file
    ULONG  *pcjTable // size of the whole table in the file
    )
{
    LONG lRet;
    lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)hff))
    {
//        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryTrueTypeTable (
                        hff,
                        ulFont,  // always 1 for version 1.0 of tt
                        ulTag,   // tag identifying the tt table
                        0, // offset into the table
                        0,   // size of the buffer to retrieve the table into
                        NULL,   // ptr to buffer into which to return the data
                        ppjTable,
                        pcjTable
                        );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            //WARNING("TTFD!_ exception in ttfdQueryTrueTypeTable\n");
            vMarkFontGone((TTC_FONTFILE *)hff, GetExceptionCode());
        }
    
        if (lRet == FD_ERROR)
            EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);

//        EngReleaseSemaphore(ghsemTTFD);

    }

    return lRet;
}

void
ttfdSemReleaseTrueTypeTable (
    HFF     hff
    )
{
        EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\gdistubs.c ===
/******************************Module*Header*******************************\
* Module Name: fd-stubs.c                                                  *
*                                                                          *
* Stubs for tricking GDI font files into compiling                         *
*                                                                          *
* Created: 1-June-1999                                                     *
* Author: Cameron Browne                                                   *
*                                                                          *
* Copyright (c) 1999 Microsoft Corporation                                 *
\**************************************************************************/


#include "fd.h"
//#include "fdsem.h"
//#include "dbg.h"
//#include "fdfc.h"
#include "fontddi.h"   // modified subset of winddi.h

#include <Math.h> /* for sqrt */

#include "..\..\..\runtime\mem.h"

#if 0
void * __stdcall GpMalloc( size_t size );
void * __stdcall GpRealloc( void *memblock, size_t size );
void __stdcall GpFree( void *memblock );
#endif

HSEMAPHORE APIENTRY EngCreateSemaphore(
    VOID
    )
{
    return NULL;
}

VOID APIENTRY EngAcquireSemaphore(
    HSEMAPHORE hsem
    )
{
}


VOID APIENTRY EngReleaseSemaphore(
    HSEMAPHORE hsem
    )
{
}

VOID APIENTRY EngDeleteSemaphore(
    HSEMAPHORE hsem
    )
{
}

VOID APIENTRY EngDebugBreak(
    VOID
    )
{
    RIP( ("TrueType font driver debug break"));
}

PVOID APIENTRY EngAllocMem(
    ULONG Flags,
    ULONG MemSize,
    ULONG Tag
    )
{
    return GpMalloc(MemSize);
}

VOID APIENTRY EngFreeMem(
    PVOID Mem
    )
{
    GpFree(Mem);
}

PVOID APIENTRY EngAllocUserMem(
    SIZE_T cj,
    ULONG tag
    )
{
    return GpMalloc(cj);
}

VOID APIENTRY EngFreeUserMem(
    PVOID pv
    )
{
    GpFree(pv);
}

int APIENTRY EngMulDiv(
    int a,
    int b,
    int c
    )
{
    LONGLONG ll;
    int iSign = 1;

    if (a < 0)
    {
        iSign = -iSign;
        a = -a;
    }
    if (b < 0)
    {
        iSign = -iSign;
        b = -b;
    }

    if (c != 0)
    {
        if (c < 0)
        {
            iSign = -iSign;
            c = -c;
        }

        ll = (LONGLONG)a;
        ll *= b;
        ll += (c/2); // used to add (c+1)/2 which is wrong
        ll /= c;

    // at this point ll is guaranteed to be > 0. Thus we will do
    // unsigned compare in the next step which generates two less instructions
    // on x86 [bodind]

        if ((ULONGLONG)ll > (ULONG)INT_MAX) // check for overflow:
        {
            if (iSign > 0)
                return INT_MAX;
            else
                return INT_MIN;
        }
        else
        {
            if (iSign > 0)
                return ((int)ll);
            else
                return (-(int)ll);
        }
    }
    else
    {
//        ASSERTGDI(c, "EngMulDiv - c == 0\n");
//        ASSERTGDI(a | b, "EngMulDiv - a|b == 0\n");

        if (iSign > 0)
            return INT_MAX;
        else
            return INT_MIN;
    }
}

BOOL APIENTRY EngLpkInstalled()
{
    return FALSE;
}

/******************************Public*Routine******************************\
*
* bFDXform, transform an array of points, output in POINTFIX
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/
#define FIX4_PRECISION  4
#define FIX4_ONE        (1 << FIX4_PRECISION)

FIX RealToPointFix(
    EFLOAT        realValue
    )
{
    return (FIX)(realValue * FIX4_ONE);
}


BOOL bFDXform(
    XFORML    *pxf
  , POINTFIX *pptfxDst
  , POINTL   *pptlSrc
  , SIZE_T    c
    )
{
    BOOL bRet;
    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    bRet = FALSE;

    if ( ef12 == 0.0 && ef21 == 0.0) {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {

            EFLOAT ef;

            ef = (EFLOAT)pptlSrc->x;
            ef *= ef11;
            pptfxDst->x = RealToPointFix( ef );

			ef = (EFLOAT)pptlSrc->y;
            ef *= ef22;
            pptfxDst->y = RealToPointFix( ef );
        }
        bRet = TRUE;
    } else {
        for ( ; c ; pptfxDst++, pptlSrc++, c--) {
            EFLOAT efX;
            EFLOAT efY;
            EFLOAT ef1;
            EFLOAT ef2;

            efX = (EFLOAT)pptlSrc->x;
            efY = (EFLOAT)pptlSrc->y;

            ef1  = efX;
            ef1 *= ef11;
            ef2  = efY;
            ef2 *= ef21;
            ef2 += ef1;

            pptfxDst->x = RealToPointFix( ef2 );

            ef1  = efX;
            ef1 *= ef12;
            ef2  = efY;
            ef2 *= ef22;
            ef2 += ef1;

            pptfxDst->y = RealToPointFix( ef2 );
        }
        bRet = TRUE;
    }
    return( bRet );
}

/******************************Public*Routine******************************\
*
* bXformUnitVector
*
* xform vector by pfdxo, compute the unit vector of the transformed
* vector and the norm of the transformed vector. Norm and the transformed
* vector are multiplied by 16 so that when converting to long the result
* will acutally be a 28.4 fix
*
* Effects:
*
* Warnings:
*
* History:
*  01-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bXformUnitVector(
      POINTL *pptl           // IN  incoming unit vector
 ,    XFORML *pxf            // IN  xform to use
 ,    EFLOAT *pefNorm        // OUT |*pptqXormed|
    )
{
    EFLOAT efX_;
    EFLOAT efY_;
    BOOL b = TRUE;

    EFLOAT ef11;
    EFLOAT ef12;
    EFLOAT ef21;
    EFLOAT ef22;
    EFLOAT efX;
    EFLOAT efY;
    //
    // Convert longs to FIX point
    //

    efX = (EFLOAT)16.0 * (EFLOAT)pptl->x;
    efY = (EFLOAT)16.0 * (EFLOAT)pptl->y;

    //
    // Convert the matrix elements from FLOAT to EFLOAT
    //

    ef11 = pxf->eM11;
    ef12 = pxf->eM12;
    ef21 = pxf->eM21;
    ef22 = pxf->eM22;

    //
    // Transform the vector and put the result in efX_ and efY_
    //

    if ( ef12 == 0.0 && ef21== 0.0 ) {
        efX_  = efX;
        efX_ *= ef11;
        efY_  = efY;
        efY_ *= ef22;
    } else {
        EFLOAT ef;

        efX_  = efX;
        efX_ *= ef11;
        ef    = efY;
        ef   *= ef21;
        efX_ += ef;

        ef    = efX;
        ef   *= ef12;
        efY_  = efY;
        efY_ *= ef22;
        efY_ += ef;
    }

    // get the norm

    efX_ *= efX_;
    efY_ *= efY_;
    efX_ += efY_;
    efX_ = (EFLOAT)sqrt(efX_);

    *pefNorm = efX_;

    return b; 
}

/******************************Public*Routine******************************\
*
* vLTimesVtfl
*
* Effects:
*
* Warnings:
*
* History:
*  05-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
POINTQF  *pptq
)
{
    LONGLONG dx, dy;

//    EVECTORFL  vtfl;
//    EFLOAT     ef; ef = l;
//    vtfl.x.eqMul(pvtfl->x,ef);
//    vtfl.y.eqMul(pvtfl->y,ef);

    dx = (LONGLONG)(pvtfl->x * (EFLOAT)l);
    dy = (LONGLONG)(pvtfl->y * (EFLOAT)l);

    pptq->x.HighPart = (LONG) (((LARGE_INTEGER*)(&dx))->LowPart);
    pptq->x.LowPart = 0;
    pptq->y.HighPart = (LONG) (((LARGE_INTEGER*)(&dy))->LowPart);
    pptq->y.u.LowPart = 0;

// convert to 28.36 format. The incoming vector will already have been
// multliplied by 16 to ensure that the result is in the 28.36

//    *pptq = vtfl;
}

#if defined(_X86_)

VOID   vLToE(FLOATL * pe, LONG l)
{
    *pe = (FLOATL)l;
}

#endif // _X86_



/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Converts an IEEE 747 float to a LONG. The form of the conversion is      *
* specified by the caller.                                                 *
*                                                                          *
*  Arguments                                                               *
*                                                                          *
*      e                    IEEE 747 32-bit float to be converted          *
*                                                                          *
*      pl                   pointer to where answer should be placed       *
*                                                                          *
*      lType                contains bits specifying the type of           *
*                           conversion to be done this can be any          *
*                           combination of the following bits:             *
*                                                                          *
*                           CV_TO_FIX   if this bit is set then            *
*                                       the answer should                  *
*                                       should be in the form              *
*                                       of a 28.4 fix point number         *
*                                       otherwise the answer is            *
*                                       to be interpreted as a 32-bit      *
*                                       LONG                               *
*                                                                          *
*                           CV_TRUNCATE if this bit is set then the        *
*                                       answer is floor(e)                 *
*                                       (if CV_TO_FIX is not set) or       *
*                                       floor(16 * e)                      *
*                                       (if CV_TO_FIX is set)              *
*                                                                          *
*  Theory                                                                  *
*                                                                          *
*  An IEEE 747 float is contained in 32 bits which for the                 *
*  purposes of this discussion I shall call "e". e is                      *
*  equivalent to                                                           *
*                                                                          *
*      e = (-1)^s * mu * 2^E                                               *
*                                                                          *
*  s is the sign bit that is contained in the 31'st bit of e.              *
*  mu is the mantissa and E is the exponetial. These are obtained          *
*  from e in the following way.                                            *
*                                                                          *
*      s = e & 0x80000000 ? -1 : 1                                         *
*                                                                          *
*      mu = M * 2^-23      // 2^23 <= M < 2^24                             *
*                                                                          *
*      M = 0x800000 | (0x7FFFFF & e)                                       *
*                                                                          *
*      E = ((0x7F800000 & e) * 2^-23) - 127                                *
*                                                                          *
*  Suppose the 32.32 Fix point number is Q, then the relation              *
*  between the float and the 32.32 is given by                             *
*                                                                          *
*      Q = e * 2^32 = s * M * 2^(E+9)                                      *
*                                                                          *
* History:                                                                 *
*  Tue 15-Aug-1995 10:36:31 by Kirk Olynyk [kirko]                         *
* Rewrote it                                                               *
*                                                                          *
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

#define CV_TRUNCATE     1
#define CV_ROUNDOFF     2
#define CV_TO_LONG      4
#define CV_TO_FIX       8

BOOL bFToL(FLOAT e, PLONG pl, LONG lType)
{
    LONGLONG Q;         // 32.32 repn of abs(e)
    LONG E;             // used to hold exponent then integer parts
    LONG le;            // bit identical to FLOAT argument e
    BOOL bRet = TRUE;   // return value

    le = *(LONG*)&e;                                    // get IEEE 747 bits
    E = (int) (((0x7f800000 & le) >> 23) - 127) + 9;    // E = exponent
    if (lType & CV_TO_FIX)                              // if (want FIX point)
        E += 4;                                         //     multiply by 16
    if (E > (63-23))                                    // if (overflow)
    {                                                   //     bail out
        bRet = FALSE;
    }
    else
    {
        Q = (LONGLONG) (0x800000 | (0x7FFFFF & le));    // abs val of mantissa
        Q = (E >= 0) ? Q << E : Q >> -E;                // account for exponent
        if (!(lType & CV_TRUNCATE))                     // if (rounding) then
            Q += 0x80000000;                            //     add 1/2
        E = (long) (Q >> 32);                           // E = abs(integer part)
        *pl = (le < 0) ? -E : E;                        // fix up sign
    }
    return(bRet);
};



LONG lCvt(FLOAT f,LONG l)
{
    LONG l_ = 0;
    bFToL(f * l, &l_, 0);
    return(l_);
}

FIX  fxLTimesEf
(
EFLOAT *pef,
LONG    l
)
{
// *pef is a norm, already multiplied by 16 to ensure that the result
// is in 28.4 format

    l = lCvt((*pef), l);
    return (FIX)l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\service.h ===
/******************************Module*Header*******************************\
* Module Name: service.h
*
* routines in service.c
*
* Created: 15-Nov-1990 13:00:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c);


VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
);

VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\mapfile.h ===
/******************************Module*Header*******************************\
* Module Name: os.h
*
* Created: 26-Oct-1990 18:07:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/


// warning the first two fields of FILEVIEW and FONTFILE view must be
// the same so that they can be used in common routines

typedef struct _FONTFILEVIEW {
   ULARGE_INTEGER  LastWriteTime;   // time stamp
            ULONG  mapCount;
            PVOID  pvView;          // font driver process view of file
            ULONG  cjView;          // size of font file view in bytes
           LPWSTR  pwszPath;        // path of the file
        // HANDLE     hFile;
        // HANDLE     hMapping;
} FONTFILEVIEW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* FONTFILE and FONTCONTEXT objects
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/


#include "xform.h"


// cjIFI - size of the whole ifimetrics struct, with all strings appended
// cjFamilyName
// cjFaceName
// cjUniqueName
// cjSubfamilyName


typedef struct _IFISIZE  // ifisz
{
    ULONG cjIFI;
    ULONG dpSims;          // offset of the FONTSIM struct
    PBYTE pjFamilyName;    // pointer to the location in the ttf file
    ULONG cjFamilyName;
    USHORT langID;
    PBYTE pjFamilyNameAlias;    // pointer to the location in the ttf file
    ULONG cjFamilyNameAlias;
    USHORT aliasLangID;
    PBYTE pjSubfamilyName; // pointer to the location in the ttf file
    ULONG cjSubfamilyName;
    PBYTE pjUniqueName;    // pointer to the location in the ttf file
    ULONG cjUniqueName;
    PBYTE pjFullName;      // pointer to the location in the ttf file
    ULONG cjFullName;
} IFISIZE, *PIFISIZE;


typedef struct _FONTFILE       *PFONTFILE;     // pff
typedef struct _FONTCONTEXT    *PFONTCONTEXT;  // pfc
typedef struct _TTC_FONTFILE   *PTTC_FONTFILE; // pttc


// in the debug version of the rasterizer STAMPEXTRA shoud be added to the
// sizes. strictly speaking this is illegal, but nevertheless very useful.
// it assumes the knowlege of rasterizer internalls [bodind],
// see fscaler.c

#define STAMPEXTRA 4


#define CJ_0  NATURAL_ALIGN(sizeof(fs_SplineKey) + STAMPEXTRA)

#define FF_EXCEPTION_IN_PAGE_ERROR 1

// set if any DBCS charset is supported

#define FF_DBCS_CHARSET        256

typedef struct _FFCACHE
{
//
// Move it from FONTFILE. We will cache it into TTCACHE.
//

    TABLE_POINTERS  tp;

    ULONG           ulTableOffset;

// FE vertical facename support

    ULONG           ulVerticalTableOffset; 
    uint16          uLongVerticalMetrics;

    ULONG           ulNumFaces;       // 1 or at most 2 if this is a FE font, (foo and @foo)

    ULONG           cj3;     // request memorySizes[3],   
    ULONG           cj4;     // request memorySizes[4],     

// some general flags, for now only exception info, such as in_page_err

    FLONG           fl;

    ULONG           dpMappingTable;

// make it simple to access the ttf file

    uint16          ui16EmHt;
    uint16          ui16PlatformID;
    uint16          ui16SpecificID;
    uint16          ui16LanguageID;

} FFCACHE;

typedef struct _FONTFILE    // ff
{
    PTTC_FONTFILE pttc;


    GP_PIFIMETRICS pifi_vertical;

    PBYTE        pj034;   // 0,3,4 buffers
    PFONTCONTEXT pfcLast; // last fc that set 034 buffers

// mem to be freed if file disappeared while trying to open font context
// only used in exception scenarios

    PFONTCONTEXT pfcToBeFreed;

    ULONG cRef;    // # no of times this font file is selected into fnt context

    ULONG_PTR iFile; // contains a pointer
    PVOID  pvView;   // contains the pointer to the top of ttf
    ULONG  cjView;  // contains size of the font file

    FFCACHE ffca;

// Note:
// The way memory is allocated for the FONTFILE structure, the IFIMETRICS
// MUST BE THE LAST ELEMENT of the structure!

    GP_IFIMETRICS   ifi;         //!!! should it not this be put on the disk??? [bodind]

} FONTFILE;


typedef struct _TTC_CACHE
{
    FLONG       flTTCFormat;
    ULONG       cTTFsInTTC;       // number of TTF's in this TTC (or one if this is a TTF file)
    DWORD       dpTTF[1];         // there will be cTTFsInTTC of these offsets in the array
} TTC_CACHE,    *PTTC_CACHE;

// we will have one of these for every TTF in a TTC. Therefore ulNumFaces can be at most 2,
// for foo and @foo faces. cjIFI is the size of either IFIMETRICS corresponding
// to foo or @foo faces (we allocate the same size for foo and @foo IFIMETRICS structures).
// cjIFI is is NOT the sum of the sizes of the two IFIMETRICS.

typedef struct _TTF_CACHE
{
    FFCACHE      ffca;       // shared data between foo and @foo faces

// we store the ifimetrics for foo face starting here, followed by the the ifimetrics for
// @foo face if there is one, followed by gset for foo face. For now we do not store gsetv,
// but compute it dynamically

    double      acIfi[1];    // really a byte array but now compiler guarantees QUAD alignment

} TTF_CACHE, *PTTF_CACHE;

// the values for iSearchVerticalGlyph

#define SUB_FUNCTION_DUMMY 0
#define SUB_FUNCTION_GSUB  1
#define SUB_FUNCTION_MORT  2

//
// TrueType collection 'ttc' font file support
//

typedef struct _TTC_HFF_ENTRY
{
    ULONG     ulOffsetTable;
    ULONG     iFace;
    HFF       hff;
} TTC_HFF_ENTRY, *PTTC_HFF_ENTRY;

typedef struct _TTC_FONTFILE    // ttcff
{
    ULONG         cRef;
    FLONG         fl;
    ULONG         ulTrueTypeResource;
    ULONG         ulNumEntry;
    PVOID         pvView;
    ULONG         cjView;
    TTC_HFF_ENTRY ahffEntry[1];
} TTC_FONTFILE, *PTTC_FONTFILE;


#define CJ_IN      NATURAL_ALIGN(sizeof(fs_GlyphInputType))
#define CJ_OUT     NATURAL_ALIGN(sizeof(fs_GlyphInfoType))


/**************************************************************************\

         GLYPHSTATUS structure

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

\**************************************************************************/

typedef struct _GLYPHSTATUS
{
    HGLYPH hgLast;
    ULONG  igLast;       // corresponding glyph index, rasterizer likes it better
    PVOID  pv;           // pointer to mem allocated just for the purpose of
                         // or producing bitmap or the outline for this glyph
} GLYPHSTATUS, *PGLYPHSTATUS;

// "method" acting on this "object"

VOID vInitGlyphState(PGLYPHSTATUS pgstat);

// HDMX stuff, from fd_royal.h in win31 sources:

typedef struct
{
  BYTE     ucEmY;
  BYTE     ucEmX;          // MAX advance width for this EmHt;
  BYTE     aucInc [1];     // maxp->numGlyphs of entries
} HDMXTABLE;        // hdmx

typedef struct
{
  uint16            Version;    // table version number, starts at zero
  uint16            cRecords;
  uint32            cjRecord;   // dword aligned size of individual record,
                                // all of them have the same size

// after this records follow:

  // HDMXTABLE         HdmxTable [cRecords]
} HDMXHEADER;  // hdhdr

// to get to the next record one does the following:
// phdmx = (HDMXTABLE *)((BYTE *)phdmx + phdhdr->cjRecord);

// 'gasp' structures

typedef struct
{
    uint16  rangeMaxPPEM;
    uint16  rangeGaspBehavior;
} GASPRANGE;

typedef struct
{
    uint16  version;
    uint16  numRanges;
    GASPRANGE   gaspRange[1];
} GASPTABLE;

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002

/**************************************************************************\
 *  FONTCONTEXT structure
\**************************************************************************/

typedef struct _FONTCONTEXT     // fc
{
    FONTOBJ*  pfo;          // points back to calling FONTOBJ
    PFONTFILE pff;          // handle of the font file selected into this context

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

    GLYPHSTATUS gstat;

// parts of FONTOBJ that are important

    FLONG   flFontType;
    SIZE    sizLogResPpi;
    ULONG   ulStyleSize;

// transform matrix in the format as requested by the font scaler
// the FONTOBJ and XFORMOBJ (in the form of the XFORM) fully specify
// the font context for the realization

    XFORML      xfm;          // cached xform
    transMatrix mx;           // the same as above, just a different format
    FLONG       flXform;

// if it were not for win31 vdmx hacks this field would not be necessary,

    LONG   lEmHtDev;          // em height in pixels in device space
    Fixed  fxPtSize;          // em height in points on the rendering device

// pointer to the hdmx table that applies if any, else NULL

    HDMXTABLE *phdmx;

// asc and desc measured along unit ascender vector in device coords.
// Unit ascender vector in device coords == xForm(0,-1)/|xForm(0,-1)|

    LONG  lAscDev;
    LONG  lDescDev;

// xMin and xMax in device coords for grid fitted glyphs, cxMax = xMax - xMin

    LONG  xMin;
    LONG  xMax;

// asender and descender in device coords for grid fitted glyphs
// cyMax = yMax - yMin;

    LONG  yMin;
    LONG  yMax;

// max width in pixels of all rasterized bitmaps

    ULONG cxMax;
    ULONG cyMax;

// the size of the GLYPHDATA structure necessary to store the largest
// glyph bitmap with the header info. This is value is cashed at the
// time the font context is opened and used later in FdQueryGlyphBitmap

    ULONG cjGlyphMax;  // in BYTE's

// tt structures, they live in pff->cj034

    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    PTABLE_POINTERS     ptp;

// a few fields that are realy only necessary if the xform is
// non trivial, cached here to speed up metric computations for glyphs:

    EFLOAT   efBase;        // |ptqBase|, enough precission

    EFLOAT   efSide;        // |ptqSide|, enough precission

    Fixed    pointSize;     // for fs_NewTransformation

// for font emboldening, most glyphs will use global emboldening info,
// only those glyphs which extend to descender will have to
// use different emb.

    USHORT  dBase;

// TrueType Rasterizer 1.7 require the overScale (for antialiazed text) to be passed to fs_NewTransformation
// we need to keep track of this value to pass it at fs_NewTransform

	USHORT  overScale;

    Fixed   subPosX;
    Fixed   subPosY;

} FONTCONTEXT;

/* fc->overscale get first set to FF_UNDEFINED_OVERSCALE and at fs_NewTransform get set to the current one */
#define FF_UNDEFINED_OVERSCALE 0x0FFFF

// flags describing the transform, may change a bit,
// quantized bit means that the original xform has been
// changed a bit to take into account vdmx quantization

#define XFORM_HORIZ           1
#define XFORM_VERT            2
#define XFORM_VDMXEXTENTS     4
#define XFORM_SINGULAR        8
#define XFORM_2PPEM	     32
#define XFORM_BITMAP_SIM_BOLD  128


// basic "methods" that act on the FONTFILE object  (in fontfile.c)

#define   PFF(hff)      ((PFONTFILE)hff)
#define   pffAlloc(cj)  ((PFONTFILE)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFF(hff)  EngFreeMem((PVOID)hff)

// basic "methods" that act on the TTC_FONTFILE object

#define   PTTC(httc)     ((PTTC_FONTFILE)httc)
#define   pttcAlloc(cj)  ((PTTC_FONTFILE)EngAllocMem(FL_ZERO_MEMORY, cj, 'dftT'))
#define   vFreeTTC(httc) V_FREE(httc)

// basic "methods" that act on the FONTCONTEXT object  (in fontfile.c)

#define   PFC(hfc)      ((PFONTCONTEXT)hfc)
#define   pfcAlloc(cj)  ((PFONTCONTEXT)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFC(hfc)  EngFreeMem((PVOID)hfc)

#define   V_FREE(pv)    EngFreeMem((PVOID)pv)
#define   PV_ALLOC(cj)  EngAllocMem(0, cj, 'dftT')

// New added Pv_Realloc used in robust rasterizer

PVOID   Pv_Realloc(PVOID pv, LONG newSzie, LONG oldSize);

// Robust rasterizer need malloc, free & realloc
// NT kernel can not support realloc, we got to implement by ourselves
#define FST_MALLOC PV_ALLOC
#define FST_FREE V_FREE
#define FST_REALLOC Pv_Realloc

// Robust rasterizer assertion
#ifdef DBG
#define FSTAssert(exp, str) ASSERTDD(exp, str)
#else
#define FSTAssert(exp,str)
#endif

// tt required functions, callbacks

// I hate to have this function defined like this [bodind],

voidPtr FS_CALLBACK_PROTO pvGetPointerCallback    (ULONG_PTR  clientID, long dp, long cjData);
void    FS_CALLBACK_PROTO vReleasePointerCallback (voidPtr pv);

BOOL bGetFastAdvanceWidth(FONTCONTEXT *, ULONG, FIX *);


//
// Data types allocated dynamically:
//
//  ID_KERNPAIR dynamically allocated array of FD_KERNINGPAIR structures
//

#define UNHINTED_MODE(pfc)       (pfc->flFontType & (FO_MONO_UNHINTED | FO_SUBPIXEL_4 | FO_CLEARTYPE))
#define IS_CLEARTYPE_NATURAL(pfc)       ((pfc->flFontType & FO_CLEARTYPE_GRID) && !(pfc->flFontType & FO_COMPATIBLE_WIDTH))
#define IS_CLEARTYPE(pfc)       ((pfc->flFontType & FO_CLEARTYPE_GRID) || (pfc->flFontType & FO_CLEARTYPE))


#define CJGD(w,h,p)                                                      \
  ALIGN4(offsetof(GLYPHBITS,aj)) +                                       \
  ALIGN4((h)*(((p)->flFontType & FO_GRAYSCALE)?((IS_CLEARTYPE(pfc) || (pfc->flFontType & FO_SUBPIXEL_4))?(w):(((w)+1)/2)):(((w)+7)/8)))

LONG lExL(FLOATL e, LONG l);


VOID vCharacterCode (PFONTFILE pff, HGLYPH hg, fs_GlyphInputType *pgin);
BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH, ULONG*, FLONG, FS_ENTRY*);


VOID vLONG_X_POINTQF(LONG lIn, POINTQF *ptqIn, POINTQF *ptqOut);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\tt.h ===
/******************************Module*Header*******************************\
* Module Name: tt.h
*
*  interface to the font scaler. Also defines some macros that should
* have been defined in the scaler *.h files
*
* Created: 17-Nov-1991 15:56:21
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



// turns out that some of the macros that follow are already defined
// in some of the top include files that precede tt.h. Worse, these
// macros are defined DIFFERENTLY than in tt.h.
// We want to enforce that these macros when used in ttfd have the meaning
// defined in tt include files so that we have to kill the definitions
// inherited from anywhere else.


//!!! maybe this should go to scaler\config.h !!!!!!!!

#ifdef SWAPL
#undef SWAPL
#endif

#ifdef SWAPW
#undef SWAPW
#endif

// defined earlier, turns on the garbage in fserror.h

#ifdef XXX
#undef XXX
#endif

// defined earlier, use tt definition

#ifdef HIWORD
#undef HIWORD
#endif

// defined earlier, use tt definition

#ifdef LOWORD
#undef LOWORD
#endif

#include "FSERROR.H"
#include "FSCDEFS.H"    // inlcudes fsconfig.h
#include "FONTMATH.H"
#include "SFNT.H"       // includes sfnt_en.h
#include "FNT.H"
#include "INTERP.H"
#include "FNTERR.H"
#include "SFNTACCS.H"
#include "FSGLUE.H"
#include "SCENTRY.H"
#include "SBIT.H"
#include "FSCALER.H"
#include "SCGLOBAL.H"
#include "SFNTOFF.H"

// allowed specific ID's

#define SPEC_ID_UNDEFINED    0   // undefined char set or indexing scheme
#define SPEC_ID_UGL          1   // UGL char set with UNICODE indexing
#define SPEC_ID_SHIFTJIS     2   // SHIFTJIS mapping
#define SPEC_ID_GB           3   // GB mapping
#define SPEC_ID_BIG5         4   // BIG5 mapping
#define SPEC_ID_WANSUNG      5   // Hangeul WANSUNG mapping

// the same but in big endian format

#define BE_SPEC_ID_UNDEFINED    0x0000   // undefined char set or indexing scheme
#define BE_SPEC_ID_UGL          0x0100   // UGL char set with UNICODE indexing
#define BE_SPEC_ID_SHIFTJIS     0x0200   // SHIFTJIS mapping
#define BE_SPEC_ID_GB           0x0300   // GB mapping
#define BE_SPEC_ID_BIG5         0x0400   // BIG5 mapping
#define BE_SPEC_ID_WANSUNG      0x0500   // Hangeul WANSUMG mapping

// platform id's, this is copied from sfnt_en.h

/*
*
* typedef enum {
*     plat_Unicode,
*     plat_Macintosh,
*     plat_ISO,
*     plat_MS
* } sfnt_PlatformEnum;
*
*/

#define  PLAT_ID_UNICODE   0
#define  PLAT_ID_MAC       1
#define  PLAT_ID_ISO       2
#define  PLAT_ID_MS        3

// the same but in big endian format

#define  BE_PLAT_ID_UNICODE   0x0000
#define  BE_PLAT_ID_MAC       0x0100
#define  BE_PLAT_ID_ISO       0x0200
#define  BE_PLAT_ID_MS        0x0300


// language id's that are required to exhist in a ttf file:

#define LANG_ID_USENGLISH   0X0409  // for microsoft records
#define LANG_ID_MAC         0       // ENGLISH FOR MAC RECORDS

// the same but in big endian format

#define BE_LANG_ID_USENGLISH   0X0904  // for microsoft records
#define BE_LANG_ID_MAC         0X0000  // ENGLISH FOR MAC RECORDS


// allowed format values of the cmap tables:

#define BE_FORMAT_MAC_STANDARD      0X0000
#define BE_FORMAT_HIGH_BYTE         0X0200
#define BE_FORMAT_MSFT_UNICODE      0X0400
#define BE_FORMAT_TRIMMED           0X0600


/*
*
* typedef enum {
*     name_Copyright,
*     name_Family,
*     name_Subfamily,
*     name_UniqueName,
*     name_FullName,
*     name_Version,
*     name_Postscript
* } sfnt_NameIndex;
*
*/

#if  0

#define NAME_ID_COPYRIGHT   0
#define NAME_ID_FAMILY      1
#define NAME_ID_SUBFAMILY   2
#define NAME_ID_UNIQNAME    3
#define NAME_ID_FULLNAME    4
#define NAME_ID_VERSION     5
#define NAME_ID_PSCRIPT     6
#define NAME_ID_TRADEMARK   7

#endif

// there are 19 tables (10 required + 9 optianal) defined in 1.0 revision
// of tt spec. We define this cut off arbitrarily (but bigger than 19)
// to get out of the loops rather than sit there and die;


#define MAX_TABLES 128

// size of some sfnt_xxx Structures as they are layed out on the disk:

#define SIZE_DIR_ENTRY        16
#define SIZE_NAMING_TABLE     6
#define SIZE_NAME_RECORD      12

// offsets into OS2 metrics table. Significant enough to be done by hand
// to ensure portability:

// original structure (from sfnt.h), version 0

/*
*
*
*   typedef struct {
*       uint16  Version;
*       int16   xAvgCharWidth;
*       uint16  usWeightClass;
*       uint16  usWidthClass;
*       int16   fsType;
*       int16   ySubscriptXSize;
*       int16   ySubscriptYSize;
*       int16   ySubscriptXOffset;
*       int16   ySubscriptYOffset;
*       int16   ySuperScriptXSize;
*       int16   ySuperScriptYSize;
*       int16   ySuperScriptXOffset;
*       int16   ySuperScriptYOffset;
*       int16   yStrikeOutSize;
*       int16   yStrikeOutPosition;
*       int16   sFamilyClass;
*       uint8   Panose [10];
*       uint32  ulCharRange [4];
*       char    achVendID [4];
*       uint16  usSelection;
*       uint16  usFirstChar;
*       uint16  usLastChar;
*   } sfnt_OS2;
*
*/



#define     OFF_OS2_Version               0
#define     OFF_OS2_xAvgCharWidth         2
#define     OFF_OS2_usWeightClass         4
#define     OFF_OS2_usWidthClass          6
#define     OFF_OS2_fsType                8
#define     OFF_OS2_ySubscriptXSize       10
#define     OFF_OS2_ySubscriptYSize       12
#define     OFF_OS2_ySubscriptXOffset     14
#define     OFF_OS2_ySubscriptYOffset     16
#define     OFF_OS2_ySuperScriptXSize     18
#define     OFF_OS2_ySuperScriptYSize     20
#define     OFF_OS2_ySuperScriptXOffset   22
#define     OFF_OS2_ySuperScriptYOffset   24
#define     OFF_OS2_yStrikeOutSize        26
#define     OFF_OS2_yStrikeOutPosition    28
#define     OFF_OS2_sFamilyClass          30
#define     OFF_OS2_Panose                32
#define     OFF_OS2_ulCharRange           42
#define     OFF_OS2_achVendID             58
#define     OFF_OS2_usSelection           62
#define     OFF_OS2_usFirstChar           64
#define     OFF_OS2_usLastChar            66


// these fields are defined in the spec but not in the sfnt.h structure above.
// I shall have to check whether these really exhist in tt files or not

#define     OFF_OS2_sTypoAscender         68
#define     OFF_OS2_sTypoDescender        70
#define     OFF_OS2_sTypoLineGap          72
#define     OFF_OS2_usWinAscent           74
#define     OFF_OS2_usWinDescent          76

// these two are added for version 200

#define     OFF_OS2_ulCodePageRange1      78
#define     OFF_OS2_ulCodePageRange2      82




// #define SIZE_OS2                        86

// values of some flags of the flag fields of the OS2 structure
//            taken from the tt spec


// fsType flags, notice bit 0x0001 is not used

#define TT_FSDEF_LICENSED        0x0002
#define TT_FSDEF_READONLY_ENCAPS 0x0004
#define TT_FSDEF_EDITABLE_ENCAPS 0x0008

#define TT_FSDEF_MASK  (TT_FSDEF_LICENSED|TT_FSDEF_READONLY_ENCAPS|TT_FSDEF_EDITABLE_ENCAPS)

// usSelection

#define TT_SEL_ITALIC            0x0001
#define TT_SEL_UNDERSCORE        0x0002
#define TT_SEL_NEGATIVE          0x0004
#define TT_SEL_OUTLINED          0x0008
#define TT_SEL_STRIKEOUT         0x0010
#define TT_SEL_BOLD              0x0020
#define TT_SEL_REGULAR           0x0040

//
// Macro to extract the big endian word at pj, really
// the correct equivalent of SWAPW macro, which does not assume
// that pj is word aligned.
//

#define BE_UINT16(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )


#define BE_INT16(pj)  ((SHORT)BE_UINT16(pj))


//
// macro to extract the big endian dword at pj, really
// a the correct equivalent of SWAPL macro, which does not assume
// that pj is DWORD aligned
//


#define BE_UINT32(pj)                                              \
    (                                                              \
        ((ULONG)BE_UINT16(pj) << 16) |                             \
        (ULONG)BE_UINT16((PBYTE)(pj) + 2)                          \
    )


#define BE_INT32(pj) ((LONG)BE_UINT32(pj))

// number of tt tables may change as we decide to add more tables to
// tt files, this list is extracted from sfnt_en.h

// required tables

//   tag_CharToIndexMap              // 'cmap'    0
//   tag_GlyphData                   // 'glyf'    1
//   tag_FontHeader                  // 'head'    2
//   tag_HoriHeader                  // 'hhea'    3
//   tag_HorizontalMetrics           // 'hmtx'    4
//   tag_IndexToLoc                  // 'loca'    5
//   tag_MaxProfile                  // 'maxp'    6
//   tag_NamingTable                 // 'name'    7
//   tag_Postscript                  // 'post'    8
//   tag_OS_2                        // 'OS/2'    9

// optional

//   tag_ControlValue                // 'cvt '    11
//   tag_FontProgram                 // 'fpgm'    12
//   tag_HoriDeviceMetrics           // 'hdmx'    13
//   tag_Kerning                     // 'kern'    14
//   tag_LSTH                        // 'LTSH'    15
//   tag_PreProgram                  // 'prep'    16
//   tag_GridfitAndScanProc          // 'gasp'    21
//   tag_BitmapLocation              // 'EBLC'    

//!!! not in the tt spec, but in defined in sfnt_en.h

//   tag_GlyphDirectory              // 'gdir'    17
//   tag_Editor0                     // 'edt0'    18
//   tag_Editor1                     // 'edt1'    19
//   tag_Encryption                  // 'cryp'    20

// REQUIRED TABLES

#define IT_REQ_CMAP    0
#define IT_REQ_GLYPH   1
#define IT_REQ_HEAD    2
#define IT_REQ_HHEAD   3
#define IT_REQ_HMTX    4
#define IT_REQ_LOCA    5
#define IT_REQ_MAXP    6
#define IT_REQ_NAME    7

#define C_REQ_TABLES   8

// optional tables

#define IT_OPT_OS2     0
#define IT_OPT_HDMX    1
#define IT_OPT_VDMX    2
#define IT_OPT_KERN    3
#define IT_OPT_LSTH    4
#define IT_OPT_POST    5
#define IT_OPT_GASP    6
#define IT_OPT_MORT    7 
#define IT_OPT_GSUB    8
#define IT_OPT_VMTX    9
#define IT_OPT_VHEA    10
#define IT_OPT_EBLC    11
#define C_OPT_TABLES   12

/*

// there are more optional tables, but ttfd is not
// using them so we are eliminating these from the code

#define IT_OPT_CVT
#define IT_OPT_FPGM
#define IT_OPT_PREP

// these are not mentioned in the spec (unless
// they are mentioned under a different name) but tags
// for them exhist in sfnt_en.h

#define IT_OPT_GDIR
#define IT_OPT_EDT0
#define IT_OPT_EDT1
#define IT_OPT_ENCR
#define IT_OPT_FOCA
#define IT_OPT_WIN

//!!! these ARE mentioned in the spec, but I found no tags for them
//!!! in the sfnt_en.h include file [bodind], I am putting the tags
//!!! here for now, until they are added to sfnt_en.h

*/



#define tag_Vdmx      0x56444d58
#define tag_Foca      0x666f6361
#define tag_Win       0x0077696e
// for far east support
#define tag_mort      0x6d6f7274 
#define tag_GSUB      0x47535542
#define tag_DSIG      'DSIG'

typedef struct _TABLE_ENTRY // te
{
    ULONG dp;  // offset to the beginning of the table
    ULONG cj;  // size of the table
} TABLE_ENTRY, *PTABLE_ENTRY;


typedef struct _TABLE_POINTERS // tptr
{
    TABLE_ENTRY ateReq[C_REQ_TABLES];
    TABLE_ENTRY ateOpt[C_OPT_TABLES];
} TABLE_POINTERS, *PTABLE_POINTERS;


// jeanp's functions

uint16 ui16Mac2Lang (uint16 Id);


// convert "os2" language id to the mac style lang id if this is a mac file

#define  CV_LANG_ID(ui16PlatformID, Id)                               \
(                                                                     \
(ui16PlatformID == BE_PLAT_ID_MS) ? (Id) : ui16Mac2Lang((uint16)(Id)) \
)

// magic number in big endian

#define BE_SFNT_MAGIC   0xF53C0F5F

// in order to understand this structure one needs to know
// the format of the table pmap  which is as follows
//
// typedef struct {
//     uint16 format;
//     uint16 length;
//     uint16 version;

// the three fields above are common for all formats

//     uint16 segCountX2;
//     uint16 searchRange;
//     uint16 entrySelector;
//     uint16 rangeShift;
//     uint16 endCount[segCount];
//     uint16 reservedPad;         // only God knows why
//     uint16 startCount[segCount];
//     uint16 idDelta[segCount];
//     uint16 idRangeOffset[segCount];
//     uint16 glyphIdArray[1];     // arbitrary length
// } CMAP_TABLE_IN_MSFT_FORMAT;
//
// Not all of these fields are relevant for us,
// we shall only need few of them. Their offsets
// from the beginning of the structure are as follows:
//

// cmap table  size and offsets

#define SIZEOF_CMAPTABLE  (3 * sizeof(uint16))

#define OFF_segCountX2  6
#define OFF_endCount    14


//
// offsets within kerning table
//

#define KERN_OFFSETOF_TABLE_VERSION             0
#define KERN_OFFSETOF_TABLE_NTABLES             1 * sizeof(USHORT)
#define KERN_SIZEOF_TABLE_HEADER                2 * sizeof(USHORT)

//
// offsets within a kerning sub table
//

#define KERN_OFFSETOF_SUBTABLE_VERSION          0
#define KERN_OFFSETOF_SUBTABLE_LENGTH           1 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_COVERAGE         2 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_NPAIRS           3 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_SEARCHRANGE      4 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_ENTRYSELECTOR    5 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_RANGESHIFT       6 * sizeof(USHORT)
#define KERN_SIZEOF_SUBTABLE_HEADER             7 * sizeof(USHORT)

#define KERN_OFFSETOF_ENTRY_LEFT                0
#define KERN_OFFSETOF_ENTRY_RIGHT               1 * sizeof(USHORT)
#define KERN_OFFSETOF_ENTRY_VALUE               2 * sizeof(USHORT)
#define KERN_SIZEOF_ENTRY                       2 * sizeof(USHORT) + sizeof(FWORD)

#define KERN_OFFSETOF_SUBTABLE_FORMAT           KERN_OFFSETOF_SUBTABLE_COVERAGE
#define KERN_WINDOWS_FORMAT                     0


// these functions are candidates to be bracketed the try/except


// FS_ENTRY fs_NewSfnt           (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewTransformation (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewGlyph          (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_GetAdvanceWidth   (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourGridFit    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourNoGridFit  (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_FindBitMapSize    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourScan       (fs_GlyphInputType *, fs_GlyphInfoType *);




#define MAX_UINT8    0xff
#define MAX_INT8     0x7f
#define MIN_INT8     (-0x7f)
#define B_INT8(x)    (((x) <= MAX_INT8) && ((x) >= MIN_INT8))

#define MAX_UINT16   0xffff
#define MAX_INT16    0x7fff
#define MIN_INT16    (-0x7fff)
#define B_INT16(x)   (((x) <= MAX_INT16) && ((x) >= MIN_INT16))

#define MAX_UINT32  0xffffffff
#define MAX_INT32   0x7fffffff
#define MIN_INT32   (-0x7fffffff)
#define B_INT32(x)   (((x) <= MAX_INT32) && ((x) >= MIN_INT32))

typedef struct 
{
    int32   version;
    int16   ascent;
    int16   descent;
    int16   lineGap;
    int16   advanceHeightMax;
    int16   minTopSideBearing;
    int16   minBottomSideBearing;
    int16   yMaxExtent;
    int16   caretSlopeRise;
    int16   caretSlopeRun;
    int16   caretOffset;
    int16   reserved1;
    int16   reserved2;
    int16   reserved3;
    int16   reserved4;
    int16   metricDataFormat;
    uint16  numOfLongVerMetrics;
} sfnt_vheaTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\service.c ===
/******************************Module*Header*******************************\
* Module Name: service.c
*
* set of service routines for converting between ascii and  unicode strings
*
* Created: 15-Nov-1990 11:38:31
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"

/******************************Public*Routine******************************\
*
* vCpyBeToLeUnicodeString,
*
* convert (c - 1) WCHAR's in big endian format to little endian and
* put a terminating zero at the end of the dest string
*
* History:
*  11-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c)
{
    LPWSTR pwcBeSrcEnd;

    ASSERTDD(c > 0, "vCpyBeToLeUnicodeString: c == 0\n");

    for
    (
        pwcBeSrcEnd = pwcBeSrc + (c - 1);
        pwcBeSrc < pwcBeSrcEnd;
        pwcBeSrc++, pwcLeDst++
    )
    {
        *pwcLeDst = BE_UINT16(pwcBeSrc);
    }
    *pwcLeDst = (WCHAR)(UCHAR)'\0';

}



/******************************Public*Routine******************************\
*
* VOID  vCvtMacToUnicode
*
* Effects:
*
* Warnings:
*
* History:
*  07-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
)
{
    PBYTE pjSrcEnd;

//!!! I believe that LangId should be used to select the proper conversion
//!!! routine, this is a stub [bodind]

    ulLangId;

    for
    (
        pjSrcEnd = pjSrcMac + c;
        pjSrcMac < pjSrcEnd;
        pjSrcMac++, pwcLeDst++
    )
    {
        *pwcLeDst = (WCHAR)(*pjSrcMac);
    }
}

/******************************Public*Routine******************************\
*
* VOID  vCpyMacToLeUnicodeString
*
*
* Ensures that string is zero terminated so that other cool things can be
* done to it such as wcscpy, wcslen e.t.c.
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
)
{
    ASSERTDD(c > 0, "vCpyMacToLeUnicodeString: c == 0\n");

    c -= 1;
    vCvtMacToUnicode (ulLangId, pwcLeDst, pjSrcMac, c);
    pwcLeDst[c] = (WCHAR)(UCHAR)'\0';
}


/**************************************************************************\
* The rest of the file is stolen from JeanP's win31 code in fd_mac.c
*
* Conversion routines from Mac character code and Mac langageID to
* Unicode character code and OS2 langage ID
*
* Public routines:
*   Unicode2Mac
*   Mac2Lang
*
\**************************************************************************/



/*
** Converts the OS2 langageID to the to the Mac langage ID
*/

#ifdef JEANP_IS_WRONG

// JEANp messed up danish and german, else my conversion table is the
// same as mine [bodind]

uint16  aCvLang [32] =
{
   0, 12,  0,  0,  0,  0,  0,  7,
  14,  0,  6, 13,  1, 10,  0, 15,
   3, 11, 21,  4,  9,  0,  8,  0,
   0,  0, 18,  0,  0,  5, 22, 17
};

#endif // JEANP_IS_WRONG

uint16  aCvLang [32] =
{
   0,     //  0 -> 0  (0           -> english == default)
  12,     //  1 -> 12 (arabic      -> arabic)
   0,     //  2 -> 0  (bulgarian   -> english == default)
   0,     //  3 -> 0  (catalon     -> english == default)
   0,     //  4 -> 0  (Chinese     -> english == default)
   0,     //  5 -> 0  (Czeh        -> english == default)
   7,     //  6 -> 7  (Danish      -> Danish)
   2,     //  7 -> 2  (German      -> German)
  14,     //  8 -> 14 (Greek       -> Greek)
   0,     //  9 -> 0  (English     -> english)
   6,     //  a -> 6  (spanish     -> spanish)
  13,     //  b -> 13 (finnish     -> finnish)
   1,     //  c -> 1  (french      -> french)
  10,     //  d -> 10 (hebrew      -> hebrew)
   0,     //  e -> 0  (hungarian   -> english == default)
  15,     //  f -> 15 (icelandic   -> icelandic)
   3,     // 10 -> 3  (Italian     -> italian)
  11,     // 11 -> 11 (japanese    -> japanese)
  21,     // 12 -> 21 (korean      -> hindi, this seems to be a bug?????????)
   4,     // 13 -> 4  (dutch       -> dutch)
   9,     // 14 -> 9  (norweign    -> norweign)
   0,     // 15 -> 0  (Polish      -> english == default)
   8,     // 16 -> 8  (portugese   -> portugese)
   0,     // 17 -> 0  (rhaeto-romanic -> english == default)
   0,     // 18 -> 0  (romanian    -> english == default)
   0,     // 19 -> 0  (russian     -> english == default)
  18,     // 1a -> 18 (Yugoslavian -> Yugoslavian), lat or cyr ????
   0,     // 1b -> 0  (slovakian   -> english == default)
   0,     // 1c -> 0  (albanian    -> english == default)
   5,     // 1d -> 5  (swedish     -> swedish)
  22,     // 1e -> 22 (thai        -> thai)
  17      // 1f -> 17 (turkish     -> turkish)
};



/************************** Public Routine *****************************\
*  Mac2Lang
*
* Converts the OS2 langageID to the to the Mac langage ID
*
* History:
*  Fri Dec 08 11:28:35 1990    -by-    Jean-Francois Peyroux [jeanp]
* Wrote it.
\***********************************************************************/

uint16 ui16Mac2Lang (uint16 Id)
{
// this is just a way to bail out if an incorrect lang id is passed to
// this routine [bodind]
// Note that Id & 1f < 32 == sizeof(aCvLang)/sizeof(aCvLang[0]), no gp-fault

    return aCvLang[Id & 0x1f];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\xform.h ===
/******************************Module*Header*******************************\
* Module Name: xform.h
*
* (Brief description)
*
* Created: 05-Apr-1992 11:06:23
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/



typedef FLOAT EFLOAT;
typedef EFLOAT *PEFLOAT;

LONG lCvt(FLOAT f,LONG l);

typedef struct _VECTORFL
{
    EFLOAT x;
    EFLOAT y;
} VECTORFL, *PVECTORFL;


BOOL bFDXform
(
XFORML   *pxf,
POINTFIX *pptfxDst,
POINTL   *pptlSrc,
SIZE_T     c
);

BOOL bXformUnitVector
(
POINTL       *pptl,           // IN,  incoming unit vector
XFORML       *pxf,            // IN,  xform to use
EFLOAT       *pefNorm         // OUT, |*pptqXormed|
);

VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
POINTQF   *pptq
);


FIX  fxLTimesEf  //!!! SHOULD BE MOVED TO TTFD and VTFD
(
EFLOAT *pef,
LONG    l
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\fondrv\tt\ttfd\vdmx.c ===
/******************************Module*Header*******************************\
* Module Name: vdmx.c
*
* Created: 03-Oct-1991 10:58:34
* Author: Jean-francois Peyroux [jeanp]
*
*     Microsoft Confidential
*
*         Copyright (c) Microsoft Corporation 1989, 1991
*
*         All Rights Reserved
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"
//#include "winfont.h"

#define LINEAR_TRESHOLD 255

#pragma pack(1)

typedef struct
{
  BYTE    bCharSet;       // Character set (0=all glyphs, 1=Windows ANSI subset
  BYTE    xRatio;         // Value to use for x-Ratio
  BYTE    yStartRatio;    // Starting y-Ratio value
  BYTE    yEndRatio;      // Ending y-Ratio value
}  RATIOS;

typedef struct
{
  USHORT  version;        // Version number for table (starts at 0)
  USHORT  numRecs;        // Number of VDMX groups present
  USHORT  numRatios;      // Number of aspect ratio groupings
} VDMX_HDR;

typedef struct
{
  USHORT  yPelHeight;     // yPelHeight (PPEM in Y) to which values apply
  SHORT   yMax;           // yMax (in pels) for this yPelHeight
  SHORT   yMin;           // yMin (in pels) for this yPelHeight
} VTABLE;

typedef struct
{
  USHORT  recs;           // Number of height records in this group.
  BYTE    startsz;        // Starting yPelHeight
  BYTE    endsz;          // Ending yPelHeight
} VDMX;

#pragma pack()

/******************************Public Routine*******************************
*
* BOOL   bSearchVdmxTable
*
* Description:
*
*   if em > 0
*       searches vdmx table for vA+vD == em. returns vA,vD (== em - vA), vEm
*   else // em < 0
*       searches vdmx table for vEm == em. returns vA,vD, vEm
*
* History:
*
*  Tue 21-Jul-1992 -by- Bodin Dresevic [BodinD]
* update: ported to NT
*   15 Nov 1991 -by-    Raymond E. Endres   [rayen]
* Added aspect ratio option and optimized the function.
*   3  Oct 1991 -by-    Jean-francois Peyroux   [jeanp]
* Wrote it.
**************************************************************************/

BOOL
bSearchVdmxTable (
    PBYTE     pjVdmx,
    ULONG     ResX,
    ULONG     ResY,
    INT       EM,     // NOT really EM, could be asc + desc wish in pixel units
    VTABLE    *pVTAB  // out put structure
    )
{
    USHORT    numRatios;        // VDMX_HDR.numRatios
    USHORT    numVtable;        // VDMX.recs, not VDMX_HDR.numRecs

    RATIOS   *pRatios;
    VDMX     *pVdmx;
    VTABLE   *pVtable;
    LONG      lRet, lRet2;
    UINT      i;
    BYTE      Abs_EM;

// do not call us if pjVdmx is null

    ASSERTDD (pjVdmx != (PBYTE)NULL, "pjVdmx == NULL\n");

// The following line is strange, but we keep it here for win31 compatibility.
// It is possible to have EM = +256, which corresponds to |ppem| < 256
// such that there is an entry for this -|ppem| in the table but
// yMax-yMin for this entry may be equal to 256. This in fact is the case
// with symbol.ttf font [bodind]

    if ((EM >= LINEAR_TRESHOLD) || (EM <= -LINEAR_TRESHOLD)) // assume EM > LINEAR_TRESHOLD scales linearly
        return FALSE;

// need to proceed to search vdmx table

    numRatios = SWAPW(((VDMX_HDR  *) pjVdmx)->numRatios);
    pRatios = (RATIOS  *) &((VDMX_HDR  *) pjVdmx)[1];

    for(i = 0; i < numRatios; i++)
    {
        if (pRatios[i].bCharSet == 1)
        {
        // must be Windows ANSI subset

            if (pRatios[i].xRatio == 0)
            {
                break;
            }           // auto match if 0
            else
            {                   // is it within aspect ratios
                lRet = ResY * pRatios[i].xRatio;
                lRet2= ResX * pRatios[i].yStartRatio;
                if (lRet >= lRet2)
                {
                    lRet2 = ResX * pRatios[i].yEndRatio;
                    if (lRet <= lRet2)
                        break;
                }
            }
        }
    }

    if (i == numRatios)  // did not find an aspect ratio match
        return FALSE;

// found an aspect ratio match

    pVdmx = (VDMX  *) (pjVdmx + SWAPW(((USHORT  *) &pRatios[numRatios])[i]));
    Abs_EM = (BYTE) (EM >=0 ? EM : - EM);

    if (EM > 0 || Abs_EM >= pVdmx->startsz && Abs_EM <= pVdmx->endsz)
    {
    // is there a Vtable for this EM

        pVtable = (VTABLE  *) &pVdmx[1];
        numVtable = SWAPW(pVdmx->recs);

        if (EM > 0)
        {
        // return the original yPelHeight

            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((pVTAB->yMax - pVTAB->yMin) == EM)
                {
                    return TRUE;
            }
            else if ((pVTAB->yMax - pVTAB->yMin) > EM)
                {
                    return FALSE;
            }
            }
        }
        else // return the actual em height in pixels
        {
            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((INT)pVTAB->yPelHeight == -EM)
                {
                    return TRUE;
            }
            else if ((INT)pVTAB->yPelHeight > -EM)
                {
                    return FALSE;
            }
            }
        }
    }
    return FALSE;
}

#ifdef THIS_IS_COMMENTED_PSEUDOCODE

// BASED ON THE DISCUSSION OF KIRKO, BODIND AND GILMANW WITH GUNTERZ

|INPUT:  hWish = wish height in pixel units
|
|OUTPUT: ascender, descender, ppem (all in pixel units) (dA,dD,dEm)
|
|
|    NOTATION:
|
|        dA = ascender in device/pixel space
|        nA = ascender in notional space
|        vA = ascender in vdmx table
|
|        dD = descender in device/pixel space
|        nD = descender in notional space
|        vD = descender in vdmx table
|
|        dEm = pixels per em in device space
|        nEm = em height in notional space
|        vEm = pixels per em in vdmx table
|
|
|LOCALS
|
|    LONG hTrial
|    LONG hEqualOrBelow
|    BOOL wasAbove
|    BOOL wasBelow
|
|PROCEDURE
|{
|    if (hWish < 0) then
|    {
|        <look in the vdmx and look for a vEm that matches -hWish>;
|        if (a match is found) then
|        {
|            dA = vA;
|            dD = vD;
|        }
|        else
|        {
|        //
|        // No Match is found in vdmx table, assume linear scaling
|        //
|            dA = round(nA * (-hWish) / nEm);
|            dD = round(nD * (-hWish) / nEm);
|        }
|        ppEm = -hWish;
|        return;
|    }
|
|//
|// hWish > 0
|//
|    <search the vdmx table for (vA + vD) that matches hWish>;
|    if (a match is found)
|    {
|        dA  = vA;
|        dCs = vD;
|        dEm = vEm;
|        return;
|    }
|
|//
|// Note, that from this point forward vA + vD never equals hWish
|// otherwise we would have found it in the step above
|//
|    ppemTrial = round(nEm * hWish / (nA + nD));
|
|    wasAbove = FALSE;
|    wasBelow = FALSE;
|
|    while (TRUE)
|    {
|        <search the vdmx table for vEm that matches ppemTrial>;
|        if (a match is found)
|        {
|            hTrial = vA + vD;
|        //
|        // This can't equal hWish (see above) so don't bother
|        // checking
|        }
|        else
|        {
|            hTrial = round(ppemTrial * (nA + nD) / nEm);
|            if (hTrial == hWish)
|            {
|                hEqualOrBelow = hTrial;
|                break;
|            }
|        }
|
|        if (hTrial < hWish)
|        {
|            hEqualOrBelow = hTrial;
|            if (wasAbove)
|                break;
|            ppemTrial = ppemTrial + 1;
|            wasBelow  = TRUE;
|        }
|        else
|        {
|            ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
|            if (wasBelow)
|                break;
|                                         // <==== OLD POSITION
|            wasAbove = TRUE
|        }
|    }
|    dA  = round(ppemTrial * nA / nEm);
|    dD  = hEqualOrBelow - dA;
|    dEm = ppemTrial;
|    return;
|}.
|

#endif // THIS_IS_COMMENTED_PSEUDOCODE


/******************************Public*Routine******************************\
*
* VOID vQuantizeXform
*
* Effects: quantize the xform according to win31 recipe. as side effects
*          this routine may compute ascender and descener in device space
*          from vdmx table as well as number of pixels per M in device space.
*
* History:
*  25-Jul-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vQuantizeXform (
    PFONTCONTEXT pfc
    )
{
    BYTE  *pjView =  (BYTE *)pfc->pff->pvView;
    Fixed  fxMyy = pfc->mx.transform[1][1];
    PBYTE  pjVdmx  = (pfc->ptp->ateOpt[IT_OPT_VDMX].dp)          ?
                     (pjView + pfc->ptp->ateOpt[IT_OPT_VDMX].dp) :
                     NULL                                        ;

    LONG   hWish;
    VTABLE vtb, vtbPrev;

    LONG   ppemTrial, hTrial, yEmN, yHeightN;

    BOOL   bWasAbove, bWasBelow, bFound, bFoundPrev;

    sfnt_FontHeader * phead =
                      (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)         ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp):
                   NULL                                      ;

    yEmN = pfc->pff->ifi.fwdUnitsPerEm;

    if (!((pfc->flXform & XFORM_HORIZ) && (fxMyy > 0) && (pjVdmx != (PBYTE)NULL)))
    {
    // nothing to do, just return.

        return;
    }

// compute hWish in pixel coords. This is lfHeight from the logfont, except
// that it has been transformed to device pixel units and the sign is preserved

    if (pfc->flFontType & FO_EM_HEIGHT)
    {
        hWish = FixMul(fxMyy, -yEmN);
    }
    else // use tmp variable
    {
        yHeightN = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        hWish = FixMul(fxMyy, yHeightN);
    }

// quick out, all bSearchVdmxTable routines will fail if hWish is too big:



    if (bSearchVdmxTable(pjVdmx,
                         pfc->sizLogResPpi.cx,
                         pfc->sizLogResPpi.cy,
                         hWish,
                         &vtb)
    )
    {
        pfc->yMax = - vtb.yMin;
        pfc->yMin = - vtb.yMax;
        pfc->lEmHtDev = vtb.yPelHeight;

    // flag that dA and dD have been computed, do not scale linerly:

        pfc->flXform |= XFORM_VDMXEXTENTS;
    }
    else
    {
    // dA and dD will have to be computed using linear scaling
    // after the xform is quantized using win31 hacked recipe
    // get the notional space values which are needed for scaling

    // get the notional space values

        if (pjOS2)
        {
        // win 31 compatibility: we only take the max over win 31 char set:
        // all the glyphs outside this set, if they stand out will get chopped
        // off to match the height of the win31 char subset:

            yHeightN = BE_INT16(pjOS2 + OFF_OS2_usWinDescent) +
                       BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        }
        else
        {
            yHeightN = BE_INT16(&phead->yMax) - BE_INT16(&phead->yMin);
        }

        if (hWish < 0)
        {
            pfc->lEmHtDev = -hWish;
        }
        else // hWish > 0
        {
        // Note, that from this point forward vA + vD never equals hWish
        // otherwise we would have found it in the step above. This claim
        // is WRONG for only one reason. suppose hWish is 256. bSearchVdmxTable
        // will return FALSE because of the early exit test |EM| <= LINEAR_TRESHOLD
        // at the begininig of the routine. We have to keep this test in the
        // code for compatibility reasons. Now it is possible to have
        // ppemTrial <= LINEAR_TRESHOLD, so that bSearchVdmxTable will not hit the
        // early exit, and such that there exists an entry in the vdmx table
        // for this -ppemTrial, but with yMax-yMin == 256 == hWish.

            // ppemTrial = F16_16TOLROUND(yEmN * fxMyy);
            ppemTrial = FixMul(fxMyy, yEmN);

            bWasAbove  = FALSE;
            bWasBelow  = FALSE;
            bFound     = FALSE;
            bFoundPrev = FALSE; // save the value from the prev. loop

        // init the strucs

            vtb.yMin       = 0;
            vtb.yMax       = 0;
            vtb.yPelHeight = 0;
            vtbPrev        = vtb;

            for (;TRUE; bFoundPrev = bFound, vtbPrev = vtb)
            {
            // search the vdmx table for vEm that matches ppemTrial

                if
                (
                    bFound = bSearchVdmxTable(
                                     pjVdmx,
                                     pfc->sizLogResPpi.cx,
                                     pfc->sizLogResPpi.cy,
                                     -ppemTrial,
                                     &vtb)
                )
                {
                    hTrial = vtb.yMax - vtb.yMin;
                //
                // This can't equal hWish (see above) so don't bother
                // checking? WRONG!!! see teh comment above.

                    if (hTrial == hWish)
                    {
                    // This assert would be correct if it were not
                    // for occasional bugs in vdmx tables.
                    // In the case of Bell MT Regular, vA+vD = 0x13 for
                    // lEmHt = 0x0f which is STRICTLY bigger than
                    // vA+vD = 0x12 for lEmHt = 0x10 which is absurd.
                    // For this reason the first
                    // bSearchVdmxTable(EM = 0X12) fails to find an entry
                    // while the second bSearchVdmxTable(EM =- 0X10)
                    // DOES FIND an entry
                    // in vdmx table such that vA+vD=0x12, generating
                    // the commented assertion to bark. That is why we converted
                    // assertion to just print out a warning message.


                    #if DBG

                        // ASSERTGDI(hWish > LINEAR_TRESHOLD, "TTFD! hWish <= LINEAR_TRESHOLD\n");

                        if (hWish <= LINEAR_TRESHOLD)
                            TtfdDbgPrint("TTFD! hWish <= LINEAR_TRESHOLD\n");

                    #endif

                    /*   Bell MT Table:

    pVtable  -->    f800 ff08       //  F8 entries = numVtable,
                                    //  startsz = 8, endsz = ff
                    0800 0800 feff
                    0900 0900 feff
                    0a00 0900 fdff
                    0b00 0a00 fdff
                    0c00 0c00 fdff
                    0d00 0c00 fdff
                    0e00 0d00 fcff
                    0f00 0e00 fbff  <- yMax-yMin = 14-(-5) = 19 == 0X13
                    1000 0e00 fcff  <- yMax-yMin = 14-(-4) = 18 // problem
                    1100 0f00 fbff
                    1200 1100 fbff
                    1300 1100 fbff
                    ..............

                    */

                        pfc->yMax = - vtb.yMin;
                        pfc->yMin = - vtb.yMax;
                        pfc->lEmHtDev = vtb.yPelHeight;

                    // flag that dA and dD have been computed, do not scale linerly:

                        pfc->flXform |= XFORM_VDMXEXTENTS;
                        break;
                    }
                }
                else
                {
                    hTrial = LongMulDiv(ppemTrial, yHeightN, yEmN);

                    if (hTrial == hWish)
                    {
                        // hEqualOrBelow = hTrial;
                        break;
                    }
                }

                if (hTrial < hWish)
                {
                    // hEqualOrBelow = hTrial;
                    if (bWasAbove)
                    {
                        if (bFound) // just found this hTrial in the search above
                        {
                            pfc->yMax = - vtb.yMin;
                            pfc->yMin = - vtb.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                    ppemTrial = ppemTrial + 1;
                    bWasBelow  = TRUE;
                }
                else
                {
                    ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
                    if (bWasBelow)
                    {
                        if (bFoundPrev) // just found this hTrial in the search above
                        {
                            ASSERTDD (ppemTrial == vtbPrev.yPelHeight,
                                      "vdmx logic messed up");

                            pfc->yMax = - vtbPrev.yMin;
                            pfc->yMin = - vtbPrev.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                                             // <==== OLD POSITION
                    bWasAbove = TRUE;
                }
            }
            pfc->lEmHtDev = ppemTrial;
        }
    }

// the following line means quantizing:

    pfc->mx.transform[1][1] = FixDiv(pfc->lEmHtDev, yEmN);

// now fix xx component accordingly: xxNew = xxOld * (yyNew/yyOld)

// we do one final tweak with the transform here:
// If the difference between
// horizontal and vertical scaling is so small that the resulting
// avg font width is the same if we replace x scaling by y scaling
// than we will do it, which will result in diag transform and we will
// be able to use hdmx tables for this realization. By doing so
// we ensure that we get the same realization when we enumerate font
// and then use the logfont returned from enumeration to realize this font
// again.

    if
    (
        (pfc->mx.transform[0][0] == fxMyy) ||
        (FixMul(pfc->mx.transform[0][0] - pfc->mx.transform[1][1],
                (Fixed)pfc->pff->ifi.fwdAveCharWidth) == 0)
    )
    {
        pfc->mx.transform[0][0] = pfc->mx.transform[1][1];
    }
    else
    {
        pfc->mx.transform[0][0] = LongMulDiv(
                                      pfc->mx.transform[0][0],
                                      pfc->mx.transform[1][1],
                                      fxMyy
                                      );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gdiplusguids\imagingguds.cpp ===
//
// this is where we get the real defn's for all of the DEFINE_GUID statements
// so that people who link to gdiplus.lib will be able to resolve them
//

#include <windows.h>
#include <wtypes.h>
#include <objbase.h>
#define INITGUID
#include <guiddef.h>
#include <gdipluspixelformats.h>
#include <gdiplusImaging.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\beziers.c ===
/*****************************************************************************
 *
 * beziers - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType) ;


/***************************************************************************
 *  PolyDraw  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyDraw
(
PLOCALDC pLocalDC,
LPPOINT pptl,
PBYTE   pb,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, pb, cptl, EMR_POLYDRAW));
}

/***************************************************************************
 *  PolyBezier  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezier
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIER));
}

/***************************************************************************
 *  PolyBezierTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyBezierTo
(
PLOCALDC pLocalDC,
LPPOINT pptl,
DWORD   cptl
)
{
        return(PolyBezierCommon(pLocalDC, pptl, (PBYTE) NULL, cptl, EMR_POLYBEZIERTO));
}

/***************************************************************************
 *  PolyBezierCommon  - Common code for PolyDraw, PolyBezier and PolyBezierTo
 **************************************************************************/
BOOL PolyBezierCommon(PLOCALDC pLocalDC, LPPOINT pptl, PBYTE pb, DWORD cptl, DWORD mrType)
{
BOOL    b ;

// If we're recording the drawing order for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            // On Win9x transform the points with the WorldToPage transform
            // before calling the HelperDC functions
            if (pfnSetVirtualResolution == NULL)
            {
                if (!bXformWorkhorse((PPOINTL) pptl, cptl, &pLocalDC->xformRWorldToRDev))
                    return FALSE;
            }
            switch (mrType)
            {
                case EMR_POLYBEZIER:
                    b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYBEZIERTO:
                    b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
                    break ;

                case EMR_POLYDRAW:
                    b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
                    break ;

                default:
                    b = FALSE;
                    RIPS(("MF3216: PolyBezierCommon, bad mrType\n")) ;
                    break ;
            }

            ASSERTGDI(b, "MF3216: PolyBezierCommon, in path render failed\n") ;
            return (b) ;
        }

// Call the common curve renderer.

        return
        (
            bRenderCurveWithPath(pLocalDC, pptl, pb, cptl,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0f, 0.0f, mrType)
        );
}


/***************************************************************************
 *  bRenderCurveWithPath - Renders a curve or area using the path api.
 *     The supported curves and areas are PolyDraw, PolyBezier, PolyBezierTo,
 *     AngleArc, Arc, Chord, Pie, Ellipse, Rectangle, and RoundRect.
 **************************************************************************/
BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
)
{
    BOOL     b = FALSE;
    INT      iPathType;
    POINTL   ppts[4] = {x1, y1, x2, y2, x3, y3, x4, y4};

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x tranform the points before passing them to the DC
        if (!bXformWorkhorse((PPOINTL) pptl, cptl, &pLocalDC->xformRWorldToRDev))
        {
            RIPS("GPMF3216: bRenderCurveWithPath, BeginPath failed\n");
            goto exit_bRenderCurveWithPath;
        }
        if (!bXformWorkhorse(ppts, 4, &pLocalDC->xformRWorldToRDev))
        {
            RIPS("GPMF3216: bRenderCurveWithPath, BeginPath failed\n");
            goto exit_bRenderCurveWithPath;
        }
    }

// We don't do curves in a path bracket here.  They should be
// taken care of by the caller.

    ASSERTGDI(!(pLocalDC->flags & RECORDING_PATH),
        "MF3216: bRenderCurveWithPath, cannot be in a path bracket\n");

// Save the helper DC first.
// This is to prevent us from accidentally deleteing the current path
// in the helper DC when we create another path to render the curve.
// E.g. BeginPath, Polyline, EndPath, PolyBezier, StrokePath.

    if (!SaveDC(pLocalDC->hdcHelper))
    {
        RIPS("MF3216: bRenderCurveWithPath, SaveDC failed\n");
        return(FALSE);
    }

// Create the path for the curve and stroke it.
// Be careful not to modify the states of the LocalDC especially in
// DoRenderPath below.
// Note that BeginPath uses the previous current position.  So this
// code will work correctly in the case of PolyBezierTo, PolyDraw
// and AngleArc.

    // Begin the path.

    b = BeginPath(pLocalDC->hdcHelper);
    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, BeginPath failed\n");
        goto exit_bRenderCurveWithPath;
    }

    // Do the curve.


    switch (mrType)
    {
        case EMR_POLYBEZIER:

            iPathType = EMR_STROKEPATH;
            b = PolyBezier(pLocalDC->hdcHelper, pptl, cptl);
            break;

        case EMR_POLYBEZIERTO:
            iPathType = EMR_STROKEPATH;
            b = PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl);
            break;

        case EMR_POLYDRAW:
            iPathType = EMR_STROKEPATH;
            b = PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl);
            break;

        case EMR_ANGLEARC:
            iPathType = EMR_STROKEPATH;
            b = AngleArc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, nRadius, eStartAngle, eSweepAngle);
            break;

        case EMR_ARC:
            iPathType = EMR_STROKEPATH;
            b = Arc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                         ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
            break;

        case EMR_CHORD:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Chord(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                           ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
            break;

        case EMR_PIE:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Pie(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                         ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
            break;

        case EMR_ELLIPSE:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Ellipse(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y);
            break;

        case EMR_RECTANGLE:
            iPathType = EMR_STROKEANDFILLPATH;
            b = Rectangle(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y) ;
            break;

        case EMR_ROUNDRECT:
            iPathType = EMR_STROKEANDFILLPATH;
            b = RoundRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                               ppts[2].x, ppts[2].y) ;
            break;

        default:
            b = FALSE;
            RIPS("MF3216: bRenderCurveWithPath, bad mrType");
            break;
    }

    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, render failed\n");
        goto exit_bRenderCurveWithPath;
    }

    // End the path

    b = EndPath(pLocalDC->hdcHelper);
    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, EndPath failed\n");
        goto exit_bRenderCurveWithPath;
    }

    // Stroke or fill the path.

    b = DoRenderPath(pLocalDC, iPathType, FALSE);
    if (!b)
    {
        RIPS("MF3216: bRenderCurveWithPath, DoRenderPath failed\n");
        goto exit_bRenderCurveWithPath;
    }

exit_bRenderCurveWithPath:

// Restore the helper DC.

    if (!RestoreDC(pLocalDC->hdcHelper, -1))
        ASSERTGDI(FALSE, "MF3216: bRenderCurveWithPath, RestoreDC failed\n") ;

// If this is a PolyBezeirTo, PolyDraw or AngleArc, make the call to the
// helper DC to update its current position.

    if (b)
    {
        switch (mrType)
        {
            case EMR_POLYBEZIER:
            case EMR_ARC:
            case EMR_CHORD:
            case EMR_PIE:
            case EMR_ELLIPSE:
            case EMR_RECTANGLE:
            case EMR_ROUNDRECT: // no need to update the helper DC
                break ;

            case EMR_POLYBEZIERTO:
                (void) PolyBezierTo(pLocalDC->hdcHelper, pptl, cptl) ;
                break ;

            case EMR_POLYDRAW:
                (void) PolyDraw(pLocalDC->hdcHelper, pptl, pb, cptl) ;
                break ;

            case EMR_ANGLEARC:
                (void) AngleArc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, nRadius, eStartAngle, eSweepAngle);
                break ;

            default:
                RIPS("MF3216: bRenderCurveWithPath, bad mrType");
                break;
        }
    }

// Return the result.

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\apientry.c ===
/*****************************************************************************
 *
 * apientry.c - This module contains the API entry points for the
 *              Win32 to Win16 metafile converter.
 *
 * Date: 8/29/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL     bMemUpdateCheckSum(PLOCALDC pLocalDC) ;
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags) ;
VOID     vFreeLocalDC(PLOCALDC pLocalDC);


extern VOID __cdecl _cfltcvt_init(VOID) ;

//CRITICAL_SECTION CriticalSection ;
//BOOL initCrit = FALSE ;

fnGetTransform pfnGetTransform = NULL ;
fnSetVirtualResolution pfnSetVirtualResolution = NULL;

// Constant definition for internal static string(s).

BYTE    szDisplay[] = "DISPLAY" ;


/*****************************************************************************
 * Entry point for translation
 *****************************************************************************/
UINT GdipConvertEmfToWmf(PBYTE pMetafileBits, UINT cDest, PBYTE pDest,
                         INT iMapMode, HDC hdcRef, UINT flags)
{
BOOL        b ;
DWORD       lret = 0;
PLOCALDC    pLocalDC ;
static HMODULE     hGDI32 = NULL;

        // This is the entry point... Make sure our function pointers are set
        if( hGDI32 == NULL )
        {
            hGDI32 = LoadLibrary(L"GDI32.DLL");
            if(hGDI32 != NULL)
            {
                pfnGetTransform = (fnGetTransform) GetProcAddress(hGDI32, "GetTransform");
                pfnSetVirtualResolution = (fnSetVirtualResolution) GetProcAddress(hGDI32, "SetVirtualResolution");
            }

            if(pfnSetVirtualResolution == NULL || pfnGetTransform == NULL )
            {
                pfnSetVirtualResolution = NULL ;
                pfnGetTransform = NULL ;
            }
        }

        // Check the requested map mode and if it's valid

        if (iMapMode < MM_MIN || iMapMode > MM_MAX)
        {
            RIPS("MF3216:ConvertEmfToWmf - Invalid MapMode\n") ;
            goto ErrorExit;
        }

        // Allocate the LocalDC and initialize some of it's fields.
        pLocalDC = pldcInitLocalDC(hdcRef, iMapMode, flags) ;
        if (pLocalDC == (PLOCALDC) 0)
        {
            goto ErrorExit ;
        }

        // If pDest is NULL then we just return the size of the buffer required
        // to hold the Win16 metafile bits.

        if (pDest == (PBYTE) 0)
        {
            pLocalDC->flags |= SIZE_ONLY ;
            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                lret = pLocalDC->ulBytesEmitted /* for the placeable Header */ ;
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Size Only failed\n") ;
            }
        }
        else
        {

            // Put the user specified Win16 buffer pointer and buffer length
            // into the localDC.

            pLocalDC->pMf16Bits = pDest ;
            pLocalDC->cMf16Dest = cDest ;

            //  Translate the Win32 metafile to a Win16 metafile.

            b = bParseWin32Metafile(pMetafileBits, pLocalDC) ;
            if (b == TRUE)
            {
                // Update the Win16 metafile header.

                b = bUpdateMf16Header(pLocalDC) ;
                if (b == TRUE)
                {
                    // Only acknowledge that we have translated some bits
                    // if everything has gone well.

                    lret = pLocalDC->ulBytesEmitted;

                    // If we're including the Win32 metafile then update the
                    // checksum field in the "Win32Comment header" record.

                    if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
                        bMemUpdateCheckSum(pLocalDC) ;

                }
            }
            else
            {
                PUTS("MF3216: ConvertEmfToWmf - Metafile conversion failed\n") ;
            }
        }

        // Free the LocalDC and its resources.

        vFreeLocalDC(pLocalDC);

ErrorExit:

        return (lret) ;
}


/*****************************************************************************
 * pldcInitLocalDC - Initialize the Local DC.
 *****************************************************************************/
PLOCALDC pldcInitLocalDC(HDC hdcRef, INT iMapMode, DWORD flags)
{
PLOCALDC    pLocalDC;
PLOCALDC    pldcRet = (PLOCALDC) NULL;  // assume error

        // Allocate and initialize memory for the LocalDC.

        pLocalDC = (PLOCALDC) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                         sizeof(LOCALDC));
        if (!pLocalDC)
        {
            PUTS("MF3216:pldcInitLocalDC - LocalAlloc failure\n") ;
            return((PLOCALDC) NULL);
        }

        // Record the size of the DC.

        pLocalDC->nSize = sizeof(LOCALDC) ;

        // Set the LocalDC boolean that controls whether or not we include
        // the Win32 metafile as one or more comment records.

        if (flags & MF3216_INCLUDE_WIN32MF)
            pLocalDC->flags |= INCLUDE_W32MF_COMMENT ;

        if (flags & GPMF3216_INCLUDE_XORPATH)
            pLocalDC->flags |= INCLUDE_W32MF_XORPATH ;

#if 0
        // Need to create a hdc for the display.
        // Initially this will be used by the bitblt translation code
        // to get a reasonable set of palette entries.
        // The reference DC only has a black & white palette.

        pLocalDC->hdcDisp = CreateDCA((LPCSTR)szDisplay, (LPCSTR)NULL, (LPCSTR)NULL, (CONST DEVMODEA *)NULL) ;
        if (pLocalDC->hdcDisp == (HDC) 0)
        {
            RIPS("MF3216:pldcInitLocalDC - CreateDCA(hdcDisp) failed\n") ;
            goto pldcInitLocalDC_exit;
        }
#endif // 0

        //  Create the HelperDC.

        if( pfnSetVirtualResolution != NULL )
        {
            pLocalDC->hdcHelper = CreateICA((LPCSTR) szDisplay,
                                           (LPCSTR) NULL,
                                           (LPCSTR) NULL,
                                           (LPDEVMODEA) NULL) ;
            if (pLocalDC->hdcHelper == (HDC)0)
            {
                PUTS("MF3216: pldcInitLocalDC, Create Helper DC failed\n") ;
                goto pldcInitLocalDC_exit;
            }
        }

        // For Win9x the DC will be created when we parse the header

        // Initialize the counters we need to keep for updating the header,
        // and keeping track of the object table.

        pLocalDC->nObjectHighWaterMark = -1;

        // If the hdcRef == NULL then we use the size of the DC in the EMF header
        if (hdcRef != NULL)
        {
            // if hdcRef == NULL then we will use the values in the MF Header
            // They will get filled in before they are used.
            pLocalDC->cxPlayDevMM  = GetDeviceCaps(hdcRef, HORZSIZE);
            pLocalDC->cyPlayDevMM  = GetDeviceCaps(hdcRef, VERTSIZE);
            pLocalDC->cxPlayDevPels = GetDeviceCaps(hdcRef, HORZRES);
            pLocalDC->cyPlayDevPels = GetDeviceCaps(hdcRef, VERTRES);
        }
        // Record the requested map mode and reference DC.

        pLocalDC->iMapMode = iMapMode ;
        pLocalDC->hdcRef   = hdcRef ;

        // Init Arc Direction.

        pLocalDC->iArcDirection = AD_COUNTERCLOCKWISE ;

        // Make current position invalid so that a moveto will be
        // emitted when it is first used.  See comments in DoMoveTo.

        pLocalDC->ptCP.x = MAXLONG ;
        pLocalDC->ptCP.y = MAXLONG ;

        // Default pen is a black pen.

        pLocalDC->lhpn32  = BLACK_PEN | ENHMETA_STOCK_OBJECT;

        // Default brush is a white brush.

        pLocalDC->lhbr32  = WHITE_BRUSH | ENHMETA_STOCK_OBJECT;

        // Default palette.

        pLocalDC->ihpal32 = DEFAULT_PALETTE | ENHMETA_STOCK_OBJECT;
        pLocalDC->ihpal16 = (DWORD) -1; // no W16 palette created yet

        pLocalDC->crBkColor = RGB(0xFF,0xFF,0xFF);

//      pLocalDC->pW16ObjHndlSlotStatus = NULL;
//      pLocalDC->cW16ObjHndlSlotStatus = 0;
//      pLocalDC->piW32ToW16ObjectMap = NULL;
//      pLocalDC->cW32ToW16ObjectMap = 0;
//      pLocalDC->crTextColor = RGB(0x0,0x0,0x0);
//      pLocalDC->iLevel = 0;
//      pLocalDC->pLocalDCSaved = NULL;
//      pLocalDC->ulBytesEmitted = 0;
//      pLocalDC->ulMaxRecord = 0;
//      pLocalDC->pW32hPal = NULL;
//      pLocalDC->iXORPass = NOTXORPASS;
//      pLocalDC->pvOldPos = NULL;
//      pLocalDC->iROP = 0;

        // Set the advanced graphics mode in the helper DC.  This is needed
        // to notify the helper DC that rectangles and ellipses are
        // inclusive-inclusive etc., especially when rendering them in a path.
        // Also, the world transform can only be set in the advanced mode.

        if( pfnSetVirtualResolution != NULL )
        {
            (void) SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);
        }

        // We are golden.

        pldcRet = pLocalDC;

pldcInitLocalDC_exit:

        if (!pldcRet)
            vFreeLocalDC(pLocalDC);

        return(pldcRet) ;
}

/*****************************************************************************
 * vFreeLocalDC - Free the Local DC and its resources.
 *****************************************************************************/
VOID vFreeLocalDC(PLOCALDC pLocalDC)
{
    UINT i;

// Free the helper DCs.

    if (pLocalDC->hdcHelper)
        if (!DeleteDC(pLocalDC->hdcHelper))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#if 0
    if (pLocalDC->hdcDisp)
        if (!DeleteDC(pLocalDC->hdcDisp))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteDC failed");
#endif // 0

    if (pLocalDC->hbmpMem)
    {
        if (!DeleteObject(pLocalDC->hbmpMem))
        {
            ASSERTGDI(FALSE, "GPMF3216: vFreeLocalDC, DeleteObject failed");
        }
    }

// Free the storage for the object translation map.

    if (pLocalDC->piW32ToW16ObjectMap)
    {
#if 0
        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
        {
            if (pLocalDC->piW32ToW16ObjectMap[i] != UNMAPPED)
                if (i > STOCK_LAST)
                    PUTS1("MF3216: vFreeLocalDC, object32 %ld is not freed\n", i - STOCK_LAST - 1);
                else
                    PUTS1("MF3216: vFreeLocalDC, stock object32 %ld is mapped\n",i);
        }
#endif // 0

        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the W32 palette handles.

    if (pLocalDC->pW32hPal)
    {
    for (i = 0; i < pLocalDC->cW32hPal; i++)
    {
        if (pLocalDC->pW32hPal[i])
                if (!DeleteObject(pLocalDC->pW32hPal[i]))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, delete palette failed");
    }

        if (LocalFree(pLocalDC->pW32hPal))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

// Free the w32 handles in the pW16ObjHndlSlotStatus array.
// We free the handles after we have deleted the helper DC so that
// the w32 handles are not selected into any DC.

    if (pLocalDC->pW16ObjHndlSlotStatus)
    {
        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
#if 0
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use
                != OPEN_AVAILABLE_SLOT)
                PUTS1("MF3216: vFreeLocalDC, object16 %ld is not freed\n", i);
#endif // 0

            if (pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle)
            {
                ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].use
                          != OPEN_AVAILABLE_SLOT,
                          "MF3216: error in object handle table");

                if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle))
                    ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, DeleteObject failed");
            }
        }

        if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
    }

    ASSERTGDI((pLocalDC->flags & (ERR_BUFFER_OVERFLOW | ERR_XORCLIPPATH)) ||
              (pLocalDC->pW16RecreationSlot == NULL),
              "MF3216 Recreation slots haven't been freed");
    DoDeleteRecreationSlots(pLocalDC);

    // The DC level should be balanced.
    if (pLocalDC->pLocalDCSaved != NULL)
    {
        PLOCALDC pNext, pTmp;

        for (pNext = pLocalDC->pLocalDCSaved; pNext; )
        {
            PUTS("MF3216: vFreeLocalDC, unbalanced DC level\n");

            pTmp = pNext->pLocalDCSaved;
            if (LocalFree(pNext))
            ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
            pNext = pTmp;
        }
    }

// Finally, free the LocalDC.

    if (LocalFree(pLocalDC))
        ASSERTGDI(FALSE, "MF3216: vFreeLocalDC, LocalFree failed");
}


/***************************************************************************
 *  Handle emitting the Win32  metafile comment  record(s).
 **************************************************************************/
BOOL bHandleWin32Comment(PLOCALDC pLocalDC)
{
INT     i;
BOOL    b ;
META_ESCAPE_ENHANCED_METAFILE mfeEnhMF;

    // Win30 may have problems with large (over 8K) escape records.
    // We will limit the size of each Win32 Comment record to
    // MAX_WIN32_COMMENT_REC_SIZE.

    // Initialize the record header.

    mfeEnhMF.rdFunction = META_ESCAPE;
    mfeEnhMF.wEscape    = MFCOMMENT;
    mfeEnhMF.ident      = MFCOMMENT_IDENTIFIER;
    mfeEnhMF.iComment   = MFCOMMENT_ENHANCED_METAFILE;
    mfeEnhMF.nVersion   = ((PENHMETAHEADER) pLocalDC->pMf32Bits)->nVersion;
    mfeEnhMF.wChecksum  = 0;   // updated by bMemUpdateCheckSum
    mfeEnhMF.fFlags     = 0;
    mfeEnhMF.nCommentRecords
    = (pLocalDC->cMf32Bits + MAX_WIN32_COMMENT_REC_SIZE - 1)
      / MAX_WIN32_COMMENT_REC_SIZE;
    mfeEnhMF.cbEnhMetaFile = pLocalDC->cMf32Bits;

    mfeEnhMF.cbRemainder = pLocalDC->cMf32Bits;
    i = 0 ;
    while (mfeEnhMF.cbRemainder)
    {
    mfeEnhMF.cbCurrent = min(mfeEnhMF.cbRemainder, MAX_WIN32_COMMENT_REC_SIZE);
    mfeEnhMF.rdSize = (sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent) / 2;
    mfeEnhMF.wCount = (WORD)(sizeof(mfeEnhMF) + mfeEnhMF.cbCurrent - sizeof(METARECORD_ESCAPE));
    mfeEnhMF.cbRemainder -= mfeEnhMF.cbCurrent;

    b = bEmitWin16EscapeEnhMetaFile(pLocalDC,
        (PMETARECORD_ESCAPE) &mfeEnhMF, &pLocalDC->pMf32Bits[i]);

    if (!b)
        break;
    i += mfeEnhMF.cbCurrent;
    }

    return(b) ;
}


/*****************************************************************************
 * bMemUpdateCheckSum - Update the checksum
 *****************************************************************************/
BOOL bMemUpdateCheckSum(PLOCALDC pLocalDC)
{
INT         i, k ;
PWORD       pword ;
WORD        CheckSum ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;


    // CheckSum the file.
    // Do a 16 bit checksum

    pword = (PWORD) pLocalDC->pMf16Bits ;
    k = pLocalDC->ulBytesEmitted / 2 ;

    CheckSum = 0 ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    // Update the checksum record value with the real checksum.

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
            &pLocalDC->pMf16Bits[sizeof(METAHEADER)];

    ASSERTGDI(IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF)
       && pmfeEnhMF->wChecksum  == 0
       && pmfeEnhMF->fFlags     == 0,
    "MF3216: bMemUpdateCheckSum: Bad pmfeEnhMF");

    pmfeEnhMF->wChecksum = -CheckSum;

#if DBG
    // Now test the checksum.  The checksum of the entire file
    // should be 0.

    CheckSum = 0 ;
    pword = (PWORD) pLocalDC->pMf16Bits ;
    for (i = 0 ; i < k ; i++)
    CheckSum += pword[i] ;

    if (CheckSum != 0)
    {
    RIPS("MF3216: MemUpdateCheckSum, (CheckSum != 0)\n") ;
    }
#endif
    return (TRUE) ;
}


/******************************Public*Routine******************************\
* Mf3216DllInitialize                                                      *
*                                                                          *
* This is the init procedure for MF3216.DLL,                               *
* which is called each time a new                                          *
* process links to it.                                                     *
\**************************************************************************/

BOOL Mf3216DllInitialize(PVOID pvDllHandle, DWORD ulReason, PCONTEXT pcontext)
{
        NOTUSED(pvDllHandle) ;
        NOTUSED(pcontext) ;

        if ( ulReason == DLL_PROCESS_ATTACH )
        {
            // This does the critical section initialization for a single
            // process.  Each process does this.  The CriticalSection data
            // structure is one of the very few (if not the only one) data
            // structures in the data segment.

//            InitializeCriticalSection(&CriticalSection) ;

        }

        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\entry.h ===
#ifndef _MF3216_ENTRY_
#define _MF3216_ENTRY_

BOOL APIENTRY DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection) ;
BOOL APIENTRY DoGdiComment(PLOCALDC pLocalDC, PEMR pEMR);

BOOL APIENTRY DoAngleArc
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y,
     DWORD   ulRadius,
     FLOAT   eStartAngle,
     FLOAT   eSweepAngle
) ;


BOOL APIENTRY DoArcTo
(
     PLOCALDC pLocalDC,
     int x1,
     int y1,
     int x2,
     int y2,
     int x3,
     int y3,
     int x4,
     int y4
) ;

BOOL APIENTRY DoArc
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoStretchBlt(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xSrc,
LONG         ySrc,
LONG         cxSrc,
LONG         cySrc,
PXFORM       pxformSrc,
DWORD        iUsageSrc,
PBITMAPINFO  lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoStretchDIBits
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         cxDst,
LONG         cyDst,
DWORD        rop,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
) ;

BOOL APIENTRY DoSetDIBitsToDevice
(
PLOCALDC     pLocalDC,
LONG         xDst,
LONG         yDst,
LONG         xDib,
LONG         yDib,
LONG         cxDib,
LONG         cyDib,
DWORD        iUsage,
DWORD        iStartScan,
DWORD        cScans,
LPBITMAPINFO lpBitmapInfo,
DWORD        cbBitmapInfo,
LPBYTE       lpBits,
DWORD        cbBits
);

BOOL APIENTRY DoChord
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoEllipse
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2
) ;

BOOL APIENTRY DoExtCreateFont
(
    PLOCALDC  pLocalDC,
    INT       ihFont,
    PLOGFONTA plfa
) ;

BOOL APIENTRY DoExtFloodFill
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor,
     DWORD       iFillType
) ;

BOOL APIENTRY DoLineTo
(
     PLOCALDC  pLocalDC,
     LONG    x,
     LONG    y
) ;

BOOL APIENTRY DoMaskBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 LONG         xSrc,
 LONG         ySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfoSrc,
 DWORD        cbBitmapInfoSrc,
 LPBYTE       lpBitsSrc,
 DWORD        cbBitsSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
) ;

BOOL APIENTRY DoPlgBlt
(
    PLOCALDC    pLocalDC,
    PPOINTL pptlDst,
    LONG    xSrc,
    LONG    ySrc,
    LONG    cxSrc,
    LONG    cySrc,
    PXFORM      pxformSrc,
    DWORD   iUsageSrc,
    PBITMAPINFO lpBitmapInfoSrc,
    DWORD       cbBitmapInfoSrc,
    LPBYTE      lpBitsSrc,
    DWORD       cbBitsSrc,
    LONG    xMask,
    LONG    yMask,
    DWORD       iUsageMask,
    PBITMAPINFO lpBitmapInfoMask,
    DWORD       cbBitmapInfoMask,
    LPBYTE      lpBitsMask,
    DWORD       cbBitsMask
) ;

BOOL APIENTRY DoMoveTo
(
     PLOCALDC pLocalDC,
     LONG    x,
     LONG    y
) ;


BOOL APIENTRY DoPie
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3,
     INT x4,
     INT y4
) ;

BOOL APIENTRY DoPolyBezier
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyBezierTo
(
     PLOCALDC pLocalDC,
     LPPOINT pptl,
     DWORD   cptl
) ;

BOOL WINAPI DoPolyDraw
(
    PLOCALDC pLocalDC,
    LPPOINT pptl,
    PBYTE   pb,
    DWORD   cptl
) ;

BOOL APIENTRY DoPoly
(
     PLOCALDC pLocalDC,
     PPOINTL  pptl,
     DWORD    cptl,
     INT      mrType,
     BOOL     transform
) ;

BOOL APIENTRY DoPolylineTo
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     DWORD   cptl
) ;

BOOL APIENTRY DoPolyPolygon
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   cptl,
     DWORD   ccptl,
     BOOL    transform
) ;

BOOL APIENTRY DoPolyPolyline
(
     PLOCALDC pLocalDC,
     PPOINTL pptl,
     PDWORD  pcptl,
     DWORD   ccptl,
     BOOL    transform
) ;

BOOL APIENTRY DoRectangle
(
     PLOCALDC pLocalDC,
     INT    x1,
     INT    y1,
     INT    x2,
     INT    y2
) ;

BOOL APIENTRY DoRestoreDC
(
     PLOCALDC pLocalDC,
     INT nSavedDC
) ;

BOOL APIENTRY DoRoundRect
(
     PLOCALDC pLocalDC,
     INT x1,
     INT y1,
     INT x2,
     INT y2,
     INT x3,
     INT y3
) ;

BOOL APIENTRY DoSaveDC
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSetPixel
(
     PLOCALDC pLocalDC,
     INT         x,
     INT         y,
     COLORREF    crColor
) ;

BOOL APIENTRY DoExtTextOut
(
     PLOCALDC pLocalDC,
     INT     x,                  // Initial x position
     INT     y,                  // Initial y position
     DWORD   flOpts,             // Options
     PRECTL  prcl,               // Clipping rectangle
     PWCH    awch,               // Wide Character array
     DWORD   cch,                // Character count
     PLONG   pDx,                // Character positioning
     DWORD   iGraphicsMode,  // Graphics mode
     INT     mrType              // Either unicode or ANSI
) ;

BOOL APIENTRY DoBeginPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoEndPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoFlattenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoAbortPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoCloseFigure
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoRenderPath
(
     PLOCALDC pLocalDC,
     INT      mrType,
     BOOL     psOnly
);

BOOL APIENTRY DoWidenPath
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoClipRect
(
 PLOCALDC pLocalDC,
 INT xLeft,
 INT yTop,
 INT xRight,
 INT yBottom,
 INT mrType
) ;

BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT       nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
) ;

BOOL APIENTRY DoOffsetClipRgn
(
     PLOCALDC pLocalDC,
     INT x,
     INT y
) ;

BOOL APIENTRY DoSetMetaRgn
(
     PLOCALDC pLocalDC
) ;

BOOL APIENTRY DoSelectClipPath
(
     PLOCALDC pLocalDC,
     INT    iMode
) ;

BOOL APIENTRY DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
) ;

BOOL APIENTRY DoModifyWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf,
     DWORD   imode
) ;

BOOL APIENTRY DoSetMapMode
(
     PLOCALDC pLocalDC,
     DWORD   ulMapMode
) ;

BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;

BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
) ;



BOOL APIENTRY DoSetViewportExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetViewportOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowExt
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWindowOrg
(
     PLOCALDC pLocalDC,
     INT     x,
     INT     y
) ;

BOOL APIENTRY DoSetWorldTransform
(
     PLOCALDC pLocalDC,
     PXFORM  pxf
) ;

BOOL APIENTRY DoDeleteObject
(
     PLOCALDC pLocalDC,
     INT hObject
) ;

BOOL APIENTRY DoSelectObject
(
     PLOCALDC pLocalDC,
     LONG   ihObject
) ;

BOOL APIENTRY DoSetBkColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoSetBkMode
(
     PLOCALDC pLocalDC,
     DWORD   iBkMode
) ;

BOOL APIENTRY DoSetMapperFlags
(
     PLOCALDC pLocalDC,
     DWORD   f
) ;

BOOL APIENTRY DoSetPolyFillMode
(
     PLOCALDC pLocalDC,
     DWORD   iPolyFillMode
) ;

BOOL APIENTRY DoSetRop2
(
     PLOCALDC pLocalDC,
     DWORD   rop
) ;

BOOL APIENTRY DoSetStretchBltMode
(
     PLOCALDC pLocalDC,
     DWORD   iStretchMode
) ;

BOOL APIENTRY DoSetTextAlign
(
     PLOCALDC pLocalDC,
     DWORD   fMode
) ;

BOOL APIENTRY DoSetTextColor
(
     PLOCALDC      pLocalDC,
     COLORREF    crColor
) ;

BOOL APIENTRY DoCreateBrushIndirect
(
     PLOCALDC      pLocalDC,
     INT         ihBrush,
     LPLOGBRUSH  lpLogBrush
) ;

BOOL WINAPI DoCreateDIBPatternBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;

BOOL WINAPI DoCreateMonoBrush
(
    PLOCALDC    pLocalDC,
    DWORD       ihBrush,
    PBITMAPINFO pBitmapInfo,
    DWORD       cbBitmapInfo,
    PBYTE       pBits,
    DWORD       cbBits,
    DWORD       iUsage
) ;


BOOL WINAPI DoCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PLOGPEN     pLogPen
) ;

BOOL WINAPI DoExtCreatePen
(
    PLOCALDC    pLocalDC,
    INT         ihPen,
    PEXTLOGPEN  pExtLogPen
) ;

BOOL APIENTRY DoCreatePalette
(
    PLOCALDC     pLocalDC,
    DWORD        ihPal,
    LPLOGPALETTE lpLogPal
) ;

BOOL APIENTRY DoSelectPalette
(
    PLOCALDC    pLocalDC,
    DWORD   ihpal
) ;

BOOL APIENTRY DoSetPaletteEntries
(
    PLOCALDC       pLocalDC,
    DWORD      ihPal,
    DWORD      iStart,
    DWORD      cEntries,
    LPPALETTEENTRY pPalEntries
);

BOOL APIENTRY DoResizePalette
(
    PLOCALDC    pLocalDC,
    DWORD       ihpal,
    DWORD       cEntries
) ;

BOOL APIENTRY DoRealizePalette
(
    PLOCALDC    pLocalDC
);

BOOL APIENTRY DoHeader
(
    PLOCALDC pLocalDC,
    PENHMETAHEADER pemfheader
) ;

BOOL APIENTRY DoEOF
(
    PLOCALDC  pLocalDC
) ;

BOOL APIENTRY DoRemoveObjects
(
    PLOCALDC pLocalDC
) ;

BOOL WINAPI DoDeleteRecreationSlots
(
    PLOCALDC pLocalDC
) ;

BOOL WINAPI DoMakeBitmapBottomUp
(
 PBITMAPINFO lpBitmapInfo,
 DWORD       cbBitmapInfo,
 LPBYTE      lpBits,
 DWORD       cbBits
) ;


#endif  // _MF3216_ENTRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\bitmaps.c ===
/*****************************************************************************
*
* bitmaps - Entry points for Win32 to Win 16 converter
*
* History:
*  Sep 1992    -by-    Hock San Lee    [hockl]
* Big rewrite.
*
* Copyright 1991 Microsoft Corp
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

HDC hdcMakeCompatibleDC(LPXFORM lpxform);

HBITMAP CreateMonoDib(LPBITMAPINFO pbmi, CONST BYTE * pjBits, UINT iUsage);

BOOL bEmitBitmap(PLOCALDC pLocalDC, HBITMAP hbm,
                 LONG xDst, LONG yDst, LONG cxDst, LONG cyDst,
                 LONG xSrc, LONG ySrc, LONG cxSrc, LONG cySrc, DWORD rop);

BOOL WINAPI DoMakeBitmapBottomUp
(
 PBITMAPINFO lpBitmapInfo,
 DWORD       cbBitmapInfo,
 LPBYTE      lpBits,
 DWORD       cbBits
 );



#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

/****************************** Internal Function **************************\
* GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
*
* Returns the number of bytes in the color table for the giving info header
*
\***************************************************************************/

WORD GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
{
    PUTS("GetSizeOfColorTable\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "GetSizeOfColorTable: dword alignment error\n");

    if (lpDIBInfo->biBitCount == 16 || lpDIBInfo->biBitCount == 32)
        return(3 * sizeof(DWORD));

    if (lpDIBInfo->biClrUsed)
        return((WORD)lpDIBInfo->biClrUsed * (WORD)sizeof(RGBQUAD));

    if (lpDIBInfo->biBitCount < 16)
        return((1 << lpDIBInfo->biBitCount) * sizeof(RGBQUAD));
    else
        return(0);
}



BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
 );

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
 );

BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
 );



 /***************************************************************************
 * SetDIBitsToDevice - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR2: Notes...
 *      The xDib, yDib, cxDib, & cyDib are in device units.  These must be
 *      converted to logical units for the stretchblt.
**************************************************************************/
BOOL APIENTRY DoSetDIBitsToDevice
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         xDib,
 LONG         yDib,
 LONG         cxDib,
 LONG         cyDib,
 DWORD        iUsage,
 DWORD        iStartScan,
 DWORD        cScans,
 LPBITMAPINFO lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
 )
{
    BOOL    b ;
    LPBITMAPINFO pbmi;
    POINTL       ptlDst ;
    RECTL        rclDst ;

    b = FALSE;

    if (!cbBitmapInfo)
        return(FALSE);

    // Adjust the height of the bitmap we're going to Blt.

    pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (pbmi == (LPBITMAPINFO) NULL)
        goto dsdbd_exit;

    RtlCopyMemory(pbmi, lpBitmapInfo, cbBitmapInfo);
    pbmi->bmiHeader.biHeight = cScans;
    pbmi->bmiHeader.biSizeImage = cbBits;

    // We will convert it into a StretchBlt call.  But first we have to
    // transform the destination rectangle.  In SetDIBitsToDevice, the destination
    // rectangle is in device units but in StretchBlt, it is in logical units.

    // Transform the destination origin to the device units on the original device.

    ptlDst.x = xDst;
    ptlDst.y = yDst;
    if (!bXformRWorldToRDev(pLocalDC, &ptlDst, 1))
        goto dsdbd_exit;

    // Transform the destination rectangle to record time world coordinates.

    rclDst.left   = ptlDst.x;
    rclDst.top    = ptlDst.y;
    rclDst.right  = ptlDst.x + cxDib;
    rclDst.bottom = ptlDst.y + cyDib;
    if (!bXformRDevToRWorld(pLocalDC, (PPOINTL) &rclDst, 2))
        goto dsdbd_exit;

    b = DoStretchBlt
        (
        pLocalDC,
        rclDst.left,
        rclDst.top,
        rclDst.right - rclDst.left,
        rclDst.bottom - rclDst.top,
        SRCCOPY,
        xDib,
        // dib to bitmap units
        ABS(pbmi->bmiHeader.biHeight) - yDib - cyDib + (LONG) iStartScan,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        pbmi,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

dsdbd_exit:
    if (pbmi)
        LocalFree(pbmi);

    return(b);
}


/***************************************************************************
* StretchDIBits - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoStretchDIBits
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xDib,
 LONG         yDib,
 LONG         cxDib,
 LONG         cyDib,
 DWORD        iUsage,
 LPBITMAPINFO lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
 )
{
    BOOL    b ;

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xDib,
        ISSOURCEINROP3(rop)
        // dib to bitmap units
        ? ABS(lpBitmapInfo->bmiHeader.biHeight) - yDib - cyDib
        : 0,
        cxDib,
        cyDib,
        &xformIdentity,     // source is in device units
        iUsage,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

    return(b) ;
}


/***************************************************************************
*  StretchBltAlt
**************************************************************************/
BOOL APIENTRY DoStretchBltAlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 HDC          hdcSrc,
 HBITMAP      hbmSrc,
 PXFORM       pxformSrc
 )
{
    BITMAPINFOHEADER bmih;
    DWORD            cbBitmapInfo;
    LPBITMAPINFO     lpBitmapInfo;
    DWORD            cbBits;
    LPBYTE           lpBits;
    BOOL         b;

    b = FALSE;

    // A NOOP ROP do nothing
    if (rop == 0x00AA0029)
    {
        return TRUE;
    }
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    if (!ISSOURCEINROP3(rop))
        return
        (
        DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        0,
        0,
        0,
        0,
        (PXFORM) NULL,
        0,
        (PBITMAPINFO) NULL,
        0,
        (LPBYTE) NULL,
        0
        )
        );

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;

    if (!GetDIBits(hdcSrc,
        hbmSrc,
        0,
        0,
        (LPBYTE) NULL,
        (LPBITMAPINFO) &bmih,
        DIB_RGB_COLORS))
        goto dsba_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biBitCount == 16 || bmih.biBitCount == 32)
        cbBitmapInfo += 3 * sizeof(DWORD);
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
        cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
        ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto dsba_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto dsba_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(hdcSrc,
        hbmSrc,
        0,
        (UINT) ABS(bmih.biHeight),
        lpBits,
        lpBitmapInfo,
        DIB_RGB_COLORS))
        goto dsba_exit;

    // Call DoStretchBlt.

    b = DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        DIB_RGB_COLORS,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits
        );

dsba_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
}


/***************************************************************************
*  StretchBlt  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits,
 DWORD        cbBits
 )
{
    BOOL    b;
    RECTL   rclDst,
            rclSrc;

    // A NOOP ROP do nothing
    if (rop == 0x00AA0029)
    {
        return TRUE;
    }


    // Handle strange destination transform separately.

    if (pLocalDC->flags & STRANGE_XFORM)
        return
        (
        DoRotatedStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        rop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        iUsageSrc,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits
        )
        );

    if (pLocalDC->iXORPass != NOTXORPASS)
    {
        if (rop == SRCCOPY)
        {
            rop = SRCINVERT;
        }
        else if (rop == PATCOPY)
        {
            rop = PATINVERT;
        }
        else
        {
            pLocalDC->flags |= ERR_XORCLIPPATH;
            return FALSE;
        }
    }


    // Do stretchblt with a simple destination transform.

    // Translate the dest rectangle

    rclDst.left   = xDst;
    rclDst.top    = yDst;
    rclDst.right  = xDst + cxDst;
    rclDst.bottom = yDst + cyDst;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rclDst, 2))
        return(FALSE);

    // Handle stretchblt without source

    if (!ISSOURCEINROP3(rop))
    {
        // Emit the Win16 metafile record.

        b = bEmitWin16BitBltNoSrc(pLocalDC,
            (SHORT) rclDst.left,
            (SHORT) rclDst.top,
            (SHORT) (rclDst.right - rclDst.left),
            (SHORT) (rclDst.bottom - rclDst.top),
            rop);
        return(b);
    }

    // Handle stretchblt with source

    // Note: Both Win32 and Win16 DIB Bitmaps are DWord aligned.

    // Make sure the source xform is valid.
    // The source is not allowed to have a rotation or shear.

    if (bRotationTest(pxformSrc) == TRUE)
    {
        RIPS("MF3216: DoStretchBlt - Invalid source xform\n");
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    // Translate the source rectangle.  Win3.1 assumes that the
    // source rectangle is in bitmap units.

    rclSrc.left   = xSrc;
    rclSrc.top    = ySrc;
    rclSrc.right  = xSrc + cxSrc;
    rclSrc.bottom = ySrc + cySrc;
    if (!bXformWorkhorse((PPOINTL) &rclSrc, 2, pxformSrc))
        return(FALSE);

    // The win3.1 StretchBlt metafile record only accepts win3.1 standard
    // bitmap with DIB_RGB_COLORS usage.  If this is not the case, we have
    // to convert it to a standard bitmap.

    if (iUsageSrc != DIB_RGB_COLORS
        || lpBitmapInfo->bmiHeader.biPlanes != 1
        || !(lpBitmapInfo->bmiHeader.biBitCount == 1
        || lpBitmapInfo->bmiHeader.biBitCount == 4
        || lpBitmapInfo->bmiHeader.biBitCount == 8
        || lpBitmapInfo->bmiHeader.biBitCount == 24)
        || lpBitmapInfo->bmiHeader.biCompression != BI_RGB )
    {
        HBITMAP hbmSrc;
        DWORD fdwInit;

        b = FALSE;
        hbmSrc = (HBITMAP) 0;

        if( ( lpBitmapInfo->bmiHeader.biCompression == BI_RGB ) ||
            ( lpBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS ) )
        {
            fdwInit = CBM_INIT | CBM_CREATEDIB;
        }
        else
        {
            fdwInit = CBM_INIT;
        }

        // Create the source bitmap.
        // Use the helper DC in CreateDIBitmap so that the colors get bind correctly.
        if (!(hbmSrc = CreateDIBitmap(
            pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) lpBitmapInfo,
            fdwInit,
            lpBits,
            lpBitmapInfo,
            (UINT) iUsageSrc)))
            goto dsb_internal_exit;

        // Emit the bitmap.

        b = bEmitBitmap(pLocalDC,
            hbmSrc,
            rclDst.left,
            rclDst.top,
            rclDst.right - rclDst.left,
            rclDst.bottom - rclDst.top,
            rclSrc.left,
            rclSrc.top,
            rclSrc.right - rclSrc.left,
            rclSrc.bottom - rclSrc.top,
            rop);

dsb_internal_exit:
        if (hbmSrc)
            DeleteObject(hbmSrc);
    }
    else
    {
        // Win98 might have added a MAX_PATH in the EMR_STRETCHDIBits
        // We need to remove it because WMF don't support it
        cbBitmapInfo = lpBitmapInfo->bmiHeader.biSize + GetSizeOfColorTable(&(lpBitmapInfo->bmiHeader));
        DoMakeBitmapBottomUp(lpBitmapInfo, cbBitmapInfo, lpBits, cbBits);
        // Handle the standard formats.

        // Emit a Win16 metafile record.
        b = bEmitWin16StretchBlt(pLocalDC,
            (SHORT) rclDst.left,
            (SHORT) rclDst.top,
            (SHORT) (rclDst.right - rclDst.left),
            (SHORT) (rclDst.bottom - rclDst.top),
            (SHORT) rclSrc.left,
            (SHORT) rclSrc.top,
            (SHORT) (rclSrc.right - rclSrc.left),
            (SHORT) (rclSrc.bottom - rclSrc.top),
            rop,
            lpBitmapInfo,
            cbBitmapInfo,
            lpBits,
            cbBits);
    }

    return(b);
}

BOOL APIENTRY DoRotatedStretchBlt
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop,
 LONG         xSrc,
 LONG         ySrc,
 LONG         cxSrc,
 LONG         cySrc,
 PXFORM       pxformSrc,
 DWORD        iUsageSrc,
 PBITMAPINFO  lpBitmapInfo,
 DWORD        cbBitmapInfo,
 LPBYTE       lpBits
 )
{
    BOOL    b;
    POINTL  aptlDst[4];
    RECTL   rclBndDst;
    HDC     hdcShadow, hdcSrc;
    HBITMAP hbmShadow, hbmShadowOld, hbmSrc, hbmSrcOld;
    PBITMAPINFO pbmiShadow;

    b = FALSE;
    if (pLocalDC->iXORPass != NOTXORPASS)
    {
        if (rop == SRCCOPY)
        {
            rop = SRCINVERT;
        }
        else if (rop == PATCOPY)
        {
            rop = PATINVERT;
        }
        else
        {
            pLocalDC->flags |= ERR_XORCLIPPATH;
            return FALSE;
        }
    }

    hdcShadow = hdcSrc = (HDC) 0;
    hbmShadow = hbmShadowOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;
    pbmiShadow = (PBITMAPINFO) NULL;

    // First, compute the bounds of the destination rectangle.

    aptlDst[0].x = xDst;
    aptlDst[0].y = yDst;
    aptlDst[1].x = xDst + cxDst;
    aptlDst[1].y = yDst;
    aptlDst[2].x = xDst + cxDst;
    aptlDst[2].y = yDst + cyDst;
    aptlDst[3].x = xDst;
    aptlDst[3].y = yDst + cyDst;

    if (!bXformRWorldToPPage(pLocalDC, aptlDst, 4))
        goto drsb_exit;

    rclBndDst.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndDst.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndDst.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

    // Prepare the source if any.

    if (ISSOURCEINROP3(rop))
    {
        // Create a compatible shadow DC with the destination transform.

        if (!(hdcShadow = hdcMakeCompatibleDC(&pLocalDC->xformRWorldToPPage)))
            goto drsb_exit;

        // Create a shadow bitmap the size of the destination rectangle bounds.
        // Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        pbmiShadow = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
        if (pbmiShadow == (PBITMAPINFO) NULL)
            goto drsb_exit;
        RtlCopyMemory(pbmiShadow, lpBitmapInfo, cbBitmapInfo);
        pbmiShadow->bmiHeader.biWidth  = rclBndDst.right - rclBndDst.left;
        pbmiShadow->bmiHeader.biHeight = rclBndDst.bottom - rclBndDst.top;
        pbmiShadow->bmiHeader.biSizeImage = 0;
        if (!(hbmShadow = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) pbmiShadow, CBM_CREATEDIB,
            (LPBYTE) NULL, pbmiShadow, iUsageSrc)))
            goto drsb_exit;

        // Select the bitmap.

        if (!(hbmShadowOld = (HBITMAP) SelectObject(hdcShadow, hbmShadow)))
            goto drsb_exit;

        // Create a compatible source DC with the given source transform.

        if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
            goto drsb_exit;

        // Create the source bitmap.
        // Use the helper DC in CreateDIBitmap so that the colors get bind correctly.

        if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
            (LPBITMAPINFOHEADER) lpBitmapInfo,
            CBM_INIT | CBM_CREATEDIB,
            lpBits,
            (LPBITMAPINFO) lpBitmapInfo,
            (UINT) iUsageSrc)))
            goto drsb_exit;

        // Select the bitmap.

        if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
            goto drsb_exit;

        // Set up the viewport origin of the shadow DC so that the destination
        // rectangle will map into coordinates within the shadow bitmap.

        OffsetViewportOrgEx(hdcShadow, (int) -rclBndDst.left,
            (int) -rclBndDst.top, (LPPOINT) NULL);

        // Stretch the source to the shadow.

        if (!StretchBlt
            (
            hdcShadow,
            (int) xDst,
            (int) yDst,
            (int) cxDst,
            (int) cyDst,
            hdcSrc,
            (int) xSrc,
            (int) ySrc,
            (int) cxSrc,
            (int) cySrc,
            SRCCOPY
            )
            )
            goto drsb_exit;

        // Deselect the shadow bitmap.

        if (!SelectObject(hdcShadow, hbmShadowOld))
            goto drsb_exit;

    }

    // Save the DC so that we can restore the clipping when we are done

    if (!DoSaveDC(pLocalDC))
        goto drsb_exit;

    // Set up the clipping rectangle on the destination.

    if (!DoClipRect(pLocalDC, xDst, yDst,
        xDst + cxDst, yDst + cyDst, EMR_INTERSECTCLIPRECT))
    {
        (void) DoRestoreDC(pLocalDC, -1);
        goto drsb_exit;
    }

    // Blt the shadow to the destination.

    // Emit a Win16 metafile record.

    if (ISSOURCEINROP3(rop))
        b = bEmitBitmap(pLocalDC,
        hbmShadow,
        rclBndDst.left,
        rclBndDst.top,
        rclBndDst.right - rclBndDst.left,
        rclBndDst.bottom - rclBndDst.top,
        0,
        0,
        rclBndDst.right - rclBndDst.left,
        rclBndDst.bottom - rclBndDst.top,
        rop);
    else
        b = bEmitWin16BitBltNoSrc(pLocalDC,
        (SHORT) rclBndDst.left,
        (SHORT) rclBndDst.top,
        (SHORT) (rclBndDst.right - rclBndDst.left),
        (SHORT) (rclBndDst.bottom - rclBndDst.top),
        rop);

    // Restore the clipping region.

    (void) DoRestoreDC(pLocalDC, -1);

    // Cleanup

drsb_exit:

    if (hbmShadowOld)
        SelectObject(hdcShadow, hbmShadowOld);
    if (hbmShadow)
        DeleteObject(hbmShadow);
    if (hdcShadow)
        DeleteDC(hdcShadow);

    if (hbmSrcOld)
        SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrc)
        DeleteObject(hbmSrc);
    if (hdcSrc)
        DeleteDC(hdcSrc);

    if (pbmiShadow)
        LocalFree((HANDLE) pbmiShadow);
    return(b);
}

/*****************************************************************************
* hdcMakeCompatibleDC
*   Create a compatible DC with the given transform.
****************************************************************************/
HDC hdcMakeCompatibleDC(LPXFORM lpxform)
{
    HDC     hdc;

    hdc = CreateCompatibleDC((HDC) 0);
    if(hdc == 0)
    {
        RIPS("MF3216: hdcMakeCompatibleDC, CreateCompatibleDC failed\n");
        return (HDC)0;
    }

    // Must be in the advanced graphics mode to modify the world transform.

    SetGraphicsMode(hdc, GM_ADVANCED);

    // Set the transform.

    if (!SetWorldTransform(hdc, lpxform))
    {
        DeleteDC(hdc);
        RIPS("MF3216: hdcMakeCompatibleDC, SetWorldTransform failed\n");
        return((HDC) 0);
    }

    return(hdc);
}

/***************************************************************************
* bEmitBitmap
**************************************************************************/
BOOL bEmitBitmap
(
 PLOCALDC pLocalDC,
 HBITMAP  hbm,
 LONG     xDst,
 LONG     yDst,
 LONG     cxDst,
 LONG     cyDst,
 LONG     xSrc,
 LONG     ySrc,
 LONG     cxSrc,
 LONG     cySrc,
 DWORD    rop
 )
{
    BITMAPINFOHEADER bmih;
    DWORD            cbBitmapInfo;
    LPBITMAPINFO     lpBitmapInfo;
    DWORD            cbBits;
    LPBYTE           lpBits;
    BOOL         b;

    b = FALSE;
    lpBitmapInfo = (LPBITMAPINFO) NULL;
    lpBits       = (LPBYTE) NULL;

    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biBitCount = 0;    // don't fill in color table
    bmih.biCompression = BI_RGB;
    if (!GetDIBits(pLocalDC->hdcHelper, hbm, 0, 0,
        (LPBYTE) NULL, (LPBITMAPINFO) &bmih, DIB_RGB_COLORS))
        goto eb_exit;

    // Compute size of the bitmap info with color table.

    cbBitmapInfo= sizeof(BITMAPINFOHEADER);
    if (bmih.biPlanes != 1 || bmih.biBitCount == 16 || bmih.biBitCount == 32)
    {
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;
    }
    else if (bmih.biClrUsed)
        cbBitmapInfo += bmih.biClrUsed * sizeof(RGBQUAD);
    else if (bmih.biBitCount < 16)
        cbBitmapInfo += (1 << bmih.biBitCount) * sizeof(RGBQUAD);

    // Compute size of the buffer required for bitmap bits.

    if (bmih.biSizeImage)
        cbBits = bmih.biSizeImage;
    else
        cbBits = CJSCAN(bmih.biWidth,bmih.biPlanes, bmih.biBitCount) *
        ABS(bmih.biHeight);

    lpBitmapInfo = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfo);
    if (lpBitmapInfo == (LPBITMAPINFO) NULL)
        goto eb_exit;

    lpBits = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpBits == (LPBYTE) NULL)
        goto eb_exit;

    // Get bitmap info and bits.

    *(PBITMAPINFOHEADER) lpBitmapInfo = bmih;

    if (!GetDIBits(pLocalDC->hdcHelper,
        hbm,
        0,
        (UINT) ABS(bmih.biHeight),
        lpBits,
        lpBitmapInfo,
        DIB_RGB_COLORS))
        goto eb_exit;

    // Emit the metafile record.

    b = bEmitWin16StretchBlt(pLocalDC,
        (SHORT) xDst,
        (SHORT) yDst,
        (SHORT) cxDst,
        (SHORT) cyDst,
        (SHORT) xSrc,
        (SHORT) ySrc,
        (SHORT) cxSrc,
        (SHORT) cySrc,
        rop,
        lpBitmapInfo,
        cbBitmapInfo,
        lpBits,
        cbBits);
eb_exit:
    if (lpBitmapInfo)
        LocalFree((HANDLE) lpBitmapInfo);
    if (lpBits)
        LocalFree((HANDLE) lpBits);

    return(b);
 }


 /***************************************************************************
 *  MaskBlt  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
 BOOL APIENTRY DoMaskBlt
     (
     PLOCALDC     pLocalDC,
     LONG         xDst,
     LONG         yDst,
     LONG         cxDst,
     LONG         cyDst,
     DWORD        rop4,
     LONG         xSrc,
     LONG         ySrc,
     PXFORM       pxformSrc,
     DWORD        iUsageSrc,
     PBITMAPINFO  lpBitmapInfoSrc,
     DWORD        cbBitmapInfoSrc,
     LPBYTE       lpBitsSrc,
     DWORD        cbBitsSrc,
     LONG         xMask,
     LONG         yMask,
     DWORD        iUsageMask,
     PBITMAPINFO  lpBitmapInfoMask,
     DWORD        cbBitmapInfoMask,
     LPBYTE       lpBitsMask,
     DWORD        cbBitsMask
     )
 {
     BOOL    b;
     DWORD   rop1;
     DWORD   rop0;
     HDC     hdcMask, hdcSrc;
     HBITMAP hbmMask, hbmMaskOld, hbmSrc, hbmSrcOld;
     RECTL   rclMask;

     b    = FALSE;
     hdcMask = hdcSrc = (HDC) 0;
     hbmMask = hbmMaskOld = hbmSrc = hbmSrcOld = (HBITMAP) 0;

     rop0 = rop4 >> 8;           // rop for 0's
     rop1 = rop4 & 0xFF0000;     // rop for 1's

     // If no mask is given, the mask is assumed to contain all 1's.
     // This is equivalent to a BitBlt using the low rop.

     if (!cbBitmapInfoMask)
         return
         (
         DoStretchBlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         rop1,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         pxformSrc,
         iUsageSrc,
         lpBitmapInfoSrc,
         cbBitmapInfoSrc,
         lpBitsSrc,
         cbBitsSrc
         )
         );

     // Handle MaskBlt with no source bitmap.

     if (!ISSOURCEINROP3(rop4))
         return
         (
         DoMaskBltNoSrc
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         rop4,
         pxformSrc,
         xMask,
         yMask,
         iUsageMask,
         lpBitmapInfoMask,
         cbBitmapInfoMask,
         lpBitsMask,
         cbBitsMask
         )
         );

     // Create a compatible mask DC.

     if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
         goto dmb_exit;

     // Must be in the advanced graphics mode to modify the world transform.

     SetGraphicsMode(hdcMask, GM_ADVANCED);

     // Create the mask bitmap.
     // Make it as big as the source and initialize it.

     // Create the mask bitmap as big as the source bitmap.

     if (!(hbmMask = CreateBitmap((int) lpBitmapInfoSrc->bmiHeader.biWidth,
         (int) lpBitmapInfoSrc->bmiHeader.biHeight,
         1, 1, (CONST VOID *) NULL)))
         goto dmb_exit;

     // Select the bitmap.

     if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
         goto dmb_exit;

     // Initialize the mask bitmap to 0's.

     if (!PatBlt(hdcMask,0,0,(int) lpBitmapInfoSrc->bmiHeader.biWidth,
         (int) lpBitmapInfoSrc->bmiHeader.biHeight,BLACKNESS))
         goto dmb_exit;

     // Compute the mask rectangle.
     // The mask bitmap is aligned against the source device rectangle.

     rclMask.left   = xSrc;
     rclMask.top    = ySrc;
     rclMask.right  = xSrc + cxDst;
     rclMask.bottom = ySrc + cyDst;
     if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
         goto dmb_exit;

     if (rclMask.left > rclMask.right)
         rclMask.left = rclMask.right /* + 1 */;// align the mask against the left edge

     if (rclMask.top > rclMask.bottom)
         rclMask.top = rclMask.bottom /* + 1 */;// align the mask against the top edge

     // Set the mask bits.

     if (!StretchDIBits(hdcMask,
         (int) rclMask.left - xMask,
         (int) rclMask.top  - yMask,
         (int) lpBitmapInfoMask->bmiHeader.biWidth,
         (int) lpBitmapInfoMask->bmiHeader.biHeight,
         (int) 0,
         (int) 0,
         (int) lpBitmapInfoMask->bmiHeader.biWidth,
         (int) lpBitmapInfoMask->bmiHeader.biHeight,
         (CONST VOID *) lpBitsMask,
         (LPBITMAPINFO) lpBitmapInfoMask,
         (UINT) iUsageMask,
         SRCCOPY))
         goto dmb_exit;

     // Set the source transform in the mask DC.

     if (!SetWorldTransform(hdcMask, pxformSrc))
         goto dmb_exit;

     // Create a compatible source DC with the given source transform.

     if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
         goto dmb_exit;

     // Create the source bitmap.
     // We cannot use CBM_CREATEDIB option here because index 0 does not
     // neccesarily contain black and index 15 or 255 does not have to be white.
     // We need a compatible bitmap that contain the standard color table so
     // that we can perform the following rop operations to emulate the maskblt.
     // Gdi uses rgb colors to perform rop operations in dibs, not color indices!
     // The helper DC is needed to create the compatible format bitmap.

     if (!(hbmSrc = CreateDIBitmap(pLocalDC->hdcHelper,
         (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
         CBM_INIT,
         lpBitsSrc,
         (LPBITMAPINFO) lpBitmapInfoSrc,
         (UINT) iUsageSrc)))
         goto dmb_exit;

     // Select the bitmap.

     if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
         goto dmb_exit;

     // We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
     // separately.  For each rop, we need to go through two passes.
     //
     // For the low rop (mask bit 1), we use the following rop table:
     //
     //  P S D | R1  R2
     //  ------+--------
     //  0 0 0 | 0   x
     //  0 0 1 | 1   x
     //  0 1 0 | x   0
     //  0 1 1 | x   1
     //  1 0 0 | 0   x
     //  1 0 1 | 1   x
     //  1 1 0 | x   0
     //  1 1 1 | x   1
     //
     // In the first pass, we AND the mask to the source bitmap to remove
     // the mask 0 bits.  This is then used to get the result (R1) for the
     // bitblt involving source 1's.
     //
     // In the second pass, we OR the NOT of the mask to the source bitmap
     // to obtain the source 0 bits.  This is then used to get the result (R2)
     // for the bitblt involving source 0's.

     // AND the mask to the source bitmap to remove the mask 0 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         SRCAND))
         goto dmb_exit;

     // Get the result (R1) for the bits involving source 1's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop1 & 0xCC0000) | 0x220000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     // OR the NOT of the mask to the source bitmap to obtain the source 0 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         MERGEPAINT))
         goto dmb_exit;

     // Get the result (R2) for the bitblt involving source 0's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop1 & 0x330000) | 0x880000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     // For the high rop (mask bit 0), we use the following rop table:
     //
     //  P S D | R1  R2
     //  ------+--------
     //  0 0 0 | 0   x
     //  0 0 1 | 1   x
     //  0 1 0 | x   0
     //  0 1 1 | x   1
     //  1 0 0 | 0   x
     //  1 0 1 | 1   x
     //  1 1 0 | x   0
     //  1 1 1 | x   1
     //
     // In the first pass, we AND the NOT of the mask to the source bitmap to remove
     // the mask 1 bits.  This is then used to get the result (R1) for the
     // bitblt involving source 1's.
     //
     // In the second pass, we OR the mask to the source bitmap
     // to obtain the source 0 bits.  This is then used to get the result (R2)
     // for the bitblt involving source 0's.

     // Restore the source bits.

     if (!SelectObject(hdcSrc, hbmSrcOld))
         goto dmb_exit;

     if (!SetDIBits(pLocalDC->hdcHelper,
         hbmSrc,
         0,
         (UINT) lpBitmapInfoSrc->bmiHeader.biHeight,
         (CONST VOID *) lpBitsSrc,
         (LPBITMAPINFO) lpBitmapInfoSrc,
         (UINT) iUsageSrc))
         goto dmb_exit;

     if (!SelectObject(hdcSrc, hbmSrc))
         goto dmb_exit;

     // AND the NOT of the mask to the source bitmap to remove the mask 1 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         0x220326))       // DSna
         goto dmb_exit;

     // Get the result (R1) for the bits involving source 1's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop0 & 0xCC0000) | 0x220000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     // OR the mask to the source bitmap to obtain the source 0 bits.

     if (!BitBlt(hdcSrc,
         (int) xSrc, (int) ySrc,
         (int) cxDst, (int) cyDst,
         hdcMask,
         (int) xSrc, (int) ySrc,
         SRCPAINT))
         goto dmb_exit;

     // Get the result (R2) for the bitblt involving source 0's.

     if (!DoStretchBltAlt
         (
         pLocalDC,
         xDst,
         yDst,
         cxDst,
         cyDst,
         (rop0 & 0x330000) | 0x880000,
         xSrc,
         ySrc,
         cxDst,
         cyDst,
         hdcSrc,
         hbmSrc,
         pxformSrc
         )
         )
         goto dmb_exit;

     b = TRUE;

     // Cleanup.

dmb_exit:

     if (hbmMaskOld)
         SelectObject(hdcMask, hbmMaskOld);
     if (hbmMask)
         DeleteObject(hbmMask);
     if (hdcMask)
         DeleteDC(hdcMask);

     if (hbmSrcOld)
         SelectObject(hdcSrc, hbmSrcOld);
     if (hbmSrc)
         DeleteObject(hbmSrc);
     if (hdcSrc)
         DeleteDC(hdcSrc);

     return(b);
}

/***************************************************************************
*  MaskBltNoSrc
**************************************************************************/
BOOL APIENTRY DoMaskBltNoSrc
(
 PLOCALDC     pLocalDC,
 LONG         xDst,
 LONG         yDst,
 LONG         cxDst,
 LONG         cyDst,
 DWORD        rop4,
 PXFORM       pxformSrc,
 LONG         xMask,
 LONG         yMask,
 DWORD        iUsageMask,
 PBITMAPINFO  lpBitmapInfoMask,
 DWORD        cbBitmapInfoMask,
 LPBYTE       lpBitsMask,
 DWORD        cbBitsMask
 )
{
    BOOL    b;
    DWORD   rop1;
    DWORD   rop0;
    HDC     hdcMask;
    HBITMAP hbmMask, hbmMaskOld;
    RECTL   rclMask;
    LONG    cxMask, cyMask;

    b    = FALSE;
    hdcMask = (HDC) 0;
    hbmMask = hbmMaskOld = (HBITMAP) 0;

    rop0 = rop4 >> 8;           // rop for 0's
    rop1 = rop4 & 0xFF0000;     // rop for 1's

    // When no source bitmap is required in the rop4, the mask is used
    // as the source in that the low rop is applied to the corresponding
    // mask 1 bits and the high rop is applied to mask 0 bits.  The source
    // transform is used to determine the mask rectangle to be used.

    // Create a compatible mask DC.

    if (!(hdcMask = CreateCompatibleDC((HDC) 0)))
        goto dmbns_exit;

    // Create the mask bitmap.

    if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
        goto dmbns_exit;

    // Select the bitmap.

    if (!(hbmMaskOld = (HBITMAP) SelectObject(hdcMask, hbmMask)))
        goto dmbns_exit;

    // Compute the mask extents.

    rclMask.left   = 0;
    rclMask.top    = 0;
    rclMask.right  = cxDst;
    rclMask.bottom = cyDst;
    if (!bXformWorkhorse((PPOINTL) &rclMask, 2, pxformSrc))
        goto dmbns_exit;

    cxMask = rclMask.right - rclMask.left;
    cyMask = rclMask.bottom - rclMask.top;

    // Align the mask rectangle.

    if (cxMask < 0)
        xMask = xMask - cxMask + 1;
    if (cyMask < 0)
        yMask = yMask - cyMask + 1;

    // We need to handle the low rop (mask bit 1) and high rop (mask bit 0)
    // separately.
    //
    // For the low rop (mask bit 1), we use the following rop table:
    //
    //  P M D | R
    //  ------+---
    //  0 0 0 | 0
    //  0 0 1 | 1
    //  0 1 0 | x
    //  0 1 1 | x
    //  1 0 0 | 0
    //  1 0 1 | 1
    //  1 1 0 | x
    //  1 1 1 | x
    //
    // The above rop will give us the result for bits that correspond to 1's
    // in the mask bitmap.  The destination bits that correspond to the 0 mask
    // bits will not be changed.  We effectively treat the mask as the source
    // in the operation.

    // Get the result (R) for the bits involving mask 1's.

    if (!DoStretchBltAlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        hdcMask,
        hbmMask,
        &xformIdentity
        )
        )
        goto dmbns_exit;
#if 0
    DoStretchBlt
        (
        pLocalDC,
        xDst,
        yDst,
        cxDst,
        cyDst,
        (rop1 & 0xCC0000) | 0x220000,
        xMask,
        yMask,
        cxMask,
        cyMask,
        &xformIdentity,
        iUsageMask,
        lpBitmapInfoMask,
        cbBitmapInfoMask,
        lpBitsMask,
        cbBitsMask
        )
#endif // 0

        // For the high rop (mask bit 0), we use the following rop table:
        //
        //  P M D | R
        //  ------+---
        //  0 0 0 | x
        //  0 0 1 | x
        //  0 1 0 | 0
        //  0 1 1 | 1
        //  1 0 0 | x
        //  1 0 1 | x
        //  1 1 0 | 0
        //  1 1 1 | 1
        //
        // The above rop will give us the result for bits that correspond to 0's
        // in the mask bitmap.  The destination bits that correspond to the 1 mask
        // bits will not be changed.  We effectively treat the mask as the source
        // in the operation.

        // Get the result (R) for the bits involving mask 0's.

        if (!DoStretchBltAlt
            (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            (rop0 & 0x330000) | 0x880000,
            xMask,
            yMask,
            cxMask,
            cyMask,
            hdcMask,
            hbmMask,
            &xformIdentity
            )
            )
            goto dmbns_exit;
#if 0
        DoStretchBlt
            (
            pLocalDC,
            xDst,
            yDst,
            cxDst,
            cyDst,
            (rop0 & 0x330000) | 0x880000,
            xMask,
            yMask,
            cxMask,
            cyMask,
            &xformIdentity,
            iUsageMask,
            lpBitmapInfoMask,
            cbBitmapInfoMask,
            lpBitsMask,
            cbBitsMask
            )
#endif // 0

            b = TRUE;

        // Cleanup.

dmbns_exit:

        if (hbmMaskOld)
            SelectObject(hdcMask, hbmMaskOld);
        if (hbmMask)
            DeleteObject(hbmMask);
        if (hdcMask)
            DeleteDC(hdcMask);

        return(b);
}


/***************************************************************************
*  PlgBlt  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoPlgBlt
(
 PLOCALDC    pLocalDC,
 PPOINTL     pptlDst,
 LONG        xSrc,
 LONG        ySrc,
 LONG        cxSrc,
 LONG        cySrc,
 PXFORM      pxformSrc,
 DWORD       iUsageSrc,
 PBITMAPINFO lpBitmapInfoSrc,
 DWORD       cbBitmapInfoSrc,
 LPBYTE      lpBitsSrc,
 DWORD       cbBitsSrc,
 LONG        xMask,
 LONG        yMask,
 DWORD       iUsageMask,
 PBITMAPINFO lpBitmapInfoMask,
 DWORD       cbBitmapInfoMask,
 LPBYTE      lpBitsMask,
 DWORD       cbBitsMask
 )
{
    BOOL    b, bMask;
    DWORD   rop4;
    HDC     hdcSrc, hdcSrcRDev;
    PBITMAPINFO pbmiSrcRDev, pbmiMaskRDev;
    LPBYTE  lpBitsSrcRDev, lpBitsMaskRDev;
    DWORD   cbBitsSrcRDev, cbBitsMaskRDev;
    HBITMAP hbmMask, hbmMaskRDev, hbmSrc, hbmSrcRDev, hbmSrcOld, hbmSrcRDevOld;
    RECTL   rclBndRDev;
    POINTL  aptlDst[4];
    POINT   ptMask;
    BITMAPINFOHEADER bmihMask;

    // We are going to convert the PlgBlt into a MaskBlt.  This can be done
    // by converting the source and mask bitmaps to the device space of the
    // recording device and then maskblt the result.

    b      = FALSE;
    hdcSrc = hdcSrcRDev = (HDC) 0;
    hbmMask = hbmMaskRDev = hbmSrc = hbmSrcRDev = hbmSrcOld = hbmSrcRDevOld = (HBITMAP) 0;
    pbmiSrcRDev = pbmiMaskRDev = (PBITMAPINFO) NULL;
    lpBitsSrcRDev = lpBitsMaskRDev = (LPBYTE) NULL;
    bMask = (cbBitmapInfoMask != 0);

    rop4 = 0xAACC0000;          // rop for MaskBlt

    // First, we transform the destination parallelogram to the device space
    // of the recording device.  This device parallelogram is then used in
    // plgblt'ing the source and mask bitmaps to the device space of the
    // recording device.

    aptlDst[0] = pptlDst[0];
    aptlDst[1] = pptlDst[1];
    aptlDst[2] = pptlDst[2];
    aptlDst[3].x = aptlDst[1].x + aptlDst[2].x - aptlDst[0].x;
    aptlDst[3].y = aptlDst[1].y + aptlDst[2].y - aptlDst[0].y;

    if (!bXformRWorldToRDev(pLocalDC, aptlDst, 4))
        goto dpb_exit;

    // Find the bounding rectangle of the parallelogram in the recording
    // device space.  This rectangle is used as the basis of the MaskBlt call.

    rclBndRDev.left   = min(aptlDst[0].x,min(aptlDst[1].x,min(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.top    = min(aptlDst[0].y,min(aptlDst[1].y,min(aptlDst[2].y,aptlDst[3].y)));
    rclBndRDev.right  = max(aptlDst[0].x,max(aptlDst[1].x,max(aptlDst[2].x,aptlDst[3].x)));
    rclBndRDev.bottom = max(aptlDst[0].y,max(aptlDst[1].y,max(aptlDst[2].y,aptlDst[3].y)));

    // Offset the device parallelogram to the origin.

    aptlDst[0].x -= rclBndRDev.left; aptlDst[0].y -= rclBndRDev.top;
    aptlDst[1].x -= rclBndRDev.left; aptlDst[1].y -= rclBndRDev.top;
    aptlDst[2].x -= rclBndRDev.left; aptlDst[2].y -= rclBndRDev.top;
    aptlDst[3].x -= rclBndRDev.left; aptlDst[3].y -= rclBndRDev.top;

    // Create the source bitmap in the recording device space for MaskBlt.
    // The size of the source bitmap is that of rclBndRDev.
    // The source image is then plgblt'd into the device parallelogram.
    // PlgBlt always takes a source bitmap.

    // Create the original source.

    if (!(hdcSrc = hdcMakeCompatibleDC(pxformSrc)))
        goto dpb_exit;

    if (!(hbmSrc = CreateDIBitmap(hdcSrc,
        (LPBITMAPINFOHEADER) lpBitmapInfoSrc,
        CBM_INIT | CBM_CREATEDIB,
        lpBitsSrc,
        (LPBITMAPINFO) lpBitmapInfoSrc,
        (UINT) iUsageSrc)))
        goto dpb_exit;

    if (!(hbmSrcOld = (HBITMAP) SelectObject(hdcSrc, hbmSrc)))
        goto dpb_exit;

    // Create the source for MaskBlt.

    if (!(hdcSrcRDev = CreateCompatibleDC((HDC) 0)))
        goto dpb_exit;

    pbmiSrcRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoSrc);
    if (pbmiSrcRDev == (PBITMAPINFO) NULL)
        goto dpb_exit;
    RtlCopyMemory(pbmiSrcRDev, lpBitmapInfoSrc, cbBitmapInfoSrc);
    pbmiSrcRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiSrcRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiSrcRDev->bmiHeader.biSizeImage = 0;
    if (!(hbmSrcRDev = CreateDIBitmap(hdcSrcRDev, (LPBITMAPINFOHEADER) pbmiSrcRDev,
        CBM_CREATEDIB, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc)))
        goto dpb_exit;

    if (!(hbmSrcRDevOld = (HBITMAP) SelectObject(hdcSrcRDev, hbmSrcRDev)))
        goto dpb_exit;

    // PlgBlt the original source bitmap into the source bitmap for MaskBlt.

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, xSrc, ySrc, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
        goto dpb_exit;

    // Retrieve the source bits for MaskBlt.

    // Get biSizeImage!

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, 0, (LPBYTE) NULL, pbmiSrcRDev, iUsageSrc))
        goto dpb_exit;

    // Compute size of the buffer required for source bits.

    if (pbmiSrcRDev->bmiHeader.biSizeImage)
        cbBitsSrcRDev = pbmiSrcRDev->bmiHeader.biSizeImage;
    else
        cbBitsSrcRDev = CJSCAN(pbmiSrcRDev->bmiHeader.biWidth,
        pbmiSrcRDev->bmiHeader.biPlanes,
        pbmiSrcRDev->bmiHeader.biBitCount)
        * ABS(pbmiSrcRDev->bmiHeader.biHeight);

    lpBitsSrcRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsSrcRDev);
    if (lpBitsSrcRDev == (LPBYTE) NULL)
        goto dpb_exit;

    // Get the source bits.

    if (!GetDIBits(hdcSrcRDev, hbmSrcRDev, 0, (UINT) pbmiSrcRDev->bmiHeader.biHeight,
        lpBitsSrcRDev, pbmiSrcRDev, iUsageSrc))
        goto dpb_exit;

    // Create the mask bitmap in the recording device space for MaskBlt.
    // The size of the mask bitmap is that of rclBndRDev.
    // The mask image is then plgblt'd into the device parallelogram.
    // If a mask is not given, create one that describes the parallelogram
    // for the source.

    if (bMask)
    {
        // Create the original mask.

        if (!(hbmMask = CreateMonoDib(lpBitmapInfoMask, lpBitsMask, (UINT) iUsageMask)))
            goto dpb_exit;

        if (!SelectObject(hdcSrc, hbmMask))
            goto dpb_exit;
    }
    else
    {
        // Create a mask describing the original source bitmap.

        ASSERTGDI(sizeof(BITMAPINFOHEADER) == 0x28,
            "MF3216: DoPlgBlt, BITMAPINFOHEADER has changed!\n");

        iUsageMask       = DIB_PAL_INDICES;
        cbBitmapInfoMask = 0x28;
        lpBitmapInfoMask = (PBITMAPINFO) &bmihMask;

        bmihMask.biSize          = 0x28;
        bmihMask.biWidth         = lpBitmapInfoSrc->bmiHeader.biWidth;
        bmihMask.biHeight        = lpBitmapInfoSrc->bmiHeader.biHeight;
        bmihMask.biPlanes        = 1;
        bmihMask.biBitCount      = 1;
        bmihMask.biCompression   = BI_RGB;
        bmihMask.biSizeImage     = 0;
        bmihMask.biXPelsPerMeter = 0;
        bmihMask.biYPelsPerMeter = 0;
        bmihMask.biClrUsed       = 0;
        bmihMask.biClrImportant  = 0;

        if (!(hbmMask = CreateBitmap((int) bmihMask.biWidth,
            (int) bmihMask.biHeight, 1, 1, (CONST VOID *) NULL)))
            goto dpb_exit;

        if (!SelectObject(hdcSrc, hbmMask))
            goto dpb_exit;

        // Initialize the mask bitmap to 1's.

        if (!PatBlt(hdcSrc,0,0,(int)bmihMask.biWidth,(int)bmihMask.biHeight,WHITENESS))
            goto dpb_exit;
    }

    // Create the mask for MaskBlt.

    pbmiMaskRDev = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, cbBitmapInfoMask);
    if (pbmiMaskRDev == (PBITMAPINFO) NULL)
        goto dpb_exit;
    RtlCopyMemory(pbmiMaskRDev, lpBitmapInfoMask, cbBitmapInfoMask);
    pbmiMaskRDev->bmiHeader.biWidth  = rclBndRDev.right - rclBndRDev.left + 1;
    pbmiMaskRDev->bmiHeader.biHeight = rclBndRDev.bottom - rclBndRDev.top + 1;
    pbmiMaskRDev->bmiHeader.biSizeImage = 0;
    pbmiMaskRDev->bmiHeader.biCompression = BI_RGB;
    if (!(hbmMaskRDev = CreateBitmap(pbmiMaskRDev->bmiHeader.biWidth,
        pbmiMaskRDev->bmiHeader.biHeight, 1, 1, (CONST VOID *) NULL)))
        goto dpb_exit;

    if (!SelectObject(hdcSrcRDev, hbmMaskRDev))
        goto dpb_exit;

    // Initialize the mask bitmap to 0's.

    if (!PatBlt(hdcSrcRDev,0,0,(int)pbmiMaskRDev->bmiHeader.biWidth,
        (int)pbmiMaskRDev->bmiHeader.biHeight,BLACKNESS))
        goto dpb_exit;

    // PlgBlt the original mask bitmap into the mask bitmap for MaskBlt.

    if (bMask)
    {
        ptMask.x = xMask;
        ptMask.y = yMask;
        if (!DPtoLP(hdcSrc, &ptMask, 1))
            goto dpb_exit;
    }
    else
    {
        ptMask.x = xSrc;
        ptMask.y = ySrc;
    }

    if (!PlgBlt(hdcSrcRDev, (LPPOINT) aptlDst, hdcSrc, ptMask.x, ptMask.y, cxSrc, cySrc, (HBITMAP) NULL, 0, 0))
        goto dpb_exit;

    // Retrieve the mask bits for MaskBlt.

    // Compute size of the buffer required for mask bits.

    cbBitsMaskRDev = CJSCAN(pbmiMaskRDev->bmiHeader.biWidth,
        pbmiMaskRDev->bmiHeader.biPlanes,
        pbmiMaskRDev->bmiHeader.biBitCount)
        * ABS(pbmiMaskRDev->bmiHeader.biHeight);

    lpBitsMaskRDev = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBitsMaskRDev);
    if (lpBitsMaskRDev == (LPBYTE) NULL)
        goto dpb_exit;

    // Get the mask bits.

    if (!GetDIBits(hdcSrcRDev, hbmMaskRDev, 0, (UINT) pbmiMaskRDev->bmiHeader.biHeight,
        lpBitsMaskRDev, pbmiMaskRDev, iUsageMask))
        goto dpb_exit;

    // Prepare for the MaskBlt.
    // The destination for the MaskBlt is rclBndRDev.  Since the extents for
    // the destination and source share the same logical values in MaskBlt,
    // we have to set the transform in the destination DC to identity.

    // Save the DC so that we can restore the transform when we are done

    if (!DoSaveDC(pLocalDC))
        goto dpb_exit;

    // Set the transforms to identity.

    if (!DoSetMapMode(pLocalDC, MM_TEXT)
        || !DoModifyWorldTransform(pLocalDC, (PXFORM) NULL, MWT_IDENTITY)
        || !DoSetWindowOrg(pLocalDC, 0, 0)
        || !DoSetViewportOrg(pLocalDC, 0, 0))
        goto dpb_restore_exit;

    // Now do the MaskBlt.

    b = DoMaskBlt
        (
        pLocalDC,
        rclBndRDev.left,        // xDst
        rclBndRDev.top,     // yDst
        rclBndRDev.right - rclBndRDev.left + 1,
        rclBndRDev.bottom - rclBndRDev.top + 1,
        rop4,
        0,              // xSrc
        0,              // ySrc
        &xformIdentity,
        iUsageSrc,
        pbmiSrcRDev,
        cbBitmapInfoSrc,
        lpBitsSrcRDev,
        cbBitsSrcRDev,
        0,              // xMask
        0,              // yMask
        iUsageMask,
        pbmiMaskRDev,
        cbBitmapInfoMask,
        lpBitsMaskRDev,
        cbBitsMaskRDev
        );

    // Restore the transforms.

dpb_restore_exit:

    (void) DoRestoreDC(pLocalDC, -1);

    // Cleanup.

dpb_exit:

    if (hbmSrcOld)
        SelectObject(hdcSrc, hbmSrcOld);
    if (hbmSrcRDevOld)
        SelectObject(hdcSrcRDev, hbmSrcRDevOld);

    if (hbmSrc)
        DeleteObject(hbmSrc);
    if (hbmSrcRDev)
        DeleteObject(hbmSrcRDev);
    if (hbmMask)
        DeleteObject(hbmMask);
    if (hbmMaskRDev)
        DeleteObject(hbmMaskRDev);

    if (hdcSrc)
        DeleteDC(hdcSrc);
    if (hdcSrcRDev)
        DeleteDC(hdcSrcRDev);

    if (pbmiSrcRDev)
        LocalFree((HANDLE) pbmiSrcRDev);
    if (pbmiMaskRDev)
        LocalFree((HANDLE) pbmiMaskRDev);
    if (lpBitsSrcRDev)
        LocalFree((HANDLE) lpBitsSrcRDev);
    if (lpBitsMaskRDev)
        LocalFree((HANDLE) lpBitsMaskRDev);

    return(b);
}


/***************************************************************************
*  SetPixel  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetPixel
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor
 )
{
    POINTL  ptl ;
    BOOL    b ;

    ptl.x = (LONG) x ;
    ptl.y = (LONG) y ;

    b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
    if (b == FALSE)
        goto exit1 ;

    b = bEmitWin16SetPixel(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor) ;
exit1:
    return(b) ;
}


/***************************************************************************
*  SetStretchBltMode  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetStretchBltMode
(
 PLOCALDC  pLocalDC,
 DWORD   iStretchMode
 )
{
    BOOL    b ;

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetStretchBltMode(pLocalDC, LOWORD(iStretchMode)) ;

    return(b) ;
}

BOOL WINAPI DoMakeBitmapBottomUp
(
 PBITMAPINFO lpBitmapInfo,
 DWORD       cbBitmapInfo,
 LPBYTE      lpBits,
 DWORD       cbBits
 )
{
    BYTE * lpNewBits;
    DWORD  destByteWidth;
    BYTE * destRaster, * srcRaster;
    INT i;
   // If it's already Bottom-Up then nothing to do
    if (lpBitmapInfo->bmiHeader.biHeight >= 0)
    {
        return TRUE;
    }

    if (lpBitmapInfo->bmiHeader.biPlanes != 1 ||
        !(lpBitmapInfo->bmiHeader.biBitCount == 1 ||
        lpBitmapInfo->bmiHeader.biBitCount == 4 ||
        lpBitmapInfo->bmiHeader.biBitCount == 8 ||
        lpBitmapInfo->bmiHeader.biBitCount == 16 ||
        lpBitmapInfo->bmiHeader.biBitCount == 24 ||
        lpBitmapInfo->bmiHeader.biBitCount == 32)
        || lpBitmapInfo->bmiHeader.biCompression != BI_RGB )
    {
        return FALSE;
    }

    lpBitmapInfo->bmiHeader.biHeight = ABS(lpBitmapInfo->bmiHeader.biHeight);
    lpNewBits = (BYTE*) LocalAlloc(LMEM_FIXED, cbBits);
    if (lpNewBits == NULL)
    {
        return FALSE;
    }

    destByteWidth = ((lpBitmapInfo->bmiHeader.biWidth * lpBitmapInfo->bmiHeader.biBitCount + 31) & ~31) >> 3;

    ASSERT(((cbBits/lpBitmapInfo->bmiHeader.biHeight)*lpBitmapInfo->bmiHeader.biHeight)==cbBits);
    ASSERT(cbBits == destByteWidth * lpBitmapInfo->bmiHeader.biHeight);

    // Start the destination at the end of the bitmap.
    destRaster    = lpNewBits + (destByteWidth * (lpBitmapInfo->bmiHeader.biHeight - 1));
    srcRaster     = lpBits;

    for (i = 0; i < lpBitmapInfo->bmiHeader.biHeight ; i++)
    {
        memcpy(destRaster, srcRaster, destByteWidth);
        destRaster -= destByteWidth;
        srcRaster  += destByteWidth;
    }

    // Recopy the reversed bitmap into the original buffer
    memcpy(lpBits, lpNewBits, cbBits);
    LocalFree( (HLOCAL) lpNewBits);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\conics.c ===
/*****************************************************************************
 *
 * conics - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


FLOAT   eRadsPerDegree = (FLOAT) (ePI / (FLOAT) 180.0) ;

BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    PPOINT pptStart, PPOINT pptEnd) ;

BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl) ;

VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl) ;


/***************************************************************************
 * DoSetArcDirection - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetArcDirection(PLOCALDC pLocalDC, INT iArcDirection)
{
        pLocalDC->iArcDirection = iArcDirection ;

        return(SetArcDirection(pLocalDC->hdcHelper, iArcDirection) != 0);
}


/***************************************************************************
 *  AngleArc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoAngleArc
(
PLOCALDC pLocalDC,
int     x,
int     y,
DWORD   ulRadius,
FLOAT   eStartAngle,
FLOAT   eSweepAngle
)
{
BOOL    b ;
POINTL  aptl[4] ;
FLOAT   eEndAngle;
INT     iArcDirection;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            if (pfnSetVirtualResolution == NULL)
            {
                POINTL p = {x, y};
                bXformWorkhorse(&p, 1, &pLocalDC->xformRWorldToRDev);
                b = AngleArc(pLocalDC->hdcHelper, p.x, p.y, ulRadius, eStartAngle, eSweepAngle) ;
            }
            else
            {
                b = AngleArc(pLocalDC->hdcHelper, x, y, ulRadius, eStartAngle, eSweepAngle) ;
            }

            ASSERTGDI(b, "MF3216: DoAngleArc, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM
     || eSweepAngle >  360.0f   // more than one revolution
     || eSweepAngle < -360.0f
       )
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// Calculate the ARC bounding box.

        aptl[0].x = x - ulRadius ;
        aptl[0].y = y - ulRadius ;
        aptl[1].x = x + ulRadius ;
        aptl[1].y = y + ulRadius ;

// Calculate the begin and end points for ARC from the
// eStartAngle and eSweepAngle.

        aptl[2].x = x + (LONG) ((double) (ulRadius) * cos(eStartAngle * eRadsPerDegree) + 0.5f) ;
        aptl[2].y = y - (LONG) ((double) (ulRadius) * sin(eStartAngle * eRadsPerDegree) + 0.5f) ;

        eEndAngle = eStartAngle + eSweepAngle ;

        aptl[3].x = x + (LONG) ((double) (ulRadius) * cos(eEndAngle * eRadsPerDegree) + 0.5f) ;
        aptl[3].y = y - (LONG) ((double) (ulRadius) * sin(eEndAngle * eRadsPerDegree) + 0.5f) ;

// If the endpoints are identical, we cannot represent the AngleArc as
// an ArcTo.  Use path to render it instead.

    if (aptl[2].x == aptl[3].x && aptl[2].y == aptl[3].y)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x, y, 0, 0, 0, 0, 0, 0,
            ulRadius, eStartAngle, eSweepAngle, EMR_ANGLEARC);

        return(b);
    }

// At this point we have the same parameters that would apply to
// a standard ArcTo.  However, we still need to determine the arc
// direction to apply.  If the sweep angle is positive, it is counter-
// clockwise.  If the sweep angle is negative, it is clockwise.

// Save the current arc direction.

        iArcDirection = pLocalDC->iArcDirection;

// Prepare the arc direction for the ArcTo.

        (void) DoSetArcDirection
        (pLocalDC, eSweepAngle < 0.0f ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE);

// Do the ArcTo.

        b = DoArcTo(pLocalDC, aptl[0].x, aptl[0].y, aptl[1].x, aptl[1].y,
                              aptl[2].x, aptl[2].y, aptl[3].x, aptl[3].y) ;

// Restore the current arc direction.

        (void) DoSetArcDirection(pLocalDC, iArcDirection);

        return (b) ;
}

/***************************************************************************
 *  Arc  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArc
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_ARC) ;

        return(b) ;
}

/***************************************************************************
 *  ArcTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoArcTo
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;
POINT   ptStart,
        ptEnd ;

    // If we're recording the drawing orders for a path
        // then just pass the drawing order to the helper DC.
        // Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            if (pfnSetVirtualResolution == NULL)
            {
                POINTL p[4] = {x1, y1, x2, y2, x3, y3, x4, y4};
                bXformWorkhorse(p, 4, &pLocalDC->xformRWorldToRDev);
                b = ArcTo(pLocalDC->hdcHelper, p[0].x, p[0].y, p[1].x, p[1].y,
                                               p[2].x, p[2].y, p[3].x, p[3].y) ;
            }
            else
            {
                b = ArcTo(pLocalDC->hdcHelper, x1, y1, x2, y2, x3, y3, x4, y4) ;
            }
            return(b) ;
        }


        b = bFindRadialEllipseIntersection(pLocalDC,
                                           x1, y1, x2, y2,
                                           x3, y3, x4, y4,
                                           &ptStart, &ptEnd) ;
        if (b == FALSE)
            return(b) ;

        b = DoLineTo(pLocalDC, ptStart.x, ptStart.y) ;
        if (b == FALSE)
            return(b) ;

        b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;
        if (b == FALSE)
            return(b) ;

        b = DoMoveTo(pLocalDC, ptEnd.x, ptEnd.y) ;

        return(b) ;
}


/***************************************************************************
 *  Chord  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoChord
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_CHORD) ;

        return(b) ;
}


/***************************************************************************
 *  Ellipse  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoEllipse
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_ELLIPSE) ;

        return(b) ;
}


/***************************************************************************
 *  Pie  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPie
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3,
int x4,
int y4
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4, EMR_PIE) ;

        return(b) ;
}


/***************************************************************************
 * bConicCommon - The mother of all conic translations.
 *                They are Arc, Chord, Pie, Ellipse, Rectangle and RoundRect.
 **************************************************************************/
BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                      INT x3, INT y3, INT x4, INT y4,
                                      DWORD mrType)
{
SHORT       sx1, sx2, sx3, sx4,
            sy1, sy2, sy3, sy4 ;
LONG        nPointls ;
POINTL      aptl[4] ;
BOOL        b ;

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

        if (pLocalDC->flags & RECORDING_PATH)
        {
            POINTL ppts[4] = {x1, y1, x2, y2, x3, y3, x4, y4};
            if (pfnSetVirtualResolution == NULL)
            {
                if (!bXformWorkhorse(ppts, 4, &pLocalDC->xformRWorldToRDev))
                {
                    return(FALSE) ;
                }
            }
            switch(mrType)
            {
                case EMR_ARC:
                    b = Arc(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                 ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
                    break ;

                case EMR_CHORD:
                    b = Chord(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                   ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);

                    break ;

                case EMR_ELLIPSE:
                    b = Ellipse(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y);
                    break ;

                case EMR_PIE:
                    b = Pie(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                 ppts[2].x, ppts[2].y, ppts[3].x, ppts[3].y);
                    break ;

                case EMR_RECTANGLE:
                    b = Rectangle(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y);
                    break ;

                case EMR_ROUNDRECT:
                    b = RoundRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                                       ppts[2].x, ppts[2].y);
                    break ;

                default:
                    b = FALSE;
                    RIPS("MF3216: bConicCommon, bad mrType");
                    break ;
            }

            ASSERTGDI(b, "MF3216: bConicCommon, in path render failed\n") ;
            return(b) ;
        }

// Do the transformations.
// And emit the Win16 drawing orders.

    if (pLocalDC->flags & STRANGE_XFORM)
        {
            b = bRenderCurveWithPath(pLocalDC, (LPPOINT) NULL, (PBYTE) NULL, 0,
            x1, y1, x2, y2, x3, y3, x4, y4, 0, 0.0f, 0.0f, mrType);

        return(b);
    }

// Do the simple transform case.

        // Compute the number of points

        nPointls = (LONG) (sizeof(aptl) / sizeof(POINTL)) ;

        // Assign all the coordinates into an array for conversion.

        aptl[0].x = x1 ;
        aptl[0].y = y1 ;
        aptl[1].x = x2 ;
        aptl[1].y = y2 ;
        aptl[2].x = x3 ;
        aptl[2].y = y3 ;
        aptl[3].x = x4 ;
        aptl[3].y = y4 ;

        // Take care of the arc direction.

        switch (mrType)
        {
            case EMR_ARC:
            case EMR_CHORD:
            case EMR_PIE:
                vDoArcReflection(pLocalDC, &aptl[2]) ;
                break ;

            default:
                break ;
        }

        // Do the Record-time World to Play-time Page transformations.
        // The radial definitions need only a world to page xform,
        // and the ellipse definitions for roundrects only require
        // a magnitude transformation.

        if (mrType != EMR_ROUNDRECT)
        {
        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, nPointls) ;
            if (!b)
                goto exit1 ;
        }
        else
        {
            /*
                For roundrects do a Record-time-World to Play-time-Page
                transform of the bounding box only.  Then a magnatude only
                transform of the corner ellipse definitions.
            */

        b = bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2) ;
            if (!b)
                goto exit1 ;

            aptl[2].x = iMagnitudeXform(pLocalDC, aptl[2].x, CX_MAG) ;
            aptl[2].y = iMagnitudeXform(pLocalDC, aptl[2].y, CY_MAG) ;
            aptl[3].x = iMagnitudeXform(pLocalDC, aptl[3].x, CX_MAG) ;
            aptl[3].y = iMagnitudeXform(pLocalDC, aptl[3].y, CY_MAG) ;
        }

        // The bounding boxes for
        // all the conics and rectangles that are handled by this
        // common routine are inclusive-inclusive, and they must
        // be transformed to the inclusive-exclusive Win16 form.

        b = bIncIncToIncExcXform(pLocalDC, (PRECTL) &aptl[0]) ;
    if (!b)
            goto exit1 ;

        // Assign the converted coordinates variables suited to
        // the Win16 metafile.

    sx1 = LOWORD(aptl[0].x) ;
    sy1 = LOWORD(aptl[0].y) ;
    sx2 = LOWORD(aptl[1].x) ;
    sy2 = LOWORD(aptl[1].y) ;
    sx3 = LOWORD(aptl[2].x) ;
    sy3 = LOWORD(aptl[2].y) ;
    sx4 = LOWORD(aptl[3].x) ;
    sy4 = LOWORD(aptl[3].y) ;

        // Emit the Win16 drawing orders to the Win16 metafile.

        switch(mrType)
        {
            case EMR_ARC:
                b = bEmitWin16Arc(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_CHORD:
                b = bEmitWin16Chord(pLocalDC, sx1, sy1, sx2, sy2,
                                              sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_ELLIPSE:
                b = bEmitWin16Ellipse(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_PIE:
                b = bEmitWin16Pie(pLocalDC, sx1, sy1, sx2, sy2,
                                            sx3, sy3, sx4, sy4) ;
                break ;

            case EMR_RECTANGLE:
                b = bEmitWin16Rectangle(pLocalDC, sx1, sy1, sx2, sy2) ;
                break ;

            case EMR_ROUNDRECT:
                b = bEmitWin16RoundRect(pLocalDC, sx1, sy1, sx2, sy2, sx3, sy3) ;
                break ;

        default:
        RIPS("MF3216: bConicCommon, bad mrType");
                break ;
        }

exit1:
        return (b) ;
}


/*****************************************************************************
 * vDoArcReflection - Test for an inversion in the RWorld to PPage matrix.
 *                    If one and only one is found then swap the start
 *                    and  end position for the conics.
 *****************************************************************************/
VOID vDoArcReflection(PLOCALDC pLocalDC, PPOINTL pptl)
{
FLOAT   eM11,
        eM22 ;
POINTL  ptl ;
BOOL    bFlip ;

    // Win16 assumes the counter-clockwise arc direction in the
    // device coordinates.  Win32 defines the arc direction in the
    // world coordinates.

    // Assume no flipping of start and end points.

    bFlip = FALSE ;

    // Account for current arc direction.

    if (pLocalDC->iArcDirection == AD_CLOCKWISE)
        bFlip = !bFlip;

        // If there is an inversion in the xform matrix then invert
        // the arc direction.

        eM11 = pLocalDC->xformRWorldToPPage.eM11 ;
        eM22 = pLocalDC->xformRWorldToPPage.eM22 ;

        if (  (eM11 < 0.0f && eM22 > 0.0f)
            ||(eM11 > 0.0f && eM22 < 0.0f)
           )
        bFlip = !bFlip;

        // If the REQUESTED Win16 mapmode is fixed, then invert the
    // arc direction.

        switch(pLocalDC->iMapMode)
        {
            case MM_LOMETRIC:
            case MM_HIMETRIC:
            case MM_LOENGLISH:
            case MM_HIENGLISH:
            case MM_TWIPS:
                bFlip = !bFlip;
                break ;
        }

    if (bFlip)
        SWAP(pptl[0], pptl[1], ptl);

        return ;
}


/*****************************************************************************
 * bIncIncToIncExcXform - Inclusize Inclusive To Inclusive Exclusize
 *                        transform in play time coordinate space.
 *****************************************************************************/
BOOL bIncIncToIncExcXform (PLOCALDC pLocalDC, PRECTL prcl)
{
LONG     l;

        // Convert the points from Playtime Page to Playtime Device space.

        if (!bXformPPageToPDev(pLocalDC, (PPOINTL) prcl, 2))
        return(FALSE);

    // Reorder the rectangle

    if (prcl->left > prcl->right)
        SWAP(prcl->left, prcl->right, l);

    if (prcl->top > prcl->bottom)
        SWAP(prcl->top, prcl->bottom, l);

        // Expand the right and bottom by one pixel.

        prcl->right++ ;
        prcl->bottom++ ;

        // Convert the points back to Playtime Page space

        return(bXformPDevToPPage(pLocalDC, (PPOINTL) prcl, 2));
}


/*****************************************************************************
 * bFindRadialEllipseIntersection - Calculate the intersection of a radial
 *                                   and an Ellipse.
 *
 *  Play the ArcTo into a path then query the path for the first and
 *  last points on the Arc.
 *****************************************************************************/
BOOL bFindRadialEllipseIntersection(PLOCALDC pLocalDC,
                                    INT x1, INT y1, INT x2, INT y2,
                                    INT x3, INT y3, INT x4, INT y4,
                                    LPPOINT pptStart, LPPOINT pptEnd)
{
BOOL    b;
POINT   ptCP;
POINTL  ppts[4] = {x1, y1, x2, y2, x3, y3, x4, y4};

    b = FALSE;          // assume failure

// Save the current position in the helper DC.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse(ppts, 4, &pLocalDC->xformRWorldToRDev))
        {
            goto exit_bFindRadialEllipseIntersection;
        }
    }

// Do an ArcTo with the same start radial line.

     if (!ArcTo(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                     ppts[2].x, ppts[2].y, ppts[2].x, ppts[2].y))
        goto exit_bFindRadialEllipseIntersection;

// Get the start point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptStart))
        goto exit_bFindRadialEllipseIntersection;

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x we need to convert from Device Units in the Helper DC
        // to WorldUnits
        if (!bXformWorkhorse((PPOINTL) pptStart, 1, &pLocalDC->xformRDevToRWorld))
            goto exit_bFindRadialEllipseIntersection;
    }


// Continue with the ArcTo with the same end radial line this time.

    if (!ArcTo(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y,
                                    ppts[3].x, ppts[3].y, ppts[3].x, ppts[3].y))
        goto exit_bFindRadialEllipseIntersection;

// Get the end point of the arc.  It is the current position.

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, pptEnd))
        goto exit_bFindRadialEllipseIntersection;

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x we need to convert from Device Units in the Helper DC
        // to WorldUnits
        if (!bXformWorkhorse((PPOINTL) pptEnd, 1, &pLocalDC->xformRDevToRWorld))
            goto exit_bFindRadialEllipseIntersection;
    }
// Everything is golden.

    b = TRUE;

exit_bFindRadialEllipseIntersection:

// Restore the current position in the helper DC.

    if (!MoveToEx(pLocalDC->hdcHelper, ptCP.x, ptCP.y, (LPPOINT) NULL))
        RIPS("MF3216: bFindRadialEllipseIntersection, MoveToEx failed");

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\colors.c ===
/*****************************************************************************
 *
 * colors - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * History:
 *  Sep 1992	-by-	Hock San Lee	[hockl]
 * Complete rewrite.
 *
 *  The following implementation takes into account that all 16-bit metafile
 *  palette records reference the current palette.
 *
 *  CreatePalette
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 *  SelectPalette
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 *  RealizePalette
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 *  ResizePalette
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  SetPaletteEntries
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 *  DeleteObject
 *      Don't emit the 16-bit record for palettes since all palettes are
 *      deleted in SelectPalette above.  Similarly, don't emit palette delete
 *      records at the end of conversion.  However, you need to delete the
 *      private copy of the palette maintained by the converter here and at
 *      the end of conversion.
 *
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  SelectPalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Emit a CreatePalette record followed by a SelectPalette record.
 *      Then emit a 16-bit DeleteObject record to delete the previous palette.
 *      The selected logical palette can be queried from the private copy
 *      maintained by the converter.  You need to keep track of the current
 *      palette so that you can emit ResizePalette or SetPaletteEntries record
 *      if the palette identifies the current palette.  You also need to deal
 *      with the stock palette correctly here (you don't need to keep a
 *      private copy of the stock palette).  Don't delete the private copy
 *      of the logical palette here! (see DeleteObject below)
 *
 **************************************************************************/
BOOL WINAPI DoSelectPalette
(
PLOCALDC pLocalDC,
DWORD	 ihpal
)
{
BOOL	     b = FALSE;
WORD         cEntries;
LPLOGPALETTE lpLogPal = (LPLOGPALETTE) NULL;
HPALETTE     hpalW32;
INT	     ihW16, ihW32Norm;

	// No need to do anything if selecting the same palette.

	if (pLocalDC->ihpal32 == ihpal)
	    return(TRUE);

	// Validate the palette index.

	if ((ihpal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	 && (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal]))
	{
            RIPS("MF3216: DoSelectPalette - ihpal invalid");
            goto error_exit;
	}

	// Get the W32 handle.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    hpalW32 = GetStockObject(DEFAULT_PALETTE) ;
	else
	    hpalW32 = pLocalDC->pW32hPal[ihpal];

        if(hpalW32 == 0)
        {
            RIPS("MF3216: DoSelectPalette - hpalW32 == 0\n");
            goto error_exit;
        }
	// Emit a CreatePalette record.

	if (!GetObjectA(hpalW32, sizeof(WORD), &cEntries))
	{
	    RIPS("MF3216: DoSelectPalette - GetObjectA failed\n");
            goto error_exit;
	}

	if (!(lpLogPal = (LPLOGPALETTE) LocalAlloc(
				LMEM_FIXED,
				sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
				 + sizeof(PALETTEENTRY) * cEntries)))
            goto error_exit;

	lpLogPal->palVersion    = 0x300;
        lpLogPal->palNumEntries = cEntries;

	GetPaletteEntries(hpalW32, 0, cEntries, lpLogPal->palPalEntry);

	// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihpal, REALIZED_PALETTE);
        if (ihW16 == -1)
            goto error_exit;

	if (!bEmitWin16CreatePalette(pLocalDC, lpLogPal))
            goto error_exit;

	// Emit a SelectPalette record.

	if (!SelectPalette(pLocalDC->hdcHelper, hpalW32, TRUE))
	    goto error_exit;

	if (!bEmitWin16SelectPalette(pLocalDC, (WORD) ihW16))
	    goto error_exit;

	// Emit a DeleteObject record to delete the previous palette.

	if (pLocalDC->ihpal16 != -1)
	{
	    ihW32Norm = iNormalizeHandle(pLocalDC, pLocalDC->ihpal32);
	    if (ihW32Norm == -1)
		goto error_exit;

	    pLocalDC->pW16ObjHndlSlotStatus[pLocalDC->ihpal16].use
		= OPEN_AVAILABLE_SLOT;
	    pLocalDC->piW32ToW16ObjectMap[ihW32Norm]
		= UNMAPPED;

	    bEmitWin16DeleteObject(pLocalDC, (WORD) pLocalDC->ihpal16);
	}

	pLocalDC->ihpal32 = ihpal;
	pLocalDC->ihpal16 = ihW16;

	b = TRUE;

error_exit:

        if (lpLogPal)
	    LocalFree((HANDLE) lpLogPal);

	return(b);
}

/***************************************************************************
 *  ResizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoResizePalette
(
PLOCALDC  pLocalDC,
DWORD     ihpal,
DWORD     cEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIPS("MF3216: DoResizePalette - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!ResizePalette(pLocalDC->pW32hPal[ihpal], cEntries))
	{
            RIPS("MF3216: DoResizePalette - ResizePalette failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16ResizePalette(pLocalDC, (WORD) cEntries));

        return(TRUE);
}

/***************************************************************************
 *  SetPaletteEntries  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Update the private copy of the logical palette in the converter.
 *      Emit a 16-bit record only if the palette identifies the current palette.
 *
 **************************************************************************/
BOOL WINAPI DoSetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD 	       ihpal,
DWORD 	       iStart,
DWORD 	       cEntries,
LPPALETTEENTRY pPalEntries
)
{
	// Do not modify the default palette.

	if (ihpal == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
	    return(TRUE);

	// Validate the palette index.

	if (ihpal >= pLocalDC->cW32hPal || !pLocalDC->pW32hPal[ihpal])
	{
            RIPS("MF3216: DoSetPaletteEntries - ihpal invalid");
	    return(FALSE);
	}

	// Do it to the private palette.

	if (!SetPaletteEntries(pLocalDC->pW32hPal[ihpal], iStart, cEntries, pPalEntries))
	{
            RIPS("MF3216: DoSetPaletteEntries - SetPaletteEntries failed");
	    return(FALSE);
	}

	// Emit a 16-bit record only if the palette identifies the
	// current palette.

	if (pLocalDC->ihpal32 == ihpal)
            return(bEmitWin16SetPaletteEntries(pLocalDC, iStart, cEntries, pPalEntries));

        return(TRUE);
}

/***************************************************************************
 *  RealizePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Just emit a 16-bit record.  This record always references the current
 *      palette in both 16 and 32-bit metafiles.
 *
 **************************************************************************/
BOOL WINAPI DoRealizePalette
(
PLOCALDC pLocalDC
)
{
        // Emit the Win16 metafile drawing order.

        return(bEmitWin16RealizePalette(pLocalDC));
}

/***************************************************************************
 *  CreatePalette  - Win32 to Win16 Metafile Converter Entry Point
 *
 *      Create a private copy of the logical palette in the converter but
 *      don't emit the 16-bit record.
 *
 **************************************************************************/
BOOL WINAPI DoCreatePalette
(
PLOCALDC     pLocalDC,
DWORD        ihPal,
LPLOGPALETTE lpLogPal
)
{
	if (ihPal != (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
        {
            LOGPALETTE *lpLogPalNew;

        // Validate the palette index.

	    if (ihPal >= pLocalDC->cW32hPal || pLocalDC->pW32hPal[ihPal])
                return(FALSE);

        // Allocate size of log palette + 2 entries for black and white.

            lpLogPalNew = LocalAlloc(LMEM_FIXED, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) + sizeof(DWORD)));

            if (lpLogPalNew == NULL)
            {
                return(FALSE);
            }

            RtlMoveMemory(lpLogPalNew, lpLogPal, lpLogPal->palNumEntries * sizeof(DWORD) + (sizeof(LOGPALETTE) - sizeof(DWORD)));
            lpLogPalNew->palNumEntries += 2;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peRed   = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peGreen = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peBlue  = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 1].peFlags = 0;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peRed   = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peGreen = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peBlue  = 0xff;
            lpLogPalNew->palPalEntry[lpLogPal->palNumEntries - 2].peFlags = 0;

        // Create a private copy of the logical palette and keep it
        // in the converter palette table.

            pLocalDC->pW32hPal[ihPal] = CreatePalette(lpLogPalNew);
            LocalFree(lpLogPalNew);

            if (!(pLocalDC->pW32hPal[ihPal]))
            {
                RIPS("MF3216: DoCreatePalette - CreatePalette failed\n") ;
                return(FALSE);
            }
        }

        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\emit.c ===
/*****************************************************************************
 *
 * emit - Emit routines for MF3216
 *
 * Date: 7/17/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 *  01-Feb-1992     -by-        c-jeffn
 *
 *      Major code cleanup from Code review 1.
 *
 * Copyright (c) 1991,92 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*----------------------------------------------------------------------------
 *  Emit (copy) nCount Bytes in pBuffer to the user supplied output buffer.
 *
 *  If this is a size only request, send the bits to the bit-bucket and
 *  just keep track of the size.
 *
 *  Note: ERROR_BUFFER_OVERFLOW flag is set in pLocalDC if output buffer
 *  is overrun.
 *---------------------------------------------------------------------------*/
BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount)
{
BOOL    b ;
UINT    ulBytesEmitted ;

        b = TRUE ;

        // Test for a size only request.

        if (!(pLocalDC->flags & SIZE_ONLY))
        {
            ulBytesEmitted = pLocalDC->ulBytesEmitted ;
            if ((ulBytesEmitted + nCount) <= pLocalDC->cMf16Dest)
            {
                memcpy(&(pLocalDC->pMf16Bits[ulBytesEmitted]), pBuffer, nCount) ;
                b = TRUE ;
            }
            else
            {
                // Signal output buffer overflow error.
                // It can happen that we overflow the buffer if we fail the XOR
                // pass but don't fail the second pass. If the failure in the
                // XOR pass happens after we have reached the end of the buffer
                // the we will have a buffer overflow because it wasn't the
                // initial XOR pass that returned the size but the second pass
                // (The same thing could happen between the second pass and the
                // GDI pass) so we make it only a warning now.
                pLocalDC->flags |= ERR_BUFFER_OVERFLOW;
                b = FALSE ;

                WARNING(("MF3216: bEmit, (pLocalDC->ulBytesEmitted + nCount) > cMf16Dest \n"));
            }


        }

        // Update the local DC byte count

        pLocalDC->ulBytesEmitted += nCount ;

        return(b) ;

}



/*----------------------------------------------------------------------------
 * Update the max record size.  Used to update the metafile header.
 *---------------------------------------------------------------------------*/
VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr)
{

    if (pLocalDC->ulMaxRecord < pmr->rdSize)
        pLocalDC->ulMaxRecord = pmr->rdSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\fonts.c ===
/*****************************************************************************
 *
 * fonts - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


 /***************************************************************************
 *  ExtCreateFont  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoExtCreateFont
(
 PLOCALDC  pLocalDC,
 INT       ihFont,
 PLOGFONTA plfa
 )
{
    BOOL    b ;
    INT     ihW16 ;
    WIN16LOGFONT Win16LogFont;
    
    b = FALSE;
    
    // Create a win16 logfont(a)
    
    Win16LogFont.lfHeight = (SHORT) iMagnitudeXform(pLocalDC, plfa->lfHeight, CY_MAG);
    if (plfa->lfHeight < 0)		// preserve sign
        Win16LogFont.lfHeight = -Win16LogFont.lfHeight;
    Win16LogFont.lfWidth  = (SHORT) iMagnitudeXform(pLocalDC, plfa->lfWidth, CX_MAG);
    if (plfa->lfWidth < 0)		// preserve sign
        Win16LogFont.lfWidth = -Win16LogFont.lfWidth;
    Win16LogFont.lfEscapement     = (SHORT) plfa->lfEscapement;
    Win16LogFont.lfOrientation    = (SHORT) plfa->lfOrientation;
    Win16LogFont.lfWeight         = (SHORT) plfa->lfWeight;
    Win16LogFont.lfItalic         = plfa->lfItalic;
    Win16LogFont.lfUnderline      = plfa->lfUnderline;
    Win16LogFont.lfStrikeOut      = plfa->lfStrikeOut;
    Win16LogFont.lfCharSet        = plfa->lfCharSet;
    Win16LogFont.lfOutPrecision   = plfa->lfOutPrecision;
    Win16LogFont.lfClipPrecision  = plfa->lfClipPrecision;
    Win16LogFont.lfQuality        = plfa->lfQuality;
    Win16LogFont.lfPitchAndFamily = plfa->lfPitchAndFamily;
    
    //vUnicodeToAnsi(pLocalDC->hdcHelper,(PCHAR) Win16LogFont.lfFaceName,
    //    (PWCH)  plfa->lfFaceName,
    //    LF_FACESIZE);
   CopyMemory(&Win16LogFont.lfFaceName, &plfa->lfFaceName, LF_FACESIZE);

    
    // Allocate the W16 handle.
    
    ihW16 = iAllocateW16Handle(pLocalDC, ihFont, REALIZED_FONT) ;
    if (ihW16 == -1)
        goto error_exit ;
    
    // Create the w32 font and store it in the w16 slot table.
    // This font is needed by the helper DC for TextOut simulations.
    
    pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateFontIndirectA(plfa);
    
    ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateFontIndirectW failed");
    
    // Emit the Win16 CreateFont metafile record.
    
    b = bEmitWin16CreateFontIndirect(pLocalDC, &Win16LogFont);
    
error_exit:
    return(b);
}

/***************************************************************************
 *  SetMapperFlags  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetMapperFlags
(
 PLOCALDC pLocalDC,
 DWORD   f
)
{
BOOL    b ;

	// Do it to the helper DC.

	SetMapperFlags(pLocalDC->hdcHelper, (DWORD) f);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetMapperFlags(pLocalDC, f) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\gdippathflatten.cpp ===
extern "C"
{
#include "precomp.h"
}
#include "wtypes.h"
#include "objbase.h"
#include "gdiplus.h"


extern "C" BOOL bInvertxform(PXFORM pxformSrc, PXFORM pxformDest);
extern "C" BOOL bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform);

using namespace Gdiplus;

inline REAL
GetDistance(
    GpPointF &      p1,
    GpPointF &      p2
    )
{
    double      dx = (double)p2.X - p1.X;
    double      dy = (double)p2.Y - p1.Y;

    return (REAL)sqrt((dx * dx) + (dy * dy));
}

// Flatten a path using GDI+ and transform the points before hand so we flatten
// the points that will go in the metafile. We allocate one buffer that will
// contain the points and types. The caller has to free that buffer
extern "C" BOOL GdipFlattenGdiPath(PLOCALDC pLocalDC,
                                   LPVOID   *buffer,
                                   INT      *count)
{
    BOOL    b = FALSE;
    INT     i ;
    INT     cpt;
    PBYTE   pb = NULL;
    PointF* pptf;
    LPPOINT ppt;
    PBYTE   pjType;
    INT     flattenCount;
    PBYTE   flattenpb = NULL;
    PointF* flattenPoints;
    PBYTE   flattenTypes;
    PBYTE   returnpb = NULL;

    ASSERT(buffer != NULL && *buffer == NULL && count != NULL);

    // Get the path data.

    // First get a count of the number of points.

    cpt = GetPath(pLocalDC->hdcHelper, (LPPOINT) NULL, (LPBYTE) NULL, 0);
    if (cpt == -1)
    {
        RIPS("MF3216: DoFlattenPath, GetPath failed\n");
        goto exit_DoFlattenPath;
    }

    // Check for empty path.

    if (cpt == 0)
    {
        b = TRUE;
        goto exit_DoFlattenPath;
    }

    // Allocate memory for the path data.

    if (!(pb = (PBYTE) LocalAlloc
        (
        LMEM_FIXED,
        cpt * (sizeof(PointF) + sizeof(POINT) + sizeof(BYTE))
        )
        )
        )
    {
        RIPS("MF3216: DoFlattenPath, LocalAlloc failed\n");
        goto exit_DoFlattenPath;
    }

    // Order of assignment is important for dword alignment.

    pptf    = (PointF*) pb;
    ppt     = (LPPOINT) (pptf + cpt);
    pjType  = (LPBYTE)  (ppt + cpt);

    // Finally, get the path data.

    if (GetPath(pLocalDC->hdcHelper, ppt, pjType, cpt) != cpt)
    {
        RIPS("MF3216: DoFlattenPath, GetPath failed\n");
        goto exit_DoFlattenPath;
    }

    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse((PPOINTL) ppt, cpt, &pLocalDC->xformRDevToRWorld))
            goto exit_DoFlattenPath;
    }

    BYTE tempType;
    for (i = 0; i < cpt; i++)
    {
        pptf[i] = PointF((REAL) ppt[i].x, (REAL) ppt[i].y);
        switch (pjType[i] & ~PT_CLOSEFIGURE)
        {
        case PT_LINETO:
            tempType = PathPointTypeLine;
            break;

        case PT_MOVETO:
            tempType = PathPointTypeStart;
            break;

        case PT_BEZIERTO:
            tempType = PathPointTypeBezier;
            break;

        default:
            WARNING(("MF3216: There's something wrong with this path"));
            break;
        }
        if (pjType[i] & PT_CLOSEFIGURE)
        {
            tempType |= PathPointTypeCloseSubpath;
        }
        pjType[i] = tempType;
    }
    {

        XFORM* xform = &(pLocalDC->xformRWorldToPPage);
        Matrix matrix((REAL)xform->eM11, (REAL)xform->eM12, (REAL)xform->eM21,
                      (REAL)xform->eM22, (REAL)xform->eDx, (REAL)xform->eDy);
        GraphicsPath gdipPath (pptf,
                               pjType,
                               cpt);
        // This will transform the flattened point into the resolution of the
        // metafile, giving us the best resolution for playtime
        gdipPath.Flatten(&matrix, 1.0f/6.0f);
        flattenCount = gdipPath.GetPointCount();

        if (flattenCount < 0)
        {
            RIPS("MF3216: GDIP failed in flatting the path\n");
            goto exit_DoFlattenPath;
        }

        if (!(flattenpb = (PBYTE) LocalAlloc
            (
            LMEM_FIXED,
            flattenCount * (sizeof(PointF) + sizeof(BYTE))
            )
            )
            )
        {
            RIPS("MF3216: DoFlattenPath, LocalAlloc failed\n");
            goto exit_DoFlattenPath;
        }
        flattenPoints = (PointF*) flattenpb;
        flattenTypes  = (PBYTE) (flattenPoints + flattenCount);

        if (!(returnpb = (PBYTE) LocalAlloc
            (
            LMEM_FIXED,
            flattenCount * (sizeof(POINT) + sizeof(BYTE))
            )
            )
            )
        {
            RIPS("MF3216: DoFlattenPath, LocalAlloc failed\n");
            goto exit_DoFlattenPath;
        }
        ppt     = (LPPOINT) returnpb;
        pjType  = (PBYTE) (ppt + flattenCount);

        if (gdipPath.GetPathTypes(flattenTypes, flattenCount) != Ok)
        {
            RIPS("MF3216: DoFlattenPath, GetPathTypes failed\n");
            goto exit_DoFlattenPath;
        }

        if (gdipPath.GetPathPoints(flattenPoints, flattenCount) != Ok)
        {
            RIPS("MF3216: DoFlattenPath, GetPathPoints failed\n");
            goto exit_DoFlattenPath;
        }

        for (i = 0; i < flattenCount; i++)
        {
            ppt[i].x = (INT)(flattenPoints[i].X + 0.5f);
            ppt[i].y = (INT)(flattenPoints[i].Y + 0.5f);
            switch (flattenTypes[i] & ~PathPointTypeCloseSubpath)
            {
            case PathPointTypeLine:
                tempType = PT_LINETO;
                break;

            case PathPointTypeStart:
                tempType = PT_MOVETO;
                break;

                break;

            default:
                WARNING(("MF3216: There's something wrong with this path"));
                break;
            }
            if (flattenTypes[i] & PathPointTypeCloseSubpath)
            {
                tempType |= PT_CLOSEFIGURE;
            }
            pjType[i] = tempType;
        }
    }
    *buffer = returnpb;
    *count  = flattenCount;
    returnpb = NULL;
    b = TRUE;

exit_DoFlattenPath:

    // Cleanup any allocations
    if (pb != NULL)
    {
        LocalFree((HANDLE)pb);
    }
    if (flattenpb != NULL)
    {
        LocalFree((HANDLE)flattenpb);
    }
    // This should only happen if we failed
    if (returnpb != NULL)
    {
        LocalFree((HANDLE)returnpb);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\metafile.hpp ===
#ifndef __GPMETAFILE_HPP__
#define __GPMETAFILE_HPP__

extern "C" UINT GdipConvertEmfToWmf(PBYTE pMetafileBits, UINT cDest, PBYTE pDest,
                 INT iMapMode, HDC hdcRef, UINT flags);

DWORD
WINAPI
GetObjectTypeInternal(
    IN HGDIOBJ handle
    );

DWORD
WINAPI
GetDCType(
    IN HDC hdc
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\handlers.h ===
/****************************************************************************
 *  Handlers.h - Definitions for handlers.
 *
 *  DATE:   11-Dec-1991
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Copyright (c) Microsoft Inc. 1991
 ****************************************************************************/

//  Following is a typedef for the Drawing Order Handler

typedef BOOL DOFN (PVOID, PLOCALDC) ;
typedef DOFN *PDOFN ;

DOFN bHandleHeader;
DOFN bHandleSetArcDirection;
DOFN bHandleArc;
DOFN bHandleArcTo;
DOFN bHandleAngleArc;
DOFN bHandleEllipse;
DOFN bHandleSelectObject;
DOFN bHandleDeleteObject;
DOFN bHandleCreateBrushIndirect;
DOFN bHandleCreateDIBPatternBrush;
DOFN bHandleCreateMonoBrush;
DOFN bHandleCreatePen;
DOFN bHandleExtCreatePen;
DOFN bHandleMoveTo;
DOFN bHandleLineTo;
DOFN bHandleChord;
DOFN bHandlePie;
DOFN bHandlePolyline;
DOFN bHandlePolylineTo ;
DOFN bHandlePolyPolyline;
DOFN bHandlePolygon ;
DOFN bHandlePolyPolygon;
DOFN bHandleRectangle;
DOFN bHandleRoundRect ;
DOFN bHandlePoly16 ;
DOFN bHandlePolyPoly16 ;

DOFN bHandleExtTextOut;
DOFN bHandlePolyTextOut;
DOFN bHandleExtCreateFont;
DOFN bHandleSetBkColor;
DOFN bHandleSetBkMode;
DOFN bHandleSetMapperFlags;
DOFN bHandleSetPolyFillMode;
DOFN bHandleSetRop2;
DOFN bHandleSetStretchBltMode;
DOFN bHandleSetTextAlign;
DOFN bHandleSetTextColor;

DOFN bHandleSelectPalette;
DOFN bHandleCreatePalette;
DOFN bHandleSetPaletteEntries;
DOFN bHandleResizePalette;
DOFN bHandleRealizePalette;

DOFN bHandleSetMapMode;

DOFN bHandleSetWindowOrg;
DOFN bHandleSetWindowExt;

DOFN bHandleSetViewportOrg;
DOFN bHandleSetViewportExt;

DOFN bHandleScaleViewportExt;
DOFN bHandleScaleWindowExt;

DOFN bHandleEOF;

DOFN bHandleSaveDC;
DOFN bHandleRestoreDC;

DOFN bHandleBitBlt;
DOFN bHandleStretchBlt;
DOFN bHandleMaskBlt;
DOFN bHandlePlgBlt;
DOFN bHandleSetDIBitsToDevice;
DOFN bHandleStretchDIBits;


DOFN bHandleBeginPath;
DOFN bHandleEndPath;
DOFN bHandleFlattenPath;
DOFN bHandleStrokePath;
DOFN bHandleFillPath;
DOFN bHandleStrokeAndFillPath;
DOFN bHandleWidenPath;
DOFN bHandleSelectClipPath;
DOFN bHandleCloseFigure;
DOFN bHandleAbortPath;

DOFN bHandlePolyBezier;
DOFN bHandlePolyBezierTo;
DOFN bHandlePolyDraw;

DOFN bHandleSetWorldTransform;
DOFN bHandleModifyWorldTransform;

DOFN bHandleSetPixel;

DOFN bHandleFillRgn;
DOFN bHandleFrameRgn;
DOFN bHandleInvertRgn;
DOFN bHandlePaintRgn;
DOFN bHandleExtSelectClipRgn;
DOFN bHandleOffsetClipRgn;

DOFN bHandleExcludeClipRect;
DOFN bHandleIntersectClipRect;
DOFN bHandleSetMetaRgn;

DOFN bHandleGdiComment;

DOFN bHandleExtFloodFill;
DOFN bHandleNotImplemented;

extern fnSetVirtualResolution pfnSetVirtualResolution;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\mf3216debug.h ===
#ifndef _MF3216DEBUG_H
#define _MF3216DEBUG_H

#define ASSERTGDI(cond, msg)    ASSERTMSG((cond), (msg))
#define RIPS(msg)               RIP((msg))
#define PUTS(msg)               WARNING((msg))
#define PUTS1(msg, arg)         WARNING((msg, arg))

#endif // !_MF3216DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\metafile.cpp ===
/******************************Module*Header*******************************\
* Module Name: metafile.cxx
*
* Includes enhanced metafile API functions.
*
* Created: 17-July-1991 10:10:36
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#define NO_STRICT

#define _GDI32_

#define WMF_KEY 0x9ac6cdd7l

extern "C" {
#if defined(_GDIPLUS_)
#include <gpprefix.h>
#endif

#include <string.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>  // defines but doesn't use ASSERT and ASSERTMSG

#undef ASSERT
#undef ASSERTMSG

#include <nturtl.h>

#include <stddef.h>
#include <windows.h>    // GDI function declarations.
#include <winspool.h>

#include "..\runtime\debug.h"
#include "mf3216Debug.h"

#define ERROR_ASSERT(cond, msg)    ASSERTMSG((cond), (msg))

//#include "nlsconv.h"    // UNICODE helpers
//#include "firewall.h"

#define __CPLUSPLUS
#include <winspool.h>
#include <w32gdip.h>
#include "ntgdistr.h"
#include "winddi.h"
#include "hmgshare.h"
#include "icm.h"
#include "local.h"      // Local object support.
#include "gdiicm.h"
#include "metadef.h"    // Metafile record type constants.
#include "metarec.h"
#include "mf16.h"
#include "ntgdi.h"
#include "glsup.h"
#include "mf3216.h"
#include <GdiplusEnums.h>
}

#undef WARNING
#define WARNING(msg)        WARNING1(msg)
#include "rectl.hxx"
#include "mfdc.hxx"     // Metafile DC declarations.

#define USE(x)  (x)
#include "mfrec.hxx"    // Metafile record class declarations.
#undef USE

#undef WARNING
#define WARNING SAVE_WARNING

#include "Metafile.hpp"

DWORD  GetDWordCheckSum(UINT cbData, PDWORD pdwData);

#define DbgPrint printf

static inline void PvmsoFromW(void *pv, WORD w)
    { ((BYTE*)pv)[0] = BYTE(w); ((BYTE*)pv)[1] = BYTE(w >> 8); }

static inline void PvmsoFromU(void *pv, ULONG u)
    {  ((BYTE*)pv)[0] = BYTE(u);
        ((BYTE*)pv)[1] = BYTE(u >> 8);
        ((BYTE*)pv)[2] = BYTE(u >> 16);
        ((BYTE*)pv)[3] = BYTE(u >> 24);  }

#ifdef DBG
static BOOL g_outputEMF = FALSE;
#endif



/******************************Public*Routine******************************\
* GetWordCheckSum(UINT cbData, PWORD pwData)
*
* Adds cbData/2 number of words pointed to by pwData to provide an
* additive checksum.  If the checksum is valid the sum of all the WORDs
* should be zero.
*
\**************************************************************************/

static DWORD GetDWordCheckSum(UINT cbData, PDWORD pdwData)
{
    DWORD   dwCheckSum = 0;
    UINT    cdwData = cbData / sizeof(DWORD);

    ASSERTGDI(!(cbData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD multiple");
    ASSERTGDI(!((ULONG_PTR)pdwData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD aligned");

    while (cdwData--)
        dwCheckSum += *pdwData++;

    return(dwCheckSum);
}


/******************************Public*Routine******************************\
* UINT APIENTRY GetWinMetaFileBits(
*          HENHMETAFILE hemf,
*          UINT nSize,
*          LPBYTE lpData
*          INT iMapMode,
*          HDC hdcRef)
*
* The GetWinMetaFileBits function returns the metafile records of the
* specified enhanced metafile  in the Windows 3.0 format and copies
* them into the buffer specified.
*
* Parameter  Description
* hemf       Identifies the metafile.
* nSize      Specifies the size of the buffer reserved for the data. Only this
*            many bytes will be written.
* lpData     Points to the buffer to receive the metafile data. If this
*            pointer is NULL, the function returns the size necessary to hold
*            the data.
* iMapMode   the desired mapping mode of the metafile contents to be returned
* hdcRef     defines the units of the metafile to be returned
*
* Return Value
* The return value is the size of the metafile data in bytes. If an error
* occurs, 0 is returned.
*
* Comments
* The handle used as the hemf parameter does NOT become invalid when the
* GetWinMetaFileBits function returns.
*
* History:
*  Thu Apr  8 14:22:23 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  02-Jan-1992     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

UINT GdipGetWinMetaFileBitsEx
(
HENHMETAFILE hemf,
UINT         cbData16,
LPBYTE       pData16,
INT          iMapMode,
INT          eFlags
)
{
    BOOL bEmbedEmf = ((eFlags & EmfToWmfBitsFlagsEmbedEmf) == EmfToWmfBitsFlagsEmbedEmf);
    BOOL bXorPass  = !((eFlags & EmfToWmfBitsFlagsNoXORClip) == EmfToWmfBitsFlagsNoXORClip);
    UINT fConverter = 0;
    if (bEmbedEmf)
    {
        fConverter |= MF3216_INCLUDE_WIN32MF;
    }
    if (bXorPass)
    {
        fConverter |= GPMF3216_INCLUDE_XORPATH;
    }

    PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;
    UINT uiHeaderSize ;

    // Always go through Cleanup to return...
    UINT returnVal = 0 ; // Pessimistic Case

    PENHMETAHEADER pmfh = NULL;
    PBYTE pemfb = NULL;

    PUTS("GetWinMetaFileBits\n");

    // Validate mapmode.

    if ((iMapMode < MM_MIN) ||
        (iMapMode > MM_MAX) ||
        GetObjectTypeInternal(hemf) != OBJ_ENHMETAFILE)
    {
        ERROR_ASSERT(FALSE, "GetWinMetaFileBits: Bad mapmode");
        return 0;
    }

    if(hemf == (HENHMETAFILE) 0 )
    {
        ERROR_ASSERT(FALSE, "GetWinMetaFileBits: Bad HEMF");
        return 0;
    }

    // Validate the metafile handle.

    // GillesK:
    // We cannot access the MF object from the handle given, but all we need
    // is the PENHMETAHEADER, so get it
    uiHeaderSize = GetEnhMetaFileHeader(hemf,      // handle to enhanced metafile
                   0,          // size of buffer
                   NULL);   // data buffer

    // We have the size of the header that we need, so Allocate the header....
    // We must make sure to free it after we are done....
    pmfh = (PENHMETAHEADER)GlobalAlloc(GMEM_FIXED,uiHeaderSize);
    if(pmfh == NULL)
    {
        goto Cleanup ;
    }
    uiHeaderSize = GetEnhMetaFileHeader(hemf,      // handle to enhanced metafile
                   uiHeaderSize,          // size of buffer
                   pmfh);   // data buffer

    ERROR_ASSERT(pmfh->iType == EMR_HEADE