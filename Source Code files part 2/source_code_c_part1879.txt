CREATEFILE;
        }
        
        // open index file
        if((fidx=fopen(idxName,"wb"))==NULL)
        {
            fclose(fin);
            fclose(fout);
            return IDS_ERRCREATEIDX;
        }
        
        
        code.position=0;
		oldcode.root=0;
        //fwrite(&code.position,4,sizeof(DWORD),fidx);
        fseek(fidx,16L,0);  //header
        
        while(fread(&temp,1,CharSize,fin))
        {
           code.root=0;
         
           if (temp!=' ' && temp!=10 && temp!=13 && temp!='|')  //CCĤ@rťզr(ΪťզC)ɡAӦCYѦC
           {
              // get roots
              i=0;          // how many roots
              do {
                 if(temp==' ') break;
                 if (temp>255) //error format
                 {
                    fclose(fin);
                    fclose(fout);
                    fclose(fidx);
                    return IDS_ERRFORMATROOT;
                 }
                 buffer=(BYTE)temp;
                 if(buffer>='a' && buffer<='z') buffer-=('a'-'A');  // upcase

                 // NrରsX
                 if(buffer>='A' && buffer<='Z')
                    buffer=buffer-'A'+5;
                 else
                    switch(buffer)
                    {
                       case ',': buffer=1; break;
                       case '.': buffer=2; break;
                       case '/': buffer=3; break;
                       case ';': buffer=4; break;
                       default:
                                 fclose(fin);
                                 fclose(fout);
                                 fclose(fidx);
                                 return IDS_ERRFORMATROOT;
                    }
                 code.root <<= 5;
                 code.root |=  (DWORD)buffer;
                 i++;
              } while (fread(&temp,1,CharSize,fin));

              if (i>=5 || code.root==0)   // to many roots!
              {
                 fclose(fin);
                 fclose(fout);
                 fclose(fidx);
                 return IDS_ERRFORMATROOTS;
              }
              else
			  {
                 code.root <<= (5-i)*5;
				 if(SortFlag)
				 {
					 if(code.root<oldcode.root)
					 {
						 fclose(fin);
						 fclose(fout);
						 fclose(fidx);
						 return IDS_ERRFORMATPHRASE;
					 }
				     oldcode.root=code.root;
				 }
			  }

              // cut space char
              while(fread(&temp,1,CharSize,fin))
                 if(temp!=' ') break;

              if(feof(fin))
              {
                 fclose(fin);
                 fclose(fout);
                 return IDS_ERRFORMATCODE;
              }

              // Xr
              i=0;
              do {
                  if(temp<=13)
					 break;	 
				  fwrite (&temp,1,sizeof(temp),fout);  // write to output file
				  i++;
              } while (fread(&temp,1,CharSize,fin));

              if (!i)
              {
                 fclose(fin);
                 fclose(fout);
                 return IDS_ERRFORMATCODE;
              }

              fwrite (&code,1,sizeof(code),fidx);  // write to index file
              code.position+=i;

           }
           
           if (SortFlag && temp=='|')  // data not sort
           {
              header[0]=*line+1;
              code.root=0xffffffff;
              fwrite (&code,1,sizeof(code),fidx);  // write to index file
			  SortFlag = FALSE;
           }
           
           while(temp!=0x000a)   // goto end of line ...
              if(!fread(&temp,1,CharSize,fin))
                 break;
           (*line) ++;
        }

        header[1]=*line+1;
        code.root=0xffffffff;
        fwrite (&code,1,sizeof(code),fidx);  // write to index file
        fseek(fidx,0L,0);
        fwrite (header,1,16,fidx);           // write header
        
        fclose(fin);
        fclose(fout);
        fclose(fidx);
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\array\convert\function.c ===
#include <windows.h>
#include <string.h>
#include <commdlg.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"

OPENFILENAME ofn ;  //ɮ׸Tc

// oɮת
LONG FileLen(HFILE hFile)
     {            
       long Len,curpos=_llseek(hFile,0L,1);
       Len=_llseek(hFile,0L,2);
       _llseek(hFile,curpos,0);
       return Len;
     }

int IsUniCode(char *FileName)
{
    FILE *fptr;
    WORD temp;
     
	if((fptr = fopen(FileName,"rb")) ==NULL)
	    return IDS_ERROPENFILE;
	
	fread(&temp,1,2,fptr);
    fclose(fptr);
	
	if (temp!=0xFEFF)
	   return IDS_ERRUNICODE;
	
     return 0;
}

/////////////////////////////////////////////////////////////////////////////
int GetFilePath(char *FileName)
{
    int i=strlen(FileName)-1;
    while(i>0 && FileName[i]!='\\') i--;
    return i;
}

BOOL PopFileOpenDlg (HWND hwnd, char *FileName, char *TitleName,char *Filter)//, int index)
     {
     char szDir[256];
     int i=GetFilePath(FileName);
     
     if(i>0) 
     {
	 strncpy(szDir,FileName,i); szDir[i]=0;
	 strcpy (FileName,FileName+i+1);
     }    
     else    szDir[0]=0;
     
     ofn.lpstrInitialDir   = szDir ;
     ofn.hwndOwner         = hwnd ;
     ofn.lpstrFile         = FileName ;
     ofn.lpstrTitle        = TitleName ;
     ofn.lpstrFilter       = Filter ;
     //if(index) ofn.nFilterIndex      = index ;
	 ofn.Flags             = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST |OFN_HIDEREADONLY;

     return GetOpenFileName (&ofn) ;
     }

BOOL PopFileSaveDlg (HWND hwnd, char *FileName, char *TitleName,char *Filter)//,int index)
     {
     char szDir[256];
     int i=GetFilePath(FileName);
     
     if(i>0) 
     {
	 strncpy(szDir,FileName,i); szDir[i]=0;
	 strcpy (FileName,FileName+i+1);
     }    
     else    szDir[0]=0;
       
     ofn.hwndOwner         = hwnd ;
     ofn.lpstrFile         = FileName ;
     ofn.lpstrTitle        = TitleName ;
     ofn.lpstrFilter       = Filter ;
     //if(index) ofn.nFilterIndex      = index ;
	 ofn.Flags             = OFN_OVERWRITEPROMPT ;

     return GetSaveFileName (&ofn) ;
     }

void PopFileInit ()
     {
     ofn.lStructSize       = sizeof (OPENFILENAME) ;
     ofn.hInstance         = NULL ;
     //ofn.lpstrFilter       = szFilter ;
     ofn.lpstrCustomFilter = NULL ;
     ofn.nMaxCustFilter    = 0 ;
     ofn.nFilterIndex      = 1 ;
     ofn.lpstrFile         = NULL ;          // Set in Open and Close functions
     ofn.nMaxFile          = _MAX_PATH ;
     ofn.lpstrFileTitle    = NULL ;          // Set in Open and Close functions
     ofn.nMaxFileTitle     = _MAX_FNAME + _MAX_EXT ;
     ofn.lpstrInitialDir   = NULL ;
     ofn.lpstrTitle        = NULL ;
     ofn.Flags             = 0 ;             // Set in Open and Close functions
     ofn.nFileOffset       = 0 ;
     ofn.nFileExtension    = 0 ;
     ofn.lpstrDefExt       = "" ;
     ofn.lCustData         = 0L ;
     ofn.lpfnHook          = NULL ;
     ofn.lpTemplateName    = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\array\convert\cvtword.c ===
//
//    C r X{
//
//                Ż 1998/03/15
//

#include <windows.h>
#include <stdio.h>
#include "resource.h"

#define CharSize  2       //for unicode file format

typedef struct {
                DWORD root;
                WORD  china;
               } ROOTINFO;


int cvtword(char *FileName,char *OutName,DWORD *line)
{
        FILE      *fin;
        FILE      *fout;
        BYTE      buffer;
        WORD      temp;
        ROOTINFO  code;
        int       i;
        
        *line =1;
        
        // open input file
        if((fin = fopen(FileName,"rb")) ==NULL)
            return IDS_ERROPENFILE;
        fread(&temp,CharSize,1,fin);  // for unicode header
        
        // open output file
        if((fout=fopen(OutName,"wb"))==NULL)
        {
            fclose(fin);
            return IDS_ERRCREATEFILE;
        }
        
        
        while(fread(&temp,1,CharSize,fin))
        {
           code.root=0;
           code.china=0;
        
           if (temp!=' ')  //CCĤ@rťզrɡAӦCYѦC
           {
              // get code
              i=0;
              do {
                 if(temp==' ') break;
                 if (temp>255) //error format
                 {
                    fclose(fin);
                    fclose(fout);
                    return IDS_ERRFORMATROOT;
                 }
                 buffer=(BYTE)temp;
                 if(buffer>='a' && buffer<='z') buffer-=('a'-'A');  //upcase

                 // rsX
                 if(buffer>='A' && buffer<='Z')
                    buffer=buffer-'A'+5;
                 else
                    switch(buffer)
                    {
                       case ',': buffer=1; break;
                       case '.': buffer=2; break;
                       case '/': buffer=3; break;
                       case ';': buffer=4; break;
                       default:
                                 fclose(fin);
                                 fclose(fout);
                                 return IDS_ERRFORMATROOT;

                    }
                 code.root <<= 5;
                 code.root |=  (DWORD)buffer;
                 i++;
              } while (fread(&temp,1,CharSize,fin));

              if (i>5 || code.root==0)   // to many roots!
              {
                 fclose(fin);
                 fclose(fout);
                 return IDS_ERRFORMATROOTS;
              }
              else
                 code.root <<= (5-i)*5;

              // cut space char
              while(fread(&temp,1,CharSize,fin))
                 if(temp!=' ') break;

              if(feof(fin))
               {
                  fclose(fin);
                  fclose(fout);
                  return IDS_ERRFORMATCODE;
               }

              if(temp<=255)
                for(i=0;i<4;i++)
                {
                   buffer=(BYTE)temp;
                   if(buffer>'Z') buffer-=('a'-'A');

                   if( (buffer>'9' && buffer<'A') ||
                       buffer<'0' || buffer>'F'     )
                   {
                       fclose(fin);
                       fclose(fout);
                       return IDS_ERRFORMATCODE;
                   }

                   code.china<<=4;
                   if(buffer>='A') code.china|=(buffer-'A'+10);
                   else            code.china|=(buffer-'0');
                   if(!fread(&temp,1,CharSize,fin))
                   {
                      fclose(fin);
                      fclose(fout);
                      return IDS_ERRFORMATCODE;
                   }

                }
              else
                code.china=temp;

              if(code.china<255) return IDS_ERRFORMATCODE;
              fwrite (&code,1,sizeof(ROOTINFO),fout);  // write to output file
			  
           }
           
           while(temp!=0x000a)   // goto end of line ...
              if(!fread(&temp,1,CharSize,fin))
                 break;
           (*line) ++;
        }

        fclose(fin);
        fclose(fout);
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\array\convert\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by ARCVT.RC
//
#define IDS_ERROPENFILE                 1
#define IDS_ERRCREATEFILE               2
#define IDS_ERRCREATEIDX                3
#define IDS_ERRUNICODE                  4
#define IDS_ERRFORMATROOT               5
#define IDS_ERRFORMATROOTS              6
#define IDS_ERRFORMATPHRASE             7
#define IDS_ERRFORMATCODE               8
#define IDD_DIALOG1                     101
#define IDR_MENU1                       102
#define IDD_ABOUT                       103
#define IDC_SOURCE                      1000
#define IDC_DESTINATION                 1001
#define IDC_EDIT1                       1001
#define IDM_CALC                        40001
#define IDM_WORD                        40001
#define IDM_JOHN                        40002
#define IDM_PHRASE                      40002
#define IDM_HIGH                        40003
#define IDM_HELP                        40004
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\chajei\chajeisrc\chajeisrc.c ===
/*************************************************
 *  chajei.c                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// ---------------------------------------------------------------------------
//
//  This program generateis Chajei Source Unicode file from its table files
//
//  History:   03-24-1998,  Weibz, Created
//
//  Usage: chajeisrc <A15.tbl> <A234.tbl>  <Acode.tbl> <Unicode Text File>
//
//
// --------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hA15, hA234, hAcode, hOutFile; 
  HANDLE   hA15Map, hA234Map, hAcodeMap;
  LPWORD   lpA15,   lpAcode,  lpA234;
  DWORD    BytesWritten;
  WORD     iA15Pattern;
  int      i;
  WORD     wOutData,    wA1,         wA5;
  WORD     wPattern234, uCode;
  WORD     OutLine[9];



  if ( argc != 5 ) {
    printf("usage: chajeisrc <A15.tbl> <A234.tbl> <Acode.tbl> <U Text File>\n");
    return; 
  }


  hA15 = CreateFile( argv[1],          // pointer to name of the file
                     GENERIC_READ,     // access (read-write) mode
                     FILE_SHARE_READ,  // share mode
                     NULL,             // pointer to security attributes
                     OPEN_EXISTING,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hA15 == INVALID_HANDLE_VALUE )  {
     printf("hA15 is INVALID_HANDLE_VALUE\n");
     return;
  }


  hA234 = CreateFile(argv[2],          // pointer to name of the file
                     GENERIC_READ,     // access (read-write) mode
                     FILE_SHARE_READ,  // share mode
                     NULL,             // pointer to security attributes
                     OPEN_EXISTING,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hA234 == INVALID_HANDLE_VALUE )  {
     printf("hA234 is INVALID_HANDLE_VALUE\n");
     return;
  }


  hAcode = CreateFile(argv[3],          // pointer to name of the file
                      GENERIC_READ,     // access (read-write) mode
                      FILE_SHARE_READ,  // share mode
                      NULL,             // pointer to security attributes
                      OPEN_EXISTING,    // how to create
                      FILE_ATTRIBUTE_NORMAL,  // file attributes
                      NULL);

  if ( hAcode == INVALID_HANDLE_VALUE )  {
     printf("hAcode is INVALID_HANDLE_VALUE\n");
     return;
  }

  hOutFile = CreateFile(  argv[4],          // pointer to name of the file
                         GENERIC_WRITE,     // access (read-write) mode
                         FILE_SHARE_WRITE,  // share mode
                         NULL,              // pointer to security attributes
                         CREATE_ALWAYS ,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  return;

  hA15Map = CreateFileMapping(hA15,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hA15Map ) {
    printf("hA15Map is NULL\n");
    return;
  } 

  hA234Map = CreateFileMapping(hA234,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hA234Map ) {
    printf("hA234Map is NULL\n");
    return;
  }

  hAcodeMap = CreateFileMapping(hAcode,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hAcodeMap ) {
    printf("hAcodeMap is NULL\n");
    return;
  }



  lpA15 = (LPWORD)MapViewOfFile(hA15Map, FILE_MAP_READ, 0, 0, 0);
  lpA234 = (LPWORD)MapViewOfFile(hA234Map, FILE_MAP_READ, 0, 0, 0);
  lpAcode = (LPWORD)MapViewOfFile(hAcodeMap, FILE_MAP_READ, 0, 0, 0);

// ------------------------------


  wOutData = 0xFEFF;

  WriteFile(hOutFile,               // handle to file to write to
            &wOutData,              // pointer to data to write to file
            2,                      // number of bytes to write
            &BytesWritten,          // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O


  for (i=0; i<5; i++) 
       OutLine[i] = 0x0020;
  OutLine[5] = 0x0009;
  OutLine[7] = 0x000D;
  OutLine[8] = 0x000A;

  for (iA15Pattern=0; iA15Pattern < 27 * 27 - 1; iA15Pattern++) {
      WORD  A234Start,  A234End,  Offset;
      WORD  wSeq;

      A234Start = lpA15[iA15Pattern];
      A234End   = lpA15[iA15Pattern+1];

      if ( A234End > A234Start ) {

         wA1 = iA15Pattern / 27;
         wA5 = iA15Pattern % 27;
         if ( wA1 == 0 )
            wA1 = 0x0020;
         else
            wA1 = wA1 + L'A' - 1; 

         if ( wA5 == 0 )
            wA5 = 0x0020;
         else
            wA5 = wA5 + L'A' - 1;

         OutLine[0] = wA1;
         OutLine[4] = wA5;

         for (Offset=A234Start; Offset<A234End; Offset++) {
             wPattern234 = lpA234[Offset]; 
             uCode = lpAcode[Offset];
             
             for (i=3; i>0; i--) {
                 wSeq = wPattern234 & 0x1f;
                 if ( wSeq == 0 ) 
                    OutLine[i] = 0x0020;
                 else
                    OutLine[i] = wSeq + L'A' - 1;   
                 wPattern234 = wPattern234 >> 5;
             }
             OutLine[6] = uCode; 
             WriteFile(hOutFile,       // handle to file to write to
                       OutLine,        // pointer to data to write to file
                       18,             // number of bytes to write
                       &BytesWritten,  // pointer to number of bytes written
                       NULL);          // pointer to structure needed for
                                       // overlapped I/O
         }

      }
  }

// ------------------------------------------------------------


  UnmapViewOfFile(lpA15);
  UnmapViewOfFile(lpA234);
  UnmapViewOfFile(lpAcode);

  CloseHandle(hA15Map);
  CloseHandle(hA234Map);
  CloseHandle(hAcodeMap);

  CloseHandle(hOutFile);
  CloseHandle(hA15);
  CloseHandle(hA234);
  CloseHandle(hAcode);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\chajei\genctbl\genctbl.c ===
/*************************************************
 *  genctbl.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// ---------------------------------------------------------------------------
//
//  This program is used to generate Chajei IME tables from its text Code table
//
//  History:   02-06-1998,  Weibz, Created
//
//  Usage:   genctbl  <Unicode Text File>  <A15.tbl> <A234.tbl>  <Acode.tbl>
//
//
// --------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile, hA15, hA234, hAcode; 
  HANDLE   hInMap;
  LPWORD   lpInFile, lpStart, lpA1, lpA5, lpAcode;
  DWORD    dwInFileSize, BytesWritten;
  DWORD    iLine, LineLen, NumLine;
  int      i;
  WORD     wOutData, wOffset, wLastOffset;
  WORD     wA1, wA5;
  WORD     wPattern234, uCode;



  if ( argc != 5 ) {
    printf("usage: genctbl <U Text File> <A15.tbl> <A234.tbl> <Acode.tbl>\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  hA15 = CreateFile( argv[2],          // pointer to name of the file
                     GENERIC_WRITE,    // access (read-write) mode
                     FILE_SHARE_WRITE, // share mode
                     NULL,             // pointer to security attributes
                     CREATE_ALWAYS,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hA15 == INVALID_HANDLE_VALUE )  {
     printf("hA15 is INVALID_HANDLE_VALUE\n");
     return;
  }


  hA234 = CreateFile(argv[3],          // pointer to name of the file
                     GENERIC_WRITE,    // access (read-write) mode
                     FILE_SHARE_WRITE, // share mode
                     NULL,             // pointer to security attributes
                     CREATE_ALWAYS,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hA234 == INVALID_HANDLE_VALUE )  {
     printf("hA234 is INVALID_HANDLE_VALUE\n");
     return;
  }


  hAcode = CreateFile(argv[4],          // pointer to name of the file
                      GENERIC_WRITE,    // access (read-write) mode
                      FILE_SHARE_WRITE, // share mode
                      NULL,             // pointer to security attributes
                      CREATE_ALWAYS,    // how to create
                      FILE_ATTRIBUTE_NORMAL,  // file attributes
                      NULL);

  if ( hAcode == INVALID_HANDLE_VALUE )  {
     printf("hAcode is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPWORD)MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  lpStart = lpInFile + 1;  // skip Unicode header signature 0xFEFF

  dwInFileSize = GetFileSize(hInFile, NULL) - 2;  // sub head two bytes

  LineLen = 9 * sizeof(WORD);

  NumLine = dwInFileSize / LineLen;

// ------------------------------

// For the first 27 words, we need to write 00 to A15.tbl

   wOutData = 0x0000;

   for (i=0; i<27; i++) {
      WriteFile(hA15,                   // handle to file to write to
                &wOutData,              // pointer to data to write to file
                2,                      // number of bytes to write
                &BytesWritten,          // pointer to number of bytes written
                NULL);                  // pointer to structure needed for
                                        // overlapped I/O
   }

   wLastOffset = 26;

   for (iLine=0; iLine < NumLine; iLine++) {

       lpA1 = lpStart;
       lpA5 = lpStart + 4;
       lpAcode = lpStart + 6;
       wA1 = *lpA1;   wA5 = *lpA5;  uCode = *lpAcode;
       if (wA1 == 0x0020)  
          wA1 = 0;
       else
          wA1 = wA1 - L'A' + 1;

       if (wA5 == 0x0020)
          wA5 = 0;
       else
          wA5 = wA5 - L'A' + 1;

       //Generate the pattern

       wPattern234 = 0;

       for (i=1; i<4; i++) {
          wPattern234 = wPattern234 << 5;
          if ( *(lpA1+i) != 0x0020 )
             wPattern234 += *(lpA1+i) - L'A' + 1;
       }

       // write this Pattern to A234.tbl

       WriteFile(hA234,                  // handle to file to write to
                 &wPattern234,           // pointer to data to write to file
                 2,                      // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O       
              

       // write uCode to Acode.tbl

       WriteFile(hAcode,                 // handle to file to write to
                 &uCode,                 // pointer to data to write to file
                 2,                      // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O



       wOffset = wA1 * 27  + wA5;

       if ( wOffset > wLastOffset ) {
          for (i=wLastOffset; i<wOffset; i++) {
              WriteFile(hA15,           // handle to file to write to
                        &iLine,         // pointer to data to write to file
                        2,              // number of bytes to write
                        &BytesWritten,  // pointer to number of bytes written
                        NULL);          // pointer to structure needed for
                                        // overlapped I/O
          }
          wLastOffset = wOffset;

       }                         

       lpStart += 9; 
   } 



   for (i=wLastOffset; i< (27*27 ); i++)
             WriteFile(hA15,           // handle to file to write to
                       &iLine,         // pointer to data to write to file
                       2,              // number of bytes to write
                       &BytesWritten,  // pointer to number of bytes written
                       NULL);          // pointer to structure needed for
                                       // overlapped I/O

// ------------------------------------------------------------


  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hA15);
  CloseHandle(hA234);
  CloseHandle(hAcode);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\chajei\genncsrc\genncsrc.c ===
/*************************************************
 *  genncsrc.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  This file is used to Generate a new source Chajei Table File.
//
//  it will read two files, one for Big5 and one for GB, to generate a new 
//  Chajei code table file.
//
//  the two input files are sorted on the external keystroke pattern,(A1&A5) 
//  and both are complete Unicode files, ( there is 0xFEFF  
//  in its first two bytes), 
//
//  the two input files contain lots of lines,every line follows below format:
//        XXXXXTCRL
//    X:   Key Code,
//    T:   Tab,  0x0009
//    C:   Unicode for this Character
//    R:   0x000D
//    L:   0x000A
//
//  we will generate a new table source file, if the same pattern exists in both
//  Big5 file and GB file, all those lines will be appended to the new file, and//  the lines of Big5 will be written first, then GB Lines
//  
//  the new generated file must be sorted on the pattern.

//
//  Created by weibz, March 03, 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )

DWORD  GetPattern( WORD  *lpWord )
{
  DWORD dwPat;
  WORD  wA1,   wA5;
  WORD  *lpA1, *lpA5;

int  i;

/*for (i=0; i<5; i++)
{
  printf("%x ", (int)(lpWord[i]) );
}
printf("\n");

*/

  lpA1 = lpWord;
  lpA5 = lpWord + 4;
  wA1 = *lpA1;   wA5 = *lpA5;

  if (wA1 == 0x0020)
     wA1 = 0;
  else
     wA1 = wA1 - L'A' + 1;

  if (wA5 == 0x0020)
     wA5 = 0;
  else
     wA5 = wA5 - L'A' + 1;

//  dwPat = (DWORD)wA1;
//  dwPat = dwPat << 16 + (DWORD)wA5;

  dwPat = wA1;
  dwPat = dwPat * 27;
  dwPat = dwPat + (DWORD)wA5;

  return dwPat; 

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInBig5File,  hInGBFile, hOutSrcFile;
  HANDLE   hInBig5Map,   hInGBMap;
  LPWORD   lpInBig5File, lpInGBFile, lpStartBig5, lpStartGB;
  DWORD    dwBig5Line,   dwGBLine;
  DWORD    iBig5Line,    iGBLine, i;
  DWORD    dwInFileSize, BytesWritten;
  WORD     wOutData;
  DWORD    dwPatternBig5, dwPatternGB;

  if ( argc != 4 ) {
    printf("Usage: genncsrc <Big5> <GB File> <New UnicdFile> \n");
    return; 
  }

  hInBig5File = CreateFile(  argv[1],          // pointer to name of the file
                             GENERIC_READ,     // access (read-write) mode
                             FILE_SHARE_READ,  // share mode
                             NULL,             // pointer to security attributes
                             OPEN_EXISTING,    // how to create
                             FILE_ATTRIBUTE_NORMAL,  // file attributes
                             NULL);    

  if ( hInBig5File == INVALID_HANDLE_VALUE )  return;

  hInGBFile = CreateFile( argv[2],          // pointer to name of the file
                          GENERIC_READ,     // access (read-write) mode
                          FILE_SHARE_READ,  // share mode
                          NULL,             // pointer to security attributes
                          OPEN_EXISTING,    // how to create
                          FILE_ATTRIBUTE_NORMAL,  // file attributes
                          NULL);

  if ( hInGBFile == INVALID_HANDLE_VALUE )  {
     printf("hInGBFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hOutSrcFile = CreateFile(argv[3],          // pointer to name of the file
                           GENERIC_WRITE,    // access (read-write) mode
                           FILE_SHARE_WRITE, // share mode
                           NULL,             // pointer to security attributes
                           CREATE_ALWAYS,    // how to create
                           FILE_ATTRIBUTE_NORMAL,  // file attributes
                           NULL);

  if ( hOutSrcFile == INVALID_HANDLE_VALUE )  {
     printf("hOutSrcFile is NULL\n");
     return;
  }


  hInBig5Map = CreateFileMapping(hInBig5File,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInBig5Map ) {
    printf("hInBig5Map is NULL\n");
    return;
  } 

  hInGBMap = CreateFileMapping(hInGBFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInGBMap ) {
    printf("hInGBMap is NULL\n");
    return;
  }

  lpInBig5File = (LPWORD)MapViewOfFile(hInBig5Map, FILE_MAP_READ, 0, 0, 0);

  lpInGBFile = (LPWORD)MapViewOfFile(hInGBMap, FILE_MAP_READ, 0, 0, 0);

  lpStartBig5 = lpInBig5File + 1;  // skip Unicode header signature 0xFEFF

  lpStartGB = lpInGBFile + 1; // skip Unicode header signature 0xFEFF

  dwInFileSize = GetFileSize(hInBig5File, NULL) - 2;  // sub head two bytes

  dwBig5Line = dwInFileSize / LINELEN;

  dwInFileSize = GetFileSize(hInGBFile, NULL) - 2; 

  dwGBLine = dwInFileSize / LINELEN;

  wOutData = 0xFEFF;
  WriteFile(hOutSrcFile,            // handle to file to write to
            &wOutData,              // pointer to data to write to file
            2,                      // number of bytes to write
            &BytesWritten,          // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O
  iBig5Line=iGBLine=0;
  while ((iBig5Line < dwBig5Line) && (iGBLine < dwGBLine)) {

    dwPatternBig5 = GetPattern(lpStartBig5);
    dwPatternGB = GetPattern(lpStartGB);
/*
printf("PatBig5=%x  PatGB=%x LineBig5=%d LineGB=%d\n",dwPatternBig5, dwPatternGB, iBig5Line, iGBLine);
*/

    if (dwPatternBig5 < dwPatternGB ) {
       // in this case, we just keep all lines in Big5 File which have same 
       // dwpattern to new generated file.

       // write lpStartBig5 to OutSrcFile 

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartBig5,            // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartBig5 += LINELEN/sizeof(WORD);
       iBig5Line ++;
    
       while ( (iBig5Line < dwBig5Line) && 
               (GetPattern(lpStartBig5) == dwPatternBig5) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartBig5,     // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartBig5 += LINELEN/sizeof(WORD);
            iBig5Line ++;
       }
    } 
    else  if ( dwPatternBig5 == dwPatternGB ) {
       // in this case, we will put all the lines in BIG5 and then in GB with
       // the same dwpattern to the new generated file.

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartBig5,            // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartBig5 += LINELEN/sizeof(WORD);
       iBig5Line ++;

       while ( (iBig5Line < dwBig5Line) &&
               (GetPattern(lpStartBig5) == dwPatternBig5) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartBig5,     // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartBig5 += LINELEN/sizeof(WORD);
            iBig5Line ++;
       }
              
       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartGB,              // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartGB += LINELEN/sizeof(WORD);
       iGBLine ++;

       while ( (iGBLine < dwGBLine) &&
               (GetPattern(lpStartGB) == dwPatternGB) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }

    } else {
      // in this case, we just put all the lines with same pattern in file
      // GB to the new generated file.

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartGB,              // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartGB += LINELEN/sizeof(WORD);
       iGBLine ++;

       while ( (iGBLine < dwGBLine) &&
               (GetPattern(lpStartGB) == dwPatternGB) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }

    } 

  } // while ...

  if ( iBig5Line < dwBig5Line ) {


//printf("\niBig5Line=%d\n", iBig5Line);

      while ( iBig5Line < dwBig5Line )  {

           WriteFile(hOutSrcFile,     // handle to file to write to
                     lpStartBig5,     // pointer to data to write to file
                     LINELEN,         // number of bytes to write
                     &BytesWritten,   // pointer to number of bytes written
                     NULL);           // pointer to structure needed for
                                      // overlapped I/O
           lpStartBig5 += LINELEN/sizeof(WORD);
           iBig5Line ++;
      }

  }

  if ( iGBLine < dwGBLine ) {

//printf("\niGBLine=%d\n", iGBLine);

       while ( iGBLine < dwGBLine )  { 

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }
  }

  UnmapViewOfFile(lpInBig5File);
  UnmapViewOfFile(lpInGBFile);

  CloseHandle(hInBig5Map);
  CloseHandle(hInGBMap);

  CloseHandle(hInBig5File);
  CloseHandle(hInGBFile);
  CloseHandle(hOutSrcFile);

  return; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\chajei\convert\convert.c ===
/*************************************************
 *  convert.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  this program is used to convert Chajei TXT file to Unicode Table file
//

#include <stdio.h>
#include <windows.h>


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile,  hOutFile; 
  HANDLE   hInMap;
  LPBYTE   lpInFile;
  WORD     OutLine[20];
  DWORD    dwInFileSize, i, NumberOfBytesWritten;
  DWORD    iLine;

  if ( argc != 3 ) {
    printf("usage: Convctbl File1  File2\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);
    

  hOutFile=CreateFile(  argv[2],          // pointer to name of the file
                        GENERIC_WRITE,    // access (read-write) mode
                        FILE_SHARE_WRITE, // share mode
                        NULL,             // pointer to security attributes
                        CREATE_ALWAYS,    // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  {
     printf("hOutFile is NULL\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  OutLine[0] = 0xFEFF;
  WriteFile(hOutFile,               // handle to file to write to
            OutLine,                // pointer to data to write to file
            2,                      // number of bytes to write
            &NumberOfBytesWritten,  // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O

  i = 0;  
  iLine = 1;

  while ( i < dwInFileSize ) {

    WORD  CharCode;

    DWORD  iStart, iTmp;
    
    CharCode = 0;

    for (iStart=0; iStart<4; iStart++) {
        BYTE  ThisByte;

        ThisByte = lpInFile[i+iStart];
        if ( (ThisByte >= '0')  &&  (ThisByte <= '9') )    
            ThisByte = ThisByte - '0';
        else
           if ( (ThisByte >= 'A') && (ThisByte <= 'F') )
              ThisByte = ThisByte - 'A' + 10;
           else
              {
                  printf("Line Num %d data error ThisByte is %c\n", iLine, ThisByte);
                  return;
              }
        CharCode = CharCode * 16 + ThisByte;
     
    }

    i += 4;

    while ( lpInFile[i] == 0x20 )  i++;

    iStart = 0;

    while ((lpInFile[i]!=0x0D) && (i<dwInFileSize)) {

        if (lpInFile[i] != 0x20) {
           OutLine[iStart] = (WORD)(lpInFile[i]) & 0x00ff;
           i++;
           iStart ++;
        }
        else  // it is  0x20
        {
           while ( lpInFile[i] == 0x20 )  i++;
           if ( (iStart < 5) && (iStart != 1 ) ) {
              OutLine[4] = OutLine[iStart-1];
              for (iTmp=iStart-1; iTmp<4; iTmp++)
                  OutLine[iTmp] = 0x0020;

           }
           if (iStart == 1)
              for (iTmp=1; iTmp<5; iTmp++)
                  OutLine[iTmp] = 0x0020;

           iStart = 5;

           OutLine[iStart++] = 0x0009;     // Add Tab
           OutLine[iStart++] = CharCode;   // Add char code 
           OutLine[iStart++] = 0x000D;
           OutLine[iStart++] = 0x000A;

           WriteFile(hOutFile,               // handle to file to write to
                     OutLine,                // pointer to data to write to file
                     iStart * sizeof(WORD),  // number of bytes to write
                     &NumberOfBytesWritten,  // number of bytes written 
                     NULL);                  // pointer to structure needed for 
                                             // overlapped I/O
           iStart = 0; 
        }
    }  // lpInFile[i] != 0x0D

    if ( lpInFile[i] == 0x0D ) {
       
       iLine ++;

       if ( lpInFile[i+1] == 0x0A )  
          i = i + 2;
       else  
          i++;
    }

    if ( iStart > 0 ) {

       if ( (iStart < 5) && (iStart != 1) ) {
          OutLine[4] = OutLine[iStart-1];
          for (iTmp=iStart-1; iTmp<4; iTmp++)
              OutLine[iTmp] = 0x0020;

       }

       if (iStart == 1)
          for (iTmp=1; iTmp<5; iTmp++)
              OutLine[iTmp] = 0x0020;

       iStart = 5;

       OutLine[iStart++] = 0x0009;     // Add Tab
       OutLine[iStart++] = CharCode;   // Add char code
       OutLine[iStart++] = 0x000D;
       OutLine[iStart++] = 0x000A;

       WriteFile(hOutFile,               // handle to file to write to
                 OutLine,                // pointer to data to write to file
                 iStart * sizeof(WORD),  // number of bytes to write
                 &NumberOfBytesWritten,  // number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O
       iStart = 0;
    }

  }  // while i<dwInFileSize

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hOutFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\chajei\sortctbl\sorttbl.c ===
/*************************************************
 *  sorttbl.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/



#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )

int __cdecl Mycompare(const void *elem1, const void *elem2 )
{
  INT   i;
  WORD  *pWord1, *pWord2;
  WORD  uCode1, uCode2;

  pWord1 = (WORD *)elem1;
  pWord2 = (WORD *)elem2;

  if ( *pWord1 > *pWord2 )  return 1;
  if ( *pWord1 < *pWord2 )  return -1;

  if ( *(pWord1+4) > *(pWord2+4) )  return 1;
  if ( *(pWord1+4) < *(pWord2+4) )  return -1;

  uCode1 = *(pWord1 + 6);
  uCode2 = *(pWord2 + 6);

  if (uCode1 > uCode2) return 1;
  if (uCode1 < uCode2) return -1; 

  return 0;

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile;
  HANDLE   hInMap;
  LPBYTE   lpInFile, lpStart;
  DWORD    dwInFileSize; 

  if ( argc != 2 ) {
    printf("usage: sorttbl UnicdeTableFile \n");
    return; 
  }


  hInFile = CreateFile(argv[1],          // pointer to name of the file
                       GENERIC_READ | GENERIC_WRITE, //access(read-write)mode
                       FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode
                       NULL,             // pointer to security attributes
                       OPEN_EXISTING,    // how to create
                       FILE_ATTRIBUTE_NORMAL,  // file attributes
                       NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);


    
  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READWRITE, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_WRITE, 0, 0, 0);

  printf("dwInFileSize=%d ", dwInFileSize);

  lpStart = lpInFile + 2;  // skip UNICODE signature FEFF
  
  qsort((void *)lpStart,(size_t)(dwInFileSize/LINELEN),(size_t)LINELEN,Mycompare);

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\dayi\convdayi\convdayi.c ===
/*************************************************
 *  convdayi.c                                   *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

//
//  this program is used to convert a ansi Text table to Unicode table file
//
//   the source file format:  (every Line)
//       AAAATMMMMT[MMM]DA
//
//       A :  Ascii code 
//       T:   Tab Key,  09
//       M:   Ma (at most  Four Keys), there may be '"', we need to delet it.
//
//   the destinate file format: (Every Line)
//
//       UUUUTCFDA
//      
//       U :  Unicode of Ma Key
//       T:   0x0009
//       C:   Unicode of the candiadate char.
//       F:   Flag, L' ' or L'*', '*' means reversion
//
//
//  History:   Weibz, created, 02/13/1998
//


#include <stdio.h>
#include <windows.h>


const WORD wChar2SeqTbl[0x42]={
    //  ' '   !     "     #     $     %     &     ' - char code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x27, 0x33, 0x28, 0x29,

    //  0     1     2     3     4     5     6     7
        0x0A, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,

    //  8     9     :     ;     <     =     >     ?
        0x08, 0x09, 0x00, 0x1E, 0x00, 0x2F, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x15, 0x24, 0x22, 0x17, 0x0D, 0x18, 0x19,

    //  H     I     J     K     L     M     N     O
        0x1A, 0x12, 0x1B, 0x1C, 0x1D, 0x26, 0x25, 0x13,

    //  P     Q     R     S     T     U     V     W
        0x14, 0x0B, 0x0E, 0x16, 0x0F, 0x11, 0x23, 0x0C,

    //  X     Y     Z     [     \     ]     ^     _
        0x21, 0x10, 0x20, 0x31, 0x34, 0x32, 0x00, 0x00,

    //  `     a
        0x35, 0x00  };


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile,  hOutFile; 
  HANDLE   hInMap;
  LPBYTE   lpInFile;
  WORD     OutLine[20];
  DWORD    dwInFileSize, i, NumberOfBytesWritten;
  DWORD    iLine;

  if ( argc != 3 ) {
    printf("Usage: convdayi File1  File2\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);
    

  hOutFile=CreateFile(  argv[2],          // pointer to name of the file
                        GENERIC_WRITE,    // access (read-write) mode
                        FILE_SHARE_WRITE, // share mode
                        NULL,             // pointer to security attributes
                        CREATE_ALWAYS,    // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  {
     printf("hOutFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  OutLine[0] = 0xFEFF;
  WriteFile(hOutFile,               // handle to file to write to
            OutLine,                // pointer to data to write to file
            2,                      // number of bytes to write
            &NumberOfBytesWritten,  // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O

  i = 0;  
  iLine = 1;

  while ( i < dwInFileSize ) {

    WORD  CharCode;
    DWORD iStart, iTmp;
    BOOL  bFirstCode;
    
    CharCode = 0;
    bFirstCode = TRUE;

    if ( i >= dwInFileSize) break; 
 

    for (iStart=0; iStart<4; iStart++) {
        BYTE  ThisByte;

        ThisByte = lpInFile[i+iStart];
        if ( (ThisByte >= '0')  &&  (ThisByte <= '9') )    
            ThisByte = ThisByte - '0';
        else
           if ( (ThisByte >= 'A') && (ThisByte <= 'F') )
              ThisByte = ThisByte - 'A' + 10;
           else
            if ( (ThisByte >= 'a') && (ThisByte <= 'f') )
              ThisByte = ThisByte - 'a' + 10;
            else
            {
             printf("Line Num %d data error ThisByte is %c\n", iLine, ThisByte);
             return;
            }
        CharCode = CharCode * 16 + ThisByte;
     
    }

    i += 4;

    while ( (lpInFile[i]== 0x09) || (lpInFile[i] == ' ')  ||
            (lpInFile[i] == '"') )  i++;

    iStart = 0;

    while ((lpInFile[i]!=0x0D) && (i<dwInFileSize)) {

        if ( (lpInFile[i] != 0x09) && (lpInFile[i] != ' ') &&
             (lpInFile[i] != '"') ) {

           //must be serial External key Code
            
           OutLine[iStart] = (WORD)(lpInFile[i]) & 0x00ff; 
           iStart ++;

           i ++;
        }
        else  // it is  0x09
        {

           while ( (lpInFile[i]== 0x09) || (lpInFile[i] == ' ') ||
                   (lpInFile[i] == '"') )  i++;

           if ( iStart == 0 )  continue;

           if ( iStart < 4 )  {

              for ( iTmp=iStart; iTmp<4; iTmp++ ) 
                  OutLine[iTmp] = 0x0020;
              
           }

           iStart = 4;

           OutLine[iStart++] = 0x0009;     // Add Tab
           OutLine[iStart++] = CharCode;   // Add char code 

           if ( bFirstCode == TRUE ) {
              OutLine[iStart++] = L' ';
              bFirstCode = FALSE;
           }
           else
              OutLine[iStart++] = L'*';
  
           OutLine[iStart++] = 0x000D;
           OutLine[iStart++] = 0x000A;

           WriteFile(hOutFile,               // handle to file to write to
                     OutLine,                // pointer to data to write to file
                     iStart * sizeof(WORD),  // number of bytes to write
                     &NumberOfBytesWritten,  // number of bytes written 
                     NULL);                  // pointer to structure needed for 
                                             // overlapped I/O
           iStart = 0; 
        }
    }  //  While lpInFile[i] != 0x0D

    if ( lpInFile[i] == 0x0D ) {
       
       iLine ++;

       if ( lpInFile[i+1] == 0x0A )  
          i = i + 2;
       else  
          i++;
    }

    if ( iStart > 0 ) {

           if ( iStart < 4 )  {

              for ( iTmp=iStart; iTmp<4; iTmp++ )
                  OutLine[iTmp] = 0x0020;

           }

           iStart = 4;

           OutLine[iStart++] = 0x0009;     // Add Tab
           OutLine[iStart++] = CharCode;   // Add char code

           if ( bFirstCode == TRUE ) {
              OutLine[iStart++] = L' ';
              bFirstCode = FALSE;
           }
           else
              OutLine[iStart++] = L'*';

           OutLine[iStart++] = 0x000D;
           OutLine[iStart++] = 0x000A;

           WriteFile(hOutFile,               // handle to file to write to
                     OutLine,                // pointer to data to write to file
                     iStart * sizeof(WORD),  // number of bytes to write
                     &NumberOfBytesWritten,  // number of bytes written
                     NULL);                  // pointer to structure needed for
                                             // overlapped I/O
           iStart = 0;

    }

  }  // while i<dwInFileSize

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hOutFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\dayi\genndsrc\genndsrc.c ===
/*************************************************
 *  genndsrc.c                                   *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

//
//  This file is used to Generate a new source Dayi Table File.
//
//  it will read two files, one for Big5 and one for GB, to generate a new 
//  Dayi code table file.
//
//  the two input files are sorted on the external keystroke pattern, 
//  and both are complete Unicode files, ( there is 0xFEFF  
//  in its first two bytes), 
//
//  the two input files contain lots of lines,every line follows below format:
//        XXXXTCFRL
//    X:   Key Code,
//    T:   Tab,  0x0009
//    C:   Unicode for this Character
//    F:   Flag: L' 'or L'*'
//    R:   0x000D
//    L:   0x000A
//
//  we will generate a new table source file, if the same pattern exists in both
//  Big5 file and GB file, all those lines will be appended to the new file, and//  the lines of Big5 will be written first, then GB Lines
//  
//  the new generated file must be sorted on the pattern.

//
//  Created by weibz, March 03, 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )

const DWORD dwChar2SeqTbl[0x42] = {
    //  ' '   !     "     #     $     %     &     ' - char code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x27, 0x33, 0x28, 0x29,

    //  0     1     2     3     4     5     6     7
        0x0A, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,

    //  8     9     :     ;     <     =     >     ?
        0x08, 0x09, 0x00, 0x1E, 0x00, 0x2F, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x15, 0x24, 0x22, 0x17, 0x0D, 0x18, 0x19,

    //  H     I     J     K     L     M     N     O
        0x1A, 0x12, 0x1B, 0x1C, 0x1D, 0x26, 0x25, 0x13,

    //  P     Q     R     S     T     U     V     W
        0x14, 0x0B, 0x0E, 0x16, 0x0F, 0x11, 0x23, 0x0C,

    //  X     Y     Z     [     \     ]     ^     _
        0x21, 0x10, 0x20, 0x31, 0x34, 0x32, 0x00, 0x00,

    //  `     a
        0x35, 0x00  };


DWORD  GetPattern( WORD  *pWord )
{
  int   i;
  DWORD dwPat, dwSeq;

  dwPat = 0;

  for (i=0; i<4; i++) {

      dwSeq = dwChar2SeqTbl[ pWord[i] - L' '];
      dwPat = (dwPat << 6)  + dwSeq;
  }

  return dwPat;

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInBig5File,  hInGBFile, hOutSrcFile;
  HANDLE   hInBig5Map,   hInGBMap;
  LPWORD   lpInBig5File, lpInGBFile, lpStartBig5, lpStartGB;
  DWORD    dwBig5Line,   dwGBLine;
  DWORD    iBig5Line,    iGBLine, i;
  DWORD    dwInFileSize, BytesWritten;
  WORD     wOutData;
  DWORD    dwPatternBig5, dwPatternGB;

  if ( argc != 4 ) {
    printf("Usage: genndsrc <Big5> <GB File> <New UnicdFile> \n");
    return; 
  }

  hInBig5File = CreateFile(  argv[1],          // pointer to name of the file
                             GENERIC_READ,     // access (read-write) mode
                             FILE_SHARE_READ,  // share mode
                             NULL,             // pointer to security attributes
                             OPEN_EXISTING,    // how to create
                             FILE_ATTRIBUTE_NORMAL,  // file attributes
                             NULL);    

  if ( hInBig5File == INVALID_HANDLE_VALUE )  return;

  hInGBFile = CreateFile( argv[2],          // pointer to name of the file
                          GENERIC_READ,     // access (read-write) mode
                          FILE_SHARE_READ,  // share mode
                          NULL,             // pointer to security attributes
                          OPEN_EXISTING,    // how to create
                          FILE_ATTRIBUTE_NORMAL,  // file attributes
                          NULL);

  if ( hInGBFile == INVALID_HANDLE_VALUE )  {
     printf("hInGBFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hOutSrcFile = CreateFile(argv[3],          // pointer to name of the file
                           GENERIC_WRITE,    // access (read-write) mode
                           FILE_SHARE_WRITE, // share mode
                           NULL,             // pointer to security attributes
                           CREATE_ALWAYS,    // how to create
                           FILE_ATTRIBUTE_NORMAL,  // file attributes
                           NULL);

  if ( hOutSrcFile == INVALID_HANDLE_VALUE )  {
     printf("hOutSrcFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInBig5Map = CreateFileMapping(hInBig5File,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInBig5Map ) {
    printf("hInBig5Map is NULL\n");
    return;
  } 

  hInGBMap = CreateFileMapping(hInGBFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInGBMap ) {
    printf("hInGBMap is NULL\n");
    return;
  }

  lpInBig5File = (LPWORD)MapViewOfFile(hInBig5Map, FILE_MAP_READ, 0, 0, 0);

  lpInGBFile = (LPWORD)MapViewOfFile(hInGBMap, FILE_MAP_READ, 0, 0, 0);

  lpStartBig5 = lpInBig5File + 1;  // skip Unicode header signature 0xFEFF

  lpStartGB = lpInGBFile + 1; // skip Unicode header signature 0xFEFF

  dwInFileSize = GetFileSize(hInBig5File, NULL) - 2;  // sub head two bytes

  dwBig5Line = dwInFileSize / LINELEN;

  dwInFileSize = GetFileSize(hInGBFile, NULL) - 2; 

  dwGBLine = dwInFileSize / LINELEN;

  wOutData = 0xFEFF;
  WriteFile(hOutSrcFile,            // handle to file to write to
            &wOutData,              // pointer to data to write to file
            2,                      // number of bytes to write
            &BytesWritten,          // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O
  iBig5Line=iGBLine=0;
  while ((iBig5Line < dwBig5Line) && (iGBLine < dwGBLine)) {

    dwPatternBig5 = GetPattern(lpStartBig5);
    dwPatternGB = GetPattern(lpStartGB);

    if (dwPatternBig5 < dwPatternGB ) {
       // in this case, we just keep all lines in Big5 File which have same 
       // dwpattern to new generated file.

       // write lpStartBig5 to OutSrcFile 

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartBig5,            // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartBig5 += LINELEN/sizeof(WORD);
       iBig5Line ++;
    
       while ( (iBig5Line < dwBig5Line) && 
               (GetPattern(lpStartBig5) == dwPatternBig5) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartBig5,     // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartBig5 += LINELEN/sizeof(WORD);
            iBig5Line ++;
       }
    } 
    else  if ( dwPatternBig5 == dwPatternGB ) {
       // in this case, we will put all the lines in BIG5 and then in GB with
       // the same dwpattern to the new generated file.

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartBig5,            // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartBig5 += LINELEN/sizeof(WORD);
       iBig5Line ++;

       while ( (iBig5Line < dwBig5Line) &&
               (GetPattern(lpStartBig5) == dwPatternBig5) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartBig5,     // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartBig5 += LINELEN/sizeof(WORD);
            iBig5Line ++;
       }
              
       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartGB,              // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartGB += LINELEN/sizeof(WORD);
       iGBLine ++;

       while ( (iGBLine < dwGBLine) &&
               (GetPattern(lpStartGB) == dwPatternGB) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }

    } else {
      // in this case, we just put all the lines with same pattern in file
      // GB to the new generated file.

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartGB,              // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartGB += LINELEN/sizeof(WORD);
       iGBLine ++;

       while ( (iGBLine < dwGBLine) &&
               (GetPattern(lpStartGB) == dwPatternGB) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }

    } 

  } // while ...

  if ( iBig5Line < dwBig5Line ) {

      while ( iBig5Line < dwBig5Line )  {

           WriteFile(hOutSrcFile,     // handle to file to write to
                     lpStartBig5,     // pointer to data to write to file
                     LINELEN,         // number of bytes to write
                     &BytesWritten,   // pointer to number of bytes written
                     NULL);           // pointer to structure needed for
                                      // overlapped I/O
           lpStartBig5 += LINELEN/sizeof(WORD);
           iBig5Line ++;
      }

  }

  if ( iGBLine < dwGBLine ) {

       while ( iGBLine < dwGBLine )  {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }
  }

  UnmapViewOfFile(lpInBig5File);
  UnmapViewOfFile(lpInGBFile);

  CloseHandle(hInBig5Map);
  CloseHandle(hInGBMap);

  CloseHandle(hInBig5File);
  CloseHandle(hInGBFile);
  CloseHandle(hOutSrcFile);

  return; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\dayi\gendtbl\gendtbl.c ===
/*************************************************
 *  gendtbl.c                                    *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

// ---------------------------------------------------------------------------
//
//  This program is used to generate Dayi IME tables from its text Code table
//
//  History:   02-13-1998,  Weibz, Created
//
//  Usage:  gendtbl <UniText File> <Phon.tbl> <Phonptr.tbl> <phoncode.tbl>
//
//
// --------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>


const DWORD dwChar2SeqTbl[0x42] = {
    //  ' '   !     "     #     $     %     &     ' - char code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x27, 0x33, 0x28, 0x29,

    //  0     1     2     3     4     5     6     7
        0x0A, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,

    //  8     9     :     ;     <     =     >     ?
        0x08, 0x09, 0x00, 0x1E, 0x00, 0x2F, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x15, 0x24, 0x22, 0x17, 0x0D, 0x18, 0x19,

    //  H     I     J     K     L     M     N     O
        0x1A, 0x12, 0x1B, 0x1C, 0x1D, 0x26, 0x25, 0x13,

    //  P     Q     R     S     T     U     V     W
        0x14, 0x0B, 0x0E, 0x16, 0x0F, 0x11, 0x23, 0x0C,

    //  X     Y     Z     [     \     ]     ^     _
        0x21, 0x10, 0x20, 0x31, 0x34, 0x32, 0x00, 0x00,

    //  `     a
        0x35, 0x00  };



const BYTE bInverseEncode[] = {
//    0    1    2    3    4    5    6    7
    0x3, 0x4, 0x5, 0x0, 0x1, 0x2, 0xA, 0xB,
//    8    9,   A    B    C    D    E    F
    0xC, 0xD, 0x6, 0x7, 0x8, 0x9, 0xF, 0xE };


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile, hDayi; 
  HANDLE   hInMap;
  LPWORD   lpInFile, lpStart;
  DWORD    dwInFileSize, BytesWritten;
  DWORD    iLine, LineLen, NumLine;
  int      i, iWord;
  WORD     uCode;
  DWORD    dwPattern;

//  WORD     *pwStored;


  if ( argc != 3 ) {
    printf("usage: gendtbl <UTextFile> <msdayi.tbl>\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  hDayi = CreateFile( argv[2],         // pointer to name of the file
                     GENERIC_WRITE,    // access (read-write) mode
                     FILE_SHARE_WRITE, // share mode
                     NULL,             // pointer to security attributes
                     CREATE_ALWAYS,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hDayi == INVALID_HANDLE_VALUE )  {
     printf("hPhon is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPWORD)MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  lpStart = lpInFile + 1;  // skip Unicode header signature 0xFEFF

  dwInFileSize = GetFileSize(hInFile, NULL) - 2;  // sub head two bytes

  LineLen = 9 * sizeof(WORD);

//
// Every Line contains XXXXTCDA
// 
//  X  stands for Sequent code
//  T  Tab,  0x0009
//  C  U Char Code
//  F  Flag, L' 'or L'*'
//  D  0x000D
//  A  0x000A
//


  NumLine = dwInFileSize / LineLen;

//  pwStored = (PWORD)LocalAlloc(LPTR, NumLine * sizeof(WORD) );
//
//  if ( pwStored == NULL ) {
//     printf("Memory Alloc Error\n");
//     return;
//  }

// ------------------------------

// the first five Bytes of Dayi.tbl should be 00, 00,00,00,00.

   dwPattern = 0x00000000;

   WriteFile(hDayi,                  // handle to file to write to
             &dwPattern,             // pointer to data to write to file
             3,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O

   uCode = 0x0000;

   WriteFile(hDayi,                  // handle to file to write to
             &uCode,                 // pointer to data to write to file
             2,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O

   iWord = 0;

   for (iLine=0; iLine < NumLine; iLine++) {
       DWORD  dwSeq;
       BOOL   fInverse;

       //Generate the pattern
       dwPattern = 0;
       for (i=0; i<4; i++) {
           dwSeq = dwChar2SeqTbl[ lpStart[i] - L' ' ]; 
           dwPattern = (dwPattern << 6)  +  dwSeq;
           
       }

       // Get the Char code 
       // Skip one 0x0009

       uCode = lpStart[5];

       fInverse = FALSE;

// we will base on the Flag of this line to determine reversion.

       if ( lpStart[6] == L'*' )
          fInverse = TRUE; 

/*       // searh if we have already stored the char.

//       for (i=0; i<iWord; i++) {
//           if ( pwStored[i] == uCode ) {
//              fInverse = TRUE;
//              break;
//           }
//       }
//
//       if ( fInverse == FALSE ) {
//          //  put this new char to the stored list.
//          pwStored[iWord] = uCode;
//          iWord ++;
//       }

*/

       if (fInverse == TRUE ) {
          WORD  wTmp;

          wTmp = bInverseEncode[ (uCode >> 12) & 0x000f ] ;
          uCode = (wTmp << 12) | (uCode & 0x0fff) ;
       }

       // write the Pattern and char code to Dayi.tbl

       WriteFile(hDayi,             // handle to file to write to
                 &dwPattern,        // pointer to data to write to file
                 3,                 // number of bytes to write
                 &BytesWritten,     // pointer to number of bytes written
                 NULL);             // pointer to structure needed for
                                    // overlapped I/O
 
       WriteFile(hDayi,             // handle to file to write to
                 &uCode,            // pointer to data to write to file
                 2,                 // number of bytes to write
                 &BytesWritten,     // pointer to number of bytes written
                 NULL);             // pointer to structure needed for
                                    // overlapped I/O

       lpStart += LineLen / sizeof(WORD); 
   } 


// the Last three Bytes of Dayi.tbl should be 0xFF, 0xFF, 0xFF.

   dwPattern = 0x00FFFFFF;

   WriteFile(hDayi,                  // handle to file to write to
             &dwPattern,             // pointer to data to write to file
             3,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O

   uCode = 0x0000;
   WriteFile(hDayi,                  // handle to file to write to
             &uCode,                 // pointer to data to write to file
             2,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O


// ------------------------------


  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);
  CloseHandle(hInFile);
  CloseHandle(hDayi);

//  LocalFree(pwStored);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\dayi\dayisrc\convdayi.c ===
/*************************************************
 *  convdayi.c                                   *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

//
//  Generate a Source Unicode table file from its msdayi.tbl file.
//
//   the MSDayi.tbl file format:  (every Line)
//       PPPC
//
//       P :  Pattern ( 3 Bytes) 
//       C:   Unicode of the char.
//
//   the destinate file format: (Every Line)
//
//       UUUUTCFDA
//      
//       U :  Unicode of Ma Key
//       T:   0x0009
//       C:   Unicode of the candiadate char.
//       F:   L' ' or L'*', L'*' means reverse the code
//
//
//  History:   Weibz, created, 03/03/1998
//


#include <stdio.h>
#include <windows.h>


const BYTE wChar2SeqTbl[0x42]={
    //  ' '   !     "     #     $     %     &     ' - char code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x27, 0x33, 0x28, 0x29,

    //  0     1     2     3     4     5     6     7
        0x0A, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,

    //  8     9     :     ;     <     =     >     ?
        0x08, 0x09, 0x00, 0x1E, 0x00, 0x2F, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x15, 0x24, 0x22, 0x17, 0x0D, 0x18, 0x19,

    //  H     I     J     K     L     M     N     O
        0x1A, 0x12, 0x1B, 0x1C, 0x1D, 0x26, 0x25, 0x13,

    //  P     Q     R     S     T     U     V     W
        0x14, 0x0B, 0x0E, 0x16, 0x0F, 0x11, 0x23, 0x0C,

    //  X     Y     Z     [     \     ]     ^     _
        0x21, 0x10, 0x20, 0x31, 0x34, 0x32, 0x00, 0x00,

    //  `     a
        0x35, 0x00  };


const BYTE bInverseEncode[] = {
//    0    1    2    3    4    5    6    7
    0x3, 0x4, 0x5, 0x0, 0x1, 0x2, 0xA, 0xB,
//    8    9,   A    B    C    D    E    F
    0xC, 0xD, 0x6, 0x7, 0x8, 0x9, 0xF, 0xE };


const BYTE bValidFirstHex[] = {
//  0  1  2  3  4  5  6  7  8  9, A  B  C  D  E  F
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1
};


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile,  hOutFile; 
  HANDLE   hInMap;
  LPBYTE   lpInFile, lpStart;
  WORD     OutLine[20], i;
  DWORD    dwInFileSize, NumberOfBytesWritten, dwPattern;
  DWORD    iLine, dwLine;

  if ( argc != 3 ) {
    printf("Usage: dayisrc File1.tbl  File2\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);
    

  hOutFile=CreateFile(  argv[2],          // pointer to name of the file
                        GENERIC_WRITE,    // access (read-write) mode
                        FILE_SHARE_WRITE, // share mode
                        NULL,             // pointer to security attributes
                        CREATE_ALWAYS,    // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  {
     printf("hOutFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  OutLine[0] = 0xFEFF;
  WriteFile(hOutFile,               // handle to file to write to
            OutLine,                // pointer to data to write to file
            2,                      // number of bytes to write
            &NumberOfBytesWritten,  // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O

  iLine = 1;

  lpStart = lpInFile + 5;  

// skip the first record, because it is 00 00 00 00 00.

  dwLine = dwInFileSize / 5; 

// skip the last line, because it is FF FF FF 00 00

  while ( iLine < (dwLine -1) ) {  
    WORD  Code1, Code2, uCode;
    DWORD dwP1, dwP2, dwP3; 
    WORD  iStart, wFlag;
    
    dwP1 = *lpStart;
    dwP2 = *(lpStart+1);
    dwP3 = *(lpStart+2);

    dwPattern = dwP1 + (dwP2 << 8) + (dwP3 << 16);
    if ( i >= dwInFileSize) break;

    Code1 =  *(lpStart+3);
    Code2 =  *(lpStart+4);

    uCode = Code1 + Code2 * 256;

    iLine++;
    lpStart += 5; 
 
    for (iStart=4; iStart>0; iStart--) {
        BYTE  ThisByte;

        ThisByte = (BYTE)(dwPattern & 0x0000003f);
        dwPattern = dwPattern >> 6;

        for (i=0; i< 0x42; i++) 
            if ( ThisByte == wChar2SeqTbl[i] ) break;

        OutLine[iStart-1] = L' ' +  i;

    }        
        
    iStart = 4;

    Code1 = uCode >> 12;

    wFlag = L' ';
    if ( !bValidFirstHex[Code1] ) {  
       Code1 = bInverseEncode[Code1];
       wFlag = L'*';
    }

    Code1 = Code1 << 12;

    uCode = Code1 | (uCode & 0x0fff);

    OutLine[iStart++] = 0x0009;  // Add Tab
    OutLine[iStart++] = uCode;   // Add char code 

    OutLine[iStart++] = wFlag;
 
    OutLine[iStart++] = 0x000D;
    OutLine[iStart++] = 0x000A;

    WriteFile(hOutFile,               // handle to file to write to
              OutLine,                // pointer to data to write to file
              iStart * sizeof(WORD),  // number of bytes to write
              &NumberOfBytesWritten,  // number of bytes written 
              NULL);                  // pointer to structure needed for 

  }

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hOutFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\dayi\sortdtbl\sortdtbl.c ===
/*************************************************
 *  sortdtbl.c                                   *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

//
//  This file is used to sort Dayi Unicode Table.
//
//   the original file contains lots of lines, every line follows below format:
//        XXXXTCFRL
//    X:   Key Code,
//    T:   Tab,  0x0009
//    C:   Unicode for this Character
//    F:   Flag: L' 'or L'*'
//    R:   0x000D
//    L:   0x000A
//
//  we will sort this file on pattern which is generated by XXXX
//


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )


const DWORD dwChar2SeqTbl[0x42] = {
    //  ' '   !     "     #     $     %     &     ' - char code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x27, 0x33, 0x28, 0x29,

    //  0     1     2     3     4     5     6     7
        0x0A, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,

    //  8     9     :     ;     <     =     >     ?
        0x08, 0x09, 0x00, 0x1E, 0x00, 0x2F, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x15, 0x24, 0x22, 0x17, 0x0D, 0x18, 0x19,

    //  H     I     J     K     L     M     N     O
        0x1A, 0x12, 0x1B, 0x1C, 0x1D, 0x26, 0x25, 0x13,

    //  P     Q     R     S     T     U     V     W
        0x14, 0x0B, 0x0E, 0x16, 0x0F, 0x11, 0x23, 0x0C,

    //  X     Y     Z     [     \     ]     ^     _
        0x21, 0x10, 0x20, 0x31, 0x34, 0x32, 0x00, 0x00,

    //  `     a
        0x35, 0x00  };


DWORD  GetPattern( WORD  *pWord )
{
  int   i, j;
  DWORD dwPat, dwSeq;

  dwPat = 0;

  for (i=0; i<4; i++) {

      dwSeq = dwChar2SeqTbl[ pWord[i] - L' '];
      dwPat = (dwPat << 6)  + dwSeq;
  }

  return dwPat; 

}


int __cdecl Mycompare(const void *elem1, const void *elem2 )
{
  WORD  *pWord1, *pWord2;
  DWORD dwPatn1, dwPatn2;

  pWord1 = (WORD *)elem1;
  pWord2 = (WORD *)elem2;

 
  dwPatn1 = GetPattern(pWord1);
  dwPatn2 = GetPattern(pWord2);

  if ( dwPatn1 > dwPatn2 )  
     return 1;
  if ( dwPatn1 < dwPatn2 )  
     return -1;

// if the pattern is the same, just sort by uCode.

  if ( *(pWord1+5)  >  *(pWord2+5) )   return 1;
  if ( *(pWord1+5)  <  *(pWord2+5) )   return -1;
 
  return 0;

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile;
  HANDLE   hInMap;
  LPBYTE   lpInFile, lpStart;
  DWORD    dwInFileSize; 

  if ( argc != 2 ) {
    printf("usage: sortdtbl UnicdeTableFile \n");
    return; 
  }


  hInFile = CreateFile(argv[1],          // pointer to name of the file
                       GENERIC_READ | GENERIC_WRITE, //access(read-write)mode
                       FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode
                       NULL,             // pointer to security attributes
                       OPEN_EXISTING,    // how to create
                       FILE_ATTRIBUTE_NORMAL,  // file attributes
                       NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);

  dwInFileSize -= 2;
    
  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READWRITE, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_WRITE, 0, 0, 0);

  printf("dwInFileSize=%d ", dwInFileSize);

  lpStart = lpInFile + 2;  // skip UNICODE signature FEFF
  
  qsort((void *)lpStart,(size_t)(dwInFileSize/LINELEN),(size_t)LINELEN,Mycompare);

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\phon\convphon\convphon.c ===
/*************************************************
 *  convphon.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/


#include <stdio.h>
#include <windows.h>

WCHAR   Seq2Key[43] = { 0,
        L'1',  L'Q', L'A', L'Z', L'2', L'W', L'S', L'X',
        L'E',  L'D', L'C', L'R', L'F', L'V', L'5', L'T',
        L'G',  L'B', L'Y', L'H', L'N', L'U', L'J', L'M',
        L'8',  L'I', L'K', L',', L'9', L'O', L'L', L'.',
        L'0',  L'P', L';', L'/', L'-', L' ', L'6', L'3',
        L'4',  L'7' };


WORD    Seq2DBCS[43] = { 0,
        0xa374, 0xa375, 0xa376, 0xa377, 0xa378, 0xa379,
        0xa37a, 0xa37b, 0xa37c, 0xa37d, 0xa37e, 0xa3a1, 
        0xa3a2, 0xa3a3, 0xa3a4, 0xa3a5, 0xa3a6, 0xa3a7, 
        0xa3a8, 0xa3a9, 0xa3aa, 0xa3b8, 0xa3b9, 0xa3ba, 
        0xa3ab, 0xa3ac, 0xa3ad, 0xa3ae, 0xa3af, 0xa3b0, 
        0xa3b1, 0xa3b2, 0xa3b3, 0xa3b4, 0xa3b5, 0xa3b6, 
        0xa3b7, 0xa3bc, 0xa3bd, 0xa3be, 0xa3bf, 0xa3bb };

// the index (position) of bo, po, mo, and fo.
// only 0 to 3 is a valid value

const char cIndexTable[] = {
//  ' '   !    "    #    $    %    &    '
     3,   -1,  -1,  -1,  -1,  -1,  -1,  -1,
//   (    )    *    +    ,    -    .    /
     -1,  -1,  -1,  -1,  2,   2,   2,   2,
//   0    1    2    3    4    5    6    7
     2,   0,   0,   3,   3,   0,   3,   3,
//   8    9    :    ;    <    =    >    ?
     2,   2,   -1,  2,   -1,  -1,  -1,  -1,
//   @    A    B    C    D    E    F    G
     -1,  0,   0,   0,   0,   0,   0,   0,
//   H    I    J    K    L    M    N    O
     0,   2,   1,   2,   2,   1,   0,   2,
//   P    Q    R    S    T    U    V    W
     2,   0,   0,   0,   0,   1,   0,   0,
//   X    Y    Z    [    \    ]    ^    _    `
     0,   0,   0,   -1,  -1,  -1,  -1,  -1,  -1
};



void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile,  hOutFile; 
  HANDLE   hInMap;
  LPBYTE   lpInFile;
  WORD     OutLine[20];
  DWORD    dwInFileSize, i, NumberOfBytesWritten;
  DWORD    iLine;

  if ( argc != 3 ) {
    printf("Usage: convphon File1  File2\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);
    

  hOutFile=CreateFile(  argv[2],          // pointer to name of the file
                        GENERIC_WRITE,    // access (read-write) mode
                        FILE_SHARE_WRITE, // share mode
                        NULL,             // pointer to security attributes
                        CREATE_ALWAYS,    // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  {
     printf("hOutFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  OutLine[0] = 0xFEFF;
  WriteFile(hOutFile,               // handle to file to write to
            OutLine,                // pointer to data to write to file
            2,                      // number of bytes to write
            &NumberOfBytesWritten,  // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O

  i = 0;  
  iLine = 1;

  while ( i < dwInFileSize ) {

    WORD  CharCode;
    BOOL  bFirstCode;
    WCHAR  LastKey;
    DWORD  iStart, iTmp;
    
    CharCode = 0;
    bFirstCode = TRUE;

    if ( i >= dwInFileSize) break; 
 

    for (iStart=0; iStart<4; iStart++) {
        BYTE  ThisByte;

        ThisByte = lpInFile[i+iStart];
        if ( (ThisByte >= '0')  &&  (ThisByte <= '9') )    
            ThisByte = ThisByte - '0';
        else
           if ( (ThisByte >= 'A') && (ThisByte <= 'F') )
              ThisByte = ThisByte - 'A' + 10;
           else
            if ( (ThisByte >= 'a') && (ThisByte <= 'f') )
              ThisByte = ThisByte - 'a' + 10;
            else
            {
             printf("Line Num %d data error ThisByte is %c\n", iLine, ThisByte);
             return;
            }
        CharCode = CharCode * 16 + ThisByte;
     
    }

    i += 4;

    while ( lpInFile[i] == 0x20 )  i++;

    iStart = 0;

    while ((lpInFile[i]!=0x0D) && (i<dwInFileSize)) {
        WORD   dbcsCode;

        if (lpInFile[i] != 0x20){//must be serial DBCS which are Phonetic
            
           if ( i+1 >= dwInFileSize )  {
              printf(" No Tail Byte, Error!\n");
              return;
           }

           dbcsCode = lpInFile[i] * 256 + lpInFile[i+1];
           i += 2;

           // try to get the Key for this Code, First search Seq2DBCS table to
           // get its sequent code, and then get this sequent code's Key.


           for (iTmp=0; iTmp<43; iTmp++ ) {

               if ( Seq2DBCS[iTmp] == dbcsCode ) {
                  OutLine[iStart] = Seq2Key[iTmp]; 
                  iStart ++;
                  break;
               }
           }
        }
        else  // it is  0x20
        {

           while ( lpInFile[i] == 0x20 )  i++;

           LastKey = OutLine[iStart-1];

           if ( (LastKey != L' ')  &&   // First Tone
                (LastKey != L'3')  &&   // Third Tone
                (LastKey != L'4')  &&   // Forth Tone
                (LastKey != L'6')  &&   // Second Tone
                (LastKey != L'7') ) {   // Fifth Tone     

             OutLine[iStart] = L' ';   // assume it is first tone
             iStart ++;
           }
               
           if ( iStart < 4 )  {

              WCHAR  tmpBuf[4];
              int    cIndex;

              for ( iTmp=0; iTmp<4; iTmp++ ) 
                  tmpBuf[iTmp] = 0x0020;
              
              for (iTmp=0; iTmp < iStart; iTmp++) {
                  cIndex = cIndexTable[ (OutLine[iTmp] - L' ') ];
                  tmpBuf[cIndex] = OutLine[iTmp];

              } 

              for (iTmp=0; iTmp < 4; iTmp++) 
              {
                  OutLine[iTmp] = tmpBuf[iTmp];
              }

           }

           iStart = 4;

           OutLine[iStart++] = 0x0009;     // Add Tab
           OutLine[iStart++] = CharCode;   // Add char code 
  
 
           if ( bFirstCode == TRUE ) {
              OutLine[iStart++] = L' ';
              bFirstCode = FALSE;
           }
           else
              OutLine[iStart++] = L'*';

           OutLine[iStart++] = 0x000D;
           OutLine[iStart++] = 0x000A;

           WriteFile(hOutFile,               // handle to file to write to
                     OutLine,                // pointer to data to write to file
                     iStart * sizeof(WORD),  // number of bytes to write
                     &NumberOfBytesWritten,  // number of bytes written 
                     NULL);                  // pointer to structure needed for 
                                             // overlapped I/O
           iStart = 0; 
        }
    }  // lpInFile[i] != 0x0D

    if ( lpInFile[i] == 0x0D ) {
       
       iLine ++;

       if ( lpInFile[i+1] == 0x0A )  
          i = i + 2;
       else  
          i++;
    }

    if ( iStart > 0 ) {

           LastKey = OutLine[iStart-1];

           if ( (LastKey != L' ')  &&   // First Tone
                (LastKey != L'3')  &&   // Third Tone
                (LastKey != L'4')  &&   // Forth Tone
                (LastKey != L'6')  &&   // Second Tone
                (LastKey != L'7') ) {   // Fifth Tone

             OutLine[iStart] = L' ';   // assume it is first tone
             iStart ++;
           }

           if ( iStart < 4 )  {

              WCHAR  tmpBuf[4];
              int    cIndex;

              for ( iTmp=0; iTmp<4; iTmp++ )
                  tmpBuf[iTmp] = 0x0020;

              for (iTmp=0; iTmp < iStart; iTmp++) {
                  cIndex = cIndexTable[ (OutLine[iTmp] - L' ') ];
                  tmpBuf[cIndex] = OutLine[iTmp];

              }

              for (iTmp=0; iTmp < 4; iTmp++)
              {
                  OutLine[iTmp] = tmpBuf[iTmp];
              }

           }

           iStart = 4;

           OutLine[iStart++] = 0x0009;     // Add Tab
           OutLine[iStart++] = CharCode;   // Add char code

           if ( bFirstCode == TRUE ) 
              OutLine[iStart++] = L' ';
           else
              OutLine[iStart++] = L'*';

           OutLine[iStart++] = 0x000D;
           OutLine[iStart++] = 0x000A;

           WriteFile(hOutFile,               // handle to file to write to
                     OutLine,                // pointer to data to write to file
                     iStart * sizeof(WORD),  // number of bytes to write
                     &NumberOfBytesWritten,  // number of bytes written
                     NULL);                  // pointer to structure needed for
                                             // overlapped I/O
           iStart = 0;

    }

  }  // while i<dwInFileSize

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hOutFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\phon\convold\convold.c ===
/*************************************************
 *  convold.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/


#include <stdio.h>
#include <windows.h>


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile,  hOutFile; 
  HANDLE   hInMap;
  LPWORD   lpInFile, lpCur;
  WORD     OutLine[20];
  DWORD    dwInFileSize, i, NumberOfBytesWritten;
  DWORD    iLine, MaxLine, MaxLen;

  if ( argc != 3 ) {
    printf("Usage: convold File1  File2\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);
    

  hOutFile=CreateFile(  argv[2],          // pointer to name of the file
                        GENERIC_WRITE,    // access (read-write) mode
                        FILE_SHARE_WRITE, // share mode
                        NULL,             // pointer to security attributes
                        CREATE_ALWAYS,    // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  {
     printf("hOutFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPWORD) MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  OutLine[0] = 0xFEFF;
  WriteFile(hOutFile,               // handle to file to write to
            OutLine,                // pointer to data to write to file
            2,                      // number of bytes to write
            &NumberOfBytesWritten,  // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                     // overlapped I/O

  lpCur = lpInFile +  1;  // skip FEFF

  i = 0;  
  iLine =1; 
  MaxLine = 1;
  MaxLen = 0;

  while ( i < (dwInFileSize / sizeof(WORD) -1)) {

    WORD   iStart;

    iStart = 0; 
    while ( *lpCur != 0x000D ) {
        OutLine[iStart++] = *lpCur;
        lpCur ++;
        i++;
    }

    if ( (OutLine[iStart-1] != L' ')  && (OutLine[iStart-1] != L'*') ) 
       OutLine[iStart++] = L' ';

    OutLine[iStart++] = 0x000D;
    OutLine[iStart++] = 0x000A;

    lpCur++;
    lpCur++;

    i++;
    i++;

    if ( MaxLen < iStart ) {
       MaxLen = iStart;
       MaxLine = iLine;
    }
    iLine ++;   

    WriteFile(hOutFile,               // handle to file to write to
              OutLine,                // pointer to data to write to file
              iStart * sizeof(WORD),  // number of bytes to write
              &NumberOfBytesWritten,  // number of bytes written
              NULL);                  // pointer to structure needed for
                                      // overlapped I/O

  }  // while i<dwInFileSize

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hOutFile);

printf("maxLen=%d, maxLine=%d\n", MaxLen, MaxLine);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\phon\gennpsrc\gennpsrc.c ===
/*************************************************
 *  gennpsrc.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  This file is used to Generate a new source Phone Table File.
//
//  it will read two files, one for Big5 and one for GB, to generate a new 
//  Phon code table file.
//
//  the two input files are sorted on the external keystroke pattern, 
//  and both are complete Unicode files, ( there is 0xFEFF  
//  in its first two bytes), 
//
//  the two input files contain lots of lines,every line follows below format:
//        XXXXTCFRL
//    X:   Key Code,
//    T:   Tab,  0x0009
//    C:   Unicode for this Character
//    F:   L' ' or L'*'
//    R:   0x000D
//    L:   0x000A
//
//  we will generate a new table source file, if the same pattern exists in both
//  Big5 file and GB file, all those lines will be appended to the new file, and//  the lines of Big5 will be written first, then GB Lines
//  
//  the new generated file must be sorted on the pattern.

//
//  Created by weibz, March 02, 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )

WCHAR   Seq2Key[43] = { 0,
        L'1',  L'Q', L'A', L'Z', L'2', L'W', L'S', L'X',
        L'E',  L'D', L'C', L'R', L'F', L'V', L'5', L'T',
        L'G',  L'B', L'Y', L'H', L'N', L'U', L'J', L'M',
        L'8',  L'I', L'K', L',', L'9', L'O', L'L', L'.',
        L'0',  L'P', L';', L'/', L'-', L' ', L'6', L'3',
        L'4',  L'7' };


DWORD  GetPattern( WORD  *pWord )
{
  int   i, j;
  WORD  wValue;
  DWORD dwPat, dwSeq;

  dwPat = 0;

  for (i=0; i<3; i++) {

      wValue = *(pWord+i);
      dwSeq = 0;

      if ( wValue != L' ' ) { 
         
         for (j=0; j<43; j++) {
             if ( wValue == Seq2Key[j] ) {
                dwSeq = j;
                break;
             }
         }
      }
      dwPat = (dwPat << 6)  + dwSeq;
  }

// handle the last character, it should be one of five tones.

  wValue = *(pWord+3);
  dwSeq = 0;
  for (j=38; j<43; j++) {
      if ( wValue == Seq2Key[j] ) {
         dwSeq = j;
         break;
      }
  }

  dwPat = (dwPat << 6) + dwSeq;

  return dwPat; 

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInBig5File,  hInGBFile, hOutSrcFile;
  HANDLE   hInBig5Map,   hInGBMap;
  LPWORD   lpInBig5File, lpInGBFile, lpStartBig5, lpStartGB;
  DWORD    dwBig5Line,   dwGBLine;
  DWORD    iBig5Line,    iGBLine, i;
  DWORD    dwInFileSize, BytesWritten;
  WORD     wOutData;
  DWORD    dwPatternBig5, dwPatternGB;

  if ( argc != 4 ) {
    printf("Usage: gennpsrc <Big5> <GB File> <New UnicdFile> \n");
    return; 
  }

  hInBig5File = CreateFile(  argv[1],          // pointer to name of the file
                             GENERIC_READ,     // access (read-write) mode
                             FILE_SHARE_READ,  // share mode
                             NULL,             // pointer to security attributes
                             OPEN_EXISTING,    // how to create
                             FILE_ATTRIBUTE_NORMAL,  // file attributes
                             NULL);    

  if ( hInBig5File == INVALID_HANDLE_VALUE )  return;

  hInGBFile = CreateFile( argv[2],          // pointer to name of the file
                          GENERIC_READ,     // access (read-write) mode
                          FILE_SHARE_READ,  // share mode
                          NULL,             // pointer to security attributes
                          OPEN_EXISTING,    // how to create
                          FILE_ATTRIBUTE_NORMAL,  // file attributes
                          NULL);

  if ( hInGBFile == INVALID_HANDLE_VALUE )  {
     printf("hInGBFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hOutSrcFile = CreateFile(argv[3],          // pointer to name of the file
                           GENERIC_WRITE,    // access (read-write) mode
                           FILE_SHARE_WRITE, // share mode
                           NULL,             // pointer to security attributes
                           CREATE_ALWAYS,    // how to create
                           FILE_ATTRIBUTE_NORMAL,  // file attributes
                           NULL);

  if ( hOutSrcFile == INVALID_HANDLE_VALUE )  {
     printf("hOutSrcFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInBig5Map = CreateFileMapping(hInBig5File,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInBig5Map ) {
    printf("hInBig5Map is NULL\n");
    return;
  } 

  hInGBMap = CreateFileMapping(hInGBFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInGBMap ) {
    printf("hInGBMap is NULL\n");
    return;
  }

  lpInBig5File = (LPWORD)MapViewOfFile(hInBig5Map, FILE_MAP_READ, 0, 0, 0);

  lpInGBFile = (LPWORD)MapViewOfFile(hInGBMap, FILE_MAP_READ, 0, 0, 0);

  lpStartBig5 = lpInBig5File + 1;  // skip Unicode header signature 0xFEFF

  lpStartGB = lpInGBFile + 1; // skip Unicode header signature 0xFEFF

  dwInFileSize = GetFileSize(hInBig5File, NULL) - 2;  // sub head two bytes

  dwBig5Line = dwInFileSize / LINELEN;

  dwInFileSize = GetFileSize(hInGBFile, NULL) - 2; 

  dwGBLine = dwInFileSize / LINELEN;

  wOutData = 0xFEFF;
  WriteFile(hOutSrcFile,            // handle to file to write to
            &wOutData,              // pointer to data to write to file
            2,                      // number of bytes to write
            &BytesWritten,          // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                    // overlapped I/O
  iBig5Line=iGBLine=0;
  while ((iBig5Line < dwBig5Line) && (iGBLine < dwGBLine)) {

    dwPatternBig5 = GetPattern(lpStartBig5);
    dwPatternGB = GetPattern(lpStartGB);

    if (dwPatternBig5 < dwPatternGB ) {
       // in this case, we just keep all lines in Big5 File which have same 
       // dwpattern to new generated file.

       // write lpStartBig5 to OutSrcFile 

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartBig5,            // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartBig5 += LINELEN/sizeof(WORD);
       iBig5Line ++;
    
       while ( (iBig5Line < dwBig5Line) && 
               (GetPattern(lpStartBig5) == dwPatternBig5) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartBig5,     // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartBig5 += LINELEN/sizeof(WORD);
            iBig5Line ++;
       }
    } 
    else  if ( dwPatternBig5 == dwPatternGB ) {
       // in this case, we will put all the lines in BIG5 and then in GB with
       // the same dwpattern to the new generated file.

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartBig5,            // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartBig5 += LINELEN/sizeof(WORD);
       iBig5Line ++;

       while ( (iBig5Line < dwBig5Line) &&
               (GetPattern(lpStartBig5) == dwPatternBig5) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartBig5,     // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartBig5 += LINELEN/sizeof(WORD);
            iBig5Line ++;
       }
              
       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartGB,              // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartGB += LINELEN/sizeof(WORD);
       iGBLine ++;

       while ( (iGBLine < dwGBLine) &&
               (GetPattern(lpStartGB) == dwPatternGB) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }

    } else {
      // in this case, we just put all the lines with same pattern in file
      // GB to the new generated file.

       WriteFile(hOutSrcFile,            // handle to file to write to
                 lpStartGB,              // pointer to data to write to file
                 LINELEN,                // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O

       lpStartGB += LINELEN/sizeof(WORD);
       iGBLine ++;

       while ( (iGBLine < dwGBLine) &&
               (GetPattern(lpStartGB) == dwPatternGB) ) {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }

    } 

  } // while ...

  if ( iBig5Line < dwBig5Line ) {

      while ( iBig5Line < dwBig5Line )  {

           WriteFile(hOutSrcFile,     // handle to file to write to
                     lpStartBig5,     // pointer to data to write to file
                     LINELEN,         // number of bytes to write
                     &BytesWritten,   // pointer to number of bytes written
                     NULL);           // pointer to structure needed for
                                      // overlapped I/O
           lpStartBig5 += LINELEN/sizeof(WORD);
           iBig5Line ++;
      }

  }

  if ( iGBLine < dwGBLine ) {

       while ( iGBLine < dwGBLine )  {

            WriteFile(hOutSrcFile,     // handle to file to write to
                      lpStartGB,       // pointer to data to write to file
                      LINELEN,         // number of bytes to write
                      &BytesWritten,   // pointer to number of bytes written
                      NULL);           // pointer to structure needed for
                                       // overlapped I/O
            lpStartGB += LINELEN/sizeof(WORD);
            iGBLine ++;
       }
  }

  UnmapViewOfFile(lpInBig5File);
  UnmapViewOfFile(lpInGBFile);

  CloseHandle(hInBig5Map);
  CloseHandle(hInGBMap);

  CloseHandle(hInBig5File);
  CloseHandle(hInGBFile);
  CloseHandle(hOutSrcFile);

  return; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\phon\genptbl\genptbl.c ===
/*************************************************
 *  genptbl.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// ---------------------------------------------------------------------------
//
//  This program is used to generate Phon IME tables from its text Code table
//
//  History:   02-09-1998,  Weibz, Created
//
//  Usage:  genptbl <UniText File> <Phon.tbl> <Phonptr.tbl> <phoncode.tbl>
//
//
// --------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>


const DWORD wChar2SeqTbl[0x42] = {
    //  ' '   !     "     #     $     %     &     ' - char code
        0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x1C, 0x25, 0x20, 0x24,

    //  0     1     2     3     4     5     6     7
        0x21, 0x01, 0x05, 0x28, 0x29, 0x0F, 0x27, 0x2A,

    //  8     9     :     ;     <     =     >     ?
        0x19, 0x1D, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x03, 0x12, 0x0B, 0x0A, 0x09, 0x0D, 0x11,

    //  H     I     J     K     L     M     N     O
        0x14, 0x1A, 0x17, 0x1B, 0x1F, 0x18, 0x15, 0x1E,

    //  P     Q     R     S     T     U     V     W
        0x22, 0x02, 0X0C, 0x07, 0x10, 0x16, 0x0E, 0x06,

    //  X     Y     Z     [     \     ]     ^     _
        0x08, 0x13, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,

    //  `     a
        0x00, 0x00 };

const BYTE bInverseEncode[] = {
//    0    1    2    3    4    5    6    7
    0x3, 0x4, 0x5, 0x0, 0x1, 0x2, 0xA, 0xB,
//    8    9,   A    B    C    D    E    F
    0xC, 0xD, 0x6, 0x7, 0x8, 0x9, 0xF, 0xE };


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile, hPhon, hPhonptr, hPhoncode; 
  HANDLE   hInMap;
  LPWORD   lpInFile, lpStart;
  DWORD    dwInFileSize, BytesWritten;
  DWORD    iLine, LineLen, NumLine;
  int      i;
  WORD     wOutData, uCode;
  DWORD    dwPattern, dwLastPattern;



  if ( argc != 5 ) {
    printf("usage: genptbl <UTextFile> <Phon.tbl> <phonptr.tbl> <phoncode.tbl>\n");
    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  hPhon = CreateFile( argv[2],          // pointer to name of the file
                     GENERIC_WRITE,    // access (read-write) mode
                     FILE_SHARE_WRITE, // share mode
                     NULL,             // pointer to security attributes
                     CREATE_ALWAYS,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hPhon == INVALID_HANDLE_VALUE )  {
     printf("hPhon is INVALID_HANDLE_VALUE\n");
     return;
  }


  hPhonptr = CreateFile(argv[3],          // pointer to name of the file
                     GENERIC_WRITE,    // access (read-write) mode
                     FILE_SHARE_WRITE, // share mode
                     NULL,             // pointer to security attributes
                     CREATE_ALWAYS,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hPhonptr == INVALID_HANDLE_VALUE )  {
     printf("hPhonptr is INVALID_HANDLE_VALUE\n");
     return;
  }


  hPhoncode = CreateFile(argv[4],          // pointer to name of the file
                      GENERIC_WRITE,    // access (read-write) mode
                      FILE_SHARE_WRITE, // share mode
                      NULL,             // pointer to security attributes
                      CREATE_ALWAYS,    // how to create
                      FILE_ATTRIBUTE_NORMAL,  // file attributes
                      NULL);

  if ( hPhoncode == INVALID_HANDLE_VALUE )  {
     printf("hPhoncode is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPWORD)MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  lpStart = lpInFile + 1;  // skip Unicode header signature 0xFEFF

  dwInFileSize = GetFileSize(hInFile, NULL) - 2;  // sub head two bytes

  LineLen = 9 * sizeof(WORD);

//
// Every Line contains XXXXTCFDA
// 
//  X  stands for Sequent code
//  T  Tab,  0x0009
//  C  U Char Code
//  F  Flag,  0x0020  or L'*'
//  D  0x000D
//  A  0x000A
//


  NumLine = dwInFileSize / LineLen;

// ------------------------------

// the first three Bytes of phon.tbl should be 0xFF, 0xFF, 0xFF.

   dwPattern = 0x00FFFFFF;

   WriteFile(hPhon,                  // handle to file to write to
             &dwPattern,             // pointer to data to write to file
             3,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O

//  and write 0x0000 to phonptr.tbl

   wOutData = 0x0000;

   
   WriteFile(hPhonptr,               // handle to file to write to
             &wOutData,              // pointer to data to write to file
             2,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O


   dwPattern = dwLastPattern = 0x00FFFFFF;

   for (iLine=0; iLine < NumLine; iLine++) {
       DWORD  dwSeq;
       BOOL   fInverse;

       //Generate the pattern
       dwPattern = 0;
       for (i=0; i<3; i++) {

           dwSeq = 0;
           if ( lpStart[i] !=  L' ') 
              dwSeq = wChar2SeqTbl[ lpStart[i] - L' ' ]; 
           dwPattern = (dwPattern << 6)  +  dwSeq;
           
       }

       // add the last key for tones

       dwSeq = wChar2SeqTbl[lpStart[3] - L' '];
       dwPattern = (dwPattern << 6)  +  dwSeq;

       // Get the Char code which will be stored in phoncode.tbl

       uCode = lpStart[5];

       fInverse = FALSE;
       if ( lpStart[6] == L'*')
          fInverse = TRUE;

       if (fInverse == TRUE ) {
          WORD  wTmp;

          wTmp = bInverseEncode[ (uCode >> 12) & 0x000f ] ;
          uCode = (wTmp << 12) | (uCode & 0x0fff) ;
       }

       // write uCode to phoncode.tbl

       WriteFile(hPhoncode,              // handle to file to write to
                 &uCode,                 // pointer to data to write to file
                 2,                      // number of bytes to write
                 &BytesWritten,          // pointer to number of bytes written
                 NULL);                  // pointer to structure needed for
                                         // overlapped I/O
              

       if ( dwPattern != dwLastPattern ) {

          // this is a different pattern, we will put this pattern to phon.tbl
          // and put the current line number (offset in phoncode.tbl in word) 
          // to file phonptr.tbl   

        
          WriteFile(hPhon,             // handle to file to write to
                    &dwPattern,        // pointer to data to write to file
                    3,                 // number of bytes to write
                    &BytesWritten,     // pointer to number of bytes written
                    NULL);             // pointer to structure needed for
                                       // overlapped I/O
 
          // write Offset to phonptr.tbl

          wOutData = (WORD)iLine;

          WriteFile(hPhonptr,          // handle to file to write to
                    &wOutData,         // pointer to data to write to file
                    2,                 // number of bytes to write
                    &BytesWritten,     // pointer to number of bytes written
                    NULL);             // pointer to structure needed for
                                       // overlapped I/O

          dwLastPattern = dwPattern;
       }                         

       lpStart += 9; 
   } 


// the Last three Bytes of phon.tbl should be 0xFF, 0xFF, 0xFF.

   dwPattern = 0x00FFFFFF;

   WriteFile(hPhon,                  // handle to file to write to
             &dwPattern,             // pointer to data to write to file
             3,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O

   wOutData = (WORD)iLine;

    
   WriteFile(hPhonptr,               // handle to file to write to
             &wOutData,              // pointer to data to write to file
             2,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O



// ------------------------------


  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hPhon);
  CloseHandle(hPhonptr);
  CloseHandle(hPhoncode);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\phon\sortptbl\sortptbl.c ===
/*************************************************
 *  sortptbl.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  This file is used to sort Phone Unicode Table.
//
//   the original file contains lots of lines, every line follows below format:
//        XXXXTCFRL
//    X:   Key Code,
//    T:   Tab,  0x0009
//    C:   Unicode for this Character
//    F:   L' ' or L'*'
//    R:   0x000D
//    L:   0x000A
//
//  we will sort this file on pattern which is generated by XXXX
//


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )

WCHAR   Seq2Key[43] = { 0,
        L'1',  L'Q', L'A', L'Z', L'2', L'W', L'S', L'X',
        L'E',  L'D', L'C', L'R', L'F', L'V', L'5', L'T',
        L'G',  L'B', L'Y', L'H', L'N', L'U', L'J', L'M',
        L'8',  L'I', L'K', L',', L'9', L'O', L'L', L'.',
        L'0',  L'P', L';', L'/', L'-', L' ', L'6', L'3',
        L'4',  L'7' };


DWORD  GetPattern( WORD  *pWord )
{
  int   i, j;
  WORD  wValue;
  DWORD dwPat, dwSeq;

  dwPat = 0;

  for (i=0; i<3; i++) {

      wValue = *(pWord+i);
      dwSeq = 0;

      if ( wValue != L' ' ) { 
         
         for (j=0; j<43; j++) {
             if ( wValue == Seq2Key[j] ) {
                dwSeq = j;
                break;
             }
         }
      }
      dwPat = (dwPat << 6)  + dwSeq;
  }

// handle the last character, it should be one of five tones.

  wValue = *(pWord+3);
  dwSeq = 0;
  for (j=38; j<43; j++) {
      if ( wValue == Seq2Key[j] ) {
         dwSeq = j;
         break;
      }
  }

  dwPat = (dwPat << 6) + dwSeq;

  return dwPat; 

}

int __cdecl Mycompare(const void *elem1, const void *elem2 )
{
  WORD  *pWord1, *pWord2;
  DWORD dwPatn1, dwPatn2;
  WORD  wCode1,  wCode2;

  pWord1 = (WORD *)elem1;
  pWord2 = (WORD *)elem2;

 
  dwPatn1 = GetPattern(pWord1);
  dwPatn2 = GetPattern(pWord2);

  if ( dwPatn1 > dwPatn2 )  
     return 1;
  if ( dwPatn1 < dwPatn2 )  
     return -1;

//  if the pattern is identical, the smaller ucode will be got first.

  wCode1 = *(pWord1 +  5);
  wCode2 = *(pWord2 +  5);

  if ( wCode1 > wCode2 )  return 1;
  if ( wCode1 < wCode2 )  return -1;
 
  return 0;

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile;
  HANDLE   hInMap;
  LPBYTE   lpInFile, lpStart;
  DWORD    dwInFileSize; 

  if ( argc != 2 ) {
    printf("usage: sortptbl UnicdeTableFile \n");
    return; 
  }


  hInFile = CreateFile(argv[1],          // pointer to name of the file
                       GENERIC_READ | GENERIC_WRITE, //access(read-write)mode
                       FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode
                       NULL,             // pointer to security attributes
                       OPEN_EXISTING,    // how to create
                       FILE_ATTRIBUTE_NORMAL,  // file attributes
                       NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);

  dwInFileSize -= 2;
    
  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READWRITE, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_WRITE, 0, 0, 0);

  printf("dwInFileSize=%d ", dwInFileSize);

  lpStart = lpInFile + 2;  // skip UNICODE signature FEFF
  
  qsort((void *)lpStart,(size_t)(dwInFileSize/LINELEN),(size_t)LINELEN,Mycompare);

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\winhk\convhk.c ===
/*************************************************
 *  winhk.c                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//
//  this program converts Table source file for HK from NTGEN format to
//  UIMETOOL format
//


#include <stdio.h>
#include <windows.h>


void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile,  hOutFile; 
  HANDLE   hInMap;
  LPWORD   lpInFile, lpCur;
  WORD     OutLine[30];
  DWORD    dwInFileSize, i, NumberOfBytesWritten;

  if ( argc != 3 ) {
    printf("Usage: convhk <NTGEN-File>  <UIMETOOL-File>\n");

    return; 
  }


  hInFile = CreateFile(  argv[1],          // pointer to name of the file
                         GENERIC_READ,     // access (read-write) mode
                         FILE_SHARE_READ,  // share mode
                         NULL,             // pointer to security attributes
                         OPEN_EXISTING,    // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);
  
  hOutFile=CreateFile(  argv[2],          // pointer to name of the file
                        GENERIC_WRITE,    // access (read-write) mode
                        FILE_SHARE_WRITE, // share mode
                        NULL,             // pointer to security attributes
                        CREATE_ALWAYS,    // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  {
     printf("hOutFile is INVALID_HANDLE_VALUE\n");
     return;
  }


  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPWORD) MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);

  OutLine[0] = 0xFEFF;
  WriteFile(hOutFile,               // handle to file to write to
            OutLine,                // pointer to data to write to file
            2,                      // number of bytes to write
            &NumberOfBytesWritten,  // pointer to number of bytes written
            NULL);                  // pointer to structure needed for
                                     // overlapped I/O

  WriteFile(hOutFile,
            L"/S A",
            8,
            &NumberOfBytesWritten,
            NULL);

  for ( i=0; i<26; i++) {
      OutLine[i] = (WORD)0xff21 + (WORD)i;
  }

  OutLine[26] = 0x000D;
  OutLine[27] = 0x000A;

  WriteFile(hOutFile,
            OutLine,
            28 * sizeof(WORD),
            &NumberOfBytesWritten,
            NULL);     

  lpCur = lpInFile +  1;  // skip FEFF

  i = 0;  

  while ( i < (dwInFileSize / sizeof(WORD) -1)) {

    WORD   iStart, *lpLineStart, ExtLen;

    iStart = 0; 

//  get a line 
    lpLineStart = lpCur; 
    while ( *lpCur != 0x000D ) {
        lpCur ++;
        i++;
    }

    ExtLen = lpCur - lpLineStart - 1;
//
//
// a line of Input file has following format:
// 
// <Unicode>?????<0D><0A>
//
//  ? stands for variable length external code
//

//  
// a line of output file has following format:
// 
// XXXXXX<09><Unicode><0D><0A>
//
// it contains 6 external code, if there is less 6 external codes, the rest
// will be fill in Blank.
//  

     for (iStart=0; iStart<ExtLen; iStart++)
     {
         WCHAR   wch;
         
         wch = lpLineStart[iStart+1];

         if (( wch <= L'z') && (wch >= L'a') ) {
            wch -= L'a' - L'A' ;
         }

         OutLine[iStart] = wch;
     }


     if (ExtLen < 6) {
        for (iStart=ExtLen; iStart<6; iStart++)
          OutLine[iStart] = L' ';
     }
 
    OutLine[6] = 0x0009;
    OutLine[7] = lpLineStart[0];
    OutLine[8] = 0x000D;
    OutLine[9] = 0x000A; 

    WriteFile(hOutFile,               // handle to file to write to
            OutLine,                // pointer to data to write to file
            10 * sizeof(WORD),  // number of bytes to write
            &NumberOfBytesWritten,  // number of bytes written
            NULL);                  // pointer to structure needed for
                                      // overlapped I/O

    lpCur += 2;
    i += 2; //skip 000D and 000A

  }  // while i<dwInFileSize

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);
  CloseHandle(hOutFile);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\phon\phonsrc\phonsrc.c ===
/*************************************************
 *  phonsrc.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

// ---------------------------------------------------------------------------
//
//  The program generates Phon Source unicode file from its table files
//
//  History:   03-24-1998,  Weibz, Created
//
//  Usage:  phonsrc <Phon.tbl> <Phonptr.tbl> <phoncode.tbl>  <Unicode File>
//
//
// --------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>


#pragma pack(1)

const DWORD wChar2SeqTbl[0x42] = {
    //  ' '   !     "     #     $     %     &     ' - char code
        0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x1C, 0x25, 0x20, 0x24,

    //  0     1     2     3     4     5     6     7
        0x21, 0x01, 0x05, 0x28, 0x29, 0x0F, 0x27, 0x2A,

    //  8     9     :     ;     <     =     >     ?
        0x19, 0x1D, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x03, 0x12, 0x0B, 0x0A, 0x09, 0x0D, 0x11,

    //  H     I     J     K     L     M     N     O
        0x14, 0x1A, 0x17, 0x1B, 0x1F, 0x18, 0x15, 0x1E,

    //  P     Q     R     S     T     U     V     W
        0x22, 0x02, 0X0C, 0x07, 0x10, 0x16, 0x0E, 0x06,

    //  X     Y     Z     [     \     ]     ^     _
        0x08, 0x13, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,

    //  `     a
        0x00, 0x00 };

const BYTE bInverseEncode[] = {
//    0    1    2    3    4    5    6    7
    0x3, 0x4, 0x5, 0x0, 0x1, 0x2, 0xA, 0xB,
//    8    9,   A    B    C    D    E    F
    0xC, 0xD, 0x6, 0x7, 0x8, 0x9, 0xF, 0xE };

const BYTE bValidFirstHex[] = {
//  0  1  2  3  4  5  6  7  8  9, A  B  C  D  E  F
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1
};

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hOutFile,   hPhon,        hPhonptr,    hPhoncode; 
  HANDLE   hPhonMap,   hPhonptrMap,  hPhoncodeMap;
  LPWORD   lpPhonptr,  lpPhoncode;
  LPBYTE   lpPhon,     lpStart;
  DWORD    dwPhonSize, BytesWritten;
  DWORD    iPattern,   NumPattern,   PatternSize, dwPattern;
  int      i,          j;
  WORD     OutLine[9], uCode;
  WORD     Offset,     OffsetStart,  OffsetEnd;


  if ( argc != 5 ) {
    printf("usage:phonsrc <Phon.tbl> <phonptr.tbl> <phoncode.tbl> <UTextFile>\n");
    return; 
  }


  hPhon = CreateFile( argv[1],         // pointer to name of the file
                     GENERIC_READ,     // access (read-write) mode
                     FILE_SHARE_READ,  // share mode
                     NULL,             // pointer to security attributes
                     OPEN_EXISTING,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hPhon == INVALID_HANDLE_VALUE )  {
     printf("hPhon is INVALID_HANDLE_VALUE\n");
     return;
  }


  hPhonptr = CreateFile(argv[2],       // pointer to name of the file
                     GENERIC_READ,     // access (read-write) mode
                     FILE_SHARE_READ,  // share mode
                     NULL,             // pointer to security attributes
                     OPEN_EXISTING,    // how to create
                     FILE_ATTRIBUTE_NORMAL,  // file attributes
                     NULL);

  if ( hPhonptr == INVALID_HANDLE_VALUE )  {
     printf("hPhonptr is INVALID_HANDLE_VALUE\n");
     return;
  }


  hPhoncode = CreateFile(argv[3],          // pointer to name of the file
                      GENERIC_READ,        // access (read-write) mode
                      FILE_SHARE_READ,     // share mode
                      NULL,                // pointer to security attributes
                      OPEN_EXISTING,       // how to create
                      FILE_ATTRIBUTE_NORMAL,  // file attributes
                      NULL);



  if ( hPhoncode == INVALID_HANDLE_VALUE )  {
     printf("hPhoncode is INVALID_HANDLE_VALUE\n");
     return;
  }


  hOutFile = CreateFile(  argv[4],          // pointer to name of the file
                         GENERIC_WRITE,     // access (read-write) mode
                         FILE_SHARE_WRITE,  // share mode
                         NULL,              // pointer to security attributes
                         CREATE_ALWAYS,     // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL);

  if ( hOutFile == INVALID_HANDLE_VALUE )  return;

  hPhonMap = CreateFileMapping(hPhon,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hPhonMap ) {
    printf("hPhonMap is NULL\n");
    return;
  } 

  hPhonptrMap = CreateFileMapping(hPhonptr,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hPhonptrMap ) {
    printf("hPhonptrMap is NULL\n");
    return;
  }

  hPhoncodeMap = CreateFileMapping(hPhoncode,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hPhoncodeMap ) {
    printf("hPhoncodeMap is NULL\n");
    return;
  }


  lpPhon = (LPBYTE)MapViewOfFile(hPhonMap, FILE_MAP_READ, 0, 0, 0);
  lpPhonptr = (LPWORD)MapViewOfFile(hPhonptrMap, FILE_MAP_READ, 0, 0, 0);
  lpPhoncode = (LPWORD)MapViewOfFile(hPhoncodeMap, FILE_MAP_READ, 0, 0, 0);


  dwPhonSize = GetFileSize(hPhon, NULL);  
  PatternSize = 3;

  NumPattern = dwPhonSize / PatternSize;

  NumPattern --;   // don't care of the last Pattern FFFFFF

//
// Every Line should be XXXXTCFDA
// 
//  X  stands for Sequent code
//  T  Tab,  0x0009
//  C  U Char Code
//  F  Flag,  0x0020  or L'*'
//  D  0x000D
//  A  0x000A
//

   for ( i=0; i<4; i++)
       OutLine[i] = 0x0020;

   OutLine[4] = 0x0009;
   OutLine[7] = 0x000D;
   OutLine[8] = 0x000A;

//  write Unicode Signature to MB Source file 

   uCode = 0xFEFF;

   
   WriteFile(hOutFile,               // handle to file to write to
             &uCode,                 // pointer to data to write to file
             2,                      // number of bytes to write
             &BytesWritten,          // pointer to number of bytes written
             NULL);                  // pointer to structure needed for
                                     // overlapped I/O


   for (iPattern=1; iPattern < NumPattern; iPattern++) {
       DWORD  dwSeq;
       WORD   wFlag,  Code1;

       //Generate the pattern
       lpStart = lpPhon + iPattern * PatternSize;
       dwPattern = *((DWORD *)lpStart);
       dwPattern = dwPattern & 0x00ffffff;

/*       if ( (lpStart[0] == 0x26) &&
            (lpStart[1] == 0x60) &&
            (lpStart[2] == 0x01) ) {
            printf("dwPattern=%x\n", dwPattern);
       }
*/

       // Fill the 4 Strokes.

       for (i=4; i>0; i--) {

           dwSeq =dwPattern & 0x0000003f; 
           if ( dwSeq == 0 )
              OutLine[i-1] = 0x0020;
           else {
 
              for (j=0; j<0x42; j++) {
                  if ( dwSeq ==  wChar2SeqTbl[j] ) { 
                      OutLine[i-1] = 0x0020 + j;
                      break;
                  }
              }

           }

           dwPattern = dwPattern >> 6;
           
       }

       // Get the Char code which is stored in phoncode.tbl

       OffsetStart = lpPhonptr[iPattern];
       OffsetEnd = lpPhonptr[iPattern+1];

       for (Offset=OffsetStart; Offset < OffsetEnd; Offset++) {
           uCode = lpPhoncode[Offset];

           Code1 = uCode >> 12;

           wFlag = L' ';
           if ( !bValidFirstHex[Code1] ) {
              Code1 = bInverseEncode[Code1];
              wFlag = L'*';
           }


           Code1 = Code1 << 12;

           uCode = Code1 | (uCode & 0x0fff);

           OutLine[5] = uCode;
           OutLine[6] = wFlag;

          // write OutLine to the MB File 

           WriteFile(hOutFile,           // handle to file to write to
                     OutLine,            // pointer to data to write to file
                     18,                 // number of bytes to write
                     &BytesWritten,      // pointer to number of bytes written
                     NULL);              // pointer to structure needed for
                                         // overlapped I/O
       }       
   } 



// ------------------------------


  UnmapViewOfFile(lpPhon);
  UnmapViewOfFile(lpPhonptr);
  UnmapViewOfFile(lpPhoncode);

  CloseHandle(hPhonMap);
  CloseHandle(hPhonptrMap);
  CloseHandle(hPhoncodeMap);

  CloseHandle(hOutFile);
  CloseHandle(hPhon);
  CloseHandle(hPhonptr);
  CloseHandle(hPhoncode);

  return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\config.c ===
/*************************************************
 *  config.c                                     *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

/**********************************************************************/
#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"

/**********************************************************************/
/* ResourceLocked()                                                   */
/**********************************************************************/
void PASCAL ResourceLocked(
    HWND        hWnd)
{
    TCHAR szErrMsg[32];

    LoadString(hInst, IDS_SHARE_VIOLATION, szErrMsg, sizeof(szErrMsg)/sizeof(TCHAR));

    MessageBeep((UINT)-1);
    MessageBox(hWnd, szErrMsg, lpImeL->szIMEName,
        MB_OK|MB_ICONHAND|MB_TASKMODAL|MB_TOPMOST);

    return;
}
/**********************************************************************/
/* ReverseConversionList()                                            */
/**********************************************************************/
void PASCAL ReverseConversionList(
    HWND   hLayoutListBox)
{
    TCHAR    szImeName[16];
    HKL FAR *lpKLMem;
    int      nLayouts, i, nIMEs;

    LoadString(hInst, IDS_NONE, szImeName, sizeof(szImeName)/sizeof(TCHAR));

    SendMessage(hLayoutListBox, LB_INSERTSTRING,
        0, (LPARAM)szImeName);

    SendMessage(hLayoutListBox, LB_SELECTSTRING,
        0, (LPARAM)szImeName);

    SendMessage(hLayoutListBox, LB_SETITEMDATA,
        0, (LPARAM)(HKL)NULL);

    nLayouts = GetKeyboardLayoutList(0, NULL);

    lpKLMem = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);
    if (!lpKLMem) {
        return;
    }

    GetKeyboardLayoutList(nLayouts, lpKLMem);

    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        HKL hKL;

        hKL = *(lpKLMem + i);

        if (LOWORD(hKL) != NATIVE_LANGUAGE) {
            // not support other language
            continue;
        }

        // NULL hIMC ???????
        if (!ImmGetConversionList(hKL, (HIMC)NULL, NULL,
            NULL, 0, GCL_REVERSECONVERSION)) {
            // this IME not support reverse conversion
            continue;
        }

        if (!ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME,
            szImeName)) {
            // this IME does not report the IME name
            continue;
        }

        nIMEs++;

        SendMessage(hLayoutListBox, LB_INSERTSTRING,
            nIMEs, (LPARAM)szImeName);

        if (hKL == lpImeL->hRevKL) {
            SendMessage(hLayoutListBox, LB_SELECTSTRING, nIMEs,
                (LPARAM)szImeName);
        }

        SendMessage(hLayoutListBox, LB_SETITEMDATA,
            nIMEs, (LPARAM)hKL);
    }

    GlobalFree((HGLOBAL)lpKLMem);

    return;
}

/**********************************************************************/
/* ImeConfigure() / UniImeConfigure()                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// configurate the IME setting
BOOL WINAPI ImeConfigure(
    HKL         hKL,            // hKL of this IME
    HWND        hAppWnd,        // the owner window
    DWORD       dwMode,         // mode of dialog
    LPVOID      lpData)         // the data depend on each mode
{
    return (TRUE);
}

/**********************************************************************/
/* ImeEscape() / UniImeEscape()                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#define IME_INPUTKEYTOSEQUENCE  0x22

// escape function of IMEs
LRESULT WINAPI ImeEscape(
    HIMC        hIMC,
    UINT        uSubFunc,
    LPVOID      lpData)
{
    LRESULT lRet;

    switch (uSubFunc) {
    case IME_ESC_QUERY_SUPPORT:
        if (!lpData) {
            return (FALSE);
        }

        switch (*(LPUINT)lpData) {
        case IME_ESC_QUERY_SUPPORT:
        case IME_ESC_MAX_KEY:
        case IME_ESC_IME_NAME:
        case IME_ESC_SYNC_HOTKEY:
        case IME_ESC_PRIVATE_HOTKEY:
            return (TRUE);
        default:
            return (FALSE);
        }
        break;
    case IME_ESC_MAX_KEY:
        return (lpImeL->nMaxKey);
    case IME_ESC_IME_NAME:
        if (!lpData) {
            return (FALSE);
        }

        *(LPMETHODNAME)lpData = *(LPMETHODNAME)lpImeL->szIMEName;

        // append a NULL terminator
        *(LPTSTR)((LPBYTE)lpData + sizeof(METHODNAME)) = '\0';
        return (TRUE);
    case IME_ESC_SYNC_HOTKEY:
        return (TRUE);
    case IME_ESC_PRIVATE_HOTKEY: {

        LPINPUTCONTEXT      lpIMC;
        lRet = FALSE;

        //
        // early return for invalid input context
        //
        if ( (lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC)) == NULL ) {
            return (FALSE);
        }

        //
        // those private hotkeys are effective only in NATIVE mode
        //
        if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_EUDC|
            IME_CMODE_NOCONVERSION|IME_CMODE_CHARCODE)) == IME_CMODE_NATIVE) {

            LPPRIVCONTEXT       lpImcP;
            LPCOMPOSITIONSTRING lpCompStr;

            if ( (lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate)) == NULL ) {
                ImmUnlockIMC(hIMC);
                return (FALSE);
            }
            
            switch (*(LPUINT)lpData) {
            case IME_ITHOTKEY_RESEND_RESULTSTR:             //  0x200
                lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                if ( lpCompStr != NULL ) {
                    if (lpCompStr->dwResultStrLen) {
                        lpImcP->fdwImeMsg |=  MSG_COMPOSITION;
                        lpImcP->dwCompChar = 0;
                        lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULT;
                        GenerateMessage(hIMC, lpIMC, lpImcP);
                        lRet = TRUE;
                    }
                    ImmUnlockIMCC(lpIMC->hCompStr);
                }          
                break;

            case IME_ITHOTKEY_PREVIOUS_COMPOSITION:          //  0x201
                lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                if ( lpCompStr == NULL ) {
                    break;
                }
                if (lpCompStr->dwResultReadStrLen) {
                    DWORD dwResultReadStrLen;
                    TCHAR szReading[16];

                    dwResultReadStrLen = lpCompStr->dwResultReadStrLen;

                    if (dwResultReadStrLen > lpImeL->nMaxKey*sizeof(WCHAR)/sizeof(TCHAR)) {
                        dwResultReadStrLen = lpImeL->nMaxKey*sizeof(WCHAR)/sizeof(TCHAR);
                    }
                    CopyMemory(szReading, (LPBYTE)lpCompStr +
                        lpCompStr->dwResultReadStrOffset,
                        dwResultReadStrLen * sizeof(TCHAR));

                    // NULL termainator
                    szReading[dwResultReadStrLen] = TEXT('\0');

                    GenerateMessage(hIMC, lpIMC, lpImcP);
                    lRet = TRUE;
                }
                ImmUnlockIMCC(lpIMC->hCompStr);
                break; 

            case IME_ITHOTKEY_UISTYLE_TOGGLE:                //  0x202
                lpImeL->fdwModeConfig ^= MODE_CONFIG_OFF_CARET_UI;

                InitImeUIData(lpImeL);

                lpImcP->fdwImeMsg |= MSG_IMN_TOGGLE_UI;

                GenerateMessage(hIMC, lpIMC, lpImcP);
                lRet = TRUE;
                break;

            default:
                break;
            }

            ImmUnlockIMCC(lpIMC->hPrivate);
            if ( ! lRet ) {
                MessageBeep((UINT)-1);
            }
        } 
        ImmUnlockIMC(hIMC);
        return (lRet);
    }

    default:
        return (FALSE);
    }

    return (lRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\compose.c ===
/*************************************************
 *  compose.c                                    *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

/**********************************************************************/
/* SearchTbl()                                                        */
/* Description:                                                       */
/*      file format can be changed in different version for           */
/*      performance consideration, ISVs should not assume its format  */
/**********************************************************************/
void PASCAL SearchTbl(          // searching the standard table files
    UINT            uTblIndex,
    LPCANDIDATELIST lpCandList,
    LPPRIVCONTEXT   lpImcP)
{
    UINT  uCode;

    uCode = (lpImcP->bSeq[0] - 1) << 12;
    uCode |= (lpImcP->bSeq[1] - 1) << 8;
    uCode |= (lpImcP->bSeq[2] - 1) << 4;
    uCode |= (lpImcP->bSeq[3] - 1);

    if (uCode <= 0x001F ||
        (uCode >= 0x007F && uCode <=0x009F))
    {
        //
        //  We want to block control code to avoid confusion.
        //
        return;
    }

    AddCodeIntoCand(lpCandList, uCode);
    return;
}

/**********************************************************************/
/* AddCodeIntoCand()                                                  */
/**********************************************************************/
void PASCAL AddCodeIntoCand(
    LPCANDIDATELIST lpCandList,
    UINT            uCode)
{
    if (lpCandList->dwCount >= MAXCAND) {
        // Grow memory here and do something,
        // if you still want to process it.
        return;
    }

    // add this string into candidate list
    *(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount]) = (WCHAR)uCode;
    // null terminator
    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount] + sizeof(WCHAR)) = '\0';

    lpCandList->dwCount++;

    if (lpCandList->dwCount >= MAXCAND) {
        return;
    }

    lpCandList->dwOffset[lpCandList->dwCount] =
        lpCandList->dwOffset[lpCandList->dwCount - 1] +
        sizeof(WCHAR) + sizeof(TCHAR);

    return;
}

/**********************************************************************/
/* CompEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CompEscapeKey(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP)
{

    if (lpImcP->fdwImeMsg & MSG_OPEN_CANDIDATE) {
        // we have candidate window, so keep composition
    } else if ((lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) ==
        (MSG_ALREADY_OPEN)) {
        // we have candidate window, so keep composition
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg|MSG_END_COMPOSITION) &
            ~(MSG_START_COMPOSITION);
    } else {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|MSG_START_COMPOSITION);
    }

    lpImcP->iImeState = CST_INIT;
    *(LPDWORD)lpImcP->bSeq = 0;

    if (lpCompStr) {
        InitCompStr(lpCompStr);
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->dwCompChar = VK_ESCAPE;
        lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
            GCS_DELTASTART);
    }

    return;
}

/**********************************************************************/
/* CompBackSpaceKey()                                                 */
/**********************************************************************/
void PASCAL CompBackSpaceKey(
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP)
{
    if (lpCompStr->dwCursorPos < sizeof(WCHAR) / sizeof(TCHAR)) {
        lpCompStr->dwCursorPos = sizeof(WCHAR) / sizeof(TCHAR);
    }

    // go back a compsoition char
    lpCompStr->dwCursorPos -= sizeof(WCHAR) / sizeof(TCHAR);

    // clean the sequence code
    lpImcP->bSeq[lpCompStr->dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))] = 0;

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = '\b';
    lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART);

    if (!lpCompStr->dwCursorPos) {
        if (lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN)) {
            ClearCand(lpIMC);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
        }

        lpImcP->iImeState = CST_INIT;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            InitCompStr(lpCompStr);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
                ~(MSG_START_COMPOSITION);
            return;
        }
    }

    // reading string is composition string for some simple IMEs
    // delta start is the same as cursor position for backspace
    lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompAttrLen =
        lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
        lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;
    // clause also back one
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD)) = lpCompStr->dwCompReadStrLen;

    return;
}


/**********************************************************************/
/* CompStrInfo()                                                      */
/**********************************************************************/
void PASCAL CompStrInfo(
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPGUIDELINE         lpGuideLine,
    WORD                wCharCode)
{

    register DWORD dwCursorPos;

    if (lpCompStr->dwCursorPos < lpCompStr->dwCompStrLen) {
        // for this kind of simple IME, previos is an error case
        for (dwCursorPos = lpCompStr->dwCursorPos;
            dwCursorPos < lpCompStr->dwCompStrLen;
            dwCursorPos += sizeof(WCHAR) / sizeof(TCHAR)) {
            lpImcP->bSeq[dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))] = 0;
        }

        lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompAttrLen =
        lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
            lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

        // tell app, there is a composition char changed
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|
            GCS_CURSORPOS|GCS_DELTASTART;
    }

    if (wCharCode == ' ') {
        // finalized char is OK
        lpImcP->dwCompChar = ' ';
        return;
    }

    if (lpCompStr->dwCursorPos < lpImeL->nMaxKey * sizeof(WCHAR) /
        sizeof(TCHAR)) {
    } else if (lpGuideLine) {
        // exceed the max input key limitation
        lpGuideLine->dwLevel = GL_LEVEL_ERROR;
        lpGuideLine->dwIndex = GL_ID_TOOMANYSTROKE;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        return;
    } else {
        MessageBeep((UINT)-1);
        return;
    }

    if (lpImeL->fdwErrMsg & NO_REV_LENGTH) {
        WORD nRevMaxKey;

        nRevMaxKey = (WORD)ImmEscape(lpImeL->hRevKL, (HIMC)NULL,
            IME_ESC_MAX_KEY, NULL);

        if (nRevMaxKey > lpImeL->nMaxKey) {
            lpImeL->nRevMaxKey = nRevMaxKey;

            SetCompLocalData(lpImeL);

            lpImcP->fdwImeMsg |= MSG_IMN_COMPOSITIONSIZE;
        } else {
            lpImeL->nRevMaxKey = lpImeL->nMaxKey;

            if (!nRevMaxKey) {
                lpImeL->hRevKL = NULL;
            }
        }

        lpImeL->fdwErrMsg &= ~(NO_REV_LENGTH);
    }

    if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION);
    } else {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
            ~(MSG_END_COMPOSITION);
    }

    if (lpImcP->iImeState == CST_INIT) {
        // clean the 4 bytes in one time
        *(LPDWORD)lpImcP->bSeq = 0;
    }

    // get the sequence code, you can treat sequence code as a kind
    // of compression - bo, po, mo, fo to 1, 2, 3, 4
    // phonetic and array table file are in sequence code format

    dwCursorPos = lpCompStr->dwCursorPos;

    lpImcP->bSeq[dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))] =
        (BYTE)lpImeL->wChar2SeqTbl[wCharCode - ' '];

    // composition/reading string - bo po mo fo, reversed internal code
    lpImcP->dwCompChar = (DWORD)lpImeL->wSeq2CompTbl[
        lpImcP->bSeq[dwCursorPos / (sizeof(WCHAR) / sizeof(TCHAR))]];

    // assign to reading string
    *((LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset +
        dwCursorPos * sizeof(TCHAR))) = (WCHAR)lpImcP->dwCompChar;

    // add one composition reading for this input key
    if (lpCompStr->dwCompReadStrLen <= dwCursorPos) {
        lpCompStr->dwCompReadStrLen += sizeof(WCHAR) / sizeof(TCHAR);
    }
    // composition string is reading string for some simple IMEs
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;

    // composition/reading attribute length is equal to reading string length
    lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompReadStrLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompStrLen;

    *((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset +
        dwCursorPos) = ATTR_TARGET_CONVERTED;

    // composition/reading clause, 1 clause only
    lpCompStr->dwCompReadClauseLen = 2 * sizeof(DWORD);
    lpCompStr->dwCompClauseLen = lpCompStr->dwCompReadClauseLen;
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD)) = lpCompStr->dwCompReadStrLen;

    // delta start from previous cursor position
    lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

    // cursor is next to the composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;

    lpImcP->iImeState = CST_INPUT;

    // tell app, there is a composition char generated
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;

    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|GCS_DELTASTART;

    return;
}

/**********************************************************************/
/* Finalize()                                                         */
/* Return vlaue                                                       */
/*      the number of candidates in the candidate list                */
/**********************************************************************/
UINT PASCAL Finalize(           // finalize Chinese word(s) by searching table
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    BOOL                fFinalized)
{
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    UINT            nCand;

    // quick key case
    if (!lpImcP->bSeq[1]) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        return (0);
    }

    if (!lpIMC->hCandInfo) {
        return (0);
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return (0);
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);
    // start from 0
    lpCandList->dwCount = 0;

    // default start from 0
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;

        // search the IME tables
    SearchTbl( 0, lpCandList, lpImcP);
    nCand = lpCandList->dwCount;

    if (!fFinalized) {

        // for quick key
        lpCandInfo->dwCount = 1;

        // open composition candidate UI window for the string(s)
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        }
    } else if (nCand == 0) {             // nothing found, error
        // move cursor back because this is wrong
        if (lpCompStr->dwCursorPos > sizeof(WCHAR) / sizeof(TCHAR)) {
            lpCompStr->dwCursorPos = lpCompStr->dwCompReadStrLen -
                sizeof(WCHAR) / sizeof(TCHAR);
        } else {
            lpCompStr->dwCursorPos = 0;
            lpImcP->iImeState = CST_INIT;
        }

        lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_COMPOSITION) &
                ~(MSG_END_COMPOSITION);
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
                ~(MSG_END_COMPOSITION);
        }

        // for quick key
        lpCandInfo->dwCount = 0;

        // close the quick key
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CLOSE_CANDIDATE);
        }

        lpImcP->fdwGcsFlag |= GCS_CURSORPOS|GCS_DELTASTART;
    } else if (nCand == 1) {      // only one choice
        SelectOneCand(
            hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);
    } else {
        lpCandInfo->dwCount = 1;

        // there are more than one strings, open composition candidate UI window
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                ~(MSG_CLOSE_CANDIDATE);
        }

        lpImcP->iImeState = CST_CHOOSE;
    }

    if (fFinalized) {
        LPGUIDELINE lpGuideLine;

        lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

        if (!lpGuideLine) {
        } else if (!nCand) {
            // nothing found, end user, you have an error now

            lpGuideLine->dwLevel = GL_LEVEL_ERROR;
            lpGuideLine->dwIndex = GL_ID_TYPINGERROR;

            lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        } else if (nCand == 1) {
        } else if (lpImeL->fwProperties1 & IMEPROP_CAND_NOBEEP_GUIDELINE) {
        } else {
            lpGuideLine->dwLevel = GL_LEVEL_WARNING;
            // multiple selection
            lpGuideLine->dwIndex = GL_ID_CHOOSECANDIDATE;

            lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        }

        if (lpGuideLine) {
            ImmUnlockIMCC(lpIMC->hGuideLine);
        }
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    return (nCand);
}

/**********************************************************************/
/* CompWord()                                                         */
/**********************************************************************/
void PASCAL CompWord(           // compose the Chinese word(s) according to
                                // input key
    WORD                wCharCode,
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPGUIDELINE         lpGuideLine,
    LPPRIVCONTEXT       lpImcP)
{
    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    // escape key
    if (wCharCode == VK_ESCAPE) {       // not good to use VK as char, but...
        CompEscapeKey(lpIMC, lpCompStr, lpImcP);
        return;
    }

    if (wCharCode == '\b') {
        CompBackSpaceKey(hIMC, lpIMC, lpCompStr, lpImcP);
        return;
    }

    if (wCharCode >= 'a' && wCharCode <= 'z') {
        wCharCode ^= 0x20;
    }

    // build up composition string info
    CompStrInfo(lpCompStr, lpImcP, lpGuideLine, wCharCode);

    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        if (lpCompStr->dwCompReadStrLen >= sizeof(WCHAR) / sizeof(TCHAR) *
            lpImeL->nMaxKey) {
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
            lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULTSTR;
        }
    } else {
        if (lpCompStr->dwCompReadStrLen < sizeof(WCHAR) / sizeof(TCHAR) *
            lpImeL->nMaxKey) {
            return;
        }

        Finalize( hIMC, lpIMC, lpCompStr, lpImcP, TRUE);
    }

    return;
}

/**********************************************************************/
/* SelectOneCand()                                                    */
/**********************************************************************/
void PASCAL SelectOneCand(
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPCANDIDATELIST     lpCandList)
{
    DWORD       dwCompStrLen;
    DWORD       dwReadClauseLen, dwReadStrLen;
    LPTSTR      lpSelectStr;
    LPGUIDELINE lpGuideLine;

    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    if (!lpImcP) {
        MessageBeep((UINT)-1);
        return;
    }

    // backup the dwCompStrLen, this value decide whether
    // we go for phrase prediction
    dwCompStrLen = lpCompStr->dwCompStrLen;
    // backup the value, this value will be destroyed in InitCompStr
    dwReadClauseLen = lpCompStr->dwCompReadClauseLen;
    dwReadStrLen = lpCompStr->dwCompReadStrLen;
    lpSelectStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwSelection]);

    InitCompStr(lpCompStr);

    // the result reading clause = compsotion reading clause
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwResultReadClauseOffset,
        (LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset,
        dwReadClauseLen * sizeof(TCHAR) + sizeof(TCHAR));
    lpCompStr->dwResultReadClauseLen = dwReadClauseLen;

    // the result reading string = compsotion reading string
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwResultReadStrOffset,
        (LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset,
        dwReadStrLen * sizeof(TCHAR) + sizeof(TCHAR));
    lpCompStr->dwResultReadStrLen = dwReadStrLen;

    // calculate result string length
    lpCompStr->dwResultStrLen = lstrlen(lpSelectStr);

    // the result string = the selected candidate;
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset, lpSelectStr,
        lpCompStr->dwResultStrLen * sizeof(TCHAR) + sizeof(TCHAR));

    lpCompStr->dwResultClauseLen = 2 * sizeof(DWORD);
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultClauseOffset +
        sizeof(DWORD)) = lpCompStr->dwResultStrLen;

    // tell application, there is a reslut string
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = 0;
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
    }

    // no candidate now, the right candidate string already be finalized
    lpCandList->dwCount = 0;

    lpImcP->iImeState = CST_INIT;
    *(LPDWORD)lpImcP->bSeq = 0;

    //if ((WORD)lpIMC->fdwSentence != IME_SMODE_PHRASEPREDICT) {
	if (!(lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT)) {
        // not in phrase prediction mode
    } else if (!dwCompStrLen) {
    } else if (lpCompStr->dwResultStrLen != sizeof(WCHAR) / sizeof(TCHAR)) {
    }

    if (!lpCandList->dwCount) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
                ~(MSG_START_COMPOSITION);
        } else {
            lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|MSG_START_COMPOSITION);
        }
    }

    if (!lpImeL->hRevKL) {
        return;
    }

    if (lpCompStr->dwResultStrLen != sizeof(WCHAR) / sizeof(TCHAR)) {
        // we only can reverse convert one DBCS character for now
        if (lpImcP->fdwImeMsg & MSG_GUIDELINE) {
            return;
        }
    }

    lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
        return;
    }

    if (lpCompStr->dwResultStrLen != sizeof(WCHAR) / sizeof(TCHAR)) {
        // we only can reverse convert one DBCS character for now
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    } else {
        TCHAR szStrBuf[4];
        UINT  uSize;

        *(LPDWORD)szStrBuf = 0;

        *(LPWSTR)szStrBuf = *(LPWSTR)((LPBYTE)lpCompStr +
            lpCompStr->dwResultStrOffset);

        uSize = ImmGetConversionList(lpImeL->hRevKL, (HIMC)NULL, szStrBuf,
            (LPCANDIDATELIST)((LPBYTE)lpGuideLine + lpGuideLine->dwPrivateOffset),
            lpGuideLine->dwPrivateSize, GCL_REVERSECONVERSION);

        if (uSize) {
            lpGuideLine->dwLevel = GL_LEVEL_INFORMATION;
            lpGuideLine->dwIndex = GL_ID_REVERSECONVERSION;

            lpImcP->fdwImeMsg |= MSG_GUIDELINE;

            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|
                    MSG_START_COMPOSITION);
            } else {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg|
                    MSG_START_COMPOSITION) & ~(MSG_END_COMPOSITION);
            }
        } else {
            lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
            lpGuideLine->dwIndex = GL_ID_UNKNOWN;
        }
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\compui.c ===
/*************************************************
 *  compui.c                                     *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

/**********************************************************************/
/* GetCompWnd                                                         */
/* Return Value :                                                     */
/*      window handle of composition                                  */
/**********************************************************************/
HWND PASCAL GetCompWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCompWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCompWnd = lpUIPrivate->hCompWnd;

    GlobalUnlock(hUIPrivate);
    return (hCompWnd);
}

/**********************************************************************/
/* GetNearCaretPosition()                                             */
/**********************************************************************/
void PASCAL GetNearCaretPosition(   // decide a near caret position according
                                    // to the caret position
    LPPOINT lpptFont,
    UINT    uEsc,
    UINT    uRot,
    LPPOINT lpptCaret,
    LPPOINT lpptNearCaret,
    BOOL    fFlags)
{
    LONG lFontSize;
    LONG xWidthUI, yHeightUI, xBorder, yBorder;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "caret position, x - %d, y - %d",
        lpptCaret->x, lpptCaret->y);
#endif
    if ((uEsc + uRot) & 0x0001) {
        lFontSize = lpptFont->x;
    } else {
        lFontSize = lpptFont->y;
    }

    if (fFlags & NEAR_CARET_CANDIDATE) {
        xWidthUI = lpImeL->xCandWi;
        yHeightUI = lpImeL->yCandHi;
        xBorder = lpImeL->cxCandBorder;
        yBorder = lpImeL->cyCandBorder;
    } else {
        xWidthUI = lpImeL->xCompWi;
        yHeightUI = lpImeL->yCompHi;
        xBorder = lpImeL->cxCompBorder;
        yBorder = lpImeL->cyCompBorder;
    }

    if (fFlags & NEAR_CARET_FIRST_TIME) {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacX;

        if (ptInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacY;

        if (ptInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    } else {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacX;

        if (ptAltInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacY;

        if (ptAltInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    }

    if (lpptNearCaret->x < sImeG.rcWorkArea.left) {
        lpptNearCaret->x = sImeG.rcWorkArea.left;
    } else if (lpptNearCaret->x + xWidthUI > sImeG.rcWorkArea.right) {
        lpptNearCaret->x = sImeG.rcWorkArea.right - xWidthUI;
    } else {
    }

    if (lpptNearCaret->y < sImeG.rcWorkArea.top) {
        lpptNearCaret->y = sImeG.rcWorkArea.top;
    } else if (lpptNearCaret->y + yHeightUI > sImeG.rcWorkArea.bottom) {
        lpptNearCaret->y = sImeG.rcWorkArea.bottom - yHeightUI;
    } else {
    }

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Near caret position, x - %d, y - %d",
        lpptNearCaret->x, lpptNearCaret->y);
#endif

    return;
}

/**********************************************************************/
/* FitInLazyOperation()                                               */
/* Return Value :                                                     */
/*      TRUE or FALSE                                                 */
/**********************************************************************/
BOOL PASCAL FitInLazyOperation( // fit in lazy operation or not
    LPPOINT lpptOrg,
    LPPOINT lpptNearCaret,      // the suggested near caret position
    LPRECT  lprcInputRect,
    UINT    uEsc)
{
    POINT ptDelta, ptTol;
    RECT  rcUIRect, rcInterRect;

    ptDelta.x = lpptOrg->x - lpptNearCaret->x;

    ptDelta.x = (ptDelta.x >= 0) ? ptDelta.x : -ptDelta.x;

    ptTol.x = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacX;

    ptTol.x = (ptTol.x >= 0) ? ptTol.x : -ptTol.x;

    if (ptDelta.x > ptTol.x) {
        return (FALSE);
    }

    ptDelta.y = lpptOrg->y - lpptNearCaret->y;

    ptDelta.y = (ptDelta.y >= 0) ? ptDelta.y : -ptDelta.y;

    ptTol.y = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacY;

    ptTol.y = (ptTol.y >= 0) ? ptTol.y : -ptTol.y;

    if (ptDelta.y > ptTol.y) {
        return (FALSE);
    }

    // build up the UI rectangle (composition window)
    rcUIRect.left = lpptOrg->x;
    rcUIRect.top = lpptOrg->y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    if (IntersectRect(&rcInterRect, &rcUIRect, lprcInputRect)) {
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* AdjustCompPosition()                                               */
/* Return Value :                                                     */
/*      the position of composition window is changed or not          */
/**********************************************************************/
BOOL PASCAL AdjustCompPosition(         // IME adjust position according to
                                        // composition form
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptOrg,             // original composition window
                                        // and final position
    LPPOINT        lpptNew)             // new expect position
{
    POINT ptNearCaret, ptOldNearCaret, ptCompWnd;
    UINT  uEsc, uRot;
    RECT  rcUIRect, rcInputRect, rcInterRect;
    POINT ptFont;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Original Position, x - %d, y - %d",
        lpptOrg->x, lpptOrg->y);
    _DebugOut(DEB_WARNING, "New Position, x - %d, y - %d",
        lpptNew->x, lpptNew->y);
#endif
    // we need to adjust according to font attribute
    if (lpIMC->lfFont.A.lfWidth > 0) {
        ptFont.x = lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfWidth < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.x = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.x = lpImeL->yCompHi;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.y = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.y = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.y = ptFont.x;
    }
#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "All positve, x - %d, y - %d",
        ptFont.x, ptFont.y);
#endif

    // if the input char is too big, we don't need to consider so much
    if (ptFont.x > lpImeL->yCompHi * 8) {
        ptFont.x = lpImeL->yCompHi * 8;
    }
    if (ptFont.y > lpImeL->yCompHi * 8) {
        ptFont.y = lpImeL->yCompHi * 8;
    }

    if (ptFont.x < sImeG.xChiCharWi) {
        ptFont.x = sImeG.xChiCharWi;
    }

    if (ptFont.y < sImeG.yChiCharHi) {
        ptFont.y = sImeG.yChiCharHi;
    }

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Not too large or too samll, x - %d, y - %d",
        ptFont.x, ptFont.y);
#endif

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);
    uRot = (UINT)((lpIMC->lfFont.A.lfOrientation + 450) / 900 % 4);

    // decide the input rectangle
    rcInputRect.left = lpptNew->x;
    rcInputRect.top = lpptNew->y;

    // build up an input rectangle from escapemment
    rcInputRect.right = rcInputRect.left + ptFont.x * ptInputEsc[uEsc].x;
    rcInputRect.bottom = rcInputRect.top + ptFont.y * ptInputEsc[uEsc].y;

    // be a normal rectangle, not a negative rectangle
    if (rcInputRect.left > rcInputRect.right) {
        LONG tmp;

        tmp = rcInputRect.left;
        rcInputRect.left = rcInputRect.right;
        rcInputRect.right = tmp;
    }

    if (rcInputRect.top > rcInputRect.bottom) {
        LONG tmp;

        tmp = rcInputRect.top;
        rcInputRect.top = rcInputRect.bottom;
        rcInputRect.bottom = tmp;
    }
#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Input Rect, top - %d, left - %d, bottom %d, right - %d",
        rcInputRect.top, rcInputRect.left, rcInputRect.bottom, rcInputRect.right);
#endif

    GetNearCaretPosition(
        &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, NEAR_CARET_FIRST_TIME);

    // 1st, use the adjust point
    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Near caret UI Rect, top - %d, left - %d, bottom %d, right - %d",
        rcUIRect.top, rcUIRect.left, rcUIRect.bottom, rcUIRect.right);
#endif

    ptCompWnd = ptOldNearCaret = ptNearCaret;

    // OK, no intersect between the near caret position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (FitInLazyOperation(
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Fit in lazy operation");
#endif
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Go to adjust point");
#endif
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy case
    GetNearCaretPosition(
            &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, 0);

    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

#ifdef IDEBUG
    _DebugOut(DEB_WARNING, "Another NearCaret UI Rect, top - %d, left - %d, bottom %d, right - %d",
        rcUIRect.top, rcUIRect.left, rcUIRect.bottom, rcUIRect.right);
#endif

    ptCompWnd = ptNearCaret;

    // OK, no intersect between the adjust position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (FitInLazyOperation(
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Fit in Another lazy operation");
#endif
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
#ifdef IDEBUG
        _DebugOut(DEB_WARNING, "Go to Another near caret point");
#endif
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy ending! :-(
    *lpptOrg = ptOldNearCaret;

    return (TRUE);
}

/**********************************************************************/
/* SetCompPosition()                                                  */
/**********************************************************************/
void PASCAL SetCompPosition(    // set the composition window position
    HWND           hCompWnd,
    LPINPUTCONTEXT lpIMC)
{
    POINT ptWnd;
    BOOL  fChange = FALSE;
    HWND  hCandWnd;


    //
    //  the client coordinate position (0, 0) of composition window
    //
    ptWnd.x = 0;
    ptWnd.y = 0;
    //
    //  convert to screen coordinates
    //
    ClientToScreen(hCompWnd, &ptWnd);
    ptWnd.x -= lpImeL->cxCompBorder;
    ptWnd.y -= lpImeL->cyCompBorder;

    if (lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION)
    {
        POINT ptNew;            // new position of UI

        ptNew = lpIMC->cfCompForm.ptCurrentPos;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        if (ptWnd.x != ptNew.x)
        {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }
        if (ptWnd.y != ptNew.y)
        {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }
        if (fChange)
        {
            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        }
    }
    else if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT)
    {
        //
        //  aplication tell us the position, we need to adjust
        //
        POINT ptNew;            // new position of UI

        ptNew = lpIMC->cfCompForm.ptCurrentPos;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        fChange = AdjustCompPosition(
            lpIMC, &ptWnd, &ptNew);
    }
    else
    {
        POINT ptNew;            // new position of UI

        ptNew.x = lpIMC->ptStatusWndPos.x + lpImeL->xStatusWi + UI_MARGIN;

        if (ptNew.x + lpImeL->xCompWi > sImeG.rcWorkArea.right)
        {
            ptNew.x = lpIMC->ptStatusWndPos.x -
                lpImeL->xCompWi - lpImeL->cxCompBorder * 2 -
                UI_MARGIN;
        }

        ptNew.y = sImeG.rcWorkArea.bottom - lpImeL->yCompHi - 2 * UI_MARGIN;

        if (ptWnd.x != ptNew.x)
        {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }

        if (ptWnd.y != ptNew.y)
        {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }

        if (fChange)
        {
            lpIMC->cfCompForm.ptCurrentPos = ptNew;

            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
        }
    }

    if (!fChange)
    {
        return;
    }

    SetWindowPos(hCompWnd,
                 NULL,
                 ptWnd.x,
                 ptWnd.y,
                 0,
                 0,
                 SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    if (lpIMC->cfCandForm[0].dwIndex == 0)
    {
        //
        // application the candidate position by itself
        //
        return;
    }


    ScreenToClient(lpIMC->hWnd, &ptWnd);

    lpIMC->cfCandForm[0].dwStyle = CFS_CANDIDATEPOS;
    lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;

    return;
}

/**********************************************************************/
/* SetCompWindow()                                                    */
/**********************************************************************/
void PASCAL SetCompWindow(              // set the position of composition window
    HWND   hCompWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hUIWnd;

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);
    if (!hUIWnd) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    SetCompPosition(
        hCompWnd, lpIMC);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* MoveDefaultCompPosition()                                          */
/**********************************************************************/
void PASCAL MoveDefaultCompPosition(    // the default comp position
                                        // need to near the caret
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hCompWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC)
    {
        return;
    }

    hCompWnd = GetCompWnd(hUIWnd);
    if (!hCompWnd)
    {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC)
    {
        return;
    }

    if (!(lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION))
    {
        SetCompPosition( hCompWnd, lpIMC);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowComp()                                                         */
/**********************************************************************/
void PASCAL ShowComp(           // Show the composition window
    HWND   hUIWnd,
    int    nShowCompCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // show or hid the UI window
    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (lpUIPrivate->nShowCompCmd == nShowCompCmd) {
        goto SwCompNoChange;
    }

    if (nShowCompCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
    }

    if (!lpUIPrivate->hCompWnd) {
        // not in show candidate window mode
/*
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        int nCurrShowState;

        lpUIPrivate->nShowCompCmd = nShowCompCmd;

        nCurrShowState = lpUIPrivate->nShowStatusCmd;
        nCurrShowState |= lpUIPrivate->nShowCandCmd;

        if (nCurrShowState == SW_HIDE) {
            // if other two are hide, the current show state is determined
            // by this composition section
            ShowWindow(lpUIPrivate->hCompWnd, lpUIPrivate->nShowCompCmd);
        } else {
            RECT rcRect;

            rcRect = lpImeL->rcCompText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(lpUIPrivate->hCompWnd, &rcRect, NULL,
                RDW_INVALIDATE);
        }
*/
    } else {
        ShowWindow(lpUIPrivate->hCompWnd, nShowCompCmd);
        lpUIPrivate->nShowCompCmd = nShowCompCmd;
    }

SwCompNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CreateCompWindow()                                                        */
/**********************************************************************/
void PASCAL CreateCompWindow(
    HWND   hUIWnd)
{
    HIMC           hIMC;
    HGLOBAL        hUIPrivate;
    LPINPUTCONTEXT lpIMC;
    LPUIPRIV       lpUIPrivate;
    LPPRIVCONTEXT  lpImcP;
    DWORD          fdwImeMsg;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate)
    {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC)
    {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)
    {
        return;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICOMPOSITIONWINDOW;

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC)
    {
        goto StartCompUnlockUIPriv;
    }

    fdwImeMsg = 0;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    if (lpImcP)
    {
        fdwImeMsg = lpImcP->fdwImeMsg;
        ImmUnlockIMCC(lpIMC->hPrivate);
    }


#if 0
    //
    //  We want to create comp window when IME starts. So the following
    //  is not good.
    //
    if (!(fdwImeMsg & MSG_ALREADY_START))
    {
        //
        //  Sometime the application call ImmNotifyIME to cancel the
        //  composition before it process WM_IME_STARTCOMPOSITION.
        //  We should avoid to process this kind of WM_IME_STARTCOMPOSITION.
        //
        goto StartCompUnlockIMC;
    }
#endif


    if (!lpUIPrivate->hCompWnd)
    {
        POINT ptNew;

        ptNew = lpIMC->cfCompForm.ptCurrentPos;

        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);

        lpUIPrivate->hCompWnd = CreateWindowEx(0,
                lpImeL->szCompClassName, NULL,
                WS_POPUP|WS_DISABLED|WS_BORDER,
                ptNew.x, ptNew.y, lpImeL->xCompWi, lpImeL->yCompHi,
                hUIWnd, (HMENU)NULL, lpInstL->hInst, NULL);

        SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);

        SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY, lpImeL->nRevMaxKey);
    }

    //
    //  try to set the position of composition UI window near the caret
    //
    SetCompPosition( lpUIPrivate->hCompWnd, lpIMC);
    ShowComp(hUIWnd, SW_SHOWNOACTIVATE);

    ImmUnlockIMC(hIMC);

StartCompUnlockUIPriv:
    GlobalUnlock(hUIPrivate);

    return;
}

#if 0
//
//  For unicode ime, we always keep the composition windows displayed
//  because we don't have a status window to show our presence.
//
/**********************************************************************/
/* EndComp()                                                          */
/**********************************************************************/
void PASCAL EndComp(
    HWND   hUIWnd)
{
    ShowComp(hUIWnd, SW_HIDE);

    return;
}
#endif

/**********************************************************************/
/* ChangeCompositionSize()                                            */
/**********************************************************************/
void PASCAL ChangeCompositionSize(
    HWND   hUIWnd)
{
    HWND            hCompWnd, hCandWnd;
    RECT            rcWnd;
    UINT            nMaxKey;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return;
    }

    GetWindowRect(hCompWnd, &rcWnd);

    if ((rcWnd.right - rcWnd.left) != lpImeL->xCompWi) {
    } else if ((rcWnd.bottom - rcWnd.top) != lpImeL->yCompHi) {
    } else {
        return;
    }

    SetWindowPos(hCompWnd, NULL,
        0, 0, lpImeL->xCompWi, lpImeL->yCompHi,
        SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);

    if (lpImeL->nRevMaxKey >= lpImeL->nMaxKey) {
        nMaxKey = lpImeL->nRevMaxKey;
    } else {
        nMaxKey = lpImeL->nMaxKey;
    }

    SetWindowLong(hCompWnd, UI_MOVE_XY, nMaxKey);

    return;
}

/**********************************************************************/
/* DestroyCompWindow()                                                */
/**********************************************************************/
void PASCAL DestroyCompWindow(          // destroy composition window
    HWND hCompWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hCompWnd,
            GetWindowLong(hCompWnd, UI_MOVE_XY),
            GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCompWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->nShowCompCmd = SW_HIDE;

    lpUIPrivate->hCompWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CompSetCursor()                                                    */
/**********************************************************************/
void PASCAL CompSetCursor(
    HWND   hCompWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

//  SetCursor(LoadCursor(NULL, IDC_SIZEALL));

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) !=
        WINDOW_NOT_DRAG) {
        return;
    }

    if (HIWORD(lParam) != WM_LBUTTONDOWN) {
        return;
    }

    // start dragging
    SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    SetCapture(hCompWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCompWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCompWnd, &rcWnd);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCompWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* CompButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CompButtonUp(       // finish drag, set comp  window to this
                                // position
    HWND   hCompWnd)
{
    LONG            lTmpCursor, lTmpOffset;
    POINT           pt;
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCompWnd, UI_MOVE_XY);

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCompWnd, UI_MOVE_OFFSET);

    pt.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCompWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);

    SetWindowLong(hCompWnd, UI_MOVE_XY, lpImeL->nRevMaxKey);
    ReleaseCapture();

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    if (pt.x < sImeG.rcWorkArea.left) {
        pt.x = sImeG.rcWorkArea.left;
    } else if (pt.x + lpImeL->xCompWi > sImeG.rcWorkArea.right) {
        pt.x = sImeG.rcWorkArea.right - lpImeL->xCompWi;
    }

    if (pt.y < sImeG.rcWorkArea.top) {
        pt.y = sImeG.rcWorkArea.top;
    } else if (pt.y + lpImeL->yCompHi > sImeG.rcWorkArea.bottom) {
        pt.y = sImeG.rcWorkArea.bottom - lpImeL->yCompHi;
    }

    lpIMC->cfCompForm.dwStyle = CFS_FORCE_POSITION;
    lpIMC->cfCompForm.ptCurrentPos.x = pt.x + lpImeL->cxCompBorder;
    lpIMC->cfCompForm.ptCurrentPos.y = pt.y + lpImeL->cyCompBorder;

    ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);

    ImmUnlockIMC(hIMC);

    // set composition window to the new poosition
    PostMessage(hCompWnd, WM_IME_NOTIFY, IMN_SETCOMPOSITIONWINDOW, 0);

    return (TRUE);
}

/**********************************************************************/
/* PaintCompWindow()                                                  */
/**********************************************************************/
void PASCAL PaintCompWindow(
    HWND   hUIWnd,
    HDC    hDC)
{
    HIMC                hIMC;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    HGDIOBJ             hOldFont;
    LOGFONT lfFont;
//  RECT                rcSunken;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);


    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    if ( hOldFont == NULL)
    {
        if (lpCompStr) {
           ImmUnlockIMCC(lpIMC->hCompStr);
        }

        ImmUnlockIMC(hIMC);
        return;
    }
/*
   // GetObject(hOldFont, sizeof(lfFont), &lfFont);
    memset (&lfFont, 0, sizeof(LOGFONT));
    lfFont.lfHeight = -11;
    lfFont.lfCharSet = NATIVE_CHARSET;
    lfFont.lfWeight = FW_NORMAL;
    lstrcpy(lfFont.lfFaceName,TEXT("MS Shell Dlg"));
    //SelectObject(hDC, CreateFontIndirect(&lfFont));
*/
    SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));

    // light gray background for normal case
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    if (!lpCompStr) {
        goto UpdCompWndShowGuideLine;
    } else if (!lpCompStr->dwCompStrLen) {
        LPGUIDELINE lpGuideLine;

UpdCompWndShowGuideLine:
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        if (lpGuideLine) {
            BOOL            fReverseConversion;
            LPCANDIDATELIST lpCandList;
            LPTSTR          lpStr;
            UINT            uStrLen;

            fReverseConversion = FALSE;

            if (lpGuideLine->dwLevel != GL_LEVEL_INFORMATION) {
                goto UpdCompWndUnlockGuideLine;
            } else if (lpGuideLine->dwIndex != GL_ID_REVERSECONVERSION) {
                goto UpdCompWndUnlockGuideLine;
            } else {
            }

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpGuideLine +
                lpGuideLine->dwPrivateOffset);

            if (!lpCandList) {
                goto UpdCompWndUnlockGuideLine;
            } else if (!lpCandList->dwCount) {
                goto UpdCompWndUnlockGuideLine;
            } else {
                fReverseConversion = TRUE;
            }

            // green text for information
            SetTextColor(hDC, RGB(0x00, 0x80, 0x00));

            lpStr = (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]);

            uStrLen = lstrlen(lpStr);

            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                ETO_OPAQUE, &lpImeL->rcCompText,
                lpStr, uStrLen, iDx);

UpdCompWndUnlockGuideLine:
            ImmUnlockIMCC(lpIMC->hGuideLine);

            if (!fReverseConversion) {
                goto UpdCompWndNoString;
            }
        } else {
UpdCompWndNoString:
            // no any information
            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                ETO_OPAQUE, &lpImeL->rcCompText,
                (LPTSTR)NULL, 0, NULL);
        }
    } else {
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset),
            (UINT)lpCompStr->dwCompStrLen, iDx);

        if (lpCompStr->dwCompStrLen <= lpCompStr->dwCursorPos) {
            goto UpdCompWndUnselectObj;
        }

        // there is error part
        // red text for error
        SetTextColor(hDC, RGB(0xFF, 0x00, 0x00));
        // dark gray background for error
        SetBkColor(hDC, RGB(0x80, 0x80, 0x80));

        ExtTextOut(hDC, lpImeL->rcCompText.left +
            lpCompStr->dwCursorPos * sImeG.xChiCharWi /
            (sizeof(WCHAR) / sizeof(TCHAR)),
            lpImeL->rcCompText.top,
            ETO_OPAQUE, NULL,
            (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset +
            lpCompStr->dwCursorPos * sizeof(TCHAR)),
            (UINT)(lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos), iDx);
    }

UpdCompWndUnselectObj:
    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    if (lpCompStr) {
        ImmUnlockIMCC(lpIMC->hCompStr);
    }

    ImmUnlockIMC(hIMC);

#if 0
    rcSunken = lpImeL->rcCompText;

    rcSunken.left -= lpImeL->cxCompBorder;
    rcSunken.top -= lpImeL->cyCompBorder;
    rcSunken.right += lpImeL->cxCompBorder;
    rcSunken.bottom += lpImeL->cyCompBorder;

    DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);
#endif

    return;
}

/**********************************************************************/
/* CompWndProc() / UniCompWndProc()                                   */
/**********************************************************************/
// composition window proc
LRESULT CALLBACK CompWndProc(
    HWND        hCompWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyCompWindow(hCompWnd);
        break;
    case WM_SETCURSOR:
        CompSetCursor(hCompWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hCompWnd,
                GetWindowLong(hCompWnd, UI_MOVE_XY),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hCompWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!CompButtonUp(
            hCompWnd)) {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam != IMN_SETCOMPOSITIONWINDOW) {
/*
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
*/
        } else {
            SetCompWindow(
                hCompWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCompWnd, &ps);
            PaintCompWindow(
                GetWindow(hCompWnd, GW_OWNER), hDC);
            EndPaint(hCompWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
    }
    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\dic.c ===
/*************************************************
 *  dic.c                                        *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <winerror.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"

/**********************************************************************/
/* LoadTable()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL LoadTable(          // check the table files of IME, include user
                                // defined dictionary
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        return (TRUE);
    }

    lpInstL->fdwTblLoad = TBL_LOADED;

    return (TRUE);
}

/**********************************************************************/
/* FreeTable()                                                        */
/**********************************************************************/
void PASCAL FreeTable(
    LPINSTDATAL lpInstL)
{

    lpInstL->fdwTblLoad = TBL_NOTLOADED;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\ddis.c ===
/*************************************************
 *  ddis.c                                       *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"

/**********************************************************************/
/* ImeInquire() / UniImeInquire()                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// initialized data structure of IME
BOOL WINAPI ImeInquire(
    LPIMEINFO   lpImeInfo,      // IME specific data report to IMM
    LPTSTR      lpszWndCls,     // the class name of UI
    DWORD       dwSystemInfoFlags)
{
    if (!lpImeInfo) {
        return (FALSE);
    }

    lpImeInfo->dwPrivateDataSize = sizeof(PRIVCONTEXT);

    lpImeInfo->fdwProperty = IME_PROP_KBD_CHAR_FIRST|
        IME_PROP_UNICODE |
        IME_PROP_CANDLIST_START_FROM_1|
        IME_PROP_NEED_ALTKEY|IME_PROP_IGNORE_UPKEYS;
    lpImeInfo->fdwConversionCaps = IME_CMODE_NATIVE | IME_CMODE_NOCONVERSION;
        lpImeInfo->fdwSentenceCaps = IME_SMODE_PHRASEPREDICT;
    // composition string is the reading string for simple IME
    lpImeInfo->fdwSCSCaps = SCS_CAP_COMPSTR|SCS_CAP_MAKEREAD;
    // IME will have different distance base multiple of 900 escapement
    lpImeInfo->fdwUICaps = UI_CAP_ROT90|UI_CAP_SOFTKBD;
    // IME want to decide conversion mode on ImeSelect
    lpImeInfo->fdwSelectCaps = 0;

    lstrcpy(lpszWndCls, lpImeL->szUIClassName);

    return (TRUE);
}

/**********************************************************************/
/* ImeDestroy() / UniImeDestroy                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// this dll is unloaded
BOOL WINAPI ImeDestroy(
    UINT        uReserved)
{
    if (uReserved) {
        return (FALSE);
    }

    // free the IME table or data base
    FreeTable(lpInstL);

    return (TRUE);
}

/**********************************************************************/
/* InitCompStr()                                                      */
/**********************************************************************/
void PASCAL InitCompStr(                // init setting for composing string
    LPCOMPOSITIONSTRING lpCompStr)
{
    if (!lpCompStr) {
        return;
    }

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadStrLen = 0;

    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompStrLen = 0;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    return;
}

/**********************************************************************/
/* ClearCompStr()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#define NMAXKEY 8
BOOL PASCAL ClearCompStr(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC               hMem;
    LPCOMPOSITIONSTRING lpCompStr;
    DWORD               dwSize;
    LPBYTE              lpbAttr;
    UINT                i;
    LPDWORD             lpdwClause;
    LPWSTR              lpwStr;

    if (!lpIMC) {
        return (FALSE);
    }

    dwSize =
        // header length
        sizeof(COMPOSITIONSTRING) +
        // composition reading attribute plus NULL terminator
        NMAXKEY * sizeof(WCHAR) / sizeof(TCHAR) + sizeof(DWORD) +
        // composition reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // composition reading string plus NULL terminator
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD) +
        // result reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result reading string plus NULL terminateor
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD) +
        // result clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result string plus NULL terminateor
        MAXSTRLEN * sizeof(WCHAR) + sizeof(DWORD);

    if (!lpIMC->hCompStr) {
        // it maybe free by other IME, init it
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCompStr, dwSize)) {
        lpIMC->hCompStr = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    lpCompStr->dwSize = dwSize;

     // 1. composition (reading) string - simple IME
     // 2. result reading string
     // 3. result string

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadAttrOffset = sizeof(COMPOSITIONSTRING);

    lpbAttr = (LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset;

    for (i = 0; i < NMAXKEY * sizeof(WCHAR) / sizeof(TCHAR); i++) {
        // for simple IMEs, we have no way to reconvert it
        *lpbAttr++ = ATTR_TARGET_CONVERTED;
    }

    *(LPDWORD)lpbAttr = 0;

    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadClauseOffset = lpCompStr->dwCompReadAttrOffset +
        NMAXKEY * sizeof(WCHAR) / sizeof(TCHAR) + sizeof(DWORD);

    lpdwClause = (LPDWORD)((LPBYTE)lpCompStr +
        lpCompStr->dwCompReadClauseOffset);
    // clause start from 0
    *lpdwClause++ = 0;
    // clause length is 0
    *lpdwClause = 0;

    lpCompStr->dwCompReadStrLen = 0;
    lpCompStr->dwCompReadStrOffset = lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // clean up the composition reading string
    lpwStr = (LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset);

    for (i = 0; i < NMAXKEY; i++) {
        *lpwStr++ = 0;
    }

    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset +
        NMAXKEY * sizeof(WCHAR)) = 0;

    // composition string is the same with composition reading string
    // for simple IMEs
    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompAttrOffset = lpCompStr->dwCompReadAttrOffset;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompClauseOffset = lpCompStr->dwCompReadClauseOffset;
    lpCompStr->dwCompStrLen = 0;
    lpCompStr->dwCompStrOffset = lpCompStr->dwCompReadStrOffset;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadClauseOffset = lpCompStr->dwCompStrOffset +
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD);

    lpdwClause = (LPDWORD)((LPBYTE)lpCompStr +
        lpCompStr->dwResultReadClauseOffset);
    // clause start from 0
    *lpdwClause++ = 0;
    // clause length is 0
    *lpdwClause = 0;

    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultReadStrOffset = lpCompStr->dwResultReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // clean up the result reading string
    lpwStr = (LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultReadStrOffset);

    for (i = 0; i < NMAXKEY; i++) {
        *lpwStr++ = 0;
    }

    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultReadStrOffset +
        NMAXKEY * sizeof(WCHAR)) = 0;

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultClauseOffset = lpCompStr->dwResultReadStrOffset +
        NMAXKEY * sizeof(WCHAR) + sizeof(DWORD);

    lpdwClause = (LPDWORD)((LPBYTE)lpCompStr +
        lpCompStr->dwResultClauseOffset);
    // clause start from 0
    *lpdwClause++ = 0;
    // clause length is 0
    *lpdwClause = 0;

    lpCompStr->dwResultStrOffset = 0;
    lpCompStr->dwResultStrOffset = lpCompStr->dwResultClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // clean up the result string
    lpwStr = (LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset);

    for (i = 0; i < NMAXKEY; i++) {
        *lpwStr++ = 0;
    }

    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset +
        NMAXKEY * sizeof(WCHAR)) = 0;

    ImmUnlockIMCC(lpIMC->hCompStr);
    return (TRUE);
}

/**********************************************************************/
/* ClearCand()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCand(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC           hMem;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND) +
        // string plus NULL terminator
        (sizeof(WCHAR) + sizeof(TCHAR)) * MAXCAND;

    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        // it maybe free by other IME, init it
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCandInfo, dwSize)) {
        lpIMC->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        return (FALSE);
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND - 1);

    ImmUnlockIMCC(lpIMC->hCandInfo);
    return (TRUE);
}

/**********************************************************************/
/* InitContext()                                                      */
/**********************************************************************/
void PASCAL InitContext(
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    if (lpIMC->fdwInit & INIT_STATUSWNDPOS) {
    } else if (!lpIMC->hWnd) {
    } else if (lpImcP->fdwInit & INIT_STATUSWNDPOS) {
    } else {
        POINT ptWnd;

        ptWnd.x = 0;
        ptWnd.y = 0;
        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (ptWnd.x > sImeG.rcWorkArea.right / 3) {
            ptWnd.x = sImeG.rcWorkArea.right / 3;
        }

        if (ptWnd.x < sImeG.rcWorkArea.left) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.left;
        } else if (ptWnd.x + lpImeL->xStatusWi > sImeG.rcWorkArea.right) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.right -
                lpImeL->xStatusWi;
        } else {
            lpIMC->ptStatusWndPos.x = ptWnd.x;
        }

        lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.bottom -
            lpImeL->yStatusHi - 2 * UI_MARGIN;

        lpImcP->fdwInit |= INIT_STATUSWNDPOS;
    }

    if (!(lpIMC->fdwInit & INIT_COMPFORM)) {
        lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
    }

    if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
    } else if (!lpIMC->hWnd) {
    } else if (lpImcP->fdwInit & INIT_COMPFORM) {
    } else {
            lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x +
                lpImeL->xStatusWi + UI_MARGIN;

            if (lpIMC->cfCompForm.ptCurrentPos.x + lpImeL->xCompWi >
                sImeG.rcWorkArea.right) {
                lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x -
                    lpImeL->xCompWi - lpImeL->cxCompBorder * 2 -
                    UI_MARGIN;
            }

        lpIMC->cfCompForm.ptCurrentPos.y = sImeG.rcWorkArea.bottom -
            lpImeL->yCompHi - 2 * UI_MARGIN;

        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);

        lpImcP->fdwInit |= INIT_COMPFORM;
    }

    return;
}

/**********************************************************************/
/* Select()                                                           */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL Select(
    LPINPUTCONTEXT lpIMC,
    BOOL           fSelect)
{
    LPPRIVCONTEXT  lpImcP;

    if (fSelect) {      // init "every" fields of hPrivate, please!!!
        if (!ClearCompStr(
                lpIMC)) {
            return (FALSE);
        }

        if (!ClearCand(lpIMC)) {
            return (FALSE);
        }
    }

    if (lpIMC->cfCandForm[0].dwIndex != 0) {
        lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;
    }

    if (!lpIMC->hPrivate) {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return (FALSE);
    }

    if (fSelect) {      // init "every" fields of hPrivate, please!!!
        lpImcP->iImeState = CST_INIT;           // init the IME state machine
        lpImcP->fdwImeMsg = 0;                  // no message be generated now
        lpImcP->dwCompChar = 0;
        lpImcP->fdwGcsFlag = 0;
        lpImcP->fdwInit = 0;

        *(LPDWORD)lpImcP->bSeq = 0;

        lpIMC->fOpen = TRUE;

        if (!(lpIMC->fdwInit & INIT_CONVERSION)) {
            lpIMC->fdwConversion = (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) |
                IME_CMODE_NATIVE;
            lpIMC->fdwInit |= INIT_CONVERSION;
        }

        if (lpIMC->fdwInit & INIT_SENTENCE) {
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) {
            *(LPWORD)&lpIMC->fdwSentence |= IME_SMODE_PHRASEPREDICT;
        } else {
        }

        if (!(lpIMC->fdwInit & INIT_LOGFONT)) {
            HDC hDC;
            HGDIOBJ hSysFont;

            hDC = GetDC(NULL);
            hSysFont = GetCurrentObject(hDC, OBJ_FONT);
            GetObject(hSysFont, sizeof(LOGFONT), &lpIMC->lfFont.A);
            ReleaseDC(NULL, hDC);

            lpIMC->fdwInit |= INIT_LOGFONT;
        }

        // if this IME is run under Chicago Simplified Chinese version
        lpIMC->lfFont.A.lfCharSet = NATIVE_CHARSET;

        InitContext(
            lpIMC, lpImcP);
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

    return (TRUE);
}

/**********************************************************************/
/* ImeSelect() / UniImeSelect()                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSelect(
    HIMC   hIMC,
    BOOL   fSelect)
{
    LPINPUTCONTEXT lpIMC;
    BOOL           fRet;

    if (!hIMC) {
        return (TRUE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    // to load/free IME table
    if (fSelect) {
        if (!lpInstL->cRefCount++) {
            LoadTable(lpInstL, lpImeL);
        }
    } else {
        if (!--lpInstL->cRefCount) {
            FreeTable(lpInstL);
        }
    }

    fRet = Select(
        lpIMC, fSelect);

    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* ImeSetActiveContext() / UniImeSetActiveContext()                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetActiveContext(
    HIMC        hIMC,
    BOOL        fOn)
{
    if (!fOn) {
    } else if (!hIMC) {
    } else {
        LPINPUTCONTEXT lpIMC;
        LPPRIVCONTEXT  lpImcP;

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            goto SetActSyncDic;
        }

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
            goto SetActUnlockIMC;
        }

        InitContext(
            lpIMC, lpImcP);

        ImmUnlockIMCC(lpIMC->hPrivate);
SetActUnlockIMC:
        ImmUnlockIMC(hIMC);

SetActSyncDic:
        ;       // NULL statement for goto
    }

    return (TRUE);
}

/**********************************************************************/
/* LoadTable()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL LoadTable(          // check the table files of IME, include user
                                // defined dictionary
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
    if (lpInstL->fdwTblLoad == TBL_LOADED) {
        return (TRUE);
    }

    lpInstL->fdwTblLoad = TBL_LOADED;

    return (TRUE);
}

/**********************************************************************/
/* FreeTable()                                                        */
/**********************************************************************/
void PASCAL FreeTable(
    LPINSTDATAL lpInstL)
{

    lpInstL->fdwTblLoad = TBL_NOTLOADED;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\data.c ===
/*************************************************
 *  data.c                                       *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <regstr.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

#pragma data_seg("INSTDATA")
HINSTANCE   hInst = NULL;
LPIMEL      lpImeL = NULL;      // per instance pointer to &sImeL
INSTDATAL   sInstL = {0};
LPINSTDATAL lpInstL = NULL;
#pragma data_seg()

IMEG       sImeG;
IMEL       sImeL;

int   iDx[3 * CANDPERPAGE];

const TCHAR szDigit[] = TEXT("01234567890");

// convert char to upper case
const BYTE bUpper[] = {
// 0x20 - 0x27
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
// 0x28 - 0x2F
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
// 0x30 - 0x37
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
// 0x38 - 0x3F
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
// 0x40 - 0x47
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
// 0x48 - 0x4F
    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
// 0x50 - 0x57
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
// 0x58 - 0x5F
    0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
//   `    a    b    c    d    e    f    g 
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   h    i    j    k    l    m    n    o
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   p    q    r    s    t    u    v    w
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   x    y    z    {    |    }    ~
    'X', 'Y', 'Z', '{', '|', '}', '~'
};

const WORD fMask[] = {          // offset of bitfield
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000
};

const TCHAR szRegNearCaret[] = TEXT("Control Panel\\Input Method");
const TCHAR szPara[] = TEXT("Parallel Distance");
const TCHAR szPerp[] = TEXT("Perpendicular Distance");
const TCHAR szParaTol[] = TEXT("Parallel Tolerance");
const TCHAR szPerpTol[] = TEXT("Perpendicular Tolerance");

//  0
//                                   |
//        Parallel Dist should on x, Penpendicular Dist should on y
//        LofFontHi also need to be considered as the distance
//               *-----------+
// 1 * LogFontHi |           |
//               +-----------+
//               1 * LogFontWi

//  900                                 1 * LogFontWi
//                                      +------------+
//                     -1 * LogFontHi   |            |
//                                      *------------+
//        Parallel Dist should on y, Penpendicular Dist should on x
//        LofFontHi also need be considered as distance
//                                   -

//  1800
//                                   |
//        Parallel Dist should on (- x), Penpendicular Dist should on y
//        LofFontHi do not need be considered as distance
//                                              *------------+
//                                1 * LogFontHi |            |
//                                              +------------+
//                                               1 * LogFontWi

//  2700
//                                   _
//        Parallel Dist should on (- y), Penpendicular Dist should on (- x)
//        LofFontHi also need to be considered as the distance
//                   +------------*
//     1 * LogFontHi |            |
//                   +------------+
//                   -1 * LogFontWi

// decide UI offset base on escapement
const NEARCARET ncUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        1,        1,      0,      0,      1},       // 0
    { 1,        0,        0,      1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,      1},       // 1800
    {-1,        0,        0,     -1,     -1,      0}        // 2700
};


// decide input rectangle base on escapement
const POINT ptInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,            1},                                  // 0
    {1,           -1},                                  // 900
    {1,            1},                                  // 1800
    {-1,           1}                                   // 2700
};

// decide another UI offset base on escapement
const NEARCARET ncAltUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        0,        1,      0,      0,     -1},       // 0
    { 0,        0,        0,     -1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,     -1},       // 1800
    { 0,        0,        0,      1,     -1,      0}        // 2700
};


// decide another input rectangle base on escapement
const POINT ptAltInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,           -1},                                  // 0
    {-1,          -1},                                  // 900
    {1,           -1},                                  // 1800
    {1,            1}                                   // 2700
};



const TCHAR szRegRevKL[] = TEXT("Reverse Layout");
const TCHAR szRegUserDic[] = TEXT("User Dictionary");

// per user setting for
const TCHAR szRegAppUser[] = REGSTR_PATH_SETUP;
const TCHAR szRegModeConfig[] = TEXT("Mode Configuration");


// all shift keys are not for typing reading characters
const BYTE bChar2VirtKey[] = {
//   ' ' !    "    #    $    %    &    '
     0,  0,   0,   0,   0,   0,   0, VK_OEM_QUOTE,
//   (    )    *    +    ,             -             .              /
     0,   0,   0,   0, VK_OEM_COMMA, VK_OEM_MINUS, VK_OEM_PERIOD, VK_OEM_SLASH,
//   0    1    2    3    4    5    6    7
    '0', '1', '2', '3', '4', '5', '6', '7',
//   8    9    :    ;              <    =            >   ?
    '8', '9',  0, VK_OEM_SEMICLN,  0, VK_OEM_EQUAL,  0,  0,
//   @    A    B    C    D    E    F    G
     0,  'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   H    I    J    K    L    M    N    O
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   P    Q    R    S    T    U    V    W
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   X    Y    Z     [                \              ]               ^   _
    'X', 'Y', 'Z', VK_OEM_LBRACKET, VK_OEM_BSLASH, VK_OEM_RBRACKET,  0,  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\convlist.c ===
/*************************************************
 *  convlist.c                                   *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

/**********************************************************************/
/* Conversion()                                                       */
/**********************************************************************/
DWORD PASCAL Conversion(
    LPCTSTR         lpszReading,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    UINT        uMaxCand;
    DWORD       dwSize =        // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAXCAND +
        // string plus NULL terminator
        (sizeof(WCHAR) + sizeof(TCHAR)) * MAXCAND;
    PRIVCONTEXT ImcP;

    if (!dwBufLen) {
        return (dwSize);
    }

    uMaxCand = dwBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) + sizeof(WCHAR) + sizeof(TCHAR);
    if (!uMaxCand) {
        // can not even put one string
        return (0);
    }

    lpCandList->dwSize = dwSize;
    lpCandList->dwStyle = IME_CAND_READ;    // candidate having same reading
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageStart = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);

    SearchTbl( 0, lpCandList, &ImcP);

    return (dwSize);
}

/**********************************************************************/
/* SearchOffset()                                                     */
/* Return Value :                                                     */
/*      the offset in table file which include this uOffset           */
/**********************************************************************/
UINT PASCAL SearchOffset(
    LPBYTE lpTbl,
    UINT   uTblSize,
    UINT   uOffset)
{
    int    iLo, iMid, iHi;
    LPWORD lpwPtr;

    iLo = 0;
    iHi = uTblSize / sizeof(WORD);
    iMid = (iLo + iHi) / 2;

    // binary search
    for (; iLo <= iHi; ) {
        lpwPtr = (LPWORD)lpTbl + iMid;

        if (uOffset > *lpwPtr) {
            iLo = iMid + 1;
        } else if (uOffset < *lpwPtr) {
            iHi = iMid - 1;
        } else {
            break;
        }

        iMid = (iLo + iHi) / 2;
    }

    if (iMid > 0) {
        iLo = iMid - 1;
    } else {
        iLo = 0;
    }

    iHi = uTblSize / sizeof(WORD);

    lpwPtr = (LPWORD)lpTbl + iLo;

    for (; iLo < iHi; iLo++, lpwPtr++) {
        if (*lpwPtr > uOffset) {
            return (iLo - 1);
        }
    }

    return (0);
}

/**********************************************************************/
/* ReverseConversion()                                                */
/**********************************************************************/

DWORD PASCAL ReverseConversion(
    UINT            uCode,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    UINT   uMaxCand;
    DWORD  dwSize =         // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP +
        // string plus NULL terminator
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR));

    UINT   uTmpCode;
    int    i;

    if (!dwBufLen) {
        return (dwSize);
    }

    uMaxCand = dwBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) +
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR));
    if (uMaxCand == 0) {
        // can not put one string
        return (0);
    }

    lpCandList->dwSize = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * uMaxCand +
        (sizeof(WCHAR) * lpImeL->nMaxKey + sizeof(TCHAR));
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);
    uTmpCode = uCode;

    for (i = lpImeL->nMaxKey - 1; i >= 0; i--) {
        UINT uCompChar;

        uCompChar = lpImeL->wSeq2CompTbl[(uTmpCode & 0xF) + 1];

        *(LPWSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
            lpCandList->dwCount] + sizeof(WCHAR) * i) = (WCHAR)uCompChar;

        uTmpCode >>= 4;
    }

    // null terminator
    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount] + sizeof(WCHAR) * lpImeL->nMaxKey) = '\0';

    // string count ++
    lpCandList->dwCount++;

    return (dwSize);
}

/**********************************************************************/
/* ImeConversionList() / UniImeConversionList()                       */
/**********************************************************************/
DWORD WINAPI ImeConversionList(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    UINT            uFlag)
{
    UINT uCode;

    if (!dwBufLen) {
    } else if (!lpszSrc) {
        return (0);
    } else if (!*lpszSrc) {
        return (0);
    } else if (!lpCandList) {
        return (0);
    } else if (dwBufLen <= sizeof(CANDIDATELIST)) {
        // buffer size can not even put the header information
        return (0);
    } else {
    }

    switch (uFlag) {
    case GCL_CONVERSION:
        return Conversion(
            lpszSrc, lpCandList, dwBufLen);
        break;
    case GCL_REVERSECONVERSION:
        if (!dwBufLen) {
            return ReverseConversion(
                0, lpCandList, dwBufLen);
        }

        // only support one DBCS char reverse conversion
        if (*(LPTSTR)((LPBYTE)lpszSrc + sizeof(WORD)) != '\0') {
            return (0);
        }

        uCode = *(LPUNAWORD)lpszSrc;

        return ReverseConversion(
            uCode, lpCandList, dwBufLen);
        break;
    case GCL_REVERSE_LENGTH:
        return sizeof(WCHAR);
        break;
    default:
        return (0);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\imeattr.h ===
/*************************************************
 *  imeattr.h                                    *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#if !defined(ROMANIME)
// the mode configuration for an IME
#define MODE_CONFIG_QUICK_KEY           0x0001
#define MODE_CONFIG_PREDICT             0x0004

#endif

#define MODE_CONFIG_OFF_CARET_UI        0x0008

#if defined(PHON)
// the different layout for Phonetic reading
#define READ_LAYOUT_DEFAULT             0
#define READ_LAYOUT_ETEN                1
#define READ_LAYOUT_IBM                 2
#define READ_LAYOUT_CHINGYEAH           3
#define READ_LAYOUTS                    4
#endif


// the bit of fwProperties1
#define IMEPROP_CAND_NOBEEP_GUIDELINE   0x0001
#define IMEPROP_UNICODE                 0x0002


#if !defined(WINIME) && !defined(UNICDIME) && !defined(ROMANIME)
#define USR_DIC_SIZE    160

typedef struct tagUsrDic {
    TCHAR szUsrDic[USR_DIC_SIZE/sizeof(TCHAR)];
} USRDIC;

typedef USRDIC      *PUSRDIC;
typedef USRDIC NEAR *NPUSRDIC;
typedef USRDIC FAR  *LPUSRDIC;
#endif

#define MAX_NAME_LENGTH         32

#if !defined(ROMANIME)

#if defined(UNIIME) || defined(MINIIME)
#define MAX_IME_TABLES          6
#else
#define MAX_IME_TABLES          4
#endif

typedef struct tagTableFiles {  // match with the IMEL
    TCHAR szTblFile[MAX_IME_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
} TABLEFILES;

typedef TABLEFILES      *PTABLEFILES;
typedef TABLEFILES NEAR *NPTABLEFILES;
typedef TABLEFILES FAR  *LPTABLEFILES;


typedef struct tagValidChar {   // match with the IMEL
    DWORD dwVersion;
    WORD  fwProperties1;
    WORD  fwProperties2;
    WORD  nMaxKey;
    WORD  nSeqCode;
    WORD  fChooseChar[6];
    WORD  wReserved1[2];
#if defined(DAYI) || defined(UNIIME) || defined(MINIIME)
    BYTE  cChooseTrans[0x60];
#endif
    WORD  fCompChar[6];
    WORD  wReserved2[2];
    WORD  wCandPerPage;
    WORD  wCandStart;
    WORD  wCandRangeStart;
    WORD  wReserved3[1];
    WORD  wSeq2CompTbl[64];
    WORD  wChar2SeqTbl[0x42];
    WORD  wReserved4[2];
#if defined(WINAR30)
    WORD  wSymbol[356];
#elif defined(DAYI)
    WORD  wSymbol[340];
#elif defined(UNIIME) || defined(MINIME)
    DWORD dwReserved5[32];
#endif
} VALIDCHAR;

typedef VALIDCHAR      *PVALIDCHAR;
typedef VALIDCHAR NEAR *NPVALIDCHAR;
typedef VALIDCHAR FAR  *LPVALIDCHAR;
#endif // !defined(ROMANIME)


typedef struct tagImeL {        // local structure, per IME structure
// interlock protection variables
    LONG        lConfigGeneral;
    LONG        lConfigRegWord;
    LONG        lConfigSelectDic;
    TCHAR       szIMEName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szUIClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szStatusClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szOffCaretClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szCMenuClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
// Configuration of the IME
    DWORD       fdwModeConfig;  // quick key/prediction mode
// status window
    int         xStatusWi;      // width of status window
    int         yStatusHi;      // high of status window
    int         cxStatusBorder; // border width of status window
    int         cyStatusBorder; // border height of status window
    RECT        rcStatusText;   // text position relative to status window
    RECT        rcInputText;    // input text relateive to status window
    RECT        rcShapeText;    // shape text relative to status window
#if defined(ROMANIME)
    WORD        nMaxKey;        // max key of a Chinese word
    WORD        wDummy;         // DWORD bounary
#else
    int         xCompWi;        // width
    int         yCompHi;        // height
    int         cxCompBorder;   // border width of composition window
    int         cyCompBorder;   // border height of composition window
    RECT        rcCompText;     // text position relative to composition window
// candidate list of composition
    int         xCandWi;        // width of candidate list
    int         yCandHi;        // high of candidate list
    int         cxCandBorder;   // border width of candidate list
    int         cyCandBorder;   // border height of candidate list
    int         cxCandMargin;   // interior border width of candidate list
    int         cyCandMargin;   // interior border height of candidate list
    RECT        rcCandText;     // text position relative to candidate window
    RECT        rcCandPrompt;   // candidate prompt bitmap
    RECT        rcCandPageText; // candidate page controls - up / home / down
    RECT        rcCandPageUp;   // candidate page up
    RECT        rcCandHome;     // candidate home page
    RECT        rcCandPageDn;   // candidate page down
    TCHAR       szCompClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    TCHAR       szCandClassName[MAX_NAME_LENGTH / sizeof(TCHAR)];
    DWORD       fdwErrMsg;      // error message flag
#if !defined(WINIME) && !defined(UNICDIME)
// standard table related data
                                // size of standard table
    UINT        uTblSize[MAX_IME_TABLES];
                                // filename of tables
    TCHAR       szTblFile[MAX_IME_TABLES][MAX_NAME_LENGTH / sizeof(TCHAR)];
                                // the IME tables
// user create word related data
                                // user dictionary file name of IME
    TCHAR       szUsrDic[USR_DIC_SIZE / sizeof(TCHAR)];
                                // user dictionary map file name
    TCHAR       szUsrDicMap[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrDicSize;    // memory size of user create words table

    UINT        uUsrDicReserved1;
    UINT        uUsrDicReserved2;
// user create phrase box       // not implemented
    TCHAR       szUsrBox[USR_DIC_SIZE / sizeof(TCHAR)];
    TCHAR       szUsrBoxMap[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrBoxSize;
    UINT        uUsrBoxReserved1;
    UINT        uUsrBoxReserved2;
#endif
// the calculated sequence mask bits
    DWORD       dwSeqMask;      // the sequence bits for one stoke
    DWORD       dwPatternMask;  // the pattern bits for one result string
    int         nSeqBytes;      // how many bytes for nMaxKey sequence chars
// reverse conversion
    HKL         hRevKL;         // the HKL of reverse mapping IME
    WORD        nRevMaxKey;
// key related data
#if defined(PHON)
    WORD        nReadLayout;    // ACER, ETen, IBM, or other - phonetic only
#else
    WORD        wDummy;         // DWORD boundary
#endif
    WORD        nSeqBits;       // no. of sequence bits
    // must match with .RC file and VALIDCHAR
    DWORD       dwVersion;
    WORD        fwProperties1;
    WORD        fwProperties2;
    WORD        nMaxKey;        // max key of a Chinese word
    WORD        nSeqCode;       // no. of sequence code
    WORD        fChooseChar[6]; // valid char in choose state
                                // translate the char code to
                                // choose constants
    WORD        wReserved1[2];
#if defined(DAYI) || defined(UNIIME) || defined(MINIIME)
    BYTE        cChooseTrans[0x60];
#endif
    WORD        fCompChar[6];   // valid char in input state
    WORD        wReserved2[2];
    WORD        wCandPerPage;   // number of candidate strings per page
    WORD        wCandStart;     // 1. 2. 3. ... 0. start from 1
                                // 1. 2. 3. ... 0. range start from 0
    WORD        wCandRangeStart;
    WORD        wReserved3[1];
// convert sequence code to composition char
    WORD        wSeq2CompTbl[64];
// convert char to sequence code
    WORD        wChar2SeqTbl[0x42];
    WORD        wReserved4[2];
#if defined(WINAR30)
    WORD        wSymbol[524];
#elif defined(DAYI)
    WORD        wSymbol[340];
#elif defined(UNIIME) || defined(MINIIME)
    DWORD       fdwReserved5[32];
#endif
#endif // defined(ROMANIME)
} IMEL;

typedef IMEL      *PIMEL;
typedef IMEL NEAR *NPIMEL;
typedef IMEL FAR  *LPIMEL;


typedef struct tagInstL {       // local instance structure, per IME instance
    HINSTANCE   hInst;          // IME DLL instance handle
    LPIMEL      lpImeL;
#if !defined(ROMANIME)
    DWORD       fdwTblLoad;     // the *.TBL load status
    int         cRefCount;      // reference count
#if !defined(WINIME) && !defined(UNICDIME)
    HANDLE      hMapTbl[MAX_IME_TABLES];
    HANDLE      hUsrDicMem;     // memory handle for user dictionary
    TCHAR       szUsrDicReserved[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrDicReserved1;
    UINT        uUsrDicReserved2;
    HANDLE      hUsrBoxMem;
    TCHAR       szUsrBoxReserved[USR_DIC_SIZE / sizeof(TCHAR)];
    UINT        uUsrBoxReserved1;
    UINT        uUsrBoxReserved2;
#endif
#endif
    DWORD       dwReserved1[32];
} INSTDATAL;

typedef INSTDATAL      *PINSTDATAL;
typedef INSTDATAL NEAR *NPINSTDATAL;
typedef INSTDATAL FAR  *LPINSTDATAL;


#if !defined(UNIIME)
extern IMEL        sImeL;
extern LPIMEL      lpImeL;
extern INSTDATAL   sInstL;
extern LPINSTDATAL lpInstL;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\imerc.h ===
/*************************************************
 *  imerc.h                                      *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#define IDIC_IME_ICON                   0x0100


#define IDBM_CMODE_NATIVE               0x0100

#if !defined(MINIIME)
#define IDBM_CMODE_NONE                 0x0110

#if !defined(ROMANIME)
#define IDBM_CMODE_ALPHANUMERIC         0x0111
#endif

#define IDBM_CMODE_FULLSHAPE            0x0113
#define IDBM_CMODE_HALFSHAPE            0x0114

#if !defined(ROMANIME)
#if !defined(WINIME) && !defined(UNICDIME)
#define IDBM_CMODE_EUDC                 0x0115
#endif
#define IDBM_CMODE_SYMBOL               0x0116
#endif


#if !defined(ROMANIME)
#define IDBM_CAND_PROMPT_PHRASE         0x0120

#if defined(WINAR30)
#define IDBM_CAND_PROMPT_QUICK_VIEW     0x0121
#endif

#define IDBM_CAND_PROMPT_NORMAL         0x0122


#define IDBM_PAGEUP_HORIZ               0x0130
#define IDBM_NO_PAGEUP_HORIZ            0x0131
#define IDBM_HOME_HORIZ                 0x0132
#define IDBM_NO_HOME_HORIZ              0x0133
#define IDBM_PAGEDN_HORIZ               0x0134
#define IDBM_NO_PAGEDN_HORIZ            0x0135
#define IDBM_PAGEUP_VERT                0x0136
#define IDBM_NO_PAGEUP_VERT             0x0137
#define IDBM_PAGEDN_VERT                0x0138
#define IDBM_NO_PAGEDN_VERT             0x0139
#endif // !defined(ROMANIME)


#define IDDG_IME_CONFIG                 0x0100


#define IDMN_CONTEXT_MENU               0x0100
#endif // !defined(MINIIME)


#define IDRC_VALIDCHAR                  0x0100


#define IDRC_TABLEFILES                 0x0110

#if !defined(MINIIME)
#define IDRC_FULLABC                    0x0120
#if !defined(ROMANIME) && !defined(WINAR30)
#define IDRC_SYMBOL                     0x0121
#endif

#if defined(UNIIME)
#define IDRC_PHRASETABLES               0x0130
#endif


#define IDCR_HAND_CURSOR                0x0100
#endif // !defined(MINIIME)


#define IDS_IMENAME                     0x0100
#define IDS_IMEUICLASS                  0x0101
#define IDS_IMECOMPCLASS                0x0102
#define IDS_IMECANDCLASS                0x0103
#define IDS_IMESTATUSCLASS              0x0104
#define IDS_IMEOFFCARETCLASS            0x0105
#define IDS_IMECMENUCLASS               0x0106


#if !defined(MINIIME)
#define IDS_CHICHAR                     0x0200
#define IDS_NONE                        0x0201


#if !defined(ROMANIME) && !defined(WINIME) && !defined(UNICDIME)
#define IDS_EUDC                        0x0210
#define IDS_USRDIC_FILTER               0x0211


#define IDS_INTERNAL_TITLE              0x0220
#define IDS_INTERNAL_MSG                0x0221
#define IDS_EUDCDICFAIL_TITLE           0x0222
#define IDS_EUDCDICFAIL_MSG             0x0223
#define IDS_NOTOPEN_TITLE               0x0224
#define IDS_NOTOPEN_MSG                 0x0225
#define IDS_FILESIZE_TITLE              0x0226
#define IDS_FILESIZE_MSG                0x0227
#define IDS_HEADERSIZE_TITLE            0x0228
#define IDS_HEADERSIZE_MSG              0x0229
#define IDS_INFOSIZE_TITLE              0x022A
#define IDS_INFOSIZE_MSG                0x022B
#define IDS_CODEPAGE_TITLE              0x022E
#define IDS_CODEPAGE_MSG                0x022F
#define IDS_CWINSIGN_TITLE              0x0230
#define IDS_CWINSIGN_MSG                0x0231
#define IDS_UNMATCHED_TITLE             0x0232
#define IDS_UNMATCHED_MSG               0x0233

#define IDS_FILE_OPEN_ERR               0x0260
#define IDS_MEM_LESS_ERR                0x0261
#endif // !defined(ROMANIME) && !defined(WINIME) && !defined(UNICDIME)


#if defined(UNIIME)
#define IDS_FILE_OPEN_FAIL              0x0300
#define IDS_MEM_LACK_FAIL               0x0301
#endif


#define IDS_SHARE_VIOLATION             0x0310


#if defined(PHON)
#define IDD_DEFAULT_KB                  0x0100
#define IDD_ETEN_KB                     0x0101
#define IDD_IBM_KB                      0x0102
#define IDD_CHING_KB                    0x0103
#endif


#define IDD_OFF_CARET_UI                0x0200
#if !defined(ROMANIME)
#define IDD_QUICK_KEY                   0x0201
#define IDD_PREDICT                     0x0202

#define IDD_LAYOUT_LIST                 0x0210

#define IDD_EUDC_DIC                    0x0211
#endif

#define IDM_SOFTKBD                     0x0100
#define IDM_SYMBOL                      0x0101
#define IDM_PROPERTIES                  0x0102
#endif // !defined(MINIIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\init.c ===
/*************************************************
 *  init.c                                       *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <winerror.h>
#include <immdev.h>
#include "imeattr.h"
#include "imerc.h"
#include "imedefs.h"

/**********************************************************************/
/* InitImeGlobalData()                                                */
/**********************************************************************/
void PASCAL InitImeGlobalData(void)
{
    TCHAR   szChiChar[4];
    HDC     hDC;
    HGDIOBJ hOldFont;
    LOGFONT lfFont;
    SIZE    lTextSize;
    int     xHalfWi[2];
    HGLOBAL hResData;
    int     i;
    DWORD   dwSize;
    HKEY    hKeyNearCaret;
    LONG    lRet;

    {
        RECT rcWorkArea;

        // get work area
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWorkArea, 0);

        if (rcWorkArea.right < 2 * UI_MARGIN) {
        } else if (rcWorkArea.bottom < 2 * UI_MARGIN) {
        } else {
            sImeG.rcWorkArea = rcWorkArea;
        }
    }

    if (sImeG.wFullSpace) {
        // the global data already init
        return;
    }

    sImeG.uAnsiCodePage = GetACP();

    // get the Chinese char
    LoadString(hInst, IDS_CHICHAR, szChiChar, sizeof(szChiChar)/sizeof(TCHAR));

    // get size of Chinese char
    hDC = GetDC(NULL);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(LOGFONT), &lfFont);

        sImeG.fDiffSysCharSet = FALSE;
        lfFont.lfCharSet = NATIVE_CHARSET;
        lfFont.lfWeight = FW_NORMAL;
        lstrcpy(lfFont.lfFaceName, TEXT("MS Shell Dlg"));
        SelectObject(hDC, CreateFontIndirect(&lfFont));

    GetTextExtentPoint(hDC, szChiChar, lstrlen(szChiChar), &lTextSize);
    if (sImeG.rcWorkArea.right < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.left = 0;
        sImeG.rcWorkArea.right = GetDeviceCaps(hDC, HORZRES);
    }
    if (sImeG.rcWorkArea.bottom < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.top = 0;
        sImeG.rcWorkArea.bottom = GetDeviceCaps(hDC, VERTRES);
    }

    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    ReleaseDC(NULL, hDC);

    // get text metrics to decide the width & height of composition window
    // these IMEs always use system font to show
    sImeG.xChiCharWi = lTextSize.cx;
    sImeG.yChiCharHi = lTextSize.cy;

    // if unfortunate the xChiCharWi is odd number, xHalfWi[0] != xHalfWi[1]
    xHalfWi[0] = sImeG.xChiCharWi / 2;
    xHalfWi[1] = sImeG.xChiCharWi - xHalfWi[0];

    for (i = 0; i < sizeof(iDx) / sizeof(int); i++) {
        iDx[i] = sImeG.xChiCharWi;
    }

    // load full ABC chars
    hResData = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDRC_FULLABC), RT_RCDATA));
    *(LPFULLABC)sImeG.wFullABC = *(LPFULLABC)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

    // full shape space
    sImeG.wFullSpace = sImeG.wFullABC[0];

    // load symbol chars
    hResData = LoadResource(hInst, FindResource(hInst,
        MAKEINTRESOURCE(IDRC_SYMBOL), RT_RCDATA));
    *(LPSYMBOL)sImeG.wSymbol = *(LPSYMBOL)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

    // get the UI offset for near caret operation
    RegCreateKey(HKEY_CURRENT_USER, szRegNearCaret, &hKeyNearCaret);

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKeyNearCaret, szPara, NULL, NULL,
        (LPBYTE)&sImeG.iPara, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPara = 0;
        RegSetValueEx(hKeyNearCaret, szPara, 0, REG_DWORD,
            (LPBYTE)&sImeG.iPara, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyNearCaret, szPerp, NULL, NULL,
        (LPBYTE)&sImeG.iPerp, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerp = sImeG.yChiCharHi;
        RegSetValueEx(hKeyNearCaret, szPerp, 0, REG_DWORD,
            (LPBYTE)&sImeG.iPerp, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyNearCaret, szParaTol, NULL, NULL,
        (LPBYTE)&sImeG.iParaTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iParaTol = sImeG.xChiCharWi * 4;
        RegSetValueEx(hKeyNearCaret, szParaTol, 0, REG_DWORD,
            (LPBYTE)&sImeG.iParaTol, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyNearCaret, szPerpTol, NULL, NULL,
        (LPBYTE)&sImeG.iPerpTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerpTol = sImeG.yChiCharHi;
        RegSetValueEx(hKeyNearCaret, szPerpTol, 0, REG_DWORD,
            (LPBYTE)&sImeG.iPerpTol, sizeof(int));
    }

    RegCloseKey(hKeyNearCaret);

    return;
}

/**********************************************************************/
/* InitImeLocalData()                                                 */
/**********************************************************************/
BOOL PASCAL InitImeLocalData(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
    HGLOBAL hResData;

    UINT    i;
    WORD    nSeqCode;

    // the local data already init
    if (lpImeL->szIMEName[0]) {
        return (TRUE);
    }

    // we will use the same string length for W version so / sizeof(WORD)
    // get the IME name
    LoadString(lpInstL->hInst, IDS_IMENAME, lpImeL->szIMEName,
        sizeof(lpImeL->szIMEName) / sizeof(WCHAR));

    // get the UI class name
    LoadString(lpInstL->hInst, IDS_IMEUICLASS, lpImeL->szUIClassName,
        sizeof(lpImeL->szUIClassName) / sizeof(WCHAR));

    // get the composition class name
    LoadString(lpInstL->hInst, IDS_IMECOMPCLASS, lpImeL->szCompClassName,
        sizeof(lpImeL->szCompClassName) / sizeof(WCHAR));

    // load valid char in choose/input state
    hResData = LoadResource(lpInstL->hInst, FindResource(lpInstL->hInst,
        MAKEINTRESOURCE(IDRC_VALIDCHAR), RT_RCDATA));
    *(LPVALIDCHAR)&lpImeL->dwVersion = *(LPVALIDCHAR)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

    nSeqCode = 0x0001;

    for (i = 1; i < sizeof(DWORD) * 8; i++) {
        nSeqCode <<= 1;
        if (nSeqCode > lpImeL->nSeqCode) {
            lpImeL->nSeqBits = (WORD)i;
            break;
        }
    }

    // calculate sequence code mask for one stoke (reading char)
    if (!lpImeL->dwSeqMask) {           // check again, it is still possible
                                        // that multiple thread reach here
        for (i = 0; i < lpImeL->nSeqBits; i++) {
            lpImeL->dwSeqMask <<= 1;
            lpImeL->dwSeqMask |= 0x0001;
        }
    }

    // data bytes for one finalized char
    lpImeL->nSeqBytes = (lpImeL->nSeqBits * lpImeL->nMaxKey + 7) / 8;

    // valid bits mask for all strokes
    if (!lpImeL->dwPatternMask) {       // check again, it is still possible
                                        // that multiple thread reach here
        for (i =0; i < lpImeL->nMaxKey; i++) {
            lpImeL->dwPatternMask <<= lpImeL->nSeqBits;
            lpImeL->dwPatternMask |= lpImeL->dwSeqMask;
        }
    }

    lpImeL->hRevKL = NULL;

    // mark this event for later check reverse length
    if (lpImeL->hRevKL) {
        lpImeL->fdwErrMsg |= NO_REV_LENGTH;
    }

    // we assume the max key is the same as this IME, check later
    lpImeL->nRevMaxKey = lpImeL->nMaxKey;


    lpImeL->fdwModeConfig = MODE_CONFIG_PREDICT;


    return (TRUE);
}

/**********************************************************************/
/* InitImeUIData()                                                    */
/**********************************************************************/
void PASCAL InitImeUIData(      // initialize each UI component coordination
    LPIMEL      lpImeL)
{
    int cxBorder, cyBorder, cxEdge, cyEdge, cxMinWindowWidth;

    cxEdge = GetSystemMetrics(SM_CXEDGE);
    cyEdge = GetSystemMetrics(SM_CYEDGE);

    // border + raising edge
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);


    lpImeL->rcCompText.top = lpImeL->cyCompBorder;
    lpImeL->rcCompText.bottom = lpImeL->rcCompText.top +
        sImeG.yChiCharHi;

        lpImeL->rcCompText.left = lpImeL->cxCompBorder;
        lpImeL->rcCompText.right = lpImeL->rcCompText.left +
            sImeG.xChiCharWi * lpImeL->nRevMaxKey;

        lpImeL->xCompWi = (lpImeL->rcCompText.right -
            lpImeL->rcCompText.left) + lpImeL->cxCompBorder * 2 * 2;
        lpImeL->xCandWi = (lpImeL->rcCandText.right -
            lpImeL->rcCandText.left) + lpImeL->cxCandBorder * 2 +
            lpImeL->cxCandMargin * 2;

    lpImeL->yCompHi = (lpImeL->rcCompText.bottom - lpImeL->rcCompText.top) +
        lpImeL->cyCompBorder * 2 * 2;


    return;
}

/**********************************************************************/
/* SetCompLocalData()                                                 */
/**********************************************************************/
void PASCAL SetCompLocalData(
    LPIMEL lpImeL)
{
    // text position relative to the composition window
    lpImeL->rcCompText.right = lpImeL->rcCompText.left +
        sImeG.xChiCharWi * lpImeL->nRevMaxKey;

    // set the width & height for composition window
    lpImeL->xCompWi = lpImeL->rcCompText.right + lpImeL->cxCompBorder * 3;

    return;
}

/**********************************************************************/
/* RegisterImeClass()                                                 */
/**********************************************************************/
void PASCAL RegisterImeClass(
    WNDPROC     lpfnUIWndProc,
    WNDPROC     lpfnCompWndProc)
{
    WNDCLASSEX wcWndCls;

    // IME UI class
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(LONG) * 2;
    wcWndCls.hIcon         = LoadIcon(lpInstL->hInst,
        MAKEINTRESOURCE(IDIC_IME_ICON));
    wcWndCls.hInstance     = lpInstL->hInst;
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPTSTR)NULL;
    wcWndCls.hIconSm       = LoadImage(lpInstL->hInst,
        MAKEINTRESOURCE(IDIC_IME_ICON), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

    // IME UI class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szUIClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME;
        wcWndCls.lpfnWndProc   = lpfnUIWndProc;
        wcWndCls.lpszClassName = lpImeL->szUIClassName;

        RegisterClassEx(&wcWndCls);
    }

    wcWndCls.style         = CS_IME|CS_HREDRAW|CS_VREDRAW;

    wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH);

    // IME composition class
    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szCompClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = lpfnCompWndProc;
        wcWndCls.lpszClassName = lpImeL->szCompClassName;

        RegisterClassEx(&wcWndCls);
    }

    return;
}

/**********************************************************************/
/* AttachIME() / UniAttachMiniIME()                                   */
/**********************************************************************/
void PASCAL AttachIME(
    WNDPROC     lpfnUIWndProc,
    WNDPROC     lpfnCompWndProc)
{

    InitImeGlobalData();
    InitImeLocalData(lpInstL, lpImeL);

    if (!lpImeL->rcStatusText.bottom) {
        InitImeUIData(lpImeL);
    }

    RegisterImeClass(
        lpfnUIWndProc,
        lpfnCompWndProc/*, lpfnCandWndProc,
        lpfnStatusWndProc, lpfnOffCaretWndProc,
        lpfnContextMenuWndProc*/);

     return;
}

/**********************************************************************/
/* DetachIME() / UniDetachMiniIME()                                   */
/**********************************************************************/
void PASCAL DetachIME(
    LPINSTDATAL lpInstL,
    LPIMEL      lpImeL)
{
    WNDCLASSEX wcWndCls;

    if (GetClassInfoEx(lpInstL->hInst, lpImeL->szCompClassName, &wcWndCls)) {
        UnregisterClass(lpImeL->szCompClassName, lpInstL->hInst);
    }

    if (!GetClassInfoEx(lpInstL->hInst, lpImeL->szUIClassName, &wcWndCls)) {
    } else if (!UnregisterClass(lpImeL->szUIClassName, lpInstL->hInst)) {
    } else {
         DestroyIcon(wcWndCls.hIcon);
         DestroyIcon(wcWndCls.hIconSm);
    }

    FreeTable(lpInstL);
}

/**********************************************************************/
/* ImeDllInit() / UniImeDllInit()                                     */
/* Return Value:                                                      */
/*      TRUE - successful                                             */
/*      FALSE - failure                                               */
/**********************************************************************/
BOOL CALLBACK ImeDllInit(
    HINSTANCE hInstance,        // instance handle of this library
    DWORD     fdwReason,        // reason called
    LPVOID    lpvReserve)       // reserve pointer
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        hInst = hInstance;

        if (lpInstL) {
            // the local instance data already init
            return (TRUE);
        }

        lpInstL = &sInstL;

        lpInstL->hInst = hInstance;

        lpInstL->lpImeL = lpImeL = &sImeL;

        AttachIME(UIWndProc, CompWndProc);
        break;
    case DLL_PROCESS_DETACH:
        DetachIME(lpInstL, lpImeL);
        break;
    default:
        break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\regword.c ===
/*************************************************
 *  regword.c                                    *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"

/**********************************************************************/
/* ImeRegsisterWord                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeRegisterWord(
    LPCTSTR     lpszReading,
    DWORD       dwStyle,
    LPCTSTR     lpszString)
{
    return (FALSE);
}
/**********************************************************************/
/* ImeUnregsisterWord / UniImeUnregisterWord                          */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeUnregisterWord(
    LPCTSTR     lpszReading,
    DWORD       dwStyle,
    LPCTSTR     lpszString)
{
    return (FALSE);
}

/**********************************************************************/
/* ImeGetRegsisterWordStyle / UniImeGetRegsisterWordStyle             */
/* Return Value:                                                      */
/*      number of styles copied/required                              */
/**********************************************************************/
UINT WINAPI ImeGetRegisterWordStyle(
    UINT        nItem,
    LPSTYLEBUF  lpStyleBuf)
{
    return (FALSE);
}

/**********************************************************************/
/* ImeEnumRegisterWord                                                */
/* Return Value:                                                      */
/*      the last value return by the callback function                */
/**********************************************************************/
UINT WINAPI ImeEnumRegisterWord(
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\notify.c ===
/*************************************************
 *  notify.c                                     *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

/**********************************************************************/
/* GenerateMessage()                                                  */
/**********************************************************************/
void PASCAL GenerateMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    if (!hIMC) {
        return;
    } else if (!lpIMC) {
        return;
    } else if (!lpImcP) {
        return;
    } else if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
        return;
    } else {
    }

    lpIMC->dwNumMsgBuf += TranslateImeMessage(NULL, lpIMC, lpImcP);

    lpImcP->fdwImeMsg &= (MSG_STATIC_STATE);
    lpImcP->fdwGcsFlag = 0;

    ImmGenerateMessage(hIMC);
    return;
}

/**********************************************************************/
/* SetString()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL SetString(
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPTSTR              lpszRead,
    DWORD               dwReadLen)
{
    LPGUIDELINE lpGuideLine;
    DWORD       i;

    // convert from byte count to the string length
    dwReadLen = dwReadLen / sizeof(TCHAR);

    if (dwReadLen > lpImeL->nMaxKey * sizeof(WCHAR) / sizeof(TCHAR)) {
        return (FALSE);
    }

    InitCompStr(lpCompStr);
    ClearCand(lpIMC);

/*
    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (lpGuideLine) {
        InitGuideLine(lpGuideLine);
        ImmUnlockIMCC(lpIMC->hGuideLine);
    }
*/

    // compoition/reading attribute
    lpCompStr->dwCompReadAttrLen = dwReadLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompReadAttrLen;

    // The IME has converted these chars
    for (i = 0; i < dwReadLen; i++) {
        *((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset + i) =
            ATTR_TARGET_CONVERTED;
    }

    // composition/reading clause, 1 clause only
    lpCompStr->dwCompReadClauseLen = 2 * sizeof(DWORD);
    lpCompStr->dwCompClauseLen = lpCompStr->dwCompReadClauseLen;
    *(LPDWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD)) = dwReadLen;

    lpCompStr->dwCompReadStrLen = dwReadLen;
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset, lpszRead,
        dwReadLen * sizeof(TCHAR) + sizeof(TCHAR));

    // dlta start from 0;
    lpCompStr->dwDeltaStart = 0;
    // cursor is next to composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    // set private input context
    lpImcP->iImeState = CST_INPUT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    }

    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
            ~(MSG_END_COMPOSITION);
    }

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = (DWORD)lpImeL->wSeq2CompTbl[
        lpImcP->bSeq[lpCompStr->dwCompReadStrLen / 2 - 1]];
    lpImcP->fdwGcsFlag = GCS_COMPREAD|GCS_COMP|
        GCS_DELTASTART|GCS_CURSORPOS;

    lpImcP->fdwImeMsg |= MSG_GUIDELINE;

    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        if (lpCompStr->dwCompReadStrLen >= sizeof(WORD) * lpImeL->nMaxKey) {
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
            lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULTSTR;
        }
    } else {
        if (dwReadLen < sizeof(WCHAR) / sizeof(TCHAR) * lpImeL->nMaxKey) {
        }
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    return (TRUE);
}

/**********************************************************************/
/* CompCancel()                                                       */
/**********************************************************************/
void PASCAL CompCancel(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    if (!lpIMC->hPrivate) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwGcsFlag = 0;

    if (lpImcP->fdwImeMsg & (MSG_ALREADY_START|MSG_START_COMPOSITION)) {
        LPCOMPOSITIONSTRING lpCompStr;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        CompEscapeKey(lpIMC, lpCompStr, lpImcP);

        if (lpCompStr) {
            ImmUnlockIMCC(lpIMC->hCompStr);
        }
    } else {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* ImeSetCompositionString()                                          */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetCompositionString(
    HIMC        hIMC,
    DWORD       dwIndex,
    LPVOID      lpComp,
    DWORD       dwCompLen,
    LPVOID      lpRead,
    DWORD       dwReadLen)
{
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    BOOL                fRet;
    TCHAR               szReading[16];

    if (!hIMC) {
        return (FALSE);
    }

    // composition string must  == reading string
    // reading is more important
    if (!dwReadLen) {
        dwReadLen = dwCompLen;
    }

    // composition string must  == reading string
    // reading is more important
    if (!lpRead) {
        lpRead = lpComp;
    }

    if (!dwReadLen) {
        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            return (FALSE);
        }

        CompCancel(hIMC, lpIMC);
        ImmUnlockIMC(hIMC);
        return (TRUE);
    } else if (!lpRead) {
        return (FALSE);
    } else if (dwReadLen >= sizeof(szReading)) {
        return (FALSE);
    } else if (!dwCompLen) {
    } else if (!lpComp) {
    } else if (dwReadLen != dwCompLen) {
        return (FALSE);
    } else if (lpRead == lpComp) {
    } else if (!lstrcmp(lpRead, lpComp)) {
        // composition string must  == reading string
    } else {
        // composition string != reading string
        return (FALSE);
    }

    if (dwIndex != SCS_SETSTR) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    fRet = FALSE;

    if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|IME_CMODE_SYMBOL)) !=
        IME_CMODE_NATIVE) {
        goto ImeSetCompStrUnlockIMC;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        goto ImeSetCompStrUnlockIMC;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto ImeSetCompStrUnlockCompStr;
    }

    if (*(LPTSTR)((LPBYTE)lpRead + dwReadLen) != '\0') {
        CopyMemory(szReading, (LPBYTE)lpRead, dwReadLen);
        lpRead = szReading;
        *(LPTSTR)((LPBYTE)lpRead + dwReadLen) = '\0';
    }

    fRet = SetString(
        hIMC, lpIMC, lpCompStr, lpImcP, lpRead, dwReadLen);

    ImmUnlockIMCC(lpIMC->hPrivate);
ImeSetCompStrUnlockCompStr:
    ImmUnlockIMCC(lpIMC->hCompStr);
ImeSetCompStrUnlockIMC:
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* GenerateImeMessage()                                               */
/**********************************************************************/
void PASCAL GenerateImeMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    DWORD          fdwImeMsg)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= fdwImeMsg;

    if (fdwImeMsg & MSG_CLOSE_CANDIDATE) {
        lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else if (fdwImeMsg & (MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE)) {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE);
    } else {
    }

    if (fdwImeMsg & MSG_END_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_START_COMPOSITION);
    } else if (fdwImeMsg & MSG_START_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION);
    } else {
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* CompComplete()                                                     */
/**********************************************************************/
void PASCAL CompComplete(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    if (!lpImcP) {
        return;
    }

    if (lpImcP->iImeState == CST_INIT) {
        // can not do any thing
        CompCancel(hIMC, lpIMC);
    } else if (lpImcP->iImeState == CST_CHOOSE) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPCANDIDATEINFO     lpCandInfo;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

        if (lpCandInfo) {
            LPCANDIDATELIST lpCandList;

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                lpCandInfo->dwOffset[0]);

            SelectOneCand(
                hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);

            ImmUnlockIMCC(lpIMC->hCandInfo);

            GenerateMessage(hIMC, lpIMC, lpImcP);
        }

        if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
    } else if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|
        IME_CMODE_EUDC|IME_CMODE_SYMBOL)) != IME_CMODE_NATIVE) {
        CompCancel(hIMC, lpIMC);
    } else if (lpImcP->iImeState == CST_INPUT) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPGUIDELINE         lpGuideLine;
        LPCANDIDATEINFO     lpCandInfo;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        CompWord(
            ' ', hIMC, lpIMC, lpCompStr, lpGuideLine, lpImcP);

        if (lpImcP->iImeState == CST_INPUT) {
            CompCancel(hIMC, lpIMC);
        } else if (lpImcP->iImeState != CST_CHOOSE) {
        } else if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(
            lpIMC->hCandInfo)) {
            LPCANDIDATELIST lpCandList;

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                lpCandInfo->dwOffset[0]);

            SelectOneCand(
                hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);

            ImmUnlockIMCC(lpIMC->hCandInfo);
        } else {
        }

        if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
        if (lpGuideLine) ImmUnlockIMCC(lpIMC->hGuideLine);

        // don't phrase predition under this case
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
        } else {
            lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
        }

        GenerateMessage(hIMC, lpIMC, lpImcP);
    } else {
        CompCancel(hIMC, lpIMC);
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* NotifyIME() / UniNotifyIME()                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI NotifyIME(
    HIMC        hIMC,
    DWORD       dwAction,
    DWORD       dwIndex,
    DWORD       dwValue)
{
    LPINPUTCONTEXT lpIMC;
    BOOL           fRet;

    fRet = FALSE;

    if (!hIMC) {
        return (fRet);
    }

    switch (dwAction) {
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
        case IMC_SETSENTENCEMODE:
        case IMC_SETOPENSTATUS:
            break;              // need to handle it
        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONWINDOW:
            return (TRUE);      // not important to the IME
        default:
            return (fRet);      // not supported
        }
        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_COMPLETE:
            break;              // need to handle it
        case CPS_CONVERT:       // all composition string can not be convert
        case CPS_REVERT:        // any more, it maybe work for some
                                // intelligent phonetic IMEs
            return (fRet);
        case CPS_CANCEL:
            break;              // need to handle it
        default:
            return (fRet);      // not supported
        }
        break;                  // need to handle it
    default:
        return (fRet);          // not supported
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (fRet);
    }

    fRet = TRUE;

    switch (dwAction) {
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_CANCEL:
            CompCancel(hIMC, lpIMC);
            break;
        case CPS_COMPLETE:
            CompComplete(
                hIMC, lpIMC);
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    ImmUnlockIMC(hIMC);
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\toascii.c ===
/*************************************************
 *  toascii.c                                    *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"


/**********************************************************************/
/* ProcessKey()                                                       */
/* Return Value:                                                      */
/*      different state which input key will change IME to            */
/**********************************************************************/
UINT PASCAL ProcessKey(     // this key will cause the IME go to what state
    WORD           wCharCode,
    UINT           uVirtKey,
    UINT           uScanCode,
    CONST LPBYTE   lpbKeyState,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    if (!lpIMC)
    {
        return (CST_INVALID);
    }

    if (!lpImcP)
    {
        return (CST_INVALID);
    }


    if (uVirtKey == VK_MENU)
    {
        //
        //  no ALT key
        //
        return (CST_INVALID);
    }
    else if (uScanCode & KF_ALTDOWN)
    {
        //
        //  no ALT-xx key
        //
        return (CST_INVALID);
    }
    else if (uVirtKey == VK_CONTROL)
    {
        //
        //  no CTRL key
        //
        return (CST_INVALID);
    }
    else if (lpbKeyState[VK_CONTROL] & 0x80)
    {
        //
        //  no CTRL-xx key
        //
        return (CST_INVALID);
    }
    else if (uVirtKey == VK_SHIFT)
    {
        //
        //  no SHIFT key
        //
        return (CST_INVALID);
    }
    else if (!lpIMC->fOpen)
    {
        //
        //  don't compose in close status
        //
        return (CST_INVALID);
    }
    else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION)
    {
        //
        //  don't compose in no coversion status
        //
        return (CST_INVALID);
    }
    else if (lpIMC->fdwConversion & IME_CMODE_CHARCODE)
    {
        //
        //  not support
        //
        return (CST_INVALID);
    }



    if (uVirtKey >= VK_NUMPAD0 && uVirtKey <= VK_DIVIDE)
    {
        //
        // A PM decision: all numpad should be past to app
        //
        return (CST_ALPHANUMERIC);
    }

    if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE))
    {
        return (CST_INVALID);
    }
    else if (!(lpbKeyState[VK_SHIFT] & 0x80))
    {
        //
        // need more check for IME_CMODE_NATIVE
        //
    }
    else if (wCharCode < ' ' && wCharCode > '~')
    {
        return (CST_INVALID);
    }

    //
    // need more check for IME_CMODE_NATIVE
    //

    if (wCharCode >= ' ' && wCharCode <= 'z')
    {
        wCharCode = bUpper[wCharCode - ' '];
    }

    if (uVirtKey == VK_ESCAPE)
    {
        register LPGUIDELINE lpGuideLine;
        register UINT        iImeState;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START)
        {
            return (CST_INPUT);
        }

        lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

        if (!lpGuideLine)
        {
            return (CST_INVALID);
        }
        else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE)
        {
            iImeState = CST_INVALID;
        }
        else
        {
            //
            //  need this key to clean information string or guideline state
            //
            iImeState = CST_INPUT;
        }

        ImmUnlockIMCC(lpIMC->hGuideLine);

        return (iImeState);
    }
    else if (uVirtKey == VK_BACK)
    {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_START)
        {
            return (CST_INPUT);
        }
        else
        {
            return (CST_INVALID);
        }
    }

    //
    // check finalize char
    //
    if (wCharCode == ' ' && lpImcP->iImeState == CST_INIT)
    {
        return (CST_INVALID);
    }
    else if (lpImeL->fCompChar[(wCharCode - ' ') >> 4] &
             fMask[wCharCode & 0x000F])
    {
        return (CST_INPUT);
    }
    else if (wCharCode >= 'G' && wCharCode <= 'Z'  ||
             wCharCode >= 'g' && wCharCode <= 'z')
    {
        //
        //  PM decision says we should not send these letters to input
        //  to avoid confusing users. We special handle this case by
        //  introducing CST_BLOCKINPUT flag.
        //
        return (CST_BLOCKINPUT);
    }

    return (CST_INVALID);
}

/**********************************************************************/
/* ImeProcessKey() / UniImeProcessKey()                               */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
// if this key is need by IME?
BOOL WINAPI ImeProcessKey(
    HIMC         hIMC,
    UINT         uVirtKey,
    LPARAM       lParam,
    CONST LPBYTE lpbKeyState)
{
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    BYTE           szAscii[4];
    int            nChars;
    BOOL           fRet;

    //
    // can't compose in NULL hIMC
    //
    if (!hIMC)
    {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC)
    {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP)
    {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    nChars = ToAscii(uVirtKey, HIWORD(lParam), lpbKeyState, (LPVOID)szAscii, 0);

    if (!nChars)
    {
        szAscii[0] = 0;
    }

    if (ProcessKey( (WORD)szAscii[0],
                    uVirtKey,
                    HIWORD(lParam),
                    lpbKeyState,
                    lpIMC,
                    lpImcP) == CST_INVALID)
    {
        fRet = FALSE;
    }
    else
    {
        fRet = TRUE;
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* TranslateToAscii()                                                 */
/* Translates the key input to WM_CHAR as keyboard drivers does       */
/*                                                                    */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateToAscii(
    UINT    uScanCode,
    LPTRANSMSG lpTransMsg,
    WORD    wCharCode)
{
    if (wCharCode)
    {
        //
        //  one char code
        //

        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam = wCharCode;
        lpTransMsg->lParam = (uScanCode << 16) | 1UL;
        return (1);
    }

    //
    //  no char code case
    //
    return (0);
}

/**********************************************************************/
/* TranslateImeMessage()                                              */
/* Return Value:                                                      */
/*      the number of translated messages                             */
/**********************************************************************/
UINT PASCAL TranslateImeMessage(
    LPTRANSMSGLIST lpTransBuf,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    UINT uNumMsg;
    UINT i;
    BOOL bLockMsgBuf;
    LPTRANSMSG lpTransMsg;

    uNumMsg = 0;
    bLockMsgBuf = FALSE;

    for (i = 0; i < 2; i++)
    {
        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONSIZE)
        {
            if (!i)
            {
                uNumMsg++;
            }
            else
            {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam = IMN_PRIVATE;
                lpTransMsg->lParam = IMN_PRIVATE_COMPOSITION_SIZE;
                lpTransMsg += 1;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_START_COMPOSITION)
        {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START))
            {
                if (!i)
                {
                    uNumMsg++;
                }
                else
                {
                    lpTransMsg->message = WM_IME_STARTCOMPOSITION;
                    lpTransMsg->wParam = 0;
                    lpTransMsg->lParam = 0;
                    lpTransMsg += 1;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_START;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONPOS)
        {
            if (!i)
            {
                uNumMsg++;
            }
            else
            {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam = IMN_SETCOMPOSITIONWINDOW;
                lpTransMsg->lParam = 0;
                lpTransMsg += 1;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_COMPOSITION)
        {
            if (!i)
            {
                uNumMsg++;
            }
            else
            {
                lpTransMsg->message = WM_IME_COMPOSITION;
                lpTransMsg->wParam = lpImcP->dwCompChar;
                lpTransMsg->lParam = lpImcP->fdwGcsFlag;
                lpTransMsg += 1;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_GUIDELINE)
        {
            if (!i)
            {
                uNumMsg++;
            }
            else
            {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam = IMN_GUIDELINE;
                lpTransMsg->lParam = 0;
                lpTransMsg += 1;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_PAGEUP)
        {
            if (!i)
            {
                uNumMsg++;
            }
            else
            {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam = IMN_PRIVATE;
                lpTransMsg->lParam = IMN_PRIVATE_PAGEUP;
                lpTransMsg += 1;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_END_COMPOSITION)
        {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START)
            {
                if (!i)
                {
                    uNumMsg++;
                }
                else
                {
                    lpTransMsg->message = WM_IME_ENDCOMPOSITION;
                    lpTransMsg->wParam = 0;
                    lpTransMsg->lParam = 0;
                    lpTransMsg += 1;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_START);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_TOGGLE_UI)
        {
            if (!i)
            {
                uNumMsg++;
            }
            else
            {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam = IMN_PRIVATE;
                lpTransMsg->lParam = IMN_PRIVATE_TOGGLE_UI;
                lpTransMsg += 1;
            }
        }

        if (!i)
        {
            HIMCC hMem;

            if (!uNumMsg)
            {
                return (uNumMsg);
            }

            if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX)
            {
                UINT uNumMsgLimit;

                // ++ for the start position of buffer to strore the messages
                uNumMsgLimit = lpTransBuf->uMsgCount;

                if (uNumMsg <= uNumMsgLimit)
                {
                    lpTransMsg = lpTransBuf->TransMsg;
                    continue;
                }
            }

            // we need to use message buffer
            if (!lpIMC->hMsgBuf)
            {
                lpIMC->hMsgBuf = ImmCreateIMCC(uNumMsg * sizeof(TRANSMSG));
                lpIMC->dwNumMsgBuf = 0;
            }
            else if (hMem = ImmReSizeIMCC(lpIMC->hMsgBuf,
                (lpIMC->dwNumMsgBuf + uNumMsg) * sizeof(TRANSMSG)))
            {
                if (hMem != lpIMC->hMsgBuf)
                {
                    ImmDestroyIMCC(lpIMC->hMsgBuf);
                    lpIMC->hMsgBuf = hMem;
                }
            }
            else
            {
                return (0);
            }

            lpTransMsg = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf);
            if (!lpTransMsg)
            {
                return (0);
            }

            lpTransMsg += lpIMC->dwNumMsgBuf;

            bLockMsgBuf = TRUE;
        }
        else
        {
            if (bLockMsgBuf)
            {
                ImmUnlockIMCC(lpIMC->hMsgBuf);
            }
        }
    }

    return (uNumMsg);
}

/**********************************************************************/
/* ImeToAsciiEx() / UniImeToAsciiex()                                 */
/* Return Value:                                                      */
/*      the number of translated message                              */
/**********************************************************************/
UINT WINAPI ImeToAsciiEx(
    UINT         uVirtKey,
    UINT         uScanCode,
    CONST LPBYTE lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT         fuState,
    HIMC         hIMC)
{
    WORD                wCharCode;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;
    LPPRIVCONTEXT       lpImcP;
    UINT                uNumMsg;
    int                 iRet;

    wCharCode = HIWORD(uVirtKey);
    uVirtKey = LOBYTE(uVirtKey);

    if (!hIMC)
    {
        return TranslateToAscii(uScanCode,
                                &lpTransBuf->TransMsg[0],
                                wCharCode);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC)
    {
        return TranslateToAscii(uScanCode,
                                &lpTransBuf->TransMsg[0],
                                wCharCode);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP)
    {
        ImmUnlockIMC(hIMC);
        return TranslateToAscii(uScanCode,
                                &lpTransBuf->TransMsg[0],
                                wCharCode);
    }

    // Now all composition realated information already pass to app
    // a brand new start
    lpImcP->fdwImeMsg = lpImcP->fdwImeMsg & (MSG_STATIC_STATE) |
        MSG_IN_IMETOASCIIEX;

    iRet = ProcessKey(wCharCode,
                      uVirtKey,
                      uScanCode,
                      lpbKeyState,
                      lpIMC,
                      lpImcP);

    if (iRet == CST_ALPHABET)
    {
        // A-Z convert to a-z, a-z convert to A-Z
        wCharCode ^= 0x20;

        iRet = CST_ALPHANUMERIC;
    }

    if (iRet == CST_ALPHANUMERIC)
    {
        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);

        uNumMsg += TranslateToAscii(uScanCode,
                                    &lpTransBuf->TransMsg[uNumMsg],
                                    wCharCode);
    }
    else if (iRet == CST_INPUT)
    {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        CompWord(wCharCode, hIMC, lpIMC, lpCompStr, lpGuideLine, lpImcP);

        if (lpGuideLine)
        {
            ImmUnlockIMCC(lpIMC->hGuideLine);
        }

        if (lpCompStr)
        {
            ImmUnlockIMCC(lpIMC->hCompStr);
        }

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    }
    else if (iRet == CST_BLOCKINPUT)
    {
        //
        //  This codepoint should be blocked.  We don't compose it for IME.
        //  Nor do we pass it to normal input. Instead, we beep.
        //
        MessageBeep(-1);
        uNumMsg = 0;
    }
    else
    {
        uNumMsg = TranslateToAscii(uScanCode,
                                   &lpTransBuf->TransMsg[0],
                                   wCharCode);
    }

    lpImcP->fdwImeMsg &= (MSG_STATIC_STATE);
    lpImcP->fdwGcsFlag = 0;

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (uNumMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\uisubs.c ===
/*************************************************
 *  uisubs.c                                     *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"
#include "imerc.h"

/**********************************************************************/
/* DrawDragBorder()                                                   */
/**********************************************************************/
void PASCAL DrawDragBorder(
    HWND hWnd,                  // window of IME is dragged
    LONG lCursorPos,            // the cursor position
    LONG lCursorOffset)         // the offset form cursor to window org
{
    HDC  hDC;
    int  cxBorder, cyBorder;
    int  x, y;
    RECT rcWnd;

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    // get cursor position
    x = (*(LPPOINTS)&lCursorPos).x;
    y = (*(LPPOINTS)&lCursorPos).y;

    // calculate the org by the offset
    x -= (*(LPPOINTS)&lCursorOffset).x;
    y -= (*(LPPOINTS)&lCursorOffset).y;

    // check for the min boundary of the display
    if (x < sImeG.rcWorkArea.left) {
        x = sImeG.rcWorkArea.left;
    }

    if (y < sImeG.rcWorkArea.top) {
        y = sImeG.rcWorkArea.top;
    }

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

    if (x + rcWnd.right - rcWnd.left > sImeG.rcWorkArea.right) {
        x = sImeG.rcWorkArea.right - (rcWnd.right - rcWnd.left);
    }

    if (y + rcWnd.bottom - rcWnd.top > sImeG.rcWorkArea.bottom) {
        y = sImeG.rcWorkArea.bottom - (rcWnd.bottom - rcWnd.top);
    }

    // draw the moving track
    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // ->
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder,
        PATINVERT);
    // v
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top -
        cyBorder, PATINVERT);
    // _>
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top,
        rcWnd.right - rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    //  v
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y,
        - cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);

    DeleteDC(hDC);
    return;
}

/**********************************************************************/
/* DrawFrameBorder()                                                  */
/**********************************************************************/
void PASCAL DrawFrameBorder(    // border of IME
    HDC  hDC,
    HWND hWnd)                  // window of IME
{
    RECT rcWnd;
    int  xWi, yHi;

    GetWindowRect(hWnd, &rcWnd);

    xWi = rcWnd.right - rcWnd.left;
    yHi = rcWnd.bottom - rcWnd.top;

    // 1, ->
    PatBlt(hDC, 0, 0, xWi, 1, WHITENESS);

    // 1, v
    PatBlt(hDC, 0, 0, 1, yHi, WHITENESS);

    // 1, _>
    PatBlt(hDC, 0, yHi, xWi, -1, BLACKNESS);

    // 1,  v
    PatBlt(hDC, xWi, 0, -1, yHi, BLACKNESS);

    xWi -= 2;
    yHi -= 2;

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 2, ->
    PatBlt(hDC, 1, 1, xWi, 1, PATCOPY);

    // 2, v
    PatBlt(hDC, 1, 1, 1, yHi, PATCOPY);

    // 2,  v
    PatBlt(hDC, xWi + 1, 1, -1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // 2, _>
    PatBlt(hDC, 1, yHi + 1, xWi, -1, PATCOPY);

    xWi -= 2;
    yHi -= 2;

    // 3, ->
    PatBlt(hDC, 2, 2, xWi, 1, PATCOPY);

    // 3, v
    PatBlt(hDC, 2, 2, 1, yHi, PATCOPY);

    // 3,  v
    PatBlt(hDC, xWi + 2, 3, -1, yHi - 1, WHITENESS);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 3, _>
    PatBlt(hDC, 2, yHi + 2, xWi, -1, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    xWi -= 2;
    yHi -= 2;

    // 4, ->
    PatBlt(hDC, 3, 3, xWi, 1, PATCOPY);

    // 4, v
    PatBlt(hDC, 3, 3, 1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 4,  v
    PatBlt(hDC, xWi + 3, 4, -1, yHi - 1, PATCOPY);

    // 4, _>
    PatBlt(hDC, 3, yHi + 3, xWi, -1, WHITENESS);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\imedefs.h ===
/*************************************************
 *  imedefs.h                                    *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

// debug flag
#define DEB_FATAL               0
#define DEB_ERR                 1
#define DEB_WARNING             2
#define DEB_TRACE               3

#ifdef _WIN32
void FAR cdecl _DebugOut(UINT, LPCSTR, ...);
#endif

#define NATIVE_CHARSET          ANSI_CHARSET
#define NATIVE_LANGUAGE         0x0409


#ifdef UNICODE
#define NATIVE_CP               1200
#define ALT_NATIVE_CP           938
#define MAX_EUDC_CHARS          6217
#else
#define NATIVE_CP               950
#define ALT_NATIVE_CP           938
#define MAX_EUDC_CHARS          5809
#endif


#define SIGN_CWIN               0x4E495743
#define SIGN__TBL               0x4C42545F



// table load status
#define TBL_NOTLOADED           0
#define TBL_LOADED              1
#define TBL_LOADERR             2

// error MessageBox flags
#define ERRMSG_LOAD_0           0x0010
#define ERRMSG_LOAD_1           0x0020
#define ERRMSG_LOAD_2           0x0040
#define ERRMSG_LOAD_3           0x0080
#define ERRMSG_LOAD_USRDIC      0x0400
#define ERRMSG_MEM_0            0x1000
#define ERRMSG_MEM_1            0x2000
#define ERRMSG_MEM_2            0x4000
#define ERRMSG_MEM_3            0x8000
#define ERRMSG_MEM_USRDIC       0x00040000


// hack flag, I borrow one bit from fdwErrMsg for reverse conversion
#define NO_REV_LENGTH           0x80000000


// state of composition
#define CST_INIT                0
#define CST_INPUT               1
#define CST_CHOOSE              2
#define CST_SYMBOL              3
#define CST_ALPHABET            4           // not in iImeState


#define CST_ALPHANUMERIC        6           // not in iImeState
#define CST_INVALID             7           // not in iImeState
#define CST_BLOCKINPUT          8           // not in iImeState

#define CST_IME_HOTKEYS         0x40        // not in iImeState
#define CST_RESEND_RESULT       (CST_IME_HOTKEYS)
#define CST_PREVIOUS_COMP       (CST_IME_HOTKEYS+1)
#define CST_TOGGLE_UI           (CST_IME_HOTKEYS+2)

// IME specific constants
#define CANDPERPAGE             9

#define CHOOSE_PREVPAGE         0x10
#define CHOOSE_NEXTPAGE         0x11
#define CHOOSE_CIRCLE           0x12
#define CHOOSE_HOME             0x13

#define MAXSTRLEN               32
#define MAXCAND                 256

#define CAND_PROMPT_PHRASE      0
#define CAND_PROMPT_QUICK_VIEW  1
#define CAND_PROMPT_NORMAL      2

// max composition ways of one big5 code, it is for reverse conversion
#if defined(ROMANIME)
#define MAX_COMP                0
#elif defined(WINIME)
#define MAX_COMP                1
#else
#define MAX_COMP                10
#endif
#define MAX_COMP_BUF            10

// border for UI
#define UI_MARGIN               4

#define STATUS_DIM_X            24
#define STATUS_DIM_Y            24

#define CAND_PROMPT_DIM_X       80
#define CAND_PROMPT_DIM_Y       16

#define PAGE_DIM_X              16
#define PAGE_DIM_Y              CAND_PROMPT_DIM_Y

// if UI_MOVE_OFFSET == WINDOW_NOTDRAG, not in drag operation
#define WINDOW_NOT_DRAG         0xFFFFFFFF

// window extra for composition window
#define UI_MOVE_OFFSET          0
#define UI_MOVE_XY              4

// window extra for context menu owner
#define CMENU_HUIWND            0
#define CMENU_MENU              4

#define WM_USER_DESTROY         (WM_USER + 0x0400)
#define WM_USER_UICHANGE        (WM_USER + 0x0401)

// the flags for GetNearCaretPosition
#define NEAR_CARET_FIRST_TIME   0x0001
#define NEAR_CARET_CANDIDATE    0x0002

// the flag for an opened or start UI
#define IMN_PRIVATE_TOGGLE_UI           0x0001
#define IMN_PRIVATE_CMENUDESTROYED      0x0002

#define IMN_PRIVATE_COMPOSITION_SIZE    0x0003
#define IMN_PRIVATE_UPDATE_PREDICT      0x0004
#define IMN_PRIVATE_UPDATE_SOFTKBD      0x0006
#define IMN_PRIVATE_PAGEUP              0x0007

#define MSG_COMPOSITION                 0x0000001

#define MSG_START_COMPOSITION           0x0000002
#define MSG_END_COMPOSITION             0x0000004
#define MSG_ALREADY_START               0x0000008
#define MSG_CHANGE_CANDIDATE            0x0000010
#define MSG_OPEN_CANDIDATE              0x0000020
#define MSG_CLOSE_CANDIDATE             0x0000040
#define MSG_ALREADY_OPEN                0x0000080
#define MSG_GUIDELINE                   0x0000100
#define MSG_IMN_COMPOSITIONPOS          0x0000200
#define MSG_IMN_COMPOSITIONSIZE         0x0000400
#define MSG_IMN_UPDATE_PREDICT          0x0000800
#define MSG_IMN_UPDATE_SOFTKBD          0x0002000
#define MSG_ALREADY_SOFTKBD             0x0004000
#define MSG_IMN_PAGEUP                  0x0008000

// original reserve for old array, now we switch to new, no one use yet
#define MSG_CHANGE_CANDIDATE2           0x1000000
#define MSG_OPEN_CANDIDATE2             0x2000000
#define MSG_CLOSE_CANDIDATE2            0x4000000
#define MSG_ALREADY_OPEN2               0x8000000

#define MSG_STATIC_STATE                (MSG_ALREADY_START|MSG_ALREADY_OPEN|MSG_ALREADY_SOFTKBD|MSG_ALREADY_OPEN2)

#define MSG_IMN_TOGGLE_UI               0x0400000
#define MSG_IN_IMETOASCIIEX             0x0800000

#define ISC_HIDE_COMP_WINDOW            0x00400000
#define ISC_HIDE_CAND_WINDOW            0x00800000
#define ISC_HIDE_SOFTKBD                0x01000000
#define ISC_LAZY_OPERATION              (ISC_HIDE_COMP_WINDOW|ISC_HIDE_CAND_WINDOW|ISC_HIDE_SOFTKBD)
#define ISC_SHOW_SOFTKBD                0x02000000
#define ISC_OPEN_STATUS_WINDOW          0x04000000
#define ISC_OFF_CARET_UI                0x08000000
#define ISC_SHOW_PRIV_UI                (ISC_SHOW_SOFTKBD|ISC_OPEN_STATUS_WINDOW|ISC_OFF_CARET_UI)
#define ISC_SHOW_UI_ALL                 (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD|ISC_OPEN_STATUS_WINDOW)
#define ISC_SETCONTEXT_UI               (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD)

#if (ISC_SHOWUIALL & (ISC_LAZY_OPERATION|ISC_SHOW_PRIV_UI))
#error bit confliction
#endif



// the virtual key value
#define VK_OEM_SEMICLN                  0xba    //  ;    :
#define VK_OEM_EQUAL                    0xbb    //  =    +
#define VK_OEM_COMMA                    0xBC    //  ,    <
#define VK_OEM_MINUS                    0xBD    //  -    _
#define VK_OEM_PERIOD                   0xBE    //  .    >
#define VK_OEM_SLASH                    0xBF    //  /    ?
#define VK_OEM_3                        0xC0    //  `    ~
#define VK_OEM_LBRACKET                 0xdb    //  [    {
#define VK_OEM_BSLASH                   0xdc    //  \    |
#define VK_OEM_RBRACKET                 0xdd    //  ]    }
#define VK_OEM_QUOTE                    0xde    //  '    "


typedef DWORD UNALIGNED FAR *LPUNADWORD;
typedef WORD  UNALIGNED FAR *LPUNAWORD;
typedef WCHAR UNALIGNED *LPUNAWSTR;

#define NFULLABC        95
typedef struct tagFullABC {
    WORD wFullABC[NFULLABC];
} FULLABC;

typedef FULLABC      *PFULLABC;
typedef FULLABC NEAR *NPFULLABC;
typedef FULLABC FAR  *LPFULLABC;


#define NSYMBOL         0x40

typedef struct tagSymbol {
    WORD wSymbol[NSYMBOL];
} SYMBOL;

typedef SYMBOL      *PSYMBOL;
typedef SYMBOL NEAR *NPSYMBOL;
typedef SYMBOL FAR  *LPSYMBOL;


#define NUM_OF_IME_HOTKEYS      3

#define MAX_NAME_LENGTH         32

typedef struct tagImeG {        // global structure, can be shared by all
                                // IMEs, the seperation (IMEL and IMEG) is
                                // only useful in UNI-IME, other IME can use
                                // one data structure
    RECT        rcWorkArea;     // the work area of applications
// full shape space (reversed internal code)
    WORD        wFullSpace;
// full shape chars (internal code)
    WORD        wFullABC[NFULLABC];
    UINT        uAnsiCodePage;
// the system charset is not NATIVE_CHARSET
    BOOL        fDiffSysCharSet;
// Chinese char width & height
    int         xChiCharWi;
    int         yChiCharHi;
// symbol chars (internal code)
    WORD        wSymbol[NSYMBOL];
// setting of UI
    int         iPara;
    int         iPerp;
    int         iParaTol;
    int         iPerpTol;
} IMEG;

typedef IMEG      *PIMEG;
typedef IMEG NEAR *NPIMEG;
typedef IMEG FAR  *LPIMEG;


typedef struct tagPRIVCONTEXT { // IME private data for each context
    BOOL        fdwImeMsg;      // what messages should be generated
    DWORD       dwCompChar;     // wParam of WM_IME_COMPOSITION
    DWORD       fdwGcsFlag;     // lParam for WM_IME_COMPOSITION
    DWORD       fdwInit;        // position init
    int         iImeState;      // the composition state - input, choose, or
// input data
    BYTE        bSeq[8];        // sequence code of input char
    DWORD       dwPattern;
    int         iInputEnd;
// the previous dwPageStart before page up
    DWORD       dwPrevPageStart;
} PRIVCONTEXT;

typedef PRIVCONTEXT      *PPRIVCONTEXT;
typedef PRIVCONTEXT NEAR *NPPRIVCONTEXT;
typedef PRIVCONTEXT FAR  *LPPRIVCONTEXT;


typedef struct tagUIPRIV {      // IME private UI data
    HWND    hCompWnd;           // composition window
    int     nShowCompCmd;
    HWND    hCandWnd;           // candidate window for composition
    int     nShowCandCmd;
    HWND    hSoftKbdWnd;        // soft keyboard window
    int     nShowSoftKbdCmd;
    HWND    hStatusWnd;         // status window
    int     nShowStatusCmd;
    DWORD   fdwSetContext;      // the actions to take at set context time
    HIMC    hCacheIMC;          // the recent selected hIMC
    HWND    hCMenuWnd;          // a window owner for context menu
} UIPRIV;

typedef UIPRIV      *PUIPRIV;
typedef UIPRIV NEAR *NPUIPRIV;
typedef UIPRIV FAR  *LPUIPRIV;


typedef struct tagNEARCARET {   // for near caret offset calculatation
    int iLogFontFacX;
    int iLogFontFacY;
    int iParaFacX;
    int iPerpFacX;
    int iParaFacY;
    int iPerpFacY;
} NEARCARET;

typedef NEARCARET      *PNEARCARET;
typedef NEARCARET NEAR *NPNEARCARET;
typedef NEARCARET FAR  *LPNEARCARET;


#ifndef RC_INVOKED
#pragma pack(1)
#endif

typedef struct tagMETHODNAME {
    BYTE  achMethodName[6];
} METHODNAME;

typedef METHODNAME      *PMETHODNAME;
typedef METHODNAME NEAR *NPMETHODNAME;
typedef METHODNAME FAR  *LPMETHODNAME;


#ifndef RC_INVOKED
#pragma pack()
#endif



extern HINSTANCE   hInst;


extern IMEG        sImeG;


extern int iDx[3 * CANDPERPAGE];

extern const TCHAR szDigit[];

extern const BYTE  bUpper[];
extern const WORD  fMask[];

extern const TCHAR szRegNearCaret[];
extern const TCHAR szPhraseDic[];
extern const TCHAR szPhrasePtr[];
extern const TCHAR szPerp[];
extern const TCHAR szPara[];
extern const TCHAR szPerpTol[];
extern const TCHAR szParaTol[];
extern const NEARCARET ncUIEsc[], ncAltUIEsc[];
extern const POINT ptInputEsc[], ptAltInputEsc[];

extern const TCHAR szRegRevKL[];
extern const TCHAR szRegUserDic[];

extern const TCHAR szRegAppUser[];
extern const TCHAR szRegModeConfig[];

extern const BYTE  bChar2VirtKey[];



int WINAPI LibMain(HANDLE, WORD, WORD, LPSTR);                  // init.c
void PASCAL InitImeUIData(LPIMEL);                              // init.c
void PASCAL SetCompLocalData(LPIMEL);                           // init.c

void PASCAL SetUserSetting(
            LPCTSTR, DWORD, LPBYTE, DWORD);                     // init.c


void PASCAL AddCodeIntoCand(LPCANDIDATELIST, UINT);             // compose.c

void PASCAL CompWord(
            WORD, HIMC, LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPGUIDELINE, LPPRIVCONTEXT);                        // compose.c

UINT PASCAL Finalize(
            HIMC, LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPPRIVCONTEXT, BOOL);                               // compose.c

void PASCAL CompEscapeKey(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
             LPPRIVCONTEXT);                                   // compose.c


void PASCAL InitCompStr(LPCOMPOSITIONSTRING);                   // ddis.c
BOOL PASCAL ClearCand(LPINPUTCONTEXT);                          // ddis.c

BOOL PASCAL Select(
            LPINPUTCONTEXT, BOOL);                              // ddis.c

UINT PASCAL TranslateImeMessage(LPTRANSMSGLIST, LPINPUTCONTEXT,
            LPPRIVCONTEXT);                                     // toascii.c

void PASCAL GenerateMessage(HIMC, LPINPUTCONTEXT,
            LPPRIVCONTEXT);                                     // notify.c

void PASCAL CompCancel(HIMC, LPINPUTCONTEXT);                   // notify.c


BOOL PASCAL LoadTable(LPINSTDATAL, LPIMEL);                     // dic.c
void PASCAL FreeTable(LPINSTDATAL);                             // dic.c



void PASCAL SearchTbl(
            UINT, LPCANDIDATELIST, LPPRIVCONTEXT);              // search.c



void    PASCAL DrawDragBorder(HWND, LONG, LONG);                // uisubs.c
void    PASCAL DrawFrameBorder(HDC, HWND);                      // uisubs.c


HWND    PASCAL GetCompWnd(HWND);                                // compui.c

void    PASCAL GetNearCaretPosition(
               LPPOINT, UINT, UINT, LPPOINT, LPPOINT, BOOL);    // compui.c

BOOL    PASCAL AdjustCompPosition(
               LPINPUTCONTEXT, LPPOINT, LPPOINT);               // compui.c

void    PASCAL SetCompPosition(
               HWND, LPINPUTCONTEXT);                           // compui.c

void    PASCAL SetCompWindow(
               HWND);                                           // compui.c

void    PASCAL MoveDefaultCompPosition(
               HWND);                                           // compui.c

void    PASCAL ShowComp(
               HWND, int);                                      // compui.c

void    PASCAL CreateCompWindow(HWND);                          // compui.c

void    PASCAL ChangeCompositionSize(
               HWND);                                           // compui.c

void PASCAL SelectOneCand(
            HIMC, LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
            LPPRIVCONTEXT, LPCANDIDATELIST);

LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);         // ui.c

LRESULT CALLBACK CompWndProc(HWND, UINT, WPARAM, LPARAM);       // compui.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\usa\ui.c ===
/*************************************************
 *  ui.c                                         *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

#include <windows.h>
#include <immdev.h>
#include "imeattr.h"
#include "imedefs.h"

/**********************************************************************/
/* CreateUIWindow()                                                   */
/**********************************************************************/
void PASCAL CreateUIWindow(             // create composition window
    HWND   hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // create storage for UI setting
    hUIPrivate = GlobalAlloc(GHND, sizeof(UIPRIV));
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)hUIPrivate);

    // set the default position for UI window, it is hide now
    SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);

    ShowWindow(hUIWnd, SW_SHOWNOACTIVATE);

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* DestroyUIWindow()                                                  */
/**********************************************************************/
void PASCAL DestroyUIWindow(            // destroy composition window
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    // composition window need to be destroyed
    if (lpUIPrivate->hCompWnd) {
        DestroyWindow(lpUIPrivate->hCompWnd);
    }

    GlobalUnlock(hUIPrivate);

    // free storage for UI settings
    GlobalFree(hUIPrivate);

    return;
}

/**********************************************************************/
/* ShowUI()                                                           */
/**********************************************************************/
void PASCAL ShowUI(             // show the sub windows
    HWND   hUIWnd,
    int    nShowCmd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    if (nShowCmd == SW_HIDE) {
    } else if (!(hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
        ImmUnlockIMC(hIMC);
        nShowCmd = SW_HIDE;
    } else {
    }

    if (nShowCmd == SW_HIDE) {

        ShowComp(hUIWnd, nShowCmd);
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        goto ShowUIUnlockIMCC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        goto ShowUIUnlockIMCC;
    }

    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW)
#if 0
        && (lpImcP->fdwImeMsg & MSG_ALREADY_START)
#endif
        ) {
        if (lpUIPrivate->hCompWnd) {
            if ((UINT)GetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY) !=
                lpImeL->nRevMaxKey) {
                ChangeCompositionSize(hUIWnd);
            }

            if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                // some time the WM_ERASEBKGND is eaten by the app
                RedrawWindow(lpUIPrivate->hCompWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            SendMessage(lpUIPrivate->hCompWnd, WM_IME_NOTIFY,
                IMN_SETCOMPOSITIONWINDOW, 0);

            if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
                ShowComp(hUIWnd, nShowCmd);
            }
        } else {
            CreateCompWindow(hUIWnd);
        }
    } else if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        // delay the hide with status window
        lpUIPrivate->fdwSetContext |= ISC_HIDE_COMP_WINDOW;
    } else {
        ShowComp(hUIWnd, SW_HIDE);
    }

    if (lpIMC->fdwInit & INIT_SENTENCE) {
        // app set the sentence mode so we should not change it
        // with the configure option set by end user
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) {
        if (!(lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT)) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPWORD)&fdwSentence |= IME_SMODE_PHRASEPREDICT;

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    } else {
        if (lpIMC->fdwSentence & IME_SMODE_PHRASEPREDICT) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPWORD)&fdwSentence &= ~(IME_SMODE_PHRASEPREDICT);

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    }

    // we switch to this hIMC
    lpUIPrivate->hCacheIMC = hIMC;

    GlobalUnlock(hUIPrivate);

ShowUIUnlockIMCC:
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return;
}


/**********************************************************************/
/* NotifyUI()                                                         */
/**********************************************************************/
void PASCAL NotifyUI(
    HWND        hUIWnd,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hStatusWnd;

    switch (wParam) {
    case IMN_SETSENTENCEMODE:
        break;
    case IMN_SETCOMPOSITIONFONT:
        // we are not going to change font, but an IME can do this if it want
        break;
    case IMN_SETCOMPOSITIONWINDOW:

//        if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI))
        {
            HWND hCompWnd;

            hCompWnd = GetCompWnd(hUIWnd);
            if (!hCompWnd) {
                return;
            }

            PostMessage(hCompWnd, WM_IME_NOTIFY, wParam, lParam);
       }
        break;
    case IMN_PRIVATE:
        switch (lParam) {
        case IMN_PRIVATE_COMPOSITION_SIZE:
            ChangeCompositionSize(
                hUIWnd);
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    return;
}

/**********************************************************************/
/* UIChange()                                                         */
/**********************************************************************/
LRESULT PASCAL UIChange(
    HWND        hUIWnd)
{
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return (0L);
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return (0L);
    }

    if (lpUIPrivate->fdwSetContext & ISC_SHOW_UI_ALL) {
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowUI(hUIWnd, SW_HIDE);
    }

    GlobalUnlock(hUIPrivate);

    return (0L);
}

/**********************************************************************/
/* SetContext()                                                       */
/**********************************************************************/
void PASCAL SetContext(         // the context activated/deactivated
    HWND        hUIWnd,
    BOOL        fOn,
    LPARAM      lShowUI)
{
    HGLOBAL  hUIPrivate;

    register LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (fOn) {
        HIMC           hIMC;
        LPINPUTCONTEXT lpIMC;

        register DWORD fdwSetContext;

        lpUIPrivate->fdwSetContext = lpUIPrivate->fdwSetContext &
            ~(ISC_SHOWUIALL|ISC_HIDE_SOFTKBD);

        lpUIPrivate->fdwSetContext |= (lShowUI & ISC_SHOWUIALL) |
            ISC_SHOW_SOFTKBD;

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
                hUIWnd, SW_HIDE);
        } else if (fdwSetContext & ISC_HIDE_COMP_WINDOW) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
        } else {
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);


        hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

        if (!hIMC) {
            goto SetCxtUnlockUIPriv;
        }

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

        if (!lpIMC) {
            goto SetCxtUnlockUIPriv;
        }

        if (lpIMC->cfCandForm[0].dwIndex != 0) {
            lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;
        }

        ImmUnlockIMC(hIMC);
    } else {
        lpUIPrivate->fdwSetContext &= ~ISC_SETCONTEXT_UI;
    }

SetCxtUnlockUIPriv:
    GlobalUnlock(hUIPrivate);

    UIChange(
        hUIWnd);

    return;
}

/**********************************************************************/
/* GetCompWindow()                                                    */
/**********************************************************************/
LRESULT PASCAL GetCompWindow(
    HWND              hUIWnd,
    LPCOMPOSITIONFORM lpCompForm)
{
    HWND           hCompWnd;
    RECT           rcCompWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return (1L);
    }

    if (!GetWindowRect(hCompWnd, &rcCompWnd)) {
        return (1L);
    }

    lpCompForm->dwStyle = CFS_RECT;
    lpCompForm->ptCurrentPos = *(LPPOINT)&rcCompWnd;
    lpCompForm->rcArea = rcCompWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

    if (!lpIMC) {
        return (1L);
    }

    ScreenToClient(lpIMC->hWnd, &lpCompForm->ptCurrentPos);

    lpCompForm->rcArea.right += lpCompForm->ptCurrentPos.x -
        lpCompForm->rcArea.left;

    lpCompForm->rcArea.bottom += lpCompForm->ptCurrentPos.y -
        lpCompForm->rcArea.top;

    *(LPPOINT)&lpCompForm->rcArea = lpCompForm->ptCurrentPos;

    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* UIWndProc() / UniUIWndProc()                                       */
/**********************************************************************/
LRESULT CALLBACK UIWndProc(
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_CREATE:
        CreateUIWindow(hUIWnd);
        break;
    case WM_DESTROY:
        DestroyUIWindow(hUIWnd);
        break;
    case WM_IME_STARTCOMPOSITION:
        //
        //  Create a window as the composition window.
        //
        CreateCompWindow(hUIWnd);
        break;
    case WM_IME_COMPOSITION:
    {
        HWND hCompWnd;
        if (lParam & GCS_RESULTSTR)
        {
            MoveDefaultCompPosition(hUIWnd);
        }

        hCompWnd = GetCompWnd(hUIWnd);

        if (hCompWnd)
        {
            RECT rcRect;

            rcRect = lpImeL->rcCompText;
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

           RedrawWindow(hCompWnd, &rcRect, NULL, RDW_INVALIDATE);
        }
        break;
    }
    case WM_IME_ENDCOMPOSITION:
        //
        //  We can destroy the composition window here. But we don't have a
        //  status window.  So we keep the composition window displayed
        //  to show our presence.
        //
        return (0L);
    case WM_IME_NOTIFY:
        NotifyUI(hUIWnd, wParam, lParam);
        break;
    case WM_IME_SETCONTEXT:
        SetContext(hUIWnd, (BOOL)wParam, lParam);
        break;
    case WM_IME_CONTROL:
        switch (wParam) {
        case IMC_GETCOMPOSITIONWINDOW:
            return GetCompWindow(hUIWnd, (LPCOMPOSITIONFORM)lParam);
        }
    case WM_IME_COMPOSITIONFULL:
        return (0L);
    case WM_IME_SELECT:
        //
        // try to use SetContext
        // SelectIME(hUIWnd, (BOOL)wParam);
        //
        SetContext( hUIWnd, (BOOL)wParam, 0);
        //
        //  We want a comp window immediately after IME starts.
        //
        CreateCompWindow(hUIWnd);
        return (0L);
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    case WM_USER_UICHANGE:
        return UIChange(
            hUIWnd);
    default:
        return DefWindowProc(hUIWnd, uMsg, wParam, lParam);
    }
    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\cks32.h ===
VOID	FAR PASCAL Checksum32( DWORD FAR *lpChksum,
			    BYTE FAR *lpData, WORD wLength );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\cmdlnpth.h ===
VOID FAR PASCAL CheckConfigFileCmdLine( LPSTR lpszCmdLine, 
				LPSTR lpszCfgPath, int nMaxString );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\critsec.h ===
extern CRITICAL_SECTION csNetDde;

#define EnterCrit() (EnterCriticalSection(&csNetDde))
#define LeaveCrit() (LeaveCriticalSection(&csNetDde))
#define CheckCritIn() assert((HANDLE)(ULONG_PTR)GetCurrentThreadId() == csNetDde.OwningThread)
#define CheckCritOut() assert((HANDLE)(ULONG_PTR)GetCurrentThreadId() != csNetDde.OwningThread)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\crc.h ===
/* $Header: "Ver=%v  %f  LastEdit=%w  Locker=%l" */
/* "Ver=1  16-Dec-92,10:03:32  LastEdit=IGOR  Locker=***_NOBODY_***" */
void FAR PASCAL one_crc_16( WORD FAR *, BYTE );
void FAR PASCAL crc_16( WORD FAR *, BYTE FAR *, int);
void FAR PASCAL one_crc_ccitt(WORD FAR *, BYTE );
void FAR PASCAL crc_ccitt(WORD FAR *, BYTE FAR *, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\dbgdde.h ===
VOID	FAR PASCAL DebugDDEMessage( PSTR, HWND, UINT, WPARAM, LPARAM );
extern BOOL	bDebugDDE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\api1632.h ===
#ifndef H__api1632
#define H__api1632


/* Wonderware additions....  */

#ifdef WIN32

// ignore nb30.h
#define NCB_INCLUDED

// ignore wwheap.h
#define H__wwheap
typedef unsigned long HHEAP;

#define hmemcpy(d,s,l) memcpy(d,s,l)
#define GlobalPtrHandle(x)      \
            (GlobalHandle(x))
#define HeapAllocPtr(x,y,z) \
            (GlobalLock(GlobalAlloc(y,z)))
#define HeapFreePtr(p) \
            (GlobalUnlock(GlobalHandle(p)), GlobalFree(GlobalHandle(p)))
#define HeapInit() (1)

#define _fstrncpy strncpy
#define _fstrcpy  strcpy
#define _fstrncmp strncmp
#define _fstrnicmp _strnicmp
#define _fstricmp _stricmp
#define _fstrupr  _strupr
#define _fstrchr  strchr
#define _fstrrchr strrchr
#define _fstrcat  strcat
#define _fstrlen  strlen
#define _fmemcpy  memcpy
#define _fmemset  memset
#define _fstrstr  strstr
#define _fstrpbrk strpbrk

#define MoveTo(h,x,y) MoveToEx(h,x,y,NULL)

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\csv.h ===
PSTR FAR PASCAL CsvToken( PSTR pszBuf );
BOOL FAR PASCAL TokenBool( PSTR pszToken, BOOL bDefault );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\ddeapi.h ===
BOOL	FAR PASCAL DdeNetAvailable( void );
BOOL	FAR PASCAL DdeIsInitiateNetRelated( void );
VOID	FAR PASCAL DdeGetOurNodeName( LPSTR lpszNodeName, int nMax );
VOID	FAR PASCAL DdeGetClientNode( HWND hWndClient, 
		    LPSTR lpszNodeName, int nMax );
VOID	FAR PASCAL DdeGetClientApp( HWND hWndClient, 
		    LPSTR lpszAppName, int nMax );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\ddecall.h ===
typedef HWND	HDDECALL;
typedef HDDECALL FAR *LPHDDECALL;

WORD FAR PASCAL DDECall( LPSTR		lpszApplication,
			 LPSTR		lpszTopic,
			 HANDLE		hMemDataSend,
			 LPHANDLE	lphMemDataRtn );

WORD FAR PASCAL DDECallEstablishConversation( LPSTR lpszApplication,
    LPSTR lpszTopic, LPHDDECALL lphDDECall );

WORD FAR PASCAL DDECallSynchronous( HDDECALL hDDECall,
    HANDLE hMemDataSend, LPHANDLE lphMemDataRtn );

WORD FAR PASCAL DDECallTerminate( HDDECALL hDDECall );

#define DDC_OK					0
#define DDC_CONVERSATION_NOT_INITIATED		1
#define DDC_DDE_CALLS_NOT_SUPPORTED		2
#define DDC_PREMATURE_TERMINATION		3
#define DDC_OUT_OF_MEMORY			4

#define DDC_USER_ERROR			    20000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\ddepkt.h ===
#ifndef H__ddepkt
#define H__ddepkt

/*
    D D E P K T
	
	DDEPKT is the unit of "message" in the netdde environment.
	Each DDEPKT contains the information pertaining to one DDE message.
 */
typedef struct ddepkt {
    DWORD		dp_size;	/* size of DDEPKT including this structure */
    struct ddepkt FAR  *dp_prev;	/* previous pointer */
    struct ddepkt FAR  *dp_next;	/* next pointer */
    DWORD_PTR	dp_hDstDder;	/* handle to destination DDER */
    DWORD_PTR	dp_hDstRouter;	/* handle to destination Router */
    DWORD		dp_routerCmd;	/* command for final Router */
} DDEPKT;
typedef DDEPKT FAR *LPDDEPKT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\dder.h ===
#ifndef H__dder
#define H__dder

/*	Calls from Router */
VOID	DderConnectionComplete( HDDER hDder, HROUTER hRouter );
VOID	DderConnectionBroken( HDDER hDder );
VOID	DderPacketFromRouter( HROUTER hRouter, LPDDEPKT lpDdePkt );
VOID	DderSetNextForRouter( HDDER hDder, HDDER hDderNext );
VOID	DderSetPrevForRouter( HDDER hDder, HDDER hDderPrev );
VOID	DderGetNextForRouter( HDDER hDder, HDDER FAR *lphDderNext );
VOID	DderGetPrevForRouter( HDDER hDder, HDDER FAR *lphDderPrev );

/*	Calls from IPC */
VOID	DderPacketFromIPC( HDDER hDder, HIPC hIpc, LPDDEPKT lpDdePkt );
HDDER	DderInitConversation( HIPC hIpc, HROUTER hRouter, LPDDEPKT lpDdePkt );
VOID	DderCloseConversation( HDDER hDder, HIPC hIpcFrom );

/*
    types
 */
#define DDTYPE_LOCAL_NET        (1)     /* local -> net */
#define DDTYPE_NET_LOCAL        (2)     /* net -> local */
#define DDTYPE_LOCAL_LOCAL      (3)     /* local -> local */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\fixfont.h ===
#ifndef H__fixfont
#define H__fixfont

HFONT FAR PASCAL GetFixedSystemFont( void );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\getglobl.h ===
#ifndef H__getglobl
#define H__getglobl

HANDLE FAR PASCAL GetGlobalAlloc( WORD, DWORD );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\debug.h ===
#ifndef H__debug
#define H__debug

/*
    Any functions that use windows.h types must be put in the 2nd section
 */

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void    debug(char *, ...);
void    DebugInit( char * lpszDebugName );
#else
void    _cdecl  debug(char *, ...);
void    __stdcall DebugInit( char * lpszDebugName );
#endif

#if DBG
#define DPRINTF(x)  debug x
#define DIPRINTF(x)  if (bDebugInfo) debug x
#define HEXDUMP(s, n) hexDump(s, n)
#define MEMERROR() NDDELogError(MSG417, __LINE__, __FILE__, NULL);
#else
#define DPRINTF(x)
#define DIPRINTF(x)
#define HEXDUMP(s, n)
#define MEMERROR()
#endif // DBG

#ifndef SKIP_DEBUG_WIN32
/*  dump.c functions */

BOOL    DumpDacl( LPTSTR szDumperName, PSECURITY_DESCRIPTOR pSD );
BOOL    DumpSid( LPTSTR szDumperName, PSID pSid );
VOID    DumpToken( HANDLE hToken );
BOOL    GetTokenUserDomain( HANDLE hToken, PSTR user, DWORD nUser,
            PSTR domain, DWORD nDomain );
VOID    DumpWhoIAm( LPSTR lpszMsg );
#endif // SKIP_DEBUG_WIN32

// #define DEBUG_IT
#ifndef DEBUG_IT
#define TRACEINIT(x)
#else
#define TRACEINIT(x) { char sz[100]; \
    char *szT; \
    wsprintfA(sz, "pid=%x, tid=%x | ", GetCurrentProcessId(), GetCurrentThreadId()); \
    szT = sz + strlen(sz); \
    wsprintfA##x; \
    strcat(szT, "\n"); \
    OutputDebugString(sz); \
    }
#endif

#endif // H__debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\ddepkts.h ===
#ifndef H__ddepkts
#define H__ddepkts

#ifndef H__ddepkt
#include    "ddepkt.h"
#define H__ddepkt
#endif

#define PQOS PSECURITY_QUALITY_OF_SERVICE
#define QOS SECURITY_QUALITY_OF_SERVICE

/*
    DDEPKTCMN           common information for all DDE message packets
 */
typedef struct {
    DDEPKT      dc_ddePkt;
    WORD        dc_message;
    WORD        dc_filler1;
    DWORD       dc_hConvSrc;
    DWORD       dc_hConvDst;
} DDEPKTCMN;
typedef DDEPKTCMN FAR *LPDDEPKTCMN;

/*
    DDEPKTINIT          initiate packet
 */
typedef struct {
    DDEPKTCMN   dp_init_ddePktCmn;
    HDDER       dp_init_fromDder;
    WORD        dp_init_offsFromNode;
    WORD        dp_init_offsFromApp;
    WORD        dp_init_offsToNode;
    WORD        dp_init_offsToApp;
    WORD        dp_init_offsToTopic;
    WORD        dp_init_offsPassword;
    DWORD       dp_init_hSecurityKey;
    DWORD       dp_init_dwSecurityType;
    DWORD       dp_init_sizePassword;
} DDEPKTINIT;
typedef DDEPKTINIT FAR *LPDDEPKTINIT;

/*
    DDEPKTSEC       defines the structure of "dp_init_offsPassword"
*/

typedef struct {
    WORD    dp_sec_offsUserName;
    WORD    dp_sec_sizeUserName;
    WORD    dp_sec_offsDomainName;
    WORD    dp_sec_sizeDomainName;
    WORD    dp_sec_offsPassword;
    WORD    dp_sec_sizePassword;
    WORD    dp_sec_offsQos;
    WORD    dp_sec_sizeQos;
} DDEPKTSEC;
typedef DDEPKTSEC FAR *LPDDEPKTSEC;

/*
    DDEPKTIACK          initiate ack packet
 */
typedef struct {
    DDEPKTCMN   dp_iack_ddePktCmn;
    HDDER       dp_iack_fromDder;
    DWORD       dp_iack_reason;
    DWORD       dp_iack_hSecurityKey;               /* replaced iack_prmXXXX */
    DWORD       dp_iack_dwSecurityType;             /* replaced iack_prmXXXX */
    WORD        dp_iack_offsFromNode;
    WORD        dp_iack_offsFromApp;
    WORD        dp_iack_offsFromTopic;
    WORD        dp_iack_offsSecurityKey;
    DWORD       dp_iack_sizeSecurityKey;
} DDEPKTIACK;
typedef DDEPKTIACK FAR *LPDDEPKTIACK;

#include    "sectype.h"

/*
    DDEPKTTERM          terminate packet
 */
typedef struct {
    DDEPKTCMN   dp_term_ddePktCmn;
} DDEPKTTERM;
typedef DDEPKTTERM FAR *LPDDEPKTTERM;

/*
    DDEPKTEXEC          execute packet
 */
typedef struct {
    DDEPKTCMN   dp_exec_ddePktCmn;
    char        dp_exec_string[ 1 ];
} DDEPKTEXEC;
typedef DDEPKTEXEC FAR *LPDDEPKTEXEC;

/*
    DDEPKTEACK          ack execute packet
 */
typedef struct {
    DDEPKTCMN   dp_eack_ddePktCmn;
    BYTE        dp_eack_fAck;
    BYTE        dp_eack_fBusy;
    BYTE        dp_eack_bAppRtn;
    BYTE        dp_eack_filler;
} DDEPKTEACK;
typedef DDEPKTEACK FAR *LPDDEPKTEACK;

/*
    DDEPKTGACK          generic ack packet
        
        used for
            WM_DDE_ACK_ADVISE
            WM_DDE_ACK_REQUEST
            WM_DDE_ACK_UNADVISE
            WM_DDE_ACK_POKE
            WM_DDE_ACK_DATA
 */
typedef struct {
    DDEPKTCMN   dp_gack_ddePktCmn;
    BYTE        dp_gack_fAck;
    BYTE        dp_gack_fBusy;
    BYTE        dp_gack_bAppRtn;
    char        dp_gack_itemName[ 1 ];
} DDEPKTGACK;
typedef DDEPKTGACK FAR *LPDDEPKTGACK;

/*
    DDEPKTRQST          request packet
 */
typedef struct {
    DDEPKTCMN   dp_rqst_ddePktCmn;
    WORD        dp_rqst_cfFormat;
    WORD        dp_rqst_offsFormat;
    WORD        dp_rqst_offsItemName;
    WORD        dp_rqst_filler;
} DDEPKTRQST;
typedef DDEPKTRQST FAR *LPDDEPKTRQST;

/*
    DDEPKTUNAD          unadvise packet
 */
typedef struct {
    DDEPKTCMN   dp_unad_ddePktCmn;
    WORD        dp_unad_cfFormat;
    WORD        dp_unad_offsFormat;
    WORD        dp_unad_offsItemName;
    WORD        dp_unad_filler;
} DDEPKTUNAD;
typedef DDEPKTUNAD FAR *LPDDEPKTUNAD;

/*
    DDEPKTADVS          advise packet
 */
typedef struct {
    DDEPKTCMN   dp_advs_ddePktCmn;
    WORD        dp_advs_cfFormat;
    WORD        dp_advs_offsFormat;
    WORD        dp_advs_offsItemName;
    BYTE        dp_advs_fAckReq;
    BYTE        dp_advs_fNoData;
} DDEPKTADVS;
typedef DDEPKTADVS FAR *LPDDEPKTADVS;

/*
    DDEPKTDATA          data packet
 */
typedef struct {
    DDEPKTCMN   dp_data_ddePktCmn;
    WORD        dp_data_cfFormat;
    WORD        dp_data_offsFormat;
    WORD        dp_data_offsItemName;
    WORD        dp_data_offsData;
    DWORD       dp_data_sizeData;
    BYTE        dp_data_fResponse;
    BYTE        dp_data_fAckReq;
    BYTE        dp_data_fRelease;
    BYTE        dp_data_filler;
} DDEPKTDATA;
typedef DDEPKTDATA FAR *LPDDEPKTDATA;

/*
    DDEPKTPOKE          poke packet
 */
typedef struct {
    DDEPKTCMN   dp_poke_ddePktCmn;
    WORD        dp_poke_cfFormat;
    WORD        dp_poke_offsFormat;
    WORD        dp_poke_offsItemName;
    WORD        dp_poke_offsData;
    DWORD       dp_poke_sizeData;
    BYTE        dp_poke_fRelease;
    BYTE        dp_poke_filler[ 3 ];
} DDEPKTPOKE;
typedef DDEPKTPOKE FAR *LPDDEPKTPOKE;

/*
    DDEPKTTEST          generic test packet
        
        used for
            WM_DDE_TEST
 */
typedef struct {
    DDEPKTCMN   dp_test_ddePktCmn;
    BYTE        dp_test_nTestNo;
    BYTE        dp_test_nPktNo;
    BYTE        dp_test_nTotalPkts;
    BYTE        dp_test_filler;
} DDEPKTTEST;
typedef DDEPKTTEST FAR *LPDDEPKTTEST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\getintg.h ===
#ifndef H__getintg
#define H__getintg

BOOL FAR PASCAL GetIntg( HWND, int, INTG * );
VOID FAR PASCAL PutIntg( HWND, int, INTG );
BOOL FAR PASCAL GetAndValidateIntg( HWND, int, INTG *, INTG, INTG );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\getradio.h ===
int FAR PASCAL GetRadioButton( HWND, int, int );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\hexdump.h ===
#ifndef H__hexdump
#define H__hexdump

VOID FAR PASCAL hexDump( LPSTR, int );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\host.h ===
#ifdef _WINDOWS
#define PcToHostLong(x) (x)
#define PcToHostWord(x) (x)
#define HostToPcLong(x) (x)
#define HostToPcWord(x) (x)
#ifdef WIN32
#include "api1632.h"
#define byte    unsigned char
#endif
#else
#ifdef VAX
#define PcToHostLong(x) (x)
#define PcToHostWord(x) (x)
#define HostToPcLong(x) (x)
#define HostToPcWord(x) (x)
#else
#define PcToHostLong(x)   ( (((x)&0xFF) << 24) |		\
			    ((((x)>>8)&0xFF) << 16) |		\
			    ((((x)>>16)&0xFF) << 8) |		\
			    ((((x)>>24)&0xFF)) )
#define HostToPcLong(x)   ( (((x)&0xFF) << 24) |		\
			    ((((x)>>8)&0xFF) << 16) |		\
			    ((((x)>>16)&0xFF) << 8) |		\
			    ((((x)>>24)&0xFF)) )
#define PcToHostWord(x) ( (((x)>>8) & 0xFF) | (((x) & 0xFF)<<8) )
#define HostToPcWord(x) ( (((x)>>8) & 0xFF) | (((x) & 0xFF)<<8) )
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\hardware.h ===
/* eliminate x86 specific compiler statements for other platforms */
/*      future versions should use undersore version of platform names */

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define __stdcall
#define _stdcall
#define stdcall
#define __cdecl
#define _cdecl
#define cdecl
#define __export
#define _export
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\hmemcpy.h ===
#ifdef WIN32
typedef char *  LPHSTR;
typedef void *  LPHVOID;
#else
typedef char huge*  LPHSTR;
typedef void huge*  LPHVOID;

VOID FAR PASCAL hmemcpy( LPVOID lpDest, const LPVOID lpSrc, 
			    DWORD dwSize );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\lmemclr.h ===
VOID FAR PASCAL lmemclear( LPSTR, int );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\internal.h ===
#ifndef H__internal
#define H__internal

VOID	FAR PASCAL	InternalErrorSetHWnd( HWND );
VOID	FAR PASCAL	InternalErrorSignOn( void );
VOID	FAR PASCAL	InternalErrorSignOff( void );
int	FAR PASCAL	InternalErrorNumUsers( void );
VOID  	FAR PASCAL 	InternalErrorStarted( void );
VOID  	FAR PASCAL 	InternalErrorDone( void );
BOOL  	FAR PASCAL 	InternalErrorAlreadyStarted( void );

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
VOID 	far 		InternalError(LPSTR, ...);
#else
VOID	far cdecl	InternalError(LPSTR, ...);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\ipc.h ===
#ifndef H__ipc
#define H__ipc

HIPC	IpcInitConversation( HDDER hDder, LPDDEPKT lpDdePkt, 
		BOOL bStartApp, LPSTR lpszCmdLine, WORD dd_type );
VOID	IpcAbortConversation( HIPC hIpc );
BOOL	IpcXmitPacket( HIPC hIpc, HDDER hDder, LPDDEPKT lpDdePkt );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\lmem.h ===
VOID  FAR PASCAL lmemcpy( LPSTR, LPSTR, int );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\nddeapip.h ===
UINT WINAPI
NDdeSpecialCommandA(
    LPSTR   lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *lpBytesDataOut
);

UINT WINAPI
NDdeSpecialCommandW(
    LPWSTR  lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *lpBytesDataOut
);

#ifdef UNICODE
#define NDdeSpecialCommand      NDdeSpecialCommandW
#else
#define NDdeSpecialCommand      NDdeSpecialCommandA
#endif

/*
 * These constants were enlarged to fix a bug in NetDDE
 * but for some reason they are exported in the public
 * nddeapi.h file so internally we use these private
 * constants instead.
 */
#define MAX_DOMAINNAMEP          31
#define MAX_USERNAMEP            (15 + MAX_DOMAINNAME + 3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

nddemsg.h nddemsg.rc: nddemsg.mc
	mc -v -h $(O) nddemsg.mc -r $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\nddemsg.c ===
#include "windows.h"

int
WinMain( HINSTANCE x, HINSTANCE y, LPSTR z, int a )
{
return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\nddelog.h ===
#define MAX_VAR_ARGS    16
#define MAX_LOG_STRING  64

VOID NDDELogErrorA(DWORD EventId, ...);
VOID NDDELogWarningA(DWORD EventId, ...);
VOID NDDELogInfoA(DWORD EventId, ...);
VOID NDDELogDataA(DWORD EventId, DWORD cbData, LPVOID lpvData);
LPSTR LogStringA(LPSTR szFormat, ...);

VOID NDDELogErrorW(DWORD EventId, ...);
VOID NDDELogWarningW(DWORD EventId, ...);
VOID NDDELogInfoW(DWORD EventId, ...);
VOID NDDELogDataW(DWORD EventId, DWORD cbData, LPVOID lpvData);
LPWSTR LogStringW(LPWSTR szFormat, ...);

#ifdef UNICODE
#define NDDELogError	NDDELogErrorW
#define NDDELogWarning	NDDELogWarningW
#define NDDELogInfo	NDDELogInfoW
#define NDDELogData	NDDELogDataW
#define LogString	LogStringW
#else
#define NDDELogError	NDDELogErrorA
#define NDDELogWarning	NDDELogWarningA
#define NDDELogInfo	NDDELogInfoA
#define NDDELogData	NDDELogDataA
#define LogString	LogStringA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\netddesh.h ===
/*
 * Strings share with other modules:
 */
#define NETDDE_TITLE    "NetDDE"
#define NETDDE_CLASS    "NetDDEMainWdw"

typedef struct _THREADDATA {
    struct _THREADDATA  *ptdNext;
    HWINSTA             hwinsta;
    HDESK               hdesk;
    HWND                hwndDDE;
    HWND                hwndDDEAgent;
    HANDLE              heventReady;
    DWORD               dwThreadId;
    BOOL                bInitiating;
} THREADDATA, *PTHREADDATA;

typedef struct _IPCINIT {
    HDDER       hDder;
    LPDDEPKT    lpDdePkt;
    BOOL        bStartApp;
    LPSTR       lpszCmdLine;
    WORD        dd_type;
} IPCINIT, *PIPCINIT;

typedef struct _IPCXMIT {
    HIPC        hIpc;
    HDDER       hDder;
    LPDDEPKT    lpDdePkt;
} IPCXMIT, *PIPCXMIT;

extern PTHREADDATA ptdHead;

extern UINT    wMsgIpcXmit;
extern UINT    wMsgDoTerminate;

extern DWORD tlsThreadData;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\nddeapis.h ===
//========================================================================
//
//  NDDEAPIS.H  supplemental include file for dde share apis
//
//========================================================================
// tabstop = 4

#ifndef          NDDEAPI_INCLUDED
#define          NDDEAPI_INCLUDED

#ifndef _INC_NDDESEC
#include    "nddesec.h"
#endif

// ============= connectFlags options =====

#define DDEF_NOPASSWORDPROMPT   0x0001

// others reserved!

//============== Api Constants ============

// String size constants

#define CNLEN                   15              // from netcons.
#define UNCLEN                  (CNLEN+2)

#define MAX_PASSWORD            15

// Permission mask bits

#define DDEACCESS_REQUEST       NDDE_SHARE_REQUEST
#define DDEACCESS_ADVISE        NDDE_SHARE_ADVISE
#define DDEACCESS_POKE          NDDE_SHARE_POKE
#define DDEACCESS_EXECUTE       NDDE_SHARE_EXECUTE
/*
#define DDEACCESS_REQUEST       0x00000001L
#define DDEACCESS_ADVISE        0x00000002L
#define DDEACCESS_POKE          0x00000004L
#define DDEACCESS_EXECUTE       0x00000008L
#define DDEACCESS_START_APP     0x00000010L
*/

// ============== Data Structures =========


//=============================================================
// DDESESSINFO - contains information about a DDE session


// ddesess_Status defines

#define DDESESS_CONNECTING_WAIT_NET_INI                1
#define DDESESS_CONNECTING_WAIT_OTHR_ND                2
#define DDESESS_CONNECTED                              3
#define DDESESS_DISCONNECTING                          4       

struct DdeSessInfo_tag {
                char        ddesess_ClientName[UNCLEN+1];
                short       ddesess_Status;
                DWORD_PTR   ddesess_Cookie;      // used to distinguish
                                                                                                               // clients of the same
                                                                                                               // name on difft. nets
};

typedef struct DdeSessInfo_tag DDESESSINFO;
typedef struct DdeSessInfo_tag * PDDESESSINFO;
typedef struct DdeSessInfo_tag far * LPDDESESSINFO;


//=============================================================
// DDECONNINFO - contains information about a DDE conversation

// ddeconn_Status defines

#define DDECONN_WAIT_LOCAL_INIT_ACK    1
#define DDECONN_WAIT_NET_INIT_ACK      2
#define DDECONN_OK                     3
#define DDECONN_TERMINATING            4
#define DDECONN_WAIT_USER_PASSWORD     5


struct DdeConnInfo_tag {
        LPSTR   ddeconn_ShareName;
        short   ddeconn_Status;
        short   ddeconn_pad;
};

typedef struct DdeConnInfo_tag DDECONNINFO;
typedef struct DdeConnInfo_tag * PDDECONNINFO;
typedef struct DdeConnInfo_tag far * LPDDECONNINFO;


// typedef UINT WINAPI DDEAPIFUNCTION;

//=============================================================
//=============================================================
//
//                              API FUNCTION PROTOTYPES
//
//=============================================================
//=============================================================

//      The following 3 functions are to be supplied (not necessarily part of API)

LPBYTE WINAPI
DdeGetSecurityKey(                      // pointer to security key or NULL if none
        LPDWORD lpcbSecurityKeySize     // gets size of security key
);


LPBYTE WINAPI
DdeEnkrypt1(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPassword,             // password to be enkrypted
        DWORD   cPasswordSize,          // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key (NULL for phase 1)
        DWORD   cKey,                   // size of key (0 for phase 1)
        LPDWORD lpcbPasswordK1Size      // gets size of resulting enkrypted stream
);

LPBYTE WINAPI
DdeEnkrypt2(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPasswordK1,           // password output in first phase
        DWORD   cPasswordK1Size,        // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key 
        DWORD   cKey,                   // size of key
        LPDWORD lpcbPasswordK2Size      // get size of resulting enkrypted stream
);

//////////////////////////////////////////////////////
//      NetDDE Statistics Access

UINT WINAPI
DdeSessionEnum (
        LPSTR   lpszServer,             // server to execute on ( must be NULL )
        UINT    nLevel,                 // info level - must be 1
        LPBYTE  lpBuffer,               // pointer to buffer that receiv
        DWORD   cBufSize,               // size of supplied buffer
        LPDWORD lpcbTotalAvailable,     // number of bytes filled in
        LPDWORD lpnItems                // number of names
);

UINT WINAPI
DdeConnectionEnum (
        LPSTR   lpszServer,             // server to execute on ( must be NULL )
        LPSTR   lpszClientName,         // name of client to enum shares from
                                        // if NULL, all
        DWORD   Cookie,                 // cookie returned from ddesessi
                                        // is used to distinguish clients of the
                                        // same name.
        UINT    nLevel,                 // info level - must be 1
        LPBYTE  lpBuffer,               // pointer to supplied buffer
                                        // which receive null terminated names
                                        // followed by a double null
        DWORD   cBufSize,               // size of supplied buffer
        LPDWORD lpcbTotalAvailable,     // number of bytes filled in
        LPDWORD lpnItems                // number of data items returned
);

UINT WINAPI
DdeSessionClose (
        LPSTR   lpszServer,             // server to execute on ( must be NULL )
        LPSTR   lpszClientName,         // client to close
        DWORD   cookie                  // cookie to identify client
);                      



UINT WINAPI
DdeGetClientInfo (
        HWND    hWndClient,
        LPSTR   lpszClientNode,
        LONG    cClientNodeLimit,
        LPSTR   lpszClientApp,
        LONG    cClientAppLimit
);

UINT WINAPI
DdeGetNodeName(
        LPSTR   lpszNodeName,
        LONG    cNodeNameLimit
);

#endif  // NDDEAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\nddesec.h ===
#ifndef          _INC_NDDESEC
#define          _INC_NDDESEC

#include <winnt.h>

#define NDDE_SHAREDB_ADD        (0x00000001)
#define NDDE_SHAREDB_DELETE     (0x00000002)
#define NDDE_SHAREDB_LIST       (0x00000004)
#define NDDE_SHAREDB_FSERVICE   (0x00000008)

#define NDDE_SHAREDB_ADMIN      (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_DELETE |      \
                                 NDDE_SHAREDB_LIST |        \
                                 NDDE_SHAREDB_FSERVICE |    \
                                 READ_CONTROL |             \
                                 WRITE_DAC |                \
                                 WRITE_OWNER)

#define NDDE_SHAREDB_OPER       (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_POWER      (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_FSERVICE |    \
                                 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_USER       (NDDE_SHAREDB_ADD |         \
                                 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_EVERYONE   (NDDE_SHAREDB_LIST)

#define NDDE_SHARE_READ             (0x00000001)
#define NDDE_SHARE_WRITE            (0x00000002)
#define NDDE_SHARE_INITIATE_STATIC  (0x00000004)
#define NDDE_SHARE_INITIATE_LINK    (0x00000008)
#define NDDE_SHARE_REQUEST          (0x00000010)
#define NDDE_SHARE_ADVISE           (0x00000020)
#define NDDE_SHARE_POKE             (0x00000040)
#define NDDE_SHARE_EXECUTE          (0x00000080)
#define NDDE_SHARE_ADD_ITEMS        (0x00000100)
#define NDDE_SHARE_LIST_ITEMS       (0x00000200)

#define NDDE_SHARE_GENERIC_READ     (NDDE_SHARE_READ |               \
                                    NDDE_SHARE_INITIATE_STATIC |     \
                                    NDDE_SHARE_REQUEST |             \
                                    NDDE_SHARE_ADVISE |              \
                                    NDDE_SHARE_LIST_ITEMS)

#define NDDE_SHARE_GENERIC_WRITE    (NDDE_SHARE_INITIATE_STATIC |    \
                                     NDDE_SHARE_INITIATE_LINK |      \
                                     NDDE_SHARE_POKE |               \
                                     DELETE)

#define NDDE_SHARE_GENERIC_EXECUTE (NDDE_SHARE_INITIATE_STATIC |     \
                                    NDDE_SHARE_INITIATE_LINK |       \
                                    NDDE_SHARE_EXECUTE)

#define NDDE_SHARE_GENERIC_ALL     (NDDE_SHARE_READ |                \
                                    NDDE_SHARE_WRITE |               \
                                    NDDE_SHARE_INITIATE_STATIC |     \
                                    NDDE_SHARE_INITIATE_LINK |       \
                                    NDDE_SHARE_REQUEST |             \
                                    NDDE_SHARE_ADVISE |              \
                                    NDDE_SHARE_POKE |                \
                                    NDDE_SHARE_EXECUTE |             \
                                    NDDE_SHARE_ADD_ITEMS |           \
                                    NDDE_SHARE_LIST_ITEMS |          \
                                    DELETE |                         \
                                    READ_CONTROL |                   \
                                    WRITE_DAC |                      \
                                    WRITE_OWNER)


#define NDDE_ITEM_REQUEST          (0x00000001)
#define NDDE_ITEM_ADVISE           (0x00000002)
#define NDDE_ITEM_POKE             (0x00000004)

#define NDDE_ITEM_GENERIC_READ     (NDDE_ITEM_REQUEST | NDDE_ITEM_ADVISE)
#define NDDE_ITEM_GENERIC_WRITE    (NDDE_ITEM_POKE)
#define NDDE_ITEM_GENERIC_EXECUTE  (0)
#define NDDE_ITEM_GENERIC_ALL      (NDDE_ITEM_REQUEST |               \
                                   NDDE_ITEM_ADVISE |                 \
                                   NDDE_ITEM_POKE |                   \
                                   DELETE |                           \
                                   READ_CONTROL |                     \
                                   WRITE_DAC |                        \
                                   WRITE_OWNER)

#define NDDE_GUI_NONE              (0)

#define NDDE_GUI_READ              (NDDE_SHARE_GENERIC_READ)

#define NDDE_GUI_READ_LINK         (NDDE_SHARE_GENERIC_READ |         \
                                    NDDE_SHARE_INITIATE_LINK)

#define NDDE_GUI_CHANGE            (NDDE_SHARE_GENERIC_READ |         \
                                    NDDE_SHARE_GENERIC_WRITE |        \
                                    NDDE_SHARE_GENERIC_EXECUTE)

#define NDDE_GUI_FULL_CONTROL      (NDDE_SHARE_GENERIC_ALL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\netbasic.h ===
#ifndef H__netbasic
#define H__netbasic

#include "warning.h"

typedef ULONG_PTR       CONNID;
typedef unsigned long   PKTID;
typedef ULONG_PTR       HPKTZ;
typedef ULONG_PTR       HROUTER;
typedef ULONG_PTR       HDDER;
typedef ULONG_PTR       HIPC;
typedef ULONG_PTR       HTIMER;

/* maximum node name string length.
    Buffers for names should be declared char buf[ MAX_NODE_NAME+1 ]; */
#define MAX_NODE_NAME   16

/* maximum network interface name string length.
    Buffers for names should be declared char buf[ MAX_NI_NAME+1 ]; */
#define MAX_NI_NAME     8

/* maximum connection info for a netintf DLL
    Buffers for names should be declared char buf[ MAX_CONN_INFO+1 ]; */
#define MAX_CONN_INFO   (512)

/* maximum string length of "additional routing info".  This is the
    information used for routing from one node to another.
    Buffers for names should be declared char buf[ MAX_ROUTE_INFO+1 ]; */
#define MAX_ROUTE_INFO  512

/* maximum application name string length.
    Buffers for names should be declared char buf[ MAX_APP_NAME+1 ]; */
#define MAX_APP_NAME    255

/* maximum topic name string length.
    Buffers for names should be declared char buf[ MAX_TOPIC_NAME+1 ]; */
#define MAX_TOPIC_NAME  255

/*  max length for a share name */
#define MAX_SHARENAMEBUF        MAX_APP_NAME + MAX_TOPIC_NAME + 1

#define ILLEGAL_NAMECHARS       " +*\\/,?()\"'"

/*
    Reason codes for Initiate Ack failing
 */
#define RIACK_TASK_MEMORY_ERR                   (1)
#define RIACK_NETDDE_NOT_ACTIVE                 (2)
#define RIACK_LOCAL_MEMORY_ERR                  (3)
#define RIACK_ROUTE_NOT_ESTABLISHED             (4)
#define RIACK_DEST_MEMORY_ERR                   (5)
#define RIACK_NOPERM                            (6)
#define RIACK_NOPERM_TO_STARTAPP                (7)
#define RIACK_STARTAPP_FAILED                   (8)
#define RIACK_NORESP_AFTER_STARTAPP             (9)
#define RIACK_UNKNOWN                           (10)
#define RIACK_TASK_IO_ERR                       (11)
#define RIACK_TASK_MAGIC_ERR                    (12)
#define RIACK_DUPLICATE_NODE_NAME               (13)
/*  1.1 reason codes                                    */
#define RIACK_NEED_PASSWORD                     (16)
#define RIACK_SHARE_NAME_TOO_BIG                (17)
/*  NT reason codes                                     */
#define RIACK_NO_NDDE_AGENT                     (20)
#define RIACK_NOT_SHARED                        (21)
#define RIACK_NOPERM_TO_INITAPP                 (22)
/*  Share access error base: 0x100 + error code returned by ntddeapi    */
#define RIACK_SHARE_ACCESS_ERROR                (256)
/* !!! Any changes must be put into hpux\netdde.h !!! */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\netpkt.h ===
#ifndef H__netpkt
#define H__netpkt

#include "netbasic.h"

/*
    N E T P K T
	
	NETPKT is the data structure sent across the variety of network
	interfaces.

 */
typedef struct {
    /* checksum of pkthdr.  Set and checked in netintf only. */
    DWORD	np_cksHeader;

    /* magic number of this connection ... unused at this time */
    DWORD	np_magicNum;

    /* offset of this packet in a message.  PKTZ level only. */
    DWORD	np_pktOffsInMsg;	

    /* size of overall message.  PKTZ level only */
    DWORD	np_msgSize;

    /* id of last packet received OK. PKTZ level only.  Set when ready 
	to xmt */
    PKTID	np_lastPktOK;

    /* last packet received.  PKTZ level only.  Set when ready to xmt */
    PKTID	np_lastPktRcvd;
    
    /* size of packet excluding header. If 0, this indicates control pkt and
	np_type should be NPKT_CONTROL.  Only set/checked at pktz level */
    WORD	np_pktSize;					    

    /* status of np_lastPktRcvd, one of:
	    PS_NO_INFO
	    PS_OK
	    PS_DATA_ERR
	    PS_MEMORY_ERR
	 PKTZ level only ... set when ready to xmt
       */
    BYTE	np_lastPktStatus;

    /* either VERMETH_CRC16 or VERMETH_CKS32.  This represents how the fields
	np_cksData and np_cksHeader are calculated.  Only played with at
	netintf level */
    BYTE	np_verifyMethod;

    /* either NPKT_ROUTER, NPKT_PKTZ or NPKT_CONTROL.  Pktz level only */
    BYTE	np_type;

    /* filler for byte-alignment problems */
    BYTE	np_filler[3];
    
    /* packet ID of this packet.  PKTZ level only */
    PKTID	np_pktID;

    /* checksum of data portion of pkt.  Only set and/or checked at 
	netintf level */
    DWORD	np_cksData;
} NETPKT;
typedef NETPKT FAR *LPNETPKT;

/* packet status */
#define PS_NO_INFO		(1)
#define PS_OK			(2)
#define PS_DATA_ERR		(3)
#define PS_MEMORY_ERR		(4)
#define PS_NO_RESPONSE		(5)

/* packet type */
#define NPKT_ROUTER	(1)
#define NPKT_PKTZ	(2)
#define NPKT_CONTROL	(3)
#define NPKT_NETIF	(4)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\netintf.h ===
#ifndef H__netintf
#define H__netintf

#include "netbasic.h"

#ifdef _WINDOWS
DWORD	NDDEInit( LPSTR lpszNodeName, HWND hWndNetdde );
#else
BOOL 	NDDEInit( LPSTR lpszNodeName );
#endif

/*  interface init status return */

#define NDDE_INIT_OK            1
#define NDDE_INIT_NO_SERVICE    2
#define NDDE_INIT_FAIL          3

void	NDDETimeSlice( void );
void	NDDEShutdown( void );

DWORD	NDDEGetCAPS( WORD nIndex );
#define NDDE_SPEC_VERSION	    0x0001
#define	NDDE_CUR_VERSION	    (0x0000030AL)

#define NDDE_MAPPING_SUPPORT    0x0002
#define	NDDE_MAPS_YES		    (0x00000001L)
#define	NDDE_MAPS_NO		    (0x00000000L)

#define NDDE_SCHEDULE_METHOD	0x0003
#define	NDDE_TIMESLICE		    (0x00000000L)

#define NDDE_CONFIG_PARAMS      0x5701      /* Wonderware Params 0x57='W' */
#define NDDE_PARAMS_OK          (0x00000001L)
#define NDDE_PARAMS_NO          (0x00000000L)


#ifdef _WINDOWS
CONNID	NDDEAddConnection( LPSTR nodeName );
#else
CONNID	NDDEAddConnection( LPSTR nodeName, HPKTZ hPktz );
#endif

CONNID	NDDEGetNewConnection( void );

VOID	NDDEDeleteConnection( CONNID connID );

DWORD	NDDEGetConnectionStatus( CONNID connID );

BOOL	NDDERcvPacket( CONNID connID, LPVOID lpRcvBuf,
		    LPWORD lpwLen, LPWORD lpwPktStatus );
		
BOOL	NDDEXmtPacket( CONNID connID, LPVOID lpXmtBuf, WORD wPktLen );

BOOL	NDDESetConnectionConfig(    CONNID connID,
			    WORD wMaxUnAckPkts,
			    WORD wPktSize,
			    LPSTR lpszName );

BOOL	NDDEGetConnectionConfig( CONNID connID,
			    WORD FAR *lpwMaxUnAckPkts,
			    WORD FAR *lpwPktSize,
			    DWORD FAR *lptimeoutRcvConnCmd,
			    DWORD FAR *lptimeoutRcvConnRsp,
			    DWORD FAR *lptimeoutMemoryPause,
			    DWORD FAR *lptimeoutKeepAlive,
			    DWORD FAR *lptimeoutXmtStuck,
			    DWORD FAR *lptimeoutSendRsp,
			    WORD FAR *lpwMaxNoResponse,
			    WORD FAR *lpwMaxXmtErr,
			    WORD FAR *lpwMaxMemErr );

#ifdef HASUI
#ifdef  _WINDOWS
        VOID	_export LogDebugInfo( CONNID connID, DWORD dwFlags );
        typedef VOID (*FP_LogDebugInfo) ( CONNID connId, DWORD dwFlags );
        VOID	_export Configure( void );
        typedef VOID (*FP_Configure) ( void );
#endif
#ifdef  VAX
        VOID	LogDebugInfo( CONNID connID, DWORD dwFlags );
        typedef VOID (*FP_LogDebugInfo) ( CONNID connId, DWORD dwFlags );
#endif
#endif

/*
    Connection status information
 */
#define NDDE_CONN_OK		((DWORD)0x00000001L)
#define NDDE_CONN_CONNECTING	((DWORD)0x00000002L)

#define NDDE_CONN_STATUS_MASK	(NDDE_CONN_OK | NDDE_CONN_CONNECTING)

#define NDDE_CALL_RCV_PKT	((DWORD)0x00000004L)

#define NDDE_READY_TO_XMT	((DWORD)0x00000008L)

/*
    Packet Status
 */
#define NDDE_PKT_HDR_OK			(0x0001)
#define NDDE_PKT_HDR_ERR		(0x0002)
#define NDDE_PKT_DATA_OK		(0x0004)
#define NDDE_PKT_DATA_ERR		(0x0008)

#ifdef _WINDOWS
typedef BOOL (*FP_Init) ( LPSTR lpszNodeName, HWND hWndNetdde );
#else
typedef BOOL (*FP_Init) ( LPSTR lpszNodeName );
#endif
typedef void (*FP_TimeSlice) ( void );
typedef void (*FP_Shutdown) ( void );
typedef DWORD (*FP_GetCAPS) ( WORD nIndex );
#ifdef _WINDOWS
typedef CONNID (*FP_AddConnection) ( LPSTR nodeName );
#else
typedef CONNID (*FP_AddConnection) ( LPSTR nodeName, HPKTZ hPktzNotify );
#endif
typedef CONNID (*FP_GetNewConnection) ( void );
typedef VOID (*FP_DeleteConnection) ( CONNID connId );
typedef DWORD (*FP_GetConnectionStatus) ( CONNID connId );
typedef BOOL (*FP_RcvPacket) ( CONNID connId, LPVOID lpRcvBuf,
		    LPWORD lpwLen, LPWORD lpwPktStatus );
typedef BOOL (*FP_XmtPacket) ( CONNID connId, LPVOID lpXmtBuf, WORD wPktLen );
typedef BOOL (*FP_SetConnectionConfig) ( CONNID connId,
			    WORD wMaxUnAckPkts,
			    WORD wPktSize,
			    LPSTR lpszName );
typedef BOOL (*FP_GetConnectionConfig) ( CONNID connId,
			    WORD FAR *lpwMaxUnAckPkts,
			    WORD FAR *lpwPktSize,
			    DWORD FAR *lptimeoutRcvConnCmd,
			    DWORD FAR *lptimeoutRcvConnRsp,
			    DWORD FAR *lptimeoutMemoryPause,
			    DWORD FAR *lptimeoutKeepAlive,
			    DWORD FAR *lptimeoutXmtStuck,
			    DWORD FAR *lptimeoutSendRsp,
			    WORD FAR *lpwMaxNoResponse,
			    WORD FAR *lpwMaxXmtErr,
			    WORD FAR *lpwMaxMemErr );

typedef struct {
    FP_Init                 Init;
    FP_GetCAPS              GetCAPS;
    FP_GetNewConnection		GetNewConnection;
    FP_AddConnection		AddConnection;
    FP_DeleteConnection		DeleteConnection;
    FP_GetConnectionStatus	GetConnectionStatus;
    FP_RcvPacket            RcvPacket;
    FP_XmtPacket            XmtPacket;
    FP_SetConnectionConfig	SetConnectionConfig;
    FP_GetConnectionConfig	GetConnectionConfig;
    FP_Shutdown             Shutdown;
    FP_TimeSlice            TimeSlice;
#ifdef HASUI
#ifdef _WINDOWS
    FP_LogDebugInfo		    LogDebugInfo;
    FP_Configure    		Configure;
#endif
#ifdef  VAX
    FP_LogDebugInfo		    LogDebugInfo;
#endif
#endif
    char                    dllName[ 9 ];
} NIPTRS;
typedef NIPTRS FAR *LPNIPTRS;

/* returns the next available network interface that supports mapping names
    to addresses */
BOOL	GetNextMappingNetIntf( LPNIPTRS FAR *lplpNiPtrs, int FAR *lpnNi );

/* converts a string representation of netintf to pointer set */
BOOL	NameToNetIntf( LPSTR lpszName, LPNIPTRS FAR *lplpNiPtrs );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\nscommn.h ===
/*
 * NSCOMMON.H    NetDDE setup code common to NetDDE tools and NT setup code.
 *
 * Created 10/3/93  SanfordS
 */

BOOL    CreateShareDBInstance(VOID);
BOOL    CreateDefaultTrust(HKEY hKeyUserRoot);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\rerr.h ===
#ifndef H__rerr
#define H__rerr

/*
    Router Errors
 */
    /* no memory */
#define RERR_NO_MEMORY			(1)
    /* connection with the next node failed */
#define RERR_NEXT_NODE_CONN_FAILED	(2)
    /* addl info after final destination reached */
#define RERR_ADDL_INFO			(3)
    /* no addl info and final destination not reached */
#define RERR_NO_ADDL_INFO		(4)
    /* connection failed during route setup */
#define RERR_CONN_FAIL			(5)
    /* route string too long */
#define RERR_ROUTE_TOO_LONG		(6)
    /* node name in route string too long */
#define RERR_NODE_NAME_TOO_LONG		(7)
    /* connection table netintf not found */
#define RERR_CONN_NETINTF_INVALID	(8)
    /* connection table: no netintf to map name */
#define RERR_CONN_NO_MAPPING_NI		(9)
    /* likely infinite loop */
#define RERR_TOO_MANY_HOPS		(10)
    /* Looped ... NET_NET with same PKTZ in and out */
#define RERR_DIRECT_LOOP		(11)

#define RERR_MAX_ERR            (12)

/* if you add any errors here, be sure to update the error messages
    in router.c !!! */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\proflspt.h ===
BOOL FAR PASCAL MyWritePrivateProfileInt( LPSTR lpAppName, LPSTR lpKeyName,
			int nValue, LPSTR lpFileName );
BOOL FAR PASCAL WritePrivateProfileLong( LPSTR lpAppName, LPSTR lpKeyName,
			LONG lValue, LPSTR lpFileName );
LONG FAR PASCAL GetPrivateProfileLong( LPSTR lpAppName, LPSTR lpKeyName,
			LONG lDefault, LPSTR lpFileName );
BOOL FAR PASCAL TestPrivateProfile( LPCSTR lpAppName, LPCSTR lpKeyName,
			LPCSTR lpFileName );
BOOL FAR WINAPI MyWritePrivateProfileString(LPCSTR  lpszSection, LPCSTR  lpszKey,
                        LPCSTR  lpszString, LPCSTR  lpszFile );
UINT FAR WINAPI MyGetPrivateProfileInt(LPCSTR  lpszSection, LPCSTR  lpszKey,
                        INT dwDefault, LPCSTR lpszFile );
DWORD FAR WINAPI MyGetPrivateProfileString(LPCSTR lpszSection, LPCSTR lpszKey,
                        LPCSTR lpszDefault, LPSTR lpszReturnBuffer,
                        DWORD cbReturnBuffer, LPCSTR lpszFile );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\router.h ===
#ifndef H__router
#define H__router

/*	Calls from DDER */
BOOL	RouterGetRouterForDder( const LPSTR lpszNodeName, HDDER hDder );
VOID	RouterPacketFromDder( HROUTER hRouter, HDDER hDder, 
	    LPDDEPKT lpDdePkt );
VOID	RouterAssociateDder( HROUTER hRouter, HDDER hDder );
VOID	RouterDisassociateDder( HROUTER hRouter, HDDER hDder );

/*	Calls from PKTZ */
VOID	RouterPacketFromNet( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID	RouterConnectionComplete( HROUTER hRouter, WORD hRouterExtra,
	    HPKTZ hPktz );
VOID	RouterConnectionBroken( HROUTER hRouter, WORD hRouterExtra,
	    HPKTZ hPktz, BOOL bFromPktz );
VOID	RouterGetNextForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER FAR *lphRouterNext, WORD FAR *lphRouterExtraNext );
VOID	RouterGetPrevForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER FAR *lphRouterPrev, WORD FAR *lphRouterExtraPrev );
VOID	RouterSetNextForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER hRouterNext, WORD hRouterExtraNext );
VOID	RouterSetPrevForPktz( HROUTER hRouter, WORD hRouterExtra,
	    HROUTER hRouterPrev, WORD hRouterExtraPrev );

#ifdef _WINDOWS
VOID	RouterCloseByName( LPSTR lpszName );
VOID	RouterEnumConnections( HWND hDlg );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\pktz.h ===
#ifndef H__pktz
#define H__pktz

#define NDDESignature   0x4E444445L

/* states of packetizer */
#define PKTZ_CONNECTED                  1
#define PKTZ_WAIT_PHYSICAL_CONNECT      2
#define PKTZ_WAIT_NEG_CMD               3
#define PKTZ_WAIT_NEG_RSP               4
#define PKTZ_PAUSE_FOR_MEMORY           5
#define PKTZ_CLOSE                      6

/* Timer IDs */
#define TID_NO_RCV_CONN_CMD             1
#define TID_NO_RCV_CONN_RSP             2
#define TID_MEMORY_PAUSE                3
#define TID_NO_RESPONSE                 4
#define TID_KEEPALIVE                   5
#define TID_XMT_STUCK                   6
#define TID_CLOSE_PKTZ                  7


/*
    PKTZ_NEG_CMD:  negotiate pktsize, etc.
 */
typedef struct {
    WORD nc_type;            /* PKTZ_NEG_CMD */
    WORD nc_pktSize;         /* proposed size of packets */
    WORD nc_maxUnackPkts;    /* proposed maximum unacknowledged packets */
    WORD nc_offsSrcNodeName; /* offset (from nc_strings[0]) of source node name */
    WORD nc_offsDstNodeName; /* offset (from nc_strings[0]) of destination node name */
    WORD nc_offsProtocols;   /* offset (from nc_strings[0]) of start of protocol strings */
    WORD nc_protocolBytes;   /* number of bytes of protocol strings */
    BYTE nc_strings[1];      /* start of NULL-terminated strings
                                 srcNodeName
                                 dstNodeName
                                 protocols
                              */
} NEGCMD, FAR *LPNEGCMD;

#define NEGRSP_ERRCLASS_NONE        (0x0000)
#define NEGRSP_ERRCLASS_NAME        (0x0001)

#define NEGRSP_ERRNAME_MISMATCH     (0x0001)
#define NEGRSP_ERRNAME_DUPLICATE    (0x0002)

#define NEGRSP_PROTOCOL_NONE    (0xFFFF)

typedef struct {
    WORD nr_type;           /* one of PKTZ_NEG_CMD or PKTZ_NEG_RSP or PKTZ_KEEPALIVE */
    WORD nr_pktSize;        /* size of packets agreed upon */
    WORD nr_maxUnackPkts;   /* maximum unacknowledged packets agreed on */
    WORD nr_protocolIndex;  /* protocol index.  NEGRSP_PROTOCOL_NONE indicates error */
    WORD nr_errorClass;     /* errors */
    WORD nr_errorNum;
} NEGRSP, FAR *LPNEGRSP;

typedef struct {
    WORD        pc_type;    /* PKTZ_NEG_... */
} PKTZCMD;
typedef PKTZCMD FAR *LPPKTZCMD;

/* types of PKTZ messages */
#define PKTZ_NEG_CMD    (1)
#define PKTZ_NEG_RSP    (2)
#define PKTZ_KEEPALIVE  (3)


/*
    N E T H D R

        NETHDR is the data in front of each network packet that the
        PKTZ uses to keep track of various information
 */
typedef struct nethdr {
    struct nethdr FAR *nh_prev; /* previous link */
    struct nethdr FAR *nh_next; /* next link */
    WORD  nh_noRsp;             /* count of consecutive no response errors */
    WORD  nh_xmtErr;            /* count of consecutive transmission errors */
    WORD  nh_memErr;            /* count of consecutive out-of-memory errors */
    WORD  nh_filler;            /* filler for byte-alignment problems */
    DWORD nh_timeSent;          /* timestamp of when sent (in msec) */
    HTIMER nh_hTimerRspTO;      /* hTimer for send response timeout */
} NETHDR, FAR *LPNETHDR;


/*
    PKTZ is the data associated with each instance of PKTZ
 */
typedef struct {
    CONNID    pk_connId;            /* connId: connection id for the associated network interface */
    WORD      pk_state;             /* PKTZ_... */
    BOOL      pk_fControlPktNeeded; /* fControlPktNeeded: do we need to send a control packet */
    PKTID     pk_pktidNextToSend;   /* pktidNextToSend: pktId of the next packet that we should send.  If we get a NACK regarding a packet, we should set pktidNextToSend to that pktid and retransmit it next chance we have */
    PKTID     pk_pktidNextToBuild;  /* pktidNextToBuild: pktId of the next packet that we build. */
    BYTE      pk_lastPktStatus;     /* lastPktStatus: status of last packet that we received from the other side.  This gets put into the next packet that we send out (put in np_lastPktStatus field) */
    PKTID     pk_lastPktRcvd;       /* lastPktRcvd: last packet that we received.  This gets put into np_lastPktRcvd on next pkt we xmit. */
    PKTID     pk_lastPktOk;         /* lastPktOk: last packet that we received OK.  This gets put into np_lastPktOK on the next pkt we xmit. */
    PKTID     pk_lastPktOkOther;    /* lastPktOkOther: last packet that the other side has received OK.  */
    PKTID     pk_pktidNextToRecv;   /* pktidNextToRecv: next packet number that we're expecting.  We ignore any packets except this packet number */
    DWORD     pk_pktOffsInXmtMsg;   /* pktOffsInMsg: where we should start in the next DDE Packet to xmit. If this is non-zero, it means that part of the DDE Packet at the head of the DDE Packet list (pk_ddePktListHead) is in the unacked packet list */
    LPDDEPKT  pk_lpDdePktSave;      /* lpDdePktSave: if we are in the middle of a DDE packet, this is a pointer to the beginning of the packet */
    char      pk_szDestName[ MAX_NODE_NAME+1 ];/* szDestName: name of destination node */
    char      pk_szAliasName[ MAX_NODE_NAME+1 ]; /* szAliasName: alias of destination node, e.g. 15.8.0.244 w/ destName of sidloan */
    WORD      pk_pktSize;           /* pktSize: how big are the packets for this netintf */
    WORD      pk_maxUnackPkts;      /* maxUnackPkts: how many unacknowledged packets should we xmit? */
    DWORD     pk_timeoutRcvNegCmd;  /* configuration parameters for timeouts and retry limits */
    DWORD     pk_timeoutRcvNegRsp;
    DWORD     pk_timeoutMemoryPause;
    DWORD     pk_timeoutKeepAlive;
    DWORD     pk_timeoutXmtStuck;
    DWORD     pk_timeoutSendRsp;
    WORD      pk_wMaxNoResponse;
    WORD      pk_wMaxXmtErr;
    WORD      pk_wMaxMemErr;
    BOOL      pk_fDisconnect;  /* disconnect information */
    int       pk_nDelay;
    LPNIPTRS  pk_lpNiPtrs;/* lpNiPtrs: pointer to list of functions for associated netintf */
            /* statistics */
    DWORD     pk_sent;
    DWORD     pk_rcvd;
    HTIMER    pk_hTimerKeepalive;
    HTIMER    pk_hTimerXmtStuck; /* hTimerRcvNegCmd: timer for timeout waiting for client to send us the connect cmd */
    HTIMER    pk_hTimerRcvNegCmd; /* hTimerRcvNegRsp: timer for timeout waiting for server to send us the connect cmd rsp */
    HTIMER    pk_hTimerRcvNegRsp; /* hTimerMemoyrPause: timer for waiting before retransmitting a packet that was NACKed because of memory errors */
    HTIMER    pk_hTimerMemoryPause;
    HTIMER    pk_hTimerCloseConnection; /* rt_hTimerClose: timer for closing this route */
                          /* list of saved packets that have been transmitted and are not acked. */
    LPNETHDR  pk_pktUnackHead;          /* Head is lowest numbered (least recent) packet */
    LPNETHDR  pk_pktUnackTail;          /* tail is highest numbered (most recent) packet */
    LPVOID    pk_rcvBuf;                /* receive buffer for getting info from netintf */
    LPNETPKT  pk_controlPkt;            /* buffer for control packet.  Must always have memory available to send a control packet */
    LPNETHDR  pk_pktFreeHead;           /* list of packet buffers available for transmission */
    LPNETHDR  pk_pktFreeTail;
                                        /* list of DDE packets that have yet to be xmitted */
    LPVOID    pk_ddePktHead;            /* earliest (least recent) */
    LPVOID    pk_ddePktTail;            /* latest (most recent) */
    LPVOID    pk_prevPktz;              /* list of packetizers in the system */
    LPVOID    pk_nextPktz;
    LPVOID    pk_prevPktzForNetintf;    /* list of packetizers associated with this netintf */
    LPVOID    pk_nextPktzForNetintf;
    HROUTER   pk_hRouterHead;           /* head of list of routers associated with PKTZ */
    WORD      pk_hRouterExtraHead;      /* extra info for list of hRouters */
} PKTZ;
typedef PKTZ FAR *LPPKTZ;



VOID	PktzSlice( void );
BOOL	PktzGetPktzForRouter( LPNIPTRS lpNiPtrs, LPSTR lpszNodeName,
		LPSTR lpszNodeInfo, HROUTER hRouter, WORD hRouterExtra,
		WORD FAR *lpwHopErr, BOOL bDisconnect, int nDelay,
		HPKTZ hPktzDisallowed );
HPKTZ	PktzNew( LPNIPTRS lpNiPtrs, BOOL bClient,
		LPSTR lpszNodeName, LPSTR lpszNodeInfo, CONNID connId,
		BOOL bDisconnect, int nDelay );
VOID	PktzAssociateRouter( HPKTZ hPktz, HROUTER hRouter,
		WORD hRouterExtra );
VOID	PktzDisassociateRouter( HPKTZ hPktz, HROUTER hRouter,
		WORD hRouterExtra );
HPKTZ	PktzGetNext( HPKTZ hPktz );
HPKTZ	PktzGetPrev( HPKTZ hPktz );
VOID	PktzSetNext( HPKTZ hPktz, HPKTZ hPktzNext );
VOID	PktzSetPrev( HPKTZ hPktz, HPKTZ hPktzPrev );
VOID	PktzLinkDdePktToXmit( HPKTZ hPktz, LPDDEPKT lpDdePkt );
#ifdef _WINDOWS
VOID	PktzCloseAll( void );
VOID	PktzCloseByName( LPSTR lpszName );
VOID	PktzEnumConnections( HWND hDlg );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\seckey.h ===
#ifndef H__seckey
#define H__seckey

VOID FAR PASCAL DdeSecKeyObtainNew( 
            LPDWORD lphSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey );

BOOL FAR PASCAL DdeSecKeyRetrieve( 
            DWORD hSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey );

VOID FAR PASCAL DdeSecKeyAge( void );

VOID FAR PASCAL DdeSecKeyRelease( DWORD hSecurityKey );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\scrnupdt.h ===
#ifndef H__scrnupdt
#define H__scrnupdt

#ifdef HASUI

extern BOOL bShowStatistics;
extern BOOL bIconic;

#define UpdateScreenStatistics()                                    \
    {                                                               \
        if( bShowStatistics && !bIconic )  {                        \
        if (ptdHead != NULL)                                        \
                InvalidateRect( ptdHead->hwndDDE, NULL, FALSE );    \
        }                                                           \
    }                                                               

#define UpdateScreenState()                                         \
    {                                                               \
        if( !bIconic )  {                                           \
        if (ptdHead != NULL) {                                      \
                InvalidateRect( ptdHead->hwndDDE, NULL, TRUE );     \
                UpdateWindow(ptdHead->hwndDDE);                     \
        }                                                           \
        }                                                           \
    }                                                               

#else

#define UpdateScreenStatistics()
#define UpdateScreenState()

#endif  // HASUI

#endif  // !H__scrnupdt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\security.h ===
/* GetSecurityInfo() looks up security information for the specified node/app
    app/topic and returns the appropriate action
 */
VOID GetSecurityInfo( LPSTR lpszFromNode, LPSTR lpszFromApp, 
    LPSTR lpszToApp, LPSTR lpszToTopic, 
    BOOL FAR *pbAllow, BOOL FAR *pbStart, 
    LPSTR lpszCmdLine, int nMaxCmdLine,
    BOOL FAR *pbAdvise, BOOL FAR *pbRequest, 
    BOOL FAR *pbPoke, BOOL FAR *pbExecute );

/* GetRoutingInfo() looks up routing information for the specified node and
    returns whether an entry was found or not
 */
BOOL GetRoutingInfo( LPSTR lpszNodeName, LPSTR lpszRouteInfo, 
    int nMaxRouteInfo, BOOL FAR *pbDisconnect, int FAR *nDelay );

/* GetConnectionInfo() looks up connection information for 
    the specified node and returns whether an entry was found or not
 */
BOOL GetConnectionInfo( LPSTR lpszNodeName, LPSTR lpszNetIntf,
    LPSTR lpszConnInfo, int nMaxConnInfo, 
    BOOL FAR *pbDisconnect, int FAR *nDelay );

BOOL ValidateSecurityInfo( void );
BOOL ValidateRoutingInfo( void );
BOOL ValidateConnectionInfo( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\secdlg.h ===
#define CI_HELP		10001
#define HC_SECURITY_INFO		0x0204

#define CI_FROM_NODE	1701
#define CI_FROM_APP	1702
#define CI_TO_APP	1703
#define CI_TO_TOPIC	1704
#define CI_PERM_READ	1705
#define CI_PERM_WRITE	1706
#define CI_PERM_EXECUTE	1707
#define CI_START_APP	1708
#define CI_COMMAND	1709
#define CI_LB		1710
#define CI_CHANGE	1711
#define CI_DELETE	1712
#define CI_APPEND	1713
#define CI_LINE_1	1714
#define CI_LINE_2	1715
#define CI_LINE_3	1716
#define CI_LINE_4	1717
#define CI_LINE_5	1718
#define CI_INSERT	1719
#define CI_RESTORE	1720
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\srvrhelp.h ===
#define MENU_HELP_INDEX		32000
#define MENU_HELP_ON_HELP	32001
#define MENU_HELP_ABOUT		32002

VOID FAR PASCAL ServerHelpInit( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\sectype.h ===
#ifndef H__sectype
#define H__sectype

/*
    NetDDE security types
*/
#define     WW_SECURITY_TYPE        1L
#define     MS_SECURITY_TYPE        2L
#define     NT_SECURITY_TYPE        3L

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\shrtrust.h ===
#ifndef H__shrtrust
#define H__shrtrust

/*
    NetDDE will fill in the following structure and pass it to NetDDE
    Agent whenever it wants to have an app started in the user's
    context.  The reason for the sharename and modifyId is to that
    a user must explicitly permit NetDDE to start an app on behalf of
    other users.
 */

#define NDDEAGT_CMD_REV         1
#define NDDEAGT_CMD_MAGIC       0xDDE1DDE1

/*      commands        */
#define NDDEAGT_CMD_WINEXEC     0x1
#define NDDEAGT_CMD_WININIT     0x2

/*      return status   */
#define NDDEAGT_START_NO        0x0

#define NDDEAGT_INIT_NO         0x0
#define NDDEAGT_INIT_OK         0x1

typedef struct {
    DWORD       dwMagic;        // must be NDDEAGT_CMD_MAGIC
    DWORD       dwRev;          // must be 1
    DWORD       dwCmd;          // one of above NDDEAGT_CMD_*
    DWORD       qwModifyId[2];  // modify Id of the share
    UINT        fuCmdShow;      // fuCmdShow to use with WinExec()
    char        szData[1];      // sharename\0 cmdline\0
} NDDEAGTCMD;
typedef NDDEAGTCMD *PNDDEAGTCMD;

#define DDE_SHARE_KEY_MAX           512
#define TRUSTED_SHARES_KEY_MAX      512
#define TRUSTED_SHARES_KEY_SIZE     15
#define KEY_MODIFY_ID_SIZE          8

#define DDE_SHARES_KEY_A                "SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_A            "SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_A    "DEFAULT\\"##TRUSTED_SHARES_KEY_A
#define TRUSTED_SHARES_KEY_PREFIX_A     "DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_A    "DDEDBi12345678"
#define KEY_MODIFY_ID_A                 "SerialNumber"
#define KEY_DB_INSTANCE_A               "ShareDBInstance"
#define KEY_CMDSHOW_A                   "CmdShow"
#define KEY_START_APP_A                 "StartApp"
#define KEY_INIT_ALLOWED_A              "InitAllowed"

#define DDE_SHARES_KEY_W                L"SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_W            L"SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_W    L"DEFAULT\\"##TRUSTED_SHARES_KEY_A
#define TRUSTED_SHARES_KEY_PREFIX_W     L"DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_W    L"DDEDBi12345678"
#define KEY_MODIFY_ID_W                 L"SerialNumber"
#define KEY_DB_INSTANCE_W               L"ShareDBInstance"
#define KEY_CMDSHOW_W                   L"CmdShow"
#define KEY_START_APP_W                 L"StartApp"
#define KEY_INIT_ALLOWED_W              L"InitAllowed"

#define DDE_SHARES_KEY                  TEXT(DDE_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY              TEXT(TRUSTED_SHARES_KEY_A)
#define DEFAULT_TRUSTED_SHARES_KEY      TEXT(DEFAULT_TRUSTED_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY_PREFIX       TEXT(TRUSTED_SHARES_KEY_PREFIX_A)
#define TRUSTED_SHARES_KEY_DEFAULT      TEXT(TRUSTED_SHARES_KEY_DEFAULT_A)
#define KEY_MODIFY_ID                   TEXT(KEY_MODIFY_ID_A)
#define KEY_DB_INSTANCE                 TEXT(KEY_DB_INSTANCE_A)
#define KEY_CMDSHOW                     TEXT(KEY_CMDSHOW_A)
#define KEY_START_APP                   TEXT(KEY_START_APP_A)
#define KEY_INIT_ALLOWED                TEXT(KEY_INIT_ALLOWED_A)

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\secinfo.h ===
#ifndef H__secinfo
#define H__secinfo

#include "netbasic.h"

typedef struct TAGsi {
    struct TAGsi FAR	*prev;
    struct TAGsi FAR	*next;
    char		 fromNode[ MAX_NODE_NAME+1 ];
    char		 fromApp[ 256 ];
    int			 pr;
    int			 pw;
    int			 pe;
    int			 ps;
    char		 toApp[ 256 ];
    char		 toTopic[ 256 ];
    char		 cmd[ 256 ];
} SECINFO;
typedef SECINFO FAR *LPSECINFO;

/*** this routine loads the initial security info ***/
BOOL		FAR PASCAL SecInfoLoad( void );

/*** the following 3 routines are used to gather the current list 
 ***/
VOID		FAR PASCAL SecInfoRewind( void );
LPSECINFO	FAR PASCAL SecInfoNext( void );
VOID		FAR PASCAL SecInfoDone( void );

/*** SecInfoReplaceList() saves this new list to disk, replaces the
	current list with the new one and frees the memory for the
	old one
 ***/
BOOL		FAR PASCAL SecInfoReplaceList( LPSECINFO lpSecInfoNewList );

LPSECINFO	FAR PASCAL SecInfoCreate( void );
VOID		FAR PASCAL SecInfoSetDefault( LPSECINFO lpSecInfo );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\tmpbuf.h ===
#ifndef H__tmpbuf
#define H__tmpbuf

extern char	tmpBuf [500];
extern char	tmpBuf2[500];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\timer.h ===
#ifndef H__timer
#define H__timer

typedef VOID (*FP_TimerCallback) (  DWORD_PTR dwUserInfo1, 
				    DWORD dwUserInfo2,
				    DWORD_PTR dwUserInfo3 );

HTIMER	TimerSet(   long timeoutPeriod,		/* msec */
		    FP_TimerCallback TimerCallback,
		    DWORD_PTR dwUserInfo1,
		    DWORD dwUserInfo2,
		    DWORD_PTR dwUserInfo3 );

BOOL	TimerDelete( HTIMER hTimer );

VOID	TimerSlice( void );

/*
    The following is a list of timeouts that the user must set up
 */

/* timeoutRcvConnCmd: how long to wait from when netintf tells us we have
    a conection to when we recv the connect command from the other side */
extern DWORD	timeoutRcvConnCmd;

/* timeoutRcvConnRsp: how long to wait from when we send the conn cmd
    to when we recv the connect command response from the other side */
extern DWORD	timeoutRcvConnRsp;

/* timeoutMemoryPause: how long to wait between sending packets that cause
    memory errors on the remote side. */
extern DWORD	timeoutMemoryPause;

/* timeoutSendRsp: how long to wait between sending a packet and expecting
    a response from the other side regarding that packet */
extern DWORD	timeoutSendRsp;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\tools.h ===
#ifndef H__tools
#define H__tools

/*lint +fvr    Routines that exhibit varying return mode */
extern LPSTR FAR PASCAL lstrcpy( LPSTR, LPSTR );
extern LPSTR FAR PASCAL lstrcat( LPSTR, LPSTR );
extern int   FAR PASCAL lstrlen( LPSTR );
/*lint -fvr    End of routines that exhibit varying return mode */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\tmpbufc.h ===
/* use only in .c file and only 1 per application */
#include "tmpbuf.h"

char	tmpBuf [500];
char	tmpBuf2[500];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\unddesi.h ===
/* UNDDESHAREINFO - contains information about a NDDE share */

struct UNDdeShareInfo_tag {
    LONG            lRevision;
    LPWSTR          lpszShareName;
    LONG            lShareType;
    LPWSTR          lpszAppTopicList;
    LONG            fSharedFlag;
    LONG            fService;
    LONG            fStartAppFlag;
    LONG            nCmdShow;
    LONG            qModifyId[2];
    LONG            cNumItems;
    LPWSTR          lpszItemList;
};
typedef struct UNDdeShareInfo_tag   UNDDESHAREINFO;
typedef struct UNDdeShareInfo_tag * PUNDDESHAREINFO;

/*
    Special commands
*/
#define NDDE_SC_TEST        0
#define NDDE_SC_REFRESH     1
#define NDDE_SC_GET_PARAM   2
#define NDDE_SC_SET_PARAM   3
#define NDDE_SC_DUMP_NETDDE 4

struct sc_param {
    LONG    pType;
    LONG    offSection;
    LONG    offKey;
    LONG    offszValue;
    UINT    pData;
};

typedef struct sc_param SC_PARAM;
typedef struct sc_param * PSC_PARAM;

#define SC_PARAM_INT    0
#define SC_PARAM_STRING 1

void    RefreshNDDECfg(void);
void    RefreshDSDMCfg(void);
void    DebugDdeIntfState();
void    DebugDderState();
void    DebugRouterState();
void    DebugPktzState();



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\userdde.h ===
#ifndef H__userdde
#define H__userdde

#include "ddepkt.h"

VOID		DebugDdePkt( LPDDEPKT lpDdePkt );

LPDDEPKT	CreateInitiatePkt(
    LPSTR   lpszToNode, 
    LPSTR   lpszToApp,
    LPSTR   lpszToTopic,
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    DWORD   dwSecurityType,
    PSECURITY_QUALITY_OF_SERVICE    pqosClient,
    LPBYTE  lpPassword,
    DWORD   dwPasswordSize,
    DWORD   hSecurityKey);

LPDDEPKT	CreateAckInitiatePkt(
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszFromTopic,
    LPBYTE  lpSecurityKey,
    DWORD   dwSecurityKeySize,
    DWORD   hSecurityKey,
    BOOL    bSuccess,
    DWORD   dwReason );

LPDDEPKT	CreateExecutePkt( LPSTR lpszCommand );

LPDDEPKT	CreateTerminatePkt( void );

VOID		FillTerminatePkt( LPDDEPKT lpDdePkt );

LPDDEPKT	CreateAckExecutePkt( BOOL fAck, BOOL fBusy, BYTE bAppRtn );

LPDDEPKT	CreateGenericAckPkt( WORD wDdeMsg, LPSTR lpszItem, 
		    BOOL fAck, BOOL fBusy, BYTE bAppRtn );

LPDDEPKT	CreateRequestPkt( LPSTR lpszItem, WORD cfFormat );

LPDDEPKT	CreateUnadvisePkt( LPSTR lpszItem, WORD cfFormat );

LPDDEPKT	CreateAdvisePkt( LPSTR lpszItem, WORD cfFormat,
		    BOOL fAckReq, BOOL fNoData );

LPDDEPKT	CreateDataPkt( LPSTR lpszItem, WORD cfFormat,
		    BOOL fResponse, BOOL fAckReq, BOOL fRelease,
		    LPVOID lpData, DWORD dwSizeOfData );

LPDDEPKT	CreatePokePkt( LPSTR lpszItem, WORD cfFormat,
		    BOOL fRelease, LPVOID lpData, DWORD dwSizeOfData );

LPDDEPKT	DdePktCopy( LPDDEPKT lpDdePkt );

WORD		GetClipFormat( LPDDEPKT lpDdePkt, WORD cfFormat,
		    WORD wOffsFormat );

LPDDEPKT FAR PASCAL CreateTestPkt( int nTestNo, int nPacket, 
			int nNum, DWORD dwSize );

/* LPSTR	GetStringOffset( LPDDEPKT lpDdePkt, WORD wOffsString ); */
#define GetStringOffset( lpDdePkt, wOffsString ) \
	(((LPSTR)(lpDdePkt)) + (wOffsString))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\verify.h ===
#ifndef H__verify
#define H__verify

/*
    Verify Methods
 */
#define VERMETH_CRC16		(1)		/* CRC-16 */
#define VERMETH_CKS32		(2)		/* 32-bit checksum */

BOOL	FAR PASCAL VerifyHdr( LPNETPKT lpPacket );
BOOL	FAR PASCAL VerifyData( LPNETPKT lpPacket );
VOID	FAR PASCAL PreparePktVerify( BYTE verifyMethod, LPNETPKT lpPacket );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\udselbox.h ===
#ifndef H__selbox
#define H__selbox

/*  SelBoxInit( hInst ) will register window classes and should only be called
   at the beginning of a program.
 */      
VOID 	FAR PASCAL	SelBoxInit( HANDLE );

/*  
	    SelBoxSetupStart( hWnd, title, noEntryMsg, numCols, lFlags );

    SelBoxSetupStart() gets passed a window handle that is the parent 
    of this window and "numCols".

    "title" will be displayed in the caption for the user
	
    "noEntryMsg" will be display in the window when there are no
    entries

    If numCols is 0, SelBox() routines will determine the
    optimum # to display on the screen.  Otherwise, SelBox() routines
    will use the number you pass.

    "lFlags" can be one of the following:
	SBSTYLE_RADIO_BUTTONS		otherwise check-box style
	SBSTYLE_RETURN_ON_SELECTION	otherwise wait for OK
	SBSTYLE_SORT_ENTRIES		otherwise put in order of calls
	SBSTYLE_ENTRIES_PRESORTED	put in order but knows that 
					they're sorted


 */	
VOID	FAR PASCAL	SelBoxSetupStart( HWND, PSTR, PSTR, int, LONG );

/*  

    BOOL SelBoxAddEntry( string, value, wFlags )

    SelBoxAddEntry() gets passed a string a value and flags.  If the user 
    clicks on this string, "value" is returned by SelBoxUserSelect().  

    The wFlags are:
        SBENTRY_DISABLED
        SBENTRY_SELECTED

    Return is FALSE for out of memory errors

 */
BOOL	FAR PASCAL	SelBoxAddEntry( LPSTR, LONG, WORD );

/*  SelBoxUserSelect( hInst, lButtons, vPosition, nFixed ) actually 
    displays the strings set up by SelBoxAddEntry(). The box is displayed
    at the vertical screen position specified by "vPosition"

    "lButtons" specifies which of the following buttons should be
    enabled:
	SB_BUTTON_NEW
	SB_BUTTON_MODIFY
	SB_BUTTON_DELETE
	SB_BUTTON_CANCEL
	SB_BUTTON_OK

    and returns one of the buttons:	  

        SB_BUTTON_OK
        SB_BUTTON_CANCEL
        SB_BUTTON_NEW
        SB_BUTTON_MODIFY
        SB_BUTTON_DELETE

   "nFixed" is set to 0 to allow free-format lengths.  If nFixed is non-zero,
   the sizes for the entries are fixed at the length specified by nFixed.

 */
LONG	FAR PASCAL	SelBoxUserSelect( HANDLE, LONG, int, int );

/*	SelBoxUserSelection() will return the handle of a sellist (hMem).
	Use 
	    SelListNumSelections( hMem )
	    SelListGetSelection( hMem, n )
	    SelListFree( hMem )
 */	     
HANDLE	FAR PASCAL	SelBoxUserSelection( void );

/*
   SelBoxCancel() simulates the user hitting the cancel button

   NOTE: It IS OK to call this routine when no selection box is displayed

 */
VOID FAR PASCAL SelBoxCancel( void );


/*
   SelBoxDoneOK( lButton ) simulates the user hitting one of the other buttons

   NOTE: It IS OK to call this routine when no selection box is displayed

 */
VOID FAR PASCAL SelBoxDoneOK( LONG );

#define SBSTYLE_RADIO_BUTTONS		0x00000001L
#define SBSTYLE_RETURN_ON_SELECTION	0x00000002L
#define SBSTYLE_SORT_ENTRIES		0x00000004L
#define SBSTYLE_ENTRIES_PRESORTED	0x00000008L

#define SBENTRY_DISABLED		0x0001
#define SBENTRY_SELECTED		0x0002
#define SBENTRY_LABEL			0x0004

/** If you add an entry here, be sure to add the button name, etc.
    to the "buttonList" in selbox.c
 **/
#define SB_BUTTON_NEW		0x00000001L
#define SB_BUTTON_MODIFY	0x00000002L
#define SB_BUTTON_DELETE	0x00000004L
#define SB_BUTTON_CANCEL	0x00000010L
#define SB_BUTTON_OK		0x00000020L

#define SB_BUTTON_NORMAL   (SB_BUTTON_CANCEL | SB_BUTTON_OK)
#define SB_BUTTON_ALL      (0xFFL)

/*
    Selection list manipulation routines
 */
int	FAR PASCAL SelListNumSelections( HANDLE );
LONG	FAR PASCAL SelListGetSelection( HANDLE, int );
VOID	FAR PASCAL SelListFree( HANDLE );
HANDLE	FAR PASCAL SelListCreate( int, WORD );
VOID	FAR PASCAL SelListSetSelection( HANDLE, int, LONG );
BOOL	FAR PASCAL SelListIsInList( HANDLE, LONG );
HANDLE	FAR PASCAL SelListCopy( HANDLE );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\windeflt.h ===
#ifndef H__windeflt
#define H__windeflt

VOID FAR PASCAL WriteWindowSizeToWinIni( HWND );
VOID FAR PASCAL AdjustWindowSizeFromWinIni( HWND );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\wwassert.h ===
#ifndef H__assert
#define H__assert

#include "debug.h"

VOID FAR PASCAL AssertLog( LPSTR, int );

#define USES_ASSERT	static char *__assertFile__ = __FILE__;

#define assert(x) 						\
    {								\
	if( !(x) )  {						\
	    AssertLog( __assertFile__, __LINE__ );			\
	}							\
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\winmsg.h ===
#ifndef H__WINMSG
#define H__WINMSG

#define NETDDEMSG_GETNODENAME	"NetddeGetOurNodeName"	
#define NETDDEMSG_GETCLIENTINFO	"NetddeGetClientInfo"
#define NETDDEMSG_SESSIONENUM	"NetddeSessionEnum"
#define NETDDEMSG_CONNENUM	"NetddeConnectionEnum"
#define NETDDEMSG_SESSIONCLOSE	"NetddeSessionClose"
#define NETDDEMSG_PASSDLGDONE   "NetddePasswordDlgDone"

/*
    CMD/RSP for client info.
        fTouched must be set by NetDDE
 */
typedef struct {
    LONG	fTouched;
    LONG_PTR hWndClient;
    LONG	cClientNodeLimit;
    LONG	cClientAppLimit;
} INFOCLI_CMD;
typedef INFOCLI_CMD FAR *LPINFOCLI_CMD;

typedef struct {
    LONG	fTouched;
    LONG	lReturn;
    WORD	offsClientNode;
    WORD	offsClientApp;
} INFOCLI_RSP;
typedef INFOCLI_RSP FAR *LPINFOCLI_RSP;

typedef struct {
    LONG	fTouched;
    LONG	nLevel;
    LONG	lReturnCode;
    DWORD	cBufSize;
    DWORD	cbTotalAvailable;
    DWORD	nItems;
} SESSENUM_CMR;
typedef SESSENUM_CMR FAR *LPSESSENUM_CMR;

typedef struct {
    LONG	fTouched;
    LONG	nLevel;
    LONG	lReturnCode;
    char	clientName[ UNCLEN+1 ];
    short	pad;
    DWORD	cookie;
    DWORD	cBufSize;
    DWORD	cbTotalAvailable;
    DWORD	nItems;
} CONNENUM_CMR;
typedef CONNENUM_CMR FAR *LPCONNENUM_CMR;

typedef struct {
    LONG	fTouched;
    LONG	lReturnCode;
    char	clientName[ UNCLEN+1 ];
    short	pad;
    DWORD_PTR cookie;
} SESSCLOSE_CMR;
typedef SESSCLOSE_CMR FAR *LPSESSCLOSE_CMR;

typedef struct {
    DWORD	dwReserved;		/* must be 1 */
    LPSTR   	lpszUserName;
    LPSTR   	lpszDomainName;
    LPSTR	lpszPassword;
    DWORD	fCancelAll;
} PASSDLGDONE;
typedef PASSDLGDONE FAR *LPPASSDLGDONE;

BOOL FAR PASCAL PasswordDlgDone( 
    HWND    	hWndPasswordDlg,
    LPSTR   	lpszUserName,
    LPSTR   	lpszDomainName,
    LPSTR   	lpszPassword,
    DWORD	fCancelAll
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ddeshare\ddeshare.h ===
/* $Header: "Ver=%v  %f  LastEdit=%w  Locker=%l" */
/* "Ver=1  16-Nov-92,15:47:10  LastEdit=BILL  Locker=***_NOBODY_***" */
/***********************************************************************\
*                                                                       *
*       Copyright Wonderware Software Development Corp. 1989            *
*                                                                       *
*                       ThisFileName="d:\ww\src\spccvt\spccvt.h" *
*                       LastEditDate="1992 Nov 16  15:47:11"            *
*                                                                       *
\***********************************************************************/


#ifndef H__udprot
#define H__udprot

#ifndef LINT_ARGS
#define LINT_ARGS
#endif

#define IDSABOUT                200

BOOL		FAR PASCAL ProtGetDriverName( LPSTR lpszName, int nMaxLength);
HANDLE		FAR PASCAL GetGlobalAlloc( WORD wFlags, DWORD dwSize );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\wwheap.h ===
#ifndef H__wwheap
#define H__wwheap

typedef LONG	   WHMEM;
typedef LONG	   HPFIXUP;
typedef WHMEM FAR *LPWHMEM;
typedef LONG	   HHEAP;

HHEAP   FAR PASCAL HeapInit( void );
BOOL    FAR PASCAL HeapRelease( HHEAP hHeap );

WHMEM	FAR PASCAL HeapAlloc( HHEAP hHeap, WORD wFlags, DWORD dwSize );
WHMEM	FAR PASCAL HeapReAlloc( HHEAP hHeap, WHMEM whMem, 
				       DWORD dwSize, WORD wFlags);
LPVOID  FAR PASCAL HeapLock( HHEAP hHeap, WHMEM whMem );
#define		   HeapUnlock( hHeap, whMem )	// do nothing
VOID	FAR PASCAL HeapFree( HHEAP hHeap, WHMEM whMem );
LONG	FAR PASCAL HeapSize( HHEAP hHeap, WHMEM whMem );
LPVOID	FAR PASCAL HeapAllocPtr( HHEAP hHeap, WORD wFlags, DWORD dwSize );
VOID	FAR PASCAL HeapFreePtr( LPVOID lpPtr );
LPVOID	FAR PASCAL HeapReAllocPtr( LPVOID lpPtr, WORD wFlags, DWORD dwSize );

VOID	FAR PASCAL HeapSetFirstFit( HHEAP hHeap );
VOID	FAR PASCAL HeapSetBestFit( HHEAP hHeap );
VOID	FAR PASCAL HeapSetAllocOnly( HHEAP hHeap );

// internal use only from here on
HHEAP   FAR PASCAL HeapRead( int fd );
BOOL    FAR PASCAL HeapWrite( int fd, HHEAP hHeap );
BOOL    FAR PASCAL HeapDoneAllocating( HHEAP hHeap );
BOOL	FAR PASCAL HeapFixup( LPVOID lpFixup );
VOID	FAR PASCAL HeapFreeFixups( HHEAP hHeap );
HPFIXUP	FAR PASCAL HeapGetFixupInfo( HHEAP hHeap, LPVOID lpPointer );
LPVOID	FAR PASCAL HeapGetPtrFixed( HHEAP hHeap, HPFIXUP hpFixup );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\incs\wwdde.h ===
#ifndef H__wwdde
#define H__wwdde

#define WM_DDE_ACK_INITIATE	(WM_DDE_LAST+1)
#define WM_DDE_ACK_EXECUTE	(WM_DDE_LAST+2)
#define WM_DDE_ACK_ADVISE	(WM_DDE_LAST+3)
#define WM_DDE_ACK_REQUEST	(WM_DDE_LAST+4)
#define WM_DDE_ACK_UNADVISE	(WM_DDE_LAST+5)
#define WM_DDE_ACK_POKE		(WM_DDE_LAST+6)
#define WM_DDE_ACK_DATA		(WM_DDE_LAST+7)
#define WM_DDE_WWTEST		(WM_DDE_LAST+8)
#define WM_HANDLE_DDE_INITIATE	(WM_DDE_LAST+9)
#define WM_HANDLE_DDE_INITIATE_PKT	(WM_DDE_LAST+10)

/* don't add any more here without changing ddeq.h, since it relies on only
    16 total messages! */

#define CF_INTOUCH_SPECIAL	(15)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ddeshare\ddeshare.c ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    DDESHARE.C

    DDE Share Access Applettee. Allows shares and trusted shares to be
    viewed, created, or modified.

    Revisions:
    12-92   PhilH.  Wonderware port from WFW'd DDEShare.
     3-93   IgorM.  Wonderware overhaul. Add trust share access.
                    Access all share types. New Security convictions.

   $History: End */

#define UNICODE
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "nddeapi.h"
#include "nddeapip.h"
#include "dialogs.h"
#include "debug.h"
#include "hexdump.h"
#include "tmpbuf.h"
#include "rc.h"
#include "nddeagnt.h"
#include <htmlhelp.h>

#define DDESHARE_VER    TEXT("Version 1.00.12 NT")

// Flags and typedef for the NT LanMan computer browser dialog.
// The actual function is I_SystemFocusDialog, in NTLANMAN.DLL.
#define FOCUSDLG_DOMAINS_ONLY        (1)
#define FOCUSDLG_SERVERS_ONLY        (2)
#define FOCUSDLG_SERVERS_AND_DOMAINS (3)
typedef UINT (APIENTRY *LPFNSYSFOCUS)(HWND, UINT, LPWSTR, UINT, PBOOL,
      LPWSTR, DWORD);
// Typedef for the ShellAbout function
typedef void (WINAPI *LPFNSHELLABOUT)(HWND, LPTSTR, LPTSTR, HICON);

HWND            hWndParent;
BOOL            bNetDDEdbg  = FALSE;
HICON           hIcon1, hIcon2;
HINSTANCE       hInst;
LPTSTR          lpszServer;
TCHAR           szTargetComputer[MAX_COMPUTERNAME_LENGTH+3];
TCHAR           szClassName[] = TEXT("NetDDEShareClass");
TCHAR           szAppName[20];
HANDLE          hAccel;

int WINAPI WinMain( HINSTANCE, HINSTANCE, LPSTR, int );
BOOL FAR PASCAL InitializeApplication( void );
BOOL FAR PASCAL InitializeInstance(LPSTR lpCmdLine, int nCmdShow);
LRESULT CALLBACK
DdeShareWindowProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK About( HWND hDlg, UINT message, WPARAM wParam,
                        LPARAM lParam);
LRESULT CALLBACK TrustSharesDlg(HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK DdeSharesDlg(HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK AddShareDlg( HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK TrustedShareDlg( HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK ServerNameDlg( HWND hDlg, UINT message,
                        WPARAM wParam, LPARAM lParam);
BOOL    RefreshShareWindow ( HWND );
BOOL    RefreshTrustedShareWindow ( HWND );
int     GetNDDEdbg(PSTR);
VOID    NDDEdbgDump(void);
VOID    ReverseNDDEdbg(WPARAM, PSTR);
BOOL ChangeMenuId(HMENU hMenu, UINT cmd, int ids, UINT cmdInsert, UINT flags);
LPTSTR IdToSz(int ids);
LPTSTR lstrcatId(LPTSTR szBuf, int id);
int MessageBoxId(HWND hwndParent, int idsText, int idsCaption, UINT mb);
extern VOID HandleError ( HWND hwnd, int ids, UINT code );

int
WINAPI
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpszCmdLine,
    int nCmdShow)
{
    MSG         msg;
    DWORD       len;

    hInst = hInstance;
    msg.wParam = 0;

    LoadString(hInst, IDS_APPNAME, szAppName, sizeof(szAppName)/sizeof(TCHAR));

    /*  Setup the configuration file path in a permenent string (in DS).
        Strip trailing blanks and tack on a \ if needed.
    */

    DebugInit( "DDESHARE" );

    if (*lpszCmdLine == '+') {
        bNetDDEdbg = TRUE;
        lpszCmdLine++;
    }
    if( *lpszCmdLine == '\0' )  {
        len = MAX_COMPUTERNAME_LENGTH + 1;
        lstrcpy( szTargetComputer, TEXT("\\\\") );
        if( GetComputerName( &szTargetComputer[2], &len ) ) {
            lpszServer = szTargetComputer;
        } else {
            lpszServer = NULL;
        }
#ifdef UNICODE
        DPRINTF(( "%ws Targetting local computer", DDESHARE_VER ));
#else
        DPRINTF(( "%s Targetting local computer", DDESHARE_VER ));
#endif
    } else {
#ifdef UNICODE
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszCmdLine, -1,
                        szTargetComputer, MAX_COMPUTERNAME_LENGTH+3 );
        // if lpszCmdLine is >=18 chars, then all 18 chars are copied, but
        // it is NOT necessarily NULL terminated.  Make the 18th char NULL.
        szTargetComputer[MAX_COMPUTERNAME_LENGTH+2] = '\0';
#else
        // lstrcpyn always null-terminates
        lstrcpyn(szTargetComputer, lpszCmdLine, MAX_COMPUTERNAME_LENGTH+3);
#endif

        lpszServer = szTargetComputer;
#ifdef UNICODE
        DPRINTF(( "%ws Targetting \"%ws\"", DDESHARE_VER, lpszServer ));
#else
        DPRINTF(( "%s Targetting \"%s\"", DDESHARE_VER, lpszServer ));
#endif
    }
    if( !InitializeApplication() ) {
        DPRINTF(("Could not initialize application"));
        return 0;
    }

    if( !InitializeInstance(lpszCmdLine, nCmdShow) ) {
        DPRINTF(("Could not initialize instance"));
        return 0;
    }

    while (GetMessage ((LPMSG)&msg, (HWND)NULL, 0, 0)) {
        if (!TranslateAccelerator(hWndParent, hAccel, &msg)) {
            TranslateMessage ( &msg);
            DispatchMessage (&msg);
        }
    }

    return( (int) msg.wParam );
}

BOOL FAR PASCAL InitializeApplication( void )
{
    WNDCLASS  wc;

    // Register the frame class
    wc.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS
                        | CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = DdeShareWindowProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInst;
    wc.hIcon         = LoadIcon( hInst, MAKEINTRESOURCE(IDICON_NetDDE) );
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE+1);
    wc.lpszMenuName  = MAKEINTRESOURCE(IDMENU_DdeShareMenu);
    wc.lpszClassName = szClassName;

    if (!RegisterClass (&wc))  {
        return( FALSE );
    }

    return TRUE;
}


/*----------------------  InitializeInstance  --------------------------*/


BOOL
FAR PASCAL
InitializeInstance(
    LPSTR   lpCmdLine,
    int     nCmdShow)
{
    TCHAR   szBuf[100];
    HMENU   hDebugMenu;

    // Create the parent window

    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(DSACCEL));
    if (!hAccel) {
        return(FALSE);
    }

    hWndParent = CreateWindow (szClassName,
            szAppName,
            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT,
            0,
            300,
            150,
            NULL,
            NULL,
            hInst,
            NULL);

    if (hWndParent ) {
        lstrcpy(szBuf, szAppName);
        lstrcatId(szBuf, IDS_ON);
        lstrcat(szBuf, lpszServer);
        SetWindowText(hWndParent, szBuf);
        if( bNetDDEdbg )  {
            hDebugMenu = GetSystemMenu( hWndParent, FALSE );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU1, IDM_DEBUG_DDE,    MF_APPEND | MF_STRING | MF_MENUBARBREAK );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU2, IDM_LOG_INFO,     MF_APPEND | MF_STRING );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU3, IDM_LOG_ERRORS,   MF_APPEND | MF_STRING );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU4, IDM_LOG_DDE_PKTS, MF_APPEND | MF_STRING );
            ChangeMenuId(hDebugMenu, 0, IDS_MENU5, IDM_DEBUG_NETDDE, MF_APPEND | MF_STRING );
            CheckMenuItem( hDebugMenu, IDM_LOG_INFO,
                GetNDDEdbg("DebugInfo") ? MF_CHECKED : MF_UNCHECKED );
            CheckMenuItem( hDebugMenu, IDM_LOG_DDE_PKTS,
                GetNDDEdbg("DebugDdePkts") ? MF_CHECKED : MF_UNCHECKED );
            CheckMenuItem( hDebugMenu, IDM_LOG_ERRORS,
                GetNDDEdbg("DebugErrors") ? MF_CHECKED : MF_UNCHECKED );
            CheckMenuItem( hDebugMenu, IDM_DEBUG_DDE,
                GetNDDEdbg("DebugDDEMessages") ? MF_CHECKED : MF_UNCHECKED );
        }

        ShowWindow (hWndParent, nCmdShow);
        UpdateWindow (hWndParent);
        return TRUE;
    }

    return FALSE;
}

VOID
CenterDlg(HWND hDlg)
{
    int             screenHeight;
    int             screenWidth;
    RECT            rect;

    GetWindowRect(hDlg, &rect);

    screenHeight = GetSystemMetrics(SM_CYSCREEN);
    screenWidth  = GetSystemMetrics(SM_CXSCREEN);

    MoveWindow(hDlg,
           (screenWidth - (rect.right - rect.left)) / 2,
           (screenHeight - (rect.bottom - rect.top)) / 2,
           rect.right - rect.left,
           rect.bottom - rect.top,
           FALSE);
    SetFocus(GetDlgItem(hDlg, IDOK));
}

LRESULT
CALLBACK
About(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        return FALSE;

    case WM_COMMAND:
        EndDialog(hDlg, TRUE);
        return TRUE;

    default:
        return FALSE;
    }
}

LRESULT CALLBACK
DdeShareWindowProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    int         x, y;
    PAINTSTRUCT ps;
    HDC         hDC;

    switch (msg)  {

    case WM_CREATE:
        START_NETDDE_SERVICES(hWnd);
        hIcon1 = LoadIcon(hInst, MAKEINTRESOURCE(IDICON_DdeShare));
        hIcon2 = LoadIcon(hInst, MAKEINTRESOURCE(IDICON_TrustShare));
        break;

    case WM_PAINT:
        hDC = BeginPaint(hWnd, &ps);
        DrawIconEx(hDC, 10, 10, hIcon1, 0, 0, 0, NULL, DI_NORMAL | DI_DEFAULTSIZE | DI_NOMIRROR);
        DrawIconEx(hDC, 62, 10, hIcon2, 0, 0, 0, NULL, DI_NORMAL | DI_DEFAULTSIZE | DI_NOMIRROR);
        EndPaint(hWnd, &ps);
        break;

    case WM_LBUTTONDBLCLK:
        x = LOWORD(lParam);
        y = HIWORD(lParam);
        if (y > 10 && y < 42) {
            if (x > 10 && x < 42) {
                PostMessage(hWnd, WM_COMMAND, IDM_DDESHARES, 0L);
            } else if (x > 62 && x < 94) {
                PostMessage(hWnd, WM_COMMAND, IDM_TRUSTSHARES, 0L);
            }
        }
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam ) ) {
        case IDM_DDESHARES:
            DialogBoxParam(hInst, MAKEINTRESOURCE(DID_DDESHARES_DLG), hWnd,
                                (DLGPROC) DdeSharesDlg, 0L );
            break;

        case IDM_TRUSTSHARES:
            DialogBoxParam(hInst, MAKEINTRESOURCE(DID_TRUSTSHARES_DLG), hWnd,
                                (DLGPROC) TrustSharesDlg, 0L );
            break;

        case IDM_SERVERNAME:
             {
             WCHAR rgwch[MAX_COMPUTERNAME_LENGTH + 5];
             TCHAR szBuf[MAX_COMPUTERNAME_LENGTH + 32];
             BOOL  bOK = FALSE;
             BOOL  fFoundLMDlg = FALSE;
             HMODULE hMod;
             LPFNSYSFOCUS lpfn;

             rgwch[0] = TEXT('\0');

             if (hMod = LoadLibraryW(L"NTLANMAN.DLL"))
                {
                if (lpfn = (LPFNSYSFOCUS)GetProcAddress(hMod, "I_SystemFocusDialog"))
                   {
                   fFoundLMDlg = TRUE;

                   (*lpfn)(hWnd, FOCUSDLG_SERVERS_ONLY, rgwch,
                        MAX_COMPUTERNAME_LENGTH+3, &bOK, L"DdeShare.hlp",
                        HELP_DLG_SELECTCOMPUTER);

                   if (IDOK == bOK && rgwch[0])
                      {
                      #ifndef UNICODE
                      WideCharToMultiByte(CP_ACP,
                          WC_COMPOSITECHECK | WC_DISCARDNS, rgwch,
                          -1, szTargetComputer, MAX_COMPUTERNAME_LENGTH + 3, NULL, &bOK);

                      // if rgwch is >=18 chars, then all 18 chars are copied, but
                      // it is NOT necessarily NULL terminated.  Make the 18th char NULL.
                      szTargetComputer[MAX_COMPUTERNAME_LENGTH + 2] = TEXT('\0');

                      #else
                      lstrcpy(szTargetComputer, rgwch);
                      #endif

                      lpszServer = szTargetComputer;
                      }
                   // else User hit Cancel or entered an empty c-name
                   }
                // Else couldn't get the proc
                FreeLibrary(hMod);
                }
             // Else couldn't find the DLL

             // If we didn't find the fancy LanMan dialog, we still can get
             // by with our own cheesy version-- 'course, ours comes up faster, too.
             if (!fFoundLMDlg)
                {
                bOK = DialogBoxParam(hInst, MAKEINTRESOURCE(DID_SERVERNAME_DLG),
                        hWnd, (DLGPROC) ServerNameDlg, 0L ) != FALSE;
                }

             lstrcat(lstrcatId(lstrcpy(szBuf, szAppName), IDS_ON),
                        szTargetComputer);
             SetWindowText(hWnd, szBuf);
             }
            break;

        case IDM_EXIT:
            PostMessage(hWnd, WM_CLOSE, 0, 0L);
            break;

        case IDC_MYHELP:
            HtmlHelpA(hWnd, "DdeShare.chm", HH_DISPLAY_TOPIC, 0);
            break;

        case MENU_HELP_ABOUT:
            {
            HMODULE hMod;
            LPFNSHELLABOUT lpfn;

            if (hMod = LoadLibrary(TEXT("SHELL32"))) {
               if (lpfn = (LPFNSHELLABOUT)GetProcAddress(hMod,
                      #ifdef UNICODE
                        "ShellAboutW"
                      #else
                        "ShellAboutA"
                      #endif
                      )) {
                  (*lpfn)(hWnd, szAppName, TEXT(""),
                        LoadIcon(hInst, MAKEINTRESOURCE(IDICON_NetDDE)));
               }
               FreeLibrary(hMod);
            }
            // Else couldn't load lib
            }
            break;

         default:
            return DefWindowProc( hWnd, msg, wParam, lParam );
            break;
        }
        break;

    case WM_SYSCOMMAND:
        switch( LOWORD(wParam) ) {
        case IDM_DEBUG_DDE:
            ReverseNDDEdbg(wParam, "DebugDDEMessages");
            break;
        case IDM_LOG_INFO:
            ReverseNDDEdbg(wParam, "DebugInfo");
            break;
        case IDM_LOG_ERRORS:
            ReverseNDDEdbg(wParam, "DebugErrors");
            break;
        case IDM_LOG_DDE_PKTS:
            ReverseNDDEdbg(wParam, "DebugDdePkts");
            break;
        case IDM_DEBUG_NETDDE:
            NDDEdbgDump();
            break;
        default:
            return (DefWindowProc(hWnd, msg, wParam, lParam));
            break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage (0);
        return DefWindowProc( hWnd, msg, wParam, lParam );
        break;

    default:
        return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    return 0;
}

BOOL
RefreshShareWindow ( HWND hDlg )
{
    UINT    RetCode;
    DWORD   entries;
    DWORD   avail;
    HWND    hCtl;
    TCHAR * s;
    LPBYTE  lpBuf;
    BOOL    OK;

    /* probe for lenght */
    RetCode = NDdeShareEnum ( lpszServer, 0, (LPBYTE)NULL, 0, &entries, &avail );
    if (RetCode != NDDE_BUF_TOO_SMALL) {
        HandleError ( hWndParent, IDS_ERROR8, RetCode );
        return FALSE;
    }
    lpBuf = LocalAlloc(LPTR, avail);
    if (lpBuf == NULL) {
        MessageBoxId ( hWndParent, IDS_MBTEXT6, IDS_MBCAP6,
                MB_ICONEXCLAMATION | MB_OK );
        return FALSE;
    }
    RetCode = NDdeShareEnum ( lpszServer, 0, lpBuf, avail, &entries, &avail );
    HandleError ( hWndParent, IDS_ERROR9, RetCode );
    hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
    SendMessage ( hCtl, LB_RESETCONTENT, 0, 0L );
    if (RetCode == NDDE_NO_ERROR) {
        for ( s = (TCHAR *)lpBuf; *s; s += lstrlen(s) + 1 ) {
            SendMessage(hCtl, LB_ADDSTRING, 0, (LPARAM)s );
        }
        OK = TRUE;
    } else {
        SendMessage(hCtl, LB_ADDSTRING, 0, (LPARAM)IdToSz(IDS_NOSHARES));
        OK = FALSE;
    }
    LocalFree(lpBuf);
    return(OK);
}

BOOL
RefreshTrustedShareWindow ( HWND hDlg )
{
    UINT    RetCode;
    DWORD   entries;
    DWORD   avail;
    TCHAR * s;
    HWND    hCtl;
    LPBYTE  lpBuf;

    /* probe for lenght */
    RetCode = NDdeTrustedShareEnum ( lpszServer, 0, (LPBYTE)NULL, 0, &entries, &avail );
    if (RetCode != NDDE_BUF_TOO_SMALL) {
        HandleError ( hWndParent, IDS_ERROR10, RetCode );
        return FALSE;
    }

    if (avail == 0) {
        SendDlgItemMessage ( hDlg, IDC_SHARE_LIST, LB_RESETCONTENT, 0, 0L );
        return TRUE;
    }

    lpBuf = LocalAlloc(LPTR, avail);
    if (lpBuf == NULL) {
        MessageBoxId ( hWndParent, IDS_MBTEXT6, IDS_MBCAP7,
                MB_ICONEXCLAMATION | MB_OK );
        return FALSE;
    }
    RetCode = NDdeTrustedShareEnum ( lpszServer, 0, lpBuf, avail,
            &entries, &avail );
    HandleError ( hWndParent, IDS_ERROR11, RetCode );
    hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
    SendMessage ( hCtl, LB_RESETCONTENT, 0, 0L );
    if (RetCode == NDDE_NO_ERROR) {
        for ( s = (TCHAR *)lpBuf; *s; s += lstrlen(s) + 1 ) {
            SendMessage(hCtl, LB_ADDSTRING, 0, (LPARAM)s );
        }
        LocalFree(lpBuf);
        return(TRUE);
    } else {
        LocalFree(lpBuf);
        return(FALSE);
    }
}


BOOL ChangeMenuId(
HMENU hMenu,
UINT cmd,
int ids,
UINT cmdInsert,
UINT flags)
{
    TCHAR szBuf[40];

    LoadString(hInst, ids, szBuf, sizeof(szBuf)/sizeof(TCHAR));
    return(ChangeMenu(hMenu, cmd, szBuf, cmdInsert, flags));
}


LPTSTR IdToSz(
int ids)
{
    static TCHAR szBuf[1000];

    LoadString(hInst, ids, szBuf, sizeof(szBuf)/sizeof(TCHAR));
    return(szBuf);
}


LPTSTR lstrcatId(
LPTSTR szBuf,
int id)
{
    TCHAR sz[100];

    LoadString(hInst, id, sz, sizeof(sz)/sizeof(TCHAR));
    return(lstrcat(szBuf, sz));
}


int MessageBoxId(
HWND hwndParent,
int idsText,
int idsCaption,
UINT mb)
{
    TCHAR szText[200];
    TCHAR szCap[30];

    LoadString(hInst, idsText, szText, sizeof(szText)/sizeof(TCHAR));
    LoadString(hInst, idsCaption, szCap, sizeof(szCap)/sizeof(TCHAR));
    return(MessageBox(hwndParent, szText, szCap, mb));
}

VOID HandleError (
    HWND    hwnd,
    int     ids,
    UINT    code )
{
    TCHAR szBuf[128];
    TCHAR s[128];

    if ( code == NDDE_NO_ERROR )
            return;
    LoadString(hInst, ids, s, sizeof(s)/sizeof(TCHAR));
    NDdeGetErrorString ( code, szBuf, 128 );
    MessageBox ( hwnd, szBuf, s, MB_ICONEXCLAMATION | MB_OK );
}

LRESULT
CALLBACK
DdeSharesDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    int             idx;
    HWND            hCtl;
    UINT            RetCode;
    TCHAR           szBuf[128];

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        if (RefreshShareWindow(hDlg) == FALSE) {
            PostMessage(hDlg, IDCANCEL, 0, 0L);
            return(FALSE);
        }
        SendDlgItemMessage(hDlg, IDC_SHARE_LIST, LB_SETCURSEL, 0, 0);
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_ADD_SHARE:
            if ( DialogBoxParam(hInst,
                    MAKEINTRESOURCE(DID_DDESHARE_DLG), hDlg,
                    (DLGPROC) AddShareDlg, 0L ) )
                RefreshShareWindow(hDlg);
            break;

        case IDC_DELETE_SHARE:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT1,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
            RetCode = NDdeShareDel ( lpszServer, szBuf, 0 );
            if (RetCode == NDDE_NO_ERROR) {
                RefreshShareWindow(hDlg);
                RetCode = NDdeSetTrustedShare(lpszServer, szBuf, 0);
                if (RetCode != NDDE_NO_ERROR) {
                    HandleError ( hDlg, IDS_ERROR12, RetCode);
                }
            } else {
                HandleError ( hDlg, IDS_ERROR13, RetCode);
            }
            break;
        case IDC_SHARE_LIST:
            if (HIWORD(wParam) != LBN_DBLCLK) {
                break;
            }
            /*  fall through */
        case IDC_PROPERTIES:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT2,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
            if (DialogBoxParam( hInst, MAKEINTRESOURCE(DID_DDESHARE_DLG), hDlg,
                    (DLGPROC) AddShareDlg, (LPARAM)(LPTSTR)szBuf))
                RefreshShareWindow(hDlg);
            break;
        case IDC_TRUST_SHARE:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT3,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
            DialogBoxParam( hInst, MAKEINTRESOURCE(DID_TRUSTEDSHARE_DLG), hDlg,
                (DLGPROC) TrustedShareDlg, (LPARAM)(LPTSTR)szBuf);
            break;
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return(TRUE);
}

LRESULT
CALLBACK
TrustSharesDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    int             idx;
    HWND            hCtl;
    TCHAR           szBuf[128];

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        if (RefreshTrustedShareWindow(hDlg) == FALSE) {
            PostMessage(hDlg, IDCANCEL, 0, 0L);
            return FALSE;
        }
        SendDlgItemMessage(hDlg, IDC_SHARE_LIST, LB_SETCURSEL, 0, 0);
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_SHARE_LIST:
            if (HIWORD(wParam) != LBN_DBLCLK) {
                break;
            }
            /*  fall through */
        case IDC_PROPERTIES:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT4,
                    IDS_MBCAP4,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
            DialogBoxParam( hInst, MAKEINTRESOURCE(DID_TRUSTEDSHARE_DLG), hDlg,
                (DLGPROC) TrustedShareDlg, (LPARAM)(LPTSTR)szBuf);
            break;
        case IDC_DELETE_SHARE:
            hCtl = GetDlgItem(hDlg, IDC_SHARE_LIST);
            idx = (int)SendMessage( hCtl, LB_GETCURSEL, 0, 0L );
            if ( idx == LB_ERR ) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT5,
                    IDS_MBCAP4,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }
            SendMessage( hCtl, LB_GETTEXT, idx, (LPARAM)szBuf );
            HandleError ( hDlg, IDS_ERROR14,
                NDdeSetTrustedShare ( lpszServer, szBuf, NDDE_TRUST_SHARE_DEL ) );
            RefreshTrustedShareWindow(hDlg);
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

LRESULT
CALLBACK
TrustedShareDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    BOOL            fError;
    TCHAR           szBuf[128];
    DWORD           dwOptions = 0;
    DWORD           dwSerial0, dwSerial1;
    UINT            RetCode;

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        SetDlgItemText( hDlg, IDC_SHARE_NAME, (LPCTSTR) lParam );
        RetCode = NDdeGetTrustedShare(lpszServer, (LPTSTR)lParam, &dwOptions,
            &dwSerial0, &dwSerial1);
        if (RetCode == NDDE_NO_ERROR) {
            CheckDlgButton( hDlg, IDC_START_APP, dwOptions & NDDE_TRUST_SHARE_START );
            CheckDlgButton( hDlg, IDC_INIT_ENABLE, dwOptions & NDDE_TRUST_SHARE_INIT );
            CheckDlgButton( hDlg, IDC_CMD_OVERRIDE, dwOptions & NDDE_TRUST_CMD_SHOW );
            SetDlgItemInt( hDlg, IDC_CMD_SHOW, dwOptions & NDDE_CMD_SHOW_MASK, FALSE );
        }
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_MODIFY:
        case IDOK:
            dwOptions = 0;
            GetDlgItemText(hDlg, IDC_SHARE_NAME, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            dwOptions = GetDlgItemInt(hDlg, IDC_CMD_SHOW, &fError, FALSE);
            if (IsDlgButtonChecked(hDlg, IDC_START_APP)) {
                dwOptions |= NDDE_TRUST_SHARE_START;
            }
            if (IsDlgButtonChecked(hDlg, IDC_INIT_ENABLE)) {
                dwOptions |= NDDE_TRUST_SHARE_INIT;
            }
            if (IsDlgButtonChecked(hDlg, IDC_CMD_OVERRIDE)) {
                dwOptions |= NDDE_TRUST_CMD_SHOW;
            }

            if (dwOptions == 0) {
                MessageBoxId( hDlg,
                    IDS_MBTEXT11,
                    IDS_MBCAP11,
                    MB_ICONEXCLAMATION | MB_OK );
                break;
            }

            RetCode = NDdeSetTrustedShare(lpszServer, szBuf, dwOptions);
            HandleError ( hWndParent, IDS_ERROR15, RetCode );
            if (LOWORD(wParam) == IDOK) {
                EndDialog(hDlg, TRUE);
            }
            break;

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

LRESULT
CALLBACK
ServerNameDlg(
    HWND        hDlg,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    TCHAR           szBuf[MAX_COMPUTERNAME_LENGTH + 100];
    DWORD           dwOptions = 0;

    switch (message) {

    case WM_INITDIALOG:
        CenterDlg(hDlg);
        break;

    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDOK:
            dwOptions = 0;
            GetDlgItemText(hDlg, IDC_SERVER_NAME, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            if (lstrlen(szBuf) > 0) {
                lstrcpy( szTargetComputer, TEXT("\\\\") );
                lstrcat( szTargetComputer, szBuf);
                lpszServer = szTargetComputer;
                lstrcpy(szBuf, szAppName);
                lstrcatId(szBuf, IDS_ON);
                lstrcat(szBuf, lpszServer);
                SetWindowText(hWndParent, szBuf);
            }
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
        default:
            return(FALSE);
        }
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

/*
    Special commands
*/
#define NDDE_SC_TEST        0
#define NDDE_SC_REFRESH     1
#define NDDE_SC_GET_PARAM   2
#define NDDE_SC_SET_PARAM   3
#define NDDE_SC_DUMP_NETDDE 4

struct sc_param {
    LONG    pType;
    LONG    offSection;
    LONG    offKey;
    LONG    offszValue;
    UINT    pData;
};

typedef struct sc_param SC_PARAM;
typedef struct sc_param * PSC_PARAM;

#define SC_PARAM_INT    0
#define SC_PARAM_STRING 1

int
GetNDDEdbg(LPSTR pszName)
{
    BYTE        szBuf[1024];
    PSC_PARAM   pParam;
    LPSTR       lpVal;
    UINT        Value;
    UINT        Count;
    UINT        nCount;
    UINT        RetStat;

    pParam = (PSC_PARAM)szBuf;
    pParam->pType = SC_PARAM_INT;
    pParam->offSection = sizeof(SC_PARAM);
    lpVal = (LPSTR)pParam + pParam->offSection;
    Count = sizeof(SC_PARAM);
    strcpy(lpVal, "General");
    pParam->offKey = pParam->offSection + strlen("General") + 1;
    Count += pParam->offKey;
    lpVal = (LPSTR)pParam + pParam->offKey;
    strcpy(lpVal, pszName);
    Count += strlen(pszName);
    nCount = sizeof(UINT);

    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_GET_PARAM,
            (LPBYTE)pParam, Count, (LPBYTE)&Value, &nCount);
    if (RetStat != NDDE_NO_ERROR) {
        DPRINTF(("Bad get special command: %d", RetStat));
    }
    return(Value);
}

void
SetNDDEdbg(
    LPSTR   pszName,
    UINT    inValue)
{
    BYTE        szBuf[1024];
    PSC_PARAM   pParam;
    LPSTR       lpVal;
    UINT        Size;
    UINT        Count   = 0;
    UINT        RetStat;
    UINT        Dummy = 0;


    pParam = (PSC_PARAM)szBuf;
    pParam->pType = SC_PARAM_INT;
    pParam->pData = inValue;
    pParam->offSection = sizeof(SC_PARAM);
    pParam->offszValue = 0;
    lpVal = (LPSTR)pParam + pParam->offSection;
    strcpy(lpVal, "General");
    Size = strlen("General") + 1;
    pParam->offKey = pParam->offSection + Size;
    Count += Size;
    lpVal = (LPSTR)pParam + pParam->offKey;
    strcpy(lpVal, pszName);
    Size =  strlen(pszName) + 1;
    Count += Size + sizeof(SC_PARAM);

    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_SET_PARAM,
            (LPBYTE)pParam, Count, (LPBYTE)&Dummy, &Dummy);
    if (RetStat != NDDE_NO_ERROR) {
        DPRINTF(("Bad set special command: %d", RetStat));
    }
    return;
}

VOID
NDDEdbgDump(void)
{
    UINT    RetStat;
    UINT    Dummy = 0;

    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_DUMP_NETDDE,
            (LPBYTE)&Dummy, Dummy, (LPBYTE)&Dummy, &Dummy);
    if (RetStat != NDDE_NO_ERROR) {
        DPRINTF(("Bad dump netdde special command: %d", RetStat));
    }
}

VOID
ReverseNDDEdbg(
    WPARAM  idMenu,
    LPSTR   pszIniName )
{
    HMENU       hMenu;
    int         DbgFlag;
    UINT    RetStat;
    UINT    Dummy = 0;


    hMenu = GetSystemMenu( hWndParent, FALSE );
    DbgFlag = GetNDDEdbg(pszIniName);
    if (DbgFlag) {
        DbgFlag = 0;
    } else {
        DbgFlag = 1;
    }
    CheckMenuItem( hMenu, (UINT)idMenu, DbgFlag ? MF_CHECKED : MF_UNCHECKED );
    SetNDDEdbg(pszIniName, DbgFlag);
    RetStat = NDdeSpecialCommand(lpszServer, NDDE_SC_REFRESH,
        (LPBYTE)&Dummy, Dummy,
        (LPBYTE)&Dummy, &Dummy);
    InvalidateRect( hWndParent, NULL, TRUE );
    UpdateWindow( hWndParent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ddeshare\dialogs.c ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    DIALOGS.C

    DDE Share Access Applettee. Create, view or modify share attributes.
    Calls SED to edit permissions associaed with share.

    Revisions:
    12-92   PhilH.  Wonderware port from WFW'd DDEShare.
     3-93   IgorM.  Wonderware complete overhaul. Add trust share access.
                    Access all share types. New Security convictions.

   $History: End */

#define UNICODE
#include <windows.h>
#include <string.h>
#include <stdlib.h>

#include "dialogs.h"
#include "nddeapi.h"
#include "nddesec.h"
#include "debug.h"
#include "rc.h"
#include <sedapi.h>
#include <htmlhelp.h>

//#define INIT_AUDIT
//#define DO_AUDIT

#ifdef UNICODE

#define CharStrChr wcschr

#else

#define CharStrChr strchr

#endif

/* max (max_appname, max_nddesharename) == 256 */
#define MAX_SHARE_INFO_BUF  256

/*  arbitrary limit on share info size, use dynamic alloc for completeness  */
#define MAX_ITEM_LIST_BUF   5000

PNDDESHAREINFO          lpDdeI  = NULL;
PSECURITY_DESCRIPTOR    pSD     = NULL;
TCHAR                   BigBuf[2048];
TCHAR                   szAclEdit[]    = TEXT("ACLEDIT");
CHAR                    szSedDaclEdit[] = "SedDiscretionaryAclEditor";
#ifdef DO_AUDIT
CHAR                    szSedSaclEdit[] = "SedSystemAclEditor";
#endif

typedef DWORD (*SEDDESCRETIONARYACLEDITOR)(
    HWND hWnd,
    HANDLE hInst,
    LPWSTR Server,
    PSED_OBJECT_TYPE_DESCRIPTOR ObjectTypeDescriptor,
    PSED_APPLICATION_ACCESSES ApplicationAccesses,
    LPWSTR ObjectName,
    PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
    ULONG_PTR CallbackContext,
    PSECURITY_DESCRIPTOR pSD,
    BOOLEAN CouldntReadDacl,
    BOOLEAN CantWriteDacl,
    LPDWORD SEDStatusReturn,
     DWORD SEDdummy
);

extern HANDLE hInst;
extern LPTSTR lpszServer;
#define MAX_SHAREOBJECT 64
WCHAR  ShareObjectName[MAX_SHAREOBJECT];

extern int MessageBoxId(HWND hwndParent, int idsText, int idsCaption, UINT mb);
extern VOID HandleError ( HWND hwnd, int ids, UINT code );
extern BOOL ChangeMenuId(HMENU hMenu, UINT cmd, int ids, UINT cmdInsert, UINT flags);
extern LPTSTR lstrcatId(LPTSTR szBuf, int id);
BOOL WINAPI PermissionsEdit( HWND hWnd, LPTSTR pShareName, DWORD_PTR dwSD);
#ifdef DO_AUDIT
BOOL WINAPI AuditEdit( HWND hWnd, LPTSTR pShareName, DWORD dwSD);
#endif

DWORD
SedCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG_PTR CallbackContext,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn );

#ifdef DO_AUDIT
DWORD
SedAuditCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG  CallbackContext,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn );
#endif


BOOL
GetAppName( LPTSTR lpAppTopicList, LPTSTR lpAppName, LONG lType )
{
    LPTSTR lpBar;
    LPTSTR lpApp;

    *lpAppName = (TCHAR) 0;
    lpApp = lpAppTopicList;

    switch (lType) {
        case SHARE_TYPE_NEW:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
        case SHARE_TYPE_STATIC:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
    }
    if( lpApp == (LPTSTR) NULL ) {
        return TRUE;
    }
    lpBar = CharStrChr( lpApp, TEXT('|') );
    if( lpBar != (LPTSTR) NULL ) {
        *lpBar = (TCHAR) 0;
        lstrcpy( lpAppName, lpApp );
        *lpBar = TEXT('|');
    }

    return TRUE;
}

BOOL
GetTopicName( LPTSTR lpAppTopicList, LPTSTR lpTopicName, LONG lType )
{
    LPTSTR lpBar;
    LPTSTR lpApp;

    lpApp = lpAppTopicList;
    *lpTopicName = (TCHAR) 0;

    switch (lType) {
        case SHARE_TYPE_NEW:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
        case SHARE_TYPE_STATIC:
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            lpApp = CharStrChr(lpApp, TEXT('\0'));
            lpApp++;
            break;
    }
    if( lpApp == (LPTSTR) NULL ) {
        return TRUE;
    }
    lpBar = CharStrChr( lpApp, TEXT('|') );
    if( lpBar != (LPTSTR) NULL ) {
        lpBar++;
        lstrcpy( lpTopicName, lpBar );
    }

    return TRUE;
}

/*
    Retrieve current dialog box fields into lpDdeI structure
*/
LONG
GetShareInfo(HWND    hDlg)
{
    HWND        hWndLB;
    LONG        lSize = sizeof(NDDESHAREINFO);
    LONG        lChars, lTmp;
    LONG        lRtn;
    PTCHAR      ptTmp;
    int         i, n = 0;
    BOOL        bFirst;
    LPTSTR      lpTmpList;
    TCHAR       dBuf[MAX_SHARE_INFO_BUF];

    lpDdeI->lpszShareName =
        (LPTSTR)((BYTE*)lpDdeI + sizeof( NDDESHAREINFO ));

    SendDlgItemMessage( hDlg, IDC_SHARENAME, WM_GETTEXT,
                MAX_NDDESHARENAME, (LPARAM)&dBuf );
    if (lstrlen(dBuf) == 0) {
        SendDlgItemMessage( hDlg, IDC_APPNAME, WM_GETTEXT,
                    MAX_NDDESHARENAME, (LPARAM)&dBuf );
        if (lstrlen(dBuf) == 0) {   /* no app name .. no share .. no share info */
            return(0);
        }
        lstrcpy( lpDdeI->lpszShareName, dBuf );
        lstrcat( lpDdeI->lpszShareName, TEXT("|") );

        SendDlgItemMessage( hDlg, IDC_TOPICNAME, WM_GETTEXT,
                    MAX_NDDESHARENAME, (LPARAM)&dBuf );
        lstrcat( lpDdeI->lpszShareName, dBuf );
        lSize += (lstrlen( lpDdeI->lpszShareName ) + 1) * sizeof(TCHAR);
    } else {
        lstrcpy( lpDdeI->lpszShareName, dBuf );
        lSize += (lstrlen( lpDdeI->lpszShareName ) + 1) * sizeof(TCHAR);
    }

    lpDdeI->lpszAppTopicList =
        (LPTSTR)(lpDdeI->lpszShareName +
                       lstrlen( lpDdeI->lpszShareName ) + 1);

    lChars = (long)SendDlgItemMessage( hDlg, IDC_APPNAME, WM_GETTEXT,
                   MAX_APPNAME, (LPARAM)&dBuf );

    if (lChars > 0) {
        lstrcpy( lpDdeI->lpszAppTopicList, dBuf );
        lstrcat( lpDdeI->lpszAppTopicList, TEXT("|") );
        lChars++;

        lChars += (long)SendDlgItemMessage( hDlg, IDC_TOPICNAME, WM_GETTEXT,
                    MAX_APPNAME, (LPARAM)&dBuf );
        lstrcat( lpDdeI->lpszAppTopicList, dBuf );
        lpDdeI->lShareType |= SHARE_TYPE_OLD;
    } else {
        lpDdeI->lShareType &= ~SHARE_TYPE_OLD;
    }
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;

    lTmp = (LONG)SendDlgItemMessage( hDlg, IDC_APPNAME_NEW, WM_GETTEXT,
                MAX_APPNAME, (LPARAM)&dBuf );
    if (lTmp > 0) {
        ptTmp = &lpDdeI->lpszAppTopicList[lChars];
        lChars +=lTmp;
        lstrcpy( ptTmp, dBuf );
        lstrcat( ptTmp, TEXT("|") );
        lChars++;

        lChars += (LONG)SendDlgItemMessage( hDlg, IDC_TOPICNAME_NEW, WM_GETTEXT,
                    MAX_APPNAME, (LPARAM)&dBuf );
        lstrcat( ptTmp, dBuf );
        lpDdeI->lShareType |= SHARE_TYPE_NEW;
    } else {
        lpDdeI->lShareType &= ~SHARE_TYPE_NEW;
    }
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;
    lTmp = (LONG)SendDlgItemMessage( hDlg, IDC_APPNAME_STATIC, WM_GETTEXT,
                MAX_APPNAME, (LPARAM)&dBuf );

    if (lTmp > 0) {
        ptTmp = &lpDdeI->lpszAppTopicList[lChars];
        lChars +=lTmp;
        lstrcpy( ptTmp, dBuf );
        lstrcat( ptTmp, TEXT("|") );
        lChars++;

        lChars += (LONG)SendDlgItemMessage( hDlg, IDC_TOPICNAME_STATIC, WM_GETTEXT,
                    MAX_APPNAME, (LPARAM)&dBuf );
        lstrcat( ptTmp, dBuf );
        lpDdeI->lShareType |= SHARE_TYPE_STATIC;
    } else {
        lpDdeI->lShareType &= ~SHARE_TYPE_STATIC;
    }
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;

    /*  add the final NULL */
    lpDdeI->lpszAppTopicList[lChars++] = (TCHAR) 0;
    lSize += sizeof(TCHAR) * lChars;

    /* Form the item list. */
    lpTmpList = (LPTSTR)LocalAlloc( LPTR, MAX_ITEM_LIST_BUF );
    lChars    = 0;
    n         = 0;
    hWndLB = GetDlgItem( hDlg, IDC_ITEM_LIST );
    if( !IsDlgButtonChecked( hDlg, IDC_ALL_ITEMS ) ) {
        bFirst = TRUE;
        lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );
        if( lRtn != LB_ERR ) {
            n = (int) lRtn;
            for( i=0; i<n; i++ ) {

                if ( SendMessage( hWndLB, LB_GETTEXTLEN, i, 0 ) < (sizeof(dBuf)/sizeof(TCHAR)) )
                    lRtn = (LONG)SendMessage( hWndLB, LB_GETTEXT, i, (LPARAM)&dBuf );
                else
                    lRtn = LB_ERR;
                if( !bFirst ) {
                    lChars++;
                } else {
                    bFirst = FALSE;
                }
                if( lRtn != LB_ERR ) {
                    lstrcpy( &lpTmpList[lChars], dBuf );
                    lChars += lstrlen( dBuf );
                }
            }
        }
    }

    lpTmpList[ lChars++ ] = (TCHAR) 0;
    lpTmpList[ lChars++ ] = (TCHAR) 0;
    lSize += sizeof(TCHAR) * lChars;
    lpDdeI->cNumItems = n;
    lpDdeI->lpszItemList = lpTmpList;

    if( IsDlgButtonChecked( hDlg, IDC_F_START_APP ) == 0 ) {
        lpDdeI->fStartAppFlag = 0;
    } else {
        lpDdeI->fStartAppFlag = 1;
    }

    if( IsDlgButtonChecked( hDlg, IDC_F_SERVICE ) == 0 ) {
        lpDdeI->fService = 0;
    } else {
        lpDdeI->fService = 1;
    }
    return(lSize);
}

/*
    Get Share SD from DSDM
*/
BOOL
GetShareSD(
    HWND    hDlg,
    LPTSTR  lpShareName )
{
    LONG    ret;
    DWORD   cbRequired;

    ret = NDdeGetShareSecurity(
        lpszServer,
        lpShareName,
        OWNER_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION,
        NULL,                       // dummy address  .. NULLs taboo
        0,                          // size of buffer for security descriptor
        &cbRequired);               // address of required size of buffer

    if ( ret != NDDE_BUF_TOO_SMALL ) {
        HandleError ( hDlg, IDS_ERROR1, ret );
        return FALSE;
    }

    if( pSD != NULL ) {
        LocalFree( pSD );
    }
    pSD = LocalAlloc(LMEM_ZEROINIT, cbRequired);
    if (pSD == NULL) {
        MessageBoxId ( hDlg,
            IDS_MBTEXT8, IDS_MBCAP1, MB_ICONEXCLAMATION | MB_OK );
        return(FALSE);
    }

    ret = NDdeGetShareSecurity(
        lpszServer,
        lpShareName,
        OWNER_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION,
        pSD,                        // address of security descriptor
        cbRequired,                 // size of buffer for security descriptor
        &cbRequired);               // address of required size of buffer

    if ( ret != NDDE_NO_ERROR ) {
        HandleError ( hDlg, IDS_ERROR2, ret );
        LocalFree(pSD);
        return FALSE;
    }
    return(TRUE);
}

/*
    Add/View/Modify DDE Share Dialog Proc
*/
BOOL
FAR PASCAL
AddShareDlg(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT        ret;
    int         n = 0;
    LONG        lSize;
    TCHAR       *dBuf;
    TCHAR       dBuf2[MAX_SHARE_INFO_BUF];
    HWND        hWndEB, hWndLB;
    LONG        lRtn, lIdx;
    BOOL        bNameInUse;
    int         i;
    BOOL        OK;
    TCHAR       szItemName[512];

static BOOL    fSDEditCalled       = FALSE;
static BOOL    fAddShareEntry      = FALSE;
static BOOL    fPropertiesCalled   = FALSE;


    switch (message) {
    case WM_INITDIALOG:            /* message: initialize dialog box */
        SendDlgItemMessage ( hDlg, IDC_SHARENAME, EM_LIMITTEXT,
                MAX_NDDESHARENAME, 0L );
        SendDlgItemMessage ( hDlg, IDC_APPNAME, EM_LIMITTEXT,
                MAX_APPNAME, 0L );
        SendDlgItemMessage ( hDlg, IDC_APPNAME_NEW, EM_LIMITTEXT,
                MAX_APPNAME, 0L );
        SendDlgItemMessage ( hDlg, IDC_APPNAME_STATIC, EM_LIMITTEXT,
                MAX_APPNAME, 0L );

        fSDEditCalled = FALSE;
        if (lParam) {
            fPropertiesCalled = TRUE;
            fAddShareEntry    = FALSE;
        } else {
            fPropertiesCalled = FALSE;
            fAddShareEntry    = TRUE;
        }

        lpDdeI = (PNDDESHAREINFO)&BigBuf;
        lpDdeI->lpszShareName =
            (LPTSTR)((BYTE*)lpDdeI + sizeof( NDDESHAREINFO ));
        lpDdeI->lpszShareName[0] = TEXT('\0');
        lpDdeI->lRevision        = 1L;
        lpDdeI->lShareType       = 1L;
        lpDdeI->lpszAppTopicList = NULL;
        lpDdeI->fSharedFlag      = 1;
        lpDdeI->fService         = 0;
        lpDdeI->fStartAppFlag    = 0;
        lpDdeI->qModifyId[0]     = 0;
        lpDdeI->qModifyId[1]     = 0;
        lpDdeI->nCmdShow         = SW_SHOWMINNOACTIVE;
        lpDdeI->cNumItems        = 0;
        lpDdeI->lpszItemList     = NULL;

        EnableWindow( GetDlgItem( hDlg, IDC_ADD ),       FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_DELETE ),    FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_ITEM_LIST ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_ITEMNAME ),  FALSE );
        CheckRadioButton( hDlg, IDC_ALL_ITEMS, IDC_RESTRICT_ITEMS,
                                IDC_ALL_ITEMS );

        if ( fPropertiesCalled ) {
            UINT ret;
            DWORD avail;
            WORD items;

            items = 0;
            ret = NDdeShareGetInfo (
                lpszServer,
                (LPTSTR)lParam,
                2,
                (LPBYTE)&BigBuf,
                2048 * sizeof(TCHAR),
                &avail,
                &items);

            if ( ret != NDDE_NO_ERROR ) {
                    HandleError ( hDlg, IDS_ERROR3, ret );
                    EndDialog ( hDlg, FALSE );
                    return TRUE;
            }

            OK = GetShareSD(hDlg, (LPTSTR)lParam);
            if (!OK) {
                EndDialog(hDlg, FALSE);
                return(TRUE);
            }

            SetDlgItemText ( hDlg, IDC_SHARENAME, lpDdeI->lpszShareName );
            EnableWindow( GetDlgItem( hDlg, IDC_SHARENAME ), FALSE );

            if (dBuf = LocalAlloc( LPTR, MAX_ITEM_LIST_BUF )) {

                if (lpDdeI->lShareType & SHARE_TYPE_OLD) {
                    GetAppName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_OLD );
                    SetDlgItemText ( hDlg, IDC_APPNAME, dBuf );
                    GetTopicName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_OLD );
                    SetDlgItemText ( hDlg, IDC_TOPICNAME, dBuf );
                }

                if (lpDdeI->lShareType & SHARE_TYPE_NEW) {
                    GetAppName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_NEW );
                    SetDlgItemText ( hDlg, IDC_APPNAME_NEW, dBuf );
                    GetTopicName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_NEW );
                    SetDlgItemText ( hDlg, IDC_TOPICNAME_NEW, dBuf );
                }

                if (lpDdeI->lShareType & SHARE_TYPE_STATIC) {
                    GetAppName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_STATIC );
                    SetDlgItemText ( hDlg, IDC_APPNAME_STATIC, dBuf );
                    GetTopicName( lpDdeI->lpszAppTopicList, dBuf, SHARE_TYPE_STATIC );
                    SetDlgItemText ( hDlg, IDC_TOPICNAME_STATIC, dBuf );
                }

                CheckDlgButton( hDlg, IDC_F_START_APP, lpDdeI->fStartAppFlag );
                CheckDlgButton( hDlg, IDC_F_SERVICE, lpDdeI->fService );

                {
                    int     n;
                    LPTSTR  lpszItem;
                    BOOL    bFirst = TRUE;

                    n = lpDdeI->cNumItems;
                    if( n > 0 ) {
                        EnableWindow( GetDlgItem( hDlg, IDC_ADD ),       TRUE );
                        EnableWindow( GetDlgItem( hDlg, IDC_DELETE ),    TRUE );
                        EnableWindow( GetDlgItem( hDlg, IDC_ITEM_LIST ), TRUE );
                            EnableWindow( GetDlgItem( hDlg, IDC_ITEMNAME ),  TRUE );
                        CheckRadioButton( hDlg, IDC_ALL_ITEMS, IDC_RESTRICT_ITEMS,
                                                IDC_RESTRICT_ITEMS );
                    }
                    lpszItem = lpDdeI->lpszItemList;
                    dBuf[0] = TEXT('\0');
                    hWndLB  = GetDlgItem( hDlg, IDC_ITEM_LIST );
                    while( n-- && (*lpszItem != TEXT('\0')) )  {
                        lRtn = (LONG)SendMessage( hWndLB, LB_ADDSTRING, 0,
                            (LPARAM)(LPTSTR)lpszItem);
                        if( bFirst )  {
                            bFirst = FALSE;
                        } else {
                            lstrcat( dBuf, TEXT(",") );
                        }
                        lstrcat( dBuf, lpszItem );
                        lpszItem += lstrlen(lpszItem) + 1;
                    }
                }
                LocalFree( dBuf );
            }
        }
        return (TRUE);

    case WM_COMMAND:
        hWndEB = GetDlgItem( hDlg, IDC_ITEMNAME );
        hWndLB = GetDlgItem( hDlg, IDC_ITEM_LIST );
        switch ( LOWORD(wParam) ) {
        case IDC_DACL:
            if (!fSDEditCalled && !fPropertiesCalled) {
                lSize = GetShareInfo(hDlg);
                if (lSize == 0) {
                    MessageBoxId ( hDlg, IDS_MBTEXT9, IDS_MBCAP1,
                        MB_ICONEXCLAMATION | MB_OK );
                    return(TRUE);
                }
                ret = NDdeShareAdd (
                    lpszServer,
                    2,
                    NULL,               /* create a default DDE Share SD */
                    (LPBYTE)lpDdeI,
                    lSize );
                HandleError ( hDlg, IDS_ERROR4, ret );
                if (ret == NDDE_NO_ERROR) {
                    fPropertiesCalled = TRUE;
                    OK = GetShareSD(hDlg, lpDdeI->lpszShareName);
                    if (!OK) {
                        return(TRUE);
                    }
                } else {
                    return(TRUE);
                }
            }
            PermissionsEdit( hDlg, lpDdeI->lpszShareName, (DWORD_PTR)lpDdeI );
            fSDEditCalled = TRUE;
            break;
#ifdef DO_AUDIT
        case IDC_SACL:
            AuditEdit( hDlg, lpDdeI->lpszShareName, (DWORD)lpDdeI );
            break;
#endif
        case IDC_ADD:
            GetDlgItemText( hDlg, IDC_ITEMNAME, dBuf2, sizeof(dBuf2)/sizeof(TCHAR) );
            if( dBuf2[0] != TEXT('\0') ) {
                /*  Check whether item name is already in the list. */
                lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );
                if( lRtn != LB_ERR ) {
                    n = (int) lRtn;
                    bNameInUse = FALSE;
                    for( i=0; !bNameInUse && (i<n); i++ ) {
                        lRtn = (LONG)SendMessage( hWndLB, LB_GETTEXT, i,
                            (LPARAM)(LPTSTR)szItemName );
                        if( lRtn != LB_ERR ) {
                            if( lstrcmpi( szItemName, dBuf2 ) == 0 ) {
                                bNameInUse = TRUE;
                            }

                        }
                    }
                }

                if( !bNameInUse ) {
                    /* Insert in sorted order. */
                    lRtn = (LONG)SendMessage(hWndLB, LB_ADDSTRING, 0,
                                        (LPARAM)(LPTSTR)dBuf2);
                    if( lRtn != LB_ERR ) {
                        lRtn = (LONG)SendMessage( hWndLB, LB_SETCURSEL,
                                                (WORD)lRtn, 0L );
                    }
                    if( lRtn != LB_ERR ) {
                        EnableWindow( GetDlgItem( hDlg, IDC_DELETE ),TRUE);
                    }
                }
            }
            SendMessage( hWndEB, EM_SETSEL, 0, (LPARAM) -1 );
            SetFocus( hWndEB );
            break;
        case IDC_DELETE:
            lIdx   = (LONG)SendMessage( hWndLB, LB_GETCURSEL, 0, 0L );
            if( lIdx != LB_ERR ) {
                lRtn = (LONG)SendMessage( hWndLB, LB_DELETESTRING, (WORD)lIdx, 0L);
                if( lRtn != LB_ERR ) {
                    lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );
                    if( lRtn != LB_ERR ) {
                        if( (int)lRtn > 0 ) {
                            EnableWindow(GetDlgItem(hDlg, IDC_DELETE ),TRUE);
                        } else {
                            EnableWindow(GetDlgItem(hDlg, IDC_DELETE ),FALSE);
                        }
                    }
                }
            }
            break;
        case IDC_ALL_ITEMS:
            SendMessage( hWndLB, LB_RESETCONTENT, 0, 0 );
            EnableWindow( GetDlgItem( hDlg, IDC_ADD ),    FALSE );
            EnableWindow( GetDlgItem( hDlg, IDC_DELETE ), FALSE );
            EnableWindow( hWndLB, FALSE );
            EnableWindow( hWndEB, FALSE );
            /* Zap item list. */
            break;
        case IDC_RESTRICT_ITEMS:
            /* Load Item listbox with current items. */
            EnableWindow( GetDlgItem( hDlg, IDC_ADD ),    TRUE );
            EnableWindow( GetDlgItem( hDlg, IDC_DELETE ), TRUE );
            EnableWindow( hWndLB, TRUE );
            EnableWindow( hWndEB, TRUE );

            lRtn = (LONG)SendMessage( hWndLB, LB_GETCOUNT, 0, 0L );

            if( lRtn != LB_ERR ) {

                if (dBuf = LocalAlloc( LPTR, MAX_ITEM_LIST_BUF ) ) {
                    n = (int) lRtn;
                    if( n == 0 ) {

                        {
                            int     n;
                            LPTSTR  lpszItem;
                            BOOL    bFirst = TRUE;

                            n = lpDdeI->cNumItems;
                            lpszItem = lpDdeI->lpszItemList;
                            dBuf[0] = TEXT('\0');
                            while( n-- && (*lpszItem != TEXT('\0')) )  {
                                lRtn = (LONG)SendMessage( hWndLB, LB_ADDSTRING, 0,
                                    (LPARAM)(LPTSTR)lpszItem);
                                if( bFirst )  {
                                    bFirst = FALSE;
                                } else {
                                    lstrcat( dBuf, TEXT(",") );
                                }
                                lstrcat( dBuf, lpszItem );
                                lpszItem += lstrlen(lpszItem) + 1;
                            }
                        }
                    }
                    LocalFree(dBuf);
                }
            }
            break;
        case IDOK:
            lSize = GetShareInfo(hDlg);
            if (lSize == 0) {
                MessageBoxId ( hDlg,
                    IDS_MBTEXT10,
                    IDS_MBCAP1,
                    MB_ICONEXCLAMATION | MB_OK );
                return(TRUE);
            }
            if ( !fPropertiesCalled ) {
                ret = NDdeShareAdd (
                        lpszServer,
                        2,
                        NULL,
                        (LPBYTE)lpDdeI,
                        lSize );
                HandleError ( hDlg, IDS_ERROR5, ret );
            } else {
                ret = NDdeShareSetInfo (
                        lpszServer,
                        lpDdeI->lpszShareName,
                        2,
                        (LPBYTE)lpDdeI,
                        lSize, 0 );
                HandleError ( hDlg, IDS_ERROR6, ret );

                ret = NDdeSetShareSecurity(
                    lpszServer,
                    lpDdeI->lpszShareName,
                    OWNER_SECURITY_INFORMATION |
                    DACL_SECURITY_INFORMATION,  // type of information to set
                    pSD                         // address of security descriptor
                    )                ;
                HandleError ( hDlg, IDS_ERROR7, ret );
            }

            if ( ret == NDDE_NO_ERROR ) {
                if( pSD ) {
                    LocalFree( pSD );
                    pSD = NULL;
                }
                EndDialog(hDlg, TRUE);
            }
            return (TRUE);

        case IDC_MYHELP:
            HtmlHelpA(hDlg, "DdeShare.chm", HELP_CONTEXT, HELP_DLG_PROPERTIES);
            break;

        case IDCANCEL:
            if ( fAddShareEntry && (pSD != NULL)) {
                NDdeShareDel(lpszServer, lpDdeI->lpszShareName, 0);
            }
            if( pSD ) {
                LocalFree( pSD );
                pSD = NULL;
            }
            EndDialog(hDlg, FALSE );
            return (TRUE);
        }
        break;
    }

    return FALSE;                     /* Didn't process a message    */
}

#define cPerms 15
#define MAX_PERMNAME_LENGTH 32
#define MAX_SPECIAL_LENGTH 64
static WCHAR awchPerms[cPerms * MAX_PERMNAME_LENGTH];

static SED_APPLICATION_ACCESS KeyPerms[cPerms] =
   {
   SED_DESC_TYPE_RESOURCE,0,                       0,
         awchPerms + MAX_PERMNAME_LENGTH * 0,
   SED_DESC_TYPE_RESOURCE, NDDE_GUI_READ,          0,
         awchPerms + MAX_PERMNAME_LENGTH * 1,
   SED_DESC_TYPE_RESOURCE, NDDE_GUI_READ_LINK,     0,
         awchPerms + MAX_PERMNAME_LENGTH * 2,
   SED_DESC_TYPE_RESOURCE, NDDE_GUI_CHANGE,        0,
         awchPerms + MAX_PERMNAME_LENGTH * 3,
   SED_DESC_TYPE_RESOURCE, NDDE_GUI_FULL_CONTROL,  0,
         awchPerms + MAX_PERMNAME_LENGTH * 4,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_READ, 0,
         awchPerms + MAX_PERMNAME_LENGTH * 5,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_WRITE,0,
         awchPerms + MAX_PERMNAME_LENGTH * 6,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_INITIATE_STATIC, 0,
         awchPerms + MAX_PERMNAME_LENGTH * 7,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_INITIATE_LINK,   0,
         awchPerms + MAX_PERMNAME_LENGTH * 8,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_REQUEST,         0,
         awchPerms + MAX_PERMNAME_LENGTH * 9,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_ADVISE,          0,
         awchPerms + MAX_PERMNAME_LENGTH * 10,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_POKE,            0,
         awchPerms + MAX_PERMNAME_LENGTH * 11,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_EXECUTE,         0,
         awchPerms + MAX_PERMNAME_LENGTH * 12,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_ADD_ITEMS,       0,
         awchPerms + MAX_PERMNAME_LENGTH * 13,
   SED_DESC_TYPE_RESOURCE_SPECIAL,NDDE_SHARE_LIST_ITEMS,      0,
         awchPerms + MAX_PERMNAME_LENGTH * 14,
   };


VOID wcscpyId(
LPWSTR szTo,
int ids)
{
    WCHAR szBuf[100];

    LoadStringW(hInst, ids, szBuf, sizeof(szBuf)/sizeof(WCHAR));
    wcscpy(szTo, szBuf);
}


BOOL WINAPI
PermissionsEdit(
    HWND    hWnd,
    LPTSTR  pShareName,
    DWORD_PTR dwSD )
{
    SEDDESCRETIONARYACLEDITOR   lpfnSDAE;
    SED_OBJECT_TYPE_DESCRIPTOR  ObjectTypeDescriptor;
    SED_APPLICATION_ACCESSES    ApplicationAccesses;
    PSECURITY_DESCRIPTOR        plSD = NULL;
    GENERIC_MAPPING             GmDdeShare;
    SED_HELP_INFO               HelpInfo;
    HANDLE                      hLibrary;
    DWORD                       Status;
    DWORD                       dwRtn;
    WCHAR                       wShareName[100];
    WCHAR                       awchSpecial[MAX_SPECIAL_LENGTH];
    unsigned                    i;

#ifdef UNICODE
    lstrcpy( wShareName, pShareName );
#else
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pShareName, -1,
                    wShareName, 100 );
#endif

    if( wShareName[0] == L'\0' ) {
        wcscpyId( wShareName, IDS_UNNAMED );
    }
    hLibrary = LoadLibrary( szAclEdit );
    if( hLibrary == (HANDLE) NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not load library (%ws) = %d", szAclEdit, GetLastError()));
#else
        DPRINTF(("Could not load library (%s) = %d", szAclEdit, GetLastError()));
#endif
        return FALSE;
    }

    lpfnSDAE = (SEDDESCRETIONARYACLEDITOR)
                    GetProcAddress( hLibrary, szSedDaclEdit );
    if( lpfnSDAE == NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not find function (%s) in library (%ws) = %d",
            szSedDaclEdit, szAclEdit, GetLastError() ));
#else
        DPRINTF(("Could not find function (%s) in library (%s) = %d",
            szSedDaclEdit, szAclEdit, GetLastError() ));
#endif
        FreeLibrary( hLibrary );
        return FALSE;
    }

    plSD = pSD;

    HelpInfo.pszHelpFileName = L"ddeshare.hlp";
    HelpInfo.aulHelpContext[HC_MAIN_DLG]                    = HELP_DLG_DDESHARENAMEPERMISSOINS;
    HelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0;
    HelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0;
    HelpInfo.aulHelpContext[HC_ADD_USER_DLG]                = 0;

    GmDdeShare.GenericRead    = 0;
    GmDdeShare.GenericWrite   = 0;
    GmDdeShare.GenericExecute = 0;
    GmDdeShare.GenericAll     = GENERIC_ALL;

    LoadString(hInst, IDS_SHAREOBJECT, ShareObjectName, MAX_SHAREOBJECT);

    ObjectTypeDescriptor.Revision                    = SED_REVISION1;
    ObjectTypeDescriptor.IsContainer                 = TRUE;
    ObjectTypeDescriptor.AllowNewObjectPerms         = FALSE;
    ObjectTypeDescriptor.MapSpecificPermsToGeneric   = FALSE;
    ObjectTypeDescriptor.GenericMapping              = &GmDdeShare;
    ObjectTypeDescriptor.GenericMappingNewObjects    = NULL;
    ObjectTypeDescriptor.ObjectTypeName              = ShareObjectName;
    ObjectTypeDescriptor.HelpInfo                    = &HelpInfo;
    ObjectTypeDescriptor.ApplyToSubContainerTitle    = NULL;
//  ObjectTypeDescriptor.ApplyToSubContainerHelpText = NULL;
    ObjectTypeDescriptor.ApplyToSubContainerConfirmation = NULL;
    ObjectTypeDescriptor.SpecialObjectAccessTitle    = awchSpecial;
    ObjectTypeDescriptor.SpecialNewObjectAccessTitle = awchSpecial;

    // Load permission names
    LoadString(hInst, IDS_SPECIAL_PERMNAME, awchSpecial, MAX_SPECIAL_LENGTH);
    for (i = 0;i < cPerms;i++)
       {
       LoadString(hInst, IDS_PERMNAME + i,
            awchPerms + MAX_PERMNAME_LENGTH * i, MAX_PERMNAME_LENGTH);
       }

    ApplicationAccesses.Count           = sizeof(KeyPerms)/sizeof(KeyPerms[0]);
    ApplicationAccesses.AccessGroup     = KeyPerms;
    ApplicationAccesses.DefaultPermName = awchPerms + MAX_PERMNAME_LENGTH;

    dwRtn = (*lpfnSDAE)( hWnd,
                         hInst,
                         NULL,
                         &ObjectTypeDescriptor,
                         &ApplicationAccesses,
                         wShareName,
                         SedCallback,
                         (ULONG_PTR)dwSD,
                         plSD,
                         FALSE,
                         FALSE,
                         &Status,
                         0L );

    if (dwRtn != NO_ERROR) {
        DPRINTF(("SED rtn ( %ld, %ld )", dwRtn, Status));
    }

    FreeLibrary( hLibrary );

    return TRUE;
}


DWORD
SedCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG_PTR dwSD,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn )
{
    DWORD                lSD;

    if( pSD ) {
        LocalFree( pSD );
        pSD = (PSECURITY_DESCRIPTOR) NULL;
    }
    lSD = GetSecurityDescriptorLength( SecDesc );
    if( pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, lSD ) ) {
        MakeSelfRelativeSD( SecDesc, pSD, &lSD );
    }
    if( IsValidSecurityDescriptor( pSD ) ) {
//      DPRINTF(("SedCallback = 0."));
        return 0;
    } else {
//      DPRINTF(("SedCallback = 1."));
        return 1;
    }
}


#ifdef DO_AUDIT

LPWSTR IdToWszAlloc(
int ids)
{
    int cch;
    WCHAR szBuf[50];
    LPWSTR wsz = NULL;

    cch = LoadStringW(hInst, ids, szBuf, sizeof(szBuf));
    if (cch) {
        wsz = (LPWSTR)LocalAlloc(LPTR, (cch + 1) * sizeof(WCHAR));
        if (wsz != NULL) {
            wcscpy(wsz, szBuf);
        }
    }
    return(wsz);
}


BOOL WINAPI
AuditEdit( HWND hWnd, LPTSTR pShareName, DWORD dwSD )
{
    SEDDESCRETIONARYACLEDITOR   lpfnSsAE;
    SED_OBJECT_TYPE_DESCRIPTOR  ObjectTypeDescriptor;
    SED_APPLICATION_ACCESSES    ApplicationAccesses;
    SED_APPLICATION_ACCESS      KeyPerms[5];
    PSECURITY_DESCRIPTOR        plSD = NULL;
    GENERIC_MAPPING             GmDdeShare;
    SED_HELP_INFO               HelpInfo;
    HANDLE      hLibrary;
    DWORD       Status;
    DWORD       dwRtn;
    WCHAR       wShareName[100];

#ifdef UNICODE
    lstrcpy( wShareName, pShareName );
#else
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pShareName, -1,
                    wShareName, 100 );
#endif

    hLibrary = LoadLibrary( szAclEdit );
    if( hLibrary == (HANDLE) NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not load library (%ws) = %d", szAclEdit, GetLastError()));
#else
        DPRINTF(("Could not load library (%s) = %d", szAclEdit, GetLastError()));
#endif
        return FALSE;
    }

    lpfnSsAE = (SEDDESCRETIONARYACLEDITOR)
                    GetProcAddress( hLibrary, szSedSaclEdit );
    if( lpfnSsAE == NULL ) {
#ifdef UNICODE
        DPRINTF(("Could not find function (%s) in library (%ws) = %d",
            szSedSaclEdit, szAclEdit, GetLastError() ));
#else
        DPRINTF(("Could not find function (%s) in library (%s) = %d",
            szSedSaclEdit, szAclEdit, GetLastError() ));
#endif
        FreeLibrary( hLibrary );
        return FALSE;
    }

    if( pSD == NULL ) {
        if( !InitializeShareSD( &pSD ) ) {
            FreeLibrary( hLibrary );
            return FALSE;
        }
    }
    plSD = pSD;

    HelpInfo.pszHelpFileName = L"ddeshare.hlp";
    HelpInfo.aulHelpContext[HC_MAIN_DLG]                    = 0;
    HelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0;
    HelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0;
    HelpInfo.aulHelpContext[HC_ADD_USER_DLG]                = 0;

    GmDdeShare.GenericRead    = NDDE_SHARE_GENERIC_READ;
    GmDdeShare.GenericWrite   = NDDE_SHARE_GENERIC_WRITE;
    GmDdeShare.GenericExecute = NDDE_SHARE_GENERIC_EXECUTE;
    GmDdeShare.GenericAll     = NDDE_SHARE_GENERIC_ALL;

    ObjectTypeDescriptor.Revision                    = SED_REVISION1;
    ObjectTypeDescriptor.IsContainer                 = TRUE;
    ObjectTypeDescriptor.AllowNewObjectPerms         = FALSE;
    ObjectTypeDescriptor.MapSpecificPermsToGeneric   = FALSE;
    ObjectTypeDescriptor.GenericMapping              = &GmDdeShare;
    ObjectTypeDescriptor.GenericMappingNewObjects    = NULL;
    ObjectTypeDescriptor.ObjectTypeName              = ShareObjectName;
    ObjectTypeDescriptor.HelpInfo                    = &HelpInfo;
    ObjectTypeDescriptor.ApplyToSubContainerTitle    = NULL;
    //ObjectTypeDescriptor.ApplyToSubContainerHelpText = NULL;
    ObjectTypeDescriptor.ApplyToSubContainerConfirmation = NULL;
    ObjectTypeDescriptor.SpecialObjectAccessTitle    = NULL;
    ObjectTypeDescriptor.SpecialNewObjectAccessTitle = NULL;

    KeyPerms[0].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[0].AccessMask1     = ACCESS_SYSTEM_SECURITY;
    KeyPerms[0].AccessMask1     = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[0].AccessMask2     = 0;
    KeyPerms[0].PermissionTitle = IdToWszAlloc(IDS_NOACCESS);

    KeyPerms[1].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[1].AccessMask1     = NDDE_GUI_READ | ACCESS_SYSTEM_SECURITY;
    KeyPerms[1].AccessMask1     = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[1].AccessMask2     = 0;
    KeyPerms[1].PermissionTitle = IdToWszAlloc(IDS_READ);

    KeyPerms[2].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[2].AccessMask1     = NDDE_GUI_READ_LINK | ACCESS_SYSTEM_SECURITY;
    KeyPerms[2].AccessMask1     = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[2].AccessMask2     = 0;
    KeyPerms[2].PermissionTitle = IdToWszAlloc(IDS_READANDLINK);

    KeyPerms[3].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[3].AccessMask1     = NDDE_GUI_CHANGE | ACCESS_SYSTEM_SECURITY;
    KeyPerms[3].AccessMask1     = READ_CONTROL | WRITE_DAC | DELETE | ACCESS_SYSTEM_SECURITY;
    KeyPerms[3].AccessMask2     = 0;
    KeyPerms[3].PermissionTitle = IdToWszAlloc(IDS_CHANGE);

    KeyPerms[4].Type            = SED_DESC_TYPE_AUDIT;
//    KeyPerms[4].AccessMask1     = NDDE_GUI_FULL_CONTROL | ACCESS_SYSTEM_SECURITY;
    KeyPerms[4].AccessMask1     = READ_CONTROL | WRITE_DAC | DELETE | ACCESS_SYSTEM_SECURITY;
    KeyPerms[4].AccessMask2     = 0;
    KeyPerms[4].PermissionTitle = IdToWszAlloc(IDS_FULLCTRL);

    ApplicationAccesses.Count           = 5;
    ApplicationAccesses.AccessGroup     = KeyPerms;
    ApplicationAccesses.DefaultPermName = KeyPerms[1].PermissionTitle;

    dwRtn = (*lpfnSsAE)( hWnd,
                         hInst,
                         NULL,
                         &ObjectTypeDescriptor,
                         &ApplicationAccesses,
                         wShareName,
                         SedAuditCallback,
                         (ULONG)dwSD,
                         plSD,
                         FALSE,
                         FALSE,
                         &Status );

    LocalFree(KeyPerms[0].PermissionTitle);
    LocalFree(KeyPerms[1].PermissionTitle);
    LocalFree(KeyPerms[2].PermissionTitle);
    LocalFree(KeyPerms[3].PermissionTitle);
    LocalFree(KeyPerms[4].PermissionTitle);

    DPRINTF(("SEDSacl rtn ( %ld, %ld )", dwRtn, Status));

    FreeLibrary( hLibrary );

    return TRUE;
}


DWORD
SedAuditCallback(
        HWND hWnd,
        HANDLE hInstance,
        ULONG  dwSD,
        PSECURITY_DESCRIPTOR SecDesc,
        PSECURITY_DESCRIPTOR SecDescNewObjects,
        BOOLEAN ApplyToSubContainers,
        BOOLEAN ApplyToSubObjects,
        LPDWORD StatusReturn )
{
    DWORD                lSD;

    if( pSD ) {
        LocalFree( pSD );
        pSD = (PSECURITY_DESCRIPTOR) NULL;
    }
    lSD = GetSecurityDescriptorLength( SecDesc );
    if( pSD = LocalAlloc( 0, lSD ) ) {
        MakeSelfRelativeSD( SecDesc, pSD, &lSD );
    }
    if( IsValidSecurityDescriptor( pSD ) ) {
        DPRINTF(("SedAuditCallback = 0."));
        return 0;
    } else {
        DPRINTF(("SedAuditCallback = 1."));
        return 1;
    }
}
#endif // DO_AUDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddeexts\exts.h ===
DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   dtd
        ,"dtd                           - Dump NetDDE THREADDATA structs\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   dpktz
        ,"dpktz <lppktz>                - Dump PKTZ structure\n"
        ,""
        ,""
        ,STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddeexts\gendef.c ===
LIBRARY NDDEEXTS

;
; This file generates nddeexts.def.  This allows one file (exts.h) to
; be used to generate extension exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to userexts.c
;
EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ddeshare\rc.h ===
#ifndef H__rc
#define H__rc

#define DSACCEL                 80

#define CI_OK                   1
#define CI_CANCEL               2

#define CI_VERSION              100

#define MENU_ADD                200
#define MENU_DELETE             201
#define MENU_LIST               202

#define IDM_DDESHARES           210
#define IDM_TRUSTSHARES         211
#define IDM_SERVERNAME          212
#define IDM_EXIT                213

#define IDC_SERVER_NAME         221

#define IDM_DEBUG_DDE           250
#define IDM_LOG_INFO            251
#define IDM_LOG_ERRORS          252
#define IDM_LOG_DDE_PKTS        253
#define IDM_DEBUG_NETDDE        254

#define HELP_DLG_DDESHARES               101
#define HELP_DLG_DDETRUSTEDSHARES        111
#define HELP_DLG_PROPERTIES              121
#define HELP_DLG_TRUSTEDSHAREPROPERTIES  131
#define HELP_DLG_DDESHARENAMEPERMISSOINS 141
#define HELP_DLG_ADDUSERSANDGROUPS       151
#define HELP_DLG_FINDACCOUNT             161
#define HELP_DLG_LOCALGROUPMEMBERSHIP    171
#define HELP_DLG_GLOBALGROUPMEMBERSHIP   181
#define HELP_DLG_SELECTCOMPUTER          191

#define HELP_MENU_DDESHARES             300
#define HELP_MENU_TRUSTEDSHARES         310
#define HELP_MENU_SELECTCOMPUTER        320
#define HELP_MENU_EXIT                  330

#define MENU_HELP_ABOUT             300

#define IDICON_NetDDE           1
#define IDICON_DdeShare         2
#define IDICON_TrustShare       3
#define IDMENU_DdeShareMenu     4

#define DID_DDESHARE_DLG        5
#define DID_TRUSTEDSHARE_DLG    6
#define DID_DDESHARES_DLG       7
#define DID_TRUSTSHARES_DLG     8
#define DID_SERVERNAME_DLG      9

#define IDS_PERMNAME            0x400
#define IDS_SPECIAL_PERMNAME    0x3FF
#define IDS_ERROR1              1
#define IDS_ERROR2              2
#define IDS_ERROR3              3
#define IDS_ERROR4              4
#define IDS_ERROR5              5
#define IDS_ERROR6              6
#define IDS_ERROR7              7
#define IDS_ERROR8              8
#define IDS_ERROR9              9
#define IDS_ERROR10             10
#define IDS_ERROR11             11
#define IDS_ERROR12             12
#define IDS_ERROR13             13
#define IDS_ERROR14             14
#define IDS_ERROR15             15
#define IDS_ERROR16             16
#define IDS_ERROR17             17
#define IDS_ERROR18             18
#define IDS_ERROR19             19
#define IDS_ERROR20             20
#define IDS_APPNAME             21
#define IDS_ON                  22
#define IDS_MBTEXT1             23
#define IDS_MBCAP1              24
#define IDS_MBTEXT2             25
#define IDS_MBTEXT3             26
#define IDS_MBTEXT4             27
#define IDS_MBCAP4              28
#define IDS_MBTEXT5             29
#define IDS_MENU1               30
#define IDS_MENU2               31
#define IDS_MENU3               32
#define IDS_MENU4               33
#define IDS_MENU5               34
#define IDS_MBTEXT6             35
#define IDS_MBCAP6              36
#define IDS_NOSHARES            37
#define IDS_MBCAP7              38
#define IDS_MBTEXT8             39
#define IDS_MBTEXT9             40
#define IDS_MBTEXT10            41
#define IDS_UNNAMED             42
#define IDS_NOACCESS            43
#define IDS_READ                44
#define IDS_READANDLINK         45
#define IDS_CHANGE              46
#define IDS_FULLCTRL            47
#define IDS_MBCAP11             48
#define IDS_MBTEXT11            49
#define IDS_SHAREOBJECT         50

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddeagnt\nddeagnt.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAGNT.C;3  9-Feb-93,20:14:14  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    NDDEAGNT.C

    NetDDE Agent for Access to Apps in User Space

    Revisions:
    12-92   IgorM.  Wonderware initial create.
     4-93   IgorM.  Wonderware modify to use Trust Share API. Add Init verify.
    10-93   SanfordsS   Auto starting and linkup to Services added.

   $History: End */


#include <windows.h>
#include <dde.h>
#include <stdio.h>
#include <string.h>
#include "netbasic.h"
#include "ddepkts.h"
#include "netddesh.h"
#include "debug.h"
#include "nddeagnt.h"
#include "nddeagnp.h"
#include "nddeapi.h"
#include "shrtrust.h"
#include "proflspt.h"
#include "immp.h"

#define WAIT_FOR_NETDDE_TIMEOUT (10 * 1000) // 10 seconds allowed to start NetDDE

TCHAR   gszAppName[]            = SZ_NDDEAGNT_SERVICE;
TCHAR   szTitle[]               = SZ_NDDEAGNT_TITLE;
TCHAR   tmpBuf[128];
TCHAR   szComputerName[ 100 ];
DWORD   cbName                  = sizeof(szComputerName);
TCHAR   szServerName[ 100 ]     = "[none]";
LPTSTR  lpszServer              = szServerName;
TCHAR   szNetDDE[]              = NETDDE_TITLE;
TCHAR   szNetDDEDSDM[]          = TEXT("NetDDEDSDM");
TCHAR   szClipSrv[]             = TEXT("ClipSrv");

TCHAR   szStartServices[]       = SZ_NDDEAGNT_TOPIC;
TCHAR   szAgentExecRtn[]        = "NetddeAgentExecRtn";
UINT    wMsgNddeAgntExecRtn;
TCHAR   szAgentWakeUp[]         = "NetddeAgentWakeUp";
UINT    wMsgNddeAgntWakeUp;
TCHAR   szAgentAlive[]          = "NetddeAgentAlive";
UINT    wMsgNddeAgntAlive;
TCHAR   szAgentDying[]          = "NetddeAgentDying";
UINT    wMsgNddeAgntDying;

HWND    hWndNddeAgnt;
HANDLE  hSemNddeAgnt            = NULL;
HANDLE  hInst;
BOOL    fStartFailed            = 0;
SC_HANDLE hSvcNetDDE            = NULL;
SC_HANDLE hSvcNetDDEDSDM        = NULL;
SC_HANDLE hSvcClipSrv           = NULL;

#if DBG
BOOL    bDebugInfo              = FALSE;
BOOL    bDebugErrors            = FALSE;
#endif

BOOL IsServiceActive(SC_HANDLE *phSvc, LPTSTR pszSvcName, BOOL fCleanup);
BOOL CompareNddeModifyId(LPTSTR lpszShareName, LPDWORD lpdwIdNdde,
        LPDWORD lpdwOptions);


LPSTR MyLoadString(
int id)
{
    /*
     * Assumes ids start at 1 and are consecutive.
     */
    static LPSTR aStrings[STR_LAST - 1] = { NULL };
    CHAR szBuf[200];
    int length;

    if (aStrings[id - 1] == NULL) {
        length = LoadString(hInst, id, szBuf, sizeof(szBuf));
        if (length == 0) {
            return("");
        }
        aStrings[id - 1] = LocalAlloc(LPTR, length + 1);
        if (aStrings[id - 1] == NULL) {
            return("");
        }
        strcpy(aStrings[id - 1], szBuf);
    }
    return(aStrings[id - 1]);
}


/****************************************************************************

    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPTSTR, INT)

    PURPOSE: calls initialization function, processes message loop

****************************************************************************/

int WINAPI
WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPTSTR     lpCmdLine,
    INT        nCmdShow)
{
    HWND hWnd;
    MSG msg;

#if DBG
    DebugInit( "NddeAgnt" );
    bDebugInfo = MyGetPrivateProfileInt("NddeAgnt",
        "DebugInfo", FALSE, "netdde.ini");
    bDebugErrors = MyGetPrivateProfileInt("NddeAgnt",
        "DebugErrors", FALSE, "netdde.ini");
#endif
    hSemNddeAgnt = CreateSemaphore(NULL, 1, 1, "NDDEAgent");
    if (hSemNddeAgnt != NULL && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(hSemNddeAgnt);
        MessageBox( NULL, MyLoadString(STR_RUNNING), gszAppName,
                    MB_TASKMODAL | MB_OK | MB_ICONEXCLAMATION );
        return (FALSE);
    }

    if (!NDDEAgntInit(hInstance)) {
        MessageBox( NULL, MyLoadString(STR_FAILED), gszAppName,
                    MB_TASKMODAL | MB_OK | MB_ICONEXCLAMATION );
        return (FALSE);
    }
    hInst = hInstance;

    hWnd = CreateWindowEx(WS_EX_TOPMOST, gszAppName,
        szTitle,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL);

    if (!hWnd)
        return (FALSE);

    hWndNddeAgnt = hWnd;
#ifdef HASUI
    ShowWindow(hWnd, SW_MINIMIZE);
    UpdateWindow(hWnd);
#endif

    /* set up lpszServer for NDDEAPI calls */
    GetComputerName( szComputerName, &cbName );
    strcpy( lpszServer, "\\\\" );
    strcat( lpszServer, szComputerName );

    /*
     * clean up any trusted shares that have been modified or deleted
     * since we last ran for this user
     */
    if (IsServiceActive(&hSvcNetDDE, szNetDDE, FALSE)) {
        CleanupTrustedShares();
    }

    while (GetMessage(&msg, 0, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return (msg.wParam);
}


#define IMMMODULENAME L"IMM32.DLL"
#define PATHDLM     L'\\'
#define IMMMODULENAMELEN    ((sizeof PATHDLM + sizeof IMMMODULENAME) / sizeof(WCHAR))

VOID GetImmFileName(PWSTR wszImmFile)
{
    UINT i = GetSystemDirectoryW(wszImmFile, MAX_PATH);
    if (i > 0 && i < MAX_PATH - IMMMODULENAMELEN) {
        wszImmFile += i;
        if (wszImmFile[-1] != PATHDLM) {
            *wszImmFile++ = PATHDLM;
        }
    }
    wcscpy(wszImmFile, IMMMODULENAME);
}

/****************************************************************************

    FUNCTION: NDDEAgntInit(HANDLE)

    PURPOSE: Initializes window data and registers window class

****************************************************************************/

INT NDDEAgntInit(HANDLE hInstance)
{
    HANDLE hMemory;
    PWNDCLASS pWndClass;
    BOOL bSuccess;

    wMsgNddeAgntExecRtn = RegisterWindowMessage( szAgentExecRtn );
    wMsgNddeAgntWakeUp = RegisterWindowMessage( szAgentWakeUp );
    wMsgNddeAgntAlive = RegisterWindowMessage( szAgentAlive );
    wMsgNddeAgntDying = RegisterWindowMessage( szAgentDying );

#ifndef LATER
#define IMM_DISABLE_IME_NAME    L"ImmDisableIme"
#else
#define IMM_DISABLE_IME_NAME    L"ImmDisableIME"
#endif
    {
        WCHAR wszImmFile[MAX_PATH];
        BOOL (WINAPI* fpImmDisableIme)(DWORD);
        HMODULE hImm;

        GetImmFileName(wszImmFile);
        hImm = GetModuleHandleW(wszImmFile);
        if (hImm) {
            fpImmDisableIme = (BOOL (WINAPI*)(DWORD))GetProcAddress(hImm, "ImmDisableIme");
            if (fpImmDisableIme) {
#ifndef LATER
                fpImmDisableIme(0);
#else
                fpImmDisableIme(-1);
#endif
            }
        }
    }

    hMemory = LocalAlloc(LPTR, sizeof(WNDCLASS));
    if(!hMemory){
        MessageBox(NULL, MyLoadString(STR_LOWMEM), NULL, MB_OK | MB_ICONHAND);
        return(FALSE);
    }

    pWndClass = (PWNDCLASS) LocalLock(hMemory);
    pWndClass->hCursor = NULL;
    pWndClass->hIcon = NULL;
    pWndClass->lpszMenuName = NULL;
    pWndClass->lpszClassName = (LPTSTR)SZ_NDDEAGNT_CLASS;
    pWndClass->hbrBackground = GetStockObject(WHITE_BRUSH);
    pWndClass->hInstance = hInstance;
    pWndClass->style = 0;
    pWndClass->lpfnWndProc = NDDEAgntWndProc;

    bSuccess = RegisterClass((LPWNDCLASS) pWndClass);

    LocalUnlock(hMemory);
    LocalFree(hMemory);
    return (bSuccess);
}




/*
 * Returns TRUE if anything went wrong or NetDDE service is active.
 */
BOOL IsServiceActive(
SC_HANDLE *phSvc,
LPTSTR pszSvcName,
BOOL fCleanup)
{
    DWORD cServices;
    DWORD iEnum                 = 0;
    SC_HANDLE hSvcMgr;
    ENUM_SERVICE_STATUS *pess  = NULL;
    DWORD cbData;
    LONG status;

    if (fCleanup) {
        if (*phSvc != NULL) {
            CloseServiceHandle(*phSvc);
            *phSvc = NULL;
        }
        return(TRUE);   // fSuccess, NOT fActive
    }
    if (*phSvc != NULL) {
        SERVICE_STATUS SvcStatus;
        /*
         * FAST method:
         */
        if (QueryServiceStatus(*phSvc, &SvcStatus)) {
            return(SvcStatus.dwCurrentState == SERVICE_RUNNING);
        } else {
            return(FALSE);
        }
    }
    hSvcMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (hSvcMgr) {
        cbData = 0;
        if (EnumServicesStatus(hSvcMgr, SERVICE_WIN32, SERVICE_ACTIVE,
                NULL, 0, &cbData, &cServices, &iEnum)) {
            /*
             * Success with cbData==0 implies no services are running
             * so return FALSE.
             */
            return(FALSE);
        }
        status = GetLastError();
        if (status != ERROR_MORE_DATA) {
            /*
             * Not what we expected.
             */
            return(TRUE);
        }
        pess = LocalAlloc(LPTR, cbData);
        if (pess == NULL) {
            CloseServiceHandle(hSvcMgr);
            return(TRUE);
        }
        iEnum = 0;
        if (!EnumServicesStatus(hSvcMgr, SERVICE_WIN32, SERVICE_ACTIVE,
                pess, cbData, &cbData, &cServices, &iEnum)) {
#if DBG
            GetLastError();
#endif
            LocalFree(pess);
            CloseServiceHandle(hSvcMgr);
            return(TRUE);
        }
        if (cServices > 0) {
            while (cServices--) {
                if (!_stricmp(pess[cServices].lpServiceName, pszSvcName)) {
                    /*
                     * Cache Service handle
                     */
                    *phSvc = OpenService(hSvcMgr, pszSvcName,
                            SERVICE_QUERY_STATUS);
                    LocalFree(pess);
                    CloseServiceHandle(hSvcMgr);
                    return(TRUE);
                }
            }
        }
        LocalFree(pess);
        CloseServiceHandle(hSvcMgr);
    }
    return(FALSE);
}


BOOL StartNetDDEServices(
BOOL fNotifyUser)
{
    SC_HANDLE hSvcMgr, hSvc;
    BOOL bOk = TRUE;
    HWND hwndDlg = NULL;

    if (fNotifyUser) {
        hwndDlg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_STARTING), NULL, NULL);
        if (hwndDlg != NULL) {
            RECT rc;
            MSG msg;

            GetWindowRect(hwndDlg, &rc);
            SetWindowPos(hwndDlg, HWND_TOPMOST,
                    (GetSystemMetrics(SM_CXFULLSCREEN) - (rc.right - rc.left)) / 2,
                    (GetSystemMetrics(SM_CYFULLSCREEN) - (rc.bottom - rc.top)) / 2,
                    0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
            // SetForegroundWindow(hwndDlg);

            /*
             * Process dialog messages so it can paint, etc.
             */
            while (PeekMessage(&msg, hwndDlg, 0, 0, PM_REMOVE)) {
                DispatchMessage(&msg);
            }
        }
    }
    hSvcMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (hSvcMgr) {
        /*
         * Because ClipSrv is dependent on NetDDE and NetDDE is dependent
         * on nddeDSDM, this call starts all three services.  In addition,
         * the service controller will not return from this call until
         * all dependent services are fully initialized so we are guarenteed
         * that NetDDE and nddeDSDM are ready to go by the time this returns.
         */
        hSvc = OpenService(hSvcMgr, "ClipSrv", SERVICE_START);
        if (hSvc) {
            StartService(hSvc, 0, NULL);
            CloseServiceHandle(hSvc);
        } else {
            bOk = FALSE;
        }
        CloseServiceHandle(hSvcMgr);
    } else {
        bOk = FALSE;
    }
    if (hwndDlg != NULL) {
        DestroyWindow(hwndDlg);
    }
    return(bOk);
}


HWND ConnectToNetDDEService(
    DWORD dwTimeout)
{
    HANDLE hPipe;
    NETDDE_PIPE_MESSAGE nameinfo;
    DWORD cbRead;
    DWORD tcStart;
    DWORD dwMode;
    MSG msg;

    /*
     * locate the NetDDE pipe .. give the system some time
     * to let the NetDDE service create it.
     */
    hPipe = CreateFileW(NETDDE_PIPE,
            GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT |
            SECURITY_IMPERSONATION, NULL);
    if (hPipe == INVALID_HANDLE_VALUE && dwTimeout == 0) {
        return NULL;
    }

    tcStart = GetTickCount();
    while (hPipe == INVALID_HANDLE_VALUE &&
            ((tcStart + dwTimeout) >
            GetTickCount())) {

        /*
         * Wait this way so NetDDE can send us our wakeup call.
         */
        MsgWaitForMultipleObjects(0, NULL, TRUE, 1000, QS_ALLINPUT);
        hPipe = CreateFileW(NETDDE_PIPE,
                GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT |
                SECURITY_IMPERSONATION, NULL);
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);
    }
    if (hPipe == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    /*
     * Package up the windowstation and desktop names and
     * send them to NetDDE.
     */
    wcscpy(nameinfo.awchNames, L"WinSta0");
    nameinfo.dwOffsetDesktop = wcslen(nameinfo.awchNames) + 1;
    wcscpy(&nameinfo.awchNames[nameinfo.dwOffsetDesktop],
            L"default");
    dwMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;
    SetNamedPipeHandleState(hPipe, &dwMode, NULL, NULL);
    if (!TransactNamedPipe(hPipe, &nameinfo, sizeof(nameinfo),
            &hWndNddeAgnt, sizeof(HWND), &cbRead, NULL)) {
        hWndNddeAgnt = NULL;
    }
    CloseHandle(hPipe);

    return hWndNddeAgnt;
}


LONG
APIENTRY
NDDEAgntWndProc(
    HWND hWnd,         // window handle
    UINT message,      // type of message
    UINT uParam,       // additional information
    LONG lParam )      // additional information
{
    TCHAR szAppName[256];
    static BOOL fInitializing = FALSE;

    switch (message) {
    case WM_CREATE:
        DIPRINTF(("WM_CREATE: %0X", (UINT) hWnd));
        if (IsServiceActive(&hSvcNetDDE, szNetDDE, FALSE) &&
                (FindWindow(NETDDE_CLASS, NETDDE_TITLE) == NULL)) {

            /*
             * Connect to NetDDE and get the main window handle
             */
            ConnectToNetDDEService(0);
        }
        SendNotifyMessage( (HWND)-1, wMsgNddeAgntAlive, (UINT) hWnd, 0);
        break;

    case WM_DDE_INITIATE:
        TRACEINIT((szT, "NDDEAgntWndProc: WM_DDE_INITIATE"));
        if (GlobalGetAtomName(LOWORD(lParam), szAppName, sizeof(szAppName))) {
            HWND hwndNetDDEMain = NULL;

            if (_stricmp(szAppName, gszAppName) != 0) {
                if (strstr(szAppName, "NDDE$") == NULL &&
                    strstr(szAppName, "\\\\") == NULL) {
                    /*
                     * Not for NetDDE at all.  let it go.
                     */
                    TRACEINIT((szT, "NDDEAgntWndProc: WM_DDE_INITIATE - not for NetDDE"));
                    return(0);
                }
            } else {
                /*
                 * Its addressing us as a DDE service!
                 *
                 * We use the WM_DDE_INITIATE as a fast execute to this app.
                 * If the atoms are right, we will start the NetDDE services
                 * if needed.  This lets other components do this with
                 * one simple SendMessage() yet does not require new APIs.
                 */
                if (!GlobalGetAtomName(HIWORD(lParam), szAppName, sizeof(szAppName))) {
                    TRACEINIT((szT, "NDDEAgntWndProc: WM_DDE_INITIATE - Bad App Atom"));
                    return(0);
                }
                if (_stricmp(szAppName, szStartServices) != 0) {
                    TRACEINIT((szT, "NDDEAgntWndProc: WM_DDE_INITIATE - Not request to start services"));
                    return(0);
                }
            }

            /*
             * If we're already initializing, skip it.
             */
            if (fInitializing) {
                TRACEINIT((szT, "NDDEAgntWndProc: fInitializing==TRUE, blow it off"));
                return 0;
            }
            fInitializing = TRUE;
            if (IsServiceActive(&hSvcNetDDE, szNetDDE, FALSE) &&
                    IsServiceActive(&hSvcNetDDEDSDM, szNetDDEDSDM, FALSE) &&
                    IsServiceActive(&hSvcClipSrv, szClipSrv, FALSE)) {

                /*
                 * If there is no main window, connect to NetDDE
                 * and get the main window handle
                 */
                if (FindWindow(NETDDE_CLASS, NETDDE_TITLE) == NULL)
                    ConnectToNetDDEService(0);
            } else {

                /*
                 * Start the NetDDE service(s)
                 */
                if (fStartFailed == 0) {
                    if (!StartNetDDEServices(TRUE)) {
                        fStartFailed++;
                        MessageBox(NULL, MyLoadString(STR_CANTSTART), szTitle,
                                MB_OK | MB_SYSTEMMODAL);
                    }

                    /*
                     * Connect to NetDDE and get the main window handle
                     */
                    if (ConnectToNetDDEService(WAIT_FOR_NETDDE_TIMEOUT) != NULL) {

                        /*
                         * BUG:  If we pass on this message to netdde, things will
                         * always work the first time... but they may also be
                         * double connected because the app may happen to send
                         * another initiate message directly to the netdde
                         * service - depending on how it does its broadcast.
                         * There is no way to solve this for all cases so we
                         * don't pass it on.  Apps that want to work first time,
                         * everytime must use DDEML (its method of enumeration
                         * works here) or they must start the services themselves.
                         */
                        //return(SendMessage(hwndNetDDEMain, message, uParam, lParam));
                    }
                }
            }
            fInitializing = FALSE;
            return(0);
        }
        break;

    case WM_COPYDATA:
        DIPRINTF(("WM_COPYDATA: %0X %0X %0lX", (UINT) hWnd, uParam, lParam));
        HandleNetddeCopyData( hWnd, uParam, (PCOPYDATASTRUCT) lParam );
        return( TRUE ); // processed the msg */
        break;

    case WM_ENDSESSION:
        if( uParam == 0 )  {
            break;
        }
        /* intentional fall-through */
    case WM_DESTROY:  // message: window being destroyed
        DIPRINTF(("WM_DESTROY: %0X", (UINT) hWnd));
        SendNotifyMessage( (HWND)-1, wMsgNddeAgntDying,
                    (UINT) hWndNddeAgnt, 0);
        PostQuitMessage(0);
        IsServiceActive(&hSvcNetDDE, szNetDDE, TRUE);           // cleanup.
        IsServiceActive(&hSvcNetDDEDSDM, szNetDDEDSDM, TRUE);   // cleanup.
        IsServiceActive(&hSvcClipSrv, szClipSrv, TRUE);      // cleanup.

        break;

    default:          // Passes it on if unproccessed
        if (message == wMsgNddeAgntWakeUp) {
            TRACEINIT((szT, "WakeUp %x received.  Sending %x to %x.",
                    wMsgNddeAgntWakeUp,
                    wMsgNddeAgntAlive,
                    uParam));
            SendMessage( (HWND) uParam, wMsgNddeAgntAlive, (UINT) hWnd, 0);
            return( TRUE ); // processed the msg
        }
        return (DefWindowProc(hWnd, message, uParam, lParam));
    }
    return (0);
}



/*
 *  HandleNetddeCopyData()
 *
 *      This handles the WM_COPYDATA message from NetDDE to start an
 *      application in the user's context
 */
BOOL
HandleNetddeCopyData(
    HWND            hWndNddeAgnt,
    UINT            wParam,
    PCOPYDATASTRUCT pCopyDataStruct )
{
    PNDDEAGTCMD     pNddeAgtCmd;
    LPTSTR          lpszShareName;
    LPTSTR          lpszCmdLine;
    UINT            uAgntExecRtn = 0;
    UINT            uAgntInitRtn = 0;
    UINT            fuCmdShow = 0;
    DWORD           dwOptions;
    COPYDATASTRUCT  cds;
    BOOL            RetStatus = FALSE;

    /* sanity checks on the structure coming in */
    if( pCopyDataStruct->cbData < sizeof(NDDEAGTCMD) )  {
        return( FALSE );
    }
    pNddeAgtCmd = (PNDDEAGTCMD)(pCopyDataStruct->lpData);
    if( pNddeAgtCmd->dwMagic != NDDEAGT_CMD_MAGIC )  {
        return( FALSE );
    }
    if( pNddeAgtCmd->dwRev != 1 )  {
        return( FALSE );
    }

    /* passed the sanity checks ... lets's do the command */
    switch( pNddeAgtCmd->dwCmd )  {
    case NDDEAGT_CMD_WINEXEC:
        /* get the sharename and cmdline out of szData */
        lpszShareName = pNddeAgtCmd->szData;
        lpszCmdLine = lpszShareName + lstrlen(lpszShareName) + 1;

        DIPRINTF(("WinExec( %s:%s )", lpszShareName, lpszCmdLine));
        /*
         * make sure that no one changed the share since the user told
         * us he trusted it
         */
        if( CompareNddeModifyId( lpszShareName,
                &pNddeAgtCmd->qwModifyId[0], &dwOptions ) )  {
            /*
             * no one has modified the share ... start the app in the
             * user's context
             */
            if (dwOptions & NDDE_TRUST_SHARE_START) {
                fuCmdShow = pNddeAgtCmd->fuCmdShow;
                if( (dwOptions & NDDE_TRUST_CMD_SHOW) )  {
                    fuCmdShow = dwOptions & NDDE_CMD_SHOW_MASK;
                }
                uAgntExecRtn = WinExec( lpszCmdLine, fuCmdShow );
#if DBG
                if (uAgntExecRtn > 31) {
                    DIPRINTF(("WinExec successful, returns: %d", uAgntExecRtn));
                } else {
                    if (bDebugErrors) {
                        DPRINTF(("WinExec(%s:%d) failed, returns: %d",
                            lpszCmdLine, fuCmdShow, uAgntExecRtn));
                    }
                }
#endif
            } else {
#if DBG
                if (bDebugErrors) {
                    DPRINTF(("WinExec() Start app not allowed"));
                }
#endif
                uAgntExecRtn = NDDEAGT_START_NO;
            }
        } else {
#if DBG
            if (bDebugErrors) {
                DPRINTF(("WinExec() CompareNddeModifyId failed"));
            }
#endif
            uAgntExecRtn = NDDEAGT_START_NO;
        }
        RetStatus = TRUE;
        break;

    case NDDEAGT_CMD_WININIT:
        /* get the sharename and cmdline out of szData */
        lpszShareName = pNddeAgtCmd->szData;

        DIPRINTF(("WinInit( %s )", lpszShareName));
        /* make sure that no one changed the share since the user told
            us he trusted it */
        if( CompareNddeModifyId( lpszShareName,
                &pNddeAgtCmd->qwModifyId[0], &dwOptions ) )  {

            /* no one has modified the share ... start the app in the
                user's context */
            if (dwOptions & NDDE_TRUST_SHARE_INIT) {
                uAgntExecRtn = NDDEAGT_INIT_OK;
#if DBG
                if (bDebugInfo) {
                    DPRINTF(("WinInit() Init allowed."));
                }
#endif
            } else {
                uAgntExecRtn = NDDEAGT_INIT_NO;
#if DBG
                if (bDebugErrors) {
                    DPRINTF(("WinInit() Init not allowed."));
                }
#endif
            }
        } else {
#if DBG
            if (bDebugErrors) {
                DPRINTF(("WinInit() CompareNddeModifyId failed"));
            }
#endif
            uAgntExecRtn = NDDEAGT_INIT_NO;
        }

        RetStatus = TRUE;
        break;

    default:
        RetStatus = FALSE;
        break;
    }
    if (RetStatus) {
        /* send a COPYDATA message back to NetDDE */
        cds.dwData = wMsgNddeAgntExecRtn;
        cds.cbData = sizeof(uAgntExecRtn);
        cds.lpData = &uAgntExecRtn;
        SendMessage( (HWND)wParam, WM_COPYDATA, (UINT) hWndNddeAgnt,
            (LPARAM) &cds );
    }
    return( RetStatus );
}


/*
 *  Given a share name, GetNddeShareModifyId() will retrieve the modify id
 *  associated with the DSDM share
 */
BOOL
GetNddeShareModifyId(
    LPTSTR  lpszShareName,
    LPDWORD lpdwId )
{
    PNDDESHAREINFO      lpDdeI = NULL;
    DWORD               avail = 0;
    WORD                items = 0;
    UINT                nRet;
    BOOL                bRetrieved = FALSE;

    DIPRINTF(("GetNddeShareModifyId( %s ): %d", lpszShareName, lpdwId ));
    /* get the share information out of the DSDM DB */
    nRet = NDdeShareGetInfo ( lpszServer, lpszShareName, 2, (LPBYTE)NULL,
        0, &avail, &items );
    if (nRet == NDDE_BUF_TOO_SMALL) {
        lpDdeI = (PNDDESHAREINFO) LocalAlloc(LMEM_FIXED, avail);
        if (lpDdeI == NULL) {
#if DBG
            if (bDebugErrors) {
                DPRINTF(("Unable to allocate sufficient (%d) memory: %d",
                    avail, GetLastError()));
            }
#endif
            bRetrieved = FALSE;
        } else {
            items = 0;
            nRet = NDdeShareGetInfo ( lpszServer, lpszShareName, 2, (LPBYTE)lpDdeI,
                avail, &avail, &items );

            if( nRet == NDDE_NO_ERROR )  {
                /* compare modify ids */
                bRetrieved = TRUE;
                lpdwId[0] = lpDdeI->qModifyId[0];
                lpdwId[1] = lpDdeI->qModifyId[1];
            } else {
#if DBG
                if (bDebugErrors) {
                    DPRINTF(("Unable to access DDE share \"%s\" info: %d",
                        lpszShareName, nRet));
                }
#endif
                bRetrieved = FALSE;
            }
            LocalFree(lpDdeI);
        }
    } else {
#if DBG
        if (bDebugErrors) {
            DPRINTF(("Unable to probe DDE share \"%s\" info size: %d",
                lpszShareName, nRet));
        }
#endif
        bRetrieved = FALSE;
    }
    return( bRetrieved );
}

BOOL
CompareModifyIds( LPTSTR lpszShareName )
{
    DWORD       dwIdNdde[2];
    DWORD       dwIdTrusted[2];
    DWORD       dwOptions;
    UINT        RetCode;
    BOOL        bRetrievedNdde;

    DIPRINTF(("ComaperModifyIds(%s)", lpszShareName));
    bRetrievedNdde = GetNddeShareModifyId( lpszShareName, &dwIdNdde[0] );
    if (!bRetrievedNdde) {
        return(FALSE);
    }
    RetCode = NDdeGetTrustedShare( lpszServer,lpszShareName,
        &dwOptions, &dwIdTrusted[0], &dwIdTrusted[1] );
    if (RetCode != NDDE_NO_ERROR) {
#if DBG
        if (bDebugErrors) {
            DPRINTF(("Error getting trusted share \"%s\" modify id: %d",
                lpszShareName, RetCode));
        }
#endif
        return(FALSE);
    }
    DIPRINTF(("CompareModifyIds() returns: NddeId: %08X%08X, TrustedId: %08X%08X",
                dwIdNdde[0], dwIdNdde[1], dwIdTrusted[0], dwIdTrusted[1]));
    if( (dwIdNdde[0] == dwIdTrusted[0])
        && (dwIdNdde[1] == dwIdTrusted[1]) )  {
        return(TRUE);
    } else {
        return(FALSE);
    }
}





/*
 *  CleanupTrustedShares() goes through all the truested shares for this user
 *  on this machine and makes certain that no one has modified the shares
 *  since the time the user said they were ok.
 */
VOID
CleanupTrustedShares( void )
{
    UINT                RetCode;
    DWORD               avail, entries;
    LPBYTE              lpBuf;
    LPTSTR              lpShareName;

    RetCode = NDdeTrustedShareEnum ( lpszServer, 0, (LPBYTE)&avail, 0, &entries, &avail );
    if (RetCode != NDDE_BUF_TOO_SMALL) {
#if DBG
        if (bDebugErrors) {
            DPRINTF(("Probing for Number of Trusted Shares Failed: %d", RetCode));
        }
#endif
        return;
    }
    lpBuf = LocalAlloc(LPTR, avail);
    if (lpBuf == NULL) {
#if DBG
        if (bDebugErrors) {
            DPRINTF(("Unable to allocate sufficient memory to enumerate trusted shares. Needed: %d", avail));
        }
#endif
        return;
    }
    RetCode = NDdeTrustedShareEnum ( lpszServer, 0, lpBuf, avail,
            &entries, &avail );
    if (RetCode != NDDE_NO_ERROR) {
#if DBG
        if (bDebugErrors) {
            DPRINTF(("Unable to enumerate trusted shares: %d", RetCode));
        }
#endif
        LocalFree(lpBuf);
        return;
    }
    for ( lpShareName = (LPTSTR)lpBuf; *lpShareName;
            lpShareName += lstrlen(lpShareName) + 1 ) {
        if( !CompareModifyIds( lpShareName ) )  {
            /* if they don't match exactly ... get rid of it */
            RetCode = NDdeSetTrustedShare( lpszServer, lpShareName, 0);   /* delete option */
#if DBG
            if (RetCode != NDDE_NO_ERROR) {
                if (bDebugErrors) {
                    DPRINTF(("Unable to delete obsolete trusted share \"%s\": %d",
                        lpShareName, RetCode));
                }
            }
#endif
        }
    }
    LocalFree(lpBuf);
    return;
}

/*
 *  CompareNddeModifyId() takes in the computer name, sharename and
 *  the modify id from a NetDDE share and looks up the sharename in
 *  the truested share db and verifies the modify ids are the same.
 */
BOOL
CompareNddeModifyId(
    LPTSTR      lpszShareName,
    LPDWORD     lpdwIdNdde,
    LPDWORD     lpdwOptions )
{
    UINT        RetCode;
    DWORD       dwIdTrusted[2]  = {0, 0};
    BOOL        bMatch = FALSE;

    RetCode = NDdeGetTrustedShare(lpszServer, lpszShareName,
        lpdwOptions, &dwIdTrusted[0], &dwIdTrusted[1]);
    if (RetCode != NDDE_NO_ERROR) {
#if DBG
        if (bDebugErrors) {
            DPRINTF(("Unable to access trusted share \"%s\" info: %d",
                lpszShareName, RetCode));
        }
#endif
        return(FALSE);
    }

    DIPRINTF(("CompareNddeModifyId() returns: NddeId: %08X%08X, TrustedId: %08X%08X",
            lpdwIdNdde[0], lpdwIdNdde[1],
            dwIdTrusted[0], dwIdTrusted[1]));

    if( (lpdwIdNdde[0] == dwIdTrusted[0])
        && (lpdwIdNdde[1] == dwIdTrusted[1]) )  {
            bMatch = TRUE;
    }

    return( bMatch );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ddeshare\dialogs.h ===
#define IDC_SHARENAME               101
#define IDC_APPNAME                 102
#define IDC_TOPICNAME               103
#define IDC_APPNAME_NEW             104
#define IDC_TOPICNAME_NEW           105
#define IDC_APPNAME_STATIC          106
#define IDC_TOPICNAME_STATIC        107
#define IDC_F_START_APP             108
#define IDC_SACL                    109
#define IDC_DACL                    110
#define IDC_ITEM_LIST               111
#define IDC_ITEMNAME                112
#define IDC_ADD                     113
#define IDC_DELETE                  114
#define IDC_ALL_ITEMS               115
#define IDC_RESTRICT_ITEMS          116
#define IDC_WW_STYLE                117
#define IDC_OLD_STYLE               118
#define IDC_NEW_STYLE               119
#define IDC_STATIC                  120
#define IDC_MYHELP                  121
#define IDC_F_SERVICE               122

#define IDC_SHARE_LIST              201
#define IDC_ADD_SHARE               203
#define IDC_PROPERTIES              204
#define IDC_DELETE_SHARE            205
#define IDC_TRUST_SHARE             206

#define IDC_SHARE_NAME              301
#define IDC_START_APP               303
#define IDC_INIT_ENABLE             304
#define IDC_CMD_OVERRIDE            305
#define IDC_CMD_SHOW                306
#define IDC_MODIFY                  308
#define IDC_VALUE                   309
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddeagnt\nddeagnp.h ===
#define MAXFONT                 10
#define IDC_NDDEAGNT            21
#define IDD_ABOUT               1
#define IDM_NDDEAGNT            20
#define IDM_EXIT               200
#define IDM_ABOUT              205
#define CI_VERSION             206
#define IDD_STARTING           100
#define STR_RUNNING            1    // STR_ must start at 1 and be consecutive.
#define STR_FAILED             2
#define STR_LOWMEM             3
#define STR_CANTSTART          4
#define STR_LAST               4

LONG	APIENTRY	NDDEAgntWndProc(HWND, UINT, WPARAM, LONG);
BOOL	APIENTRY	About(HWND, UINT, WPARAM, LONG);
INT                 NDDEAgntInit(HANDLE);
VOID                CleanupTrustedShares( void );
BOOL                HandleNetddeCopyData( HWND hWndNddeAgnt, UINT wParam,
			            PCOPYDATASTRUCT pCopyDataStruct );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddeexts\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

$(O)\nddeexts.def: gendef.c exts.h
        $(CXX_COMPILER_NAME) /EP gendef.c > $(O)\nddeexts.def

nddeexts.c: exts.h $(O)\nddeexts.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddeexts\nddeexts.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "netintf.h"
#include "netpkt.h"
#include "ddepkt.h"
#include "netbasic.h"
#include "netddesh.h"
#include "pktz.h"

PSTR pszExtName         = "USEREXTS";

#include <stdexts.h>
#include <stdexts.c>

char gach1[80];

/****************************************************************************\
* Flags stuff
\****************************************************************************/

#define NO_FLAG (LPSTR)-1  // use this for non-meaningful entries.

/*
 * Converts a 32bit set of flags into an appropriate string.
 * pszBuf should be large enough to hold this string, no checks are done.
 * pszBuf can be NULL, allowing use of a local static buffer but note that
 * this is not reentrant.
 * Output string has the form: " = FLAG1 | FLAG2 ..."
 */
LPSTR GetFlags(
LPSTR *apszFlagStrings,
DWORD dwFlags,
LPSTR pszBuf)
{
    static char szT[400];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    *pszBuf = '\0';

    for (i = 0; dwFlags; dwFlags >>= 1, i++) {
        if (!fNoMoreNames && (apszFlagStrings[i] == NULL)) {
            fNoMoreNames = TRUE;
        }
        if (dwFlags & 1) {
            if (!fFirst) {
                strcat(pszBuf, " | ");
            } else {
                strcat(pszBuf, " = ");
                fFirst = FALSE;
            }
            if (fNoMoreNames || (apszFlagStrings[i] == NO_FLAG)) {
                char ach[16];
                sprintf(ach, "0x%lx", 1 << i);
                strcat(pszBuf, ach);
            } else {
                strcat(pszBuf, apszFlagStrings[i]);
            }
        }
    }
    return(pszBuf);
}


BOOL Idtd()
{
    THREADDATA td, *ptd;

    moveExpValue(&ptd, "netdde!ptdHead");

    SAFEWHILE (ptd != NULL) {
        move(td, ptd);
        Print(
            "PTHREADDATA @ %x:\n"
            "  hwinsta     = %x\n"
            "  hdesk       = %x\n"
            "  hwndDDE     = %x\n"
            "  hwndDDEAgent= %x\n"
            "  heventReady = %x\n"
            "  dwThreadId  = %x\n"
            "  bInitiating = %x\n"
        ,
            ptd,
            td.hwinsta,
            td.hdesk,
            td.hwndDDE,
            td.hwndDDEAgent,
            td.heventReady,
            td.dwThreadId,
            td.bInitiating
        );
        ptd = td.ptdNext;
    }
    return(TRUE);
}



BOOL Idpktz(
DWORD opts,
PVOID param1)
{
    PKTZ pktz;

    if (param1 == 0) {
        Print("You must supply a pktz pointer.  Try breaking on PktzSlice().\n");
        return(FALSE);
    }
    move(pktz, param1);
    Print(
            "pk_connId              = %08lx\n"
            "pk_state               = %08lx\n"
            "pk_fControlPktNeeded   = %08lx\n"
            "pk_pktidNextToSend     = %08lx\n"
            "pk_pktidNextToBuild    = %08lx\n"
            "pk_lastPktStatus       = %08lx\n"
            "pk_lastPktRcvd         = %08lx\n"
            "pk_lastPktOk           = %08lx\n"
            "pk_lastPktOkOther      = %08lx\n"
            "pk_pktidNextToRecv     = %08lx\n"
            "pk_pktOffsInXmtMsg     = %08lx\n"
            "pk_lpDdePktSave        = %08lx\n"
            ,
             pktz.pk_connId           ,
             pktz.pk_state            ,
             pktz.pk_fControlPktNeeded,
             pktz.pk_pktidNextToSend  ,
             pktz.pk_pktidNextToBuild ,
             pktz.pk_lastPktStatus    ,
             pktz.pk_lastPktRcvd      ,
             pktz.pk_lastPktOk        ,
             pktz.pk_lastPktOkOther   ,
             pktz.pk_pktidNextToRecv  ,
             pktz.pk_pktOffsInXmtMsg  ,
             pktz.pk_lpDdePktSave     );

    Print(
            "pk_szDestName          = \"%s\"\n"
            "pk_szAliasName         = \"%s\"\n"
            ,
             &pktz.pk_szDestName         ,
             &pktz.pk_szAliasName        );

    Print(
            "pk_pktSize             = %08lx\n"
            "pk_maxUnackPkts        = %08lx\n"
            "pk_timeoutRcvNegCmd    = %08lx\n"
            "pk_timeoutRcvNegRsp    = %08lx\n"
            "pk_timeoutMemoryPause  = %08lx\n"
            "pk_timeoutKeepAlive    = %08lx\n"
            "pk_timeoutXmtStuck     = %08lx\n"
            "pk_timeoutSendRsp      = %08lx\n"
            "pk_wMaxNoResponse      = %08lx\n"
            "pk_wMaxXmtErr          = %08lx\n"
            "pk_wMaxMemErr          = %08lx\n"
            "pk_fDisconnect         = %08lx\n"
            "pk_nDelay              = %08lx\n"
            ,
             pktz.pk_pktSize            ,
             pktz.pk_maxUnackPkts       ,
             pktz.pk_timeoutRcvNegCmd   ,
             pktz.pk_timeoutRcvNegRsp   ,
             pktz.pk_timeoutMemoryPause ,
             pktz.pk_timeoutKeepAlive   ,
             pktz.pk_timeoutXmtStuck    ,
             pktz.pk_timeoutSendRsp     ,
             pktz.pk_wMaxNoResponse     ,
             pktz.pk_wMaxXmtErr         ,
             pktz.pk_wMaxMemErr         ,
             pktz.pk_fDisconnect        ,
             pktz.pk_nDelay             );

    Print(
            "pk_lpNiPtrs            = %08lx\n"
            "pk_sent                = %08lx\n"
            "pk_rcvd                = %08lx\n"
            "pk_hTimerKeepalive     = %08lx\n"
            "pk_hTimerXmtStuck      = %08lx\n"
            "pk_hTimerRcvNegCmd     = %08lx\n"
            "pk_hTimerRcvNegRsp     = %08lx\n"
            "pk_hTimerMemoryPause   = %08lx\n"
            "pk_hTimerCloseConnection = %08lx\n"
            "pk_pktUnackHead        = %08lx\n"
            "pk_pktUnackTail        = %08lx\n"
            "pk_rcvBuf              = %08lx\n"
            ,
             pktz.pk_lpNiPtrs               ,
             pktz.pk_sent                   ,
             pktz.pk_rcvd                   ,
             pktz.pk_hTimerKeepalive        ,
             pktz.pk_hTimerXmtStuck         ,
             pktz.pk_hTimerRcvNegCmd        ,
             pktz.pk_hTimerRcvNegRsp        ,
             pktz.pk_hTimerMemoryPause      ,
             pktz.pk_hTimerCloseConnection  ,
             pktz.pk_pktUnackHead           ,
             pktz.pk_pktUnackTail           ,
             pktz.pk_rcvBuf                 );

    Print(
            "pk_controlPkt          = %08lx\n"
            "pk_pktFreeHead         = %08lx\n"
            "pk_pktFreeTail         = %08lx\n"
            "pk_ddePktHead          = %08lx\n"
            "pk_ddePktTail          = %08lx\n"
            "pk_prevPktz            = %08lx\n"
            "pk_nextPktz            = %08lx\n"
            "pk_prevPktzForNetintf  = %08lx\n"
            "pk_nextPktzForNetintf  = %08lx\n"
            "pk_hRouterHead         = %08lx\n"
            "pk_hRouterExtraHead    = %08lx\n"
            ,
             pktz.pk_controlPkt             ,
             pktz.pk_pktFreeHead            ,
             pktz.pk_pktFreeTail            ,
             pktz.pk_ddePktHead             ,
             pktz.pk_ddePktTail             ,
             pktz.pk_prevPktz               ,
             pktz.pk_nextPktz               ,
             pktz.pk_prevPktzForNetintf     ,
             pktz.pk_nextPktzForNetintf     ,
             pktz.pk_hRouterHead            ,
             pktz.pk_hRouterExtraHead       );
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddenb32\config.h ===
#define CI_HELP			101
#define CI_PACKET_SIZE		102
#define CI_MAX_UNACK_PKTS	103
#define CI_RCV_CONN_CMD		104
#define CI_RCV_CONN_RSP		105
#define CI_MEMORY_PAUSE		106
#define CI_NO_RESPONSE		107
#define CI_KEEP_ALIVE		108
#define CI_RETRY_LIMIT_XMIT_ERR	109
#define CI_RETRY_LIMIT_MEM_ERR	110
#define CI_RETRY_LIMIT_RSP_ERR	111
#define CI_XMT_STUCK		112
#define CI_FROM_NETBIOS		113
#define CI_FIXED_PKT_SIZE	114
#define CI_RESTORE          119
#define CI_VERSION          120

#define CI_VAL_CRC		201
#define CI_VAL_CHECKSUM		202

#define CI_LOG_ALL		301
#define CI_LOG_UNUSUAL		302
#define CI_LOG_NONE		303

#define NBE_NRC_BUFLEN                  1
//#define NBE_FULL_BUFFERS              2
#define NBE_NRC_ILLCMD                  3
#define NBE_NRC_CMDTMO                  4
#define NBE_NRC_INCOMP                  5
#define NBE_NRC_BADDR                   6
#define NBE_NRC_SNUMOUT                 7
#define NBE_NRC_NORES                   8
#define NBE_NRC_SCLOSED                 9
#define NBE_NRC_CMDCAN                  10
//#define NBE_PCDMA_FAILED              11
#define NBE_NRC_DUPNAME                 12
#define NBE_NRC_NAMTFUL                 13
#define NBE_NRC_ACTSES                  14
#define NBE_NRC_NOWILD                  15
#define NBE_NRC_LOCTFUL                 16
#define NBE_NRC_REMTFUL                 17
#define NBE_NRC_ILLNN                   18
#define NBE_NRC_NOCALL                  19
//#define NBE_NRC_NOWILD2                 20
#define NBE_NRC_INUSE                   21
#define NBE_NRC_NAMERR                  22
#define NBE_NRC_SABORT                  23
#define NBE_NRC_NAMCONF                 24
//#define NBE_INCOMPAT_REMOTE_DEV       25
#define NBE_NRC_IFBUSY                  26
#define NBE_NRC_TOOMANY                 27
#define NBE_NRC_BRIDGE                  28
#define NBE_NRC_CANOCCR                 29
//#define NBE_RESERVED_NAME             30
#define NBE_NRC_CANCEL                  31
#define NBE_NRC_DUPENV                  32
//#define NBE_MULT_REQ_FOR_SAME_SESSION 33
#define NBE_NRC_ENVNOTDEF               34
#define NBE_NRC_OSRESNOTAV              35
#define NBE_NRC_MAXAPPS                 36
#define NBE_NRC_NOSAPS                  37
#define NBE_NRC_NORESOURCES             38
#define NBE_NRC_SYSTEM                  39
//#define NBE_HOT_CARRIER_REMOTE        40
//#define NBE_HOT_CARRIER_LOCAL         41
//#define NBE_NO_CARRIER                42
//#define NBE_INTERFACE_FAILURE         43
//#define NBE_BITS_ON_TOO_LONG          44
//#define NBE_BITS_ON                   45
//#define NBE_ADAPTER_FAILED            46
//#define NBE_DIR_INITIALIZE_ERROR      47
//#define NBE_DIR_OPEN_ADAPTER_ERROR    48
//#define NBE_IBM_LAN_INTERNAL_ERROR    49
//#define NBE_NETBIOS_CARD_ERROR        50
#define NBE_NRC_OPENERR                 51
//#define NBE_SAP_FAILED                52
//#define NBE_UNEXPECTED_ADAPTER_CLOSE  53
#define NBE_HARDWARE_ERROR              54
#define NBE_UNKNOWN_ERROR               55

#define NBE_NRC_INVADDRESS         2
#define NBE_NRC_INVDDID            11
#define NBE_NRC_LOCKFAIL            25
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddenb32\ncb.h ===
typedef struct {
    BYTE	NcbCommand;
    BYTE	NcbRetCode;
    BYTE	NcbLsn;
    BYTE	NcbNum;
    LPSTR	NcbBufferAddr;
    WORD	NcbLength;
    char	NcbCallName[ 16 ];
    char	NcbName[ 16 ];
    BYTE	NcbRto;
    BYTE	NcbSto;
    LPSTR	NcbPostAddr;
    BYTE	NcbLanaNum;
    BYTE	NcbCmdCplt;
    char	NcbReserved[ 14 ];
} NCB;
typedef NCB *PNCB;
typedef NCB FAR *LPNCB;

#define NO_WAIT			0x80

#define NETBIOS_INVALID_COMMAND	0x03
#define NETBIOS_CALL		0x10
#define NETBIOS_LISTEN		0x11
#define NETBIOS_HANG_UP		0x12
#define NETBIOS_SEND		0x14
#define NETBIOS_RECEIVE		0x15
#define NETBIOS_ADD_NAME	0x30
#define NETBIOS_DELETE_NAME	0x31
#define NETBIOS_RESET_ADAPTER   0x32
#define NETBIOS_ADAPTER_STATUS	0x33
#define NETBIOS_CANCEL		0x35
#define NETBIOS_ADD_GROUP_NAME	0x36

#define COMMAND_PENDING		0xFF
#define INVALID_SESSION		0x00
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddenb32\dlc.h ===
#define MAX_NAMES 254

struct NameTableEntry {
    char	EntryName[ 16 ];
    BYTE	EntryNameNum;
    BYTE	EntryNameStatus;	/* & with 0x0087 for status */
};

typedef struct {
    BYTE	PermanentNodeName[ 6 ];
    BYTE	MajorVersionNumber;
    BYTE	AlwaysZero;
    BYTE	LanAdapterType;
    BYTE	MinorVersionNumber;
    WORD	ReportingPeriodMinutes;
    WORD	FrameRejectedReceiveCount;
    WORD	FrameRejectedXmitCount;
    WORD	I_FrameReceiveErrorCount;
    WORD	XmitAbortCount;
    DWORD	SuccessfulFrameXmitCount;
    DWORD	SuccessfulFrameRcvCount;
    WORD	I_FrameXmitErrorCount;
    WORD	RmtRqstBufferDepletionCount;
    WORD	ExpiredT1TimerCount;
    WORD	ExpiredTiTimerCount;
    LPSTR	LocalExtStatPtr;
    WORD	FreeCommandBlocks;
    WORD	CurrentMaxNcbs;
    WORD	MaximumCommands;
    WORD	TransmitBufferDepletionCount;
    WORD	MaximumDatagramPacketSize;
    WORD	PendingSessionCount;
    WORD	MaxPendingSessionCount;
    WORD	MaximumSessions;
    WORD	MaximumSessionPacketSize;
    WORD	NameTableEntryCount;
    struct NameTableEntry TableEntry[ MAX_NAMES ];
} DLC;
typedef DLC FAR *LPDLC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddenb32\netbios.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NETBIOS.C;3  13-Feb-93,9:21:54  LastEdit=IGOR  Locker=IGORM" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "api1632.h"

#include    <dos.h>
#include    <string.h>
#include    <windows.h>

#undef      NCB_INCLUDED
#include    <nb30.h>        // Use Microsoft's NCB defs

#include    "host.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "dlc.h"
#include    "hexdump.h"
#include    "debug.h"
#include    "verify.h"
#include    "wwassert.h"
#include    "tmpbuf.h"
#include    "tmpbufc.h"
#include    "proflspt.h"
typedef     long INTG;
#include    "getintg.h"
#include    "config.h"
#include    "nddemsg.h"
#include    "nddelog.h"


USES_ASSERT

#define NETBIOS_SPECIAL     0x1F

#define RS_IDLE             0x11
#define RS_RECVING          0x12

#define SS_IDLE             0x21
#define SS_XMITING          0x22

typedef struct conn {
    struct conn FAR    *prev;
    struct conn FAR    *next;

    char                nodeName[ MAX_NODE_NAME+1 ];
    BYTE                sessionLsn;
    BYTE                lananum;
    int                 current_lananum;
    int                 lananum_count;
    DWORD               state;
    WORD                wMaxUnAckPkts;
    WORD                wPktSize;
    BYTE                bXmtVerifyMethod;
    NCB                 ncbCall;

    LPSTR               lpRcvBuf;
    NCB                 ncbRecv;
    WORD                wLastPktStatus;
    WORD                wLastPktSize;
    WORD                wRcvState;

    LPSTR               lpXmtBuf;
    NCB                 ncbSend;
    WORD                wXmtState;
} CONN;
typedef CONN FAR *LPCONN;

extern HANDLE   hInst;

VOID FAR PASCAL CenterDlg(HWND);

BYTE    lananum[ MAX_LANA ];    // configured lan adapter numbers
int     nLananums;              // how many lananums are configured
int     last_good_lana = 0;     // index of the last lana that connected

/*
        Event Logger Control Variables
*/
BOOL    bNDDELogInfo            = FALSE;
BOOL    bNDDELogWarnings        = FALSE;
BOOL    bNDDELogErrors          = TRUE;


/*
        Debug Logger (netdde.log) Control Variables
*/
BOOL    bDebugInfo          = FALSE;
BOOL    bDebugMenu          = FALSE;
BOOL    bLogAll             = FALSE;
BOOL    bLogUnusual         = TRUE;
BOOL    bUseNetbiosPost;
BOOL    bUseResetAdapter    = FALSE;
BOOL    bUseAdapterStatus   = TRUE;
WORD    dflt_pktsize;

BYTE    dflt_vermeth            = VERMETH_CKS32;
WORD    dflt_maxunack           = 10;
DWORD   dflt_timeoutRcvConnCmd  = 60000;
DWORD   dflt_timeoutRcvConnRsp  = 60000;
DWORD   dflt_timeoutMemoryPause = 10000;
DWORD   dflt_timeoutKeepAlive   = 60000;
DWORD   dflt_timeoutXmtStuck    = 120000;
DWORD   dflt_timeoutSendRsp     = 60000;
WORD    dflt_maxNoResponse      = 3;
WORD    dflt_maxXmtErr          = 3;
WORD    dflt_maxMemErr          = 3;
BYTE    dflt_maxSessions        = 0; //if zero, defaults to max of 16 sessions for NT


char        szNetddeIni[]           =       "netdde.ini";
char        szUsePost[]             =       "UseNetbiosPost";
char        szUseReset[]            =       "UseResetAdapter";
char        szUseStatus[]           =       "UseAdapterStatus";

BOOL        bNameAdded[ MAX_LANA ];
#ifdef HASUI
char        szHelpFileName[ 128 ];
#endif // HASUI
char        buf[ 500 ];
char        ourNodeName[ 20 ];
LPCONN      lpConnHead;
HHEAP       hHeap;              /*  dummy */
PNCB        lpNcbListen[ MAX_LANA ];

HWND            NB_hWndNetdde;

/*
 *  only put NCBs in the DS if they are SYNCHRONOUS, i.e., if ASYNCH is not set
 */
NCB             ncbAddName;
NCB             ncbHangup;
NCB             ncbDeleteName;
NCB             ncbCancel;
NCB             ncbCheck;


#if DBG
VOID                        LogDebugInfo( CONNID connId, DWORD dwFlags );
#endif // DBG

#ifdef HASUI
VOID                        Configure( void );
BOOL    FAR PASCAL          ConfigureDlgProc( HWND, unsigned, WORD, LONG );
#else
VOID                        Configure( void ) { };
BOOL
FAR PASCAL
ConfigureDlgProc( HWND hDummy, unsigned uDummy, WORD wDummy, LONG lDummy )
{
    return(FALSE);
}
#endif

VOID    FAR PASCAL MakeHelpPathName( char *szFileName, int nMax );
BOOL    FAR PASCAL SetupListen( int nLananum );
VOID    FAR PASCAL SetupReceive( LPCONN lpConn );
CONNID  FAR PASCAL CreateConnId( void );
BOOL    FAR PASCAL AllocateBuffers( LPCONN lpConn );
VOID    FAR PASCAL FreeBuffers( LPCONN lpConn );
VOID    FAR PASCAL FreeConnId( CONNID connId );
VOID    FAR PASCAL DoDisconnect( CONNID connId );
LPSTR   FAR PASCAL NetbiosErrorMsg( BYTE errCode );
UCHAR APIENTRY      Netbios( PNCB pncb );
VOID                NetbiosPost( PNCB lpNcb );
VOID    FAR PASCAL HangUpSession( BYTE, BYTE );
BYTE    FAR PASCAL NetbiosDeleteName( BYTE, LPSTR );
VOID    FAR PASCAL CancelNCB( BYTE, PNCB );
VOID    FAR PASCAL NetBIOSPostMsg( PNCB lpNCB, int nCompletionCode );
BOOL    FAR PASCAL InitLanaNums( VOID );

/* this is important since _TEXT is FIXED, PRELOAD, NONDISCARDABLE */



void
NDDETimeSlice( void )
{
    LPCONN      lpConn;
    BOOL        gotRcv;
    BOOL        bClose;
    LPNETPKT    lpPacket;

    lpConn = lpConnHead;
    while( lpConn )  {
        if( lpConn->state & NDDE_CONN_CONNECTING )  {
            if( lpConn->ncbCall.ncb_cmd_cplt != NRC_PENDING )  {
                if( lpConn->ncbCall.ncb_retcode == 0x00 )  {
                    DIPRINTF(( "Connected Lsn %d", lpConn->ncbCall.ncb_lsn ));
                    lpConn->state = NDDE_CONN_OK | NDDE_READY_TO_XMT;
                    lpConn->sessionLsn = lpConn->ncbCall.ncb_lsn;
                    last_good_lana = lpConn->current_lananum;
                    SetupReceive( lpConn );
                } else {
                    if (++lpConn->current_lananum >= nLananums) {
                        lpConn->current_lananum = 0;    // wrap around
                    }
                    if( ++lpConn->lananum_count >= nLananums )  {
                        // tried them all and it still failed
                        if( bLogAll )  {
                            /*  Connect failed to "%1": %2  */
                            NDDELogWarning(MSG200, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbCall.ncb_retcode ), NULL );
                        } else if( bLogUnusual )  {
                            switch( lpConn->ncbCall.ncb_retcode )  {
                            case 0x12:  // no remote listen
                            case 0x14:  // cannot find name or no answer
                                break;
                            default:
                                /*  Connect failed to "%1": %2  */
                                NDDELogError(MSG200, (LPSTR) lpConn->nodeName,
                                    NetbiosErrorMsg( lpConn->ncbCall.ncb_retcode ), NULL );
                            }
                        }
                        lpConn->state = 0;
                    } else {
                        // try the next LAN adapter num
                        lpConn->lananum = lananum[ lpConn->current_lananum ];
                        lpConn->ncbCall.ncb_lana_num = lpConn->lananum;
                        lpConn->ncbCall.ncb_cmd_cplt = 0;
                        lpConn->ncbCall.ncb_retcode = 0;
                        Netbios( &lpConn->ncbCall );
                    }
                }
            }
        } else if( lpConn->state & NDDE_CONN_OK )  {
            bClose = FALSE;
            gotRcv = FALSE;
            if( lpConn->wRcvState == RS_RECVING )  {
                if( lpConn->ncbRecv.ncb_cmd_cplt != NRC_PENDING )  {
                    lpConn->wRcvState = RS_IDLE;
                    if( lpConn->ncbRecv.ncb_retcode == 0x00 )  {
                        lpPacket = (LPNETPKT) lpConn->lpRcvBuf;
                        if( VerifyHdr( lpPacket ) && VerifyData( lpPacket ) ){
                            lpConn->wLastPktStatus =
                                NDDE_PKT_HDR_OK | NDDE_PKT_DATA_OK;
                            lpConn->wLastPktSize = lpConn->ncbRecv.ncb_length;
                            gotRcv = TRUE;
                        } else {
                            bClose = TRUE;
                        }
                    } else if( (lpConn->ncbRecv.ncb_retcode == 0x0A)
                                || (lpConn->ncbRecv.ncb_retcode == 0x18) )  {
                        if( bLogAll )  {
                            // Session has been closed normally
                            /*  Receive error. Session to %1 closed abonormally: %2  */
                            NDDELogWarning(MSG201, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbRecv.ncb_retcode ), NULL );
                        }
                        bClose = TRUE;
                    } else {
                        if( bLogUnusual )  {
                            /*  Receive error. Session to %1 closed abonormally: %2  */
                            NDDELogError(MSG201, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbRecv.ncb_retcode ), NULL );
                        }
                        bClose = TRUE;
                    }
                }
            }
            if( !bClose && (lpConn->wXmtState == SS_XMITING) )  {
                if( lpConn->ncbSend.ncb_cmd_cplt != NRC_PENDING )  {
                    lpConn->wXmtState = SS_IDLE;
                    if( lpConn->ncbSend.ncb_retcode == 0x00 )  {
                        lpConn->state |= NDDE_READY_TO_XMT;
                        lpConn->wXmtState = SS_IDLE;
                    } else if( (lpConn->ncbSend.ncb_retcode == 0x0A) ||
                        (lpConn->ncbSend.ncb_retcode == 0x18) )  {
                        bClose = TRUE;
                    } else {
                        if( bLogUnusual )  {
                            /*  Send error. Session to %1 closed abonormally: %2  */
                            NDDELogWarning(MSG202, (LPSTR) lpConn->nodeName,
                                NetbiosErrorMsg( lpConn->ncbSend.ncb_retcode ), NULL );
                        }
                        bClose = TRUE;
                    }
                }
            }
            if( bClose )  {
                DoDisconnect( (CONNID) lpConn );
            } else if( gotRcv )  {
                lpConn->state |= NDDE_CALL_RCV_PKT;
            }
        }
        lpConn = lpConn->next;
    }
}




DWORD
NDDEGetCAPS( WORD nIndex )
{
    switch( nIndex )  {
    case NDDE_SPEC_VERSION:
        return( NDDE_CUR_VERSION );
        break;

    case NDDE_MAPPING_SUPPORT:
        return( NDDE_MAPS_YES );
        break;

    case NDDE_SCHEDULE_METHOD:
        return( NDDE_TIMESLICE );
        break;

#ifdef HASUI
    case NDDE_CONFIG_PARAMS:
        if (bDebugMenu) {
            return(NDDE_PARAMS_OK);
        } else {
            return(NDDE_PARAMS_NO);
        }
        break;
#endif

    default:
        return( 0L );
    }
}




DWORD
NDDEInit(
    LPSTR   lpszNodeName,
    HWND    hWndNetdde )
{
    BOOL                ok;
    static char         dllName[] = "NetBIOS";

#if DBG
    DebugInit( "NetBIOS" );
#endif // DBG

    NB_hWndNetdde = hWndNetdde;

/*
        Determine what we're allowed to log in the event logger
*/
    bNDDELogInfo = MyGetPrivateProfileInt( dllName,
        "NDDELogInfo", FALSE, szNetddeIni );
    bNDDELogWarnings = MyGetPrivateProfileInt( dllName,
        "NDDELogWarnings", FALSE, szNetddeIni );
    bNDDELogErrors = MyGetPrivateProfileInt( dllName,
        "NDDELogErrors", TRUE, szNetddeIni );


    if( lstrlen( lpszNodeName ) > 15 )  {
        NDDELogError(MSG208, lpszNodeName);
        return( NDDE_INIT_FAIL );
    }

    lstrcpy( ourNodeName, lpszNodeName );
#ifdef HASUI
    MakeHelpPathName( szHelpFileName, sizeof(szHelpFileName) );
#endif // HASUI
    bUseNetbiosPost = MyGetPrivateProfileInt( dllName,
        szUsePost, TRUE, szNetddeIni );
    bUseResetAdapter = MyGetPrivateProfileInt( dllName,
        szUseReset, TRUE, szNetddeIni );
    bUseAdapterStatus = MyGetPrivateProfileInt( dllName,
        szUseStatus, TRUE, szNetddeIni );

    bLogAll = MyGetPrivateProfileInt( dllName,
                        "LogAll", FALSE, szNetddeIni );
    bLogUnusual = MyGetPrivateProfileInt( dllName,
                        "LogUnusual", TRUE, szNetddeIni );
    if( bLogAll )  {
        bLogUnusual = TRUE;
    }

#if DBG
    bDebugMenu = MyGetPrivateProfileInt( "General", "DebugMenu",
        FALSE, szNetddeIni);
    bDebugInfo = MyGetPrivateProfileInt( dllName, "DebugInfo",
        FALSE, szNetddeIni);
#endif

    dflt_vermeth = (BYTE)MyGetPrivateProfileInt( dllName,
                        "Vermeth", VERMETH_CKS32, szNetddeIni );
    if( dflt_vermeth != VERMETH_CRC16 )  {
        dflt_vermeth = VERMETH_CKS32;
    }
    dflt_maxunack = (WORD)MyGetPrivateProfileInt( dllName,
                        "Maxunack", 10, szNetddeIni );
    dflt_timeoutRcvConnCmd = GetPrivateProfileLong( dllName,
                        "TimeoutRcvConnCmd", 60000, szNetddeIni );
    dflt_timeoutRcvConnRsp = GetPrivateProfileLong( dllName,
                        "TimeoutRcvConnRsp", 60000, szNetddeIni );
    dflt_timeoutMemoryPause = GetPrivateProfileLong( dllName,
                        "TimeoutMemoryPause", 10000, szNetddeIni );
    dflt_timeoutKeepAlive = GetPrivateProfileLong( dllName,
                        "TimeoutKeepAlive", 60000, szNetddeIni );
    dflt_timeoutXmtStuck = GetPrivateProfileLong( dllName,
                        "TimeoutXmtStuck", 120000, szNetddeIni );
    dflt_timeoutSendRsp = GetPrivateProfileLong( dllName,
                        "TimeoutSendRsp", 60000, szNetddeIni );
    dflt_maxNoResponse = (WORD)MyGetPrivateProfileInt( dllName,
                        "MaxNoResponse", 3, szNetddeIni );
    dflt_maxXmtErr = (WORD)MyGetPrivateProfileInt( dllName,
                        "MaxXmtErr", 3, szNetddeIni );
    dflt_maxMemErr = (WORD)MyGetPrivateProfileInt( dllName,
                        "MaxMemErr", 3, szNetddeIni );
    dflt_maxSessions = (BYTE)MyGetPrivateProfileInt( dllName,
                        "MaxSessions", 0, szNetddeIni );

    ok = InitLanaNums();

    if (ok) {
        return(NDDE_INIT_OK);
    } else {
        return(NDDE_INIT_FAIL);
    }

}

BOOL
InitLanaNums( )
{
    BOOL                ok = TRUE;
    LANA_ENUM           lana_enum;
    NCB                 ncbEnum;
    int                 i, l;

    /*
     * find out how many and which lananums we support
     */
    _fmemset( (LPSTR)&ncbEnum, 0, sizeof(ncbEnum) );
    ncbEnum.ncb_command = NCBENUM;
    ncbEnum.ncb_buffer = (PUCHAR)&lana_enum;
    ncbEnum.ncb_length = sizeof(lana_enum);
    Netbios(&ncbEnum);
    if (ncbEnum.ncb_retcode != NRC_GOODRET) {
        DPRINTF(("ncbEnum failed: %s", NetbiosErrorMsg(ncbEnum.ncb_retcode)));
        NDDELogError(MSG204, NULL);
        nLananums = 0;
        ok = FALSE;
    } else {
        nLananums = lana_enum.length;
        for (l = 0; l < nLananums ; l++) {
            lananum[l] = lana_enum.lana[l];
        }
    }

    /*
     * allocate NCB listen blocks for each lanna
     */
    for( i=0; ok && i<nLananums; i++ )  {
        lpNcbListen[i] = HeapAllocPtr( hHeap, GMEM_MOVEABLE,
            (DWORD)sizeof(NCB) );
        if( !lpNcbListen[i] )  {
            NDDELogError(MSG203, NULL);
            ok = FALSE;
        }
    }

    if (ok) {
        dflt_pktsize = 0;
        /*
         * cycle through each lan adapter and determine default pkt size
         */
        for( l = 0; ok && l < nLananums; l++ )  {
            /*
             * Reset each adapter.
             */
            if( !bUseResetAdapter )  {
                DIPRINTF(( "Skipping reset adapter" ));
                dflt_pktsize = 1470;
            } else {
                _fmemset( (LPSTR)&ncbCheck, 0, sizeof(ncbCheck) );
                ncbCheck.ncb_command         = NCBRESET;
                ncbCheck.ncb_lana_num        = lananum[l];
                ncbCheck.ncb_callname[0]     = dflt_maxSessions;    // Num Sessions
                ncbCheck.ncb_callname[1]     = 0;    // Num Commands
                ncbCheck.ncb_callname[2]     = 0;    // Num Names
                ncbCheck.ncb_callname[3]     = 0;    // Name #1 Usage:
                                                        // 0: don't want it
                                                        // 1: want it
                Netbios( &ncbCheck );
                DIPRINTF(( "Reset adapter status: %02X", ncbCheck.ncb_retcode ));

                if( ncbCheck.ncb_retcode != 0x00 )  {
                    /*  NetBIOS Reset Adapter interface %1 failed: %2   */
                    NDDELogInfo(MSG209, LogString("%d", lananum[l]),
                        LogString("0x%0X", ncbCheck.ncb_retcode), NULL);
                    /*
                     * this adapter must be messed up even though the registry
                     * says its ok.  Just remove this lananum from the list.
                     */
                    nLananums--;
                    lananum[l] = lananum[nLananums];
                    HeapFreePtr(lpNcbListen[l]);
                    lpNcbListen[l] = lpNcbListen[nLananums];
                    if (nLananums == 0) {
                        ok = FALSE;
                    } else {
                        l--;
                    }
                    continue;
                }
            }

            /*
             * get status of each adapter.
             */
            if( !bUseAdapterStatus )  {
                DIPRINTF(( "Skipping Adapter Status" ));
                dflt_pktsize = 1470;
            } else {
                {
                    DLC DlcData;

                    _fmemset( (LPSTR)&ncbCheck, 0, sizeof(ncbCheck) );
                    ncbCheck.ncb_command     = NCBASTAT;
                    ncbCheck.ncb_buffer  = (LPSTR) &DlcData;
                    ncbCheck.ncb_length      = sizeof(DlcData) - sizeof(DlcData.TableEntry);
                    for( i = 0; i < NCBNAMSZ; i++ )  {
                        ncbCheck.ncb_callname[i] = ' ';
                    }
                    ncbCheck.ncb_callname[0] = '*';
                    ncbCheck.ncb_lana_num = lananum[l];
                    ncbCheck.ncb_retcode = 0xFF;

                    Netbios( &ncbCheck );
                }
                DIPRINTF(( "Adapter status returned: %02X", ncbCheck.ncb_retcode ));
                if( (ncbCheck.ncb_retcode != 0x00)
                        && (ncbCheck.ncb_retcode != 0x06) )  {
                    if (ncbCheck.ncb_retcode == 0xFF) {
                        /*
                         * Int 5C Vector set but NetBIOS not installed.
                         */
                        NDDELogError(MSG210, NULL);
                    } else {
                        /*
                         * NetBIOS Adapter Status Query on interface %1 failed: %2
                         */
                        NDDELogError(MSG211, LogString("%d", l),
                            LogString("0x%0X", ncbCheck.ncb_retcode), NULL);
                    }
                    /*
                     * Remove this lananum from the list.
                     */
                    nLananums--;
                    lananum[l] = lananum[nLananums];
                    HeapFreePtr(lpNcbListen[l]);
                    lpNcbListen[l] = lpNcbListen[nLananums];
                    if (nLananums == 0) {
                        ok = FALSE;
                    } else {
                        l--;
                    }
                    continue;
                }
            }
            // make dflt_pktsize maximum of available LAN Adapters
            dflt_pktsize = max((int)dflt_pktsize,1470);
        }
    }

    if( ok )  {
        /*
         * cycle through each lan adapter and add name
         */
        for( l=0; ok && l<nLananums; l++ )  {
            _fmemset( (LPSTR)&ncbAddName, 0, sizeof(ncbAddName) );
            ncbAddName.ncb_command = NCBADDNAME;
            for( i = 0; i < NCBNAMSZ; i++ )  {
                ncbAddName.ncb_callname[i] = ' ';
                ncbAddName.ncb_name[i] = ' ';
            }
            strncpy( ncbAddName.ncb_name, ourNodeName, lstrlen(ourNodeName) );
            ncbAddName.ncb_name[15] = NETBIOS_SPECIAL;
            ncbAddName.ncb_lana_num = lananum[l];
            Netbios( &ncbAddName );
            bNameAdded[l] = FALSE;
            switch( ncbAddName.ncb_retcode )  {
            case NRC_GOODRET:
                bNameAdded[l] = TRUE;
                break;
            case NRC_DUPNAME:
            case NRC_INUSE:
                /*  Node name "%1" already in use on network adapter %2 */
                NDDELogError(MSG212, (LPSTR) ourNodeName,
                    LogString("%d", l), NULL);
                ok = FALSE;
                break;
            default:
                /*  Unknown Error Code returned by adapter %1
                    while adding node name to network: %2 */
                NDDELogError(MSG213, LogString("%d", l),
                    LogString("0x%0X", ncbAddName.ncb_retcode), NULL);
                ok = FALSE;
            }
        }
    }
    if( ok )  {
        for( l=0; ok && l<nLananums; l++ )  {
            ok = SetupListen( l );
            if( !ok ) {
                NDDELogError(MSG214, NULL);
            }
        }
    }

    return ok;
}



void
NDDEShutdown( void )
{
    LPCONN      lpConn;
    CONNID      connId;
    int         i;
    int         stat;

    lpConn = lpConnHead;
    while( connId = (CONNID) lpConn )  {
        lpConn = lpConn->next;
        NDDEDeleteConnection( connId );
    }
    lpConnHead = lpConn;

    for( i=0; i<nLananums; i++ )  {
        if( lpNcbListen[i] )
            if (lpNcbListen[i]->ncb_cmd_cplt == NRC_PENDING) {
                CancelNCB( lananum[i], lpNcbListen[i] );
            } else {
                HangUpSession( lananum[i], lpNcbListen[i]->ncb_lsn );
            }
        if (stat = NetbiosDeleteName( lananum[i], ourNodeName )) {
            /*  Unable to delete our name "%1" from interface: status = %2  */
            NDDELogWarning(MSG205, (LPSTR) ourNodeName,
                LogString("0x%0X", stat), NULL);
        }
    }
}




CONNID
FAR PASCAL CreateConnId( void )
{
    LPCONN      lpConn;

    lpConn = HeapAllocPtr( hHeap, GMEM_MOVEABLE | GMEM_ZEROINIT,
        (DWORD) sizeof(CONN) );
    if( lpConn )  {
        lstrcpy( lpConn->nodeName, "[UNKNOWN]" );
        lpConn->sessionLsn              = 0;
        lpConn->state                   = 0;
        lpConn->wMaxUnAckPkts           = dflt_maxunack;
        lpConn->wPktSize                = dflt_pktsize;
        lpConn->bXmtVerifyMethod        = dflt_vermeth;
        lpConn->prev                    = (LPCONN) NULL;
        lpConn->next                    = lpConnHead;
        lpConn->wRcvState               = RS_IDLE;
        lpConn->wXmtState               = SS_IDLE;
        if( AllocateBuffers( lpConn ) )  {
            /* link into list */
            if( lpConnHead )  {
                lpConnHead->prev = lpConn;
            }
            lpConnHead = lpConn;
        } else {
            HeapFreePtr( lpConn );
            lpConn = NULL;
        }
    }
    return( (CONNID) lpConn );
}




VOID
FAR PASCAL FreeConnId( CONNID connId )
{
    LPCONN      lpConn;
    LPCONN      lpConnPrev;
    LPCONN      lpConnNext;

    if( connId )  {
        lpConn = (LPCONN) connId;
        lpConnPrev = lpConn->prev;
        lpConnNext = lpConn->next;
        if( lpConnPrev )  {
            lpConnPrev->next = lpConnNext;
        } else {
            lpConnHead = lpConnNext;
        }
        if( lpConnNext )  {
            lpConnNext->prev = lpConnPrev;
        }
        FreeBuffers( lpConn );
        HeapFreePtr( lpConn );
    }
}




BOOL
FAR PASCAL
SetupListen( int nLananum )
{
    PNCB       lpNCB;
    int         i;

    if( lpNcbListen[nLananum] == NULL )  {
        return( FALSE );
    }

    lpNCB = lpNcbListen[nLananum];
    _fmemset( (LPSTR)lpNCB, 0, sizeof(NCB) );
    lpNCB->ncb_command = NCBLISTEN | ASYNCH;
    for( i = 0; i < NCBNAMSZ; i++ )  {
        lpNCB->ncb_callname[i] = ' ';
        lpNCB->ncb_name[i] = ' ';
    }
    lpNCB->ncb_callname[0] = '*';
    for( i=0; i<15; i++ )  {
        if( ourNodeName[i] == '\0' )  {
            break;
        } else {
            lpNCB->ncb_name[i] = ourNodeName[i];
        }
    }
    lpNCB->ncb_name[15] = NETBIOS_SPECIAL;
    lpNCB->ncb_rto = 0;
    lpNCB->ncb_sto = 0;
    lpNCB->ncb_lana_num = lananum[nLananum];
    if( bUseNetbiosPost )  {
        lpNCB->ncb_post = NetbiosPost;
    }

    Netbios( lpNCB );

    return( TRUE );
}




CONNID
NDDEGetNewConnection( void )
{
    LPCONN  lpConn;
    int     i;
    CONNID  connIdWaitGet = (CONNID) NULL;
    BOOL    bNetReturned = FALSE;

    for( i=0; !connIdWaitGet && i<nLananums; i++ )  {
        if( lpNcbListen[i]
            && (lpNcbListen[i]->ncb_cmd_cplt != NRC_PENDING ) )  {
            if( lpNcbListen[i]->ncb_retcode == 0x00 )  {
                connIdWaitGet = CreateConnId();
                if( connIdWaitGet )  {
                    lpConn = (LPCONN) connIdWaitGet;
                    lpConn->sessionLsn  = lpNcbListen[i]->ncb_lsn;
                    lpConn->lananum     = lananum[i];
                    lpConn->state       = NDDE_CONN_OK | NDDE_READY_TO_XMT;
                    DIPRINTF(( "Someone called us, lsn: %d",
                            lpConn->sessionLsn ));
                    SetupReceive( lpConn );
                } else {
                    /* not enough memory for connection ... close it */
                    HangUpSession( lananum[i], lpNcbListen[i]->ncb_lsn );
                }
                SetupListen( i );
            } else {

                static DWORD TimeMark = 0;

                //  The net is down or the cable is unplugged.  Log an error
                //  infrequently, so we dont slow down the system
                //  No need to repeatedly retry without waiting at least 1 sec
                //
                if(lpNcbListen[i]->ncb_retcode != NRC_NOWILD)
                {
                    if ((GetTickCount() - TimeMark) > (30*60*1000))
                    {
                        TimeMark = GetTickCount();
                        /*  Listen failed: %1   */
                        NDDELogError(MSG206,
                            NetbiosErrorMsg( lpNcbListen[i]->ncb_retcode ), NULL );
                    }

                    Sleep(2000);
                    SetupListen( i );
                }
                else
                {
                    //  NRC_NOWILD is the error we get when the network comes back; we need to
                    //  free and then reinitialize the lpncblisten structures; also reset the log timeout
                    //

                    NDDELogError(MSG206,
                        NetbiosErrorMsg( lpNcbListen[i]->ncb_retcode ), NULL );

                    bNetReturned = TRUE;

                    TimeMark = 0;
                }
            }
        }
    }

    //  cancel all NCB calls before freeing the memory; InitLanaNums will reinitialize all NB settings
    //
    if (bNetReturned)
    {
        for( i=0; i<nLananums; i++ )
        {
            if ( lpNcbListen[i] )
            {
                if (lpNcbListen[i]->ncb_cmd_cplt == NRC_PENDING)
                    CancelNCB(lananum[i], lpNcbListen[i]);

                HeapFreePtr( lpNcbListen[i] );
                lpNcbListen[i] = NULL;
            }
        }

        InitLanaNums();
    }

    return( connIdWaitGet );
}




CONNID
	NDDEAddConnection( LPSTR nodeName )
{
    LPCONN      lpConn;
    CONNID      connId;
    BOOL        ok;
    int         i;


    if( lstrlen(nodeName) > 15 )  {
        NDDELogError(MSG207, nodeName, NULL);
        return( (CONNID) NULL );
    }

    connId = CreateConnId();
    if( connId )  {
        ok = TRUE;
        lpConn = (LPCONN) connId;
        _fstrncpy( lpConn->nodeName, nodeName, sizeof(lpConn->nodeName) );
        AnsiUpperBuff( lpConn->nodeName, lstrlen(lpConn->nodeName) );
        lpConn->state   = NDDE_CONN_CONNECTING;
        _fmemset( (LPSTR)&lpConn->ncbCall, 0, sizeof(NCB) );
        lpConn->ncbCall.ncb_command = NCBCALL | ASYNCH;
        for( i = 0; i < NCBNAMSZ; i++ )  {
            lpConn->ncbCall.ncb_callname[i] = ' ';
            lpConn->ncbCall.ncb_name[i] = ' ';
        }
        lstrcpy( tmpBuf, nodeName );
        AnsiUpperBuff( tmpBuf, lstrlen(tmpBuf) );
        _fstrncpy( lpConn->ncbCall.ncb_callname, tmpBuf, lstrlen(tmpBuf) );

        lstrcpy( tmpBuf, ourNodeName );
        _fstrncpy( lpConn->ncbCall.ncb_name, tmpBuf, lstrlen(tmpBuf) );
        lpConn->ncbCall.ncb_callname[15] = NETBIOS_SPECIAL;
        lpConn->ncbCall.ncb_name[15] = NETBIOS_SPECIAL;
        lpConn->ncbCall.ncb_rto = 0;
        lpConn->ncbCall.ncb_sto = 0;
        lpConn->current_lananum = last_good_lana;
        lpConn->lananum_count = 0;
        lpConn->lananum = lananum[last_good_lana];
        lpConn->ncbCall.ncb_lana_num = lpConn->lananum;
        if( bUseNetbiosPost )  {
            lpConn->ncbCall.ncb_post = NetbiosPost;
        }
        Netbios( &lpConn->ncbCall );
    }
    return( connId );
}




VOID
NDDEDeleteConnection( CONNID connId )
{
    if( connId )  {
        DoDisconnect( connId );
        FreeConnId( connId );
    }
}




VOID
FAR PASCAL
DoDisconnect( CONNID connId )
{
    LPCONN      lpConn;

    DIPRINTF(( "DoDisconnect" ));

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        if( lpConn->sessionLsn > 0 )  {
            if( lpConn->wRcvState == RS_RECVING )  {
                CancelNCB( lpConn->lananum, &lpConn->ncbRecv );
                lpConn->wRcvState = RS_IDLE;
            }
            if( lpConn->wXmtState == SS_XMITING )  {
                CancelNCB( lpConn->lananum, &lpConn->ncbSend );
                lpConn->wXmtState = SS_IDLE;
            }
            HangUpSession( lpConn->lananum, lpConn->sessionLsn );
            lpConn->sessionLsn = 0;
        }
        lpConn->state &= ~NDDE_CONN_STATUS_MASK;
    }
}




DWORD
NDDEGetConnectionStatus( CONNID connId )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        return( lpConn->state );
    } else {
        return( 0 );
    }
}




BOOL
NDDERcvPacket(
    CONNID  connId,
    LPVOID  lpRcvBuf,
    LPWORD  lpwLen,
    LPWORD  lpwPktStatus )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn
        && (lpConn->state & NDDE_CONN_OK)
        && (lpConn->state & NDDE_CALL_RCV_PKT) )  {

        *lpwLen         = lpConn->wLastPktSize;
        *lpwPktStatus   = lpConn->wLastPktStatus;
        _fmemcpy( lpRcvBuf, lpConn->lpRcvBuf, lpConn->wLastPktSize );

        /* get ready to receive another pkt */
        SetupReceive( lpConn );

        lpConn->state &= ~NDDE_CALL_RCV_PKT;
        return( TRUE );
    } else {
        return( FALSE );
    }
}




VOID
FAR PASCAL
SetupReceive( LPCONN lpConn )
{
    _fmemset( (LPSTR)&lpConn->ncbRecv, 0, sizeof(NCB) );
    lpConn->ncbRecv.ncb_command = NCBRECV | ASYNCH;
    lpConn->ncbRecv.ncb_lsn = lpConn->sessionLsn;
    lpConn->ncbRecv.ncb_buffer = lpConn->lpRcvBuf;
    lpConn->ncbRecv.ncb_length = (WORD)lpConn->wPktSize;
    if( bUseNetbiosPost )  {
        lpConn->ncbRecv.ncb_post = NetbiosPost;
    }
    lpConn->ncbRecv.ncb_lana_num = lpConn->lananum;
    Netbios( &lpConn->ncbRecv );
    lpConn->wRcvState = RS_RECVING;
}



BOOL
NDDEXmtPacket(
    CONNID  connId,
    LPVOID  lpXmtBuf,
    WORD    wPktLen )
{
    LPCONN      lpConn;
    LPNETPKT    lpPacket;

    lpConn = (LPCONN) connId;
    if( lpConn
        && (lpConn->state & NDDE_CONN_OK)
        && (lpConn->state & NDDE_READY_TO_XMT)
        && (lpConn->wXmtState == SS_IDLE) )  {

        /* copy contents in */
        _fmemcpy( lpConn->lpXmtBuf, lpXmtBuf, wPktLen );
        lpPacket = (LPNETPKT) lpConn->lpXmtBuf;
        lpPacket->np_pktSize = wPktLen - sizeof(NETPKT);

        PreparePktVerify( lpConn->bXmtVerifyMethod, lpPacket );

        _fmemset( (LPSTR)&lpConn->ncbSend, 0, sizeof(NCB) );
        lpConn->ncbSend.ncb_command      = NCBSEND | ASYNCH;
        lpConn->ncbSend.ncb_lsn          = lpConn->sessionLsn;
        lpConn->ncbSend.ncb_buffer   = (LPSTR)lpConn->lpXmtBuf;
        lpConn->ncbSend.ncb_length       =
            lpPacket->np_pktSize + sizeof(NETPKT);
        if( bUseNetbiosPost )  {
            lpConn->ncbSend.ncb_post = NetbiosPost;
        }
        lpConn->ncbSend.ncb_lana_num = lpConn->lananum;
        lpConn->state &= ~NDDE_READY_TO_XMT;
        lpConn->wXmtState = SS_XMITING;

        Netbios( &lpConn->ncbSend );
        return( TRUE );
    }
    return( FALSE );
}

#if DBG
VOID DumpNCB(PNCB n)
{
    DPRINTF(("NCB Cmd: %02X, RetCode: %02X, Lsn: %02X, Num: %02X",
        n->ncb_command, n->ncb_retcode, n->ncb_lsn, n->ncb_num));
    DPRINTF(("BufAddr: %08lX, Length: %d, CallName: %Fs, Name: %Fs",
        n->ncb_buffer, n->ncb_length, n->ncb_callname, n->ncb_name));
    DPRINTF(("Rto: %02X, Sto: %02X, PostAddr: %08lX, LanNum: %02X, CmdCplt: %02X",
        n->ncb_rto, n->ncb_sto, n->ncb_post, n->ncb_lana_num, n->ncb_cmd_cplt));
}
#endif  //DBG
VOID
LogDebugInfo(
    CONNID  connId,
    DWORD   dwFlags )
{
#if DBG
    LPCONN      lpConn;

    if( connId )  {
        lpConn = (LPCONN) connId;
        DPRINTF(( "\"%-16.16Fs\" session: %02X state:%08lX rcvState:%04X xmtState:%04X",
            (LPSTR)lpConn->nodeName, lpConn->sessionLsn, lpConn->state,
            lpConn->wRcvState, lpConn->wXmtState ));
        if (lpConn->wRcvState != RS_IDLE) {
            DPRINTF(( "Receiving NCB"));
            DumpNCB((PNCB)&lpConn->ncbRecv);
        }
        if (lpConn->wXmtState != SS_IDLE) {
            DPRINTF(( "Transmitting NCB"));
            DumpNCB((PNCB)&lpConn->ncbSend);
        }
    } else {
        DPRINTF(( "NetBIOS State ..." ));
        lpConn = lpConnHead;
        while( lpConn )  {
            LogDebugInfo( (CONNID) lpConn, dwFlags );
            lpConn = lpConn->next;
        }
        DPRINTF(( "" ));
    }
#endif  //DBG
}




BOOL
NDDESetConnectionConfig(
    CONNID  connId,
    WORD    wMaxUnAckPkts,
    WORD    wPktSize,
    LPSTR   lpszName )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        lpConn->wPktSize = wPktSize;
        lpConn->wMaxUnAckPkts = wMaxUnAckPkts;
        _fstrncpy( lpConn->nodeName, lpszName, sizeof(lpConn->nodeName) );
    }
    return( TRUE );
}




BOOL
NDDEGetConnectionConfig(
    CONNID      connId,
    WORD FAR   *lpwMaxUnAckPkts,
    WORD FAR   *lpwPktSize,
    DWORD FAR  *lptimeoutRcvConnCmd,
    DWORD FAR  *lptimeoutRcvConnRsp,
    DWORD FAR  *lptimeoutMemoryPause,
    DWORD FAR  *lptimeoutKeepAlive,
    DWORD FAR  *lptimeoutXmtStuck,
    DWORD FAR  *lptimeoutSendRsp,
    WORD FAR   *lpwMaxNoResponse,
    WORD FAR   *lpwMaxXmtErr,
    WORD FAR   *lpwMaxMemErr )
{
    LPCONN      lpConn;

    lpConn = (LPCONN) connId;
    if( lpConn )  {
        *lpwPktSize = lpConn->wPktSize;
        *lpwMaxUnAckPkts = lpConn->wMaxUnAckPkts;
    } else {
        *lpwPktSize = dflt_pktsize;
        *lpwMaxUnAckPkts = dflt_maxunack;
    }
    *lptimeoutRcvConnCmd        = dflt_timeoutRcvConnCmd;
    *lptimeoutRcvConnRsp        = dflt_timeoutRcvConnRsp;
    *lptimeoutMemoryPause       = dflt_timeoutMemoryPause;
    *lptimeoutKeepAlive         = dflt_timeoutKeepAlive;
    *lptimeoutXmtStuck          = dflt_timeoutXmtStuck;
    *lptimeoutSendRsp           = dflt_timeoutSendRsp;
    *lpwMaxNoResponse           = dflt_maxNoResponse;
    *lpwMaxXmtErr               = dflt_maxXmtErr;
    *lpwMaxMemErr               = dflt_maxMemErr;

    return( TRUE );
}




BOOL
FAR PASCAL
AllocateBuffers( LPCONN lpConn )
{
    /* shouldn't be in the middle of stuff */
    assert( lpConn->wRcvState == RS_IDLE );
    assert( lpConn->wXmtState == SS_IDLE );

    /* get rid of old buffers */
    FreeBuffers( lpConn );

    lpConn->lpXmtBuf = HeapAllocPtr( hHeap, GMEM_MOVEABLE, lpConn->wPktSize );
    lpConn->lpRcvBuf = HeapAllocPtr( hHeap, GMEM_MOVEABLE, lpConn->wPktSize );
    if( lpConn->lpXmtBuf && lpConn->lpRcvBuf )  {
        lpConn->wXmtState       = SS_IDLE;
        lpConn->wRcvState       = RS_IDLE;
        return( TRUE );
    } else {
        return( FALSE );
    }
}

VOID
FAR PASCAL
FreeBuffers( LPCONN lpConn )
{
    if( lpConn->lpXmtBuf )  {
        HeapFreePtr( lpConn->lpXmtBuf );
        lpConn->lpXmtBuf = NULL;
    }
    if( lpConn->lpRcvBuf )  {
        HeapFreePtr( lpConn->lpRcvBuf );
        lpConn->lpRcvBuf = NULL;
    }
}

VOID
FAR PASCAL
HangUpSession(
    BYTE    lananum,
    BYTE    sessionLsn )
{
    DIPRINTF(( "Hanging up session %d", sessionLsn ));
    _fmemset( (LPSTR)&ncbHangup, 0, sizeof(NCB) );
    ncbHangup.ncb_command = NCBHANGUP;
    ncbHangup.ncb_lsn = sessionLsn;
    ncbHangup.ncb_lana_num = lananum;
    Netbios( &ncbHangup );
}

VOID
FAR PASCAL
CancelNCB(
    BYTE    lananum,
    PNCB   lpNCBToCancel )
{
    PNCB       lpNCB;

    lpNCB = &ncbCancel;
    _fmemset( (LPSTR)lpNCB, 0, sizeof(NCB) );
    lpNCB->ncb_command = NCBCANCEL;
    lpNCB->ncb_buffer = (LPSTR) lpNCBToCancel;
    lpNCB->ncb_lana_num = lananum;
    Netbios( lpNCB );
}

BYTE
FAR PASCAL
NetbiosDeleteName(
    BYTE    lananum,
    LPSTR   lpszName )
{
    int                         i;

    _fmemset( (LPSTR)&ncbDeleteName, 0, sizeof(ncbDeleteName) );
    ncbDeleteName.ncb_command = NCBDELNAME;
    for( i = 0; i < NCBNAMSZ; i++ )  {
        ncbDeleteName.ncb_callname[i] = ' ';
        ncbDeleteName.ncb_name[i] = ' ';
    }
    strncpy( ncbDeleteName.ncb_name, ourNodeName, lstrlen(ourNodeName) );
    ncbDeleteName.ncb_name[15] = NETBIOS_SPECIAL;
    ncbDeleteName.ncb_lana_num = lananum;
    Netbios( &ncbDeleteName );
    return( ncbDeleteName.ncb_retcode );
}




LPSTR
FAR PASCAL
NetbiosErrorMsg( BYTE errCode )
{
    static      char    msg[ 100 ];
    PSTR        pMsg;
    int         id;

    wsprintf( msg, "%02X: ", errCode );
    pMsg = &msg[ lstrlen(msg) ];
    switch( errCode ) {
    case NRC_BUFLEN:
        id = NBE_NRC_BUFLEN;
        break;
//    case 0x02:
//        id = NBE_FULL_BUFFERS;
//        break;
    case NRC_ILLCMD:
        id = NBE_NRC_ILLCMD;
        break;
    case NRC_CMDTMO:
        id = NBE_NRC_CMDTMO;
        break;
    case NRC_INCOMP:
        id = NBE_NRC_INCOMP;
        break;
    case NRC_BADDR:
        id = NBE_NRC_BADDR;
        break;
    case NRC_SNUMOUT:
        id = NBE_NRC_SNUMOUT;
        break;
    case NRC_NORES:
        id = NBE_NRC_NORES;
        break;
    case NRC_SCLOSED:
        id = NBE_NRC_SCLOSED;
        break;
    case NRC_CMDCAN:
        id = NBE_NRC_CMDCAN;
        break;
//    case 0x0C:
//        id = NBE_PCDMA_FAILED;
//        break;
    case NRC_DUPNAME:
        id = NBE_NRC_DUPNAME;
        break;
    case NRC_NAMTFUL:
        id = NBE_NRC_NAMTFUL;
        break;
    case NRC_ACTSES:
        id = NBE_NRC_ACTSES;
        break;
//    case 0x10:
//        id = NBE_NRC_NOWILD;
//        break;
    case NRC_LOCTFUL:
        id = NBE_NRC_LOCTFUL;
        break;
    case NRC_REMTFUL:
        id = NBE_NRC_REMTFUL;
        break;
    case NRC_ILLNN:
        id = NBE_NRC_ILLNN;
        break;
    case NRC_NOCALL:
        id = NBE_NRC_NOCALL;
        break;
    case NRC_NOWILD:
        id = NBE_NRC_NOWILD;
        break;
    case NRC_INUSE:
        id = NBE_NRC_INUSE;
        break;
    case NRC_NAMERR:
        id = NBE_NRC_NAMERR;
        break;
    case NRC_SABORT:
        id = NBE_NRC_SABORT;
        break;
    case NRC_NAMCONF:
        id = NBE_NRC_NAMCONF;
        break;
//    case 0x1A:
//        id = NBE_INCOMPAT_REMOTE_DEV;
//        break;
    case NRC_IFBUSY:
        id = NBE_NRC_IFBUSY;
        break;
    case NRC_TOOMANY:
        id = NBE_NRC_TOOMANY;
        break;
    case NRC_BRIDGE:
        id = NBE_NRC_BRIDGE;
        break;
    case NRC_CANOCCR:
        id = NBE_NRC_CANOCCR;
        break;
//    case 0x25:
//        id = NBE_RESERVED_NAME;
//        break;
    case NRC_CANCEL:
        id = NBE_NRC_CANCEL;
        break;
    case NRC_DUPENV:
        id = NBE_NRC_DUPENV;
        break;
//    case 0x33:
//        id = NBE_MULT_REQ_FOR_SAME_SESSION;
//        break;
    case NRC_ENVNOTDEF:
        id = NBE_NRC_ENVNOTDEF;
        break;
    case NRC_OSRESNOTAV:
        id = NBE_NRC_OSRESNOTAV;
        break;
    case NRC_MAXAPPS:
        id = NBE_NRC_MAXAPPS;
        break;
    case NRC_NOSAPS:
        id = NBE_NRC_NOSAPS;
        break;
    case NRC_NORESOURCES:
        id = NBE_NRC_NORESOURCES;
        break;
    case NRC_INVADDRESS:
        id = NBE_NRC_INVADDRESS;
        break;
    case NRC_INVDDID:
        id = NBE_NRC_INVDDID;
        break;
    case NRC_LOCKFAIL:
        id = NBE_NRC_LOCKFAIL;
        break;
    case NRC_OPENERR:
        id = NBE_NRC_OPENERR;
        break;
    case NRC_SYSTEM:
        id = NBE_NRC_SYSTEM;
        break;
//    case 0x41:
//        id = NBE_HOT_CARRIER_REMOTE;
//        break;
//    case 0x42:
//        id = NBE_HOT_CARRIER_LOCAL;
//        break;
//    case 0x43:
//        id = NBE_NO_CARRIER;
//        break;
//    case 0x45:
//        id = NBE_INTERFACE_FAILURE;
//        break;
//    case 0x4E:
//        id = NBE_BITS_ON_TOO_LONG;
//        break;
//    case 0x4F:
//        id = NBE_BITS_ON;
//        break;
//    case 0x50:
//        id = NBE_ADAPTER_FAILED;
//        break;
//    case 0xF7:
//        id = NBE_DIR_INITIALIZE_ERROR;
//        break;
//    case 0xF8:
//        id = NBE_DIR_OPEN_ADAPTER_ERROR;
//        break;
//    case 0xF9:
//        id = NBE_IBM_LAN_INTERNAL_ERROR;
//        break;
//    case 0xFA:
//        id = NBE_NETBIOS_CARD_ERROR;
//        break;
//    case 0xFB:
//        id = NBE_NRC_OPENERR;
//        break;
//    case 0xFC:
//        id = NBE_SAP_FAILED;
//        break;
//    case 0xFD:
//        id = NBE_UNEXPECTED_ADAPTER_CLOSE;
//        break;
    default:
        if( (errCode >= 0x50) && (errCode <= 0xF6) )  {
            id =  NBE_HARDWARE_ERROR;
        } else {
            id =  NBE_UNKNOWN_ERROR;
        }
        break;
    }
    LoadString(hInst, id, pMsg, sizeof(msg) - lstrlen(msg));
    return( msg );
}


#ifdef HASUI

VOID
Configure( void )
{
    int     result;

    result = DialogBox( hInst, "CONFIGURE",
        GetFocus(), (DLGPROC)ConfigureDlgProc );
    if( result < 0 )  {
        MessageBox( NULL, "Not enough memory for dialog box",
            GetAppName(), MB_TASKMODAL | MB_OK );
    }
}

VOID
InitDlg(HWND hDlg)
{
    CheckDlgButton( hDlg, CI_LOG_ALL, bLogAll );
    CheckDlgButton( hDlg, CI_LOG_UNUSUAL,  bLogAll ? FALSE : bLogUnusual );
    CheckDlgButton( hDlg, CI_LOG_NONE,
        (bLogAll || bLogUnusual) ? FALSE : TRUE);

    PutIntg( hDlg, CI_MAX_UNACK_PKTS, dflt_maxunack );
    PutIntg( hDlg, CI_RCV_CONN_CMD, dflt_timeoutRcvConnCmd / 1000L );
    PutIntg( hDlg, CI_RCV_CONN_RSP, dflt_timeoutRcvConnRsp / 1000L );
    PutIntg( hDlg, CI_MEMORY_PAUSE, dflt_timeoutMemoryPause / 1000L );
    PutIntg( hDlg, CI_KEEP_ALIVE, dflt_timeoutKeepAlive / 1000L );
    PutIntg( hDlg, CI_XMT_STUCK, dflt_timeoutXmtStuck / 1000L );
    PutIntg( hDlg, CI_NO_RESPONSE, dflt_timeoutSendRsp / 1000L );
    PutIntg( hDlg, CI_RETRY_LIMIT_XMIT_ERR, dflt_maxXmtErr );
    PutIntg( hDlg, CI_RETRY_LIMIT_MEM_ERR, dflt_maxMemErr );
    PutIntg( hDlg, CI_RETRY_LIMIT_RSP_ERR, dflt_maxNoResponse );

    SendDlgItemMessage( hDlg, CI_PACKET_SIZE,
        EM_SETSEL, 0, MAKELONG(0,32767) );
    SetFocus( GetDlgItem( hDlg, CI_LOG_UNUSUAL ) );
}

VOID
RestoreDlg(void)
{
    dflt_vermeth            = VERMETH_CKS32;
    dflt_maxunack           = 10;
    dflt_timeoutRcvConnCmd  = 60000;
    dflt_timeoutRcvConnRsp  = 60000;
    dflt_timeoutMemoryPause = 10000;
    dflt_timeoutKeepAlive   = 60000;
    dflt_timeoutXmtStuck    = 120000;
    dflt_timeoutSendRsp     = 60000;
    dflt_maxNoResponse      = 3;
    dflt_maxXmtErr          = 3;
    dflt_maxMemErr          = 3;
    bLogAll                 = FALSE;
    bLogUnusual             = TRUE;
}

static  INTG    tmp_dflt_maxunack;
static  INTG    tmp_dflt_timeoutRcvConnCmd;
static  INTG    tmp_dflt_timeoutRcvConnRsp;
static  INTG    tmp_dflt_timeoutMemoryPause;
static  INTG    tmp_dflt_timeoutKeepAlive;
static  INTG    tmp_dflt_timeoutXmtStuck;
static  INTG    tmp_dflt_timeoutSendRsp;
static  INTG    tmp_dflt_maxNoResponse;
static  INTG    tmp_dflt_maxXmtErr;
static  INTG    tmp_dflt_maxMemErr;
static  char    dllName[ 20 ];

BOOL
FAR PASCAL
ConfigureDlgProc(
    HWND        hDlg,           /* window handle of the dialog box      */
    unsigned    message,        /* type of message                      */
    WORD        wParam,         /* message-specific information         */
    LONG        lParam )
{
    BOOL        ok;
    BOOL        bChg;

    switch( message ) {
        case WM_INITDIALOG:             /* message: initialize dialog box       */
            CenterDlg(hDlg);
            SetDlgItemText(hDlg, CI_VERSION, GetString(VERS_NETBIOS));
                EnableWindow( GetDlgItem( hDlg, CI_VERSION ), 0 );
            InitDlg(hDlg);
                return FALSE;

        case WM_COMMAND:                /* message: received a command          */
            switch( wParam )  {
                case CI_HELP:
                    WinHelp( hDlg, szHelpFileName, HELP_INDEX, 0L );
                    break;
                case CI_RESTORE :
                    RestoreDlg();
                    InitDlg(hDlg);
                    break;

        case IDOK:
            ok = TRUE;
            bChg = FALSE;
            lstrcpy( dllName, "NetBIOS" );
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_MAX_UNACK_PKTS,
                    &tmp_dflt_maxunack, 1, 100 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_RCV_CONN_CMD,
                    &tmp_dflt_timeoutRcvConnCmd, 1, 36000 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_RCV_CONN_RSP,
                    &tmp_dflt_timeoutRcvConnRsp, 1, 36000 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_MEMORY_PAUSE,
                    &tmp_dflt_timeoutMemoryPause, 1, 36000 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_KEEP_ALIVE,
                    &tmp_dflt_timeoutKeepAlive, 0, 36000 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_XMT_STUCK,
                    &tmp_dflt_timeoutXmtStuck, 0, 36000 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_NO_RESPONSE,
                    &tmp_dflt_timeoutSendRsp, 1, 36000 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_RETRY_LIMIT_XMIT_ERR,
                    &tmp_dflt_maxXmtErr, 0, 100 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_RETRY_LIMIT_MEM_ERR,
                    &tmp_dflt_maxMemErr, 0, 100 );
            }
            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_RETRY_LIMIT_RSP_ERR,
                    &tmp_dflt_maxNoResponse, 0, 100 );
            }
            if( ok )  {
                if( IsDlgButtonChecked( hDlg, CI_LOG_ALL ) )  {
                    if( !bLogAll || !bLogUnusual )  {
                        MyWritePrivateProfileInt( dllName,
                            "LogAll", TRUE, szNetddeIni );
                        MyWritePrivateProfileInt( dllName,
                            "LogUnusual", TRUE, szNetddeIni );
                        bLogAll = TRUE;
                        bLogUnusual = TRUE;
                    }
                } else if( IsDlgButtonChecked( hDlg, CI_LOG_UNUSUAL ) )  {
                    if( bLogAll || !bLogUnusual )  {
                        MyWritePrivateProfileInt( dllName,
                            "LogAll", FALSE, szNetddeIni );
                        MyWritePrivateProfileInt( dllName,
                            "LogUnusual", TRUE, szNetddeIni );
                        bLogAll = FALSE;
                        bLogUnusual = TRUE;
                    }
                } else {
                    if( bLogAll || bLogUnusual )  {
                        MyWritePrivateProfileInt( dllName,
                            "LogAll", FALSE, szNetddeIni );
                        MyWritePrivateProfileInt( dllName,
                            "LogUnusual", FALSE, szNetddeIni );
                        bLogAll = FALSE;
                        bLogUnusual = FALSE;
                    }
                }
            }
            if( ok )  {
                if( dflt_maxunack != (WORD)tmp_dflt_maxunack )  {
                    MyWritePrivateProfileInt( dllName, "Maxunack",
                        (int)tmp_dflt_maxunack, szNetddeIni );
                    dflt_maxunack = (int)tmp_dflt_maxunack;
                    bChg = TRUE;
                }
                if( dflt_timeoutRcvConnCmd !=
                        (DWORD)(tmp_dflt_timeoutRcvConnCmd*1000L) )  {
                    WritePrivateProfileLong( dllName, "TimeoutRcvConnCmd",
                        tmp_dflt_timeoutRcvConnCmd * 1000L, szNetddeIni );
                    dflt_timeoutRcvConnCmd =
                        tmp_dflt_timeoutRcvConnCmd * 1000L;
                    bChg = TRUE;
                }
                if( dflt_timeoutRcvConnRsp !=
                        (DWORD)(tmp_dflt_timeoutRcvConnRsp*1000L) )  {
                    WritePrivateProfileLong( dllName, "TimeoutRcvConnRsp",
                        tmp_dflt_timeoutRcvConnRsp * 1000L, szNetddeIni );
                    dflt_timeoutRcvConnRsp =
                        tmp_dflt_timeoutRcvConnRsp * 1000L;
                    bChg = TRUE;
                }
                if( dflt_timeoutMemoryPause !=
                        (DWORD)(tmp_dflt_timeoutMemoryPause*1000L) )  {
                    WritePrivateProfileLong( dllName, "TimeoutMemoryPause",
                        tmp_dflt_timeoutMemoryPause * 1000L, szNetddeIni );
                    dflt_timeoutMemoryPause =
                        tmp_dflt_timeoutMemoryPause * 1000L;
                    bChg = TRUE;
                }
                if( dflt_timeoutKeepAlive !=
                        (DWORD)(tmp_dflt_timeoutKeepAlive*1000L) )  {
                    WritePrivateProfileLong( dllName, "TimeoutKeepAlive",
                        tmp_dflt_timeoutKeepAlive * 1000L, szNetddeIni );
                    dflt_timeoutKeepAlive =
                        tmp_dflt_timeoutKeepAlive * 1000L;
                    bChg = TRUE;
                }
                if( dflt_timeoutXmtStuck !=
                        (DWORD)(tmp_dflt_timeoutXmtStuck*1000L) )  {
                    WritePrivateProfileLong( dllName, "TimeoutXmtStuck",
                        tmp_dflt_timeoutXmtStuck * 1000L, szNetddeIni );
                    dflt_timeoutXmtStuck =
                        tmp_dflt_timeoutXmtStuck * 1000L;
                    bChg = TRUE;
                }
                if( dflt_timeoutSendRsp !=
                        (DWORD)(tmp_dflt_timeoutSendRsp*1000L) )  {
                    WritePrivateProfileLong( dllName, "TimeoutSendRsp",
                        tmp_dflt_timeoutSendRsp * 1000L, szNetddeIni );
                    dflt_timeoutSendRsp =
                        tmp_dflt_timeoutSendRsp * 1000L;
                    bChg = TRUE;
                }
                if( dflt_maxNoResponse != (WORD)tmp_dflt_maxNoResponse )  {
                    MyWritePrivateProfileInt( dllName, "MaxNoResponse",
                        (int)tmp_dflt_maxNoResponse, szNetddeIni );
                    dflt_maxNoResponse = (WORD)tmp_dflt_maxNoResponse;
                    bChg = TRUE;
                }
                if( dflt_maxXmtErr != (WORD)tmp_dflt_maxXmtErr )  {
                    MyWritePrivateProfileInt( dllName, "MaxXmtErr",
                        (int)tmp_dflt_maxXmtErr, szNetddeIni );
                    dflt_maxXmtErr = (WORD)tmp_dflt_maxXmtErr;
                    bChg = TRUE;
                }
                if( dflt_maxMemErr != (WORD)tmp_dflt_maxMemErr )  {
                    MyWritePrivateProfileInt( dllName, "MaxMemErr",
                        (int)tmp_dflt_maxMemErr, szNetddeIni );
                    dflt_maxMemErr = (WORD)tmp_dflt_maxMemErr;
                    bChg = TRUE;
                }
                if( bChg )  {
                    MessageBox( NULL,
                        "Changes take effect for future conversations",
                        GetAppName(),
                        MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OK );
                }
                WinHelp( hDlg, szHelpFileName, HELP_QUIT, 0L );
                EndDialog( hDlg, TRUE );
            }
            break;
        case IDCANCEL:
            WinHelp( hDlg, szHelpFileName, HELP_QUIT, 0L );
            EndDialog(hDlg, FALSE);
            break;
        }
        break;
    }
    return( FALSE );            /* Didn't process a message             */
}

/****************************************************************************

   FUNCTION:   MakeHelpPathName

   PURPOSE:    Assumes that the .HLP help file is in the same
               directory as the .exe executable.  This function derives
               the full path name of the help file from the path of the
               executable.

****************************************************************************/

VOID
FAR PASCAL
MakeHelpPathName(
    char   *szFileName,
    int     nMax )
{
   char    *pcFileName;
   int      nFileNameLen;

   nFileNameLen = GetModuleFileName( hInst, szFileName, nMax );
   pcFileName = szFileName + nFileNameLen;

   while (pcFileName > szFileName) {
       if( (*pcFileName == '\\') || (*pcFileName == ':') ) {
           *(++pcFileName) = '\0';
           break;
       }
       nFileNameLen--;
       pcFileName--;
   }

   if( (nFileNameLen+13) < nMax ) {
       lstrcat( szFileName, "netbios.hlp" );
   } else {
       lstrcat( szFileName, "?" );
   }
}
#endif // HASUI

VOID
FAR PASCAL
NetBIOSPostMsg(
    PNCB    lpNCB,
    int      nCompletionCode )
{
    /* THIS IS AT INTERRUPT LEVEL ... no Windows API CALLS! */

    /* tell NetDDE that we're done */
    PostMessage( NB_hWndNetdde, WM_TIMER, 0, 0L );
}


VOID
NetbiosPost( PNCB lpNCB )
{
    /* tell NetDDE that we're done */
    PostMessage( NB_hWndNetdde, WM_TIMER, 0, 0L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\client\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt
IDL_NAME = ndeapi
INCS     = -I$(SDK_INC_PATH)  -I$(SDK_INC_PATH)\crt
EXTRN_DEPENDS = $(SDK_INC_PATH)\windef.h \
                ..\$(IDL_NAME).acf
CPP_FLAGS = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

$(O)\$(IDL_NAME)_c.c : ..\$(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -Oicf -robust -server none -oldnames -error all -ms_ext -c_ext $(CPP_FLAGS) ..\$(IDL_NAME).idl $(INCS) /out $(O) /acf ..\$(IDL_NAME).acf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nddenb32\dllmain.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DLLMAIN.C;1  16-Dec-92,10:14:24  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#define NOCOMM
#define LINT_ARGS
// #include	<string.h>
#include	"windows.h"
#include	"hardware.h"
#include	"wwassert.h"
#include	"tmpbufc.h"
#include	"getglobl.h"

USES_ASSERT

HANDLE	hInst;

int FAR PASCAL WEP (int bSystemExit);
#ifndef WIN32
int FAR PASCAL LibMain( HANDLE hInstance, WORD wDataSeg,
			WORD wHeapSize, LPSTR lpszCmdLine );
#endif

#ifdef PROFILING
#include "profiler.h"
#endif

#ifdef WIN32
INT  APIENTRY LibMain(HANDLE hInstance, DWORD ul_reason_being_called, LPVOID lpReserved)
{
    hInst = hInstance;
    return 1;
	UNREFERENCED_PARAMETER(hInstance);
	UNREFERENCED_PARAMETER(ul_reason_being_called);
	UNREFERENCED_PARAMETER(lpReserved);
}
#else
unsigned char _osmajor;

int
FAR PASCAL
LibMain( hInstance, wDataSeg, wHeapSize, lpszCmdLine )
HANDLE		hInstance;
WORD		wDataSeg;
WORD		wHeapSize;
LPSTR		lpszCmdLine;
{
    int		rtn;

    _osmajor = 3;

    rtn   = 0;
    hInst = hInstance;
    if( wHeapSize != 0 )  {
	rtn = LocalInit( wDataSeg, NULL, wHeapSize );
    }

    /* extra lock on DS to prevent moving by indirect calls to malloc() */
    LockData(0);

#ifdef PROFILING
    TraceInit( hInstance );
#endif

    return( rtn );
}

/****************************************************************************
    FUNCTION:  WEP(int)

    PURPOSE:  Performs cleanup tasks when the DLL is unloaded.  WEP() is
              called automatically by Windows when the DLL is unloaded
              (no remaining tasks still have the DLL loaded).  It is
              strongly recommended that a DLL have a WEP() function,
              even if it does nothing but return, as in this example.

*******************************************************************************/
int FAR PASCAL WEP (bSystemExit)
int  bSystemExit;
{
    return( 1 );
}
#endif

HANDLE
FAR PASCAL GetGlobalAlloc( WORD wFlags, DWORD dwSize )
{
    // allocate memory as fixed to avoid NCBs and NetBIOS recv/xmit buffers
    //  from moving
    return(GlobalAlloc( GMEM_FIXED | (wFlags & ~GMEM_MOVEABLE), dwSize ));
}

PSTR
FAR PASCAL GetAppName(void)
{
    return( "NetBIOS" );
}

BOOL
FAR PASCAL
ProtGetDriverName( LPSTR lpszName, int nMaxLength )
{
    lstrcpy( lpszName, "NETBIOS" );
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\client\nddeapic.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    NDDEAPIC.C -

    Network DDE Api implementation routines - Client side

    Revisions:
     7-92   clausgi created for WFW
    12-92   BillU.  Wonderware secure DSDM port.
    12-92   ColeC.  Wonderware RPC'd for NT..
     3-93   IgorM.  Wonderware new APIs for NT and SD massaging.

   $History: End */

#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <memory.h>

#include "nddeapi.h"
#include "nddesec.h"
#include "debug.h"
#include "ndeapi.h"
#include "unddesi.h"
#include "mbstring.h"

//#define NDDE_DEBUG

char    tmpBuf [500];

// dll instance saved in libmain
HINSTANCE          hInst;

wchar_t  * pszUuid                          = NULL;
wchar_t  * pszProtocolSequence              = L"ncacn_np";
wchar_t    szNetworkAddress[UNCLEN+1];
wchar_t  * szEndpoint                       = L"\\pipe\\nddeapi";
wchar_t  * pszOptions                       = L"security=impersonation static true";
wchar_t  * pszStringBinding                 = NULL;


RPC_STATUS NDdeApiBindA( LPSTR  pszNetworkAddress );
RPC_STATUS NDdeApiBindW( LPWSTR pszNetworkAddress );
RPC_STATUS NDdeApiUnbind( void );

int LengthMultiSzA( LPSTR pMz );
int LengthMultiSzW( LPWSTR pMz );
int LengthAppTopicListA( LPSTR pMz );
int LengthAppTopicListW( LPWSTR pMz );


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Validation functions
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// this one needs to be exported for clipbook(clausgi 8/4/92)
BOOL WINAPI NDdeIsValidShareNameA ( LPSTR shareName )
{
    if ( !shareName ) {
        return FALSE;
    }

    if ( strlen(shareName) < 1 || strlen(shareName) > MAX_NDDESHARENAME ) {
        return FALSE;
    }

    // share name cannot contain '=' or '\' because of registry and .ini syntax!

    if (GetSystemMetrics(SM_DBCSENABLED)) {
        if (_mbschr(shareName, '=') || _mbschr(shareName, '\\'))
            return FALSE;
    } else {
        if (strchr(shareName, '=') || strchr(shareName, '\\'))
            return FALSE;
    }

    return TRUE;
}


// this one needs to be exported for clipbook(clausgi 8/4/92)
BOOL WINAPI NDdeIsValidShareNameW ( LPWSTR shareName )
{
    if ( !shareName ) {
        return FALSE;
    }

    if ( wcslen(shareName) < 1 || wcslen(shareName) > MAX_NDDESHARENAME ) {
        return FALSE;
    }

    // share name cannot contain '=' because of .ini syntax!
    if ( wcschr(shareName, L'=') || wcschr(shareName, L'\\')) {
        return FALSE;
    }

    return TRUE;
}


BOOL NDdeParseAppTopicListA (
    LPSTR appTopicList,
    LPSTR *pOldStr,
    LPSTR *pNewStr,
    LPSTR *pStaticStr,
    PLONG  pShareType )
{
    LPSTR       pStr;
    BOOL        bAnyPresent;
    int         len;
    int         nBarPos;

    /*  There should be three fields separated by NULLs ending with a
        double NULL.  Four NULLs total.  At least one field should
        contain a valid app|topic pair.  No commas are allowed and there
        should be at least one character on each side of the vertical
        bar.
    */

    *pOldStr    = NULL;
    *pNewStr    = NULL;
    *pStaticStr = NULL;
    *pShareType = 0;

    if ( !appTopicList ) {
        return FALSE;
    }

    bAnyPresent = FALSE;
    /*  Check the old style link share. */
    pStr     = appTopicList;
    *pOldStr = pStr;
    len      = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x1;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check the new style link share. */
    pStr     = pStr + strlen(pStr) + 1;
    *pNewStr = pStr;
    len      = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x2;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check the static data share. */
    pStr        = pStr + strlen(pStr) + 1;
    *pStaticStr = pStr;
    len         = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x4;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check for the extra NULL at the end of the AppTopicList. */
    pStr = pStr + strlen(pStr) + 1;
    if( *pStr != '\0' ) {
        return FALSE;
    }

    return bAnyPresent;
}

BOOL WINAPI NDdeIsValidAppTopicListA ( LPSTR appTopicList )
{
    LPSTR pOldStr;
    LPSTR pNewStr;
    LPSTR pStaticStr;
    LONG   lShareType;

    return NDdeParseAppTopicListA( appTopicList, &pOldStr, &pNewStr,
                                   &pStaticStr,  &lShareType );
}

BOOL NDdeParseAppTopicListW (
    LPWSTR appTopicList,
    LPWSTR *pOldStr,
    LPWSTR *pNewStr,
    LPWSTR *pStaticStr,
    PLONG  pShareType )
{
    LPWSTR      pStr;
    BOOL        bAnyPresent;
    int         len;
    int         nBarPos;

    /*  There should be three fields separated by NULLs ending with a
        double NULL.  Four NULLs total.  At least one field should
        contain a valid app|topic pair.  No commas are allowed and there
        should be at least one character on each side of the vertical
        bar.
    */

    *pOldStr    = NULL;
    *pNewStr    = NULL;
    *pStaticStr = NULL;
    *pShareType = 0;

    if ( !appTopicList ) {
        return FALSE;
    }

    bAnyPresent = FALSE;
    /*  Check the old style link share. */
    pStr     = appTopicList;
    *pOldStr = pStr;
    len      = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x1;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the new style link share. */
    pStr     = pStr + wcslen(pStr) + 1;
    *pNewStr = pStr;
    len      = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x2;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the static data share. */
    pStr        = pStr + wcslen(pStr) + 1;
    *pStaticStr = pStr;
    len         = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= 0x4;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check for the extra NULL at the end of the AppTopicList. */
    pStr = pStr + wcslen(pStr) + 1;
    if( *pStr != L'\0' ) {
        return FALSE;
    }

    return bAnyPresent;
}

BOOL ValidateItemName ( LPWSTR itemName )
{
    if ( !itemName ) {
        return FALSE;
    }

    if ( wcslen(itemName) > MAX_ITEMNAME ) {
        return FALSE;
    }

    if ( wcschr ( itemName, SEP_CHAR ) ) {
        return FALSE;
    }

    return TRUE;
}

BOOL WINAPI NDdeIsValidAppTopicListW ( LPWSTR appTopicList )
{
    LPWSTR pOldStr;
    LPWSTR pNewStr;
    LPWSTR pStaticStr;
    LONG   lShareType;

    return NDdeParseAppTopicListW( appTopicList, &pOldStr, &pNewStr,
                                   &pStaticStr,  &lShareType );
}

DWORD PtrToOffset( LPVOID field, LPVOID base ) {

    if( field == NULL ) {
        return 0;
    } else {
        return (DWORD)((LPBYTE)field - (LPBYTE)base);
    }
}

LPVOID OffsetToPtr( LPVOID base, DWORD offset ) {

    if( offset == 0 ) {
        return NULL;
    } else {
        return (LPVOID)((LPBYTE)base + offset);
    }
}


/*
    Covert DDE Share Info to Unicode and back
*/
int
ConvertNDdeToAnsii(
    PUNDDESHAREINFO lpUDdeShare,
    PNDDESHAREINFO  lpDdeShare,
    int             ccbBuffer )
{
    int         cbRequired;
    LPWSTR      pStr;
    LPBYTE      lpszTarget;
    int         cchAppTopicList, nAppTopicStart;
    int         cchShareName;
    int         cchItemList;

    /* Compute size required. */
    cbRequired    = sizeof( NDDESHAREINFO );
    cchShareName  = WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                    lpUDdeShare->lpszShareName, -1, NULL, 0, NULL, NULL );
    cbRequired   += sizeof(CHAR) * cchShareName;

    pStr = lpUDdeShare->lpszAppTopicList;
    nAppTopicStart = cbRequired;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    pStr = pStr + wcslen( pStr ) + 1;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    pStr = pStr + wcslen( pStr ) + 1;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    cbRequired += sizeof(CHAR);         /* The extra NULL */
    cchAppTopicList = (cbRequired - nAppTopicStart) / sizeof( CHAR );

    cchItemList = LengthMultiSzW( lpUDdeShare->lpszItemList );
    cbRequired += sizeof(CHAR) * cchItemList;

    if( (ccbBuffer >= cbRequired) && (lpDdeShare != NULL) ) {
        lpDdeShare->lRevision     = lpUDdeShare->lRevision;
        lpDdeShare->lShareType    = lpUDdeShare->lShareType;
        lpDdeShare->fSharedFlag   = lpUDdeShare->fSharedFlag;
        lpDdeShare->fService      = lpUDdeShare->fService;
        lpDdeShare->fStartAppFlag = lpUDdeShare->fStartAppFlag;
        lpDdeShare->nCmdShow      = lpUDdeShare->nCmdShow;
        lpDdeShare->qModifyId[0]  = lpUDdeShare->qModifyId[0];
        lpDdeShare->qModifyId[1]  = lpUDdeShare->qModifyId[1];
        lpDdeShare->cNumItems     = lpUDdeShare->cNumItems;

        lpszTarget = ((LPBYTE)lpDdeShare + sizeof( NDDESHAREINFO ));
        lpDdeShare->lpszShareName = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszShareName, -1,
                        lpDdeShare->lpszShareName, cchShareName, NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchShareName;

        lpDdeShare->lpszAppTopicList = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszAppTopicList, cchAppTopicList,
                        lpDdeShare->lpszAppTopicList, cchAppTopicList,
                            NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchAppTopicList;

        lpDdeShare->lpszItemList = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszItemList, cchItemList,
                        lpDdeShare->lpszItemList, cchItemList, NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchItemList;
    }

    return cbRequired;
}



int
ConvertNDdeToUnicode(
    PNDDESHAREINFO  lpDdeShare,
    PUNDDESHAREINFO lpUDdeShare,
    int             ccbBuffer )
{
    int         cbRequired;
    LPSTR       pStr;
    LPSTR       lpszTarget;
    int         cchAppTopicList, nAppTopicStart;
    int         cchShareName;
    int         cchItemList;

    /* Compute size required. */
    cbRequired    = sizeof( UNDDESHAREINFO );
    cchShareName  = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    lpDdeShare->lpszShareName, -1, NULL, 0 );
    cbRequired   += sizeof(WCHAR) * cchShareName;

    pStr = lpDdeShare->lpszAppTopicList;
    nAppTopicStart = cbRequired;
    cbRequired += sizeof(WCHAR) * MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    pStr, -1, NULL, 0 );
    pStr = pStr + strlen( pStr ) + 1;
    cbRequired += sizeof(WCHAR) * MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    pStr, -1, NULL, 0 );
    pStr = pStr + strlen( pStr ) + 1;
    cbRequired += sizeof(WCHAR) * MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                    pStr, -1, NULL, 0 );
    cbRequired += sizeof(WCHAR);                /* The extra NULL */
    cchAppTopicList = (cbRequired - nAppTopicStart) / sizeof( WCHAR );

    cchItemList = LengthMultiSzA( lpDdeShare->lpszItemList );
    cbRequired += sizeof(WCHAR) * cchItemList;

    if( (ccbBuffer >= cbRequired) && (lpUDdeShare != NULL) ) {
        lpUDdeShare->lRevision = lpDdeShare->lRevision;
        lpUDdeShare->lShareType = lpDdeShare->lShareType;
        lpUDdeShare->fSharedFlag = lpDdeShare->fSharedFlag;
        lpUDdeShare->fService = lpDdeShare->fService;
        lpUDdeShare->fStartAppFlag = lpDdeShare->fStartAppFlag;
        lpUDdeShare->nCmdShow = lpDdeShare->nCmdShow;
        lpUDdeShare->qModifyId[0] = lpDdeShare->qModifyId[0];
        lpUDdeShare->qModifyId[1] = lpDdeShare->qModifyId[1];
        lpUDdeShare->cNumItems = lpDdeShare->cNumItems;

        lpszTarget = ((LPSTR)lpUDdeShare + sizeof( UNDDESHAREINFO ));

        lpUDdeShare->lpszShareName = (LPWSTR) lpszTarget;
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpDdeShare->lpszShareName, -1,
                        lpUDdeShare->lpszShareName, cchShareName );
        lpszTarget += sizeof(WCHAR) * cchShareName;

        lpUDdeShare->lpszAppTopicList = (LPWSTR) lpszTarget;
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpDdeShare->lpszAppTopicList, cchAppTopicList,
                        lpUDdeShare->lpszAppTopicList, cchAppTopicList );
        lpszTarget += sizeof(WCHAR) * cchAppTopicList;

        lpUDdeShare->lpszItemList = (LPWSTR) lpszTarget;
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpDdeShare->lpszItemList, cchItemList,
                        lpUDdeShare->lpszItemList, cchItemList );
    }
    return cbRequired;
}

/*=================== API FUNCTIONS ============================
 *
 *  Dde Share manipulation functions in NDDEAPI.DLL
 *
 *=================== API FUNCTIONS ============================*/

/*
    Create and Add a Share
*/

UINT WINAPI
NDdeShareAddW (
    LPWSTR                  lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains struct, data
    DWORD                   cBufSize    // sizeof supplied buffer
)
{
    UINT                        RetValue;
    PSECURITY_DESCRIPTOR        pSDrel = NULL;
    DWORD                       dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       sdr;
    BOOL                        OK;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
        dwSize = GetSecurityDescriptorLength(pSD);
        OK = GetSecurityDescriptorControl(pSD, &sdc, &sdr);
        if (!OK) {
            DPRINTF(("NDdeShareAddW(): cannot get SD control: %d", GetLastError()));
            return(NDDE_INVALID_SECURITY_DESC);
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            pSDrel = LocalAlloc(LPTR, dwSize);
            if (pSDrel == NULL) {
                // MEMERROR();
                return(NDDE_OUT_OF_MEMORY);
            }
            OK = MakeSelfRelativeSD(pSD, pSDrel, &dwSize);
            if (!OK) {
                DPRINTF(("NDdeShareAddW(): bad SD: %d", GetLastError()));
                LocalFree(pSDrel);
                return(NDDE_INVALID_SECURITY_DESC);
            }
        } else {
            pSDrel = pSD;
        }
    }

    RetValue = NDDE_CANT_ACCESS_SERVER;
    RpcTryExcept {
        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {

            PUNDDESHAREINFO pN;
            DWORD nSn, nAt, nIt;

            pN  = (PUNDDESHAREINFO)lpBuffer;

            nSn = (wcslen(pN->lpszShareName) + 1) * sizeof(wchar_t);
            nAt = LengthAppTopicListW( pN->lpszAppTopicList ) * sizeof(wchar_t);
            nIt = LengthMultiSzW( pN->lpszItemList ) * sizeof(wchar_t);

            RetValue = wwNDdeShareAddW(
                nLevel, lpBuffer, cBufSize,
                (byte *)pN->lpszShareName, nSn,
                (byte *)pN->lpszAppTopicList, nAt,
                (byte *)pSDrel, dwSize,
                (byte *)pN->lpszItemList, nIt );

            NDdeApiUnbind();
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return RetValue;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareAddW", RpcExceptionCode() ));
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}



UINT WINAPI
NDdeShareAddA (
    LPSTR                   lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains struct, data
    DWORD                   cBufSize    // sizeof supplied buffer
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    LPWSTR              lpwszServer;
    UINT                uRtn;
    int                 nLen;

    if (lpBuffer == NULL) {
        return NDDE_INVALID_PARAMETER;
    }

    if (lpszServer == NULL) {
        lpwszServer = NULL;
    } else {
        nLen = (strlen(lpszServer) + 1) * sizeof(WCHAR);
        lpwszServer = LocalAlloc(LPTR, nLen);
        if (lpwszServer == NULL) {
            // MEMERROR();
            return(NDDE_OUT_OF_MEMORY);
        }
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                        lpszServer, -1,
                        lpwszServer, nLen / sizeof(WCHAR) );
    }


    nLen = ConvertNDdeToUnicode( (PNDDESHAREINFO)lpBuffer, NULL, 0 );
    lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, nLen );
    if (lpUDdeShare == NULL) {
        // MEMERROR();
        uRtn = NDDE_OUT_OF_MEMORY;
    } else {
        nLen = ConvertNDdeToUnicode((PNDDESHAREINFO)lpBuffer , lpUDdeShare, nLen );
        uRtn = NDdeShareAddW(lpwszServer, nLevel, pSD, (LPBYTE)lpUDdeShare, nLen);
        LocalFree( lpUDdeShare );
    }

    if (lpwszServer != NULL) {
        LocalFree( lpwszServer );
    }
    return uRtn;
}


/*
    Delete a Share
*/

UINT WINAPI
NDdeShareDelA (
    LPSTR       lpszServer,     // server to execute on ( must be NULL )
    LPSTR       lpszShareName,  // name of share to delete
    UINT        wReserved       // reserved for force level (?) 0 for now
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeShareDelA(
                lpszShareName, wReserved );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareDelA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeShareDelW (
    LPWSTR      lpszServer,     // server to execute on ( must be NULL )
    LPWSTR      lpszShareName,  // name of share to delete
    UINT        wReserved       // reserved for force level (?) 0 for now
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeShareDelW(
                lpszShareName, wReserved );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareDelW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Get Share Security Descriptor
*/

UINT WINAPI
NDdeGetShareSecurityA(
    LPSTR                       lpszServer,         // server to execute on ( must be NULL )
    LPSTR                       lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbSDRequired  // address of required size of buffer
)
{
    UINT RetValue;

    RpcTryExcept {

        DWORD   ncbSizeToReturn;

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetShareSecurityA(
                lpszShareName, (unsigned long) si,
                (byte *) pSD, cbSD, TRUE, lpcbSDRequired, &ncbSizeToReturn  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetShareSecurityA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept

}



UINT WINAPI
NDdeGetShareSecurityW(
    LPWSTR                      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR                      lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of buffer security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbSDRequired  // address of required size of buffer
)
{
    UINT RetValue;

    RpcTryExcept {

        DWORD   ncbSizeToReturn;

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetShareSecurityW(
                lpszShareName, (unsigned long) si,
                (byte *) pSD, cbSD, TRUE, lpcbSDRequired, &ncbSizeToReturn  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetShareSecurityW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Set Share Security Descriptor
*/

UINT WINAPI
NDdeSetShareSecurityA(
    LPSTR                       lpszServer,         // server to execute on ( must be NULL )
    LPSTR                       lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
)
{
    UINT                        RetValue;
    PSECURITY_DESCRIPTOR        pSDrel = NULL;
    DWORD                       dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       sdr;
    BOOL                        OK;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
        dwSize = GetSecurityDescriptorLength(pSD);
        OK = GetSecurityDescriptorControl(pSD, &sdc, &sdr);
        if (!OK) {
            DPRINTF(("NDdeSetShareSecurityA(): cannot get SD control: %d", GetLastError()));
            return(NDDE_INVALID_SECURITY_DESC);
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            pSDrel = LocalAlloc(LPTR, dwSize);
            if (pSDrel == NULL) {
                // MEMERROR();
                return(NDDE_OUT_OF_MEMORY);
            }
            OK = MakeSelfRelativeSD(pSD, pSDrel, &dwSize);
            if (!OK) {
                DPRINTF(("NDdeSetShareSecurityA(): bad SD: %d", GetLastError()));
                LocalFree(pSDrel);
                return(NDDE_INVALID_SECURITY_DESC);
            }
        } else {
            pSDrel = pSD;
        }
    } else {
        return(NDDE_INVALID_SECURITY_DESC);
    }

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetShareSecurityA(
                lpszShareName, (unsigned long) si,
                (byte *) pSDrel, dwSize );
            NDdeApiUnbind();
        } else {
            RetValue = NDDE_CANT_ACCESS_SERVER;
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return RetValue;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetShareSecurityA", RpcExceptionCode() ));
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept

}

UINT WINAPI
NDdeSetShareSecurityW(
    LPWSTR                      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR                      lpszShareName,  // name of share
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
)
{
    UINT                        RetValue;
    PSECURITY_DESCRIPTOR        pSDrel = NULL;
    DWORD                       dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       sdr;
    BOOL                        OK;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
        dwSize = GetSecurityDescriptorLength(pSD);
        OK = GetSecurityDescriptorControl(pSD, &sdc, &sdr);
        if (!OK) {
            DPRINTF(("NDdeSetShareSecurityW(): cannot get SD control: %d", GetLastError()));
            return(NDDE_INVALID_SECURITY_DESC);
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            pSDrel = LocalAlloc(LPTR, dwSize);
            if (pSDrel == NULL) {
                // MEMERROR();
                return(NDDE_OUT_OF_MEMORY);
            }
            OK = MakeSelfRelativeSD(pSD, pSDrel, &dwSize);
            if (!OK) {
                DPRINTF(("NDdeSetShareSecurityW(): bad SD: %d", GetLastError()));
                LocalFree(pSDrel);
                return(NDDE_INVALID_SECURITY_DESC);
            }
        } else {
            pSDrel = pSD;
        }
    } else {
        return(NDDE_INVALID_SECURITY_DESC);
    }

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetShareSecurityW(
                lpszShareName, (unsigned long) si,
                (byte *) pSDrel, dwSize );
            NDdeApiUnbind();
        } else {
            RetValue = NDDE_CANT_ACCESS_SERVER;
        }
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return RetValue;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetShareSecurityW", RpcExceptionCode() ));
        if (!(sdc & SE_SELF_RELATIVE)) {
            LocalFree(pSDrel);
        }
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Enumerate Shares
*/

UINT WINAPI
NDdeShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {

            RetValue = wwNDdeShareEnumA(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareEnumA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeShareEnumW(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareEnumW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}





UINT WINAPI
NDdeShareGetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
)
{
    UINT RetValue;
    DWORD lpnRetSize, lpnSn, lpnAt, lpnIt;
    PUNDDESHAREINFO p;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            if ( lpnItems == (LPWORD) NULL ) {
                return NDDE_INVALID_PARAMETER;
            }
            if ( *lpnItems     != 0 ) {
                return NDDE_INVALID_PARAMETER;
            }
            RetValue = wwNDdeShareGetInfoW(
                lpszShareName, nLevel, lpBuffer, cBufSize,
                lpnTotalAvailable, lpnItems,
                TRUE,   /* RPC, Not a local call */
                &lpnRetSize, &lpnSn, &lpnAt, &lpnIt );
            NDdeApiUnbind();

            if( RetValue == NDDE_NO_ERROR ) {

                p = (PUNDDESHAREINFO)lpBuffer;
                p->lpszShareName    = (LPWSTR)(lpBuffer + lpnSn);
                p->lpszAppTopicList = (LPWSTR)(lpBuffer + lpnAt);
                p->lpszItemList     = (LPWSTR)(lpBuffer + lpnIt);
            }
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareGetInfoW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}



UINT WINAPI
NDdeShareGetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level
    LPBYTE  lpBuffer,           // gets struct
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    UINT                uRtn;
    WCHAR               lpwShareName[MAX_NDDESHARENAME + 1];
    WCHAR               lpwServer[MAX_COMPUTERNAME_LENGTH + 1];
    int                 nLen;

    if( lpszShareName == NULL ||
            lpnTotalAvailable == NULL ||
            lpnItems == NULL ||
            *lpnItems != 0) {
        return NDDE_INVALID_PARAMETER;
    }

    if (lpszServer != NULL) {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszServer, -1,
                             lpwServer, MAX_COMPUTERNAME_LENGTH + 1 );
    }
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME + 1 );

    /*
     * First try to call with actual buffer given - may be big enough as is.
     */
    uRtn = NDdeShareGetInfoW((lpszServer == NULL) ? NULL : lpwServer,
            lpwShareName,
            nLevel,
            lpBuffer,
            cBufSize,
            lpnTotalAvailable,
            lpnItems);

    if( uRtn == NDDE_BUF_TOO_SMALL ) {
        /*
         * Buffer won't hold UNICODE form so allocate one big enough and
         * try again.
         */
        lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, *lpnTotalAvailable );
        if( lpUDdeShare == NULL)  {
            // MEMERROR();
            return( NDDE_OUT_OF_MEMORY );
        }
        uRtn = NDdeShareGetInfoW((lpszServer == NULL) ? (LPWSTR)lpszServer : lpwServer,
                lpwShareName,
                nLevel,
                (LPBYTE)lpUDdeShare,
                *lpnTotalAvailable,
                lpnTotalAvailable,
                lpnItems);

        if( uRtn == NDDE_NO_ERROR ) {
            /*
             * It fit so convert data to Ansii and see if it will fit in
             * lpBuffer.  If so, cool, else BUF_TOO_SMALL.
             */
            nLen = ConvertNDdeToAnsii( lpUDdeShare, NULL, 0 );
            *lpnTotalAvailable = nLen;

            if( nLen > (int)cBufSize ) {
                LocalFree( lpUDdeShare );
                return NDDE_BUF_TOO_SMALL;
            }

            ConvertNDdeToAnsii( (PUNDDESHAREINFO)lpUDdeShare,
                                (PNDDESHAREINFO) lpBuffer,
                                cBufSize );
        }

        LocalFree( lpUDdeShare );
    } else if( uRtn == NDDE_NO_ERROR ) {
        lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, *lpnTotalAvailable );
        if( lpUDdeShare == NULL)  {
            // MEMERROR();
            return( NDDE_OUT_OF_MEMORY );
        }
        /*
         * Move results into temporary buffer and fixup pointers.
         */
        memcpy(lpUDdeShare, lpBuffer, *lpnTotalAvailable);
        lpUDdeShare->lpszShareName = (LPWSTR)(
                (LPBYTE)(((PNDDESHAREINFO)lpBuffer)->lpszShareName) +
                ((DWORD_PTR)lpUDdeShare - (DWORD_PTR)lpBuffer));
        lpUDdeShare->lpszAppTopicList = (LPWSTR)(
                (LPBYTE)(((PNDDESHAREINFO)lpBuffer)->lpszAppTopicList) +
                ((DWORD_PTR)lpUDdeShare - (DWORD_PTR)lpBuffer));
        /*
         * Convert temporary buffer to Ansii and place into original buffer.
         */
        *lpnTotalAvailable = ConvertNDdeToAnsii(
                lpUDdeShare,
                (PNDDESHAREINFO)lpBuffer,
                *lpnTotalAvailable);
        LocalFree(lpUDdeShare);
    }

    return uRtn;
}



UINT WINAPI
NDdeShareSetInfoW (
    LPWSTR  lpszServer, // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // must point to struct
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {

            PUNDDESHAREINFO pN;
            DWORD nSn, nAt, nIt;

            pN  = (PUNDDESHAREINFO)lpBuffer;

            nSn = (wcslen(pN->lpszShareName) + 1) * sizeof(wchar_t);
            nAt = LengthAppTopicListW( pN->lpszAppTopicList ) *
                sizeof(wchar_t);
            nIt = LengthMultiSzW( pN->lpszItemList ) * sizeof(wchar_t);

            RetValue = wwNDdeShareSetInfoW(
                lpszShareName, nLevel, lpBuffer, cBufSize, sParmNum,
                (byte *)pN->lpszShareName, nSn,
                (byte *)pN->lpszAppTopicList, nAt,
                (byte *)pN->lpszItemList, nIt );

            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeShareSetInfoW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}



UINT WINAPI
NDdeShareSetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // must point to struct
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    UINT                uRtn;
    int                 nLen;
    WCHAR               lpwShareName[MAX_NDDESHARENAME + 1];
    WCHAR               lpwServer[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR              lpwszServer = lpwServer;

    if(lpszShareName == NULL ||
            lpBuffer == NULL ||
            ((PNDDESHAREINFO)lpBuffer)->lpszShareName == NULL ||
            ((PNDDESHAREINFO)lpBuffer)->lpszAppTopicList == NULL ||
            ((PNDDESHAREINFO)lpBuffer)->lpszItemList == NULL) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME + 1 );

    if (lpszServer != NULL) {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszServer, -1,
                             lpwServer, MAX_COMPUTERNAME_LENGTH + 1 );
    } else {
        lpwszServer = NULL;
    }

    nLen = ConvertNDdeToUnicode( (PNDDESHAREINFO)lpBuffer, NULL, 0 );
    lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, nLen );
    if( !lpUDdeShare )  {
        // MEMERROR();
        return( NDDE_OUT_OF_MEMORY );
    }
    nLen = ConvertNDdeToUnicode( (PNDDESHAREINFO)lpBuffer, lpUDdeShare, nLen );

    uRtn = NDdeShareSetInfoW(lpwszServer, lpwShareName, nLevel,
            (LPBYTE)lpUDdeShare, nLen, sParmNum);

    LocalFree( lpUDdeShare );

    return uRtn;
}


/*
    Set/Create a trusted share
*/

UINT WINAPI
NDdeSetTrustedShareA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetTrustedShareA(
                lpszShareName, (unsigned long) dwTrustOptions);
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetTrustedShareA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

UINT WINAPI
NDdeSetTrustedShareW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSetTrustedShareW(
                lpszShareName, (unsigned long) dwTrustOptions);
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSetTrustedShareW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

/*
    Get a trusted share options
*/

UINT WINAPI
NDdeGetTrustedShareA (
    LPSTR       lpszServer,         // server to execute on ( must be NULL )
    LPSTR       lpszShareName,      // name of share to get
    LPDWORD     lpdwTrustOptions,   // trust options to apply
    LPDWORD     lpdwShareModId0,    // share mod id word 0
    LPDWORD     lpdwShareModId1     // share mod id word 1
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetTrustedShareA(
                lpszShareName, lpdwTrustOptions,
                lpdwShareModId0, lpdwShareModId1  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetTrustedShareA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

UINT WINAPI
NDdeGetTrustedShareW (
    LPWSTR      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR      lpszShareName,      // name of share to get
    LPDWORD     lpdwTrustOptions,   // trust options to apply
    LPDWORD     lpdwShareModId0,    // share mod id word 0
    LPDWORD     lpdwShareModId1     // share mod id word 1
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeGetTrustedShareW(
                lpszShareName, lpdwTrustOptions,
                lpdwShareModId0, lpdwShareModId1  );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeGetTrustedShareW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Enumerate trusted shares
*/
UINT WINAPI
NDdeTrustedShareEnumA (
    LPSTR   lpszServer,             // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,               // pointer to buffer
    DWORD   cBufSize,               // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {

            RetValue = wwNDdeTrustedShareEnumA(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeTrustedShareEnumA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}

UINT WINAPI
NDdeTrustedShareEnumW (
    LPWSTR  lpszServer,             // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,               // pointer to buffer
    DWORD   cBufSize,               // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
)
{
    UINT                RetValue;
    unsigned long       lpnRetSize;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeTrustedShareEnumW(
                nLevel, lpBuffer, cBufSize, lpnEntriesRead,
                lpcbTotalAvailable, &lpnRetSize );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeTrustedShareEnumW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


/*
    Special Command
*/
UINT WINAPI
NDdeSpecialCommandA(
    LPSTR   lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *lpBytesDataOut
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindA( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSpecialCommand(
                nCommand, lpDataIn, nBytesDataIn, lpDataOut,
                    (unsigned long *)lpBytesDataOut );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSpecialCommandA", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeSpecialCommandW(
    LPWSTR  lpszServer,
    UINT    nCommand,
    LPBYTE  lpDataIn,
    UINT    nBytesDataIn,
    LPBYTE  lpDataOut,
    UINT   *nBytesDataOut
)
{
    UINT RetValue;

    RpcTryExcept {

        if( NDdeApiBindW( lpszServer ) == RPC_S_OK ) {
            RetValue = wwNDdeSpecialCommand(
                nCommand, lpDataIn, nBytesDataIn, lpDataOut,
                    (unsigned long *)nBytesDataOut );
            NDdeApiUnbind();
            return RetValue;
        } else {
            return NDDE_CANT_ACCESS_SERVER;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        DPRINTF(("Rpc Exception %d in NddeSpecialCommandW", RpcExceptionCode() ));
        return NDDE_CANT_ACCESS_SERVER;
    }
    RpcEndExcept
}


UINT WINAPI
NDdeGetErrorStringA (
    UINT    uErrorCode,         // Error code to get string for
    LPSTR   lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
)
{
    if (!LoadStringA ( hInst, uErrorCode, lpszErrorString, (int)cBufSize )) {
        return NDDE_INTERNAL_ERROR;
    }
    return NDDE_NO_ERROR;
}


UINT WINAPI
NDdeGetErrorStringW (
    UINT    uErrorCode,         // Error code to get string for
    LPWSTR  lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
)
{
    if (!LoadStringW ( hInst, uErrorCode, lpszErrorString, (int)cBufSize )) {
        return NDDE_INTERNAL_ERROR;
    }
    return NDDE_NO_ERROR;
}


//=============== DLL housekeeping ===============//

INT  APIENTRY LibMain(
    HANDLE hInstance,
    DWORD ul_reason_being_called,
    LPVOID lpReserved )
{
    hInst = hInstance;
#if DBG
    DebugInit( "NDDEAPI" );
#endif

    return 1;

    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(ul_reason_being_called);
    UNREFERENCED_PARAMETER(lpReserved);
}

RPC_STATUS NDdeApiBindA( LPSTR pszNetworkAddress )
{
    WCHAR lpwNetworkAddress[1000];

    if( pszNetworkAddress ) {

        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszNetworkAddress, -1,
                    lpwNetworkAddress, 1000 );
    } else {
        wcscpy( lpwNetworkAddress, L"" );
    }
    return NDdeApiBindW( lpwNetworkAddress );
}

RPC_STATUS NDdeApiBindW( LPWSTR pszNetworkAddress )
{
    RPC_STATUS status;

    if( pszNetworkAddress != NULL) {
        wcscpy( szNetworkAddress, pszNetworkAddress );
    } else {
        wcscpy( szNetworkAddress, L"" );
    }

    status = RpcStringBindingComposeW(pszUuid,
                                     pszProtocolSequence,
                                     szNetworkAddress,
                                     szEndpoint,
                                     pszOptions,
                                     &pszStringBinding);
    if( status != RPC_S_OK ) {
         sprintf(tmpBuf,
             "RpcStringBindingComposeW failed: (0x%x)\n", status );

         MessageBox(NULL, tmpBuf,  "RPC Runtime Error",  MB_ICONEXCLAMATION);
         return(status);
    }

    status = RpcBindingFromStringBindingW( pszStringBinding,
                                           &hNDdeApi );
    RpcStringFreeW( &pszStringBinding );

    if( status != RPC_S_OK ) {
         sprintf(tmpBuf,
             "RpcBindingFromStringBindingW failed:(0x%x)\n", status );

         MessageBox(NULL, tmpBuf,  "RPC Runtime Error",  MB_ICONEXCLAMATION);
         return(status);
   }

   return(status);
}

RPC_STATUS NDdeApiUnbind( void )
{
     RPC_STATUS status;

     status = RpcBindingFree(&hNDdeApi);  // remote calls done; unbind
     if (status) {
          MessageBox(NULL, "RpcBindingFree failed", "RPC Error",
                     MB_ICONSTOP);
     }
     return(status);
}

int LengthMultiSzA( LPSTR pMz )
{
    int nLen;

    nLen = 0;

    if( !pMz ) {
        return 0;
    }
    if( *pMz != '\0' ) {
        while( *pMz++ != '\0' ) {
            nLen++;
            while( *pMz++ != '\0' ) {
                nLen++;
            }
            nLen++;
        }
    } else {
        nLen++;
    }
    nLen++;             /* count the second terminating '\0' */

    return nLen;
}

int LengthMultiSzW( LPWSTR pMz )
{
    int nLen;

    nLen = 0;

    if( !pMz ) {
        return 0;
    }
    if( *pMz != L'\0' ) {
        while( *pMz++ != L'\0' ) {
            nLen++;
            while( *pMz++ != L'\0' ) {
                nLen++;
            }
            nLen++;
        }
    } else {
        nLen++;
    }
    nLen++;             /* count the second terminating '\0' */

    return nLen;
}

int LengthAppTopicListA( LPSTR pMz )
{
    LPSTR a, b, c;
    long x;

    if( !pMz ) {
        return 0;
    }
    if( NDdeParseAppTopicListA( pMz, &a, &b, &c, &x ) ) {
        return strlen(a) + strlen(b) + strlen(c) + 4;
    } else {
        return 0;
    }

}

int LengthAppTopicListW( LPWSTR pMz )
{
    LPWSTR a, b, c;
    long x;

    if( !pMz ) {
        return 0;
    }
    if( NDdeParseAppTopicListW( pMz, &a, &b, &c, &x ) ) {
        return wcslen(a) + wcslen(b) + wcslen(c) + 4;
    } else {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\server\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt
IDL_NAME = ndeapi
INCS     = -I$(SDK_INC_PATH)  -I$(SDK_INC_PATH)\crt
EXTRN_DEPENDS = $(SDK_INC_PATH)\windef.h \
                ..\$(IDL_NAME).acf
CPP_FLAGS = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

$(O)\$(IDL_NAME)_s.c : ..\$(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -Oicf -robust -client none -oldnames -error all -ms_ext -c_ext $(CPP_FLAGS) ..\$(IDL_NAME).idl $(INCS) /out $(O) /acf ..\$(IDL_NAME).acf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\client\oldstub.c ===
#include <stdlib.h>
#include <rpc.h>
#include <rpcndr.h>

// ====================================================================
//                MIDL allocate and free
// ====================================================================

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void * MIDL_user_allocate(size_t len)
#else
void * _stdcall MIDL_user_allocate(size_t len)
#endif
{
    return(malloc(len));
}

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void MIDL_user_free(void * ptr)
#else
void _stdcall MIDL_user_free(void * ptr)
#endif
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\server\nddeapip.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIP.C;2  11-Feb-93,11:28:36  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    NDDEAPIP.C

    Network DDE Share access Api implementation routines.

    Revisions:
    12-92   BillU.  Wonderware secure DSDM port.
    12-92   ColeC.  Wonderware RPC'd for NT..
     3-93   IgorM.  Wonderware new APIs for NT. General overhaul and engine swap.

   $History: End */


#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

#include "nddeapi.h"
#include "nddesec.h"
#include "nddelog.h"
#include "nddemsg.h"
#define SKIP_DEBUG_WIN32
#include "debug.h"
#include "hexdump.h"
#include "ndeapi.h"
#include "shrtrust.h"
#include "unddesi.h"
#include "proflspt.h"
#include "mbstring.h"

//#define NDDE_DEBUG
#if DBG
BOOL    bDebugDSDMInfo      = FALSE;
BOOL    bDebugDSDMErrors    = FALSE;
#endif

static PSECURITY_DESCRIPTOR    pDsDmSD;
static CRITICAL_SECTION        DsDmCriticalSection;
static WCHAR                   szTrustedShareKey[TRUSTED_SHARES_KEY_MAX] = L"";


//
// Generic mapping for share objects
//

static GENERIC_MAPPING        ShareGenMap = {
    NDDE_SHARE_GENERIC_READ,
    NDDE_SHARE_GENERIC_WRITE,
    NDDE_SHARE_GENERIC_EXECUTE,
    NDDE_SHARE_GENERIC_ALL
};


/**************************************************************
    external refs
***************************************************************/
BOOL
BuildNewSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pNewSecurityDescriptor,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pPreviousSecurityDescriptor,
    PSECURITY_DESCRIPTOR    pUpdatedSecurityDescriptor );

PSECURITY_DESCRIPTOR
AllocCopySecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PDWORD                  pLength );

BOOL
NDdeParseAppTopicListA (
    LPSTR   appTopicList,
    LPSTR  *pOldStr,
    LPSTR  *pNewStr,
    LPSTR  *pStaticStr,
    PLONG   pShareType );

BOOL
NDdeParseAppTopicListW (
    LPWSTR  appTopicList,
    LPWSTR *pOldStr,
    LPWSTR *pNewStr,
    LPWSTR *pStaticStr,
    PLONG   pShareType );

BOOL
NDdeParseItemList (
    LPWSTR      itemList,
    LONG        cNumItems,
    PLONG       plSize );

int
LengthMultiSzA( LPSTR pMz );

int
LengthMultiSzW( LPWSTR pMz );

int
LengthAppTopicListA( LPSTR pMz );

int
LengthAppTopicListW( LPWSTR pMz );

BOOL
UpdateDSDMModifyId(LONG lSerialId[]);

BOOL
UpdateShareModifyId(
    HKEY    hKey,
    LONG    lSerialId[]);

BOOL
GetShareSerialNumber(
    PWCHAR  pwShareName,
    LPBYTE  lpSerialNumber);

BOOL
GetShareNameSD(
    HKEY                    hKey,
    PSECURITY_DESCRIPTOR   *ppSD,
    DWORD                  *pcbData );

BOOL
NDdeShareAccessCheck(
    LPWSTR                  lpszShareName,
    PSECURITY_DESCRIPTOR    pSD,
    DWORD                   dwDesiredAccess,
    PGENERIC_MAPPING        pgm,
    BOOL                    fObjectCreation,
    DWORD                  *pGrantedAccess,
    BOOL                   *pStatus );

BOOL
NDdeShareAccessCheckAudit(
    LPWSTR                  lpszShareName,
    PSECURITY_DESCRIPTOR    pSD,
    DWORD                   dwDesiredAccess,
    PGENERIC_MAPPING        pgm,
    BOOL                    fObjectCreation,
    BOOL                    fObjectDeletion,
    DWORD                  *pGrantedAccess,
    BOOL                   *pStatus );



BOOL
GetTokenHandleRead( PHANDLE pTokenHandle );

HANDLE
OpenCurrentUserKey(ULONG DesiredAccess);

// dll instance saved in libmain
// Not needed in the server
//HINSTANCE        hInst;

GENERIC_MAPPING ShareDBGenericMapping = { NDDE_SHAREDB_EVERYONE,
                                          NDDE_SHAREDB_USER,
                                          NDDE_SHAREDB_USER,
                                          NDDE_SHAREDB_ADMIN };

GENERIC_MAPPING ShareGenericMapping = { NDDE_SHARE_GENERIC_READ,
                                        NDDE_SHARE_GENERIC_WRITE,
                                        NDDE_SHARE_GENERIC_EXECUTE,
                                        NDDE_SHARE_GENERIC_ALL };

#define ImpersonateAndSetup( RpcClient )                                \
    {                                                                   \
        RPC_STATUS              rpcStatus;                              \
                                                                        \
        EnterCriticalSection( &DsDmCriticalSection );                   \
        if( RpcClient ) {                                               \
            rpcStatus = RpcImpersonateClient( 0 );                      \
            if( rpcStatus != RPC_S_OK )  {                              \
                LeaveCriticalSection( &DsDmCriticalSection );           \
                NDDELogErrorW( MSG400, LogStringW( L"%d", rpcStatus ),  \
                    NULL );                                             \
                return NDDE_ACCESS_DENIED;                              \
            }                                                           \
        }                                                               \
    }

#define RevertAndCleanUp( RpcClient )                                   \
    {                                                                   \
        if( RpcClient ) {                                               \
            RevertToSelf();                                             \
        }                                                               \
        LeaveCriticalSection( &DsDmCriticalSection );                   \
    }


/**************************************************************

    NetDDE DSDM SHARE ACCESS API

***************************************************************/

/*
    Share Name Validation
*/

BOOL WINAPI
NDdeIsValidShareNameA ( LPSTR shareName )
{
    DWORD len;

    if ( !shareName ) {
        return FALSE;
    }

    len = strlen(shareName);

    if ( len < 1 || len > MAX_NDDESHARENAME ) {
        return FALSE;
    }

    // share name cannot contain '=' or '\' because of registry and .ini syntax!
    if (GetSystemMetrics(SM_DBCSENABLED)) {
        if (_mbschr(shareName, '=') || _mbschr(shareName, '\\'))
            return FALSE;
    } else {
        if (strchr(shareName, '=') || strchr(shareName, '\\'))
            return FALSE;
    }
    
    return TRUE;
}


// this one needs to be exported for clipbook(clausgi 8/4/92)
BOOL WINAPI
NDdeIsValidShareNameW ( LPWSTR shareName )
{
    DWORD len;

    if ( !shareName ) {
        return FALSE;
    }

    len = wcslen(shareName);

    if ( len < 1 || len > MAX_NDDESHARENAME ) {
        return FALSE;
    }

    // share name cannot contain '=' because of .ini syntax!
    if ( wcschr(shareName, L'=') || wcschr(shareName, L'\\')) {
        return FALSE;
    }
    return TRUE;
}


/*
    Validate App Topic List
*/
BOOL WINAPI
wwNDdeIsValidAppTopicListA ( LPSTR appTopicList )
{
    LPSTR pOldStr;
    LPSTR pNewStr;
    LPSTR pStaticStr;
    LONG   lShareType;

    return NDdeParseAppTopicListA( appTopicList, &pOldStr, &pNewStr,
                                   &pStaticStr,  &lShareType );
}


BOOL WINAPI
NDdeIsValidAppTopicListW ( LPWSTR appTopicList )
{
    LPWSTR pOldStr;
    LPWSTR pNewStr;
    LPWSTR pStaticStr;
    LONG   lShareType;

    return NDdeParseAppTopicListW( appTopicList, &pOldStr, &pNewStr,
                                  &pStaticStr,  &lShareType );
}


//=================== API FUNCTIONS ============================
//
//  Dde Share manipulation functions in NDDEAPI.DLL
//
//=================== API FUNCTIONS ============================

unsigned long
wwNDdeShareAddW (
    unsigned long   nLevel,       // info level must be 2
    byte          * lpBuffer,     // contains struct, data
    unsigned long   cBufSize,     // sizeof supplied buffer
    byte          * psn,
    unsigned long   lsn,
    byte          * pat,
    unsigned long   lat,
    byte          * pSD,
    unsigned long   lsd,
    byte          * pit,
    unsigned long   lit
)
{
    PUNDDESHAREINFO         lpDdeShare;
    PSECURITY_DESCRIPTOR    pShareSD = pSD, pNewSD;
    LONG                    lRtn;
    HKEY                    hKey;
    DWORD                   dwDisp;
    WCHAR                   szShareAdd[500];
    LONG                    lItemList;
    BOOL                    OK;
    DWORD                   dwDesiredAccess, dwGrantedAccess;
    BOOL                    fStatus;
    LPWSTR                  pOldStr;
    LPWSTR                  pNewStr;
    LPWSTR                  pStaticStr;
    LONG                    lShareType;
    LONG                    lSerialNumber[2];
    HANDLE                  hClientToken;


    if (lsn < sizeof (WCHAR) || (lsn & (sizeof (WCHAR) - 1)) != 0) {
        return NDDE_INVALID_PARAMETER;
    }

    if ( ((PWCHAR)psn == NULL) || (IsBadReadPtr(psn,lsn) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (((PWCHAR)psn)[lsn/sizeof (WCHAR) - 1] != L'\0') {
        return NDDE_INVALID_PARAMETER;
    }
    
    if (lsd != 0)
       {
       if (!IsValidSecurityDescriptor(pSD))
          {
          return(NDDE_INVALID_SECURITY_DESC);
          }
       else // 6-25-93 a-mgates Added this else {}.
          {
          pShareSD = pSD;
          }
       }
    else
       {
       pShareSD = NULL;
       }

    if ( nLevel != 2 )  {
        return NDDE_INVALID_LEVEL;
    }
    if ( cBufSize < sizeof(UNDDESHAREINFO) ) {
        return NDDE_BUF_TOO_SMALL;
    }

    lpDdeShare = (PUNDDESHAREINFO)lpBuffer;
    if( lpDdeShare == (PUNDDESHAREINFO) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    /* Fixup the pointers in the UNDDESHAREINFO strucure */

    lpDdeShare->lpszShareName    = (LPWSTR)psn;
    lpDdeShare->lpszAppTopicList = (LPWSTR)pat;
    lpDdeShare->lpszItemList     = (LPWSTR)pit;

    if ( !NDdeIsValidShareNameW ( lpDdeShare->lpszShareName )) {
        return NDDE_INVALID_SHARE;
    }

    if ( !NDdeParseAppTopicListW ( lpDdeShare->lpszAppTopicList,
                                  &pOldStr, &pNewStr, &pStaticStr,
                                  &lShareType)) {
        return NDDE_INVALID_TOPIC;
    }

    if ( !NDdeParseItemList ( lpDdeShare->lpszItemList,
                              lpDdeShare->cNumItems, &lItemList )) {
        return NDDE_INVALID_ITEM_LIST;
    }

    ImpersonateAndSetup( TRUE );

    /*  Make sure the caller has AddShare(As) access rights. */
    dwDesiredAccess = NDDE_SHAREDB_ADD;
    if (lpDdeShare->fService) {
        dwDesiredAccess |= NDDE_SHAREDB_FSERVICE;
    }
    OK = NDdeShareAccessCheckAudit( lpDdeShare->lpszShareName, pDsDmSD,
        dwDesiredAccess, &ShareDBGenericMapping, TRUE, FALSE,
        &dwGrantedAccess, &fStatus );

    RevertAndCleanUp( TRUE );

    if( !OK || !fStatus ) {
        return NDDE_ACCESS_DENIED;
    }

#ifdef NDDE_DEBUG
    DPRINTF(("Revision               = (%d)", lpDdeShare->lRevision));
    DPRINTF(("ShareName              = (%ws)", lpDdeShare->lpszShareName));
    DPRINTF(("ShareType              = (%d)", lpDdeShare->lShareType));
    DPRINTF(("ShareType*             = (%d)", lShareType));
    DPRINTF(("AppTopicList"));
    DPRINTF(("  Old-style link share = (%ws)", pOldStr));
    DPRINTF(("  New-style link share = (%ws)", pNewStr));
    DPRINTF(("  Static data share    = (%ws)", pStaticStr));
    DPRINTF(("SharedFlag             = (%d)", lpDdeShare->fSharedFlag));
    DPRINTF(("ServiceFlag            = (%d)", lpDdeShare->fService));
    DPRINTF(("StartAppFlag           = (%d)", lpDdeShare->fStartAppFlag));
    DPRINTF(("nCmdShow               = (%d)", lpDdeShare->nCmdShow));
    DPRINTF(("SerialNumber           = (%d, %d)", lpDdeShare->qModifyId[0],
                                                 lpDdeShare->qModifyId[1]));
    DPRINTF(("NumItems               = (%d)", lpDdeShare->cNumItems));
    {
        LPWSTR  lpszItem = lpDdeShare->lpszItemList;
        int     n= 0;
        for( n=0; n<lpDdeShare->cNumItems; n++ )  {
            DPRINTF(("ItemList[%d]             = (%ws)", n, lpszItem));
            lpszItem = lpszItem + wcslen(lpszItem) + 1;
        }
    }
#endif

    // check for share existence
    wcscpy( szShareAdd, DDE_SHARES_KEY_W );
    wcscat( szShareAdd, L"\\" );
    if( wcslen(szShareAdd) + wcslen(lpDdeShare->lpszShareName) + 1 >= 500 ) {
        return NDDE_OUT_OF_MEMORY;
    }
    wcscat( szShareAdd, lpDdeShare->lpszShareName );

    lRtn = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
            szShareAdd,
            0,
            L"NetDDEShare",
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,   /* use default inherited from container */
            &hKey,
            &dwDisp );

    if( lRtn == ERROR_SUCCESS ) {
        if (dwDisp == REG_OPENED_EXISTING_KEY) {
            RegCloseKey( hKey );
            return NDDE_SHARE_ALREADY_EXIST;
        }
        OK = UpdateDSDMModifyId(lSerialNumber);
        if (!OK) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }

        lpDdeShare->qModifyId[0] = lSerialNumber[0];
        lpDdeShare->qModifyId[1] = lSerialNumber[1];

        /*  Set the key values. */

        lRtn = RegSetValueExW( hKey,
                   L"ShareName",
                   0,
                   REG_SZ,
                   (LPBYTE)lpDdeShare->lpszShareName,
                   sizeof(WCHAR) *
                   (wcslen( lpDdeShare->lpszShareName ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"OldStyleLink",
                   0,
                   REG_SZ,
                   (LPBYTE)pOldStr,
                   sizeof(WCHAR) * (wcslen( pOldStr ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"NewStyleLink",
                   0,
                   REG_SZ,
                   (LPBYTE)pNewStr,
                   sizeof(WCHAR) * (wcslen( pNewStr ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"StaticDataLink",
                   0,
                   REG_SZ,
                   (LPBYTE)pStaticStr,
                   sizeof(WCHAR) * (wcslen( pStaticStr ) + 1) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"ItemList",
                   0,
                   REG_MULTI_SZ,
                   (LPBYTE)lpDdeShare->lpszItemList,
                   sizeof(WCHAR) * lItemList );
        lRtn = RegSetValueExW( hKey,
                   L"Revision",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->lRevision,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"ShareType",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lShareType,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"SharedFlag",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->fSharedFlag,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"Service",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->fService,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"StartAppFlag",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->fStartAppFlag,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"fuCmdShow",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->nCmdShow,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }

        ImpersonateAndSetup( TRUE );
        if( !GetTokenHandleRead( &hClientToken ) ) {
       #if DBG
            if (bDebugDSDMErrors) {
                DPRINTF(("Could not get client token handle."));
            }
       #endif
            RevertAndCleanUp(TRUE);
            return NDDE_ACCESS_DENIED;
        }
        RevertAndCleanUp(TRUE);

        OK = CreatePrivateObjectSecurity(
                   pDsDmSD,            // psdParent
                   pShareSD,        // psdCreator
                       &pNewSD,            // lppsdNew
                       FALSE,            // fContainer
                       hClientToken,        // hClientToken
                       &ShareGenMap);        // pgm

        if (!OK) {
            CloseHandle(hClientToken);
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }

        lRtn = RegSetValueExW( hKey,
                   L"SecurityDescriptor",
                   0,
                   REG_BINARY,
                   pNewSD,
                   GetSecurityDescriptorLength( pNewSD ) );

        OK = DestroyPrivateObjectSecurity(&pNewSD);
    #if DBG
        if (!OK && bDebugDSDMErrors) {
            DPRINTF(("Unable to DestroyPrivateObject(): %d", GetLastError()));
        }
    #endif

        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        lRtn = RegSetValueExW( hKey,
                   L"NumItems",
                   0,
                   REG_DWORD,
                   (LPBYTE)&lpDdeShare->cNumItems,
                   sizeof( LONG ) );
        if( lRtn != ERROR_SUCCESS ) {
            RegDeleteKeyW(HKEY_LOCAL_MACHINE, szShareAdd);
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        OK = UpdateShareModifyId(hKey, lSerialNumber);

        // no longer needed
        // RegCloseKey( hKey ); ALREADY CLOSED BY UpdateShareModifyId!

        if (!OK) {
            return NDDE_REGISTRY_ERROR;
        }
    } else {
        return NDDE_REGISTRY_ERROR;
    }

    return NDDE_NO_ERROR;
}


/*
    Delete a Share
*/

unsigned long
wwNDdeShareDelA (
    unsigned char * lpszShareName, // name of share to delete
    unsigned long   wReserved      // reserved for force level (?) 0 for now
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME * 2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME * 2 );

    uRtn = wwNDdeShareDelW( lpwShareName, wReserved );

    return uRtn;
}

unsigned long
wwNDdeShareDelW (
    wchar_t *     lpszShareName,  // name of share to delete
    unsigned long wReserved       // reserved for force level (?) 0 for now
)
{
    WCHAR                   szShareDel[500];
    LONG                    lRtn;
    PSECURITY_DESCRIPTOR    pSnSD;
    DWORD                   cbData;
    HKEY                    hKey;
    BOOL                    OK;
    DWORD                   dwDesiredAccess, dwGrantedAccess;
    BOOL                    fStatus;

    if( lpszShareName == (wchar_t *) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }
    if ( wReserved != 0 ) {
        return NDDE_INVALID_PARAMETER;
    }

    // check for share existence
    wcscpy( szShareDel, DDE_SHARES_KEY_W );
    wcscat( szShareDel, L"\\" );
    if( wcslen(szShareDel) + wcslen(lpszShareName) + 1 >= 500 ) {
        return NDDE_OUT_OF_MEMORY;
    }
    wcscat( szShareDel, lpszShareName );
    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  szShareDel,
                  0,
                  KEY_WRITE | KEY_READ | DELETE,
                  &hKey );

    if( lRtn != ERROR_SUCCESS ) {
        return NDDE_ACCESS_DENIED;
    } else {
        OK = GetShareNameSD( hKey, &pSnSD, &cbData );
        RegCloseKey( hKey );
        if( !OK ) {
            return NDDE_REGISTRY_ERROR;
        }
        /*  Can have Ds rights on the ShareDB or DELETE on the ShareName. */
        /*  Make sure the caller has DelShare(Ds) access rights. */
        ImpersonateAndSetup( TRUE );
        dwDesiredAccess = DELETE;
        OK = NDdeShareAccessCheckAudit( lpszShareName, pSnSD, dwDesiredAccess,
                               &ShareDBGenericMapping, FALSE, TRUE,
                               &dwGrantedAccess, &fStatus );

    LocalFree(pSnSD);

        if( !OK || !fStatus) {
            dwDesiredAccess = NDDE_SHAREDB_DELETE;
            OK = NDdeShareAccessCheckAudit( lpszShareName, pDsDmSD, dwDesiredAccess,
                                       &ShareDBGenericMapping, FALSE, TRUE,
                                       &dwGrantedAccess, &fStatus );
            if( !(OK && fStatus)) {
                RevertAndCleanUp( TRUE );
                return NDDE_ACCESS_DENIED;
            }
        }
        RevertAndCleanUp( TRUE );

        lRtn = RegDeleteKeyW( HKEY_LOCAL_MACHINE, szShareDel );
        if( lRtn != ERROR_SUCCESS ) {
            NDDELogErrorW( MSG402, szShareDel, LogStringW( L"%d", lRtn ),
                LogStringW( L"%d", GetLastError() ), NULL );
            return NDDE_REGISTRY_ERROR;
        }
    }

    return NDDE_NO_ERROR;
}


/*
    Get Share Security
*/

unsigned long
wwNDdeGetShareSecurityA (
    unsigned char * lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME * 2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME * 2 );

    uRtn = wwNDdeGetShareSecurityW( lpwShareName, si, pSD, cbSD,
        bRemoteCall, lpcbSDRequired, lpnSizeReturned );

    return uRtn;
}

unsigned long
wwNDdeGetShareSecurityW (
    wchar_t *       lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor buffer
    unsigned long   cbSD,           // and length for SD buffer
    unsigned long   bRemoteCall,    // RPC client (not local) call
    unsigned long * lpcbSDRequired, // number of bytes needed
    unsigned long * lpnSizeReturned // number actually written
)
{
    WCHAR                   szShareSet[DDE_SHARE_KEY_MAX];
    LONG                    lRtn;
    HKEY                    hKey;
    BOOL                    OK;
    DWORD                   dwDesiredAccess = 0;
    DWORD                   dwGrantedAccess = 0;
    BOOL                    fStatus;
    PSECURITY_DESCRIPTOR    pSnSD;
    DWORD                   cbData;


    *lpnSizeReturned = 0L;      /* assume nothing is returned */

    if( lpszShareName == (wchar_t *) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }

    if (lpcbSDRequired == NULL) {
        return(NDDE_INVALID_PARAMETER);
    }
    // check for share existence - must exist for GetInfo
    wcscpy( szShareSet, DDE_SHARES_KEY_W );
    wcscat( szShareSet, L"\\" );
    if( wcslen(szShareSet) + wcslen(lpszShareName) + 1 >= DDE_SHARE_KEY_MAX ) {
        return NDDE_OUT_OF_MEMORY;
    }
    wcscat( szShareSet, lpszShareName );

    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
        szShareSet,
        0,
        KEY_READ,
        &hKey );
    if( lRtn != ERROR_SUCCESS )  {
    return NDDE_SHARE_NOT_EXIST;
    }

    /*  Make sure the caller has proper access rights. */
    /*  **********Read the key security info here. **************/
    OK = GetShareNameSD( hKey, &pSnSD, &cbData );
    RegCloseKey( hKey );
    if( !OK ) {
    return NDDE_REGISTRY_ERROR;
    }
    if (!bRemoteCall) {
    *lpcbSDRequired = cbData;          // number of bytes needed
    if ((cbSD < cbData) || (pSD == NULL) || (IsBadWritePtr(pSD,cbSD) != 0)) {
        LocalFree( pSnSD );
        return(NDDE_BUF_TOO_SMALL);
    } else {
        *lpnSizeReturned = cbData;
        memcpy(pSD, pSnSD, cbData);
        LocalFree( pSnSD );
        return(NDDE_NO_ERROR);
    }
    }

    ImpersonateAndSetup( bRemoteCall );
    if (si & (DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION |
          GROUP_SECURITY_INFORMATION)) {
    dwDesiredAccess = READ_CONTROL;
    }
    if (si & SACL_SECURITY_INFORMATION) {
    dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }
    OK = NDdeShareAccessCheckAudit( lpszShareName, pSnSD, dwDesiredAccess,
                   &ShareGenericMapping, FALSE, FALSE,
                   &dwGrantedAccess, &fStatus);
    RevertAndCleanUp( bRemoteCall );
    if( !OK || !fStatus ) {
    LocalFree( pSnSD );
    return NDDE_ACCESS_DENIED;
    }

    if ( (pSD != NULL) && (IsBadWritePtr(pSD,cbSD) != 0) ) {
        LocalFree( pSnSD );
        return(NDDE_INVALID_PARAMETER);
    }

    OK = GetPrivateObjectSecurity(
            pSnSD,              // ObjectDescriptor
            si,                 // SecurityInformation
            pSD,                // ResultantDescriptor
            cbSD,               // DescriptorLength
            lpcbSDRequired);    // ReturnLength

    LocalFree( pSnSD );

    if (!OK) {
    // just a guess.
    return NDDE_BUF_TOO_SMALL;
    } else {
        *lpnSizeReturned = GetSecurityDescriptorLength(pSD);
    }

    return(NDDE_NO_ERROR);
}


/*
    Set Share Security
*/

unsigned long
wwNDdeSetShareSecurityA (
    unsigned char * lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor
    unsigned long   sdl             // and length
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME * 2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME * 2 );

    uRtn = wwNDdeSetShareSecurityW( lpwShareName, si, pSD, sdl );

    return uRtn;
}

unsigned long
wwNDdeSetShareSecurityW (
    wchar_t *       lpszShareName,  // name of share
    unsigned long   si,             // security info
    byte *          pSD,            // security descriptor
    unsigned long   sdl             // and length
)
{
    ACCESS_MASK             dwDesiredAccess = 0;
    ACCESS_MASK             dwGrantedAccess;
    BOOL                    fStatus;
    WCHAR                   szShareSet[DDE_SHARE_KEY_MAX];
    LONG                    lRtn;
    HKEY                    hKey;
    BOOL                    OK;
    DWORD            cbSDold;
    PSECURITY_DESCRIPTOR    pSDold;
    LONG                    lSerialNumber[2];
    DWORD                   cbData;
    HANDLE            hClientToken;

    if (pSD) {
        if (!IsValidSecurityDescriptor(pSD)) {
            return(NDDE_INVALID_SECURITY_DESC);
        }
    } else {
        return(NDDE_INVALID_SECURITY_DESC);
    }

    if( lpszShareName == (wchar_t *) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( !NDdeIsValidShareNameW(lpszShareName) ) {
        return NDDE_INVALID_SHARE;
    }

    // check for share existence - must exist for SetInfo
    wcscpy( szShareSet, DDE_SHARES_KEY_W );
    wcscat( szShareSet, L"\\" );
    if( wcslen(szShareSet) + wcslen(lpszShareName) + 1 >= DDE_SHARE_KEY_MAX ) {
        return NDDE_OUT_OF_MEMORY;
    }
    wcscat( szShareSet, lpszShareName );

    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
        szShareSet,
        0,
        KEY_WRITE | KEY_READ,
        &hKey );
    if( lRtn != ERROR_SUCCESS )  {
    return NDDE_ACCESS_DENIED;
    }

    /*  **********Read the key security info here. **************/
    OK = GetShareNameSD( hKey, &pSDold, &cbData );
    if( !OK ) {
        RegCloseKey( hKey );
        return NDDE_REGISTRY_ERROR;
    }

    ImpersonateAndSetup( TRUE );

//
    if (si & DACL_SECURITY_INFORMATION) {
    dwDesiredAccess = WRITE_DAC;
    }

    if (si & (GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION)) {
    dwDesiredAccess |= WRITE_OWNER;
    }

    if (si & SACL_SECURITY_INFORMATION) {
    dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    OK = NDdeShareAccessCheckAudit( lpszShareName, pSDold, dwDesiredAccess,
                   &ShareGenericMapping, FALSE, FALSE,
                   &dwGrantedAccess, &fStatus);

    if (!OK || !fStatus ) {
        LocalFree( pSDold );
        RegCloseKey(hKey);
        RevertAndCleanUp( TRUE );
        return NDDE_ACCESS_DENIED;
    }

    if (!GetTokenHandleRead( &hClientToken ) ) {
        LocalFree( pSDold );
        RegCloseKey(hKey);
        RevertAndCleanUp( TRUE );

    // Likely Access-denied
        return NDDE_ACCESS_DENIED;
    }
//
    RevertAndCleanUp( TRUE );
    OK = SetPrivateObjectSecurity(si,    // si
        pSD,            // psdSource
        &pSDold,            // lppsdTarget
        &ShareGenMap,        // pgm
        hClientToken);        // hClientToken

    CloseHandle(hClientToken);

    if (!OK) {
        free(pSDold);
        RegCloseKey(hKey);

        // failed, possibly access denied, insufficient privilege,
        // out of memory...  all in a way are ACCESS_DENIED.

        return NDDE_ACCESS_DENIED;
    }

    cbSDold = GetSecurityDescriptorLength(pSDold);

    OK = UpdateDSDMModifyId(lSerialNumber);
    if (!OK) {
        LocalFree(pSDold);
        RegCloseKey( hKey );
        return NDDE_REGISTRY_ERROR;
    }

    if (pSDold) {
    lRtn = RegSetValueExW( hKey,
           L"SecurityDescriptor",
           0,
           REG_BINARY,
           (LPBYTE)pSDold,
           cbSDold );

    DestroyPrivateObjectSecurity(&pSDold);
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Set Share SD: %d", lRtn));
        }
#endif
        RegCloseKey( hKey );
        return NDDE_REGISTRY_ERROR;
    }
    } else {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }

    OK = UpdateShareModifyId(hKey, lSerialNumber);

    // RegCloseKey(hKey); ALREADY CLOSED BY UpdateShareModifyId

    if( !OK ) {
    return NDDE_REGISTRY_ERROR;
    }

    return NDDE_NO_ERROR;
}


/*
    Enumerate Shares
*/

unsigned long
wwNDdeShareEnumA (
    unsigned long   nLevel,             //  0 for null separated 00 terminated list
    byte *          lpBuffer,           // pointer to buffer
    unsigned long   cBufSize,           // size of buffer
    unsigned long * lpnEntriesRead,     // number of names returned
    unsigned long * lpcbTotalAvailable, // number of bytes available
    unsigned long * lpnSizeToReturn     // num bytes for Rpc to ret to client
)
{
    DWORD       cbTotalBytes;
    DWORD       cbEntriesRead;
    DWORD       cbSizeToReturn;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpLocalBuf;

    *lpnSizeToReturn = 0;

    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( !lpnEntriesRead || !lpcbTotalAvailable ) {
        return NDDE_INVALID_PARAMETER;
    }


    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    if (cBufSize > 0) {
        lpLocalBuf = (LPWSTR)LocalAlloc( LPTR, sizeof(WCHAR)*cBufSize );
        if( lpLocalBuf == NULL ) {
            MEMERROR();
            return NDDE_OUT_OF_MEMORY;
        }
    } else {
        lpLocalBuf = (LPWSTR)&cbTotalBytes;
    }

    enumRet    = wwNDdeShareEnumW( nLevel,
                        (LPBYTE)lpLocalBuf, sizeof(WCHAR)*cBufSize,
                        &cbEntriesRead, &cbTotalBytes, &cbSizeToReturn );

    *lpnEntriesRead     = cbEntriesRead;
    *lpcbTotalAvailable = cbTotalBytes / sizeof(WCHAR);
    *lpnSizeToReturn    = cbSizeToReturn / sizeof(WCHAR);

    if( enumRet == NDDE_NO_ERROR ) {
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpLocalBuf, cbTotalBytes / sizeof(WCHAR),
                        lpBuffer, cbTotalBytes / sizeof(WCHAR),
                            NULL, NULL );
    }
    if (cBufSize > 0) {
        LocalFree( lpLocalBuf );
    }
    return( enumRet );
}

unsigned long
wwNDdeShareEnumW (
    unsigned long   nLevel,             //  0 for null separated 00 terminated list
    byte *          lpBuffer,           // pointer to buffer
    unsigned long   cBufSize,           // size of buffer
    unsigned long * lpnEntriesRead,     // number of names returned
    unsigned long * lpcbTotalAvailable, // number of bytes available
    unsigned long * lpnSizeToReturn     // num bytes for Rpc to ret to client
)
{
    WCHAR       szShareName[ MAX_NDDESHARENAME ];
    DWORD       cbShareName;
    DWORD       cbTotalAvailable;
    DWORD       cbEntriesRead;
    UINT        ret;
    HKEY        hKeyRoot;
    DWORD       cbLeft;
    DWORD       cbThis;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpszTarget;
    int         idx = 0;
    BOOL        OK;
    DWORD       dwDesiredAccess, dwGrantedAccess;
    BOOL        fStatus;

    *lpnSizeToReturn = 0;

    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( !lpnEntriesRead || !lpcbTotalAvailable ) {
        return NDDE_INVALID_PARAMETER;
    }

    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    ImpersonateAndSetup( TRUE );

    /*  Make sure the caller has EnumShare(Ls) access rights. */
    dwDesiredAccess = NDDE_SHAREDB_LIST;
    OK = NDdeShareAccessCheckAudit( L"ShareDB", pDsDmSD, dwDesiredAccess,
                               &ShareDBGenericMapping, FALSE, FALSE,
                               &dwGrantedAccess, &fStatus );

    RevertAndCleanUp( TRUE );
    if( !OK || !fStatus ) {
        return NDDE_ACCESS_DENIED;
    }

    cbLeft = cBufSize;
    if( cbLeft > 0 )  {
        cbLeft -= sizeof(WCHAR);        // but leave space for double-NULL
    }
    cbTotalAvailable = sizeof(WCHAR);   // leave space for double-NULL
    cbEntriesRead    = 0;
    lpszTarget       = (LPWSTR)lpBuffer;

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE, DDE_SHARES_KEY,
        0, KEY_READ, &hKeyRoot );
    if( ret == ERROR_SUCCESS )  {
        while( ret == ERROR_SUCCESS )  {
            cbShareName = sizeof(szShareName)/sizeof(WCHAR);
            ret = RegEnumKeyExW( hKeyRoot, idx++, szShareName,
                &cbShareName, NULL, NULL, NULL, NULL );
            if( ret == ERROR_SUCCESS )  {
                cbThis = (cbShareName + 1) * sizeof(WCHAR);
                cbTotalAvailable += cbThis;
                if( enumRet == NDDE_NO_ERROR )  {
                    if( cbThis > cbLeft )  {
                        enumRet = NDDE_BUF_TOO_SMALL;
                    } else {
                        /* copy this string in */
                        wcscpy( lpszTarget, szShareName );
                        lpszTarget += cbShareName;
                        *lpszTarget++ = L'\0';
                        /* decrement what's left */
                        cbLeft -= cbThis;
                        cbEntriesRead++;
                    }
                }
            }
        }
        RegCloseKey( hKeyRoot );
    }
    *lpnEntriesRead      = cbEntriesRead;
    *lpcbTotalAvailable  = cbTotalAvailable;
    if( enumRet == NDDE_NO_ERROR ) {
        if( lpszTarget )  {
            *lpszTarget = L'\0';
        }
        *lpnSizeToReturn = cbTotalAvailable;
    }

    return( enumRet );
}


/*
    Set Trusted Share
*/

unsigned long
wwNDdeSetTrustedShareA(
    unsigned char * lpszShareName,      // name of share
    unsigned long   dwOptions           // trust share options
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME * 2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME * 2 );

    uRtn = wwNDdeSetTrustedShareW( lpwShareName, dwOptions );

    return uRtn;
}

unsigned long
wwNDdeSetTrustedShareW(
    wchar_t *       lpszShareName,      // name of share
    unsigned long   dwOptions           // trust share options
)
{
    LONG    lRet;
    DWORD   dwDisp;
    HKEY    hKeyRoot, hSubKey, hCurrentUserKey;
    LONG    lSerialNumber[2];
    DWORD   cbSerialNumber = 2 * sizeof( LONG );
    UINT    uData;
    DWORD    cbData = sizeof(uData);
    LONG    RetStatus = NDDE_NO_ERROR;

    if (lpszShareName == NULL) {
        return(NDDE_INVALID_PARAMETER);
    }

    if (!GetShareSerialNumber(lpszShareName, (LPBYTE)&lSerialNumber)) {
        lSerialNumber[0] = 0;
        lSerialNumber[1] = 0;
    }

    ImpersonateAndSetup( TRUE );

    hCurrentUserKey = (HKEY)OpenCurrentUserKey(KEY_ALL_ACCESS);
    if (hCurrentUserKey == 0) {
        RevertAndCleanUp( TRUE );
        return(NDDE_TRUST_SHARE_FAIL);
    }

    lRet = RegCreateKeyExW( hCurrentUserKey,
        szTrustedShareKey,
        0, L"",
        REG_OPTION_NON_VOLATILE,
        KEY_CREATE_SUB_KEY,
        NULL,
        &hKeyRoot,
        &dwDisp);
    if( lRet == ERROR_SUCCESS)  {   /* must be have access */
        if ((dwOptions == 0) || (dwOptions & NDDE_TRUST_SHARE_DEL)) {
            /*  Delete a Trust Share */
            lRet = RegDeleteKeyW(hKeyRoot, lpszShareName);
            RegCloseKey(hKeyRoot);
            if (lRet != ERROR_SUCCESS) {
#if DBG
                if (bDebugDSDMErrors) {
                    DPRINTF(("Trusted Share Key Delete Failed: %d", lRet));
                }
#endif
                RetStatus = NDDE_TRUST_SHARE_FAIL;
            }
        } else {    /* Create or Modify a Trust Share */
            lRet = RegCreateKeyExW( hKeyRoot,
                lpszShareName,
                0, NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE | KEY_READ,
                NULL,
                &hSubKey,
                &dwDisp);
            if (lRet != ERROR_SUCCESS) { /* fail to create or open */
#if DBG
                if (bDebugDSDMErrors) {
                    DPRINTF(("Trusted Share Key Open/Create Failed: %d", lRet));
                }
#endif
                RegCloseKey(hKeyRoot);
                RetStatus = NDDE_TRUST_SHARE_FAIL;
            } else {
                lRet = RegSetValueEx( hSubKey,
                   KEY_MODIFY_ID,
                   0,
                   REG_BINARY,
                   (LPBYTE)&lSerialNumber, cbSerialNumber );
#if DBG
                if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                    DPRINTF(("Unable to set trusted share serial number."));
                }
#endif
                if (dwOptions & NDDE_TRUST_CMD_SHOW) {
                    uData = dwOptions & NDDE_CMD_SHOW_MASK;
                    lRet = RegSetValueEx( hSubKey,
                        KEY_CMDSHOW,
                        0,
                        REG_DWORD,
                        (LPBYTE)&uData,
                        cbData );
#if DBG
                    if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                        DPRINTF(("Unable to set trusted share command show."));
                    }
#endif
                } else {
                    lRet = RegDeleteValue( hSubKey, KEY_CMDSHOW);
                }
                uData = (dwOptions & NDDE_TRUST_SHARE_START ? 1 : 0);
                lRet = RegSetValueEx( hSubKey,
                    KEY_START_APP,
                    0,
                    REG_DWORD,
                    (LPBYTE)&uData,
                    cbData );
#if DBG
                if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                    DPRINTF(("Unable to set trusted share start app flag."));
                }
#endif
                uData = (dwOptions & NDDE_TRUST_SHARE_INIT ? 1 : 0);
                lRet = RegSetValueEx( hSubKey,
                    KEY_INIT_ALLOWED,
                    0,
                    REG_DWORD,
                    (LPBYTE)&uData,
                    cbData );
#if DBG
                if ((lRet != ERROR_SUCCESS) && bDebugDSDMErrors) {
                    DPRINTF(("Unable to set trusted share int allowed flag."));
                }
#endif
                RegCloseKey(hSubKey);
                RegCloseKey(hKeyRoot);
            }
        }
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open current user trusted shares root key for setting: %d", lRet));
            DPRINTF(("   %ws", szTrustedShareKey));
        }
#endif
        RetStatus = NDDE_TRUST_SHARE_FAIL;
    }
    RegCloseKey( hCurrentUserKey );
    RevertAndCleanUp( TRUE );
    return(RetStatus);
}


/*
    Get Trusted Share Options
*/

unsigned long
wwNDdeGetTrustedShareA(
    unsigned char * lpszShareName,      // name of share
    unsigned long * lpdwOptions,        // ptr to trust share opt
    unsigned long * lpdwShareModId0,    // ptr to trust share opt
    unsigned long * lpdwShareModId1     // ptr to trust share opt
)
{
    UINT        uRtn;
    WCHAR       lpwShareName[MAX_NDDESHARENAME * 2];

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME * 2 );

    uRtn = wwNDdeGetTrustedShareW( lpwShareName,
        lpdwOptions, lpdwShareModId0, lpdwShareModId1 );

    return uRtn;
}

unsigned long
wwNDdeGetTrustedShareW(
    wchar_t *       lpszShareName,      // name of share
    unsigned long * lpdwOptions,        // ptr to trust share opt
    unsigned long * lpdwShareModId0,    // ptr to trust share opt
    unsigned long * lpdwShareModId1     // ptr to trust share opt
)
{
    LONG    lRet;
    UINT    len;
    HKEY    hKeyRoot, hCurrentUserKey;
    UINT    uData;
    LONG    lSerialId[2];
    DWORD    cbData = sizeof(uData);
    DWORD   dwType;
    DWORD   dwOptions = 0;
    PWCHAR  lpTrustedShare;

    if (lpszShareName == NULL) {
        return(NDDE_INVALID_PARAMETER);
    }

    len = (wcslen(szTrustedShareKey) + wcslen(lpszShareName) + 2) * sizeof(WCHAR);
    lpTrustedShare = LocalAlloc(LPTR, len);
    if (lpTrustedShare == NULL) {
        MEMERROR();
        return(NDDE_OUT_OF_MEMORY);
    }
    wcscpy(lpTrustedShare, szTrustedShareKey);
    wcscat(lpTrustedShare, L"\\");
    wcscat(lpTrustedShare, lpszShareName);

    ImpersonateAndSetup( TRUE );

    hCurrentUserKey = (HKEY)OpenCurrentUserKey(KEY_ALL_ACCESS);
    if (hCurrentUserKey == 0) {
        RevertAndCleanUp( TRUE );
        LocalFree(lpTrustedShare);
        return(NDDE_TRUST_SHARE_FAIL);
    }


    lRet = RegOpenKeyExW( hCurrentUserKey, lpTrustedShare,
        0, KEY_QUERY_VALUE, &hKeyRoot );
    RevertAndCleanUp(TRUE);
    if( lRet == ERROR_SUCCESS )  {   /* must be have access */
        lRet = RegQueryValueEx(hKeyRoot, KEY_CMDSHOW, NULL,
                &dwType, (LPBYTE)&uData, &cbData);
        if (lRet == ERROR_SUCCESS) {
            dwOptions = uData;
            dwOptions |= NDDE_TRUST_CMD_SHOW;
        }
        lRet = RegQueryValueEx(hKeyRoot, KEY_START_APP, NULL,
                &dwType, (LPBYTE)&uData, &cbData);
        if (lRet == ERROR_SUCCESS) {
            if (uData == 1)
                dwOptions |= NDDE_TRUST_SHARE_START;
        }
        lRet = RegQueryValueEx(hKeyRoot, KEY_INIT_ALLOWED, NULL,
                &dwType, (LPBYTE)&uData, &cbData);
        if (lRet == ERROR_SUCCESS) {
            if (uData == 1)
                dwOptions |= NDDE_TRUST_SHARE_INIT;
        }
        cbData = 2 * sizeof(LONG);
        lRet = RegQueryValueEx(hKeyRoot, KEY_MODIFY_ID, NULL,
                &dwType, (LPBYTE)&lSerialId, &cbData);
        if (lRet == ERROR_SUCCESS) {
            *lpdwShareModId0 = lSerialId[0];
            *lpdwShareModId1 = lSerialId[1];
        } else {
#if DBG
            if (bDebugDSDMErrors) {
                DPRINTF(("Unable to access trusted share serial number: %d", lRet));
            }
#endif
            *lpdwShareModId0 = 0;
            *lpdwShareModId1 = 0;
        }

        *lpdwOptions = dwOptions;
        RegCloseKey(hKeyRoot);
        RegCloseKey( hCurrentUserKey );
        LocalFree(lpTrustedShare);
        return(NDDE_NO_ERROR);
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open current user trusted shares root key for getting: %d", lRet));
            DPRINTF(("   %ws", lpTrustedShare));
        }
#endif
        RegCloseKey( hCurrentUserKey );
        LocalFree(lpTrustedShare);
        return(NDDE_TRUST_SHARE_FAIL);
    }
}


/*
    Enumerate Trusted Shares
*/
unsigned long
wwNDdeTrustedShareEnumA (
    unsigned long   nLevel,                 /* 0 (0 sep, 00 term) */
    byte           *lpBuffer,               /* pointer to buffer */
    unsigned long   cBufSize,               /* size of buffer */
    unsigned long  *lpnEntriesRead,         /* num names returned */
    unsigned long  *lpcbTotalAvailable,     /* num bytes available */
    unsigned long  *lpnSizeToReturn    )
{
    DWORD       cbTotalBytes;
    DWORD       cbEntriesRead;
    DWORD       cbSizeToReturn;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpLocalBuf;

    *lpnSizeToReturn = 0;
    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( !lpnEntriesRead || !lpcbTotalAvailable ) {
        return NDDE_INVALID_PARAMETER;
    }

    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }


    if (cBufSize > 0) {
        lpLocalBuf = (LPWSTR)LocalAlloc( LPTR, sizeof(WCHAR)*cBufSize );
        if( lpLocalBuf == NULL ) {
            MEMERROR();
            return NDDE_OUT_OF_MEMORY;
        }
    } else {
        lpLocalBuf = (LPWSTR)&cbTotalBytes; /* fill in a dummy, NULLs bad */
    }

    enumRet    = wwNDdeTrustedShareEnumW( nLevel,
                        (LPBYTE)lpLocalBuf, sizeof(WCHAR)*cBufSize,
                        &cbEntriesRead, &cbTotalBytes, &cbSizeToReturn );

    *lpnEntriesRead     = cbEntriesRead;
    *lpcbTotalAvailable = cbTotalBytes / sizeof(WCHAR);
    *lpnSizeToReturn    = cbSizeToReturn / sizeof(WCHAR);

    if( enumRet == NDDE_NO_ERROR ) {
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpLocalBuf, cbTotalBytes / sizeof(WCHAR),
                        lpBuffer, cbTotalBytes / sizeof(WCHAR),
                            NULL, NULL );
    }
    if (cBufSize > 0) {
        LocalFree( lpLocalBuf );
    }
    return( enumRet );
}

unsigned long
wwNDdeTrustedShareEnumW (
    unsigned long       nLevel,             /* 0 (0 sep, 00 term) */
    byte               *lpBuffer,           /* pointer to buffer */
    unsigned long       cBufSize,           /* size of buffer */
    unsigned long      *lpnEntriesRead,     /* num names returned */
    unsigned long      *lpcbTotalAvailable, /* num bytes available */
    unsigned long      *lpnSizeToReturn)
{
    WCHAR       szShareName[ MAX_NDDESHARENAME ];
    DWORD       cbShareName;
    DWORD       cbTotalAvailable;
    DWORD       cbEntriesRead;
    DWORD       dwDisp;
    LONG        lRet;
    HKEY        hKeyRoot, hCurrentUserKey;
    DWORD       cbLeft;
    DWORD       cbThis;
    UINT        enumRet = NDDE_NO_ERROR;
    LPWSTR      lpszTarget;
    int         idx = 0;

    *lpnSizeToReturn = 0;
    if ( nLevel != 0 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( !lpnEntriesRead || !lpcbTotalAvailable ) {
        return NDDE_INVALID_PARAMETER;
    }

    // lpBuffer can be NULL if cBufSize is 0, to get needed buffer size
    if ( (lpBuffer == NULL) && (cBufSize != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // if lpBuffer is not NULL, need to validate it up to cBufSize bytes
    if ( (lpBuffer != NULL) && (IsBadWritePtr(lpBuffer,cBufSize) != 0) ) {
        return NDDE_INVALID_PARAMETER;
    }


    /* Assume as System Service WE HAVE RIGHTS! */

    cbLeft = cBufSize;
    if( cbLeft > 0 )  {
        cbLeft -= sizeof(WCHAR);        // but leave space for double-NULL
    }
    cbTotalAvailable = sizeof(WCHAR);   // leave space for double-NULL
    cbEntriesRead    = 0;
    lpszTarget       = (LPWSTR)lpBuffer;

    ImpersonateAndSetup( TRUE );

    hCurrentUserKey = (HKEY)OpenCurrentUserKey(KEY_ALL_ACCESS);
    if (hCurrentUserKey == 0) {
        RevertAndCleanUp( TRUE );
        return(NDDE_TRUST_SHARE_FAIL);
    }

    lRet = RegCreateKeyExW(
            hCurrentUserKey,
            szTrustedShareKey,
            0,
            L"",
            REG_OPTION_NON_VOLATILE,
            KEY_ENUMERATE_SUB_KEYS,
            NULL,
            &hKeyRoot,
            &dwDisp);
    if( lRet == ERROR_SUCCESS )  {
        while( lRet == ERROR_SUCCESS )  {
            cbShareName = sizeof(szShareName);
            lRet = RegEnumKeyExW( hKeyRoot, idx++, szShareName,
                &cbShareName, NULL, NULL, NULL, NULL );
            if( lRet == ERROR_SUCCESS )  {
                cbThis = (cbShareName + 1) * sizeof(WCHAR);
                cbTotalAvailable += cbThis;
                if( enumRet == NDDE_NO_ERROR )  {
                    if( cbThis > cbLeft )  {
                        enumRet = NDDE_BUF_TOO_SMALL;
                    } else {
                        /* copy this string in */
                        wcscpy( lpszTarget, szShareName );
                        lpszTarget += cbShareName;
                        *lpszTarget++ = L'\0';
                        /* decrement what's left */
                        cbLeft -= cbThis;
                        cbEntriesRead++;
                    }
                }
            } else {
                if (lRet != ERROR_NO_MORE_ITEMS) {
#if DBG
                    if (bDebugDSDMErrors) {
                        DPRINTF(("Error while enumerating trusted shares: %d", lRet));
                    }
#endif
                    RegCloseKey(hKeyRoot);
                    RegCloseKey( hCurrentUserKey );
                    RevertAndCleanUp( TRUE );
                    return(NDDE_TRUST_SHARE_FAIL);
                }
            }
        }
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open current user trusted shares key for enumeration: %d", lRet));
            DPRINTF(("   %ws", szTrustedShareKey));
        }
#endif
        RegCloseKey( hCurrentUserKey );
        RevertAndCleanUp( TRUE );
        return(NDDE_TRUST_SHARE_FAIL);
    }
    RegCloseKey( hKeyRoot );
    RegCloseKey( hCurrentUserKey );
    RevertAndCleanUp( TRUE );

    *lpnEntriesRead      = cbEntriesRead;
    *lpcbTotalAvailable  = cbTotalAvailable;
    if( enumRet == NDDE_NO_ERROR ) {
        if( lpszTarget )  {
            *lpszTarget = L'\0';
        }
        *lpnSizeToReturn = ((cbTotalAvailable == sizeof(WCHAR)) ? 0 : cbTotalAvailable);
    }
    return( (lpBuffer == NULL) ? NDDE_BUF_TOO_SMALL : enumRet );
}


/*
    Get DDE Share Info
*/

unsigned long
wwNDdeShareGetInfoW (
    wchar_t        *lpszShareName,      // name of share
    unsigned long   nLevel,             // info level must be 2
    byte           *lpBuffer,           // gets struct
    unsigned long   cBufSize,           // sizeof buffer
    unsigned long  *lpnTotalAvailable,  // number of bytes available
    unsigned short *lpnItems,           // item mask for partial getinfo
                                        // (must be 0)
    unsigned long   bRemoteCall,        // RPC client (not local) call
    unsigned long  *lpnSizeToReturn,
    unsigned long  *lpnSn,
    unsigned long  *lpnAt,
    unsigned long  *lpnIt
)
        /*  This function has an extra argument, bRemoteCall, that allows
            NetDDE to call locally.  In this case, we have to avoid
            the RpcImpersonateClient and RevertToSelf calls.
        */

{
    DWORD               cbRequired;
    HKEY                hKey;
    WCHAR               szKeyName[ DDE_SHARE_KEY_MAX ];
    WCHAR               buf[ 10000 ];
    LONG                lRtn;
    PUNDDESHAREINFO     lpNDDEinfo;
    LPWSTR              lpszTarget;
    DWORD               cbData;
    DWORD               dwType;
    LONG                nItems;
    BOOL                OK;
    DWORD               dwDesiredAccess, dwGrantedAccess;
    BOOL                fStatus;
    PSECURITY_DESCRIPTOR pKeySD;
    LPWSTR              pOldStr, pNewStr, pStaticStr;
    LONG                lShareType;
    LONG                lItemList;
    PUNDDESHAREINFO     lpUDdeShare;


    *lpnSizeToReturn = 0;

    if ( lpszShareName == (LPWSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( lpnItems == (LPWORD) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }
    if ( nLevel        != 2 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( !NDdeIsValidShareNameW ( lpszShareName ) )  {
        return NDDE_INVALID_SHARE;
    }

    wsprintfW( szKeyName, L"%ws\\%ws", DDE_SHARES_KEY_W, lpszShareName);
    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE, szKeyName,
        0, KEY_READ, &hKey );
    if( lRtn == ERROR_SUCCESS )  {
        /*  Make sure the caller has GetShareInfo(R) access rights. */
        /*  **********Read the key security info here. **************/
        if (bRemoteCall) {
            OK = GetShareNameSD( hKey, &pKeySD, &cbData );
            if (!OK) {
                RegCloseKey( hKey );
                RevertAndCleanUp( bRemoteCall );
                return NDDE_ACCESS_DENIED;
            }
            dwDesiredAccess = NDDE_SHARE_READ;
            ImpersonateAndSetup( bRemoteCall );
            OK = NDdeShareAccessCheckAudit( lpszShareName, pKeySD, dwDesiredAccess,
                                           &ShareGenericMapping, FALSE, FALSE,
                                           &dwGrantedAccess, &fStatus);
            RevertAndCleanUp( bRemoteCall );
            LocalFree( pKeySD );
            if( !OK || !fStatus ) {
#if DBG
                if (bDebugDSDMErrors) {
                    DPRINTF(("Share \"%ws\" access validation error: %d %0X",
                        lpszShareName, GetLastError(), fStatus));
                }
#endif
                RegCloseKey( hKey );
                return NDDE_ACCESS_DENIED;
            }
        }

        /*  Set the key values. */
        cbRequired = sizeof(NDDESHAREINFO);
        cbData = sizeof(buf);
        lRtn = RegQueryValueExW( hKey,
                       L"ShareName",
                       NULL,
                       &dwType,
                       (LPBYTE)buf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = sizeof(buf);
        lRtn = RegQueryValueExW( hKey,
                       L"OldStyleLink",
                       NULL,
                       &dwType,
                       (LPBYTE)buf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = sizeof(buf);
        lRtn = RegQueryValueExW( hKey,
                       L"NewStyleLink",
                       NULL,
                       &dwType,
                       (LPBYTE)buf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = sizeof(buf);
        lRtn = RegQueryValueExW( hKey,
                       L"StaticDataLink",
                       NULL,
                       &dwType,
                       (LPBYTE)buf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;
        cbRequired++;                   /*  Allow for the extra NULL */

        cbData = sizeof(buf);
        lRtn = RegQueryValueExW( hKey,
                   L"ItemList",
                   NULL,
                   &dwType,
                   (LPBYTE)buf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData;

        cbData = sizeof(buf);
        lRtn = RegQueryValueExW( hKey,
                       L"SecurityDescriptor",
                       NULL,
                       &dwType,
                       (LPBYTE)buf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        cbRequired += cbData + 3; // leave room in case we need to round up

        cbData = sizeof(buf);
        lRtn = RegQueryValueExW( hKey,
                       L"NumItems",
                       NULL,
                       &dwType,
                       (LPBYTE)buf, &cbData );
        if( lRtn != ERROR_SUCCESS ) {
            RegCloseKey( hKey );
            return NDDE_REGISTRY_ERROR;
        }
        nItems = *((LPLONG)buf);
        cbRequired += cbData;

        *lpnTotalAvailable = cbRequired;
        if( lpnItems )  {
            *lpnItems = (WORD)nItems;
        }

        if( (cbRequired <= cBufSize) &&
            (IsBadWritePtr(lpBuffer,cbRequired) == 0) ) {

            lpNDDEinfo = (PUNDDESHAREINFO)lpBuffer;
            lpszTarget = (LPWSTR)(lpBuffer + sizeof(UNDDESHAREINFO));
            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"ShareName",
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            wcscpy( lpszTarget, buf );
            lpNDDEinfo->lpszShareName = lpszTarget;
            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            /* Check share name for corruption. */
            if( lstrcmpiW( lpNDDEinfo->lpszShareName, lpszShareName ) != 0 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"OldStyleLink",
                           NULL,
                           &dwType,
                           (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->lpszAppTopicList = lpszTarget;
            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"NewStyleLink",
                           NULL,
                           &dwType,
                           (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"StaticDataLink",
                           NULL,
                           &dwType,
                           (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            *lpszTarget++ = L'\0';
            if ( !NDdeParseAppTopicListW ( lpNDDEinfo->lpszAppTopicList,
                                          &pOldStr, &pNewStr, &pStaticStr,
                                          &lShareType) ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                       L"ItemList",
                       NULL,
                       &dwType,
                       (LPBYTE)lpszTarget, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->lpszItemList = lpszTarget;
            lpszTarget = (LPWSTR) ((LPBYTE)lpszTarget + cbData);
            if ( !NDdeParseItemList ( lpNDDEinfo->lpszItemList,
                                      nItems, &lItemList )) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"Revision",
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->lRevision = *((LPLONG)buf);
            /* Check Revision for corruption. */
            if( lpNDDEinfo->lRevision != 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"ShareType",
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->lShareType = *((LPLONG)buf);
            if( lpNDDEinfo->lShareType != lShareType ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"SharedFlag",
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->fSharedFlag = *((LPLONG)buf);
            /* Check share flag for corruption. */
            if( lpNDDEinfo->fSharedFlag > 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"Service",
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->fService = *((LPLONG)buf);
            if( lpNDDEinfo->fService > 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"StartAppFlag",
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->fStartAppFlag = *((LPLONG)buf);
            if( lpNDDEinfo->fStartAppFlag > 1 ) {
                RegCloseKey( hKey );
                return NDDE_SHARE_DATA_CORRUPTED;
            }

            cbData = sizeof(buf);
            lRtn = RegQueryValueExW( hKey,
                           L"fuCmdShow",
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            lpNDDEinfo->nCmdShow = *((LPLONG)buf);

            cbData = sizeof(buf);
            lRtn = RegQueryValueEx( hKey,
                           KEY_MODIFY_ID,
                           NULL,
                           &dwType,
                           (LPBYTE)buf, &cbData );
            if( lRtn != ERROR_SUCCESS ) {
                RegCloseKey( hKey );
                return NDDE_REGISTRY_ERROR;
            }
            memcpy( &lpNDDEinfo->qModifyId[0], buf, cbData );

            lpNDDEinfo->cNumItems = nItems;
        } else {
            RegCloseKey( hKey );
            return NDDE_BUF_TOO_SMALL;
        }
        RegCloseKey( hKey );
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open DDE share \"%ws\": %d",
                lpszShareName, lRtn));
        }
#endif
        return NDDE_SHARE_NOT_EXIST;
    }

    if (IsBadWritePtr(lpBuffer,sizeof(NDDESHAREINFO)) != 0)
        return NDDE_BUF_TOO_SMALL;
    else  {
        lpUDdeShare = (PUNDDESHAREINFO)lpBuffer;
        *lpnSn = (LONG)((LPBYTE)lpUDdeShare->lpszShareName - lpBuffer);
        *lpnAt = (LONG)((LPBYTE)lpUDdeShare->lpszAppTopicList - lpBuffer);
        *lpnIt = (LONG)((LPBYTE)lpUDdeShare->lpszItemList - lpBuffer);
    }

    *lpnSizeToReturn = *lpnTotalAvailable;
    return NDDE_NO_ERROR;
}

/*
 * We have to keep ConvertNDdeToAnsi and wwNDdeShareGetInfoA around till
 * netdde.exe is UNICODIZED because it calls this.   (SanfordS)
 */


int ConvertNDdeToAnsii(
    PUNDDESHAREINFO lpUDdeShare,
    PNDDESHAREINFO  lpDdeShare,
    int             ccbBuffer )
{
    int         cbRequired;
    LPWSTR      pStr;
    LPBYTE      lpszTarget;
    int         cchAppTopicList, nAppTopicStart;
    int         cchShareName;
    int         cchItemList;

    /* Compute size required. */
    cbRequired    = sizeof( NDDESHAREINFO );
    cchShareName  = WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                    lpUDdeShare->lpszShareName, -1, NULL, 0, NULL, NULL );
    cbRequired   += sizeof(CHAR) * cchShareName;

    pStr = lpUDdeShare->lpszAppTopicList;
    nAppTopicStart = cbRequired;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    pStr = pStr + wcslen( pStr ) + 1;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    pStr = pStr + wcslen( pStr ) + 1;
    cbRequired += sizeof(CHAR) * WideCharToMultiByte( CP_ACP,
        WC_COMPOSITECHECK, pStr, -1, NULL, 0, NULL, NULL );
    cbRequired += sizeof(CHAR);         /* The extra NULL */
    cchAppTopicList = (cbRequired - nAppTopicStart) / sizeof( CHAR );

    cchItemList = LengthMultiSzW( lpUDdeShare->lpszItemList );
    cbRequired += sizeof(CHAR) * cchItemList;

    if( (ccbBuffer >= cbRequired) && (lpDdeShare != NULL) ) {
        lpDdeShare->lRevision     = lpUDdeShare->lRevision;
        lpDdeShare->lShareType    = lpUDdeShare->lShareType;
        lpDdeShare->fSharedFlag   = lpUDdeShare->fSharedFlag;
        lpDdeShare->fService      = lpUDdeShare->fService;
        lpDdeShare->fStartAppFlag = lpUDdeShare->fStartAppFlag;
        lpDdeShare->nCmdShow      = lpUDdeShare->nCmdShow;
        lpDdeShare->qModifyId[0]  = lpUDdeShare->qModifyId[0];
        lpDdeShare->qModifyId[1]  = lpUDdeShare->qModifyId[1];
        lpDdeShare->cNumItems     = lpUDdeShare->cNumItems;

        lpszTarget = ((LPBYTE)lpDdeShare + sizeof( NDDESHAREINFO ));
        lpDdeShare->lpszShareName = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszShareName, -1,
                        lpDdeShare->lpszShareName, cchShareName, NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchShareName;

        lpDdeShare->lpszAppTopicList = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszAppTopicList, cchAppTopicList,
                        lpDdeShare->lpszAppTopicList, cchAppTopicList,
                            NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchAppTopicList;

        lpDdeShare->lpszItemList = (LPSTR) lpszTarget;
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
                        lpUDdeShare->lpszItemList, cchItemList,
                        lpDdeShare->lpszItemList, cchItemList, NULL, NULL );
        lpszTarget += sizeof(CHAR) * cchItemList;
    }

    return cbRequired;
}



unsigned long wwNDdeShareGetInfoA (
    unsigned char   *lpszShareName,     // name of share
    unsigned long    nLevel,            // info level must be 2
    byte            *lpBuffer,          // gets struct
    unsigned long    cBufSize,          // sizeof buffer
    unsigned long   *lpnTotalAvailable, // number of bytes available
    unsigned short  *lpnItems,          // item mask for partial getinfo
                                        // (must be 0)
    unsigned long *lpnSizeToReturn,

    unsigned long *lpnSn,
    unsigned long *lpnAt,
    unsigned long *lpnIt
)
{
    PUNDDESHAREINFO     lpUDdeShare;
    UINT                uRtn;
    DWORD               dwLen;
    WORD                nItems;
    WCHAR               lpwShareName[MAX_NDDESHARENAME * 2];
    int                 nLen;
    DWORD               nRetSize, n0, n1, n2;

    PNDDESHAREINFO      lpDdeShare;

    *lpnSizeToReturn = 0;

    if( lpszShareName == (LPSTR) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpszShareName, -1,
                         lpwShareName, MAX_NDDESHARENAME * 2 );

    nItems = 0;
    uRtn = wwNDdeShareGetInfoW( lpwShareName, nLevel,
                          lpBuffer, 0, &dwLen, &nItems,
                          FALSE,
                          &nRetSize, &n0, &n1, &n2 );
    if( uRtn == NDDE_BUF_TOO_SMALL ) {
        lpUDdeShare = (PUNDDESHAREINFO)LocalAlloc( LPTR, dwLen );
        if( !lpUDdeShare )  {
            MEMERROR();
            return( NDDE_OUT_OF_MEMORY );
        }
        nItems = 0;
        uRtn = wwNDdeShareGetInfoW( lpwShareName, nLevel,
                              (LPBYTE)lpUDdeShare, dwLen, &dwLen, &nItems,
                              FALSE,
                              &nRetSize, &n0, &n1, &n2 );

        if( uRtn == NDDE_NO_ERROR ) {
            nLen = ConvertNDdeToAnsii( lpUDdeShare, NULL, 0 );
            *lpnTotalAvailable = nLen;
            *lpnItems          = nItems;

            if( nLen > (int)cBufSize ) {
                LocalFree( lpUDdeShare );
                return NDDE_BUF_TOO_SMALL;
            }

            ConvertNDdeToAnsii( (PUNDDESHAREINFO)lpUDdeShare,
                                (PNDDESHAREINFO) lpBuffer,
                                cBufSize );
        }

        LocalFree( lpUDdeShare );

    }

    if( uRtn == NDDE_NO_ERROR ) {
        lpDdeShare = (PNDDESHAREINFO)lpBuffer;
        *lpnSn = (LONG)((LPBYTE)lpDdeShare->lpszShareName - lpBuffer);
        *lpnAt = (LONG)((LPBYTE)lpDdeShare->lpszAppTopicList - lpBuffer);
        *lpnIt = (LONG)((LPBYTE)lpDdeShare->lpszItemList - lpBuffer);
        *lpnSizeToReturn = nLen;
    } else {
        *lpnTotalAvailable = 0;
        *lpnItems          = 0;
    }

    return uRtn;
}


/*
    Set DDE Share Info
*/


unsigned long
wwNDdeShareSetInfoW (
    wchar_t       *lpszShareName,       // name of share
    unsigned long  nLevel,              // info level must be 2
    byte          *lpBuffer,            // must point to struct
    unsigned long  cBufSize,            // sizeof buffer
    unsigned short sParmNum,            // Parameter index
                                        // ( must be 0 - entire )
    byte * psn,
    unsigned long lsn,
    byte * pat,
    unsigned long lat,
    byte * pit,
    unsigned long lit
)
{
    WCHAR                szShareSet[DDE_SHARE_KEY_MAX];
    PUNDDESHAREINFO      lpDdeShare;
    LONG                 lRtn;
    LONG                 lItemList;
    HKEY                 hKey;
    BOOL                 OK;
    DWORD                dwDesiredAccess, dwGrantedAccess;
    BOOL                 fStatus;
    PSECURITY_DESCRIPTOR pSnSD;
    LPWSTR               pOldStr;
    LPWSTR               pNewStr;
    LPWSTR               pStaticStr;
    LONG                 lShareType;
    LONG                 lSerialNumber[2];
    DWORD                cbData;
     DWORD                     dwType;
     LONG                         fOldService;
     WCHAR                     buf[16];

    if ( nLevel != 2 ) {
        return NDDE_INVALID_LEVEL;
    }
    if ( cBufSize < sizeof(NDDESHAREINFO) ) {
        return NDDE_BUF_TOO_SMALL;
    }

    // only set of all parameters is currently supported!
    if ( sParmNum != 0 ) {
        return NDDE_INVALID_PARAMETER;
    }

    lpDdeShare = (PUNDDESHAREINFO)lpBuffer;
    if( lpDdeShare == (PUNDDESHAREINFO) NULL ) {
        return NDDE_INVALID_PARAMETER;
    }

    /* Fixup the pointers in the NDDESHAREINFO structure */

    lpDdeShare->lpszShareName    = (LPWSTR)psn;
    lpDdeShare->lpszAppTopicList = (LPWSTR)pat;
    lpDdeShare->lpszItemList     = (LPWSTR)pit;


    if ( !NDdeIsValidShareNameW ( lpDdeShare->lpszShareName )) {
        return NDDE_INVALID_SHARE;
    }

    if ( !NDdeParseAppTopicListW ( lpDdeShare->lpszAppTopicList,
                                  &pOldStr, &pNewStr, &pStaticStr,
                                  &lShareType)) {
        return NDDE_INVALID_TOPIC;
    }

    if ( !NDdeParseItemList ( lpDdeShare->lpszItemList,
                              lpDdeShare->cNumItems, &lItemList )) {
        return NDDE_INVALID_ITEM_LIST;
    }

    // since only setting all paramters is supported, the supplied
    // name of the share MUST match the name of the share contained
    // in the supplied struct!
    if ( lstrcmpiW( lpDdeShare->lpszShareName, lpszShareName ) ) {
        return NDDE_INVALID_PARAMETER;
    }

    // check for share existence - must exist for SetInfo
    wcscpy( szShareSet, DDE_SHARES_KEY_W );
    wcscat( szShareSet, L"\\" );
    if( wcslen(szShareSet) + wcslen(lpszShareName) + 1 >= DDE_SHARE_KEY_MAX ) {
        return NDDE_OUT_OF_MEMORY;
    }
    wcscat( szShareSet, lpszShareName );

    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
          szShareSet,
          0,
          KEY_WRITE | KEY_READ,
          &hKey );
    if( lRtn != ERROR_SUCCESS )  {
    return NDDE_SHARE_NOT_EXIST;
    }
    /*  Make sure the caller has WriteShareInfo(W) access rights. */
    /*  **********Read the key security info here. **************/
    OK = GetShareNameSD( hKey, &pSnSD, &cbData );
    if( OK ) {
    dwDesiredAccess = NDDE_SHARE_WRITE;
    ImpersonateAndSetup( TRUE );
    OK = NDdeShareAccessCheckAudit( lpszShareName, pSnSD, dwDesiredAccess,
                   &ShareGenericMapping, FALSE, FALSE,
                   &dwGrantedAccess, &fStatus);
    RevertAndCleanUp( TRUE );
    LocalFree( pSnSD );
    }
    if( !OK || !fStatus ) {
    RegCloseKey( hKey );
    return NDDE_ACCESS_DENIED;
    }

    /*  Make sure the caller has AddShare(As) access rights. */
    cbData = sizeof(buf);
    *(LONG *)buf = 0L;
   lRtn = RegQueryValueExW( hKey,
                            L"Service",
                            NULL,
                            &dwType,
                            (LPBYTE)buf, &cbData );
    fOldService = *(LONG *)buf;
    dwDesiredAccess = NDDE_SHAREDB_ADD;
    if (lpDdeShare->fService != fOldService) {
        ImpersonateAndSetup( TRUE );
        dwDesiredAccess = NDDE_SHAREDB_FSERVICE;
        OK = NDdeShareAccessCheckAudit( lpDdeShare->lpszShareName, pDsDmSD,
            dwDesiredAccess, &ShareDBGenericMapping, TRUE, FALSE,
            &dwGrantedAccess, &fStatus );
        RevertAndCleanUp( TRUE );
        if (!OK || !fStatus) {
            RegCloseKey( hKey );
            return NDDE_ACCESS_DENIED;
        }
    }

    OK = UpdateDSDMModifyId(lSerialNumber);
    if (!OK) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lpDdeShare->qModifyId[0] = lSerialNumber[0];
    lpDdeShare->qModifyId[1] = lSerialNumber[1];

    /*  *****************Do the SetInfo Operation**************** */

#ifdef NDDE_DEBUG
    DPRINTF(("Revision               = (%d)", lpDdeShare->lRevision));
    DPRINTF(("ShareName              = (%ws)", lpDdeShare->lpszShareName));
    DPRINTF(("ShareType              = (%d)", lpDdeShare->lShareType));
    DPRINTF(("ShareType*             = (%d)", lShareType));
    DPRINTF(("AppTopicList"));
    DPRINTF(("  Old-style link share = (%ws)", pOldStr));
    DPRINTF(("  New-style link share = (%ws)", pNewStr));
    DPRINTF(("  Static data share    = (%ws)", pStaticStr));
    DPRINTF(("SharedFlag             = (%d)", lpDdeShare->fSharedFlag));
    DPRINTF(("ServiceFlag            = (%d)", lpDdeShare->fService));
    DPRINTF(("StartAppFlag           = (%d)", lpDdeShare->fStartAppFlag));
    DPRINTF(("nCmdShow               = (%d)", lpDdeShare->nCmdShow));
    DPRINTF(("SerialNumber           = (%d, %d)", lpDdeShare->qModifyId[0],
                           lpDdeShare->qModifyId[1]));
    DPRINTF(("NumItems               = (%d)", lpDdeShare->cNumItems));
    {
    LPWSTR      lpszItem = lpDdeShare->lpszItemList;
    int n= 0;
    for( n=0; n<lpDdeShare->cNumItems; n++ )  {
        DPRINTF(("ItemList[%d]             = (%ws)", n, lpszItem));
        lpszItem = lpszItem + wcslen(lpszItem) + 1;
    }
    }
#endif
    /*  Set the key values. */
    lRtn = RegSetValueExW( hKey,
           L"ShareName",
           0,
           REG_SZ,
           (LPBYTE)lpDdeShare->lpszShareName,
           sizeof(WCHAR) *
               (wcslen( lpDdeShare->lpszShareName ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"OldStyleLink",
           0,
           REG_SZ,
           (LPBYTE)pOldStr,
           sizeof(WCHAR) * (wcslen( pOldStr ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"NewStyleLink",
           0,
           REG_SZ,
           (LPBYTE)pNewStr,
           sizeof(WCHAR) * (wcslen( pNewStr ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"StaticDataLink",
           0,
           REG_SZ,
           (LPBYTE)pStaticStr,
           sizeof(WCHAR) * (wcslen( pStaticStr ) + 1) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"ItemList",
           0,
           REG_MULTI_SZ,
           (LPBYTE)lpDdeShare->lpszItemList,
           sizeof(WCHAR) * lItemList );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"Revision",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->lRevision,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"ShareType",
           0,
           REG_DWORD,
           (LPBYTE)&lShareType,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"SharedFlag",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->fSharedFlag,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"Service",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->fService,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"StartAppFlag",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->fStartAppFlag,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"fuCmdShow",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->nCmdShow,
           sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueEx( hKey,
           KEY_MODIFY_ID,
           0,
           REG_BINARY,
           (LPBYTE)&lpDdeShare->qModifyId[0],
           2 * sizeof( LONG ) );
    if( lRtn != ERROR_SUCCESS ) {
    RegCloseKey( hKey );
    return NDDE_REGISTRY_ERROR;
    }
    lRtn = RegSetValueExW( hKey,
           L"NumItems",
           0,
           REG_DWORD,
           (LPBYTE)&lpDdeShare->cNumItems,
           sizeof( LONG ) );
    RegCloseKey(hKey);

    if( lRtn != ERROR_SUCCESS ) {
    return NDDE_REGISTRY_ERROR;
    }

    return NDDE_NO_ERROR;
}


/*
    Special Command
*/

unsigned long
wwNDdeSpecialCommand(
    unsigned long  nCommand,
    byte          *lpDataIn,
    unsigned long  nBytesDataIn,
    byte          *lpDataOut,
    unsigned long *nBytesDataOut
)
{
    UINT        RetValue, RetDataLength;
    UINT        i;
    BOOL        ok  = TRUE;
    PSC_PARAM   psc_param;
    char        szBuf[1024];
    UINT        nLength;
    UINT        umax;


    RetValue      = NDDE_NO_ERROR;
    RetDataLength = 0;

    switch( nCommand ) {

        case NDDE_SC_TEST: {       // test command, return *lpDataIn to *lpDataOut

            if ( (lpDataIn == NULL)  || (IsBadReadPtr(lpDataIn,nBytesDataIn) != 0) ||
                 (lpDataOut == NULL) || (IsBadWritePtr(lpDataOut,nBytesDataIn) != 0) )  {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }

            for( i=0; i<nBytesDataIn; i++ ) {
                lpDataOut[i] = lpDataIn[i];
            }
            RetDataLength = nBytesDataIn;
            }
            break;

        case NDDE_SC_REFRESH:       // refresh NetDDE operating params from reg
            RefreshNDDECfg();
            RefreshDSDMCfg();
            break;

        case NDDE_SC_DUMP_NETDDE:
#if DBG
            DebugDdeIntfState();
            DebugDderState();
            DebugRouterState();
            DebugPktzState();
#endif
            break;

        case NDDE_SC_GET_PARAM:     // get a NetDDE param from registry

            if (   (lpDataIn == NULL)
                || (nBytesDataOut == NULL)
                || (nBytesDataIn < sizeof(SC_PARAM) )
                || (IsBadReadPtr(lpDataIn,sizeof(SC_PARAM)) != 0)) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }

            psc_param = (PSC_PARAM)lpDataIn;
            umax = max(psc_param->offSection, psc_param->offKey);
            if ( (nBytesDataIn < umax) ||
                 (IsBadReadPtr(lpDataIn,umax) != 0) ) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }
            if (psc_param->pType == SC_PARAM_INT) {
                if ( (*nBytesDataOut < sizeof(UINT)) ||
                     (lpDataOut == NULL) ||
                     (IsBadWritePtr(lpDataOut,sizeof(UINT)) != 0) ) {
                     RetDataLength = sizeof(UINT);
                     RetValue = NDDE_BUF_TOO_SMALL;
                } else {
                    *((UINT *)lpDataOut) = MyGetPrivateProfileInt(
                        (LPCSTR)psc_param + psc_param->offSection,
                        (LPCSTR)psc_param + psc_param->offKey,
                        0, NULL);
                    RetDataLength = sizeof(UINT);
                }
            } else if (psc_param->pType == SC_PARAM_STRING) {
                nLength = MyGetPrivateProfileString(
                    (LPCSTR)psc_param + psc_param->offSection,
                    (LPCSTR)psc_param + psc_param->offKey,
                    "Dummy",
                    (LPSTR)szBuf, 1024, NULL);
                RetDataLength = nLength;
                if ( (*nBytesDataOut < nLength) ||
                     (lpDataOut == NULL) || 
                     (IsBadWritePtr(lpDataOut,nLength) != 0) ) {
                     RetValue = NDDE_BUF_TOO_SMALL;
                } else {
                    strncpy(lpDataOut, szBuf, nLength);
                }
            }
            break;

        case NDDE_SC_SET_PARAM:     // set a NetDDE param in registry

            if (   (lpDataIn == NULL)
                || (nBytesDataIn < sizeof(SC_PARAM) )
                || (IsBadReadPtr(lpDataIn,sizeof(SC_PARAM)) != 0)) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }
            psc_param = (PSC_PARAM)lpDataIn;
            umax = max(max(psc_param->offSection, psc_param->offKey), psc_param->offszValue);
            if ( (nBytesDataIn < umax) ||
                 (IsBadReadPtr(lpDataIn,umax) != 0) ) {
                RetValue = NDDE_INVALID_PARAMETER;
                break;
            }
            if (psc_param->pType == SC_PARAM_INT) {
                ok = MyWritePrivateProfileInt(
                    (LPSTR)psc_param + psc_param->offSection,
                    (LPSTR)psc_param + psc_param->offKey,
                    psc_param->pData,
                    NULL);
            } else if (psc_param->pType == SC_PARAM_STRING) {
                ok = MyWritePrivateProfileString(
                    (LPCSTR)psc_param + psc_param->offSection,
                    (LPCSTR)psc_param + psc_param->offKey,
                    (LPCSTR)psc_param + psc_param->offszValue,
                    NULL);
            }
            if (!ok) {
                RetValue = NDDE_REGISTRY_ERROR;
            }
            break;

        default:
            RetValue      = NDDE_INVALID_SPECIAL_COMMAND;
            RetDataLength = 0;
            break;
    }

    *nBytesDataOut = RetDataLength;
    return RetValue;
}


BOOL
BuildShareDatabaseSD( PSECURITY_DESCRIPTOR *ppSD )
{
    PSID                        AdminsAliasSid;
    PSID                        PowerUsersAliasSid;
    PSID                        UsersAliasSid;
    PSID                        WorldSid;
    PSID                        CreatorOwnerSid;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    NtAuthority    = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SECURITY_DESCRIPTOR         aSD;
    PSECURITY_DESCRIPTOR        pSD;
    int                         AceCount;
    PSID                        AceSid[10];
    ACCESS_MASK                 AceMask[10];
    BYTE                        AceFlags[10];
    PACL                        TmpAcl;
    PACCESS_ALLOWED_ACE         TmpAce;
    DWORD                       lSD;
    LONG                        DaclLength;
    BOOL                        OK;
    int                         i;

    OK = InitializeSecurityDescriptor( &aSD, SECURITY_DESCRIPTOR_REVISION );

    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        return FALSE;
    }

    OK = AllocateAndInitializeSid( &NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &AdminsAliasSid );

    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        return FALSE;
    }

    AceCount = 0;

    AceSid[AceCount]   = AdminsAliasSid;
    AceMask[AceCount]  = NDDE_SHAREDB_ADMIN;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_POWER_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &PowerUsersAliasSid );
    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        return FALSE;
    }

    AceSid[AceCount]   = PowerUsersAliasSid;
    AceMask[AceCount]  = NDDE_SHAREDB_POWER;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &UsersAliasSid );

    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        return FALSE;
    }

    AceSid[AceCount]   = UsersAliasSid;
    AceMask[AceCount]  = NDDE_SHAREDB_USER;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &WorldAuthority,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &WorldSid );
    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        return FALSE;
    }

    AceSid[AceCount]   = WorldSid;
    AceMask[AceCount]  = NDDE_SHAREDB_EVERYONE;
    AceFlags[AceCount] = 0;
    AceCount++;

    //
    // The rest of this ACL will provide inheritable protection
    // for DDE share objects when they are created.  Notice that
    // each of the following ACEs is marked as InheritOnly and
    // ObjectInherit.
    //

    AceSid[AceCount]   = WorldSid;
    AceMask[AceCount]  = NDDE_GUI_READ_LINK;
    AceFlags[AceCount] = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
    AceCount++;

    OK = AllocateAndInitializeSid(   &CreatorAuthority,
                                1,
                                SECURITY_CREATOR_OWNER_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &CreatorOwnerSid );
    if( !OK ) {
        NDDELogErrorW( MSG410, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        FreeSid( WorldSid );
        return FALSE;
    }


    AceSid[AceCount]   = CreatorOwnerSid;
    AceMask[AceCount]  = NDDE_GUI_FULL_CONTROL;
    AceFlags[AceCount] = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
    AceCount++;


    OK = SetSecurityDescriptorOwner( &aSD, AdminsAliasSid, FALSE);
    if( !OK ) {
        NDDELogErrorW( MSG411, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        FreeSid( WorldSid );
        FreeSid( CreatorOwnerSid );
        return FALSE;
    }

    OK = SetSecurityDescriptorGroup( &aSD, AdminsAliasSid, FALSE );
    if( !OK ) {
        NDDELogErrorW( MSG412, LogStringW( L"%d", GetLastError() ), NULL );
        FreeSid( AdminsAliasSid );
        FreeSid( PowerUsersAliasSid );
        FreeSid( UsersAliasSid );
        FreeSid( WorldSid );
        FreeSid( CreatorOwnerSid );
        return FALSE;
    }

    /*  Setup the default ACL for a new DDE Share Object. */
    DaclLength = (DWORD)sizeof(ACL);
    for( i=0; i<AceCount; i++ ) {
        DaclLength += GetLengthSid( AceSid[i] ) +
                      (DWORD)sizeof( ACCESS_ALLOWED_ACE ) -
                      (DWORD)sizeof(DWORD);
    }
    TmpAcl = (PACL)LocalAlloc( 0, DaclLength );
    if( !TmpAcl ) {
        MEMERROR();
        NDDELogErrorW( MSG406, LogStringW( L"%d", GetLastError() ), NULL );
    }
    OK = InitializeAcl( TmpAcl, DaclLength, ACL_REVISION2 );
    if( !OK ) {
        NDDELogErrorW( MSG407, LogStringW( L"%d", GetLastError() ), NULL );
    }
    for( i=0; i<AceCount; i++ ) {
        OK = AddAccessAllowedAce( TmpAcl, ACL_REVISION2, AceMask[i],
                                      AceSid[i] );
        if( !OK ) {
            NDDELogErrorW( MSG408, LogStringW( L"%d", GetLastError() ), NULL);
        }
        OK = GetAce( TmpAcl, i, (LPVOID *)&TmpAce );
        if( !OK ) {
            NDDELogErrorW( MSG409, LogStringW( L"%d", GetLastError() ), NULL);
        }
        TmpAce->Header.AceFlags = AceFlags[i];
    }

    OK = SetSecurityDescriptorDacl ( &aSD, TRUE, TmpAcl, FALSE );
    if( !OK ) {
        NDDELogErrorW( MSG413, LogStringW( L"%d", GetLastError() ), NULL);
    }
    lSD = GetSecurityDescriptorLength( &aSD );
    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, lSD );
    if (pSD == NULL) {
        MEMERROR();
    } else {
        OK  = MakeSelfRelativeSD( &aSD, pSD, &lSD );
        if( !OK ) {
            NDDELogErrorW( MSG414, LogStringW( L"%d", GetLastError() ), NULL);
            LocalFree( pSD );
            *ppSD = NULL;
        } else {
            *ppSD = pSD;
        }
    }

    FreeSid( AdminsAliasSid );
    FreeSid( PowerUsersAliasSid );
    FreeSid( UsersAliasSid );
    FreeSid( WorldSid );
    FreeSid( CreatorOwnerSid );

    LocalFree( TmpAcl );

    return OK;
}


static char    dllName[]             = "NDDEAPI";
static char    szNetddeIni[]        = "netdde.ini";

/*
    Determine what we're allowed to log in the event logger
*/
void
RefreshDSDMCfg(void)
{
#if DBG
    bDebugDSDMInfo = MyGetPrivateProfileInt( dllName,
        "DebugInfo", FALSE, szNetddeIni );
    bDebugDSDMErrors = MyGetPrivateProfileInt( dllName,
        "DebugErrors", FALSE, szNetddeIni );
#endif
}

INT APIENTRY
NDdeApiInit( void )
{
    HKEY        hKey;
    LONG        lRtn;
    DWORD       dwInstance;
    DWORD       dwType = REG_DWORD;
    DWORD       cbData = sizeof(DWORD);

#if DBG
    RefreshDSDMCfg();
    if (bDebugDSDMInfo) {
        DPRINTF(("NDdeApiInit() called."));
    }
#endif
    /*  Build the Security Descriptor for the ShareDatabase. */
    if( !BuildShareDatabaseSD( &pDsDmSD ) ) {
        NDDELogErrorW( MSG405, NULL );
        return FALSE;
    }

    /*  Check that the ShareDatabase key exists in the Registry. */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                  DDE_SHARES_KEY,
                  0,
                  READ_CONTROL | KEY_QUERY_VALUE,
                  &hKey );

    if( lRtn != ERROR_SUCCESS ) {
        MessageBox( NULL, "DDE Shares database does not exist.", "NDdeApi",
            MB_OK );
        return FALSE;
    }

    lRtn = RegQueryValueEx( hKey,
                KEY_DB_INSTANCE,
                NULL,
                &dwType,
                (LPBYTE)&dwInstance, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to query DDE Shares DB Instance Value: %d", lRtn));
        }
#endif
        return FALSE;
    }
    swprintf(szTrustedShareKey, L"%ws\\%ws%08X",
        TRUSTED_SHARES_KEY_W,
        TRUSTED_SHARES_KEY_PREFIX_W,
        dwInstance);

    __try
    {
        InitializeCriticalSection( &DsDmCriticalSection );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPRINTF(("InitializeCriticalSection excepted."));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\server\nddeapir.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIR.C;1  16-Dec-92,10:14:40  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "windows.h"

int
WinMain( HINSTANCE x, HINSTANCE y, LPSTR z, int a )
{
	return(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\server\nddeapis.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIU.C;1  2-Apr-93,16:21:24  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>
#include <rpcndr.h>
#include "ndeapi.h"
#include "debug.h"

char    tmpBuf2[500];
HANDLE  hThread;
DWORD   IdThread;

extern INT APIENTRY NDdeApiInit( void );



//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: TRUE if successfull, FALSE if not.
//


BOOL
CreateSids(
    PSID                    *BuiltInAdministrators,
    PSID                    *System,
    PSID                    *AuthenticatedUsers
)
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and System, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  BuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            //  sub-authority
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         System)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         AuthenticatedUsers)) {

        // error

        FreeSid(*BuiltInAdministrators);
        *BuiltInAdministrators = NULL;

        FreeSid(*System);
        *System = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


//
// CreateRPCSd
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.  Modify the code to
// change. 
//
// Caller must free the returned buffer if not NULL.
//

PSECURITY_DESCRIPTOR
CreateRPCSd(
    VOID
)
{
    PSID                    AuthenticatedUsers;
    PSID                    BuiltInAdministrators;
    PSID                    System;

    if (!CreateSids(&BuiltInAdministrators,
                    &System,
                    &AuthenticatedUsers)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    pSd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(AuthenticatedUsers) +
            GetLengthSid(BuiltInAdministrators) +
            GetLengthSid(System);

        pSd = LocalAlloc(LPTR,
                        SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!pSd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)pSd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            FILE_ALL_ACCESS & ~(WRITE_DAC | 
                                                 WRITE_OWNER |
                                                 FILE_CREATE_PIPE_INSTANCE),
                                            AuthenticatedUsers)) {

                // Failed to build the ACE granting "Authenticated users"
                // (SYNCHRONIZE | GENERIC_READ) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            BuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // GENERIC_ALL access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            System)) {

                // Failed to build the ACE granting "System"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(pSd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(pSd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(AuthenticatedUsers);
                FreeSid(BuiltInAdministrators);
                FreeSid(System);

                return pSd;
            }

            LocalFree(pSd);
        }

        FreeSid(AuthenticatedUsers);
        FreeSid(BuiltInAdministrators);
        FreeSid(System);
    }

    return NULL;
}


DWORD StartRpc( DWORD x ) {
    RPC_STATUS status;
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszEndpoint         = "\\pipe\\nddeapi";
    unsigned int    cMinCalls           = 1;
    unsigned int    cMaxCalls           = 20;

    if( NDdeApiInit() ) {

        SECURITY_DESCRIPTOR     *pSd;

        pSd = CreateRPCSd();

        if (!pSd) {
           DPRINTF(("CreateRPCSD failed."));

           return 0;
        } else {

            status = RpcServerUseProtseqEp(
                pszProtocolSequence,
                cMaxCalls,
                pszEndpoint,
                pSd);

            LocalFree(pSd);
        }

        if (status)
           {
           DPRINTF(("RpcServerUseProtseqEp returned 0x%x", status));
           return( 0 );
           }

        status = RpcServerRegisterIf(
            nddeapi_ServerIfHandle,
            NULL,
            NULL);

        if (status)
           {
           DPRINTF(("RpcServerRegisterIf returned 0x%x", status));
           return( 0 );
           }

        status = RpcServerListen(
            cMinCalls,
            cMaxCalls,
            FALSE /* don't wait*/);

    }
    return 0;
}

// ====================================================================
//                MIDL allocate and free
// ====================================================================

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void * MIDL_user_allocate(size_t len)
#else
void * _stdcall MIDL_user_allocate(size_t len)
#endif
{
    return(LocalAlloc(LPTR,len));
}

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
void MIDL_user_free(void * ptr)
#else
void _stdcall MIDL_user_free(void * ptr)
#endif
{
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\cfconvrt.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CFCONVRT.C;2  25-Feb-93,11:32:40  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

//#define   DEBUG_CONVERT

#include    <memory.h>
#include    <string.h>
#include    <dde.h>
#include    "dde1.h"
#include    "host.h"
#include    "windows.h"
#include    "netbasic.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "debug.h"
#include    "hexdump.h"
#include    "getglobl.h"
#include    "userdde.h"
#include    "nddemsg.h"
#include    "nddelog.h"


extern  BOOL    bDebugInfo;
/*
LPVOID
DbgGlobalLock(HGLOBAL hnd);

BOOL
DbgGlobalUnlock(HGLOBAL hnd);

HGLOBAL
DbgGlobalFree(HGLOBAL hnd);

#define GlobalFree DbgGlobalFree
#define GlobalLock DbgGlobalLock
#define GlobalUnlock DbgGlobalUnlock
*/


#pragma pack(2)

typedef struct tagMETAFILEPICT16 {    /* mfp16wow32 */
    WORD    mm;
    WORD    xExt;
    WORD    yExt;
    WORD    hMF;
} METAFILEPICT16;
typedef METAFILEPICT16 UNALIGNED *LPMETAFILEPICT16;

#pragma pack(1)

typedef struct tagBITMAP16
  {
    WORD        bmType;
    WORD        bmWidth;
    WORD        bmHeight;
    WORD        bmWidthBytes;
    BYTE        bmPlanes;
    BYTE        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP16;
typedef BITMAP16 UNALIGNED *LPBITMAP16;


#pragma pack()


BOOL
FAR PASCAL
ConvertDataToPktMetafile(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex,
    BOOL    bWin16Con )
{
    HANDLE              hPict;
    BOOL                ok = TRUE;
    LPMETAFILEPICT      lpMetafilePict;
    LPMETAFILEPICT16    lpMetafilePict16;
    LPMETAFILEPICT      lpMetafilePictNew;
    LPSTR               lpDataPortion = *plpDataPortion;
    DWORD               dwSize = *pdwSize;
    DWORD               dwhMFSize;
    DWORD               dwErr;
    HANDLE              hDataComplex = *phDataComplex;

    /* the only thing in the DDE data is the handle to the METAFILEPICT */
    hPict = *((LPHANDLE)lpDataPortion);

    lpMetafilePict = (LPMETAFILEPICT) GlobalLock( hPict );
    if( lpMetafilePict )  {
        if( lpMetafilePict->hMF )  {
            dwhMFSize = GetMetaFileBitsEx(lpMetafilePict->hMF, 0, NULL);
            if (dwhMFSize == 0) {
                dwErr = GetLastError();
                DPRINTF(("Unable to get size of Meta File object: %d", dwErr));
                /* GetMetaFileBitsEx() failed: %1 */
                NDDELogError(MSG079, LogString("%d", dwErr), NULL);
                GlobalUnlock(hPict);
                return(FALSE);
            }


            if (bWin16Con) {
                dwSize = sizeof(METAFILEPICT16) + dwhMFSize;
            } else {
                dwSize = sizeof(METAFILEPICT) + dwhMFSize;
            }

            hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
            if( hDataComplex )  {
                // copy the metafile after the matafilepict structure

                // unlocked later
                lpMetafilePictNew = (LPMETAFILEPICT) GlobalLock(
                    hDataComplex );

                // copy metafilepict part
                if (bWin16Con) {
                    lpMetafilePict16 = (LPMETAFILEPICT16)lpMetafilePictNew;
                    lpMetafilePict16->mm = (WORD) lpMetafilePict->mm;
                    lpMetafilePict16->xExt = (WORD) lpMetafilePict->xExt;
                    lpMetafilePict16->yExt = (WORD) lpMetafilePict->yExt;
                    lpDataPortion = ((LPBYTE) lpMetafilePictNew) + sizeof(METAFILEPICT16);
                } else {
                    *lpMetafilePictNew = *lpMetafilePict;
                    lpDataPortion = ((LPBYTE) lpMetafilePictNew) + sizeof(METAFILEPICT);
                }

                if (GetMetaFileBitsEx(lpMetafilePict->hMF, dwhMFSize,
                        lpDataPortion) != dwhMFSize) {
                    dwErr = GetLastError();
                    DPRINTF(("hMF copy failed using GetMetaFileBitsEx(): %d", dwErr));
                    /* GetMetaFileBitsEx() failed: %1 */
                    NDDELogError(MSG079, LogString("%d", dwErr), NULL);
                    GlobalUnlock(hPict);
                    GlobalUnlock(hDataComplex);
                    GlobalFree(hDataComplex);
                    return(FALSE);
                }
                lpDataPortion = (LPSTR) lpMetafilePictNew;
            } else {
                MEMERROR();
                /*  Not enough memory for metafile copy: %1 */
                NDDELogError(MSG050,
                    LogString("%d", dwSize), NULL);
                ok = FALSE;
            }
        } else {
            /*  No metafile in metafilepict */
            NDDELogError(MSG051, NULL);
            ok = FALSE;
        }
        GlobalUnlock( hPict );
    } else {
        /*  Could not lock metafilepict */
        NDDELogError(MSG052, NULL);
        ok = FALSE;
    }

    *plpDataPortion = lpDataPortion;
    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataMetafile(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData,
    BOOL            bWin16Con )
{
    HANDLE              hData;
    HANDLE              hPict = 0;
    HANDLE              hPictMetafile = 0;
    DWORD               dwhMFSize;
    DWORD               dwErr;
    LPBYTE              lphMF;
    LPMETAFILEPICT16    lpMetafilePict16;
    LPMETAFILEPICT      lpMetafilePict;
    LPSTR               lpData;
    BOOL                ok = TRUE;

    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE)+sizeof(DDELN) );
    if( hData == 0 )  {
        MEMERROR();
        return( 0 );
    }
    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Couldn't lock memory for metafile handle */
        NDDELogError(MSG053, NULL);
        GlobalFree( hData );
        return( 0 );
    }

    /* copy in data portion */
    hPict = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        (DWORD) sizeof(METAFILEPICT) );
    if( hPict )  {
        lpMetafilePict = (LPMETAFILEPICT) GlobalLock( hPict );
        if (lpMetafilePict == NULL) {
            /*  Couldn't lock memory for metafile handle */
            NDDELogError(MSG053, NULL);
            GlobalFree( hPict );
            GlobalUnlock( hData );
            GlobalFree( hData );
            return( 0 );
        }

        // copy METAFILEPICT struct
        if (bWin16Con) {
            dwhMFSize = lpDdePktData->dp_data_sizeData - sizeof(METAFILEPICT16);
            lphMF = GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData )
                + sizeof(METAFILEPICT16);
            lpMetafilePict16 = (LPMETAFILEPICT16) GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData );
            lpMetafilePict->mm = (DWORD) lpMetafilePict16->mm;
            lpMetafilePict->xExt = (DWORD) lpMetafilePict16->xExt;
            lpMetafilePict->yExt = (DWORD) lpMetafilePict16->yExt;
        } else {
            dwhMFSize = lpDdePktData->dp_data_sizeData - sizeof(METAFILEPICT);
            lphMF = GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData )
                + sizeof(METAFILEPICT);
            memcpy( lpMetafilePict,
                GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData ),
                sizeof(METAFILEPICT) );
        }

        // create the HMF
        lpMetafilePict->hMF = SetMetaFileBitsEx(dwhMFSize, lphMF);
        hPictMetafile = lpMetafilePict->hMF;
        if (hPictMetafile == 0) {
            dwErr = GetLastError();
            DPRINTF(("SetMetaFileBitsEx(size == %d) failed: %d, mode: %d",
                dwhMFSize, dwErr, bWin16Con));
            /* SetMetaFileBitsEx() failed: %1 */
            NDDELogError(MSG080, LogString("%d", dwErr), NULL);
            ok = FALSE;
        }

        GlobalUnlock( hPict );
    } else {
        MEMERROR();
        /*  Not enough memory for metafilepict: %1  */
        NDDELogError(MSG055,
            LogString("%d", sizeof(METAFILEPICT)), NULL);
        ok = FALSE;
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hPict;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hPict )  {
            GlobalUnlock(hPict);
            GlobalFree( hPict );
        }
        if( hPictMetafile )  {
            GlobalFree( hPictMetafile );
        }
        if (hData) {
            GlobalUnlock(hData);
            GlobalFree(hData);
        }
        return( NULL );
    }
}

/*
 * One might ask - why in the !@#$% are they using GetBitmapBits() to convert
 * the bitmap to bits instead of the more sane GetDIBits() API.  History
 * has it that this came from clipbrd of ancient times.  Clipbrd dealt with
 * this problem by storing a parellel CF_DIB format along with the near-
 * useless bits of CF_BITMAP fame.  So for compatability, we cannot fix this
 * to do the correct thing...ah life in the compatability lane.
 */
BOOL
FAR PASCAL
ConvertDataToPktBitmap(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex,
    BOOL    bWin16Con )
{
    HANDLE              hBitmap;
    BITMAP              Bitmap;
    LPBITMAP16          lpBitmap16;
    BOOL                ok = TRUE;
    LPBITMAP            lpBitmap;
    LPSTR               lpDataPortion = *plpDataPortion;
    LPBYTE              lpData = NULL;
    DWORD               dwSize = *pdwSize;
    DWORD               cbBitmap;
    HANDLE              hDataComplex = *phDataComplex;

    /* the only thing in the DDE data is the handle to the BITMAP */
    hBitmap = *((LPHANDLE)lpDataPortion);
#if DBG
    if (bDebugInfo) {
        DPRINTF(( "Info from DDE: %ld bytes", dwSize ));
        HEXDUMP( (LPSTR)lpDataPortion, (int) min( (DWORD)0x40, dwSize ) );
//        DPRINTF(( "BITMAP %04X size: %ld", hBitmap, GlobalSize(hBitmap) ));
    }
#endif

    lpBitmap = &Bitmap;
    // get bitmap header
    ok = GetObject ( hBitmap, sizeof(BITMAP), lpBitmap );

    if( ok )  {     // calculate # of bytes needed to store bitmap bits
        cbBitmap = GetBitmapBits(hBitmap, 0, NULL);
        if (bWin16Con) {
            dwSize = sizeof(BITMAP16) + cbBitmap;
        } else {
            dwSize = sizeof(BITMAP) + cbBitmap;
        }

#if DBG
        if (bDebugInfo) {
            DPRINTF(( "bitmap %Fp %ld bytes", lpBitmap, dwSize ));
            HEXDUMP( (LPSTR) lpBitmap, 0x40 );
        }
#endif
        hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
        if( hDataComplex )  {
            // unlocked later
            lpData = GlobalLock( hDataComplex );

            // copy bitmap header
            if (bWin16Con) {
                lpBitmap16 = (LPBITMAP16) lpData;
                lpBitmap16->bmType = (WORD) lpBitmap->bmType;
                lpBitmap16->bmWidth = (WORD) lpBitmap->bmWidth;
                lpBitmap16->bmHeight = (WORD) lpBitmap->bmHeight;
                lpBitmap16->bmWidthBytes = (WORD) ((lpBitmap->bmWidth
                    * lpBitmap->bmBitsPixel + 15) >> 3) & 0xFFFE;
//                lpBitmap16->bmWidthBytes = (WORD) lpBitmap->bmWidthBytes;
                lpBitmap16->bmPlanes = (BYTE) lpBitmap->bmPlanes;
                lpBitmap16->bmBitsPixel = (BYTE) lpBitmap->bmBitsPixel;
                lpDataPortion = ((LPBYTE) lpData) + sizeof(BITMAP16);
            } else {
                memcpy ( lpData, lpBitmap, sizeof(BITMAP ) );
                lpDataPortion = ((LPBYTE) lpData) + sizeof(BITMAP);
            }
            // copy bits
            if ( !GetBitmapBits ( hBitmap, cbBitmap, lpDataPortion)) {
                    ok = FALSE;
            }
#ifdef  DEBUG_CONVERT
            DPRINTF(("ConvertDataToPktBitmap(), size: %d, mode: %d", dwSize, bWin16Con));
            HEXDUMP(lpData, dwSize);
#endif
        } else {
            MEMERROR();
            /*  Not enough memory for bitmap copy: %1   */
            NDDELogError(MSG056,
                LogString("%d", dwSize), NULL);
            ok = FALSE;
        }
    } else {
        /*  Could not lock bitmap   */
        NDDELogError(MSG057, NULL);
        ok = FALSE;
    }

    *plpDataPortion = lpData;

    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataBitmap(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData,
    BOOL            bWin16Con )
{
    HANDLE              hData;
    HANDLE              hBitmap = NULL;
    BITMAP              Bitmap;
    LPBITMAP            lpBitmap;
    LPBITMAP16          lpBitmap16;
    LPSTR               lpData;
    BOOL                ok = TRUE;

    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /*  Not enough memory for bitmap copy: %1   */
        NDDELogError(MSG056,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in bitmap header */
    if (bWin16Con) {
        lpBitmap = &Bitmap;
        lpBitmap16 = (LPBITMAP16)GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsData );
        lpBitmap->bmType = (DWORD) lpBitmap16->bmType;
        lpBitmap->bmWidth = (DWORD) lpBitmap16->bmWidth;
        lpBitmap->bmHeight = (DWORD) lpBitmap16->bmHeight;
        lpBitmap->bmWidthBytes = (DWORD) lpBitmap16->bmWidthBytes;
        lpBitmap->bmPlanes = (WORD) lpBitmap16->bmPlanes;
        lpBitmap->bmBitsPixel = (WORD) lpBitmap16->bmBitsPixel;
        lpBitmap->bmBits = (LPBYTE)lpBitmap16 + sizeof(BITMAP16);
    } else {
        lpBitmap = (LPBITMAP)GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsData );
        lpBitmap->bmBits = (LPBYTE)lpBitmap + sizeof(BITMAP);
    }

#ifdef  DEBUG_CONVERT
    DPRINTF(("ConvertPktToDataBitmap(), size: %d, mode: %d", lpDdePktData->dp_data_sizeData, bWin16Con));
    HEXDUMP(GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData ),
            lpDdePktData->dp_data_sizeData);
#endif

    if ( lpBitmap->bmWidth ) {      // make sure no 0 width
            // assume bits follow header in packet data

            hBitmap = CreateBitmapIndirect ( lpBitmap );
    }

    if( hBitmap )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hBitmap;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hBitmap )  {
            GlobalFree( hBitmap );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}


BOOL
FAR PASCAL
ConvertDataToPktEnhMetafile(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex )
{
    DWORD           dwSize = *pdwSize;
    LPSTR           lpDataPortion = *plpDataPortion;
    HANDLE          hDataComplex = *phDataComplex;
    HENHMETAFILE    hEMF;
    LPBYTE          lpEnhMetafile;
    DWORD           dwhEMFSize;
    DWORD           dwErr;
    BOOL            ok = TRUE;

    hEMF = *((LPHANDLE)lpDataPortion);
    dwhEMFSize = GetEnhMetaFileBits(hEMF, 0, NULL);
    if (dwhEMFSize == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to get size of Meta Enhanced File object: %d", dwErr));
        /* GetEnhMetaFileBits() failed: %1 */
        NDDELogError(MSG081, LogString("%d", dwErr), NULL);
        return(FALSE);
    }
    hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwhEMFSize );
    if( hDataComplex )  {
        lpEnhMetafile = (LPBYTE) GlobalLock( hDataComplex );
        if (GetEnhMetaFileBits(hEMF, dwhEMFSize,
                    lpEnhMetafile) != dwhEMFSize) {
            dwErr = GetLastError();
            DPRINTF(("hEMF copy failed using GetEnhMetaFileBits(): %d", dwErr));
            /* GetMetaFileBitsEx() failed: %1 */
            NDDELogError(MSG081, LogString("%d", dwErr), NULL);
            GlobalUnlock(hDataComplex);
            GlobalFree(hDataComplex);
            ok = FALSE;
        }
        lpDataPortion = (LPSTR) lpEnhMetafile;
    } else {
        MEMERROR();
        /*  Not enough memory for metafile copy: %1 */
        NDDELogError(MSG050, LogString("%d", dwhEMFSize), NULL);
        ok = FALSE;
    }

    *plpDataPortion = lpDataPortion;
    *pdwSize = dwhEMFSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataEnhMetafile(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData )
{
    HANDLE              hData;
    LPBYTE              lpEMF;
    HENHMETAFILE        hEMF;
    HANDLE              hBitmap = NULL;
    LPSTR               lpData;
    DWORD               dwErr;
    BOOL                ok = TRUE;

    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /*  Not enough memory for bitmap copy: %1   */
        NDDELogError(MSG056,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in data portion */

    lpEMF = (LPBYTE)GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsData );
    hEMF = SetEnhMetaFileBits( lpDdePktData->dp_data_sizeData, lpEMF);
    if (hEMF == 0) {
        dwErr = GetLastError();
        DPRINTF(("SetEnhMetaFileBitsEx(size == %d) failed: %d",
            lpDdePktData->dp_data_sizeData, dwErr));
        /* SetEnhMetaFileBits() failed: %1 */
        NDDELogError(MSG082, LogString("%d", dwErr), NULL);
        ok = FALSE;
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hEMF;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hEMF )  {
            GlobalFree( hEMF );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}


BOOL
FAR PASCAL
ConvertDataToPktDIB(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex )
{
    DWORD           dwSize = *pdwSize;
    LPSTR           lpDataPortion = *plpDataPortion;
    HANDLE          hDataComplex = *phDataComplex;
    HANDLE          hIndirect;
    LPBYTE          lpIndirect;
    DWORD           dwErr;
    BOOL            ok = TRUE;

    hIndirect = *((LPHANDLE)lpDataPortion);

    dwSize = (DWORD)GlobalSize(hIndirect);
    if (dwSize == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to get size of Indirect object: %d", dwErr));
        /* GlobalSize() for indirect object failed: %1 */
        NDDELogError(MSG086, LogString("%d", dwErr), NULL);
        return(FALSE);
    }
    hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
    if( hDataComplex )  {
        lpDataPortion = (LPSTR) GlobalLock( hDataComplex );
        lpIndirect = (LPBYTE) GlobalLock(hIndirect);
        memcpy(lpDataPortion, lpIndirect, dwSize);
    } else {
        MEMERROR();
        /*  Not enough memory for metafile copy: %1 */
        NDDELogError(MSG050, LogString("%d", dwSize), NULL);
        ok = FALSE;
    }
#ifdef  DEBUG_CONVERT
    DPRINTF(("ConvertDataToPktDIB(), size: %d", dwSize));
    HEXDUMP(lpDataPortion, dwSize);
#endif
    *plpDataPortion = lpDataPortion;
    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataDIB(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData )
{
    HANDLE              hData;
    LPBYTE              lpIndirectData;
    HANDLE              hIndirect = NULL;
    LPSTR               lpData;
    LPBYTE              lpStupidData;
    DWORD               dwErr;
    BOOL                ok = TRUE;


    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)),
            "CF_DIB", LogString("%d", GetLastError()), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in data portion */

    lpIndirectData = (LPBYTE)GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsData );
    hIndirect = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
            lpDdePktData->dp_data_sizeData);
    if (hIndirect == 0) {
        MEMERROR();
        dwErr = GetLastError();
        DPRINTF(("Unalbe to allocate memory for indirect object of size %d. Error: %d",
            lpDdePktData->dp_data_sizeData, dwErr));
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", lpDdePktData->dp_data_sizeData),
            "CF_DIB", LogString("%d", dwErr), NULL);
        ok = FALSE;
    } else {
        lpStupidData = GlobalLock(hIndirect);
        memcpy(lpStupidData, lpIndirectData, lpDdePktData->dp_data_sizeData);

#ifdef  DEBUG_CONVERT
        DPRINTF(("ConvertPktToDataDIB(), size: %d", lpDdePktData->dp_data_sizeData));
        HEXDUMP(lpStupidData, lpDdePktData->dp_data_sizeData);
#endif
        GlobalUnlock(hIndirect);
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hIndirect;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hIndirect )  {
            GlobalFree( hIndirect );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}

BOOL
FAR PASCAL
ConvertDataToPktPalette(
    LPSTR   *plpDataPortion,
    DWORD   *pdwSize,
    HANDLE  *phDataComplex )
{
    DWORD           dwSize = *pdwSize;
    LPSTR           lpDataPortion = *plpDataPortion;
    HANDLE          hDataComplex = *phDataComplex;
    LOGPALETTE     *lpLogPalette = NULL;
    HANDLE          hPalette;
    DWORD           dwErr;
    DWORD           dwCount;
    DWORD           dwTmp;
    BOOL            ok = TRUE;

    hPalette = *((LPHANDLE)lpDataPortion);
    dwCount = GetPaletteEntries(hPalette, 0, 0, NULL);
    if (dwCount == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to get number of palette entries: %d", dwErr));
        /* GetPaletteEntries() failed: %1 */
        NDDELogError(MSG083, LogString("%d", dwErr), NULL);
        return(FALSE);
    }
    dwSize = dwCount * sizeof(PALETTEENTRY) + sizeof(LOGPALETTE) - sizeof(PALETTEENTRY);
    hDataComplex = GlobalAlloc( GMEM_MOVEABLE, dwSize );
    if( hDataComplex )  {
        MEMERROR();
        lpLogPalette = (LOGPALETTE *) GlobalLock( hDataComplex );
        lpLogPalette->palVersion = 0x300;
        lpLogPalette->palNumEntries = (WORD)dwCount;
        dwTmp = GetPaletteEntries(hPalette, 0, dwCount, lpLogPalette->palPalEntry);
#ifdef  DEBUG_CONVERT
        DPRINTF(("ConvertDataToPktPalette(), size: %d, count: %d", dwSize, dwCount));
        HEXDUMP(lpLogPalette, dwSize);
#endif
        if (dwTmp == 0) {
            dwErr = GetLastError();
            DPRINTF(("Unable to get the palette entries: %d", dwErr));
            /* GetPaletteEntries() failed: %1 */
            NDDELogError(MSG083, LogString("%d", dwErr), NULL);
            GlobalUnlock(hDataComplex);
            GlobalFree(hDataComplex);
            return(FALSE);
        }
    } else {
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", dwSize),
            "CF_PALETTE", LogString("%d", GetLastError()), NULL);
        ok = FALSE;
    }

    *plpDataPortion = (LPSTR)lpLogPalette;
    *pdwSize = dwSize;
    *phDataComplex = hDataComplex;
    return( ok );
}

HANDLE
FAR PASCAL
ConvertPktToDataPalette(
    LPDDEPKT        lpDdePkt,
    LPDDEPKTDATA    lpDdePktData )
{
    HANDLE              hData;
    LOGPALETTE         *lpIndirectData;
    HANDLE              hPalette = NULL;
    LPSTR               lpData;
    DWORD               dwErr;
    BOOL                ok = TRUE;


    hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
        sizeof(HANDLE) + sizeof(DDELN) );
    if( hData == NULL )  {
        MEMERROR();
        /* Unable to allocate enough memory [%1] for %2 conversion: %3 */
        NDDELogError(MSG085,
            LogString("%d", sizeof(HANDLE) + sizeof(DDELN)),
            "CF_PALETTE", LogString("%d", GetLastError()), NULL);
        return( NULL );
    }

    lpData = GlobalLock( hData );
    if( lpData == NULL )  {
        /*  Could not lock memory for bitmap handle */
        NDDELogError(MSG058, NULL);
        GlobalFree( hData );
        return( NULL );
    }

    /* copy in data portion */

    lpIndirectData = (LOGPALETTE *)GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsData );
#ifdef  DEBUG_CONVERT
    DPRINTF(("ConvertPktToDataPalette(), size: %d", lpDdePktData->dp_data_sizeData));
    HEXDUMP(lpIndirectData, lpDdePktData->dp_data_sizeData);
#endif
    hPalette = CreatePalette(lpIndirectData);
    if (hPalette == 0) {
        dwErr = GetLastError();
        DPRINTF(("Unable to create palette: %d", dwErr));
        /* CreatePalette() failed: %1 */
        NDDELogError(MSG084, LogString("%d", dwErr), NULL);
        ok = FALSE;
    }

    if( ok )  {
        *( (LPHANDLE) ((LPDATA)lpData)->info ) = hPalette;
        GlobalUnlock(hData);
        return( hData );
    } else {
        if( hPalette )  {
            GlobalFree( hPalette );
        }
        GlobalUnlock(hData);
        GlobalFree(hData);
        return( NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\ddeintf.h ===
VOID	FAR PASCAL DDEHandleInitiate( HWND hWndNetdde, HWND hWndClient, ATOM aApp, ATOM aTopic );
VOID	FAR PASCAL TerminateAllConversations( void );
BOOL	FAR PASCAL DDEIntfInit( void );

#define TIMERID_EXIT		76
#define TIMERID_CHECK_QPOST	77
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\dde1.h ===
/***********************************************\
			*	ThisFileName="d:\ww\src\wdde\dde.h"	*
			*	LastEditDate="1988 Nov 11  10:02:24"	*
			\***********************************************/
/* DDE.H: include file for Microsoft Windows apps that use DDE.
 *
 *      This file contains the definitions of the DDE constants
 *      and strucutures.
 *
 */
#ifndef DDE1_H
#define DDE1_H

/*
 *
 * The data sturcture of options for ADVISE, DATA, REQUEST and POKE
 *
 */
typedef struct {
	unsigned short unused   :12,	/* reserved for future use */
		fResponse :1,	/* in response to request  */
		fRelease  :1,	/* release data		   */
		fNoData   :1,	/* null data handle ok	   */
		fAckReq   :1;	/* Ack expected		   */
	
	short	cfFormat;	/* clipboard data format   */
} DDELNWW;
typedef DDELNWW *	LPDDELN;


/* WM_DDE_ACK message wStatus values */
#define ACK_MSG    0x8000
#define BUSY_MSG   0x4000
#define NACK_MSG   0x0000


typedef struct {
	DDELNWW     options;	        /* flags and format	*/
	unsigned    char	info[ 2 ];	/* data buffer		*/
} DATA;

typedef DATA *	PDATA;
typedef DATA *	LPDATA;


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\ddeq.h ===
#define INIT_Q_SIZE	120

typedef HANDLE	HDDEQ;

typedef struct {
    UINT_PTR	wMsg		:  4;
    UINT_PTR	fRelease	:  1;
    UINT_PTR	fAckReq		:  1;
    UINT_PTR	fResponse	:  1;
    UINT_PTR	fNoData		:  1;
    UINT_PTR	hData		: sizeof(UINT_PTR) * 8; // 32 or 64
} DDEQENT;
typedef DDEQENT FAR *LPDDEQENT;

HDDEQ	FAR PASCAL DDEQAlloc( void );
BOOL	FAR PASCAL DDEQAdd( HDDEQ, LPDDEQENT );
BOOL	FAR PASCAL DDEQRemove( HDDEQ, LPDDEQENT );
VOID	FAR PASCAL DDEQFree( HDDEQ );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ndeapi\server\nddeapiu.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEAPIU.C;1  2-Apr-93,16:21:24  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin

    NDDEAPIU.C

    Network DDE Share Api utility routines. Perform support functions for
    main API functions.

    Revisions:
     4-93   IgorM.  Wonderware new API changes for NT. Subdivide and conquer.

   $History: End */


#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

#include "nddeapi.h"
#include "nddesec.h"
#include "nddelog.h"
#include "nddemsg.h"
#define SKIP_DEBUG_WIN32
#include "debug.h"
#include "hexdump.h"
#include "ndeapi.h"
#include "shrtrust.h"
#include "unddesi.h"

#if DBG
extern BOOL bDebugDSDMErrors;
extern BOOL bDebugDSDMInfo;
#endif


/*
    Parse App Topic List
*/
BOOL NDdeParseAppTopicListA (
    LPSTR    appTopicList,
    LPSTR   *pOldStr,
    LPSTR   *pNewStr,
    LPSTR   *pStaticStr,
    PLONG    pShareType )
{
    LPSTR       pStr;
    BOOL        bAnyPresent;
    int         len;
    int         nBarPos;

    /*  There should be three fields separated by NULLs ending with a
        double NULL.  Four NULLs total.  At least one field should
        contain a valid app|topic pair.  No commas are allowed and there
        should be at least one character on each side of the vertical
        bar.
    */

    *pOldStr    = NULL;
    *pNewStr    = NULL;
    *pStaticStr = NULL;
    *pShareType = 0;

    if ( !appTopicList ) {
        return FALSE;
    }

    bAnyPresent = FALSE;
    /*  Check the old style link share. */
    pStr     = appTopicList;
    *pOldStr = pStr;
    len      = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) ) {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_OLD;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check the new style link share. */
    pStr     = pStr + strlen(pStr) + 1;
    *pNewStr = pStr;
    len      = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_NEW;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check the static data share. */
    pStr        = pStr + strlen(pStr) + 1;
    *pStaticStr = pStr;
    len         = strlen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = strcspn( pStr, BAR_CHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_STATIC;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( strchr ( pStr, SEP_CHAR )) {
        return FALSE;
    }

    /*  Check for the extra NULL at the end of the AppTopicList. */
    pStr = pStr + strlen(pStr) + 1;
    if( *pStr != '\0' ) {
        return FALSE;
    }

    return bAnyPresent;
}

BOOL NDdeParseAppTopicListW (
    LPWSTR  appTopicList,
    LPWSTR *pOldStr,
    LPWSTR *pNewStr,
    LPWSTR *pStaticStr,
    PLONG   pShareType )
{
    LPWSTR      pStr;
    BOOL        bAnyPresent;
    int         len;
    int         nBarPos;

    /*  There should be three fields separated by NULLs ending with a
        double NULL.  Four NULLs total.  At least one field should
        contain a valid app|topic pair.  No commas are allowed and there
        should be at least one character on each side of the vertical
        bar.
    */

    *pOldStr    = NULL;
    *pNewStr    = NULL;
    *pStaticStr = NULL;
    *pShareType = 0;

    if ( !appTopicList ) {
        return FALSE;
    }

    bAnyPresent = FALSE;
    /*  Check the old style link share. */
    pStr     = appTopicList;
    *pOldStr = pStr;
    len      = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_OLD;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the new style link share. */
    pStr     = pStr + wcslen(pStr) + 1;
    *pNewStr = pStr;
    len      = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_NEW;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check the static data share. */
    pStr        = pStr + wcslen(pStr) + 1;
    *pStaticStr = pStr;
    len         = wcslen( pStr );
    if ( len > 0 ) {
        bAnyPresent = TRUE;
        nBarPos = wcscspn( pStr, BAR_WCHAR );
        if( (nBarPos <= 0) || (nBarPos >= (len-1)) )  {
            return FALSE;
        }
        *pShareType |= SHARE_TYPE_STATIC;
    }

    if ( len > MAX_APPNAME ) {
        return FALSE;
    }

    if ( wcschr ( pStr, SEP_WCHAR )) {
        return FALSE;
    }

    /*  Check for the extra NULL at the end of the AppTopicList. */
    pStr = pStr + wcslen(pStr) + 1;
    if( *pStr != L'\0' ) {
        return FALSE;
    }

    return bAnyPresent;
}


/*
    Parse Item List
*/
BOOL
NDdeParseItemList (
    LPWSTR      itemList,
    LONG        cNumItems,
    PLONG       plSize )
{
    LPWSTR      lpszItem = itemList;
    int         n = 0;
    LONG        lSize = 0;
    int         nLen;

    do {
        if( *lpszItem == L'\0' )  {
            break; // while loop
        } else {
            n++;
            nLen = wcslen(lpszItem) + 1;
            lSize += nLen;
            lpszItem += nLen;
        }
    } while( *lpszItem != L'\0' );

    if( n == 0 )  {
        lSize++;                /* include first NULL of double NULL */
    }
    if( n != cNumItems )  {
        return( FALSE );
    }

    lSize ++;   // room for last NULL
    *plSize = lSize;

    return( TRUE );
}

/*
    Missileaneous Functions
*/
int
LengthMultiSzA( LPSTR pMz )
{
    int nLen;

    nLen = 0;

    if( !pMz ) {
        return 0;
    }
    if( *pMz != '\0' ) {
        while( *pMz++ != '\0' ) {
            nLen++;
            while( *pMz++ != '\0' ) {
                nLen++;
            }
            nLen++;
        }
    } else {
        nLen++;
    }
    nLen++;             /* count the second terminating '\0' */

    return nLen;
}

int
LengthMultiSzW( LPWSTR pMz )
{
    int nLen;

    nLen = 0;

    if( !pMz ) {
        return 0;
    }
    if( *pMz != L'\0' ) {
        while( *pMz++ != L'\0' ) {
            nLen++;
            while( *pMz++ != L'\0' ) {
                nLen++;
            }
            nLen++;
        }
    } else {
        nLen++;
    }
    nLen++;             /* count the second terminating '\0' */

    return nLen;
}

int
LengthAppTopicListA( LPSTR pMz )
{
    LPSTR a, b, c;
    long x;

    if( !pMz ) {
        return 0;
    }
    if( NDdeParseAppTopicListA( pMz, &a, &b, &c, &x ) ) {
        return strlen(a) + strlen(b) + strlen(c) + 4;
    } else {
        return 0;
    }

}

int
LengthAppTopicListW( LPWSTR pMz )
{
    LPWSTR a, b, c;
    long x;

    if( !pMz ) {
        return 0;
    }
    if( NDdeParseAppTopicListW( pMz, &a, &b, &c, &x ) ) {
        return wcslen(a) + wcslen(b) + wcslen(c) + 4;
    } else {
        return 0;
    }
}

BOOL
ValidateItemName ( LPWSTR itemName )
{
    if ( !itemName ) {
        return FALSE;
    }

    if ( wcslen(itemName) > MAX_ITEMNAME ) {
        return FALSE;
    }

    if ( wcschr ( itemName, SEP_CHAR ) ) {
        return FALSE;
    }

    return TRUE;
}

DWORD
PtrToOffset(
    LPVOID field,
    LPVOID base )
{

    if( field == NULL ) {
        return 0;
    } else {
        return (DWORD)((LPBYTE)field - (LPBYTE)base);
    }
}

LPVOID
OffsetToPtr(
    LPVOID base,
    DWORD offset )
{

    if( offset == 0 ) {
        return NULL;
    } else {
        return (LPVOID)((LPBYTE)base + offset);
    }
}


/*
    Get Share Serial Number
*/
BOOL
GetShareSerialNumber(
    PWCHAR  pwShareName,
    LPBYTE  lpSerialNumber)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   cbData;
    DWORD   dwType;
    WCHAR   szShareSubKey[MAX_NDDESHARENAME +
                    sizeof(DDE_SHARES_KEY_W) / sizeof(WCHAR) + 1];

    wcscpy(szShareSubKey, DDE_SHARES_KEY_W);
    wcscat(szShareSubKey, L"\\");
    wcscat(szShareSubKey, pwShareName);
    lRtn = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  szShareSubKey,
                  0,
                  KEY_QUERY_VALUE,
                  &hKey );

    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to open DDE share \"HKEY_LOCAL_MACHINE\\%ws\" key for query.",
                szShareSubKey));
        }
#endif
        return FALSE;
    }
    cbData = 2 * sizeof( LONG );
    lRtn = RegQueryValueEx( hKey,
        KEY_MODIFY_ID,
        NULL,
        &dwType,
        lpSerialNumber, &cbData );
    RegCloseKey( hKey );
    if (lRtn != ERROR_SUCCESS) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to query DDE share \"%ws\" serial number.",
                pwShareName));
        }
#endif
        return(FALSE);
    }
    return(TRUE);
}


/*
    Update Share Modify Id  (Unicode)
*/
BOOL
UpdateShareModifyId(
    HKEY    hKey,
    LONG    lSerialId[])
{
    DWORD   cbData;
    LONG    lRtn;

    cbData = 2 * sizeof( LONG );
    lRtn = RegSetValueEx( hKey,
                   KEY_MODIFY_ID,
                   0,
                   REG_BINARY,
                   (LPBYTE)lSerialId, cbData );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Set Share Modify Id: %d", lRtn));
        }
#endif
        RegCloseKey( hKey );
        return FALSE;
    }
    RegCloseKey( hKey );
    return(TRUE);
}

/*
    Update DSDM Modify Id   (Unicode)
*/
BOOL
UpdateDSDMModifyId(LONG lSerialId[])
{
    LONG    lRtn;
    HKEY    hDdeShareKey;
    DWORD   dwType;
    DWORD   cbData;

    /*  Get and update the current SerialNumber. */
    /*  Do we have to Lock the value somehow? */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                  DDE_SHARES_KEY,
                  0,
                  KEY_WRITE | KEY_READ,
                  &hDdeShareKey );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Open DSDM Key: %d", lRtn));
        }
#endif
        return FALSE;
    }
    cbData = 2 * sizeof( LONG );
    lRtn = RegQueryValueEx( hDdeShareKey,
                   KEY_MODIFY_ID,
                   NULL,
                   &dwType,
                   (LPBYTE)lSerialId,
                   &cbData );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Query DSDM Modify Id: %d", lRtn));
        }
#endif
        RegCloseKey( hDdeShareKey );
        return FALSE;
    }

    if( ++lSerialId[0] == 0 ) {
        ++lSerialId[1];
    }
    lRtn = RegSetValueEx( hDdeShareKey,
                   KEY_MODIFY_ID,
                   0,
                   REG_BINARY,
                   (LPBYTE)lSerialId, cbData );
    RegCloseKey( hDdeShareKey );
    if( lRtn != ERROR_SUCCESS ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Set DSDM Modify Id: %d", lRtn));
        }
#endif
        return FALSE;
    }
    return(TRUE);
}

/*
    Get Share's Security Descriptor stored in Registry (UNICODE)
*/
BOOL
GetShareNameSD(
    HKEY                    hKey,
    PSECURITY_DESCRIPTOR   *ppSD,
    PDWORD                  pcbData )
{
    PSECURITY_DESCRIPTOR pSD;
    DWORD       cbData;
    DWORD       dwType;
    LONG        lRtn;
    BOOL        OK = TRUE;

    /*  **********Read the key security info here. **************/
    /*  Get the size of the SD. */
    cbData = 0;
    lRtn = RegQueryValueExW( hKey,
                   L"SecurityDescriptor",
                   NULL,
                   &dwType,
                   NULL, &cbData );

    if( (lRtn != ERROR_MORE_DATA) && (lRtn != ERROR_SUCCESS) ) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to Probe share SD size: %d, cbData: %d",
                lRtn, cbData));
        }
#endif
        *pcbData = 0;
        *ppSD = NULL;
        return FALSE;
    }

    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cbData );
    if( !pSD ) {
        MEMERROR();
        /* LocalAlloc failed: %1 */
        NDDELogErrorW( MSG406, LogStringW( L"%d", GetLastError() ), NULL );
        *ppSD = NULL;
        return FALSE;
    }
    lRtn = RegQueryValueExW( hKey,
                   L"SecurityDescriptor",
                   NULL,
                   &dwType,
                   (LPBYTE)pSD, &cbData );

    if( (lRtn == ERROR_SUCCESS) && (OK = IsValidSecurityDescriptor(pSD)) ) {
        *ppSD = pSD;
        *pcbData = cbData;
        return TRUE;
    } else {
#if DBG
        if (!OK && bDebugDSDMErrors) {
            DPRINTF(("Invalid SD fished out of Registery: %d", GetLastError()));
            HEXDUMP(pSD, cbData);
        }
#endif
        /* Could not read the ShareName Security Descriptor: %1 */
        NDDELogErrorW( MSG415, LogStringW( L"%d", GetLastError() ), NULL );
        *ppSD = NULL;
        *pcbData = 0;
        LocalFree( pSD );
        return FALSE;
    }
}


/*
    Share Access Check And Audit
*/
BOOL
NDdeShareAccessCheckAudit(
    LPWSTR                  lpszShareName,
    PSECURITY_DESCRIPTOR    pSD,
    DWORD                   dwDesiredAccess,
    PGENERIC_MAPPING        pgm,
    BOOL                    fObjectCreation,
    BOOL                    fObjectDeletion,
    DWORD                  *pGrantedAccess,
    BOOL                   *pStatus )
{
    BOOL        OK;
    BOOL        fGenerateOnClose;
    HANDLE      hAudit;

    /*  Make sure the caller has the appropriate access rights. */
// DumpWhoIAm( "Doing access check" );
    hAudit = &hAudit;
    OK = AccessCheckAndAuditAlarmW(
        L"NetDDE",
        (LPVOID)&hAudit,
        L"DDE Share",
        lpszShareName,
        pSD,
        dwDesiredAccess,
        pgm,
        fObjectCreation,
        pGrantedAccess,
        pStatus,
        &fGenerateOnClose );

    if( OK && *pStatus )  {
#if DBG
        if (bDebugDSDMInfo) {
            DPRINTF(( "NddeShareAccessCheckAudit: %x => %x, %d/%d",
                dwDesiredAccess, *pGrantedAccess, *pStatus, OK ));
        }
#endif
        if (fObjectDeletion) {
            ObjectDeleteAuditAlarmW( L"NetDDE", (LPVOID)&hAudit,
                fGenerateOnClose );
        }
        ObjectCloseAuditAlarmW( L"NetDDE", (LPVOID)&hAudit,
            fGenerateOnClose );
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(( "Error -- NddeShareAccessCheckAudit: lpszShareName=%ws, pStatus=%d, OK=%d, Err=%d",
                lpszShareName, *pStatus, OK, GetLastError() ));
        }
#endif
    }

    return OK;
}

/*
    Build a new Security Descriptor from an old one and an updated one
*/
BOOL
BuildNewSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pNewSecurityDescriptor,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pPreviousSecurityDescriptor,
    PSECURITY_DESCRIPTOR    pUpdatedSecurityDescriptor
)
{
    BOOL Defaulted;
    PSID pOwnerSid;
    PSID pGroupSid;
    BOOL DaclPresent;
    PACL pDacl;
    BOOL SaclPresent;
    PACL pSacl;
    BOOL OK = TRUE;

    if( OK ) {
        if( SecurityInformation & OWNER_SECURITY_INFORMATION )
            OK = GetSecurityDescriptorOwner( pUpdatedSecurityDescriptor,
                                             &pOwnerSid, &Defaulted );
        else
            OK = GetSecurityDescriptorOwner( pPreviousSecurityDescriptor,
                                             &pOwnerSid, &Defaulted );

        if( OK )
            SetSecurityDescriptorOwner( pNewSecurityDescriptor,
                                        pOwnerSid, Defaulted );
    }

    if( OK ) {
        if( SecurityInformation & DACL_SECURITY_INFORMATION )
            OK = GetSecurityDescriptorDacl( pUpdatedSecurityDescriptor,
                                            &DaclPresent, &pDacl, &Defaulted );
        else
            OK = GetSecurityDescriptorDacl( pPreviousSecurityDescriptor,
                                            &DaclPresent, &pDacl, &Defaulted );

        if( OK )
            SetSecurityDescriptorDacl( pNewSecurityDescriptor,
                                       DaclPresent, pDacl, Defaulted );
    }

    if( OK ) {
        if( SecurityInformation & SACL_SECURITY_INFORMATION )
            OK = GetSecurityDescriptorSacl( pUpdatedSecurityDescriptor,
                                            &SaclPresent, &pSacl, &Defaulted );
        else
            OK = GetSecurityDescriptorSacl( pPreviousSecurityDescriptor,
                                            &SaclPresent, &pSacl, &Defaulted );

        if( OK )
            SetSecurityDescriptorSacl( pNewSecurityDescriptor,
                                       SaclPresent, pSacl, Defaulted );
    }

    if( OK ) {
        if ( SecurityInformation & GROUP_SECURITY_INFORMATION ) {
            OK = GetSecurityDescriptorGroup( pUpdatedSecurityDescriptor,
                                         &pGroupSid, &Defaulted );
        } else {
            OK = GetSecurityDescriptorGroup( pPreviousSecurityDescriptor,
                                         &pGroupSid, &Defaulted );
        }

        if( OK )
            OK = SetSecurityDescriptorGroup( pNewSecurityDescriptor,
                                         pGroupSid, Defaulted );
    }

    return OK;
}


/*
    Make a Self Relative Security Descriptor
 */
PSECURITY_DESCRIPTOR
AllocCopySecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PDWORD                  pLength)
{
    PSECURITY_DESCRIPTOR    pSecurityDescriptorCopy;
    DWORD                   Length;
    BOOL                    OK;

    Length = GetSecurityDescriptorLength(pSecurityDescriptor);

    if(pSecurityDescriptorCopy =
            (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, Length)) {
        MakeSelfRelativeSD(pSecurityDescriptor,
                           pSecurityDescriptorCopy,
                           &Length);
        *pLength = Length;
        OK = IsValidSecurityDescriptor(pSecurityDescriptorCopy);
        if (!OK) {
#if DBG
            if (bDebugDSDMErrors) {
                DPRINTF(("Created an invalid SD: %d, Length: %d", GetLastError(), Length));
                HEXDUMP(pSecurityDescriptorCopy, Length);
            }
#endif
            LocalFree(pSecurityDescriptorCopy);
            pSecurityDescriptorCopy = NULL;
        }
    } else {
        MEMERROR();
    }

    return pSecurityDescriptorCopy;
}

/*
    Extract Current Thread token handle
*/
BOOL
GetTokenHandleRead( PHANDLE pTokenHandle )
{
    if( !OpenThreadToken( GetCurrentThread(),
                          TOKEN_READ,
                          FALSE,
                          pTokenHandle ) ) {

        if( GetLastError() == ERROR_NO_TOKEN ) {
            if( !OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_READ,
                                   pTokenHandle ) ) {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    return TRUE;
}


/*
    Share Access Check
*/
BOOL
NDdeShareAccessCheck(
    LPWSTR                  lpszShareName,
    PSECURITY_DESCRIPTOR    pSD,
    DWORD                   dwDesiredAccess,
    PGENERIC_MAPPING        pgm,
    BOOL                    fObjectCreation,
    DWORD                  *pGrantedAccess,
    BOOL                   *pStatus )
{
    BOOL        OK;
    HANDLE      hClient;
    BYTE        BigBuf[500];
    DWORD       cbps = sizeof(BigBuf);

    OK = GetTokenHandleRead(&hClient);
    if (!OK) {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Unable to get token handle for Access Check: %d", GetLastError()));
        }
#endif
        return(FALSE);
    }

    OK =  AccessCheck(
        pSD,
        hClient,
        dwDesiredAccess,
        pgm,
        (PPRIVILEGE_SET)&BigBuf,
        &cbps,
        pGrantedAccess,
        pStatus);

    if( OK && *pStatus )  {
        CloseHandle(hClient);
        return(OK);
    } else {
#if DBG
        if (bDebugDSDMErrors) {
            DPRINTF(("Error -- Unable pass Access Check: OK=%d, Status=%d, Err=%d",
                OK, *pStatus, GetLastError()));
        }
#endif
        return FALSE;
    }

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\ddeq.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DDEQ.C;1  16-Dec-92,10:15:52  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

/*
    TODO:

        - increase Q if full
            - allocate more entries
            - copy from oldest+1 through nEntries-1 to entry 1
                [none if oldest == nEntries-1]
              from there, copy 0 to newest
                [none if newest == nEntries-1]
            - set oldest = 0
            - set newest = old nEntries-1
            - call DDEQAdd() recursively
 */

#include    "host.h"
#include    "windows.h"
#include    "spt.h"
#include    "ddeq.h"
#include    "wwassert.h"
#include    "debug.h"
#include    "nddemsg.h"
#include    "nddelog.h"

USES_ASSERT

typedef struct {
    int         oldest;
    int         newest;
    int         nEntries;
    DDEQENT     qEnt[ 1 ];
} DDEQ;
typedef DDEQ FAR *LPDDEQ;

#ifdef COMMENT
    oldest      newest  #liveEntries    valid entries
        0       0       0
        0       1       1               1
        0       2       2               1,2
        0       3       3               1,2,3
        1       3       2               2,3
        2       3       1               3
        3       3       0
        3       0       1               0


    oldest      newest  valid entries
        0       3       1,2,3
        1       0       2,3,0
        2       1       3,0,1
        3       2       0,1,2
#endif

HDDEQ
FAR PASCAL
DDEQAlloc( void )
{
    HDDEQ       hDDEQ;
    LPDDEQ      lpDDEQ;
    DWORD       size;

    size = (DWORD) sizeof( DDEQ ) + ((INIT_Q_SIZE-1) * sizeof(DDEQENT));
    hDDEQ = GetGlobalAlloc( GMEM_MOVEABLE, size);
    if( hDDEQ )  {                              // did the alloc succeed?
        lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
        assert( lpDDEQ );                       // did the lock succeed?
        lpDDEQ->newest          = 0;
        lpDDEQ->oldest          = 0;
        lpDDEQ->nEntries        = INIT_Q_SIZE;
        GlobalUnlock( hDDEQ );
    } else {
        MEMERROR();
    }

    return( hDDEQ );
}

BOOL
FAR PASCAL
DDEQAdd(
    HDDEQ       hDDEQ,
    LPDDEQENT   lpDDEQEnt )
{
    register LPDDEQ     lpDDEQ;
    int                 candidate, nEntriesNew;

    lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
    assert( lpDDEQ );
    candidate = (lpDDEQ->newest + 1) % lpDDEQ->nEntries;
    if( candidate == lpDDEQ->oldest )  {
        /*
         * Dynamically grow the queue since we are full.
         */
        nEntriesNew = lpDDEQ->nEntries + INIT_Q_SIZE;
        GlobalUnlock(hDDEQ);
        if (!GlobalReAlloc(hDDEQ,
                sizeof( DDEQ ) + ((nEntriesNew - 1) * sizeof(DDEQENT)),
                GMEM_MOVEABLE)) {
            MEMERROR();
            /* Unable to add to DDE msg queue. Newest: %1, Oldest: %2, Entries: %3 */
            NDDELogError(MSG059,
                LogString("%d", lpDDEQ->newest),
                LogString("%d", lpDDEQ->oldest),
                LogString("%d", lpDDEQ->nEntries), NULL);
            return(FALSE);
        } else {
            int i;

            lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
            assert(lpDDEQ);
            if (candidate != 0) {
                /*
                 * oldest == newest + 1 so move all the oldest ones
                 * out to the newly allocated area which moves the
                 * free space to between oldest and newest.
                 * candidate = 0 is a redundant case where no work is needed.
                 */
                for (i = lpDDEQ->nEntries - 1; i >= lpDDEQ->oldest; i--) {
                    lpDDEQ->qEnt[i + INIT_Q_SIZE] = lpDDEQ->qEnt[i];
                }
                lpDDEQ->oldest += INIT_Q_SIZE;
            }
            lpDDEQ->nEntries += INIT_Q_SIZE;
            candidate = (lpDDEQ->newest + 1) % lpDDEQ->nEntries;
        }
    }
    lpDDEQ->newest = candidate;
    lpDDEQ->qEnt[ lpDDEQ->newest ] = *lpDDEQEnt;
    GlobalUnlock( hDDEQ );

    return(TRUE);
}

BOOL
FAR PASCAL
DDEQRemove(
    HDDEQ       hDDEQ,
    LPDDEQENT   lpDDEQEnt )
{
    register LPDDEQ     lpDDEQ;
    BOOL                bRemoved;

    lpDDEQ = (LPDDEQ) GlobalLock( hDDEQ );
    assert( lpDDEQ );
    if( lpDDEQ->oldest == lpDDEQ->newest )  {
        bRemoved = FALSE;
    } else {
        lpDDEQ->oldest = (lpDDEQ->oldest + 1) % lpDDEQ->nEntries;
        *lpDDEQEnt = lpDDEQ->qEnt[ lpDDEQ->oldest ];
        bRemoved = TRUE;
    }
    GlobalUnlock( hDDEQ );

    return( bRemoved );
}

VOID
FAR PASCAL
DDEQFree( HDDEQ hDDEQ )
{
    DDEQENT     DDEQEnt;
    DWORD       size;

    while( DDEQRemove(hDDEQ, &DDEQEnt )){
        if( DDEQEnt.hData )  {
            size = (DWORD)GlobalSize((HANDLE)DDEQEnt.hData);
            if (size) {
                /*
                 * List here all the messages that are freed.
                 */
                NDDELogWarning(MSG060,
                        LogString("msg       %x\n"
                                  "fRelease  %d\n"
                                  "fAckReq   %d\n",
                                  DDEQEnt.wMsg,
                                  DDEQEnt.fRelease,
                                  DDEQEnt.fAckReq),
                        LogString("fResponse %d\n"
                                  "fNoData   %d\n"
                                  "hData     %x\n\n",
                                  DDEQEnt.fResponse,
                                  DDEQEnt.fNoData,
                                  DDEQEnt.hData), NULL);
                GlobalFree((HANDLE)DDEQEnt.hData);
            } else {
                if (!DDEQEnt.fRelease) {
                    /*  DDEQFree() releasing invalid msg handle %1 */
                    NDDELogError(MSG060,
                        LogString("0x%0X", DDEQEnt.hData), NULL);
                }
            }
        }
    }
    GlobalFree( hDDEQ );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\hndltokn.h ===
int __stdcall ForceImpersonate( HANDLE hClientAccessToken );
int __stdcall ForceClearImpersonation( void );
int __stdcall GetProcessToken( HANDLE hProcess, HANDLE *phToken );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\encrypt.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/
/* :ts=4        This file uses 4 space hard tabs */

//***   encrypt.c - This file contains the routines for session password
//                                      encryption.
#include <windows.h>
#include <hardware.h>
#include "netcons.h"
#include <des.h>


/*   Functions exported from des.c   */

//void InitLanManKey(const char FAR *Key);
void InitKeyLM( const unsigned char *KeyIn, unsigned char *KeyOut);

//void des(unsigned char *inbuf, unsigned char *outbuf, int crypt_mode);
//void desf(unsigned char FAR *inbuf, unsigned char FAR *outbuf, int crypt_mode);


#define ENCRYPT 0
#define DECRYPT 1

#include <string.h>



//* Standard text used in the password encryption process.

static char StdText[8] = "KGS!@#$%";

void Encrypt(
                char *key,                      // Key to encrypt with
                char *text,                     // 8 bytes of text to encrypt
                char *buf,                      // buffer to receive result
                int bufLen,                     // length of result buffer
                void *scratch);         // ptr to scratch space (must be least 200 bytes)


#ifdef CONN_SEG
#pragma alloc_text(CONN_SEG, Encrypt)
#endif


//**    Encrypt - encrypt text with key
//
//      This routine takes a key and encrypts 8 bytes of data with the key
//      until the result buffer is filled.  The key is advanced ahead for each
//      iteration so it must be (bufLen/8)*7 bytes long.  Any partial buffer
//      left over is filled with zeroes.

void
Encrypt(
char *key,                                      // Key to encrypt with
char *text,                                     // 8 bytes of text to encrypt
char *buf,                                      // buffer to receive result
int bufLen,
void *scratch)
{
//      Assert4(Expr, (bufLen >= CRYPT_TXT_LEN));

        do {
            DESTable KeySched;
            unsigned char keyLM[ 8 ];

            InitKeyLM(key, keyLM);
            deskey(&KeySched, keyLM);
            des(buf, text, &KeySched, ENCRYPT);

            key += CRYPT_KEY_LEN;
            buf += CRYPT_TXT_LEN;
        } while ((bufLen -= CRYPT_TXT_LEN) >= CRYPT_TXT_LEN);

        if (bufLen != 0)
                memset(buf, 0, bufLen);
        return;
}


//**    PassEncrypt - encrypt user's password
//
//      This routine takes the session encryption text and encrypts it using
//      the user's password using the following algorithm taken from encrypt.doc.
//
//  Notation for algorithm description:
//
//              All variables are named according to the convention     <letter><number>
//              where the number defines the length of the item.  And [k..j] is used
//              to specify a substring that starts at byte "k" and extends to byte "j"
//              in the specified variable.  Please note that 0 is used as the first
//              character in the string.
//
//      There is an encryption function, E, whose inputs are a seven byte
//      encryption key and and eight bytes of data and whose output is eight
//      bytes of encrypted data.
//
//      C8 is received as the data portion of the negotiate response SMB.
//
//      At the Redir the following is done to create the
//      smb_apasswd in the session setup SMB:
//
//      Let P14 be the plain text password the redirector received at logon time.
//
//      Let P24 be the session password to be sent in the session setup SMB.
//
//      First P14 is used to encrypt the standard text, S8, and obtain P21:
//              P21[0..7] = E(P14[0..6], S8)
//              P21[8..15] = E(P14[7..13], S8)
//              P21[16..20] = 0
//
//      Then P21 is used to encrypt negotiate smb_cryptkey, C8, from the server
//      to get, P24, the smb_apasswd of the session setup SMB:
//
//              P24[0..7] = E(P21[0..6], C8)
//              P24[8..15] = E(P21[7..13], C8)
//              P24[16..23] = E(P21[14..20], C8)

char    p21[21];                        // encrypted password

void
PassEncrypt(
char            *cryptkey,      // ptr to session logon is taking place on
char            *pwd,           // ptr to password string
char            *buf)           // place to store encrypted text
{
    // First encrypt the "standard text" with user's password to obtain the
    // encrypted password.

    Encrypt(pwd, StdText, p21, sizeof(p21), buf);

    // Encrypt the negotiated encryption text with the encrypted password
    // to obtain the password text to be transmitted.

    Encrypt(p21, cryptkey, buf, SESSION_PWLEN, buf+SESSION_PWLEN);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\hndltokn.c ===
#include    <hardware.h>
#include    "nt.h"
#include    "ntdef.h"
#include    "ntpsapi.h"
#define SKIP_DEBUG_WIN32
#include    "debug.h"
#include    "hndltokn.h"


int __stdcall ForceImpersonate( HANDLE hToken )
{
    NTSTATUS    Status;

    Status = NtSetInformationThread( NtCurrentThread(),
        ThreadImpersonationToken, (PVOID) &hToken, (ULONG)sizeof(hToken) );
    if ( NT_SUCCESS( Status ) )  {
        return( TRUE );
    } else {
        return( FALSE );
    }
}

int __stdcall ForceClearImpersonation( void )
{
    HANDLE      hToken = NULL;
    NTSTATUS    Status;


    Status = NtSetInformationThread( NtCurrentThread(),
        ThreadImpersonationToken, (PVOID) &hToken, (ULONG)sizeof(hToken) );
    if ( NT_SUCCESS( Status ) )  {
        return( TRUE );
    } else {
        return( FALSE );
    }
}

int __stdcall GetProcessToken( HANDLE hProcess, HANDLE *phToken )
{
    HANDLE      hToken = NULL;
    NTSTATUS    Status;
    ULONG       uLen;


    Status = NtQueryInformationProcess( hProcess, ProcessAccessToken,
        (PVOID) phToken, (ULONG)sizeof(HANDLE), &uLen );
    if ( NT_SUCCESS( Status ) )  {
        return( TRUE );
    } else {
        return( FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\enkrypt.c ===
#define		WIN31
#include "windows.h"
#include "nddeapi.h"
#include "nddeapis.h"
#include "netcons.h"
#include "debug.h"
#include <string.h>
#include <stdlib.h>
#include <memory.h>

void
PassEncrypt(
char		*cryptkey,	// ptr to session logon is taking place on
char		*pwd,		// ptr to password string
char		*buf);          // place to store encrypted text

/*
    Performs the second phase of enkryption (f2).
*/
#define MAX_K2BUF   256

static char    K2Buf[MAX_K2BUF];
static char    KeyBuf[8];
static char    PasswordBuf[MAX_PASSWORD+1];

LPBYTE WINAPI
DdeEnkrypt2(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPasswordK1,           // password output in first phase
        DWORD   cPasswordK1Size,        // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key
        DWORD   cKey,                   // size of key
        LPDWORD lpcbPasswordK2Size      // get size of resulting enkrypted stream
)
{
    DWORD   KeyLen = cKey;
    LPBYTE  lpKeyIt = lpKey;


    if( (cKey == 0) || (cPasswordK1Size == 0) )  {
        *lpcbPasswordK2Size = cPasswordK1Size;
        return(lpPasswordK1);
    } else {
        memset( PasswordBuf, 0, sizeof(PasswordBuf) );
        lstrcpy( PasswordBuf, lpPasswordK1 );
        memcpy( KeyBuf, lpKey, 8 );
        PassEncrypt( KeyBuf, PasswordBuf, K2Buf );
        *lpcbPasswordK2Size = SESSION_PWLEN;
        return( (LPBYTE)K2Buf );
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\nddegui.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDEGUI.C;1  16-Dec-92,10:16:36  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <string.h>

#include    "host.h"
#include    <windows.h>
#include    <hardware.h>
#include    "commdlg.h"
#include    "netdde.h"
#include    "netintf.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "dde.h"
#include    "ipc.h"
#include    "debug.h"
#include    "netpkt.h"
#include    "tmpbuf.h"
#include    "tmpbufc.h"
#include    "pktz.h"
#include    "router.h"
#include    "dder.h"
#include    "hexdump.h"
#include    "ddeintf.h"
#include    "dbgdde.h"
#include    "ddeq.h"
#include    "timer.h"
#include    "proflspt.h"
#include    "security.h"
#include    "fixfont.h"
#include    "secinfo.h"
typedef long INTG;
#include    "getintg.h"
#include    "nddeapi.h"
#include    "winmsg.h"
#include    "seckey.h"
#include    "nddemsg.h"
#include    "nddelog.h"


VOID
SelectOurFont(HWND hWnd)
{
    CHOOSEFONT  chf;

    _fmemset( (LPVOID)&chf, 0, sizeof(chf) );
    chf.lStructSize = sizeof(CHOOSEFONT);
    chf.hwndOwner = hWnd;
    chf.hDC = 0;
    chf.lpLogFont = &NetDDELogFont;
    chf.rgbColors = dwNetDDEFontColor;
    chf.Flags = CF_SCREENFONTS | CF_FIXEDPITCHONLY
    | CF_INITTOLOGFONTSTRUCT | CF_EFFECTS;
    chf.nFontType = SCREEN_FONTTYPE;
    if( ChooseFont( (CHOOSEFONT FAR *)&chf ) )  {
    MyWritePrivateProfileString( szGeneral, "FontName",
        NetDDELogFont.lfFaceName, szNetddeIni );
    MyWritePrivateProfileInt( szGeneral, "FontHeight",
        NetDDELogFont.lfHeight, szNetddeIni );
    MyWritePrivateProfileInt( szGeneral, "FontWeight",
        NetDDELogFont.lfWeight, szNetddeIni );
    MyWritePrivateProfileInt( szGeneral, "FontItalic",
        NetDDELogFont.lfItalic, szNetddeIni );
    MyWritePrivateProfileInt( szGeneral, "FontWidth",
        NetDDELogFont.lfWidth, szNetddeIni );
    WritePrivateProfileLong( szGeneral, "FontColor",
        dwNetDDEFontColor = chf.rgbColors, szNetddeIni );
    MyWritePrivateProfileInt( szGeneral, "FontPitchAndFamily",
        NetDDELogFont.lfPitchAndFamily, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontEscapement",
        NetDDELogFont.lfEscapement, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontOrientation",
        NetDDELogFont.lfOrientation, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontUnderline",
        NetDDELogFont.lfUnderline, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontStrikeOut",
        NetDDELogFont.lfStrikeOut, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontCharSet",
        NetDDELogFont.lfCharSet, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontOutPrecision",
        NetDDELogFont.lfOutPrecision, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontClipPrecision",
        NetDDELogFont.lfClipPrecision, szNetddeIni);
    MyWritePrivateProfileInt( szGeneral, "FontQuality",
        NetDDELogFont.lfQuality, szNetddeIni);
    if (hFont) {
        DeleteObject(hFont);
    }
    hFont = CreateFontIndirect(&NetDDELogFont);
    if (hPen) {
        DeleteObject(hPen);
    }
    hPen = CreatePen(PS_SOLID, 1, dwNetDDEFontColor);
    }
}

#define SECTION_SPACE   10

#define SETUP_HEADING_TEXT(hDC)                 \
        SetBkColor( hDC, RGB(255,255,255) );    \
        SetTextColor( hDC, RGB(0,0,0) )

#define SETUP_INFO_TEXT(hDC)                    \
        SetBkColor( hDC, RGB(255,255,255) );    \
        SetTextColor( hDC, RGB(0,0,0) )


VOID
FAR PASCAL
DoPaint(
    HWND    hWnd)
{
    PAINTSTRUCT ps;
    HDC         hDC;
    int         i;
    int         n;
    HFONT       hFontOld = 0;
    HPEN        hPenOld = 0;
    TEXTMETRIC  tmStuff;
    int         lineHeight;
    int         x;
    int         vertPos;
    int         xLine;
    int         yBoxStart;
    int         yBoxEnd;
    int         vertEnd;
    PNI         pNi;
    SIZE        Extent;
    int         xText;
    RECT        rectClient;
    extern char nameFromUser[];

    BeginPaint (hWnd, (LPPAINTSTRUCT) &ps);
    hDC = ps.hdc;
    if( ps.fErase )  {
        FillRect( hDC, &ps.rcPaint, GetStockObject(WHITE_BRUSH) );
    }

    if( hFont )  {
        hFontOld = SelectObject( hDC, hFont );
    }

    if ( hPen ) {
        hPenOld = SelectObject( hDC, hPen);
    }

    SetTextColor(hDC, dwNetDDEFontColor);
    GetClientRect( hWnd, &rectClient );
    vertEnd = rectClient.bottom;

    GetTextMetrics( hDC, (LPTEXTMETRIC)&tmStuff );
    lineHeight = tmStuff.tmExternalLeading + tmStuff.tmHeight;

    xLine = 2;
    x = xLine+2;
    vertPos = 2;

    strcpy( tmpBuf, " Network Interfaces active: " );
    if( nNiOk == 0 )  {
        strcat( tmpBuf, "NONE" );
    } else {
        for( n=0,i=0; i<nNi; i++ )  {
            pNi = &niInf[i];
            if( pNi->bOk )  {
                if( n > 0 )  {
                    strcat( tmpBuf, ", " );
                }
                n++;
                strcat( tmpBuf, pNi->niPtrs.dllName );
            }
        }
    }
    TextOut( hDC, x, vertPos, tmpBuf, lstrlen(tmpBuf) );
    vertPos += lineHeight + 2;

    if( bShowPktz && (vertPos < vertEnd))  {
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxStart = vertPos;
        vertPos += 2;

        strcpy( tmpBuf, "Connections" );
        GetTextExtentPoint( hDC, tmpBuf, lstrlen(tmpBuf), (LPSIZE)&Extent );
        xText = max( xLine,
            ((rectClient.right - rectClient.left) - Extent.cx)/2 );
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, xText, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;
        if( bShowStatistics )  {
            wsprintf( tmpBuf, " %7s %7s %-16.16s %-33.33s Status %100s",
                (LPSTR)"Sent",
                (LPSTR)"Rcvd",
                (LPSTR)"Layer",
                (LPSTR)"Node",
                (LPSTR)" " );
        } else {
            wsprintf( tmpBuf,
                " %-16.16s %-33.33s Status %100s",
                (LPSTR)"Layer",
                (LPSTR)"Node",
                (LPSTR)" " );
        }
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, x, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );

        vertPos = PktzDraw( hDC, x, vertPos+2, lineHeight ) + 2;

        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxEnd = vertPos;
        MoveTo( hDC, xLine, yBoxStart );
        LineTo( hDC, xLine, yBoxEnd );

        vertPos += SECTION_SPACE;
    }

    if( bShowRouter  && (vertPos < vertEnd))  {
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxStart = vertPos;

        vertPos += 2;

        strcpy( tmpBuf, "Routes" );
        GetTextExtentPoint( hDC, tmpBuf, lstrlen(tmpBuf), (LPSIZE)&Extent );
        xText = max( xLine,
            ((rectClient.right - rectClient.left) - Extent.cx)/2 );
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, xText, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;

        if( bShowStatistics )  {
            wsprintf( tmpBuf, " %7s %7s %-16.16s %-33.33s Status%100s",
                (LPSTR)"Sent",
                (LPSTR)"Rcvd",
                (LPSTR)"",
                (LPSTR)"Dest",
                (LPSTR)" " );
        } else {
            wsprintf( tmpBuf, " %-16.16s %-33.33s Status%100s",
                (LPSTR)"",
                (LPSTR)"Dest",
                (LPSTR)" "  );
        }
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, x, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );

        vertPos = RouterDraw( FALSE, hDC, x, vertPos + 2, lineHeight ) + 2;

        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxEnd = vertPos;
        MoveTo( hDC, xLine, yBoxStart );
        LineTo( hDC, xLine, yBoxEnd );

        vertPos += SECTION_SPACE;
    }

    if( bShowRouterThru  && (vertPos < vertEnd))  {
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxStart = vertPos;

        vertPos += 2;

        strcpy( tmpBuf, "Hops" );
        GetTextExtentPoint( hDC, tmpBuf, lstrlen(tmpBuf), (LPSIZE)&Extent );
        xText = max( xLine,
            ((rectClient.right - rectClient.left) - Extent.cx)/2 );
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, xText, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;

        if( bShowStatistics )  {
            wsprintf( tmpBuf, " %7s %7s %-16.16s %-33.33s Status%100s",
                (LPSTR)"Sent",
                (LPSTR)"Rcvd",
                (LPSTR)"Source",
                (LPSTR)"Dest",
                (LPSTR)" " );
        } else {
            wsprintf( tmpBuf, " %-16.16s %-33.33s Status%100s",
                (LPSTR)"Source",
                (LPSTR)"Dest",
                (LPSTR)" "  );
        }
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, x, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );

        vertPos = RouterDraw( TRUE, hDC, x, vertPos + 2, lineHeight ) + 2;

        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxEnd = vertPos;
        MoveTo( hDC, xLine, yBoxStart );
        LineTo( hDC, xLine, yBoxEnd );

        vertPos += SECTION_SPACE;
    }

    if( bShowDder  && (vertPos < vertEnd))  {
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxStart = vertPos;

        vertPos += 2;

        strcpy( tmpBuf, "DDE Routes" );
        GetTextExtentPoint( hDC, tmpBuf, lstrlen(tmpBuf), (LPSIZE)&Extent );
        xText = max( xLine,
            ((rectClient.right - rectClient.left) - Extent.cx)/2 );
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, xText, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;

        if( bShowStatistics )  {
            wsprintf( tmpBuf,
                " %7s %7s %-16.16s %-33.33s Status%100s",
                (LPSTR)"Sent",
                (LPSTR)"Rcvd",
                (LPSTR)"Type",
                (LPSTR)" ",
                (LPSTR)" "  );
        } else {
            wsprintf( tmpBuf, " %-16.16s %-33.33s Status%100s",
                (LPSTR)"Type",
                (LPSTR)" ",
                (LPSTR)" "  );
        }
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, x, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );

        vertPos = DderDraw( hDC, x, vertPos + 2, lineHeight ) + 2;

        yBoxEnd = vertPos;
        MoveTo( hDC, xLine, yBoxStart );
        LineTo( hDC, xLine, yBoxEnd );

        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        vertPos += SECTION_SPACE;
    }

    if( bShowIpc  && (vertPos < vertEnd))  {
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
        yBoxStart = vertPos;

        vertPos += 2;

        strcpy( tmpBuf, "Conversations" );
        GetTextExtentPoint( hDC, tmpBuf, lstrlen(tmpBuf), (LPSIZE)&Extent );
        xText = max( xLine,
            ((rectClient.right - rectClient.left) - Extent.cx)/2 );
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, xText, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;

        if( bShowStatistics )  {
            wsprintf( tmpBuf, " %7s %7s %-50.50s Status%100s",
                (LPSTR)"Sent",
                (LPSTR)"Rcvd",
                (LPSTR)"Conversation",
                (LPSTR)" "  );
        } else {
            wsprintf( tmpBuf, " %-50.50s Status%100s",
                (LPSTR)"Conversation",
                (LPSTR)" "  );
        }
        SetTextColor(hDC, dwNetDDEFontColor);
        TextOut( hDC, x, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight + 2;
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );

        vertPos = IpcDraw( hDC, x, vertPos + 2, lineHeight ) + 2;

        yBoxEnd = vertPos;
        MoveTo( hDC, xLine, yBoxStart );
        LineTo( hDC, xLine, yBoxEnd );
        MoveTo( hDC, xLine, vertPos );
        LineTo( hDC, GetSystemMetrics( SM_CXSCREEN ), vertPos );
    }

    if( hFontOld )  {
        SelectObject( hDC, hFontOld );
    }
    if( hPenOld )  {
        SelectObject( hDC, hPenOld );
    }
    EndPaint (hWnd, (LPPAINTSTRUCT) &ps);
}

BOOL
FAR PASCAL
About(
    HWND        hDlg,           /* window handle of the dialog box      */
    unsigned    message,        /* type of message                      */
    UINT        wParam,         /* message-specific information         */
    LONG        lParam )
{
    switch( message ) {

    case WM_INITDIALOG:         /* message: initialize dialog box       */
        CenterDlg(hDlg);
        SetDlgItemText( hDlg, CI_VERSION, GetString(VERS_NETDDE) );
        SetFocus( GetDlgItem( hDlg, IDOK ) );
        return FALSE;

    case WM_COMMAND:            /* message: received a command          */

        if( (wParam == IDOK) ||         /* "OK" box selected?           */
            (wParam == IDCANCEL)) {     /* System menu close command?   */

            EndDialog(hDlg, TRUE);      /* Exit the dialog box          */
            return (TRUE);
        }
        break;
    }
    return( FALSE );            /* Didn't process a message             */
}

VOID
NetIntfDlg( void )
{
    int     result;

    result = DialogBox( hInst, "NETINTF",
        hWndNetdde, (DLGPROC) NetIntfDlgProc );
    if( result < 0 )  {
        MessageBox( NULL, "Not enough memory for dialog box",
            GetAppName(), MB_TASKMODAL | MB_OK );
    }

    // redraw client area
    InvalidateRect( hWndNetdde, NULL, TRUE );
}
VOID
CloseDlg( void )
{
    int     result;

    result = DialogBox( hInst, "CLOSE", hWndNetdde, (DLGPROC) CloseDlgProc );
    if( result < 0 )  {
        MessageBox( NULL, "Not enough memory for dialog box",
            GetAppName(), MB_TASKMODAL | MB_OK );
    }

    // redraw client area
    InvalidateRect( hWndNetdde, NULL, TRUE );
}

BOOL
FAR PASCAL
_export
NetIntfDlgProc(
    HWND        hDlg,           /* window handle of the dialog box      */
    UINT        message,        /* type of message                      */
    UINT        wParam,         /* message-specific information         */
    LONG        lParam )
{
    BOOL        ok;
    WORD    nBS;

    switch( message ) {

    case WM_INITDIALOG:         /* message: initialize dialog box       */
        CenterDlg(hDlg);

    CheckDlgButton( hDlg, CI_SERIAL, NetIntfConfigured( "SERIAL" ) );
        CheckDlgButton( hDlg, CI_NETBIOS, NetIntfConfigured( "NDDENB32" ) );
        CheckDlgButton( hDlg, CI_DECNET, NetIntfConfigured( "DECNET" ) );
        SetFocus( GetDlgItem( hDlg, CI_NETBIOS ) );
        return FALSE;

    case WM_COMMAND:            /* message: received a command          */
        switch( wParam )  {
        case CI_SERIAL:
        case CI_NETBIOS:
        case CI_DECNET:
            CheckDlgButton( hDlg, wParam,
                !IsDlgButtonChecked( hDlg, wParam ) );
            break;
        case CI_HELP:
            WinHelp( hDlg, szHelpFileName, HELP_CONTEXT,
                (DWORD) HC_NETINTF );
            break;
        case IDOK:
            ok = TRUE;
            if( ok )  {
                ok = CheckNetIntfCfg( "SERIAL",
                    nBS = IsDlgButtonChecked( hDlg, CI_SERIAL ) );
                if (!ok) {
                    CheckDlgButton( hDlg, CI_SERIAL, !nBS);
                }
            }
            if( ok )  {
                ok = CheckNetIntfCfg( "NDDENB32",
                    nBS = IsDlgButtonChecked( hDlg, CI_NETBIOS ) );
                if (!ok) {
                    CheckDlgButton( hDlg, CI_NETBIOS, !nBS);
                }
            }
            if( ok )  {
                ok = CheckNetIntfCfg( "DECNET",
                    nBS = IsDlgButtonChecked( hDlg, CI_DECNET ) );
                if (!ok) {
                    CheckDlgButton( hDlg, CI_DECNET, !nBS);
                }
            }
            if( ok )  {
                EndDialog( hDlg, TRUE );
            }
            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        }
        break;
    }
    return( FALSE );            /* Didn't process a message             */
}

BOOL
FAR PASCAL
_export
PreferencesDlgProc(
    HWND        hDlg,           /* window handle of the dialog box      */
    unsigned    message,        /* type of message                      */
    UINT        wParam,         /* message-specific information         */
    LONG        lParam )
{
    BOOL        ok;
    INTG        tmp_dflt_delay;

    switch( message ) {

    case WM_INITDIALOG:         /* message: initialize dialog box       */
        CenterDlg(hDlg);

        CheckDlgButton( hDlg, CI_DFLT_DISCONNECT, bDefaultRouteDisconnect );
        PutIntg( hDlg, CI_DFLT_DELAY, nDefaultRouteDisconnectTime );
        PutIntg( hDlg, CI_TIME_SLICE, nDefaultTimeSlice );
        bTimeSliceChange = FALSE;
        CheckDlgButton( hDlg, CI_LOG_PERM_VIOL, bLogPermissionViolations );
        CheckDlgButton( hDlg, CI_LOG_EXEC_FAIL, bLogExecFailures );
        SetDlgItemText( hDlg, CI_DFLT_ROUTE, szDefaultRoute );
        SetFocus( GetDlgItem( hDlg, CI_DFLT_DISCONNECT ) );
        return FALSE;

    case WM_COMMAND:            /* message: received a command          */
        switch( wParam )  {
        case CI_HELP:
            WinHelp( hDlg, szHelpFileName, HELP_CONTEXT,
                (DWORD) HC_PREFERENCES );
            break;
        case CI_TIME_SLICE:
            if (HIWORD(lParam) == EN_CHANGE) {
                bTimeSliceChange = TRUE;
            }
            break;
        case IDOK:
            if (bTimeSliceChange) {
                if (GetIntg( hDlg, CI_TIME_SLICE, &tmp_dflt_delay) ) {
                    if (tmp_dflt_delay == -1) {
                        KillTimer( hWndNetdde, 1);
                    } else {
                        ok = GetAndValidateIntg( hDlg, CI_TIME_SLICE,
                            &tmp_dflt_delay, 55, 32768);
                        if (ok) {
                            KillTimer( hWndNetdde, 1);
                            SetTimer( hWndNetdde, 1, (int)tmp_dflt_delay, NULL );
                        }
                    }
                    if (ok) {
                        nDefaultTimeSlice = (int)tmp_dflt_delay;
                        MyWritePrivateProfileInt( szGeneral, "DefaultTimeSlice",
                            nDefaultTimeSlice, szNetddeIni);
                    }
                } else {
                    ok = FALSE;
                }
            }

            if( ok )  {
                ok = GetAndValidateIntg( hDlg, CI_DFLT_DELAY,
                    &tmp_dflt_delay, 1, 500 );
            }
            if( ok )  {
                nDefaultRouteDisconnectTime = (int)tmp_dflt_delay;
                nDefaultConnDisconnectTime = (int)tmp_dflt_delay;
                bDefaultRouteDisconnect = IsDlgButtonChecked( hDlg,
                    CI_DFLT_DISCONNECT );
                bDefaultConnDisconnect = bDefaultRouteDisconnect;
                MyWritePrivateProfileInt( szGeneral,
                    "DefaultRouteDisconnect",
                    bDefaultRouteDisconnect, szNetddeIni );
                MyWritePrivateProfileInt( szGeneral,
                    "DefaultRouteDisconnectTime",
                    nDefaultRouteDisconnectTime, szNetddeIni );
                MyWritePrivateProfileInt( szGeneral,
                    "DefaultConnectionDisconnect",
                    bDefaultConnDisconnect, szNetddeIni );
                MyWritePrivateProfileInt( szGeneral,
                    "DefaultConnectionDisconnectTime",
                    nDefaultConnDisconnectTime, szNetddeIni );

                bLogPermissionViolations = IsDlgButtonChecked( hDlg,
                    CI_LOG_PERM_VIOL );
                MyWritePrivateProfileInt( szGeneral,
                    "LogPermissionViolations", bLogPermissionViolations,
                    szNetddeIni );

                bLogExecFailures =  IsDlgButtonChecked( hDlg,
                    CI_LOG_EXEC_FAIL );
                MyWritePrivateProfileInt( szGeneral,
                    "LogExecFailures", bLogExecFailures,
                    szNetddeIni );

                GetDlgItemText( hDlg, CI_DFLT_ROUTE, szDefaultRoute,
                    sizeof(szDefaultRoute) );
                MyWritePrivateProfileString( szGeneral, "DefaultRoute",
                    szDefaultRoute, szNetddeIni );
                EndDialog( hDlg, TRUE );
            }
            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        }
        break;
    }
    return( FALSE );            /* Didn't process a message             */
}

BOOL
FAR PASCAL
_export
CloseDlgProc(
    HWND        hDlg,           /* window handle of the dialog box      */
    unsigned    message,        /* type of message                      */
    UINT        wParam,         /* message-specific information         */
    LONG        lParam )
{
    BOOL        ok  = TRUE;
    char        szName[ MAX_CONN_INFO+1 ];

    switch( message ) {

    case WM_INITDIALOG:         /* message: initialize dialog box       */
        CenterDlg(hDlg);

        SendDlgItemMessage( hDlg, CI_COMBO_NAME, CB_RESETCONTENT, 0, 0L );
        PktzEnumConnections( hDlg );
        RouterEnumConnections( hDlg );
        SendDlgItemMessage( hDlg, CI_COMBO_NAME, CB_SETCURSEL, 0, 0L );

        SetFocus( GetDlgItem( hDlg, CI_COMBO_NAME ) );
        return FALSE;

    case WM_COMMAND:            /* message: received a command          */
        switch( wParam )  {
        case CI_HELP:
            WinHelp( hDlg, szHelpFileName, HELP_CONTEXT,
                (DWORD) HC_CLOSE );
            break;
        case CI_CLOSE_ALL:
            if( MessageBox( hDlg, "Close all connections?\n\nAre you sure?",
                    GetAppName(), MB_TASKMODAL | MB_ICONQUESTION | MB_YESNO )
                        == IDYES )  {
                PktzCloseAll();
                EndDialog( hDlg, TRUE );
            }
            break;

        case IDOK:
            GetDlgItemText( hDlg, CI_COMBO_NAME, szName, sizeof(szName) );
            if( szName[0] )  {
                wsprintf( tmpBuf,
                    "Close connection to \"%s\"?\n\nAre you sure?",
                    (LPSTR) szName );
                if( MessageBox( hDlg, tmpBuf, GetAppName(),
                        MB_TASKMODAL | MB_ICONQUESTION | MB_YESNO ) == IDYES){
                    PktzCloseByName( szName );
                    RouterCloseByName( szName );
                }
            }
            EndDialog( hDlg, TRUE );
            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        }
        break;
    }
    return( FALSE );            /* Didn't process a message             */
}

/****************************************************************************

   FUNCTION:   MakeHelpPathName

   PURPOSE:    Assumes that the .HLP help file is in the same
               directory as the .exe executable.  This function derives
               the full path name of the help file from the path of the
               executable.

****************************************************************************/

VOID
FAR PASCAL
MakeHelpPathName(
    char    *szFileName,
    int     nMax )
{
   char *  pcFileName;
   int     nFileNameLen;

   nFileNameLen = GetModuleFileName( hInst, szFileName, nMax );
   pcFileName = szFileName + nFileNameLen;

   while (pcFileName > szFileName) {
       if( (*pcFileName == '\\') || (*pcFileName == ':') ) {
           *(++pcFileName) = '\0';
           break;
       }
       nFileNameLen--;
       pcFileName--;
   }

   if( (nFileNameLen+13) < nMax ) {
       lstrcat( szFileName, "netdde.hlp" );
   } else {
       lstrcat( szFileName, "?" );
   }
}


BOOL
FAR PASCAL
NetIntfConfigured( LPSTR lpszName )
{
    int         i;

    for ( i=0; i<MAX_NETINTFS; i++ )  {
        wsprintf( tmpBuf2, szInterfaceFmt, i+1 );
        MyGetPrivateProfileString( szInterfaces, tmpBuf2,
            "", tmpBuf, sizeof(tmpBuf), szNetddeIni );

        if ( tmpBuf[0] == '\0' )
            break;      // done looking
        else {
            AnsiUpper( tmpBuf );
            if ( _fstrstr( tmpBuf, lpszName ) )
                        return( TRUE );
                }
        }
    return( FALSE );
}



BOOL
FAR PASCAL
CheckNetIntfCfg(
    LPSTR   lpszName,
    BOOL    bConfigured )
{
    if( NetIntfConfigured( lpszName ) == bConfigured )  {
        // user didn't change the selection
        return( TRUE );
    }

    // user changed the selection for this
    if( bConfigured )  {
        // user trying to add the netintf
        if( AddNetIntf( lpszName ) )  {
            wsprintf( tmpBuf, "Added \"%s\" Network Interface", lpszName );
            MessageBox( NULL, tmpBuf, GetAppName(),
                MB_TASKMODAL | MB_OK | MB_ICONINFORMATION );
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        if( PktzAnyActiveForNetIntf( lpszName ) )  {
            wsprintf( tmpBuf,
                "Cannot deconfigure \"%s\".\nActive connections.\n\nUse /Connections/Close Direct",
                lpszName );
            MessageBox( NULL, tmpBuf, GetAppName(),
                MB_ICONSTOP | MB_TASKMODAL | MB_OK );
            return( FALSE );
        } else {
            // user trying to delete the netintf
            wsprintf( tmpBuf, "Really deconfigure \"%s\"?", lpszName );
            if( MessageBox( NULL, tmpBuf, GetAppName(),
                MB_ICONQUESTION | MB_TASKMODAL | MB_YESNO ) == IDYES)  {

                // it seems odd that we're doing this again, but here's the
                // reason.  We want to check this before asking the guy if
                // he's sure, just to be courteous.
                //
                // But, if a new connection comes in while the dialog is up
                // we don't want to get a protection violation!
                if( PktzAnyActiveForNetIntf( lpszName ) )  {
                    wsprintf( tmpBuf,
                        "Cannot deconfigure \"%s\".\nActive connections.\n\nUse /Connections/Close Direct",
                        lpszName );
                    MessageBox( NULL, tmpBuf, GetAppName(),
                        MB_ICONSTOP | MB_TASKMODAL | MB_OK );
                    return( FALSE );
                }
                return( DeleteNetIntf( lpszName ) );
            } else {
                return( FALSE );
            }
        }
    }
    return( FALSE );
}


VOID
FAR PASCAL
ReverseMenuBoolean(
    int     idMenu,
    BOOL   *pbItem,
    PSTR    pszIniName )
{
    HMENU       hMenu;

    *pbItem = !*pbItem;
    hMenu = GetMenu( hWndNetdde );
    CheckMenuItem( hMenu, idMenu, *pbItem ? MF_CHECKED : MF_UNCHECKED );
    WritePrivateProfileLong( szGeneral, pszIniName, (LONG)*pbItem,
        szNetddeIni );
    InvalidateRect( hWndNetdde, NULL, TRUE );
    UpdateWindow( hWndNetdde );
}

VOID
FAR PASCAL
ReverseSysMenuBoolean(
    int     idMenu,
    BOOL   *pbItem,
    PSTR    pszIniName )
{
    HMENU       hMenu;

    *pbItem = !*pbItem;
    hMenu = GetSystemMenu( hWndNetdde, FALSE );
    CheckMenuItem( hMenu, idMenu, *pbItem ? MF_CHECKED : MF_UNCHECKED );
    WritePrivateProfileLong( szGeneral, pszIniName, (LONG)*pbItem,
        szNetddeIni );
    InvalidateRect( hWndNetdde, NULL, TRUE );
    UpdateWindow( hWndNetdde );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\netcons.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  NETCONS.H				    *
 *								    *
 *  This file contains constants used throughout the LAN Manager    *
 *  API header files.  It should be included in any source file     *
 *  that is going to include other LAN Manager API header files or  *
 *  call a LAN Manager API.					    *
 *								    *
 ********************************************************************/

/*
 *	NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *	strlen() value.  This does not include space for the 
 *	terminating 0-byte.  When allocating space for such an item,
 *	use the form:
 *
 *		char username[UNLEN+1];
 *
 *	An exception to this is the PATHLEN manifest, which does
 *	include space for the terminating 0-byte.
 */

#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED


#define CNLEN		15		    /* Computer name length     */
#define UNCLEN		(CNLEN+2)	    /* UNC computer name length */
#define NNLEN		12		    /* 8.3 Net name length      */
#define RMLEN		(UNCLEN+1+NNLEN)    /* Maximum remote name length */

#define SNLEN		15		    /* Service name length      */
#define STXTLEN		63		    /* Service text length      */

#define PATHLEN 	260

#define DEVLEN		 8 		    /* Device name length	*/

#define DNLEN		CNLEN		    /* Maximum domain name length */
#define EVLEN		16		    /* event name length        */
#define JOBSTLEN	80		    /* status length in print job */
#define	AFLEN		64		    /* Maximum length of alert  */
					    /* names field 		*/
#define UNLEN		20	   	    /* Maximum user name length	*/
#define GNLEN 		UNLEN		    /* Group name               */
#define PWLEN		14		    /* Maximum password length  */
#define SHPWLEN 	 8		    /* Share password length	*/
#define CLTYPE_LEN	12		    /* Length of client type string */


#define MAXCOMMENTSZ	48		    /* server & share comment length */

#define QNLEN		12		    /* Queue name maximum length     */
#define PDLEN		 8		    /* Print destination length      */
#define DTLEN		 9	            /* Spool file data type          */
					    /* e.g. IBMQSTD,IBMQESC,IBMQRAW  */
#define ALERTSZ		128		    /* size of alert string in server */
#define MAXDEVENTRIES	(sizeof (int)*8)    /* Max number of device entries   */
					    /* We use int bitmap to represent */

#define	HOURS_IN_WEEK		24*7	    /* for struct user_info_2 in UAS */
#define	MAXWORKSTATIONS		8	    /* for struct user_info_2 in UAS */

#define NETBIOS_NAME_LEN	16	    /* NetBIOS net name */



/*
 *	Constants used with encryption
 */

#define	CRYPT_KEY_LEN	7
#define	CRYPT_TXT_LEN	8
#define ENCRYPTED_PWLEN	16
#define SESSION_PWLEN	24
#define SESSION_CRYPT_KLEN 21

/*
 *  Value to be used with SetInfo calls to allow setting of all
 *  settable parameters (parmnum zero option)
*/
#ifndef  PARMNUM_ALL
#define		PARMNUM_ALL		0
#endif

/*
 *	Message File Names
 */

#define MESSAGE_FILE		"NETPROG\\NET.MSG"
#define MESSAGE_FILENAME	"NET.MSG"
#define OS2MSG_FILE		"NETPROG\\OSO001.MSG"
#define OS2MSG_FILENAME		"OSO001.MSG"
#define HELP_MSG_FILE		"NETPROG\\NETH.MSG"
#define HELP_MSG_FILENAME	"NETH.MSG"
#define NMP_MSG_FILE		"NETPROG\\NMP.MSG"
#define NMP_MSG_FILENAME	"NMP.MSG"

#define MESSAGE_FILE_BASE	"NETPROG\\NET00000"
#define MESSAGE_FILE_EXT	".MSG"



#define NMP_LOW_END		230
#define NMP_HIGH_END		240

#ifndef NULL
#define  NULL    0
#endif


#define PUNAVAIL NULL
#define API_RET_TYPE unsigned
#define API_FUNCTION API_RET_TYPE far pascal







#endif /* NETCONS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\nddeserv.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDESERV.C;1  16-Dec-92,10:16:44  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <string.h>

#include    "host.h"
#include    <windows.h>
#include    <hardware.h>
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "debug.h"
#include    "netbasic.h"
#include    "ddepkts.h"
#include    "netddesh.h"
#include    "critsec.h"

VOID NDDELogEventW(DWORD EventId, WORD fwEventType, WORD cStrings, LPWSTR *aszMsg);
void RefreshNDDECfg(void);
/*
    Global Start-Up Arguments .. saved by service launcher
*/
extern  HANDLE  hInstance;          /* current instance             */
extern  LPSTR   lpCmdLine;          /* command line                 */
extern  int     nCmdShow;           /* show-window type (open/icon) */

extern  BOOL    bNDDEPaused;        /* stop servicing main window msgs */
extern  BOOL    bNetddeClosed;
extern  HANDLE  hInst;

extern  HANDLE  hThreadPipe;

extern  DWORD   __stdcall   StartRpc( DWORD dwParam );
extern  VOID    __stdcall   NddeMain(DWORD nThreadInput);

/*************************************************************
*   Launching NetDDE as a NT Service
**************************************************************/

/* Other Globals */

SERVICE_STATUS          ssStatus;
SERVICE_STATUS_HANDLE   sshNDDEStatusHandle;
SERVICE_STATUS_HANDLE   sshDSDMStatusHandle;
HANDLE                  hDSDMServDoneEvent = 0;
HANDLE                  hNDDEServDoneEvent = 0;
HANDLE                  hNDDEServStartedEvent = 0;

HANDLE                  hThread;
DWORD                   IdThread;
HANDLE                  hThreadRpc;
DWORD                   IdThreadRpc;

/* exit code that is set by any thread when error occurs */

DWORD                   dwGlobalErr = NO_ERROR;


VOID    NDDEMainFunc(DWORD dwArgc, LPTSTR *lpszArgv);
VOID    NDDEServCtrlHandler (DWORD dwCtrlCode);
VOID    DSDMMainFunc(DWORD dwArgc, LPTSTR *lpszArgv);
VOID    DSDMServCtrlHandler (DWORD dwCtrlCode);

BOOL    ReportStatusToSCMgr (   HANDLE hService,
                                SERVICE_STATUS_HANDLE sshNDDEStatusHandle,
                                DWORD dwCurrentState,
                                DWORD dwWin32ExitCode,
                                DWORD dwCheckPoint,
                                DWORD dwWaitHint);
BOOL    NDDESrvInit( VOID );
BOOL    DSDMSrvInit( VOID );

VOID PauseNDDESrv( VOID );
VOID ResumeNDDESrv( VOID );
VOID PauseDSDMSrv( VOID );
VOID ResumeDSDMSrv( VOID );

int
APIENTRY
WinMain(
    HINSTANCE  hInstancex,
    HINSTANCE  hPrevInstancex,
    LPSTR      lpCmdLinex,
    INT        nCmdShowx )
{

    SERVICE_TABLE_ENTRY   steDispatchTable[] = {

        /* entry for "NetDDE" */
        { TEXT("NetDDE"),(LPSERVICE_MAIN_FUNCTION) NDDEMainFunc},

        /* entry for "NetDDEdsdm" */
        { TEXT("NetDDEdsdm"),(LPSERVICE_MAIN_FUNCTION) DSDMMainFunc},

        /* NULL entry designating end of table */
        { NULL, NULL }
    };

  /*
   * Main thread of service process starts service control
   * dispatcher that dispatches start and control requests
   * for the services specified in steDispatchTable. This
   * function does not return unless there is an error.
   */
    hInstance = hInstancex;
#if DBG
    DebugInit( "NetDDE" );
#endif
    lpCmdLine = lpCmdLinex;
    nCmdShow = nCmdShowx;
    if( !StartServiceCtrlDispatcher( steDispatchTable ) ) {
        NDDELogError(MSG074, LogString("%d", GetLastError()), NULL );
    }
    return 0;
}



/*
 * SERVICE_MAIN_FUNCTION of "NetDDEService"
 *
 * When service is started, the service control dispatcher
 * creates a new thread to execute this function.
 */

VOID
NDDEMainFunc(
    DWORD dwArgc,
    LPTSTR *lpszArgv )
{

  DWORD dwWait;

  TRACEINIT((szT, "NDDEMainFunc: Entering."));

  /* Register control handler function for this service */

  sshNDDEStatusHandle = RegisterServiceCtrlHandler(
          TEXT("NetDDE"),           /* service name             */
          NDDEServCtrlHandler);      /* control handler function */

  if ( sshNDDEStatusHandle == (SERVICE_STATUS_HANDLE) 0 ) {
      TRACEINIT((szT, "NDDEMainFunc: Error1 Leaving."));
      goto Cleanup;
  }

  /* SERVICE_STATUS members that don't change in example */

  ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
  ssStatus.dwServiceSpecificExitCode = 0;

  /* Report status to Service Control Manager */

  if( !ReportStatusToSCMgr(
      NULL,
      sshNDDEStatusHandle,
      SERVICE_START_PENDING, /* service state */
      NO_ERROR,              /* exit code     */
      1,                     /* checkpoint    */
      5000) ) {              /* wait hint     */

      goto Cleanup;
  }

  /*
   * Create event object. Control handler function signals
   * this event when it receives the "stop" control code.
   */

  hNDDEServDoneEvent = CreateEvent (
      NULL,    /* no security attributes */
      TRUE,    /* manual reset event     */
      FALSE,   /* not-signalled          */
      NULL) ;  /* no name                */

  if ( hNDDEServDoneEvent == (HANDLE) 0 ) {
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hNDDEServDoneEvent,
            sshNDDEStatusHandle,
            SERVICE_START_PENDING, /* service state */
            NO_ERROR,              /* exit code     */
            2,                     /* checkpoint    */
            500) ) {               /* wait hint     */
        goto Cleanup;
    }

  hNDDEServStartedEvent = CreateEvent (
      NULL,    /* no security attributes */
      TRUE,    /* manual reset event     */
      FALSE,   /* not-signalled          */
      NULL) ;  /* no name                */

  if ( hNDDEServStartedEvent == (HANDLE) 0 ) {
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hNDDEServDoneEvent,
            sshNDDEStatusHandle,
            SERVICE_START_PENDING, /* service state */
            NO_ERROR,              /* exit code     */
            3,                     /* checkpoint    */
            500) ) {               /* wait hint     */
        goto Cleanup;
    }

  /* start thread that performs work of service */

  if( !NDDESrvInit() ) {
      TRACEINIT((szT, "NDDEMainFunc: NDDESrvInit failed."));
      goto Cleanup;
  }

  /*
   * Wait till NetDDE is truely ready to handle DDE
   */
  WaitForSingleObject(hNDDEServStartedEvent, INFINITE);
  CloseHandle(hNDDEServStartedEvent);
  hNDDEServStartedEvent = 0;

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hNDDEServDoneEvent,
            sshNDDEStatusHandle,
            SERVICE_RUNNING, /* service state */
            NO_ERROR,        /* exit code     */
            0,               /* checkpoint    */
            0) ) {           /* wait hint     */
        goto Cleanup;
    }

  /* Wait indefinitely until hNDDEServDoneEvent is signalled */

    TRACEINIT((szT, "NDDEMainFunc: Waiting on hNDDEServDoneEvent=%x.",
            hNDDEServDoneEvent));
    dwWait = WaitForSingleObject (
        hNDDEServDoneEvent,  /* event object      */
        INFINITE);       /* wait indefinitely */
    TRACEINIT((szT, "NDDEMainFunc: hNDDEServDoneEvent=%x is signaled.",
            hNDDEServDoneEvent));

  /* Wait for the Pipe Thread to exit. */

    if (hThreadPipe) {
        TRACEINIT((szT, "NDDEMainFunc: Waiting for Pipe Thread to exit."));
        WaitForSingleObject(hThreadPipe, INFINITE);
        TRACEINIT((szT, "NDDEMainFunc: Pipe Thread has exited."));

        CloseHandle(hThreadPipe);
        hThreadPipe = NULL;
    }

Cleanup :

    EnterCrit();
    if (hNDDEServDoneEvent != 0) {
        TRACEINIT((szT, "NDDEMainFunc: Closing hNDDEServDoneEvent=%x",
            hNDDEServDoneEvent));
        CloseHandle(hNDDEServDoneEvent);
        hNDDEServDoneEvent = 0;
    }
    if (hNDDEServStartedEvent != 0) {
        CloseHandle(hNDDEServStartedEvent);
        hNDDEServStartedEvent = 0;
    }
    LeaveCrit();

  /* try to report stopped status to SC Manager */

    if (sshNDDEStatusHandle != 0) {
        (VOID) ReportStatusToSCMgr(
                    NULL,
                    sshNDDEStatusHandle,
                    SERVICE_STOPPED, dwGlobalErr, 0, 0);
    }

  /*
   * When SERVICE_MAIN_FUNCTION returns in a single service
   * process, the StartServiceCtrlDispatcher function in
   * the main thread returns, terminating the process.
   */

  TRACEINIT((szT, "NDDEMainFunc: leaving"));


  // Remove this exitprocess call for #326041
  // This can kill netddedsdm prematurely and uncleanly.
#if 0
      /*
       * just to make sure, do it here.
       */
      ExitProcess(0);
#endif

  return;

}

/*
 * SERVICE_MAIN_FUNCTION of "DSDMService"
 *
 * When service is started, the service control dispatcher
 * creates a new thread to execute this function.
 */

VOID
DSDMMainFunc(
    DWORD dwArgc,
    LPTSTR *lpszArgv )
{

  DWORD dwWait;

  /* Register control handler function for this service */

  TRACEINIT((szT, "DSDMMainFunc: Entering."));

  sshDSDMStatusHandle = RegisterServiceCtrlHandler(
          TEXT("NetDDEdsdm"),  /* service name             */
          DSDMServCtrlHandler); /* control handler function */

  if ( sshDSDMStatusHandle == (SERVICE_STATUS_HANDLE) 0 ) {
      TRACEINIT((szT, "DSDMMainFunc: Error1 Leaving."));
      goto Cleanup;
  }

  /* SERVICE_STATUS members that don't change in example */

  ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
  ssStatus.dwServiceSpecificExitCode = 0;

  /* Report status to Service Control Manager */

  if( !ReportStatusToSCMgr(
      hDSDMServDoneEvent,
      sshDSDMStatusHandle,
      SERVICE_START_PENDING, /* service state */
      NO_ERROR,              /* exit code     */
      1,                     /* checkpoint    */
      500) ) {              /* wait hint     */

      TRACEINIT((szT, "DSDMMainFunc: Error2 Leaving."));
      goto Cleanup;
  }

  /*
   * Create event object. Control handler function signals
   * this event when it receives the "stop" control code.
   */

  hDSDMServDoneEvent = CreateEvent (
      NULL,    /* no security attributes */
      TRUE,    /* manual reset event     */
      FALSE,   /* not-signalled          */
      NULL) ;  /* no name                */

  if ( hDSDMServDoneEvent == (HANDLE) 0 ) {
      TRACEINIT((szT, "DSDMMainFunc: Error3 Leaving."));
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hDSDMServDoneEvent,
            sshDSDMStatusHandle,
            SERVICE_START_PENDING, /* service state */
            NO_ERROR,              /* exit code     */
            2,                     /* checkpoint    */
            500) ) {              /* wait hint     */
        TRACEINIT((szT, "DSDMMainFunc: Error4 Leaving."));
        goto Cleanup;
    }

  /* start thread that performs work of service */

  if( !DSDMSrvInit() ) {
      goto Cleanup;
  }

  /* Report status to Service Control Manager */

    if( !ReportStatusToSCMgr(
            hDSDMServDoneEvent,
            sshDSDMStatusHandle,
            SERVICE_RUNNING, /* service state */
            NO_ERROR,        /* exit code     */
            0,               /* checkpoint    */
            0) ) {           /* wait hint     */
        TRACEINIT((szT, "DSDMMainFunc: Error5 Leaving."));
        goto Cleanup;
    }

  /* Wait indefinitely until hDSDMServDoneEvent is signalled */

    TRACEINIT((szT, "DSDMMainFunc: Waiting on hDSDMServDoneEvent=%x.",
            hDSDMServDoneEvent));
    dwWait = WaitForSingleObject (
        hDSDMServDoneEvent,  /* event object      */
        INFINITE);       /* wait indefinitely */
    TRACEINIT((szT, "DSDMMainFunc: hDSDMServDoneEvent=%x is signaled.",
            hDSDMServDoneEvent));

Cleanup :

    if (hDSDMServDoneEvent != 0) {
        TRACEINIT((szT, "DSDMMainFunc: Closing hDSDMServDoneEvent=%x",
            hDSDMServDoneEvent));
        CloseHandle(hDSDMServDoneEvent);
        hDSDMServDoneEvent = 0;
    }

  /* try to report stopped status to SC Manager */

    if (sshDSDMStatusHandle != 0) {
        (VOID) ReportStatusToSCMgr(
            hDSDMServDoneEvent,
            sshDSDMStatusHandle,
            SERVICE_STOPPED, dwGlobalErr, 0, 0);
    }

  /*
   * When SERVICE_MAIN_FUNCTION returns in a single service
   * process, the StartServiceCtrlDispatcher function in
   * the main thread returns, terminating the process.
   */

  TRACEINIT((szT, "DSDMMainFunc: Leaving."));
  return;

}



/*
 * ReportStatusToSCMgr function
 *
 * This function is called by the MainFunc() and
 * by the ServCtrlHandler() to update the service's status
 * to the Service Control Manager.
 */


BOOL
ReportStatusToSCMgr(
    HANDLE  hService,
    SERVICE_STATUS_HANDLE   sshStatusHandle,
    DWORD   dwCurrentState,
    DWORD   dwWin32ExitCode,
    DWORD   dwCheckPoint,
    DWORD   dwWaitHint )
{
  BOOL fResult;

  /* disable control requests until service is started */

  if (dwCurrentState == SERVICE_START_PENDING) {
      ssStatus.dwControlsAccepted = 0;
  } else {
      ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                           SERVICE_ACCEPT_PAUSE_CONTINUE;
  }


  /* These SERVICE_STATUS members set from parameters */

  ssStatus.dwCurrentState = dwCurrentState;
  ssStatus.dwWin32ExitCode = dwWin32ExitCode;
  ssStatus.dwCheckPoint = dwCheckPoint;
  ssStatus.dwWaitHint = dwWaitHint;

  TRACEINIT((szT, "ReportStatusToSCMgr: dwCurrentState=%x.",
        dwCurrentState));
  /* Report status of service to Service Control Manager */

    if (! (fResult = SetServiceStatus (
          sshStatusHandle,    /* service reference handle */
          &ssStatus) ) ) {    /* SERVICE_STATUS structure */

        /* if error occurs, stop service */
        NDDELogError(MSG075, LogString("%d", GetLastError()), NULL);
        if (hService) {
            SetEvent(hService);
        }
  }
  return fResult;
}


/*
 * Service control dispatcher invokes this function when it
 * gets a control request from the Service Control Manager.
 */

VOID
NDDEServCtrlHandler( DWORD dwCtrlCode ) {

  DWORD  dwState = SERVICE_RUNNING;
  PTHREADDATA ptd;

  /* Handle the requested control code */

  switch(dwCtrlCode) {

      /* pause the service if its running */

      case SERVICE_CONTROL_PAUSE:

          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_PAUSE"));
          if (ssStatus.dwCurrentState == SERVICE_RUNNING) {
              PauseNDDESrv();

              dwState = SERVICE_PAUSED;
          }
          break;

      /* resume paused service */

      case SERVICE_CONTROL_CONTINUE:

          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_CONTINUE"));
          if (ssStatus.dwCurrentState == SERVICE_PAUSED) {
              ResumeNDDESrv();
              dwState = SERVICE_RUNNING;
          }
          break;

      /* stop the service */

      case SERVICE_CONTROL_STOP:

          dwState = SERVICE_STOP_PENDING;

          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_STOP"));
          if (!bNetddeClosed) {     /* drop our window too */
              for (ptd = ptdHead; ptd != NULL; ptd = ptd->ptdNext) {
                  TRACEINIT((szT, "NDDEServCtrlHandler: Destroying hwndDDE=%x", ptd->hwndDDE));
                  SendMessage(ptd->hwndDDE, WM_DESTROY, 0, 0);
              }
          }

          /*
           * Report status, specifying checkpoint and wait
           * hint, before setting termination event
           */

          (VOID) ReportStatusToSCMgr(
                    hNDDEServDoneEvent,
                    sshNDDEStatusHandle,
                   SERVICE_STOP_PENDING, /* current state */
                   NO_ERROR,             /* exit code     */
                   1,                    /* check point   */
                   500);                /* wait hint     */


            NDDELogInfo(MSG076, NULL);
            TRACEINIT((szT, "NDDEServCtrlHandler: Setting hNDDEServDoneEvent=%x",
                    hNDDEServDoneEvent));
            if (hNDDEServDoneEvent) {
                SetEvent(hNDDEServDoneEvent);
            }
            return;


      /* update service status */

      case SERVICE_CONTROL_INTERROGATE:
          TRACEINIT((szT, "NDDEServCtrlHandler: SERVICE_CONTROL_INTERROGATE"));
          break;

      /* invalid control code */

      default:
          break;

    }

    /* Send a status response */

    (VOID) ReportStatusToSCMgr(
                    hNDDEServDoneEvent,
                    sshNDDEStatusHandle,
                    dwState, NO_ERROR, 0, 0);

}

/*
 * Service control dispatcher invokes this function when it
 * gets a control request from the Service Control Manager.
 */

VOID
DSDMServCtrlHandler( DWORD dwCtrlCode ) {

  DWORD  dwState = SERVICE_RUNNING;
  PTHREADDATA ptd;

  /* Handle the requested control code */

  switch(dwCtrlCode) {

      /* pause the service if its running */

      case SERVICE_CONTROL_PAUSE:

          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_PAUSE"));
          if (ssStatus.dwCurrentState == SERVICE_RUNNING) {
              PauseDSDMSrv();

              dwState = SERVICE_PAUSED;
          }
          break;

      /* resume paused service */

      case SERVICE_CONTROL_CONTINUE:

          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_CONTINUE"));
          if (ssStatus.dwCurrentState == SERVICE_PAUSED) {
              ResumeDSDMSrv();
              dwState = SERVICE_RUNNING;
          }
          break;

      /* stop the service */

      case SERVICE_CONTROL_STOP:

          dwState = SERVICE_STOP_PENDING;

          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_STOP"));
          if (!bNetddeClosed) {     /* drop our window too */
              for (ptd = ptdHead; ptd != NULL; ptd = ptd->ptdNext) {
                  TRACEINIT((szT, "DSDMServCtrlHandler: Destroying hwndDDE=%x", ptd->hwndDDE));
                  SendMessage(ptd->hwndDDE, WM_DESTROY, 0, 0);
              }
          }

          /*
           * Report status, specifying checkpoint and wait
           * hint, before setting termination event
           */

          (VOID) ReportStatusToSCMgr(
                    hDSDMServDoneEvent,
                    sshDSDMStatusHandle,
                   SERVICE_STOP_PENDING, /* current state */
                   NO_ERROR,             /* exit code     */
                   1,                    /* check point   */
                   500);                /* wait hint     */


            NDDELogInfo(MSG077, NULL);
            TRACEINIT((szT, "DSDMServCtrlHandler: Setting hDSDMServDoneEvent=%x", hDSDMServDoneEvent));
            if (hDSDMServDoneEvent) {
                SetEvent(hDSDMServDoneEvent);
            }
            return;


      /* update service status */

      case SERVICE_CONTROL_INTERROGATE:
          TRACEINIT((szT, "DSDMServCtrlHandler: SERVICE_CONTROL_INTERROGATE"));
          break;

      /* invalid control code */

      default:
          break;

    }

    /* Send a status response */

    (VOID) ReportStatusToSCMgr(
                    hDSDMServDoneEvent,
                    sshDSDMStatusHandle,
                    dwState, NO_ERROR, 0, 0);

}


VOID
PauseNDDESrv( VOID )
{
#ifdef  HASUI
    PTHREADDATA ptd;

    wsprintf( tmpBuf, "%s - \"%s\" - Paused",
        (LPSTR)szAppName, (LPSTR)ourNodeName );
    for (ptd = ptdHead; ptd != NULL; ptd = ptd->ptdNext)
        SetWindowText( ptd->hwndDDE, tmpBuf );
    }
#endif
    bNDDEPaused = TRUE;
}

VOID
ResumeNDDESrv( VOID )
{
#ifdef  HASUI
    PTHREADDATA ptd;

    wsprintf( tmpBuf, "%s - \"%s\"",
        (LPSTR)szAppName, (LPSTR)ourNodeName );
    for (ptd = ptdHead; ptd != NULL; ptd = ptd->ptdNext)
        SetWindowText( ptd->hwndDDE, tmpBuf );
#endif
    bNDDEPaused = FALSE;
}

VOID
PauseDSDMSrv( VOID )
{
    bNDDEPaused = TRUE;
}

VOID
ResumeDSDMSrv( VOID )
{
    bNDDEPaused = FALSE;
}

/*
    Initialize Main NetDDE Proc
*/
BOOL
NDDESrvInit( VOID )
{
    RefreshNDDECfg();

    TRACEINIT((szT, "NDDESrvInit: Creating thread for NddeMain."));
    hThread = CreateThread(
        NULL,           /* Default security                  */
        0,              /* Same stack size as primary thread */
        (LPTHREAD_START_ROUTINE)NddeMain, /* Start address   */
        0,              /* Parameter to WindowThread()       */
        0,              /* Run immediately                   */
        &IdThread );    /* Where to store thread id          */

    if (hThread) {
        CloseHandle(hThread);
        return TRUE;
    } else {
        NDDELogError(MSG071, LogString("%d", GetLastError()), NULL);
        return(FALSE);
    }
}

/*
    Initialize Main DSDM Proc
*/
BOOL
DSDMSrvInit( VOID )
{
    hThreadRpc = CreateThread(
        NULL,           /* Default security                  */
        0,              /* Same stack size as primary thread */
        (LPTHREAD_START_ROUTINE)StartRpc, /* Start address   */
        (LPVOID)hInst,  /* Parameter          */
        0,              /* Run immediately                   */
        &IdThreadRpc ); /* Where to store thread id          */

    if (hThreadRpc) {
        CloseHandle(hThreadRpc);
        return TRUE;
    } else {
        NDDELogError(MSG072, LogString("%d", GetLastError()), NULL);
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\netdde.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NETDDE.C;3  9-Feb-93,17:59:36  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <string.h>

#include    "host.h"
#include    <windows.h>
#include    <hardware.h>
#include    <malloc.h>
#include    "commdlg.h"
#include    "netdde.h"
#include    "netintf.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "dde.h"
#include    "ipc.h"
#include    "debug.h"
#include    "netpkt.h"
#include    "tmpbuf.h"
#include    "tmpbufc.h"
#include    "pktz.h"
#include    "router.h"
#include    "dder.h"
#include    "hexdump.h"
#include    "ddeintf.h"
#include    "dbgdde.h"
#include    "ddeq.h"
#include    "timer.h"
#include    "proflspt.h"
#include    "security.h"
#include    "fixfont.h"
#include    "secinfo.h"
typedef long INTG;
#include    "getintg.h"
#include    "nddeapi.h"
#include    "winmsg.h"
#include    "seckey.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "netddesh.h"
#include    "nddeagnt.h"
#include    "critsec.h"

/*
    Run-Time Options
*/
#define DEFAULT_START_LOGGER    FALSE
#define DEFAULT_TIME_SLICE      1000
#define DEFAULT_START_APP       TRUE
#define DEFAULT_SECURITY_TYPE   NT_SECURITY_TYPE
#define AGING_TIME              3600L       /* 3600 seconds, or 60 minutes */
#define ONE_SECOND              1000L       /* 1 second */
#define ONE_MINUTE             60000L       /* 60 seconds, or 1 minute */

/* variables for real environment */
BOOL    bNetddeClosed           =  FALSE;
BOOL    bNDDEPaused             =  FALSE;
DWORD   dflt_timeoutRcvConnCmd  =  ONE_MINUTE;      /* 60 seconds */
DWORD   dflt_timeoutRcvConnRsp  =  ONE_MINUTE;      /* 60 seconds */
DWORD   dflt_timeoutMemoryPause =  5*ONE_SECOND;    /*  5 seconds */
DWORD   dflt_timeoutSendRsp     =  10*ONE_SECOND;   /* 10 seconds */
DWORD   dflt_timeoutKeepAlive   =  10*ONE_SECOND;   /* 10 seconds */
DWORD   dflt_timeoutXmtStuck    =  2*ONE_MINUTE;    /*120 seconds */

WORD    dflt_wMaxNoResponse     = 3;
WORD    dflt_wMaxXmtErr         = 3;
WORD    dflt_wMaxMemErr         = 3;
HDESK   ghdesk = NULL;

/*  a place to save NetDDE's own identity   */

BOOL                    bSavedDacl;
PSECURITY_DESCRIPTOR    psdNetdde;

typedef struct {
    BOOL                bOk;
    NIPTRS              niPtrs;
    BOOL                bMapping;
    BOOL                bParamsOK;
    HANDLE              hLibrary;
} NI;
typedef NI *PNI;

NI      niInf[ MAX_NETINTFS ];
int     nCP=0;      /* number of net i/f param menu items in menu */
int     nDI=0;      /* number of net i/f debug dump items in menu */
int     nNi=0;      /* number of table entries consumed */
int     nNiOk=0;    /* number of alive interface */

PTHREADDATA ptdHead;

DWORD tlsThreadData = 0xffffffff;

CRITICAL_SECTION csNetDde;

VOID NetDDEThread(PTHREADDATA ptd);
VOID PipeThread(PVOID pvoid);

static SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

// .ini strings
char    szNetddeIni[]           =       "netdde.ini";
char    szGeneral[]             =       "General";
char    szInterfaceFmt[]        =       "Interface%d";
char    szInterfaces[]          =       "Interfaces";

// error strings
#ifdef  HASUI
char    szDlgBoxMemErr[]        =       "Not enough memory for dialog box";
#endif

// global strings
char    szLastConnect[ MAX_NODE_NAME+1 ];
char    ourNodeName[ MAX_NODE_NAME+1 ];
char    szInitiatingNode[ MAX_NODE_NAME+1 ];
char    szInitiatingApp[ 256 ];
char    szServerName[ 132 ];
LPSTR   lpszServer;
BOOL    bInitiating                 = FALSE;    // Protect with CritSec
BOOL    bDefaultAllowConversation   = TRUE;
BOOL    bDefaultStartApp            = DEFAULT_START_APP;
BOOL    bDefaultAdvisePermitted     = TRUE;
BOOL    bDefaultRequestPermitted    = TRUE;
BOOL    bDefaultPokePermitted       = TRUE;
BOOL    bDefaultExecutePermitted    = TRUE;
BOOL    bDefaultRouteDisconnect     = TRUE;
BOOL    bLogPermissionViolations    = TRUE;
BOOL    bLogExecFailures            = TRUE;
BOOL    bLogRetries                 = TRUE;
int     nDefaultRouteDisconnectTime = 30;
BOOL    bDefaultConnDisconnect      = TRUE;
int     nDefaultConnDisconnectTime  = 30;

char    szDefaultRoute[ MAX_ROUTE_INFO+1 ];
BOOL    bIconic;

#if DBG
BOOL    bDebugMenu      = FALSE;
BOOL    bDebugInfo      = FALSE;
BOOL    bDebugErrors    = FALSE;
BOOL    bDebugDdePkts   = FALSE;
BOOL    bDumpTokens     = FALSE;
extern  BOOL    bDebugDDE;
extern  char    szDebugFileName[];
#endif

BOOL    bShowStatistics     = TRUE;
DWORD   dwSecurityType      = DEFAULT_SECURITY_TYPE;
DWORD   dwSecKeyAgeLimit    = AGING_TIME;


/*
        Event Logger Control Variables
*/
BOOL    bNDDELogInfo            = FALSE;
BOOL    bNDDELogWarnings        = FALSE;
BOOL    bNDDELogErrors          = TRUE;

#ifdef HASUI

BOOL    bShowPktz       = TRUE;
BOOL    bShowRouter     = TRUE;
BOOL    bShowRouterThru = FALSE;
BOOL    bShowDder       = FALSE;
BOOL    bShowIpc        = TRUE;
char    szHelpFileName[ 128 ];

#endif

WORD    cfPrinterPicture;

char    szAgentAlive[] =    "NetddeAgentAlive";
UINT    wMsgNddeAgntAlive;
char    szAgentWakeUp[] =    "NetddeAgentWakeUp";
UINT    wMsgNddeAgntWakeUp;
char    szAgentExecRtn[] =  "NetddeAgentExecRtn";
UINT    wMsgNddeAgntExecRtn;
char    szAgentDying[] =    "NetddeAgentDying";
UINT    wMsgNddeAgntDying;

UINT    wMsgInitiateAckBack;
UINT    wMsgNetddeAlive;
UINT    wMsgGetOurNodeName;
UINT    wMsgGetClientInfo;
#ifdef  ENUM
UINT    wMsgSessionEnum;
UINT    wMsgConnectionEnum;
#endif
UINT    wMsgSessionClose;
UINT    wMsgPasswordDlgDone;

UINT    wMsgIpcInit;
UINT    wMsgIpcXmit;
UINT    wMsgDoTerminate;

DWORD   dwSerialNumber;
WORD    wClipFmtInTouchDDE;
HANDLE  hInst;
HANDLE  hThreadPipe = NULL;

char    szAppName[] = NETDDE_TITLE;

#ifdef HASUI
LOGFONT     NetDDELogFont;
HFONT       hFont = 0;
COLORREF    dwNetDDEFontColor;
HPEN        hPen = 0;
#endif

extern  HWND    hWndDDEHead;
extern  HANDLE  hNDDEServDoneEvent;
extern  VOID    NDDEServCtrlHandler (DWORD dwCtrlCode);

VOID    FAR PASCAL PasswordAgentDying( void );
BOOL    FAR PASCAL ProcessPasswordDlgMessages( LPMSG lpMsg );
VOID    FAR PASCAL CenterDlg(HWND);
HWND    FAR PASCAL GetHWndLogger( void );
VOID    FAR PASCAL ServiceInitiates( void );
VOID    SelectOurFont(HWND);
VOID    NetIntfDlg( HWND hWndNetdde );
VOID    CloseDlg( HWND hWndNetdde );
VOID    RouteSelectName( void );
BOOL    FAR PASCAL AddNetIntf( HWND hWnd, LPSTR lpszDllName );
BOOL    FAR PASCAL DeleteNetIntf( HWND hWnd, LPSTR lpszIntfName );
VOID    FAR PASCAL MakeHelpPathName( char *szFileName, int nMax );
BOOL    FAR PASCAL DeleteNetIntfFromNetDdeIni( int nToDelete );
FARPROC FAR PASCAL XGetProcAddress( LPSTR lpszDllName, HANDLE hLibrary,
                        LPSTR lpszFuncName );
BOOL    FAR PASCAL GetNiPtrs( HANDLE FAR *lphLibrary, LPSTR lpszDllName,
                        LPNIPTRS lpNiPtrs );
BOOL    FAR PASCAL NetIntfConfigured( LPSTR lpszName );
VOID    FAR PASCAL ReverseMenuBoolean( HWND hWndNetdde, int idMenu, BOOL *pbItem,
                        PSTR pszIniName );
VOID    FAR PASCAL ReverseSysMenuBoolean( HWND hWndNetdde, int idMenu, BOOL *pbItem,
                        PSTR pszIniName );
BOOL    FAR PASCAL UdInit( HANDLE, HANDLE, LPSTR, int );
int     IpcDraw( HDC hDC, int x, int vertPos, int lineHeight );
int     DderDraw( HDC hDC, int x, int vertPos, int lineHeight );
int     PktzDraw( HDC hDC, int x, int vertPos, int lineHeight );
BOOL    FAR PASCAL NameInList( HWND hDlg, int cid, LPSTR lpszName );
VOID    FAR PASCAL DoPaint( HWND hWnd );
VOID    FAR PASCAL NetddeEnumConnection( HWND hDlg, LPSTR lpszName );
VOID    FAR PASCAL NetddeEnumRoute( HWND hDlg, LPSTR lpszName );
BOOL    PktzAnyActiveForNetIntf( LPSTR lpszIntfName );
int     RouterDraw( BOOL bThru, HDC hDC, int x, int vertPos, int lineHeight );
HPKTZ   PktzSelect( void );
VOID    DdeIntfTest( int nTestNo );
BOOL    FAR PASCAL CheckNetIntfCfg( LPSTR lpszName, BOOL bConfigured );
BOOL    FAR PASCAL NetIntfDlgProc( HWND, unsigned, UINT, LONG );
BOOL    FAR PASCAL CloseDlgProc( HWND, unsigned, UINT, LONG );
BOOL    FAR PASCAL PreferencesDlgProc( HWND, unsigned, UINT, LONG );
BOOL    FAR PASCAL RoutesDlgProc( HWND, unsigned, UINT, LONG );
BOOL    FAR PASCAL RouterCloseByCookie( LPSTR lpszName, DWORD_PTR dwCookie );
#ifdef  ENUM
VOID    FAR PASCAL RouterEnumConnectionsForApi( LPCONNENUM_CMR lpConnEnum );
int     FAR PASCAL RouterCount( void );
VOID    FAR PASCAL RouterFillInEnum( LPSTR lpBuffer, DWORD cBufSize );
#endif
BOOL    CtrlHandler(DWORD);

#if DBG
VOID    FAR PASCAL DebugDdeIntfState( void );
VOID    FAR PASCAL DebugDderState( void );
VOID    FAR PASCAL DebugRouterState( void );
VOID    FAR PASCAL DebugPktzState( void );
#endif

extern HANDLE hNDDEServStartedEvent;

BOOL    FAR PASCAL InitializeInterface( HWND hWnd, PNI pNi, LPSTR lpszDllName, int nNi );

/*
    Global Start-Up Arguments .. saved by service launcher
*/
HANDLE  hInstance;          /* current instance             */
LPSTR   lpCmdLine;          /* command line                 */
int     nCmdShow;           /* show-window type (open/icon) */

//****************************************************************
//    NetDDE WinMain()
//****************************************************************
VOID   __stdcall
NddeMain(DWORD nThreadInput)
{
    DWORD ThreadId;
    PTHREADDATA ptd;

    TRACEINIT((szT, "NddeMain: Entering."));

    if (bNetddeClosed == FALSE) {


        /*
         * Do this section ONLY on first time startup of NetDDE.
         */


        if( !InitApplication( hInstance ) ) {
            TRACEINIT((szT, "NddeMain: Error1 Leaving."));
            goto Cleanup;
        }

        /* Perform initializations that apply to a specific instance */

        if( !InitInstance( hInstance, nCmdShow, lpCmdLine ) ) {
            TRACEINIT((szT, "NddeMain: Error2 Leaving."));
            goto Cleanup;
        }

        /*
         * make this process shutdown near last.
         */
        SetProcessShutdownParameters(0xf0, 0);

        /*
         * set us up so we can be notified of logoffs and shutdowns.
         */
        TRACEINIT((szT, "Setting console control handler."));
        if (!SetConsoleCtrlHandler(CtrlHandler, TRUE)) {
            TRACEINIT((szT, "NddeMain: Error4 Leaving."));
            goto Cleanup;
        }
    } else {


        /*
         * Do this section ONLY on subsequent non-first-time startups.
         */


        bNetddeClosed = FALSE;
    }


    /*
     * This gets done on ALL startups.
     */


    __try
    {
        InitializeCriticalSection(&csNetDde);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TRACEINIT((szT, "NddeMain: Error 6 InitializeCriticalSection excepted"));
        goto Cleanup;
    }

    tlsThreadData = TlsAlloc();
    if (tlsThreadData == 0xffffffff) {
        TRACEINIT((szT, "NddeMain: Error3 Leaving"));
        goto Cleanup;
    }

    /*
     * Create the pipe thread suspended.  This will ensure that the
     * net interfaces will be initialized with the main window.
     */
    ghdesk = GetThreadDesktop(GetCurrentThreadId());
    TRACEINIT((szT, "Creating a pipe thread."));

    /*
     * Check to see if the pipe thread is not already running
     */
    hThreadPipe = CreateThread(NULL, 0,
            (LPTHREAD_START_ROUTINE)PipeThread,
            NULL,
            CREATE_SUSPENDED, &ThreadId);
    if (hThreadPipe == NULL) {
        TRACEINIT((szT, "NddeMain: Error5 Leaving."));
        goto Cleanup;
    }
    TRACEINIT((szT, "Pipe thread created."));

    ptd = LocalAlloc(LPTR, sizeof(THREADDATA));
    if (ptd == NULL) {
        MEMERROR();
    } else {
        ptd->dwThreadId = GetCurrentThreadId();
        NetDDEThread(ptd);
    }

Cleanup:
    if (hNDDEServStartedEvent) {
        SetEvent(hNDDEServStartedEvent);   // let root thread run.
    }

    TRACEINIT((szT, "NddeMain: Leaving"));
}


/*
 * Spawns a NetDDE listening thread and window on the given
 * window station and desktop.  Returns the hwndDDE created
 * if any.  If a NetDDE window already exists on the given
 * window station and desktop, that window is returned.
 */
HWND SpawnNetDDEThread(
LPWSTR szWinSta,
LPWSTR szDesktop,
HANDLE hPipe)
{
    HWND hwndDDE = NULL;
    HANDLE hThread;
    PTHREADDATA ptd;
    HWINSTA hwinstaSave;
    HDESK hdeskSave;

    TRACEINIT((szT,
            "SpawnNetDDEThread: winsta=%ws, desktop=%ws.",
            szWinSta, szDesktop));

    // if (!ImpersonateNamedPipeClient(hPipe)) {
    //    TRACEINIT((szT, "SpawnNetDDEThread: Impersonate failed."));
    //    return(0);
    // }
    ptd = LocalAlloc(LPTR, sizeof(THREADDATA));
    if (ptd == NULL) {
        MEMERROR();
        return(NULL);
    }

    /*
     * Attempt to open the windowstation
     */
    ptd->hwinsta = OpenWindowStationW(szWinSta, FALSE,
            WINSTA_READATTRIBUTES | WINSTA_ACCESSCLIPBOARD |
            WINSTA_ACCESSGLOBALATOMS | STANDARD_RIGHTS_REQUIRED);
    if (ptd->hwinsta == NULL) {
        // RevertToSelf();
        TRACEINIT((szT, "SpawnNetDDEThread: OpenWindowStation failed."));
        return(NULL);
    }

    /*
     * Switch windowstations.
     */
    hwinstaSave = GetProcessWindowStation();
    SetProcessWindowStation(ptd->hwinsta);

    /*
     * Attempt to open the desktop
     */
    ptd->hdesk = OpenDesktopW(szDesktop, 0, FALSE,
            DESKTOP_READOBJECTS | DESKTOP_CREATEWINDOW |
            DESKTOP_CREATEMENU | DESKTOP_WRITEOBJECTS |
            STANDARD_RIGHTS_REQUIRED);
    if (ptd->hdesk == NULL) {
        TRACEINIT((szT, "SpawnNetDDEThread: OpenDesktop failed."));
        SetProcessWindowStation(hwinstaSave);
        // RevertToSelf();
        CloseWindowStation(ptd->hwinsta);
        return(NULL);
    }

    /*
     * Make sure we only create one thread per desktop.
     */
    hdeskSave = GetThreadDesktop(GetCurrentThreadId());
    SetThreadDesktop(ptd->hdesk);

    hwndDDE = FindWindow(NETDDE_CLASS, NETDDE_TITLE);

    SetThreadDesktop(hdeskSave);
    SetProcessWindowStation(hwinstaSave);
    // RevertToSelf();

    if (hwndDDE != NULL) {
        TRACEINIT((szT, "SpawnNetDDEThread: hwndDDE %x already exists.", hwndDDE));
        return(hwndDDE);
    }

    /*
     * Create a synchronization event and create
     * the dde thread.
     */
    ptd->heventReady = CreateEvent(NULL, FALSE, FALSE, NULL);
    hThread = CreateThread(NULL, 0,
            (LPTHREAD_START_ROUTINE)NetDDEThread,
            ptd,
            0, &ptd->dwThreadId);
    if (hThread == NULL) {
        CloseWindowStation(ptd->hwinsta);
        CloseDesktop(ptd->hdesk);
        CloseHandle(ptd->heventReady);
        LocalFree(ptd);
        return(NULL);
    }

    CloseHandle(hThread);

    WaitForSingleObject(ptd->heventReady, INFINITE);
    CloseHandle(ptd->heventReady);
    hwndDDE = ptd->hwndDDE;

    TRACEINIT((szT, "SpawnNetDDEThread: hwndDDE=%x.", hwndDDE));
    return(hwndDDE);
}



VOID PipeThread(
    PVOID pvoid)
{
    SECURITY_ATTRIBUTES sa;
    HANDLE hPipe = NULL;
    DWORD cbRead;
    NETDDE_PIPE_MESSAGE nameinfo;
    PSID psid;
    PACL pdacl;
    DWORD dwResult;
    OVERLAPPED  overlapped;
    HANDLE heventArray[2];


    /* Create named pipe to communicate with USER */

    TRACEINIT((szT, "PipeThread: Starting."));
    /*
     * Create the manual reset event for the OVERLAPPED structure.
     */
    overlapped.Internal =
    overlapped.InternalHigh =
    overlapped.Offset =
    overlapped.OffsetHigh = 0;
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (overlapped.hEvent == NULL) {
        TRACEINIT((szT, "PipeThread: Error3 Leaving."));
        goto Cleanup;
    }

    /*
     * Initialize the array of events on which to wait.
     */
    heventArray[0] = hNDDEServDoneEvent;
    heventArray[1] = overlapped.hEvent;

    /*
     * Setup the pipe's security attributes
     */
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = FALSE;

    psid = LocalAlloc(LPTR, GetSidLengthRequired( 1 ) );
    if (psid == NULL) {
        MEMERROR();
        goto Cleanup;
    }
    InitializeSid( psid, &WorldSidAuthority, 1 );
    *(GetSidSubAuthority( psid, 0 )) = SECURITY_WORLD_RID;
    sa.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,
            SECURITY_DESCRIPTOR_MIN_LENGTH +
            (ULONG)sizeof(ACL) +
            (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid( psid ));
    if (sa.lpSecurityDescriptor == NULL) {
        MEMERROR();
        LocalFree(psid);
        TRACEINIT((szT, "PipeThread: Error Leaving."));
        goto Cleanup;
    }
    InitializeSecurityDescriptor(sa.lpSecurityDescriptor,
            SECURITY_DESCRIPTOR_REVISION);
    pdacl = (PACL)((PCHAR)sa.lpSecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);
    InitializeAcl(pdacl, (ULONG)sizeof(ACL) +
            (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid( psid ), ACL_REVISION2);
    AddAccessAllowedAce(pdacl, ACL_REVISION2,
        GENERIC_READ | GENERIC_WRITE, psid);
    SetSecurityDescriptorDacl(sa.lpSecurityDescriptor, TRUE, pdacl, FALSE);

    /*
     * Create the pipe.
     */
    hPipe = CreateNamedPipeW(NETDDE_PIPE,
            PIPE_ACCESS_DUPLEX | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
            1, 1, 1, 1000, &sa);
    LocalFree(psid);
    LocalFree(sa.lpSecurityDescriptor);
    if (hPipe == INVALID_HANDLE_VALUE) {
        TRACEINIT((szT, "PipeThread: Error2 Leaving."));
        goto Cleanup;
    }

    /*
     * always create a NetDDE thread/window on the default desktop of
     * WINSTA0.
     */
    SpawnNetDDEThread(L"WinSta0", L"Default", hPipe);

    /*
     * wait for connection requests from USER for any other spawns.
     */
    while (TRUE) {
        /*
         * Wait for somebody to connect to our pipe.
         */
        ConnectNamedPipe(hPipe, &overlapped);

        switch (GetLastError()) {
        case ERROR_PIPE_CONNECTED:
            /*
             * This error just means that a pipe connected before we
             * made our call to ConnectNamedPipe.  All we need to do
             * is set our overlapped event so we know that a client
             * is already connected.
             */
            SetEvent(overlapped.hEvent);
            TRACEINIT((szT, "PipeThread: ConnectNamePipe = ERROR_PIPE_CONNECTED"));
            break;

        case ERROR_IO_PENDING:
            /*
             * Nothing to do yet, so fall into out WaitForMultipleObjects()
             * code below.
             */
            TRACEINIT((szT, "PipeThread: ConnectNamePipe = ERROR_IO_PENDING"));
            break;

        default:
            /*
             * A real error ocurred!  Write this error to the Event Log and
             * shut down the NDDE service.
             */
            TRACEINIT((szT, "PipeThread: ConnectNamePipe = error %d", GetLastError()));
            NDDEServCtrlHandler( SERVICE_CONTROL_STOP );
            goto Cleanup;
        }

        /*
         * Wait for NDDE service to stop or a connect on the DDE pipe.  We
         * put the service stop handle first to give a STOP priority over
         * a connect.
         */
        TRACEINIT((szT, "PipeThread: Waiting for multiple objects."));
        dwResult = WaitForMultipleObjects(2, heventArray, FALSE, INFINITE);
        switch (dwResult) {
        case WAIT_OBJECT_0:
            TRACEINIT((szT, "PipeThread: hNDDEServDoneEvent"));
            goto Cleanup;

        case WAIT_OBJECT_0 + 1:
            /*
             * A client has connected, establish a DDE connection.
             */
            TRACEINIT((szT, "PipeThread: client connect"));
            while (ReadFile(hPipe, &nameinfo, sizeof(nameinfo), &cbRead, NULL)) {
                HWND hwndDDE;

                hwndDDE = SpawnNetDDEThread(nameinfo.awchNames,
                        &nameinfo.awchNames[nameinfo.dwOffsetDesktop],
                        hPipe);
                TRACEINIT((szT, "PipeThread: client gets hwnd=0x%X", hwndDDE));
                WriteFile(hPipe, &hwndDDE, sizeof(HWND), &cbRead, NULL);
            }
            TRACEINIT((szT, "PipeThread: DisconnectNamedPipe"));
            DisconnectNamedPipe(hPipe);
            break;

        default:
            /*
             * An error ocurred in WaitForMultiple objects.  We should log
             * the error and stop the NDDE service.
             */
            TRACEINIT((szT, "PipeThread: WFMO error = %d, %d", dwResult, GetLastError()));
            NDDEServCtrlHandler( SERVICE_CONTROL_STOP );
            goto Cleanup;
        }
    }

Cleanup:
    TRACEINIT((szT, "PipeThread: Cleanup overlapped.hEvent"));
    if (overlapped.hEvent) {
        CloseHandle(overlapped.hEvent);
    }

    TRACEINIT((szT, "PipeThread: clode hPipe"));
    if (hPipe) {
        CloseHandle(hPipe);
    }

    if (hNDDEServStartedEvent) {
        SetEvent(hNDDEServStartedEvent);   // let root thread run.
    }

    TRACEINIT((szT, "PipeThread: Leaving."));
}



BOOL
FAR PASCAL
InitApplication( HANDLE hInstance ) {   /* current instance             */

    WNDCLASS  wc;

#if DBG && defined(HASUI)
    bDebugMenu = MyGetPrivateProfileInt( szGeneral, "DebugMenu", FALSE,
        szNetddeIni );
#endif

    wc.style = CS_HREDRAW | CS_VREDRAW; /* Class style(s)                 */
    wc.lpfnWndProc = MainWndProc;       /* Function to retrieve msgs for  */
                                        /* windows of this class.         */
    wc.cbClsExtra = 0;                  /* No per-class extra data.       */
    wc.cbWndExtra = 0;                  /* No per-window extra data.      */
    wc.hInstance = hInstance;           /* Application that owns the class*/
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
#ifdef HASUI
    wc.hIcon = LoadIcon( hInstance, szAppName );
    wc.lpszMenuName =  szAppName;      /* Name of menu in .RC file.      */
#else
    wc.hIcon = 0;
    wc.lpszMenuName =  NULL;
#endif // HASUI
    wc.lpszClassName = "NetDDEMainWdw";   /* Name used to CreateWindow.     */

    return( RegisterClass( &wc ) );

}


/*
    Refresh NetDDE Configuration Variables
*/
void
RefreshNDDECfg(void)
{
    char    szDefaultLogFile[256] = "";

    /*
     * Load default security info
     */
    bDefaultAllowConversation = MyGetPrivateProfileInt( szGeneral,
        "InitAllow", TRUE, szNetddeIni );
    bDefaultStartApp = MyGetPrivateProfileInt( szGeneral,
        "StartApp", DEFAULT_START_APP, szNetddeIni );
    bDefaultAdvisePermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultAdvisePermitted", TRUE, szNetddeIni );
    bDefaultRequestPermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultRequestPermitted", TRUE, szNetddeIni );
    bDefaultPokePermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultPokePermitted", TRUE, szNetddeIni );
    bDefaultExecutePermitted = MyGetPrivateProfileInt( szGeneral,
        "DefaultExecutePermitted", TRUE, szNetddeIni );
    dwSecurityType = (DWORD)MyGetPrivateProfileInt( szGeneral,
        "SecurityType", DEFAULT_SECURITY_TYPE, szNetddeIni );

    /*
     * Detgermine what we're allowed to log in the event logger
     */
    bNDDELogInfo = MyGetPrivateProfileInt( szGeneral,
        "NDDELogInfo", FALSE, szNetddeIni );
    bNDDELogWarnings = MyGetPrivateProfileInt( szGeneral,
        "NDDELogWarnings", FALSE, szNetddeIni );
    bNDDELogErrors = MyGetPrivateProfileInt( szGeneral,
        "NDDELogErrors", TRUE, szNetddeIni );

    /*
     * Determine what we are going to dump to private log
     */
#if DBG
    MyGetPrivateProfileString( szGeneral, "DefaultLogFile", "netdde.log",
        szDefaultLogFile, sizeof(szDefaultLogFile), szNetddeIni );
    if (lstrlen(szDefaultLogFile) > 0) {
        lstrcpy(szDebugFileName, szDefaultLogFile);
    }
    bDebugInfo = MyGetPrivateProfileInt( szGeneral,
        "DebugInfo", FALSE, szNetddeIni );
    bDebugErrors = MyGetPrivateProfileInt( szGeneral,
        "DebugErrors", FALSE, szNetddeIni );
    bDebugDdePkts = MyGetPrivateProfileInt( szGeneral,
        "DebugDdePkts", FALSE, szNetddeIni );
    bDumpTokens = MyGetPrivateProfileInt( szGeneral,
        "DumpTokens", FALSE, szNetddeIni );
    bDebugDDE = MyGetPrivateProfileInt( szGeneral,
        "DebugDDEMessages", FALSE, szNetddeIni );
#endif

    bLogPermissionViolations = MyGetPrivateProfileInt( szGeneral,
        "LogPermissionViolations", TRUE, szNetddeIni );
    bLogExecFailures = MyGetPrivateProfileInt( szGeneral,
        "LogExecFailures", TRUE, szNetddeIni );
    bLogRetries = MyGetPrivateProfileInt( szGeneral,
        "LogRetries", TRUE, szNetddeIni );

    bDefaultRouteDisconnect = MyGetPrivateProfileInt( szGeneral,
        "DefaultRouteDisconnect", TRUE, szNetddeIni );
    MyGetPrivateProfileString( szGeneral, "DefaultRoute", "",
        szDefaultRoute, sizeof(szDefaultRoute), szNetddeIni );
    nDefaultRouteDisconnectTime = MyGetPrivateProfileInt( szGeneral,
        "DefaultRouteDisconnectTime", 30, szNetddeIni );
    bDefaultConnDisconnect = MyGetPrivateProfileInt( szGeneral,
        "DefaultConnectionDisconnect", TRUE, szNetddeIni );
    nDefaultConnDisconnectTime = MyGetPrivateProfileInt( szGeneral,
        "DefaultConnectionDisconnectTime", 30, szNetddeIni );
    dwSecKeyAgeLimit = GetPrivateProfileLong( szGeneral,
        "SecKeyAgeLimit", AGING_TIME, szNetddeIni);

#ifdef  HASUI
    bShowDder = MyGetPrivateProfileInt( szGeneral,
        "ShowDder", FALSE, szNetddeIni );
    bShowStatistics = MyGetPrivateProfileInt( szGeneral,
        "ShowStatistics", FALSE, szNetddeIni );
    bShowPktz = MyGetPrivateProfileInt( szGeneral,
        "ShowPktz", TRUE, szNetddeIni );
    bShowRouter = MyGetPrivateProfileInt( szGeneral,
        "ShowRouter", TRUE, szNetddeIni );
    bShowRouterThru = MyGetPrivateProfileInt( szGeneral,
        "ShowRouterThrough", FALSE, szNetddeIni );
    bShowIpc = MyGetPrivateProfileInt( szGeneral,
        "ShowIpc", TRUE, szNetddeIni );
    NetDDELogFont.lfHeight = MyGetPrivateProfileInt( szGeneral,
        "FontHeight", 0, szNetddeIni);
    NetDDELogFont.lfWidth = MyGetPrivateProfileInt( szGeneral,
        "FontWidth", 0, szNetddeIni);
    NetDDELogFont.lfWeight = MyGetPrivateProfileInt( szGeneral,
        "FontWeight", 0, szNetddeIni);
    NetDDELogFont.lfItalic = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontItalic", 0, szNetddeIni);
    dwNetDDEFontColor = (DWORD) GetPrivateProfileLong( szGeneral,
        "FontColor", RGB(0, 0, 0), szNetddeIni);
    MyGetPrivateProfileString( szGeneral, "FontName", "",
        NetDDELogFont.lfFaceName, LF_FACESIZE, szNetddeIni );
    NetDDELogFont.lfPitchAndFamily = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontPitchAndFamily", FIXED_PITCH | FF_MODERN, szNetddeIni);
    NetDDELogFont.lfEscapement = MyGetPrivateProfileInt( szGeneral,
        "FontEscapement", 0, szNetddeIni);
    NetDDELogFont.lfOrientation = MyGetPrivateProfileInt( szGeneral,
        "FontOrientation", 0, szNetddeIni);
    NetDDELogFont.lfUnderline = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontUnderline", 0, szNetddeIni);
    NetDDELogFont.lfStrikeOut = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontStrikeOut", 0, szNetddeIni);
    NetDDELogFont.lfCharSet = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontCharSet", 0, szNetddeIni);
    NetDDELogFont.lfOutPrecision = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontOutPrecision", 0, szNetddeIni);
    NetDDELogFont.lfClipPrecision = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontClipPrecision", 0, szNetddeIni);
    NetDDELogFont.lfQuality = (BYTE) MyGetPrivateProfileInt( szGeneral,
        "FontQuality", 0, szNetddeIni);
#endif
}


long    FAR PASCAL DDEWddeWndProc( HWND, unsigned, UINT, LONG );



BOOL
FAR PASCAL
InitInstance(
    HANDLE      hInstance,      /* Current instance identifier          */
    int         nCmdShow,       /* Param for first ShowWindow() call.   */
    LPSTR       lpCmdLine )
{

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

#ifdef  ENUM
    wMsgSessionEnum = RegisterWindowMessage( NETDDEMSG_SESSIONENUM );
    wMsgConnectionEnum = RegisterWindowMessage( NETDDEMSG_CONNENUM );
#endif

    wMsgNddeAgntExecRtn = RegisterWindowMessage( szAgentExecRtn );
    wMsgNddeAgntAlive = RegisterWindowMessage( szAgentAlive );
    wMsgNddeAgntWakeUp = RegisterWindowMessage( szAgentWakeUp );
    wMsgNddeAgntDying = RegisterWindowMessage( szAgentDying );
    wMsgInitiateAckBack = RegisterWindowMessage( "NetddeInitiateAck" );
    wMsgNetddeAlive = RegisterWindowMessage( "NetddeAlive" );
    wMsgGetOurNodeName = RegisterWindowMessage( NETDDEMSG_GETNODENAME );
    wMsgGetClientInfo = RegisterWindowMessage( NETDDEMSG_GETCLIENTINFO );
    wMsgSessionClose = RegisterWindowMessage( NETDDEMSG_SESSIONCLOSE );
    wMsgPasswordDlgDone = RegisterWindowMessage( NETDDEMSG_PASSDLGDONE );

    wMsgIpcInit = RegisterWindowMessage( "HandleIpcInit" );
    wMsgIpcXmit = RegisterWindowMessage( "HandleIpcXmit" );
    wMsgDoTerminate = RegisterWindowMessage( "DoTerminate" );

    cfPrinterPicture = (WORD)RegisterClipboardFormat( "Printer_Picture" );

#ifdef HASUI
    /* remember where the help file is */
    MakeHelpPathName( szHelpFileName, sizeof(szHelpFileName) );
#endif // HASUI

    if( !DDEIntfInit() )  {
        return( FALSE );
    }

    wClipFmtInTouchDDE = (WORD)RegisterClipboardFormat( "InTouch Blocked DDE V2" );

    return( TRUE );
}



/*
 * Started by SpawnNetDDEThread for a specific desktop.
 */
VOID NetDDEThread(
    PTHREADDATA ptd)
{
    HWND        hWnd;           /* Main window handle.                  */
    DWORD       cbName = sizeof(ourNodeName);
    PNI         pNi;
    int         i;
#ifdef HASUI
    HMENU       hMenu;
    HMENU       hMenuConfigure;
    HMENU       hMenuDebug;
#endif // HASUI
    MSG         msg;
    extern char nameFromUser[];

    TRACEINIT((szT, "NetDDEThread: Entering."));

    if (ptd->hdesk != NULL) {
        SetThreadDesktop(ptd->hdesk);
    }

    /* Create a main window for this application instance.  */
    hWnd = CreateWindow(
        NETDDE_CLASS,                   /* Window class name            */
        szAppName,                      /* Text for title bar.          */
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,                           /* no parent.                   */
        NULL,                           /* Use the window class menu.   */
        hInstance,                      /* This instance owns window.   */
        NULL                            /* Pointer not needed.          */
    );

    /* If window could not be created, return "failure" */

    if (hWnd == NULL) {
        if (ptd->heventReady != NULL) {
            SetEvent(ptd->heventReady);
        }
        if (hNDDEServStartedEvent) {
            SetEvent(hNDDEServStartedEvent);    // let root thread run.
        }
        TRACEINIT((szT, "NetDDEThread: Error 1 Leaving."));
        return;
    }

    /*
     * We have a window, so put this thread at the head of the list.
     */
    ptd->hwndDDE = hWnd;
    TRACEINIT((szT, "NetDDEThread: Created hwndDDE=%x.", hWnd));
    TlsSetValue(tlsThreadData, ptd);
    EnterCrit();
    ptd->ptdNext = ptdHead;
    ptdHead = ptd;
    LeaveCrit();

#if DBG && defined(HASUI)
    if( bDebugMenu )  {
        hMenuDebug = GetSystemMenu( hWnd, FALSE );
        ChangeMenu(hMenuDebug, 0,
            "View DD&E Routes", IDM_SHOW_DDER,
            MF_APPEND | MF_STRING | MF_MENUBARBREAK );
        ChangeMenu(hMenuDebug, 0,
            "Log &DDE Traffic", IDM_DEBUG_DDE,
            MF_APPEND | MF_STRING );
        ChangeMenu(hMenuDebug, 0,
            "Log &Info", IDM_LOG_INFO,
            MF_APPEND | MF_STRING );
        ChangeMenu(hMenuDebug, 0,
            "Log DDE &Packets", IDM_LOG_DDE_PKTS,
            MF_APPEND | MF_STRING );
        ChangeMenu(hMenuDebug, 0,
            "Dump &NetDDE State", IDM_DEBUG_NETDDE,
            MF_APPEND | MF_STRING );
        CheckMenuItem( hMenuDebug, IDM_LOG_INFO,
            bDebugInfo ? MF_CHECKED : MF_UNCHECKED );
        CheckMenuItem( hMenuDebug, IDM_LOG_DDE_PKTS,
            bDebugDdePkts ? MF_CHECKED : MF_UNCHECKED );
        CheckMenuItem( hMenuDebug, IDM_SHOW_DDER,
            bShowDder ? MF_CHECKED : MF_UNCHECKED );
        CheckMenuItem( hMenuDebug, IDM_DEBUG_DDE,
            bDebugDDE ? MF_CHECKED : MF_UNCHECKED );
    }
#endif


#ifdef HASUI
    ShowWindow(hWnd, SW_SHOWMINNOACTIVE );
#endif

    GetComputerName( ourNodeName, &cbName );

    /* set up lpszServer for NDDEAPI calls */
    lpszServer = szServerName;
    lstrcpy( lpszServer, "\\\\" );
    lstrcat( lpszServer, ourNodeName );

    AnsiUpper( ourNodeName );
    OemToAnsi ( ourNodeName, ourNodeName );

    /*  NetDDE Service on node "%1" started. */

    NDDELogInfo(MSG001, ourNodeName, NULL);

#ifdef HASUI
    wsprintf( tmpBuf, "%s - \"%s\"",
        (LPSTR)szAppName, (LPSTR)ourNodeName );
    SetWindowText( hWnd, tmpBuf );

    hMenu = GetMenu( hWnd );
    hMenuConfigure = GetSubMenu( hMenu, 0 );
#endif // HASUI

#ifdef HASUI
    CheckMenuItem( hMenu, IDM_SHOW_STATISTICS,
        bShowStatistics ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hMenu, IDM_SHOW_PKTZ,
        bShowPktz ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hMenu, IDM_SHOW_ROUTER,
        bShowRouter ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hMenu, IDM_SHOW_ROUTER_THRU,
        bShowRouterThru ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem( hMenu, IDM_SHOW_IPC,
        bShowIpc ? MF_CHECKED : MF_UNCHECKED );

    hFont = CreateFontIndirect(&NetDDELogFont);
    hPen = CreatePen(PS_SOLID, 1, dwNetDDEFontColor);
#endif // HASUI

    /*
     * Initialize the net interfaces if need be.
     */
    if (!nNi) {
        for( i=0; i<MAX_NETINTFS; i++ )  {
            pNi = &niInf[i];
            pNi->bOk = FALSE;
            pNi->hLibrary = 0;
            wsprintf( tmpBuf2, szInterfaceFmt, i+1 );
            MyGetPrivateProfileString( szInterfaces, tmpBuf2,
                "", tmpBuf, sizeof(tmpBuf), szNetddeIni );

            if( tmpBuf[0] == '\0' )  {
                break;      // done looking
            } else {
                InitializeInterface( hWnd, pNi, tmpBuf, nNi );
                nNi++;
            }
        }

        if ( !nNi ) {  /* if no interfaces defined, default to NDDENB32 */
            InitializeInterface ( hWnd, &niInf[0], "NDDENB32", 0 );
            nNi++;
        }

    }


    /*
     * The net interfaces have been associated with the main
     * window, so we can now let the pipe thread run.
     */
    ResumeThread(hThreadPipe);


#ifdef HASUI
    InvalidateRect( hWnd, NULL, TRUE );
    UpdateWindow( hWnd );               /* Sends WM_PAINT message       */

    if( nNiOk == 0 )  {         /* were any interfaces defined ? */
        NetIntfDlg( hWnd );
    }
#endif // HASUI

    /*
     * Send the window handle back to the server and let our
     * creator know that we're ready.
     */
    if (ptd->hdesk != NULL) {
        SetEvent(ptd->heventReady);
    }

    /*
     * Notify starting thread that we are ready to go.
     */
    if (hNDDEServStartedEvent) {
        SetEvent(hNDDEServStartedEvent);
    }

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while( GetMessage( &msg, NULL, 0, 0 ) ) {
        if( !ProcessPasswordDlgMessages( &msg ) )  {

            TranslateMessage( &msg );       /* Translates virtual key codes */
            DispatchMessage( &msg );        /* Dispatches message to window */
        }
    }

    if (ptd->hdesk != NULL) {
        if (IsWindow(ptd->hwndDDE))
            DestroyWindow(ptd->hwndDDE);
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            DispatchMessage( &msg );        /* Dispatches message to window */
        }
        SetThreadDesktop(ghdesk);
        CloseDesktop(ptd->hdesk);
        CloseWindowStation(ptd->hwinsta);
    }
    ptd->hwndDDE = NULL;

    TRACEINIT((szT, "NetDDEThread: Leaveing."));
}



BOOL CtrlHandler(
    DWORD dwEvent)
{
    PTHREADDATA ptd;
    if (dwEvent == CTRL_LOGOFF_EVENT || dwEvent == CTRL_SHUTDOWN_EVENT) {
        for (ptd = ptdHead; ptd != NULL; ptd = ptd->ptdNext) {
            if (ptd->hdesk != NULL || dwEvent == CTRL_SHUTDOWN_EVENT) {
                SendMessage(ptd->hwndDDE, WM_CLOSE, 0, 0);
            }
        }
        return TRUE;
    }
    return FALSE;
}


/*
    HandleNetddeCopyData()

    This handles the WM_COPYDATA message from NetDDE to start an
    application in the user's context
*/
BOOL
HandleNetddeCopyData(
    HWND hWndTo,
    HWND hWndFrom,
    PCOPYDATASTRUCT pCopyDataStruct )
{
    extern UINT    uAgntExecRtn;

    if( pCopyDataStruct->dwData == wMsgNddeAgntExecRtn )  {
        /* sanity checks on the structure coming in */
        if( pCopyDataStruct->cbData != sizeof(uAgntExecRtn) )  {
            /*  Invalid COPYDATA size %1 received. */

            NDDELogError(MSG003, LogString("%d", pCopyDataStruct->cbData), NULL);
            return( FALSE );
        }
        uAgntExecRtn = *((ULONG *)(pCopyDataStruct->lpData));
        return( TRUE );
    } else {
        /*  Invalid COPYDATA command %1 received. */

        NDDELogError(MSG004, LogString("0x%0X", pCopyDataStruct->dwData), NULL);
        return( FALSE );
    }
}

//BOOL
//GetWindowDacl(
//    HWND                    hwnd,
//    PSECURITY_DESCRIPTOR   *ppsd )
//{
//    DWORD                       cbSec   = 0;
//    BOOL                        ok      = FALSE;
//    SECURITY_INFORMATION        si      = DACL_SECURITY_INFORMATION;
//
//    ok = GetUserObjectSecurity( hwnd,
//        &si,
//        (PSECURITY_DESCRIPTOR)NULL,
//        0,
//        &cbSec );
//    if( !ok  && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))  {
//        *ppsd = (PSECURITY_DESCRIPTOR)malloc( cbSec );
//        if( *ppsd )  {
//            ok = GetUserObjectSecurity( hwnd,
//                &si,
//                *ppsd,
//                cbSec,
//                &cbSec );
//            if( !ok )  {
//                DPRINTF(("Unable to get DACL for %0X window: %d", hwnd, GetLastError()));
//                free( *ppsd );
//                *ppsd = (PSECURITY_DESCRIPTOR) NULL;
//            }
//        }
//    } else {
//        DPRINTF(("%d: Unable to probe DACL size for %0X window: %d", ok, hwnd, GetLastError()));
//    }
//    return( ok );
//}
//
//BOOL
//SetWindowDacl( HWND hwnd, PSECURITY_DESCRIPTOR psd )
//{
//    BOOL                        ok = FALSE;
//    SECURITY_INFORMATION        si = DACL_SECURITY_INFORMATION;
//
//    ok = SetUserObjectSecurity( hwnd, &si, psd );
//    if (!ok) {
//        DPRINTF(("Unable to set DACL on %0X window: %d", hwnd, GetLastError()));
//    }
//    return( ok );
//}

/*******************************************************************
 *
 *            MAIN NETDDE WINDOW PROC
 *
 * This window proc handles all NetDDE DDE trafic plus communication
 * with any associated agent window if necessary.  There is one
 * main NetDDE window per desktop and one agent on the logged on
 * desktop.
 *******************************************************************/

LPARAM
FAR PASCAL
MainWndProc(
    HWND        hWnd,              /* window handle                     */
    unsigned    message,           /* type of message                   */
    WPARAM      wParam,            /* additional information            */
    LPARAM      lParam )           /* additional information            */
{
    LPSTR           ptr;
    PNI             pNi;
    CONNID          connId;
    HPKTZ           hPktz;
    DWORD           dwNow;
    LPINFOCLI_CMD   lpInfoCliCmd;
    LPINFOCLI_RSP   lpInfoCliRsp;
    int             i;
    HWND            hDeskTop;
    PTHREADDATA     ptd;
    PTHREADDATA     *pptd;
#ifdef HASUI
    int             result;
#endif
    HWND            hwndDDEChild;

    static DWORD dwLastCheckKeys = 0;
    extern char nameFromUser[];

    if (bNDDEPaused) {
        return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    switch( message ) {
    case WM_CREATE:
        TRACEINIT((szT, "MainWndProc: Created."));
        hDeskTop = GetDesktopWindow();
        if (hDeskTop) {
            if (!UpdateWindow(hDeskTop)) {
                NDDELogError(MSG078, NULL);
                break;
            }
        } else {
            NDDELogError(MSG078, NULL);
            break;
        }
        TRACEINIT((szT, "Post Broadcasting NddeAgentWakeUp call:%x\n", wMsgNddeAgntWakeUp));
        PostMessage( HWND_BROADCAST, wMsgNddeAgntWakeUp, (UINT_PTR) hWnd, 0);
        break;

    case WM_COPYDATA:
        /*
         * This contains the return code from the previous request to the
         * NetDDE Agent application.  The results are placed into the
         * global uAgentExecRtn.
         */
        HandleNetddeCopyData( hWnd, (HWND)wParam, (PCOPYDATASTRUCT) lParam );
        return( TRUE );    // processed the msg */
        break;

#ifdef HASUI
    case WM_KEYDOWN:
        if( wParam == VK_F1 ) {
            /* If F1 without shift, then call up help main index topic */
            WinHelp( hWnd, szHelpFileName, HELP_INDEX, 0L );
        } else {
            return( DefWindowProc( hWnd, message, wParam, lParam ) );
        }
        break;
#endif // HASUI

    case WM_CLOSE:
#if 1
        /*
         * For some reason, this is forcing the children to die before
         * this window.
         */
        hwndDDEChild = GetWindow(hWnd, GW_CHILD);
        if (hwndDDEChild != NULL) {
            while (hwndDDEChild != NULL) {
                DPRINTF(("Forcing close of window %x\n", hwndDDEChild));
                DestroyWindow(hwndDDEChild);
                hwndDDEChild = GetWindow(hWnd, GW_CHILD);
            }
            NDDELogWarning(MSG015, NULL);
        }
        return (DefWindowProc(hWnd, message, wParam, lParam));
#else
        EnterCrit();
        if( hWndDDEHead )  {
            LeaveCrit();
            /*  Cannot close while DDE conversations are in progress.
                WM_CLOSE ignored. */
            NDDELogWarning(MSG015, NULL);
        } else {
            LeaveCrit();
#ifdef  HASUI
            if( MessageBox( NULL, "Close NetDDE?", GetAppName(),
                MB_TASKMODAL | MB_YESNO | MB_ICONQUESTION ) == IDYES )
#endif  // HASUI
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        break;
#endif

#ifdef HASUI
    case WM_LBUTTONDOWN:
        InvalidateRect( hWnd, NULL, TRUE );
        return (DefWindowProc(hWnd, message, wParam, lParam));
        break;

    case WM_SIZE:
        if( wParam == SIZEICONIC )  {
            bIconic = TRUE;
        } else if( bIconic )  {
            bIconic = FALSE;
            DoPaint( hWnd );
        }
        break;

    case WM_PAINT:
        if( bIconic )  {
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        DoPaint( hWnd );
        break;
#endif // HASUI

    case WM_DDE_INITIATE:
        /*
         * This is where we catch flying initiates to start conversations.
         */

        TRACEINIT((szT, "MainWndProc: WM_DDE_INITIATE..."));
        EnterCrit();
        ptd = TlsGetValue(tlsThreadData);
        if( !ptd->bInitiating )  {
#if DBG
            if( bDebugDDE )  {
                DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
            }
#endif  // DBG
            // ignore if we don't have any valid network interfaces
            if( nNiOk > 0 )  {
                ptd->bInitiating = TRUE;
                DDEHandleInitiate( hWnd, (HWND) wParam, /* client       */
                            (ATOM) LOWORD(lParam),      /* app          */
                            (ATOM) HIWORD(lParam) );    /* topic        */
                ptd->bInitiating = FALSE;
                /*
                 * Kick ourselves to process queues.
                 */
                PostMessage( hWnd, WM_TIMER, 0, 0L );
            } else {
                TRACEINIT((szT, "MainWndProc: nNiOk == 0."));
                if( LOWORD(lParam) )  {
                    GlobalGetAtomName( (ATOM) LOWORD(lParam),
                        tmpBuf, sizeof(tmpBuf) );
                    if (_fstrnicmp(&tmpBuf[2], ourNodeName, lstrlen(ourNodeName)) == 0) {
                        ptd->bInitiating = TRUE;
                        DDEHandleInitiate( hWnd, (HWND) wParam, /* client       */
                                    (ATOM) LOWORD(lParam),      /* app          */
                                    (ATOM) HIWORD(lParam) );    /* topic        */
                        ptd->bInitiating = FALSE;
                        /*
                         * Kick ourselves to process queues.
                         */
                        PostMessage( hWnd, WM_TIMER, 0, 0L );
                    }
                }
            }
        } else {
            TRACEINIT((szT, "MainWndProc: ptd->bInitiating is set, INIT skipped."));
        }
        LeaveCrit();
        break;

    case WM_TIMER:
        /*
         * This timer goes off to service various goodies:
         *      Security Keys that are ageing.
         *      Initiates in the hWndDDEHead list.
         *      Incomming packets.
         *      Timers. (ie we run all our timers off of one WM_TIMER tick)
         *      NetBios connections.
         */
        if (ptdHead != NULL && ptdHead->hwndDDE != hWnd) {
            PostMessage(ptdHead->hwndDDE, WM_TIMER, 0, 0);
            break;
        }
        /* do not process timers if we are closed */
        if( !bNetddeClosed )  {
            dwNow = GetTickCount();
            /* check for aged keys every minute or so */
            if( (dwNow < dwLastCheckKeys)
                || ((dwNow - dwLastCheckKeys) > ONE_MINUTE))  {
                DdeSecKeyAge();
                dwLastCheckKeys = dwNow;
            }

            // service all initiates
            ServiceInitiates();

            // service all packetizers
            PktzSlice();

            // service all timers
            TimerSlice();

            // service all network interfaces
            for( i=0; i<nNi; i++ )  {
                pNi = &niInf[i];
                if( pNi->bOk )  {
                    /* give the other side a chance */
                    (*pNi->niPtrs.TimeSlice)();

                    connId = (*pNi->niPtrs.GetNewConnection)();
                    if( connId )  {
                        hPktz = PktzNew( &pNi->niPtrs, FALSE /* server */,
                            "", "", connId, FALSE, 0 );
                        if( !hPktz )  {
                            /*  Failed creating new server paketizer for connection id %d */
                            NDDELogError(MSG005, LogString("0x%0X", connId), NULL);
                        }
                    }
                }
            }
            // service all packetizers
            /*
             * Why is this called twice??? (sanfords)
             */
            PktzSlice();
        }
        break;

#ifdef HASUI
    case WM_SYSCOMMAND:
        switch( wParam & 0xFFF0 ) {
        case IDM_SHOW_DDER:
            ReverseSysMenuBoolean( hWnd, wParam, &bShowDder, "ShowDder" );
            break;
#if DBG
        case IDM_DEBUG_DDE:
            ReverseSysMenuBoolean( hWnd, wParam, &bDebugDDE, "DebugDDEMessages" );
            break;
        case IDM_DEBUG_NETDDE:
            DebugDdeIntfState();
            DebugDderState();
            DebugRouterState();
            DebugPktzState();
            DPRINTF(( "" ));
            break;
        case IDM_LOG_INFO:
            ReverseSysMenuBoolean( hWnd, wParam, &bDebugInfo, "DebugInfo" );
            break;
        case IDM_LOG_DDE_PKTS:
            ReverseSysMenuBoolean( hWnd, wParam, &bDebugDdePkts, "DebugDdePkts" );
            break;
#endif  // DBG
        default:
            if ( (wParam >= IDM_DEBUG_INTF) &&
                (wParam <= IDM_DEBUG_INTF_MAX) )  {
                i = (wParam - IDM_DEBUG_INTF) >> 4;
                pNi = &niInf[ i ];
                if ( pNi->bOk ) {
                    (*(pNi->niPtrs.LogDebugInfo))( (CONNID)NULL,
                                    (DWORD) 0xFFFFFFFFL );
                } else {
                    /*  %1: (wParam = %2). Undefined Network Interface Selected */

                    NDDELogError(MSG006, "WM_SYSCOMAND",
                        LogString("%d", wParam), NULL);
                }

            } else {
                return (DefWindowProc(hWnd, message, wParam, lParam));
            }
        }
        break;

    case WM_COMMAND:    /* message: command from application menu */
        switch( wParam ) {
        case IDM_NETINTFS:
            NetIntfDlg( hWnd );
            break;

        case IDM_CLOSE:
            CloseDlg( hWnd );
            break;

        case IDM_SHOW_FONT:
            SelectOurFont(hWnd);
            InvalidateRect(hWnd, NULL, TRUE);
            break;

#if DBG
        case IDM_SHOW_LOGGER:
            {
                char    x[256];

                strcpy(tmpBuf, "notepad ");

                GetSystemDirectory( x, sizeof(x) );
                lstrcat( tmpBuf, x );
                lstrcat( tmpBuf, "\\netdde.log" );
                WinExec(tmpBuf, SW_SHOWNORMAL);
            }
            break;
#endif  // DBG

        case IDM_PREFERENCES:
            result = DialogBox( hInst, "PREFERENCES",
                hWnd, (DLGPROC)PreferencesDlgProc );
            if( result < 0 ){
                MessageBox( NULL, szDlgBoxMemErr,
                    GetAppName(), MB_TASKMODAL | MB_OK | MB_ICONSTOP );
            }
            break;

        case IDM_ROUTE_INFO:
            result = DialogBox( hInst, "ROUTES",
                hWnd, (DLGPROC)RoutesDlgProc );
            if ( result < 0 ) {
                MessageBox( NULL, szDlgBoxMemErr,
                            GetAppName(), MB_TASKMODAL | MB_OK | MB_ICONSTOP );
            }
            break;

        case IDM_HELP_INDEX:
            WinHelp( hWnd, szHelpFileName, HELP_INDEX, 0L );
            break;

        case IDM_HELP_HELP:
            WinHelp( hWnd, szHelpFileName, HELP_HELPONHELP, 0L );
            break;

        case IDM_CONNECT:
            if( GetNameFromUser( "Name to connect to ...", szLastConnect,
                ILLEGAL_NAMECHARS, MAX_NODE_NAME, HC_CONNECT_OPEN ) )  {
                if( lstrcmpi( nameFromUser, ourNodeName ) == 0 )  {
                    MessageBox( NULL,
                        "Cannot connect to yourself",
                        GetAppName(),
                        MB_TASKMODAL | MB_OK | MB_ICONEXCLAMATION );
                } else {
                    RouterGetRouterForDder( nameFromUser, (HDDER) NULL );
                    strcpy( szLastConnect, nameFromUser );
                }
            }
            break;

        case IDM_NODENAME:
            if( GetNameFromUser( "Name for this node ...", ourNodeName,
                    ILLEGAL_NAMECHARS, MAX_NODE_NAME, HC_NODE_NAME ) )  {
                MyGetPrivateProfileString( szGeneral, "LocalNodeName", "",
                    tmpBuf, sizeof(tmpBuf), szNetddeIni );
                if( lstrcmpi( nameFromUser, tmpBuf ) != 0 )  {
                    AnsiUpper( nameFromUser );
                    MessageBox( hWnd,
                        "Node Name change will take effect the next time you start NetDDE",
                        GetAppName(),
                        MB_ICONEXCLAMATION | MB_OK );
                    MyWritePrivateProfileString( szGeneral, "LocalNodeName",
                        nameFromUser, szNetddeIni );
                }
            }
            break;
        case IDM_SHOW_STATISTICS:
            ReverseMenuBoolean( hWnd, wParam, &bShowStatistics, "ShowStatistics" );
            break;
        case IDM_SHOW_PKTZ:
            ReverseMenuBoolean( hWnd, wParam, &bShowPktz, "ShowPktz" );
            break;
        case IDM_SHOW_ROUTER:
            ReverseMenuBoolean( hWnd, wParam, &bShowRouter, "ShowRouter" );
            break;
        case IDM_SHOW_ROUTER_THRU:
            ReverseMenuBoolean( hWnd, wParam, &bShowRouterThru, "ShowRouterThrough" );
            break;
        case IDM_SHOW_IPC:
            ReverseMenuBoolean( hWnd, wParam, &bShowIpc, "ShowIpc" );
            break;
        case IDM_ABOUT:
            result = DialogBox( hInst, "AboutBox", hWnd, (DLGPROC) About );
            if( result < 0 )  {
                MessageBox( NULL, szDlgBoxMemErr,
                    GetAppName(), MB_TASKMODAL | MB_OK );
            }
            break;

        default:
            i = wParam - IDM_CONFIG_IF;
            if (i < MAX_NETINTFS) {
                pNi = &niInf[ i ];
                if (pNi->bOk) {
                    (*(pNi->niPtrs.Configure))();
                } else {
                    /*  %1: (wParam = %2). Undefined Network Interface Selected */

                    NDDELogError(MSG006, "WM_COMMAND",
                        LogString("0x%0X", wParam), NULL);
                }
            } else {
                return (DefWindowProc(hWnd, message, wParam, lParam));
            }
        }
        break;
#endif // HASUI

    case WM_DESTROY:            /* message: window being destroyed */

        /*
         * Unlink this thread from the list.
         */
        EnterCrit();
        for (pptd = &ptdHead; *pptd && (*pptd)->hwndDDE != hWnd;
                pptd = &(*pptd)->ptdNext)
            ;
        if (*pptd)
            *pptd = (*pptd)->ptdNext;

        if (ptdHead == NULL) {
            for( i=0; i<nNi; i++ )  {
                pNi = &niInf[i];
                if( pNi->bOk && pNi->niPtrs.Shutdown )  {
                    (*pNi->niPtrs.Shutdown)();
                }
#if 0 // Not needed, and messes us up w/multiple thread stuff.
                if( pNi->hLibrary )  {
                    FreeLibrary( pNi->hLibrary );
                    pNi->hLibrary = 0;
                }
#endif
            }
            bNetddeClosed = TRUE;
            /*  NetDDE Service on node "%1" has been stopped. */

            NDDELogInfo(MSG002, ourNodeName, NULL);

#ifdef HASUI
            WinHelp( hWnd, szHelpFileName, HELP_QUIT, 0L );
#endif // HASUI
        }
        LeaveCrit();
        PostQuitMessage( 0 );
        break;

    default:                    /* Passes it on if unproccessed    */
        if (message == wMsgIpcInit) {
            PIPCINIT pii;

            pii = (PIPCINIT)wParam;
            return IpcInitConversation( pii->hDder, pii->lpDdePkt,
                    pii->bStartApp, pii->lpszCmdLine, pii->dd_type );
        } else if (message == wMsgIpcXmit) {
            PIPCXMIT pix;

            pix = (PIPCXMIT)wParam;
            return IpcXmitPacket(pix->hIpc, pix->hDder, pix->lpDdePkt);
        } else if (message == wMsgNddeAgntAlive) {
            /*  NetDDE Agent %1 Coming Alive */

            TRACEINIT((szT, "NetDDE window got wMsgAgntAlive.\n"));
            NDDELogInfo(MSG007, LogString("0x%0X", wParam), NULL);
            ptd = TlsGetValue(tlsThreadData);
            ptd->hwndDDEAgent = (HWND) wParam;
        } else if (message == wMsgNddeAgntDying) {
            /*  NetDDE Agent %1 Dying   */

            NDDELogInfo(MSG008, LogString("0x%0X", wParam), NULL);
            PasswordAgentDying();
            ptd = TlsGetValue(tlsThreadData);
            ptd->hwndDDEAgent = 0;
        } else if( message == wMsgNetddeAlive )  {
            if( wParam )  {
                ptr = GlobalLock( (HANDLE) wParam );
                if( ptr )  {
                    *( (HWND FAR *)ptr ) = hWnd;
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
        } else if( message == wMsgGetOurNodeName )  {
            if( wParam )  {
                ptr = GlobalLock( (HANDLE) wParam );
                if( ptr )  {
                    lstrcpy( ptr, ourNodeName );
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
#ifdef  ENUM
        } else if( message == wMsgSessionEnum )  {
            if( wParam )  {
                LPSESSENUM_CMR    lpSessEnum;
                LPSTR        lpResult;

                lpSessEnum = (LPSESSENUM_CMR) GlobalLock( (HANDLE) wParam );
                if( lpSessEnum )  {
                    lpSessEnum->fTouched = TRUE;
                    lpSessEnum->lReturnCode = NDDE_NO_ERROR;
                    lpSessEnum->nItems = RouterCount();
                    lpSessEnum->cbTotalAvailable =
                        lpSessEnum->nItems * sizeof(DDESESSINFO);
                    lpResult = ((LPSTR)lpSessEnum) + sizeof(SESSENUM_CMR);
                    RouterFillInEnum( lpResult, lpSessEnum->cBufSize );
                    if( lpSessEnum->cBufSize < lpSessEnum->cbTotalAvailable) {
                        lpSessEnum->lReturnCode = NDDE_BUF_TOO_SMALL;
                    }
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
        } else if( message == wMsgConnectionEnum )  {
            if( wParam )  {
                LPCONNENUM_CMR    lpConnEnum;

                lpConnEnum = (LPCONNENUM_CMR) GlobalLock( (HANDLE) wParam );
                if( lpConnEnum )  {
                    lpConnEnum->fTouched = TRUE;
                    RouterEnumConnectionsForApi( lpConnEnum );
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
#endif
        } else if( message == wMsgPasswordDlgDone )  {
            PasswordDlgDone( (HWND)wParam,
                ((LPPASSDLGDONE)lParam)->lpszUserName,
                ((LPPASSDLGDONE)lParam)->lpszDomainName,
                ((LPPASSDLGDONE)lParam)->lpszPassword,
                ((LPPASSDLGDONE)lParam)->fCancelAll );
        } else if( message == wMsgSessionClose )  {
            if( wParam )  {
                LPSESSCLOSE_CMR    lpSessClose;

                lpSessClose = (LPSESSCLOSE_CMR) GlobalLock( (HANDLE) wParam );
                if( lpSessClose )  {
                    lpSessClose->fTouched = TRUE;
                    if( RouterCloseByCookie( lpSessClose->clientName,
                        lpSessClose->cookie ) )  {
                        lpSessClose->lReturnCode = NDDE_NO_ERROR;
                    } else {
                        lpSessClose->lReturnCode = NDDE_INVALID_SESSION;
                    }
                    GlobalUnlock( (HANDLE)wParam );
                }
                return( 1L );
            }
        } else if( message == wMsgGetClientInfo )  {
            if( wParam )  {
                HWND    hWndClient;
                LONG    lMaxNode;
                LONG    lMaxApp;
                LPSTR    lpszResult;
                int    n;
                char    clientNameFull[ 128 ];
                LPSTR    lpszClientName;

                lpInfoCliCmd = (LPINFOCLI_CMD) GlobalLock( (HANDLE) wParam );
                if( lpInfoCliCmd )  {
                    hWndClient = (HWND)lpInfoCliCmd->hWndClient;
                    lMaxNode = lpInfoCliCmd->cClientNodeLimit;
                    lMaxApp = lpInfoCliCmd->cClientAppLimit;
                    lpInfoCliRsp = (LPINFOCLI_RSP)lpInfoCliCmd;
                    lpInfoCliRsp->fTouched = TRUE;
                    EnterCrit();
                    ptd = TlsGetValue(tlsThreadData);
                    if( ptd->bInitiating )  {
                        lpInfoCliRsp->offsClientNode = sizeof(INFOCLI_RSP);
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientNode;
                        _fstrncpy( lpszResult, szInitiatingNode,
                            (int)lMaxNode );
                        lpInfoCliRsp->offsClientApp =
                            lpInfoCliRsp->offsClientNode
                                + lstrlen( lpszResult ) + 1;
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientApp;
                        _fstrncpy( lpszResult, szInitiatingApp,
                            (int)lMaxNode );
                    } else {
                        lpInfoCliRsp->offsClientNode = sizeof(INFOCLI_RSP);
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientNode;
                        *lpszResult = '\0';
                        lpInfoCliRsp->offsClientApp =
                            lpInfoCliRsp->offsClientNode
                                + lstrlen( lpszResult ) + 1;
                        lpszResult = ((LPSTR)lpInfoCliRsp) +
                            lpInfoCliRsp->offsClientApp;

                        n = GetModuleFileName(
                            (HMODULE)GetClassLongPtr( hWndClient, GCLP_HMODULE ),
                            clientNameFull,
                            sizeof(clientNameFull) );
                        lpszClientName = &clientNameFull[ n-1 ];
                        while( *lpszClientName != '.' )  {
                            lpszClientName--;
                        }
                        *lpszClientName = '\0'; // null out '.'

                        while( (*lpszClientName != '\\')
                            && (*lpszClientName != ':')
                            && (*lpszClientName != '/'))  {
                            lpszClientName--;
                        }
                        lpszClientName++;

                        _fstrncpy( lpszResult, lpszClientName,
                            (int)lMaxNode );
                    }
                    GlobalUnlock( (HANDLE)wParam );
                    LeaveCrit();
                }
                return( 1L );
            }
        } else {
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
    }
    return( 0 );
}

BOOL
FAR PASCAL
ProtGetDriverName(
    LPSTR   lpszName,
    int     nMaxLength )
{
    strncpy( lpszName, szAppName, nMaxLength );
    return( TRUE );
}


FARPROC
FAR PASCAL
XGetProcAddress(
    LPSTR   lpszDllName,
    HANDLE  hLibrary,
    LPSTR   lpszFuncName )
{
    FARPROC     rtn;

    rtn = GetProcAddress( hLibrary, lpszFuncName );
    if( rtn == (FARPROC)NULL )  {  // try without the underscore
        rtn = GetProcAddress( hLibrary, lpszFuncName+1 );
    }
    if( rtn == (FARPROC)NULL )  {
        /*  Cannot load function address of "%1" from "%2" DLL */

        NDDELogError(MSG009, lpszFuncName, lpszDllName, NULL);
    }
    return( rtn );
}

BOOL
FAR PASCAL
GetNiPtrs(
    HANDLE FAR *lphLibrary,
    LPSTR       lpszDllName,
    LPNIPTRS    lpNiPtrs )
{
    BOOL        ok = TRUE;
    char        dllName[ 128 ];

    lstrcpyn( lpNiPtrs->dllName, lpszDllName, sizeof(lpNiPtrs->dllName) );
    lpNiPtrs->dllName[ sizeof(lpNiPtrs->dllName)-1 ] = '\0';

    lstrcpy( dllName, lpszDllName );
    *lphLibrary = LoadLibrary( dllName );
    if( *lphLibrary )  {
        if( ok )  {
            lpNiPtrs->Init = (FP_Init)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEInit" );
            if( !lpNiPtrs->Init )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetCAPS = (FP_GetCAPS)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetCAPS" );
            if( !lpNiPtrs->GetCAPS )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetNewConnection = (FP_GetNewConnection)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetNewConnection" );
            if( !lpNiPtrs->GetNewConnection )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->AddConnection = (FP_AddConnection)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEAddConnection" );
            if( !lpNiPtrs->AddConnection )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->DeleteConnection = (FP_DeleteConnection)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEDeleteConnection" );
            if( !lpNiPtrs->DeleteConnection )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetConnectionStatus = (FP_GetConnectionStatus)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetConnectionStatus" );
            if( !lpNiPtrs->GetConnectionStatus )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->RcvPacket = (FP_RcvPacket)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDERcvPacket" );
            if( !lpNiPtrs->RcvPacket )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->XmtPacket = (FP_XmtPacket)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEXmtPacket" );
            if( !lpNiPtrs->XmtPacket )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->SetConnectionConfig = (FP_SetConnectionConfig)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDESetConnectionConfig" );
            if( !lpNiPtrs->SetConnectionConfig )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->GetConnectionConfig = (FP_GetConnectionConfig)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEGetConnectionConfig" );
            if( !lpNiPtrs->GetConnectionConfig )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->Shutdown = (FP_Shutdown)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDEShutdown" );
            if( !lpNiPtrs->Shutdown )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->TimeSlice = (FP_TimeSlice)
                XGetProcAddress( lpszDllName, *lphLibrary,
                    "NDDETimeSlice" );
            if( !lpNiPtrs->TimeSlice )  {
                ok = FALSE;
            }
        }
#ifdef HASUI
        if( ok )  {
            lpNiPtrs->Configure = (FP_Configure)
                XGetProcAddress( lpszDllName, *lphLibrary, "Configure" );
            if( !lpNiPtrs->Configure )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpNiPtrs->LogDebugInfo = (FP_LogDebugInfo)
                XGetProcAddress( lpszDllName, *lphLibrary, "LogDebugInfo" );
            if( !lpNiPtrs->LogDebugInfo )  {
                ok = FALSE;
            }
        }
#endif
    } else {
        /* Error loading "%1" DLL: %2 */

        NDDELogError(MSG010, dllName, LogString("%d", GetLastError()), NULL);
        return( FALSE );
    }
    if( !ok )  {
        if( *lphLibrary )  {
            FreeLibrary( *lphLibrary );
        }
        *lphLibrary = NULL;
        /* Error loading "%1" DLL functions */

        NDDELogError(MSG011, dllName, NULL);
    }
    return( ok );
}

/* returns the next available network interface that supports mapping names
    to addresses */
BOOL
GetNextMappingNetIntf(
    LPNIPTRS FAR *lplpNiPtrs,
    int FAR      *lpnNi )
{
    int         i;
    PNI         pNi;

    *lpnNi = *lpnNi+1;

    for( i=*lpnNi; i<nNi; i++ )  {
        pNi = &niInf[i];
        if( pNi->bOk && pNi->bMapping )  {
            *lplpNiPtrs = &niInf[ i ].niPtrs;
            *lpnNi = i;
            return( TRUE );
        }
    }
    return( FALSE );
}

BOOL
NameToNetIntf(
    LPSTR           lpszName,
    LPNIPTRS FAR   *lplpNiPtrs )
{
    int         i;
    PNI         pNi;

    *lplpNiPtrs = NULL;
    for( i=0; i<nNi; i++ )  {
        pNi = &niInf[i];
        if( pNi->bOk && (lstrcmpi( pNi->niPtrs.dllName, lpszName ) == 0) ) {
            *lplpNiPtrs = &pNi->niPtrs;
            return( TRUE );
        }
    }
    return( FALSE );
}


BOOL
FAR PASCAL
NameInList(
    HWND    hDlg,
    int     cid,
    LPSTR   lpszName )
{
    int         nIndex  = -1;
    char        szInfo[ MAX_CONN_INFO+1 ];
    BOOL        ok;

    while( TRUE )  {
        nIndex = (int) SendDlgItemMessage( hDlg, cid, CB_FINDSTRING, nIndex,
            (LPARAM)(LPSTR)lpszName );
        if( nIndex == CB_ERR )  {
            ok = FALSE;
            break;
        } else {
            /* unfortunately, CB_FINDSTRING returns a match if only a
                prefix matches ... that's why we have to get the string for
                the index that CB_FINDSTRING returns and compare it to
                the string we're looking for
             */
            SendDlgItemMessage( hDlg, cid, CB_GETLBTEXT, nIndex,
                (LPARAM)(LPSTR)szInfo );
            if( lstrcmpi( szInfo, lpszName ) == 0 )  {
                ok = TRUE; /* already in list */
                break;
            }
        }
    }
    return ok;
}

VOID
FAR PASCAL
NetddeEnumConnection(
    HWND    hDlg,
    LPSTR   lpszName )
{
    if( !NameInList( hDlg, CI_COMBO_NAME, lpszName ) )  {
        SendDlgItemMessage( hDlg, CI_COMBO_NAME, CB_ADDSTRING,
            0, (LPARAM)(LPSTR)lpszName );
    }
}

VOID
FAR PASCAL
NetddeEnumRoute(
    HWND    hDlg,
    LPSTR   lpszName )
{
    if( !NameInList( hDlg, CI_COMBO_NAME, lpszName ) )  {
        SendDlgItemMessage( hDlg, CI_COMBO_NAME, CB_ADDSTRING,
            0, (LPARAM)(LPSTR)lpszName );
    }
}


BOOL
FAR PASCAL
AddNetIntf( HWND hWnd, LPSTR lpszDllName )
{
    int         nLastInterface = 0;
    int         i;
    PNI         pNi;

    AnsiUpper( lpszDllName );
    for( i=0; i<MAX_NETINTFS; i++ )  {
        wsprintf( tmpBuf2, szInterfaceFmt, i+1 );
        MyGetPrivateProfileString( szInterfaces, tmpBuf2,
            "", tmpBuf, sizeof(tmpBuf), szNetddeIni );

        if( tmpBuf[0] == '\0' )  {
            break;      // done looking
        } else {
            nLastInterface = i+1;
        }
    }

    // not found in current list
    if( nLastInterface == MAX_NETINTFS )  {
        /*  Cannot add "%1" DLL.
            Already have maximum number of network interface DLLs   */
        NDDELogError(MSG069, lpszDllName, NULL);
        return( FALSE );
    }

    for (i = 0; i < MAX_NETINTFS; i++) {
        if (niInf[i].bOk == FALSE) {
            pNi = &niInf[i];
            break;
        }
    }
    if( i >= MAX_NETINTFS )  {
        NDDELogError(MSG070, lpszDllName, NULL);
        return( FALSE );
    }
    pNi->hLibrary = 0;

    if( InitializeInterface( hWnd, pNi, lpszDllName, i ) )  {
        // record this as a network interface
        wsprintf( tmpBuf2, szInterfaceFmt, nLastInterface+1 );
        MyWritePrivateProfileString( szInterfaces, tmpBuf2,
            lpszDllName, szNetddeIni );
    if (i >= nNi)
        nNi++;
        return( TRUE );
    } else {
        return( FALSE );
    }
}

BOOL
FAR PASCAL
InitializeInterface(
    HWND    hWndNetdde,
    PNI     pNi,
    LPSTR   lpszDllName,
    int     nCurrentNi )
{
    BOOL        ok;
    DWORD       stat = 0;
#ifdef HASUI
    HCURSOR     hCursor, hOldCursor;
    HMENU       hMenu;
    HMENU       hMenuConfigure;
    HMENU       hMenuDebug;
    char        menuName[ 100 ];
#endif

    if( ok = GetNiPtrs( &pNi->hLibrary, lpszDllName, &pNi->niPtrs ) )  {
#ifdef HASUI
        hCursor = LoadCursor( NULL, IDC_WAIT );
        hOldCursor = SetCursor( hCursor );
#endif // HASUI

        stat = (*pNi->niPtrs.Init)( ourNodeName, hWndNetdde );
        if (stat != NDDE_INIT_OK) {
            ok = FALSE;
        }

#ifdef HASUI
        SetCursor( hOldCursor );
#endif // HASUI

        if( ok )  {
            if( (*pNi->niPtrs.GetCAPS)( NDDE_SPEC_VERSION ) != NDDE_CUR_VERSION )  {
                /*  Wrong version of "%1" DLL: %2%\
                    Disabling this interface. */

                NDDELogError(MSG012, pNi->niPtrs.dllName,
                    LogString("0x%0X", (*pNi->niPtrs.GetCAPS)( NDDE_SPEC_VERSION )), NULL);
                (*pNi->niPtrs.Shutdown)();
                ok = FALSE;
            }
        }
        if( ok )  {
            pNi->bOk = TRUE;
            pNi->bMapping =
                (BOOL) (*pNi->niPtrs.GetCAPS)( NDDE_MAPPING_SUPPORT );
#ifdef HASUI
            pNi->bParamsOK =
                (BOOL) (*pNi->niPtrs.GetCAPS)( NDDE_CONFIG_PARAMS );
            if (pNi->bParamsOK) {
                hMenu = GetMenu( hWndNetdde );
                hMenuConfigure = GetSubMenu( hMenu, 0 );
                if (nCP++ == 0) {
                    AppendMenu(hMenuConfigure, MF_SEPARATOR, 0, NULL);
                }
                wsprintf( menuName, "%s Parameters ...",
                    (LPSTR) pNi->niPtrs.dllName );
                ChangeMenu( hMenuConfigure, 0, menuName,
                    IDM_CONFIG_IF + nCurrentNi, MF_APPEND );
            }
#if DBG
            if( bDebugMenu )  {
                hMenuDebug = GetSystemMenu( hWndNetdde, FALSE );
                if (nDI++ == 0) {
                    AppendMenu(hMenuDebug, MF_SEPARATOR, 0, NULL);
                }
                wsprintf( menuName, "Dump %s state ...",
                            (LPSTR) pNi->niPtrs.dllName );
                ChangeMenu( hMenuDebug, 0, menuName,
                            IDM_DEBUG_INTF + (nCurrentNi<<4), MF_APPEND );
            }
#endif
#endif
            nNiOk ++;
        } else {
            /*  Initialization of "%1" DLL failed */

            if (stat != NDDE_INIT_NO_SERVICE) {
                NDDELogError(MSG013, (LPSTR) pNi->niPtrs.dllName, NULL);
            }
        }
    }
    return( ok );
}

BOOL
FAR PASCAL
DeleteNetIntf( HWND hWnd, LPSTR lpszIntfName )
{
    BOOL        ok = TRUE;
    int         i;
    PNI         pNi;
    int         nInterfaces = 0;
    BOOL        found = FALSE;
#ifdef HASUI
    HMENU       hMenu;
    HMENU       hMenuConfigure;
    HMENU       hMenuDebug;
#endif

    for( i=0; ok && !found && i<MAX_NETINTFS; i++ )  {
        wsprintf( tmpBuf2, szInterfaceFmt, i+1 );
        MyGetPrivateProfileString( szInterfaces, tmpBuf2,
            "", tmpBuf, sizeof(tmpBuf), szNetddeIni );

        if( tmpBuf[0] == '\0' )  {
            return( FALSE );
        } else {
            if( lstrcmpi( lpszIntfName, tmpBuf ) == 0 )  {
                // actually delete it
                found = TRUE;
                ok = DeleteNetIntfFromNetDdeIni( i );
            }
        }
    }

    if( !found || !ok )  {
        return( FALSE );
    }

    found = FALSE;
    for( i=0; ok && !found && i<nNi; i++ )  {
        pNi = &niInf[i];
        if( pNi->bOk && (lstrcmpi( lpszIntfName, pNi->niPtrs.dllName) == 0)){
            found = TRUE;
            if( pNi->niPtrs.Shutdown )  {
                (*pNi->niPtrs.Shutdown)();
            }
            if( pNi->hLibrary )  {
                FreeLibrary( pNi->hLibrary );
                pNi->hLibrary = 0;
            }
            pNi->bOk = FALSE;
            nNiOk --;

#ifdef HASUI
            // delete from the menu
            if (ptdHead->hwndDDE) {
                hMenu = GetMenu( ptdHead->hwndDDE );
                hMenuConfigure = GetSubMenu( hMenu, 0 );
                hMenuDebug = GetSystemMenu( ptdHead->hwndDDE, FALSE );
                if (pNi->bParamsOK) {
                    DeleteMenu( hMenuConfigure, IDM_CONFIG_IF + i, MF_BYCOMMAND );
                    nCP--;
                    if (nCP == 0) {
                        DeleteMenu(hMenuConfigure,
                            GetMenuItemCount(hMenuConfigure) - 1, MF_BYPOSITION);
                    }
                }
#if DBG
                if( bDebugMenu )  {
                    DeleteMenu( hMenuDebug,
                        IDM_DEBUG_INTF + (i<<4),
                        MF_BYCOMMAND );
                    nDI--;
                    if (nDI == 0) {
                        DeleteMenu(hMenuDebug,
                            GetMenuItemCount(hMenuDebug) - 1, MF_BYPOSITION);
                    }
                }
#endif  // DBG
            }
#endif // HASUI
        }
    }
    return( ok );
}

BOOL
FAR PASCAL
DeleteNetIntfFromNetDdeIni( int nToDelete )
{
    int         i;
    char        dllName[ 128 ];
    BOOL        done = FALSE;

    // if we delete Interface2  copy Interface3 to Interface2, Interface4
    //  to Interface3, etc.

    for( i=nToDelete; !done && i<MAX_NETINTFS; i++ )  {
        wsprintf( tmpBuf2, szInterfaceFmt, i+2 );
        MyGetPrivateProfileString( szInterfaces, tmpBuf2,
            "", dllName, sizeof(dllName), szNetddeIni );

        if( dllName[0] == '\0' )  {
            wsprintf( tmpBuf2, szInterfaceFmt, i+1 );
            MyWritePrivateProfileString( szInterfaces, tmpBuf2,
                NULL, szNetddeIni );
            break;      // done looking
        } else {
            wsprintf( tmpBuf2, szInterfaceFmt, i+1 );
            MyWritePrivateProfileString( szInterfaces, tmpBuf2,
                dllName, szNetddeIni );
        }
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\netdde.h ===
#define GUI_ROUTES

#define IDM_NODENAME			101
#define IDM_NETINTF_PARMS		102
#define IDM_DEFAULT_NETINTF		103
#define IDM_ROUTE_INFO			104
#define IDM_ADD_NETINTF			105
#define IDM_DELETE_NETINTF		106
#define IDM_CLOSE_CONNECTION		107
#define IDM_CONNECT			108
#define IDM_NETINTFS			109
#define IDM_SECURITY_FILE		111
#define IDM_CLOSE_ROUTE			112
#define IDM_PREFERENCES			113
#define IDM_PHYSICAL_CONNECTIONS	114
#define IDM_VALIDATE_FILES		115
#define IDM_SHOW_LOGGER			116
#define IDM_CLOSE			117
#define IDM_SHOW_FONT       118
#define IDM_CLOSE_ALL_CONNECTIONS	119

#define IDM_CONFIG_IF       120

#define IDM_HELP_INDEX			291
#define IDM_HELP_HELP			292
#define IDM_ABOUT			293

#define MAX_NETINTFS 8

#define IDM_SHOW_DDER			0x100
#define IDM_DEBUG_DDE			0x110
#define IDM_LOG_INFO			0x120
#define IDM_LOG_DDE_PKTS		0x130
#define IDM_DEBUG_NETDDE		0x140
#define IDM_DEBUG_NETDDE_MEMORY		0x150
#define IDM_DEBUG_INTF			0x160
#define IDM_DEBUG_INTF_MAX		(IDM_DEBUG_INTF + (MAX_NETINTFS<<4))

#define IDM_SHOW_PKTZ			401
#define IDM_SHOW_ROUTER			402
#define IDM_SHOW_IPC			404
#define IDM_SHOW_STATISTICS		405
#define IDM_SHOW_ROUTER_THRU		406

#define CI_ND_NAME			131
#define CI_EDIT				132
#define CI_DFLT_ALLOW			133
#define CI_DFLT_RUN			134
#define CI_DFLT_DISCONNECT		135
#define CI_DFLT_DELAY			136
#define CI_TIME_SLICE           137

#define CI_VERSION			200

#define CI_DEST_NAME			300
#define CI_ROUTE_INFO			301
#define CI_DEFAULTS			302
#define CI_ALLOW_ADVISE			304
#define CI_ALLOW_REQUEST		305
#define CI_ALLOW_POKE			306
#define CI_ALLOW_EXECUTE		307
#define CI_DFLT_ROUTE			308
#define CI_COMBO_NAME			309
#define CI_CLOSE_ALL			310
#define CI_LOG_PERM_VIOL		311
#define CI_LOG_EXEC_FAIL		312

#define CI_RTNAME   510
#define CI_RTDELETE 511
#define CI_RTADD    512
#define CI_RTMODIFY 513
#define CI_RTPATH   514
#define CI_RTPATHI  5115

#define CI_HELP				10001

#define CI_SERIAL		141
#define CI_NETBIOS		142
#define CI_NMTCPIP		143
#define CI_FTCPIP       144
#define CI_DECNET		145
#define CI_NOVELL		146


/**** Help Contexts ****/
#define HC_NODE_NAME			0x0200
#define HC_ROUTE_INFO			0x0201
#define HC_CONNECT_OPEN			0x0202
#define HC_NETINTF			0x0203
#define HC_SECURITY_INFO		0x0204
#define HC_PREFERENCES			0x0205
#define HC_CONNECTION_INFO		0x0206
#define HC_SECURITY_DEFAULT		0x0207
#define HC_CONNECTION_DEFAULT		0x0208
#define HC_ROUTE_DEFAULT		0x0209
#define HC_CLOSE			0x020A
#define HC_ROUTE_CONFIG     0x020B

/*** add any additional lines to netdde.hpj! ***/

BOOL	FAR PASCAL InitApplication( HANDLE );
BOOL	FAR PASCAL InitInstance( HANDLE, int, LPSTR );
LPARAM	FAR PASCAL MainWndProc( HWND, unsigned, WPARAM, LPARAM );
BOOL	FAR PASCAL About( HWND, unsigned, UINT, LONG );
BOOL	FAR PASCAL ProtGetDriverName( LPSTR lpszName, int nMaxLength );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\spt.h ===
HANDLE	FAR PASCAL GetGlobalAlloc( WORD, DWORD );
PSTR	FAR PASCAL GetAppName( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\shareif.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "SHAREIF.C;1  16-Dec-92,10:17:46  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <windows.h>
#include    "tmpbuf.h"
#include    "debug.h"
#include    "netbasic.h"
#include    "nddeapi.h"
#include    "nddemsg.h"
#include    "nddelog.h"

static char    szClipRef[] = "NDDE$";

WORD
atohn (
    LPSTR   s,
    int     n )
{
    WORD ret = 0;
    int i;

    for ( i = 0, ret = 0; i < n; ret << 4, i++ )
        if ( '0' <= s[i] && s[i] <= '9' )
            ret += s[i] - '0';
        else if ( tolower(s[i]) >= 'a' && tolower(s[i]) <= 'f' )
            ret += tolower(s[i]) - 'a';
    return ret;
}



/*
 * See if the given DDE appname is prepended by a NDDE$ string -
 * meaning that it is a reference to a NetDDE share.
 */
BOOL
IsShare(LPSTR lpApp)
{
    return( _strnicmp( lpApp, szClipRef, 5 ) == 0 );
}




WORD
ExtractFlags(LPSTR lpApp)
{
    WORD    ret = 0;
    LPSTR   pch;

    if ( IsShare(lpApp) ) {
        pch = lpApp + lstrlen(szClipRef);
        if ( lstrlen(pch) >= 4 ) {
            ret = atohn(pch,4);
        }
    }
    return ret;
}

BOOL
GetShareName(
    LPSTR   lpShareBuf,
    LPSTR   lpAppName,
    LPSTR   lpTopicName
)
{
    BOOL    ww;
    int     k;

    ww = !IsShare(lpAppName);

    if ((k = lstrlen(lpAppName)) > MAX_SHARENAMEBUF) {
        return(FALSE);
    }
    if (ww) {
        if ((k + lstrlen(lpTopicName) + 1) > MAX_SHARENAMEBUF) {
            return(FALSE);
        }
        lstrcpy(lpShareBuf, lpAppName);
        lstrcat(lpShareBuf, "|");
        lstrcat(lpShareBuf, lpTopicName);
    } else {
        lstrcpy(lpShareBuf, lpTopicName);
    }
    return(TRUE);
}


/*
 * This function produces appripriate App and Topic strings from
 * the share's internal concatonated string format based on
 * the share type.
 *
 * Internally, the shares would be:
 * OLDApp|OLDTopic \0 NEWApp|NewTopic \n STATICApp|STATICTopic \0 \0.
 * SAS 4/14/95
 */
BOOL
GetShareAppTopic(
    DWORD           lType,          // type of share accessed
    PNDDESHAREINFO  lpShareInfo,    // share info buffer
    LPSTR           lpAppName,      // where to put it
    LPSTR           lpTopicName)      // where to put it
{
    LPSTR           lpName;

    lpName = lpShareInfo->lpszAppTopicList;
    switch (lType) {
    case SHARE_TYPE_STATIC:
        lpName += strlen(lpName) + 1;
        /* INTENTIONAL FALL-THROUGH */

    case SHARE_TYPE_NEW:
        lpName += strlen(lpName) + 1;
        /* INTENTIONAL FALL-THROUGH */

    case SHARE_TYPE_OLD:
        strcpy(tmpBuf, lpName);
        lpName = strchr(tmpBuf, '|');
        if (lpName) {
            *lpName++ = '\0';
            strcpy(lpAppName, tmpBuf);
            strcpy(lpTopicName, lpName);
        } else {
            return( FALSE );
        }
        break;
    default:
        /*  Invaid Share Type request: %1   */
        NDDELogError(MSG063, LogString("%d", lType), NULL);
        return(FALSE);
    }
    return(TRUE);
}


BOOL
GetShareAppName(
    DWORD           lType,          // type of share accessed
    PNDDESHAREINFO  lpShareInfo,    // share info buffer
    LPSTR           lpAppName)      // where to put it
{
    LPSTR           lpName;

    lpName = lpShareInfo->lpszAppTopicList;
    switch (lType) {
        case SHARE_TYPE_OLD:
            strcpy(tmpBuf, lpName);
            lpName = strchr(lpName, '|');
            if (lpName) {
                *lpName = '\0';
            }
            strcpy(lpAppName, tmpBuf);
            break;
        case SHARE_TYPE_NEW:
            lpName += strlen(lpName) + 1;
            strcpy(tmpBuf, lpName);
            lpName = strchr(lpName, '|');
            if (lpName) {
                *lpName = '\0';
            }
            strcpy(lpAppName, tmpBuf);
            break;
        case SHARE_TYPE_STATIC:
            lpName += strlen(lpName) + 1;
            lpName += strlen(lpName) + 1;
            strcpy(tmpBuf, lpName);
            lpName = strchr(lpName, '|');
            if (lpName) {
                *lpName = '\0';
            }
            strcpy(lpAppName, tmpBuf);
            break;
        default:
            /*  Invaid Share Type request: %1   */
            NDDELogError(MSG063, LogString("%d", lType), NULL);
            return(FALSE);
    }
    return(TRUE);
}

BOOL
GetShareTopicName(
    DWORD           lType,          // type of share accessed
    PNDDESHAREINFO  lpShareInfo,    // share info buffer
    LPSTR           lpTopicName)    // where to put it
{
    LPSTR           lpName;

    lpName = lpShareInfo->lpszAppTopicList;
    *lpTopicName = '\0';
    switch (lType) {
        case SHARE_TYPE_OLD:
            if (lpName = strchr(lpName, '|')){
                strcpy(lpTopicName, ++lpName);
            }
            break;
        case SHARE_TYPE_NEW:
            lpName += strlen(lpName) + 1;
            if (lpName = strchr(lpName, '|')){
                strcpy(lpTopicName, ++lpName);
            }
            break;
        case SHARE_TYPE_STATIC:
            lpName += strlen(lpName) + 1;
            lpName += strlen(lpName) + 1;
            if (lpName = strchr(lpName, '|')){
                strcpy(lpTopicName, ++lpName);
            }
            break;
        default:
            /*  Invaid Share Type request: %1   */
            NDDELogError(MSG063, LogString("%d", lType), NULL);
            return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\password.h ===
#define IDC_DDESHARE                101
#define IDC_SHARENAME               102
#define IDC_SERVERNODE              106
#define IDC_PASSWORD                107
#define IDC_FAILED_PASSWORD_MSGBOX  108
#define IDC_CANCEL_ALL              109
#define IDC_MORE_CONVS              110
#define IDC_CACHE_PASSWORD          111

#define IDD_GETPASSWD               200
#define IDD_GETNTPASSWD             300

#define INVALID_PASSWORD                1

// globals for dialog - temporary...

struct DlgParam {
        LPSTR   glpszShareName;         // name of share being accessed
        LPSTR   glpszComputer;          // name of target server
        LPSTR   glpszUserName;          // current user name
        LPSTR   glpszDomainName;        // current domain name
        BOOL    gfLastOneFailed;
        BOOL    fCachePassword;         // default state of cache button
        BOOL    gfMoreConvs;
};
#define IDC_USER_NAME               301
#define IDC_DOMAIN_NAME             302

HWND WINAPI
PasswordGetFromUserModeless (
    HWND    hwndParent,             // window handle of dialog parent
    LPSTR   lpszTargetSrv,          // machine resource is on
    LPSTR   lpszShareName,          // name of share being accessed
    LPSTR   lpszUserName,           // current user name
    LPSTR   lpszDomainName,         // current domain name
    DWORD   dwSecurityType,         // security type
    BOOL    bFailedLastPassword,    // is this the first time for this?
    BOOL    bMoreConvs              // more convs for this task?
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\password.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "PASSWORD.C;1  16-Dec-92,10:17:30  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "api1632.h"
#include    <string.h>
#include    <stdlib.h>
#include    <dde.h>
#include    "windows.h"
#include    "nddeapi.h"
#include    "nddeapip.h"
#include    "nddeapis.h"
#include    "netbasic.h"
#include    "ddepkts.h"
#include    "winmsg.h"
#include    "sectype.h"
#include    "tmpbufc.h"
#include    "debug.h"
#include    "password.h"
#include    "ddeq.h"
#include    "dder.h"
#include    "wwdde.h"
#include    "wininfo.h"
#include    "nddemsg.h"
#include    "nddelog.h"

extern  LRESULT CALLBACK PasswdDlgWB(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam );
extern  LRESULT CALLBACK PasswdDlgNT(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam );

extern  BOOL    GetShareName( LPSTR, LPSTR, LPSTR);
extern  VOID    IpcAbortConversation( HIPC hIpc );

extern  HINSTANCE	    hInst;
static  HCURSOR         hOldCursor;


DWORD   tlsDialogHead = 0xffffffff;

HWND WINAPI
PasswordGetFromUserModeless (
    HWND    hwndParent,             // window handle of dialog parent
    LPSTR   lpszTargetSrv,          // machine resource is on
    LPSTR   lpszShareName,          // name of share being accessed
    LPSTR   lpszUserName,           // current user name
    LPSTR   lpszDomainName,         // current domain name
    DWORD   dwSecurityType,         // security type
    BOOL    bFailedLastPassword,    // is this the first time for this?
    BOOL    bMoreConvs              // more convs for this task?
)

{
    HWND    	    hWndPasswordDlg;
    static struct DlgParam DlgP;

    // global copies of pointers for dialog routine
    DlgP.glpszShareName = lpszShareName;
    DlgP.glpszComputer = lpszTargetSrv;
    DlgP.gfMoreConvs = bMoreConvs;
    DlgP.gfLastOneFailed = bFailedLastPassword;

    /* Select which dialog box to pop based on server type */

    switch (dwSecurityType) {
    case    MS_SECURITY_TYPE:
        hWndPasswordDlg = CreateDialogParam(hInst,
            MAKEINTRESOURCE(IDD_GETPASSWD), hwndParent, (DLGPROC) PasswdDlgWB,
            (LPARAM)( struct DlgParam far * ) & DlgP );
        if( hWndPasswordDlg )  {
            SetForegroundWindow( hWndPasswordDlg );
        } else {
	    DPRINTF(("CreateDialogParam() for WB croaked: %d", GetLastError()));
	}
        break;
    case    NT_SECURITY_TYPE:
        DlgP.glpszUserName = lpszUserName;
        DlgP.glpszDomainName = lpszDomainName;
        hWndPasswordDlg = CreateDialogParam(hInst,
            MAKEINTRESOURCE(IDD_GETNTPASSWD), hwndParent, (DLGPROC) PasswdDlgNT,
            (LPARAM)( struct DlgParam far * ) & DlgP );
        if( hWndPasswordDlg )  {
            SetForegroundWindow( hWndPasswordDlg );
        }
        break;
    default:
        /*  Internal Error -- Unknown Security Type %1  */
        NDDELogError(MSG061, LogString("%d", dwSecurityType), NULL);
        hWndPasswordDlg = NULL;
        break;
    }
    if( hWndPasswordDlg )  {
        EnableWindow( hwndParent, 0 );
    }
    return( hWndPasswordDlg );
}

VOID MBRes(
HWND hwndParent,
int StringId,
LPTSTR pszCaption,
UINT uiFlags)
{
    TCHAR szT[300];

    LoadString(hInst, StringId, szT, sizeof(szT));
    MessageBox(hwndParent, szT, pszCaption, uiFlags);
}

LRESULT CALLBACK
PasswdDlgWB(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam )
{
static  struct      DlgParam far * lpDlgP;
static  WORD        wMsgDonePasswordDlg = 0;
        char        szPassword[ MAX_PASSWORD + 1 ];
        WORD        cbLen;
        PASSDLGDONE passDlgDone;

    if( wMsgDonePasswordDlg == 0 )  {
        wMsgDonePasswordDlg = (WORD)RegisterWindowMessage( NETDDEMSG_PASSDLGDONE );
    }
    switch ( message ) {
    case WM_INITDIALOG:
        lpDlgP = ( struct DlgParam far * ) lParam;
        SetDlgItemText ( hDlg, IDC_DDESHARE, lpDlgP->glpszShareName );
        SetDlgItemText ( hDlg, IDC_SERVERNODE, lpDlgP->glpszComputer );
        SendDlgItemMessage ( hDlg, IDC_PASSWORD, EM_LIMITTEXT,
            MAX_PASSWORD, 0L );
        hOldCursor = SetCursor(LoadCursor(hInst, IDC_ARROW));
        SetFocus( GetDlgItem( hDlg, IDC_PASSWORD ) );
        if( lpDlgP->gfMoreConvs )  {
            PostMessage( hDlg, WM_COMMAND, IDC_MORE_CONVS,
                0L );
        }
        if( lpDlgP->gfLastOneFailed )  {
            PostMessage( hDlg, WM_COMMAND, IDC_FAILED_PASSWORD_MSGBOX,
                0L );
        }
        ShowWindow( GetDlgItem( hDlg, IDC_CANCEL_ALL ), SW_HIDE );
        return( FALSE );
        break;
    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_FAILED_PASSWORD_MSGBOX:
            MBRes( hDlg, INVALID_PASSWORD, "NetDDE", MB_OK | MB_ICONSTOP );
            break;
        case IDC_MORE_CONVS:
            EnableWindow( GetDlgItem( hDlg, IDC_CANCEL_ALL ), 1 );
            ShowWindow( GetDlgItem( hDlg, IDC_CANCEL_ALL ), SW_SHOW );
            break;
        case IDOK:
            cbLen = (WORD)GetDlgItemText( hDlg, IDC_PASSWORD,
                szPassword, sizeof(szPassword) );
	    _strupr( szPassword );
            passDlgDone.dwReserved = 1L;
            if (cbLen) {
                passDlgDone.lpszPassword = (LPSTR)szPassword;
            } else {
                passDlgDone.lpszPassword = (LPSTR)NULL;
            }
            /*  User/Domain names could not have changed, nothing to pass back */
            passDlgDone.lpszUserName = (LPSTR)NULL;
            passDlgDone.lpszDomainName = (LPSTR)NULL;
            passDlgDone.fCancelAll = FALSE;
            SendMessage( ((HWND)-1), wMsgDonePasswordDlg, (WPARAM)hDlg,
                (LPARAM) (LPPASSDLGDONE)&passDlgDone );
	    SetCursor(hOldCursor);
            DestroyWindow( hDlg );
            return TRUE;
        case IDCANCEL:
            passDlgDone.dwReserved = 1L;
            passDlgDone.lpszPassword = (LPSTR)NULL;
            passDlgDone.lpszUserName = (LPSTR)NULL;
            passDlgDone.lpszDomainName = (LPSTR)NULL;
            passDlgDone.fCancelAll = FALSE;
            SendMessage( ((HWND)-1), wMsgDonePasswordDlg, (WPARAM)hDlg,
                (LONG_PTR) (LPPASSDLGDONE)&passDlgDone );
	    SetCursor(hOldCursor);
            DestroyWindow( hDlg );
            return TRUE;
        case IDC_CANCEL_ALL:
            passDlgDone.dwReserved = 1L;
            passDlgDone.lpszPassword = (LPSTR)NULL;
            passDlgDone.lpszUserName = (LPSTR)NULL;
            passDlgDone.lpszDomainName = (LPSTR)NULL;
            passDlgDone.fCancelAll = TRUE;
            SendMessage( ((HWND)-1), wMsgDonePasswordDlg, (WPARAM)hDlg,
                (LONG_PTR) (LPPASSDLGDONE)&passDlgDone );
	    SetCursor(hOldCursor);
            DestroyWindow( hDlg );
            return TRUE;
        }
        break;
    }
    return FALSE;
}

LRESULT CALLBACK
PasswdDlgNT(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam )
{
static  struct  DlgParam far * lpDlgPnt;
static  WORD    wMsgDonePasswordDlgNT = 0;
    char        szPassword[ MAX_PASSWORD + 1 ];
    char        szUserName[ MAX_USERNAMEP + 1 ];
    char        szDomainName[ MAX_DOMAINNAMEP + 1 ];
    LPSTR       lpDom;
    WORD        cbLen;
    PASSDLGDONE passDlgDone;

    if( wMsgDonePasswordDlgNT == 0 )  {
        wMsgDonePasswordDlgNT = (WORD)RegisterWindowMessage( NETDDEMSG_PASSDLGDONE );
    }
    switch ( message ) {
    case WM_INITDIALOG:
        lpDlgPnt = ( struct DlgParam far * ) lParam;
        SetDlgItemText ( hDlg, IDC_DDESHARE, lpDlgPnt->glpszShareName );
        SetDlgItemText ( hDlg, IDC_SERVERNODE, lpDlgPnt->glpszComputer );
        SetDlgItemText ( hDlg, IDC_USER_NAME, lpDlgPnt->glpszUserName );
        SendDlgItemMessage ( hDlg, IDC_USER_NAME, EM_LIMITTEXT,
            MAX_USERNAMEP, 0L );
        SendDlgItemMessage ( hDlg, IDC_PASSWORD, EM_LIMITTEXT,
            MAX_PASSWORD, 0L );
        SendDlgItemMessage ( hDlg, IDC_USER_NAME, EM_SETSEL,
            0, 32767L );
        if( lpDlgPnt->glpszUserName[0] )  {
            SetFocus( GetDlgItem( hDlg, IDC_PASSWORD ) );
        } else {
            SetFocus( GetDlgItem( hDlg, IDC_USER_NAME ) );
        }
        if( lpDlgPnt->gfMoreConvs )  {
            PostMessage( hDlg, WM_COMMAND, IDC_MORE_CONVS, 0L );
        }
        if( lpDlgPnt->gfLastOneFailed )  {
            PostMessage( hDlg, WM_COMMAND, IDC_FAILED_PASSWORD_MSGBOX, 0L );
        }
        hOldCursor = SetCursor(LoadCursor(hInst, IDC_ARROW));
        ShowWindow( GetDlgItem( hDlg, IDC_CANCEL_ALL ), SW_HIDE );
        return( FALSE );
        break;
    case WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case IDC_FAILED_PASSWORD_MSGBOX:
            MBRes( hDlg, INVALID_PASSWORD, "NetDDE", MB_OK | MB_ICONSTOP );
            break;
        case IDC_MORE_CONVS:
            EnableWindow( GetDlgItem( hDlg, IDC_CANCEL_ALL ), 1 );
            ShowWindow( GetDlgItem( hDlg, IDC_CANCEL_ALL ), SW_SHOW );
            break;
        case IDOK:
            cbLen = (WORD)GetDlgItemText( hDlg, IDC_PASSWORD,
                szPassword, sizeof(szPassword) );
	    _strupr( szPassword );
            if (cbLen) {
                passDlgDone.lpszPassword = (LPSTR)szPassword;
            } else {
                passDlgDone.lpszPassword = (LPSTR)NULL;
            }
            cbLen = (WORD)GetDlgItemText( hDlg, IDC_USER_NAME,
                szDomainName, sizeof(szDomainName) );
	    _strupr( szDomainName );
            if (cbLen) {
                lpDom = strchr(szDomainName, '\\');
                if( lpDom )  {
                    passDlgDone.lpszDomainName = (LPSTR)szDomainName;
                    *lpDom++ = '\0';
                    passDlgDone.lpszUserName = (LPSTR)lpDom;
                } else {
                    strcpy( szUserName, szDomainName );
                    passDlgDone.lpszUserName = (LPSTR)szUserName;
                    szDomainName[0] = '\0';
                    passDlgDone.lpszDomainName = (LPSTR)szDomainName;
                }
            } else {
                passDlgDone.lpszDomainName = (LPSTR)NULL;
                passDlgDone.lpszUserName = (LPSTR)NULL;
            }

            passDlgDone.dwReserved = 1L;
            passDlgDone.fCancelAll = FALSE;
            SendMessage( ((HWND)-1), wMsgDonePasswordDlgNT, (WPARAM)hDlg,
                (LPARAM) (LPPASSDLGDONE)&passDlgDone );
	    SetCursor(hOldCursor);
            DestroyWindow( hDlg );
            return TRUE;
        case IDCANCEL:
            passDlgDone.dwReserved = 1L;
            passDlgDone.lpszPassword = (LPSTR)NULL;
            passDlgDone.lpszUserName = (LPSTR)NULL;
            passDlgDone.lpszDomainName = (LPSTR)NULL;
            passDlgDone.fCancelAll = FALSE;
            SendMessage( ((HWND)-1), wMsgDonePasswordDlgNT, (WPARAM)hDlg,
                (LPARAM) (LPPASSDLGDONE)&passDlgDone );
	    SetCursor(hOldCursor);
            DestroyWindow( hDlg );
            return TRUE;
        case IDC_CANCEL_ALL:
            passDlgDone.dwReserved = 1L;
            passDlgDone.lpszPassword = (LPSTR)NULL;
            passDlgDone.lpszUserName = (LPSTR)NULL;
            passDlgDone.lpszDomainName = (LPSTR)NULL;
            passDlgDone.fCancelAll = TRUE;
            SendMessage( ((HWND)-1), wMsgDonePasswordDlgNT, (WPARAM)hDlg,
                (LPARAM) (LPPASSDLGDONE)&passDlgDone );
	    SetCursor(hOldCursor);
            DestroyWindow( hDlg );
            return TRUE;
        }
    }
    return FALSE;
}

HWND
FAR PASCAL
GetAppWindow( HWND hWnd )
{
    HWND        hWndTop = hWnd;
    HMODULE     hTask;

    if (!(hTask = GetWindowTask(hWnd))) {
        return(hWnd);
    }

    for (hWndTop = GetWindow(GetDesktopWindow(), GW_CHILD);
        hWndTop && ((GetWindowTask(hWndTop) != hTask)
            || !IsWindowVisible(hWndTop));
        hWndTop = GetNextWindow(hWndTop, GW_HWNDNEXT));

    if (!hWndTop) {
        return(hWnd);
    } else {
        return(hWndTop);
    }
}

BOOL
FAR PASCAL
SetUpForPasswordPrompt( LPWININFO lpWinInfo )
{
    LPWININFO   lpDialogHead;
    LPWININFO   lpWinTail;
    LPWININFO   lpWinCur;
    LPWININFO   lpNext;
    LPWININFO   lpLast;
    BOOL        bDone;
    static char        szShareNameBuf[MAX_SHARENAMEBUF + 1];

    if (tlsDialogHead == -1) {
        tlsDialogHead = TlsAlloc();
    }
    lpDialogHead = TlsGetValue(tlsDialogHead);
    lpWinTail = (LPWININFO) NULL;
    lpWinCur = lpDialogHead;
    bDone = FALSE;
    while( !bDone && lpWinCur )  {
        if( lpWinCur->hTask == lpWinInfo->hTask )  {
            /* already a password dialog up for this task.
                Add it to the end of the list */
            bDone = TRUE;
            lpLast = lpWinCur;
            lpNext = lpWinCur->lpTaskDlgNext;
            while( lpNext )  {
                lpLast = lpNext;
                lpNext = lpNext->lpTaskDlgNext;
            }
            lpLast->lpTaskDlgNext = lpWinInfo;
            lpWinInfo->lpTaskDlgPrev = lpLast;
            lpWinInfo->lpTaskDlgNext = (LPWININFO) NULL;
            SendMessage( lpWinCur->hWndPasswordDlg, WM_COMMAND,
                IDC_MORE_CONVS, 0L );
        } else {
            lpWinTail = lpWinCur;
            lpWinCur = lpWinCur->lpDialogNext;
        }
    }

    if( !bDone )  {     // no dialog up for this task
        GetShareName(szShareNameBuf,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName );
        lpWinInfo->hWndPasswordDlg = PasswordGetFromUserModeless(
            GetAppWindow( lpWinInfo->hWndDDELocal ),
            ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName,   // Server name
            szShareNameBuf,                                 // Share name
            lpWinInfo->szUserName,                          // Current User Name
            lpWinInfo->szDomainName,                        // Current Domain Name
            lpWinInfo->dwSecurityType,                      // Security type
            lpWinInfo->nInitNACK > 2 ? TRUE : FALSE,        // fail msg?
            lpWinInfo->lpTaskDlgNext ? TRUE : FALSE );      // any more?

        if( lpWinInfo->hWndPasswordDlg )  {
            // created dialog OK
            bDone = TRUE;
            if( lpDialogHead )  {
                lpDialogHead->lpDialogPrev = lpWinInfo;
            }
            lpWinInfo->lpDialogPrev = (LPWININFO) NULL;
            lpWinInfo->lpDialogNext = lpDialogHead;
            lpDialogHead = lpWinInfo;
            TlsSetValue(tlsDialogHead, lpDialogHead);
        } else {
            /*  Could not create password dialog box: %1    */
            NDDELogError(MSG062,
                LogString("%d", GetLastError()), NULL);
        }
    }
    return( bDone );
}


BOOL
FAR PASCAL
ProcessPasswordDlgMessages( LPMSG lpMsg )
{
    LPWININFO   lpWinInfo;
    BOOL        bProcessed = FALSE;

    lpWinInfo = TlsGetValue(tlsDialogHead);
    while( !bProcessed && lpWinInfo )  {
        bProcessed = IsDialogMessage( lpWinInfo->hWndPasswordDlg, lpMsg );
        lpWinInfo = lpWinInfo->lpDialogNext;
    }
    return( bProcessed );
}

BOOL
FAR PASCAL
PasswordDlgDone(
    HWND    hWndPasswordDlg,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    LPSTR   lpszPassword,
    DWORD   fCancelAll
    )
{
    LPWININFO   lpWinInfo;
    LPWININFO   lpOther;
    LPWININFO   lpOtherNext;
    LPWININFO   lpPrev;
    LPWININFO   lpNext;
    BOOL        bProcessed = FALSE;

    lpWinInfo = TlsGetValue(tlsDialogHead);
    lpPrev = (LPWININFO) NULL;
    while( !bProcessed && lpWinInfo )  {
        lpNext = lpWinInfo->lpDialogNext;
        if( hWndPasswordDlg == lpWinInfo->hWndPasswordDlg )  {
            bProcessed = TRUE;
            lpWinInfo->hWndPasswordDlg = 0;
            EnableWindow( GetAppWindow( lpWinInfo->hWndDDELocal ), 1 );

            if( lpWinInfo->lpTaskDlgNext )  {
                if( fCancelAll )  {
                    lpOther = (LPWININFO) lpWinInfo->lpTaskDlgNext;
                    while( lpOther )  {
                        lpOtherNext = (LPWININFO) lpOther->lpTaskDlgNext;
                        IpcAbortConversation( (HIPC)lpOther->hWndDDE );
                        lpOther->lpTaskDlgPrev = NULL;
                        lpOther->lpTaskDlgNext = NULL;
                        lpOther = lpOtherNext;
                    }
                } else {
                    // set up next one for this task
                    PostMessage(
                        ((LPWININFO)lpWinInfo->lpTaskDlgNext)->hWndDDE,
                        WM_HANDLE_DDE_INITIATE, 0, 0L );
                    ((LPWININFO)lpWinInfo->lpTaskDlgNext)->lpTaskDlgPrev =
                        NULL;
                    lpWinInfo->lpTaskDlgNext = NULL;
                }
            }

            // delete from the list
            if( lpPrev )  {
                lpPrev->lpDialogNext = lpNext;
            } else {
                TlsSetValue(tlsDialogHead, lpNext);
            }
            if( lpNext )  {
                lpNext->lpDialogPrev = lpPrev;
            }

            // if the user entered a password, send the initiate pkt
            //  otherwise, abort the conversation
            if (lpszUserName) {
                lstrcpy(lpWinInfo->szUserName, lpszUserName);
            } else {
                lstrcpy(lpWinInfo->szUserName, "");
            }
            if (lpszDomainName) {
                lstrcpy(lpWinInfo->szDomainName, lpszDomainName);
            } else {
                lstrcpy(lpWinInfo->szDomainName, "");
            }
            if( lpszPassword )  {
                lstrcpy(lpWinInfo->szPassword, lpszPassword);
                SendMessage( lpWinInfo->hWndDDE, WM_HANDLE_DDE_INITIATE_PKT,
                    (WORD) lstrlen(lpszPassword), (LPARAM) lpWinInfo->szPassword );
            } else if( lpszUserName )  {
                lstrcpy(lpWinInfo->szPassword, "");
                SendMessage( lpWinInfo->hWndDDE, WM_HANDLE_DDE_INITIATE_PKT,
                    0, 0L );
            } else {
                IpcAbortConversation( (HIPC)lpWinInfo->hWndDDE );
	    }
        }
        lpPrev = lpWinInfo;
        lpWinInfo = lpNext;
    }
    return( bProcessed );
}

VOID
FAR PASCAL
PasswordAgentDying( void )
{
    LPWININFO   lpWinInfo;

    lpWinInfo = TlsGetValue(tlsDialogHead);
    while( lpWinInfo )  {
        if( lpWinInfo->hWndPasswordDlg )  {
            PostMessage( lpWinInfo->hWndPasswordDlg, WM_COMMAND,
                IDC_CANCEL_ALL, 0L );
        }
        lpWinInfo = lpWinInfo->lpDialogNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\uservald.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "USERVALD.C;1  16-Dec-92,10:18:06  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "api1632.h"
#include    <string.h>
#include    <stdlib.h>
#include    <windows.h>
#include    <hardware.h>
#include    <dde.h>
#include    "nddeapi.h"
#include    "nddesec.h"
#include    "winmsg.h"
#include    "sectype.h"
#include    "tmpbufc.h"
#include    "debug.h"
#include    "hexdump.h"
#include    "uservald.h"
#include    "hndltokn.h"
#include    "nddemsg.h"
#include    "nddelog.h"

#define USE_IMP

#if DBG
extern  BOOL    bDebugInfo;
#endif

BOOL
_stdcall
NDDEGetChallengeResponse(
    LUID    LogonId,
    LPSTR   lpszPasswordK1,
    int     cbPasswordK1,
    LPSTR   lpszChallenge,
    int     cbChallenge,
    DWORD  *pcbPasswordK1,
    BOOL   *pbHasPasswordK1 );

GENERIC_MAPPING ShareObjectGm = {NDDE_SHARE_GENERIC_READ,
                 NDDE_SHARE_GENERIC_WRITE,
                 NDDE_SHARE_GENERIC_EXECUTE,
                 NDDE_SHARE_GENERIC_ALL};

#ifndef USE_IMP
BOOL
SubversiveImpersonateClient( HWND hwnd )
{
    HANDLE      hThread;
    HANDLE      hProcess;
    HANDLE      hToken;
    BOOL        ok = TRUE;

    hThread = (HANDLE) GetWindowThreadProcessId( hwnd, (LPDWORD)&hProcess );

    if( !(ok = OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY | TOKEN_IMPERSONATE,
                          TRUE,
                          &hToken )) ) {

        if( GetLastError() == ERROR_NO_TOKEN ) {
            ok = OpenProcessToken( GetCurrentProcess(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                &hToken );
        }
    }
    if( ok )  {
        ForceImpersonate( hToken );
    }
    return( ok );
}

VOID
SubversiveRevert( void )
{
    ForceClearImpersonation();
}
#endif // !USE_IMP


BOOL
GetTokenHandle( PHANDLE pTokenHandle )
{
    DWORD   last_error;
    BOOL    ok;

    if( !(ok = OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY | TOKEN_IMPERSONATE,
                          TRUE,
                          pTokenHandle )) ) {

        if( (last_error = GetLastError()) == ERROR_NO_TOKEN ) {
            if( !(ok = OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_QUERY | TOKEN_IMPERSONATE,
                                   pTokenHandle )) ) {
                last_error = GetLastError();
            }
        }
    }
    if (!ok) {
        /*  Unable to open current thread or process token: %1  */
        NDDELogError(MSG064, LogString("%d", last_error), NULL);
    }
    return( ok );
}

BOOL
WINAPI
GetCurrentUserDomainName(
    HWND        hwnd,
    LPSTR       lpUserName,
    DWORD       dwUserNameBufSize,
    LPSTR       lpDomainName,
    DWORD       dwDomainNameBufSize)
{
    HANDLE          hThreadToken    = NULL;
    HANDLE          hMemory         = 0;
    TOKEN_USER    * pUserToken      = NULL;
    DWORD           UserTokenLen;
    PSID            pUserSID;
    SID_NAME_USE    UserSIDType;
    BOOL            ok;
    char            pComputerName[] = "";

    if (ok = GetTokenHandle( &hThreadToken )) {
        ok = GetTokenInformation(hThreadToken, TokenUser,
            pUserToken, 0, &UserTokenLen);
        if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            hMemory = LocalAlloc(LPTR, UserTokenLen);
            if (hMemory) {
                pUserToken = (TOKEN_USER *)LocalLock(hMemory);
                ok = GetTokenInformation(hThreadToken, TokenUser,
                    pUserToken, UserTokenLen, &UserTokenLen);
            } else {
                MEMERROR();
            }
        }
        if (ok) {
            pUserSID = pUserToken->User.Sid;
            ok = LookupAccountSid(pComputerName,
                pUserSID,
                lpUserName,
                &dwUserNameBufSize,
                lpDomainName,
                &dwDomainNameBufSize,
                &UserSIDType);
            if (ok) {
                DIPRINTF(("Current User: %s, Domain: %s", lpUserName, lpDomainName));
            } else {
                /*  Unable to get user account info from open token: %1 */
                DWORD dwErr = GetLastError();

                DPRINTF(("LookupAccountSid failed, error = %s\n", LogString("%d", dwErr)));
                NDDELogError(MSG065, LogString("%d", dwErr), NULL);
            }
        } else {
            /*  Unable to get user token info: %1   */
            NDDELogError(MSG066, LogString("%d", GetLastError()), NULL);
        }
    }

    if (!ok) {
        lstrcpy(lpUserName, "");
        lstrcpy(lpDomainName, "");
    }
    if (hMemory) {
        LocalUnlock(hMemory);
        LocalFree(hMemory);
    }
    if (hThreadToken) {
        CloseHandle(hThreadToken);  // clean up our mess.
    }
    return(ok);
}

BOOL    DumpSid( LPTSTR szDumperName, PSID pSid );

/*------------------------------------------------------------------------
    Determinate Access given Client Token, Security Descriptor
    ----------------------------------------------------------------------*/
BOOL
DetermineAccess(
    LPSTR                   lpszDdeShareName,
    PSECURITY_DESCRIPTOR    pSD,
    LPDWORD                 lpdwGrantedAccess,
    LPVOID                  lpvHandleIdAudit,
    LPBOOL                  lpfGenerateOnClose)
{
    BOOL            OK;
    BOOL            fStatus;
    LONG            lErr;

    OK = IsValidSecurityDescriptor(pSD);
    if (!OK) {
#if DBG
        DPRINTF(("A bogus SD passed to DetermineAccess(): %d", GetLastError()));
        HEXDUMP(pSD, GetSecurityDescriptorLength(pSD));
#endif
        return(FALSE);
    }
    OK = AccessCheckAndAuditAlarm(
            NDDE_AUDIT_SUBSYSTEM,
            lpvHandleIdAudit,
            NDDE_AUDIT_OBJECT_TYPE,
            lpszDdeShareName,
            pSD,
            MAXIMUM_ALLOWED,
            &ShareObjectGm,
            FALSE,      // not creating the object
            lpdwGrantedAccess,
            &fStatus,
            lpfGenerateOnClose );
    if (OK) {
        return OK && fStatus;
    } else {
#if DBG
        if (bDebugInfo) {
            lErr = GetLastError();
            DumpWhoIAm( "For AccessCheckAndAuditAlarm" );
            DPRINTF(( "AccessCheckAndAuditAlarm OK:%d, fStatus: %d, dGA:%0X, LE: %d",
                OK, fStatus, *lpdwGrantedAccess, lErr));
            HEXDUMP(pSD, GetSecurityDescriptorLength(pSD));
        }
#endif
        return(FALSE);
    }
}


BOOL
GetUserDomain(
    HWND    hWndDdePartner,
    HWND    hWndDdeOurs,
    LPSTR   lpszUserName,
    int     cbUserName,
    LPSTR   lpszDomainName,
    int     cbDomainName )
{
    BOOL    ok = TRUE;

#ifdef USE_IMP
    ok = ImpersonateDdeClientWindow( hWndDdePartner, hWndDdeOurs );
#else
    ok = SubversiveImpersonateClient( hWndDdePartner );
#endif
    if (ok) {
        ok = GetCurrentUserDomainName( hWndDdeOurs, lpszUserName, cbUserName,
            lpszDomainName, cbDomainName );
#ifdef USE_IMP
        RevertToSelf();
#else
        SubversiveRevert();
#endif
    } else {
        /*  Unable to impersonate DDE client: %1    */
        NDDELogError(MSG068, LogString("%d", GetLastError()), NULL);
    }
    return( ok );
}

BOOL
GetUserDomainPassword(
    HWND    hWndDdePartner,
    HWND    hWndDdeOurs,
    LPSTR   lpszUserName,
    int     cbUserName,
    LPSTR   lpszDomainName,
    int     cbDomainName,
    LPSTR   lpszPasswordK1,
    DWORD   cbPasswordK1,
    LPSTR   lpszChallenge,
    int     cbChallenge,
    DWORD  *pcbPasswordK1,
    BOOL   *pbHasPasswordK1 )
{
    BOOL                ok = TRUE;
    TOKEN_STATISTICS    * pTokenStatistics = NULL;
    DWORD               TokenStatisticsLen;
    HANDLE              hMemory = 0;
    HANDLE              hThreadToken    = NULL;
    BOOL                bImpersonated   = FALSE;

    *pbHasPasswordK1 = FALSE;
#ifdef USE_IMP
    ok = ImpersonateDdeClientWindow( hWndDdePartner, hWndDdeOurs );
#else
    ok = SubversiveImpersonateClient( hWndDdePartner );
#endif
    if (ok) {
        bImpersonated = TRUE;
        ok = GetCurrentUserDomainName( hWndDdeOurs, lpszUserName, cbUserName,
            lpszDomainName, cbDomainName );
    }
    if( ok )  {
        ok = GetTokenHandle( &hThreadToken );
    }
    if( ok )  {
        ok = GetTokenInformation( hThreadToken, TokenStatistics,
            pTokenStatistics, 0, &TokenStatisticsLen);
        if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            hMemory = LocalAlloc(LPTR, TokenStatisticsLen);
            if (hMemory) {
                pTokenStatistics = (TOKEN_STATISTICS *)LocalLock(hMemory);
                ok = GetTokenInformation( hThreadToken, TokenStatistics,
                    pTokenStatistics, TokenStatisticsLen,
                    &TokenStatisticsLen);
            } else {
                MEMERROR();
            }
        }
        if( ok )  {
#ifdef USE_IMP
            RevertToSelf();
#else
            SubversiveRevert();
#endif
            bImpersonated = FALSE;
            ok = NDDEGetChallengeResponse(
                pTokenStatistics->AuthenticationId,
                lpszPasswordK1,
                cbPasswordK1,
                lpszChallenge,
                cbChallenge,
                pcbPasswordK1,
                pbHasPasswordK1 );
        }
        ok = TRUE; // have user and domain ... *pbHasPasswordK1 contains
                        // whether we have response or not
    } else {
        /*  Unable to impersonate DDE client: %1    */
        NDDELogError(MSG068, LogString("%d", GetLastError()), NULL);
    }
    if( bImpersonated )  {
#ifdef USE_IMP
        RevertToSelf();
#else
        SubversiveRevert();
#endif
        bImpersonated = FALSE;
    }
    if (hThreadToken) {
        CloseHandle(hThreadToken);      // clean up our mess
    }
    if (hMemory) {
        LocalUnlock(hMemory);
        LocalFree(hMemory);
    }
    return( ok );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\uservald.h ===
#ifndef H__uservald
#define H__uservald

BOOL
GetUserDomain(
    HWND	hWndDdePartner,
    HWND	hWndDdeOurs,
    LPSTR	lpszUserName,
    int		cbUserName,
    LPSTR	lpszDomainName,
    int		cbDomainName );

BOOL
GetUserDomainPassword(
    HWND	hWndDdePartner,
    HWND	hWndDdeOurs,
    LPSTR	lpszUserName,
    int		cbUserName,
    LPSTR	lpszDomainName,
    int		cbDomainName,
    LPSTR	lpszPasswordK1,
    DWORD	cbPasswordK1,
    LPSTR	lpszChallenge,
    int		cbChallenge,
    DWORD	*pcbPasswordK1,
    BOOL	*pbHasPasswordK1 );

BOOL
DetermineAccess(
        LPSTR                   lpszDdeShareName,
        PSECURITY_DESCRIPTOR    pSD,
        LPDWORD                 lpdwGrantedAccess,
        LPVOID                  lpvHandleIdAudit,
        LPBOOL                  lpfGenerateOnClose );

#define NDDE_AUDIT_SUBSYSTEM    TEXT("NetDDE Object")
#define NDDE_AUDIT_OBJECT_TYPE  TEXT("DDE Share")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\wininfo.h ===
#ifndef H__WIN_INFO
#define H__WIN_INFO

#include "nddeapip.h"

/*      Window States */
#define WST_WAIT_INIT_ACK       0x1
#define WST_OK                  0x2
#define WST_TERMINATED          0x3
#define WST_WAIT_NET_INIT_ACK   0x4
#define WST_TERMINATION_COMPLETE 0x5


#define WNDEXTRA                sizeof(void far *)       // sizeof void far *

#define MAX_INIT_NACK           32767       // number of init NACKs retried

typedef struct {
    unsigned    bClientSideOfNet        : 1;
    unsigned    bServerSideOfNet        : 1;
    unsigned    bOnWindowList           : 1;
    unsigned    bOnTermWindowList       : 1;
    unsigned    bSentTerminateNet       : 1;
    unsigned    bRcvdTerminateNet       : 1;
    unsigned    bSentTerminateLocally   : 1;
    unsigned    bRcvdTerminateLocally   : 1;
    unsigned    bInitiating             : 1;
    unsigned    bWin16Connection        : 1;
    int         nExtraInitiateAcks;
    HANDLE      hMemWaitInitQueue;              // queue of messages while
                                                //  waiting for INIT_ACK over
                                                //  network
    HWND        hWndDDE;
    HWND        hWndDDELocal;
    HMODULE     hTask;
    HWND        hWndPasswordDlg;
    LPVOID      lpDialogPrev;
    LPVOID      lpDialogNext;
    LPVOID      lpTaskDlgPrev;
    LPVOID      lpTaskDlgNext;
    HDDER       hDder;
    WORD        nInitNACK;                      // number of Init Nacks rcvd
    WORD        wState;                         // current window state
    HWND        hWndPrev;
    HWND        hWndNext;
    DWORD       dwSent;
    DWORD       dwRcvd;
    HDDEQ       qDDEIncomingCmd;
    HDDEQ       qDDEOutgoingCmd;
    LPDDEPKT    lpDdePktTerminate;
    WORD        offsNodeName;
    WORD        offsAppName;
    WORD        offsTopicName;
    WORD        offsClientName;
    WORD        connectFlags;        // add clausgi 7-21
    BOOL        dwWaitingServiceInitiate;
    char        szUserName[MAX_USERNAMEP + 1];
    char        szDomainName[MAX_DOMAINNAMEP + 1];
    char        szPassword[MAX_PASSWORD + 1];
    QOS         qosClient;
    DWORD       dwSecurityType;
    DWORD       sizeSecurityKeyRcvd;
    LPBYTE      lpSecurityKeyRcvd;
    DWORD       hSecurityKeyRcvd;
    BOOL        fCallObjectCloseAuditAlarm;
    BOOL        fGenerateAuditOnClose;
    HANDLE      hAudit;
    char        data[1];
} WININFO;
typedef WININFO FAR *LPWININFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\chksum32.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CHKSUM32.C;1  16-Dec-92,10:20:06  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1989-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#define NOMINMAX
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NONCMESSAGES
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NOCOLOR
#define NOCREATESTRUCT
#define NOFONT
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER

#define NOKEYBOARDINFO
#define NOLANGUAGE
#define NOLFILEIO
#define NOMDI

#define NOANSI
#define NOSTRECTCHBLT
#define NOESCAPES
#define NOPALETTE
#define NORCCODES
#include "windows.h"
#include "debug.h"
#include "host.h"

VOID		FAR PASCAL Checksum32( DWORD FAR *lpChksum,
			    BYTE FAR *lpData, WORD wLength );

VOID
FAR PASCAL
Checksum32( DWORD FAR *lpChksum, BYTE FAR *lpData, WORD wLength )
{
    register DWORD	dwSum;
    register WORD	wTodo = wLength;
    register BYTE FAR  *lpInfo = lpData;
    
    dwSum = 0xFFFFFFFFL;

    while( wTodo > 4 )  {
	dwSum   += HostToPcLong( *((DWORD FAR *)lpInfo) );
	lpInfo  += 4;
	wTodo -= 4;
    }
    while( wTodo > 0 )  {
	dwSum += *((BYTE FAR *)lpInfo);
	lpInfo++;
	wTodo--;
    }
    
    *lpChksum = dwSum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\connects.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CONNECTS.C;1  16-Dec-92,10:20:12  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>

#include    "host.h"
#include    "windows.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "security.h"
#include    "debug.h"
#include    "csv.h"
#include    "api1632.h"
#include    "proflspt.h"

extern char szNetddeIni[];

/*
    Global variables
*/
extern BOOL     bDefaultConnDisconnect;
extern int      nDefaultConnDisconnectTime;


BOOL
GetConnectionInfo(
    LPSTR       lpszNodeName,
    LPSTR       lpszNetIntf,
    LPSTR       lpszConnInfo,
    int         nMaxConnInfo,
    BOOL FAR   *pbDisconnect,
    int FAR    *pnDelay )
{
    BOOL        found = FALSE;
    char        line[256];
    int         len;
    PSTR        tokenNetIntf;
    PSTR        tokenConnInfo;
    PSTR        tokenDisconnect;
    PSTR        tokenDelay;

    /* defaults */
    *pbDisconnect = bDefaultConnDisconnect;
    *pnDelay = nDefaultConnDisconnectTime;
    *lpszNetIntf = '\0';
    *lpszConnInfo = '\0';
    lstrcpyn( lpszConnInfo, lpszNodeName, nMaxConnInfo );

    len = MyGetPrivateProfileString("ConnectionNames", lpszNodeName, "",
        (LPSTR) line, sizeof(line), szNetddeIni );
    if( len == 0 )  {
        return( FALSE );
    }

    tokenNetIntf = CsvToken( line );
    tokenConnInfo = CsvToken( NULL );
    tokenDisconnect = CsvToken( NULL );
    tokenDelay = CsvToken( NULL );
    found = TRUE;

    lstrcpyn( lpszNetIntf, tokenNetIntf, MAX_NI_NAME );

    /* only copy connInfo if some there to copy, otherwise
                        let the default stand     */
    if( tokenConnInfo && (tokenConnInfo[0] != '\0'))  {
        lstrcpyn( lpszConnInfo, tokenConnInfo, nMaxConnInfo );
    }

    *pbDisconnect = TokenBool( tokenDisconnect, bDefaultConnDisconnect );
    if( tokenDelay )  {
        *pnDelay = max( 1, atoi( tokenDelay ) );
    }

    return( found );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\nsetup\nsetup.c ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
* Copyright (c) Microsoft Corp. 1993  All Rights Reserved               *
*                                                                       *
* Module: NSETUP.C                                                      *
*                                                                       *
* Utility to setup the registry to support the standard NetDDE config.  *
*                                                                       *
* History:                                                              *
*                                                                       *
* 10/3/93   SanfordS    Moved code used by NT setup to a common library.*
*                                                                       *
*************************************************************************/

#include    <windows.h>
#include    "shrtrust.h"
#include    "nscommn.h"

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    INT       nCmdShow)
{
    if (CreateShareDBInstance()) {
        CreateDefaultTrust(HKEY_CURRENT_USER);
    }
    return (0);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\ntddecmn.c ===
#include "windows.h"

int
WinMain( HINSTANCE x, HINSTANCE y, LPSTR z, int a )
{
return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\netdde\ddeintf.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DDEINTF.C;3  22-Mar-93,10:50:44  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

//#define DEBUG_PASSWORD

/*
    TODO:
        - handling out of memory or atom alloc fail or DDE protocol violations
            by terminating conversation with special abort_conversation
            packet
        - if WaitInitAddMsg() fails, handle appropriately ... terminate
            conversation
 */
/*
        U N A D V I S E  --->

            Client                      Server

Atom:           nothing                 add

Memory:         N/A                     N/A

Queue:          Add to outgoing         Add to incoming


        E X E C U T E  --->

            Client                      Server

Atom:           N/A                     N/A

Memory:         nothing                 create

Queue:          Add to outgoing         Add to incoming

        P O K E  --->

            Client                      Server

Atom:           nothing                 adMemory:         nothing                 create

Queue:          Add to outgoing         Add to incoming

        A D V I S E  --->

            Client                      Server

Atom:           nothing                 add

Memory:         nothing                 create

Queue:          Add to outgoing         Add to incoming

        R E Q U E S T  --->

            Client                      Server

Atom:           nothing                 add

Memory:         N/A                     N/A

Queue:          Add to outgoing         Add to incoming









        A C K  --->

            Client                              Server

Atom:           delete                          add/del

Memory:         if !fRelease or NACK_MSG        if fRelease and ACK_MSG
                 Free it                            Free it

Queue:          Sub from incoming - must        Sub from outgoing - must
                    be WM_DDE_DATA                  be WM_DDE_DATA

        <--- D A T A

            Client                              Server

Atom:       - add                               if !fAckReq delete
            - if fResponse delete

Memory:     create if non-NULL                  if fAckReq - nothing
                                                else if fRelease - free

                                                if !fAckReq && !fRelease
                                                    ERROR

Queue:      if fResponse                        if fResponse
                sub from outgoing                   sub from incoming

            if fAckReq                          if fAckReq
                add to incoming                     add to outgoing


        <--- A C K

            Client                              Server

Atom:       if cmd was REQUEST, POKE,           if cmd was REQUEST, POKE,
                ADVISE or UNADVISE:                 ADVISE or UNADVISE:
                    add/del                             delete

Memory:     if cmd was                          if cmd was
                EXECUTE:  nothing                   EXECUTE:  free
                UNADVISE: N/A                       UNADVISE: N/A
                ADVISE:   if ACK_MSG - free         ADVISE:   ACK_MSG: nothing
                          if NACK_MSG - nothing               NACK_MSG: free
                REQUEST:  N/A                       REQUEST:  N/A
                POKE:     if fRelease & ACK_MSG     POKE:if fRelease & ACK_MSG
                            free                                nothing
                          else                           else
                            nothing                             free

Queue:          sub from outgoing               sub from incoming
 */



#define LINT_ARGS
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    "tmpbuf.h"
#define NOMINMAX
#include    <ctype.h>
#include    <memory.h>

#include    "host.h"

#include    <windows.h>
#include    <hardware.h>
#include    <dde.h>
#include    "dde1.h"
#include    "shellapi.h"
#include    "debug.h"
#include    "netbasic.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "ddeq.h"
#include    "dder.h"
#include    "ipc.h"
#include    "spt.h"
#include    "ddeintf.h"
#include    "dbgdde.h"
#include    "wwassert.h"
#include    "hmemcpy.h"
#include    "userdde.h"
#include    "wwdde.h"
#include    "internal.h"
#include    "scrnupdt.h"
#include    "hexdump.h"
#include    "nddeapi.h"
#include    "nddeapis.h"
#include    "winmsg.h"
#include    "seckey.h"
#include    "shrtrust.h"
#include    "uservald.h"
#include    "wininfo.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "hndltokn.h"
#include    "netddesh.h"
#include    "critsec.h"
#include    "wwassert.h"

BOOL WINAPI DdeGetQualityOfService(HWND hwndClient, HWND hwndServer, PSECURITY_QUALITY_OF_SERVICE pqos);

USES_ASSERT

/*  extracted from ndeapi.h because of MIDL's crappy defines */

unsigned long wwNDdeGetShareSecurityA(
    unsigned char *lpszShareName,
    unsigned long si,
    byte *psd,
    unsigned long cbsd,
    unsigned long bRemoteCall,
    unsigned long *lpcbsdRequired,
    unsigned long *lpnSizeToReturn);

unsigned long wwNDdeShareGetInfoA(
    unsigned char *lpszShareName,
    unsigned long nLevel,
    byte *lpBuffer,
    unsigned long cBufSize,
    unsigned long *lpnTotalAvailable,
    unsigned short *lpnItems,
    unsigned long *lpnSizeToReturn,
    unsigned long *lpnSnOffset,
    unsigned long *lpnAtOffset,
    unsigned long *lpnItOffset);

/************** remove above after MIDL fixed **************/



BOOL WINAPI ImpersonateDdeClientWindow(HWND hWndClient,HWND hWndServer);

BOOL MapShareInformation(WORD dd_type, LPSTR lpAppName, LPSTR lpTopicName, LPSTR lpRsltAppName,
        LPSTR lpRsltTopicName, LPSTR lpszCmdLine, PNDDESHAREINFO *lplpShareInfo, LONG *lplActualShareType);
LRESULT RequestExec(HANDLE hWndDDE, LPSTR lpszCmdLine, PNDDESHAREINFO lpShareInfo);
LRESULT RequestInit(HANDLE hWndDDE, PNDDESHAREINFO lpShareInfo);


#define IDC_MORE_CONVS          110

#define WIQ_INCR        100
typedef struct {
    UINT        message;
    LPARAM      lParam;
} WIMSG;
typedef WIMSG FAR *LPWIMSG;

typedef struct {
    int         wi_nMessagesQueued;
    int         wi_nMessagesLeft;
    WIMSG       wi_msg[1];
} MSGQHDR;
typedef MSGQHDR FAR *LPMSGQHDR;

extern LPSTR    lpszServer;
extern char     szInitiatingNode[ ];
extern char     szInitiatingApp[ ];
extern WORD     wMsgInitiateAckBack;
extern BOOL     bNetddeClosed;
extern DWORD    dwReasonInitFail;
extern BOOL     bLogExecFailures;
extern BOOL     bDefaultStartApp;

#if  DBG
extern  BOOL    bDebugInfo;
extern  BOOL    bDebugDdePkts;
extern  BOOL    bDumpTokens;
#endif // DBG

/*
    External Routines
*/
#if  DBG
VOID    FAR PASCAL  DebugDderState( void );
VOID    FAR PASCAL  DebugRouterState( void );
VOID    FAR PASCAL  DebugPktzState( void );
#endif // DBG

VOID    FAR PASCAL  DderUpdatePermissions( HDDER, PNDDESHAREINFO, DWORD);
BOOL                GetShareName( LPSTR, LPSTR, LPSTR);
BOOL                IsShare(LPSTR);
BOOL                GetShareAppTopic( DWORD, PNDDESHAREINFO, LPSTR, LPSTR);
BOOL                GetShareAppName( DWORD, PNDDESHAREINFO, LPSTR);
BOOL                GetShareTopicName( DWORD, PNDDESHAREINFO, LPSTR);
WORD                ExtractFlags(LPSTR lpApp);


#ifdef  DEBUG_PASSWORD
extern LPBYTE WINAPI
DdeDeKrypt2(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPasswordK1,           // password output in first phase
        DWORD   cPasswordK1Size,        // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key
        DWORD   cKey,                   // size of key
        LPDWORD lpcbPasswordK2Size      // get size of resulting enkrypted stream
);
#endif // DEBUG_PASSWORD

extern LPBYTE WINAPI
DdeEnkrypt2(                            // pointer to enkrypted byte stream returned
        LPBYTE  lpPasswordK1,           // password output in first phase
        DWORD   cPasswordK1Size,        // size of password to be enkrypted
        LPBYTE  lpKey,                  // pointer to key
        DWORD   cKey,                   // size of key
        LPDWORD lpcbPasswordK2Size      // get size of resulting enkrypted stream
);

/*
    External variables used
 */
extern HANDLE   hInst;
extern WORD     wClipFmtInTouchDDE;
extern HCURSOR  hDDEInitCursor;
extern char     ourNodeName[];
extern WORD     cfPrinterPicture;
extern DWORD    dwReasonInitFail;

/*
    Local variables
 */
#if  DBG
BOOL                bDebugDDE;
VOID    FAR PASCAL  debug_srv_client(HWND hWndDDE, LPWININFO lpWinInfo);
VOID    FAR PASCAL  DebugDdeIntfState( void );
#endif // DBG

unsigned long   nW, nX, nY, nZ;

BOOL            bClosingAllConversations;
BOOL            bDebugYield;
HWND            hWndDDEHead;            // Protect by CritSec
HWND            hWndDDEHeadTerminating; // Protect by CritSec
int             nInitsWaiting;          // Protect by CritSec
char            szNetDDEIntf[]  =       "NetDDEIntf";
UINT            uAgntExecRtn;
HHEAP           hHeap;


/*
    External Functions for conversions
*/
extern BOOL    FAR PASCAL  ConvertDataToPktMetafile( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex, BOOL bWin16Con );
extern HANDLE  FAR PASCAL  ConvertPktToDataMetafile( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData, BOOL bWin16Con );
extern BOOL    FAR PASCAL  ConvertDataToPktBitmap( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex, BOOL bWin16Con );
extern HANDLE  FAR PASCAL  ConvertPktToDataBitmap( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData, BOOL bWin16Con );
extern BOOL    FAR PASCAL  ConvertDataToPktEnhMetafile( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex);
extern HANDLE  FAR PASCAL  ConvertPktToDataEnhMetafile( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData );
extern BOOL    FAR PASCAL  ConvertDataToPktPalette( LPSTR *plpDataPortion,
                            DWORD *pdwSize, HANDLE *phDataComplex);
extern HANDLE  FAR PASCAL  ConvertPktToDataPalette( LPDDEPKT lpDdePkt,
                            LPDDEPKTDATA lpDdePktData );
extern BOOL FAR PASCAL      ConvertDataToPktDIB(LPSTR   *plpDataPortion,
                            DWORD   *pdwSize, HANDLE  *phDataComplex);
extern HANDLE  FAR PASCAL   ConvertPktToDataDIB(LPDDEPKT        lpDdePkt,
                            LPDDEPKTDATA    lpDdePktData );

/*
    Local routines
 */
LPWININFO FAR PASCAL CreateWinInfo( LPSTR lpszNode, LPSTR lpszApp,
        LPSTR lpszTopic, LPSTR lpszClient, HWND hWndDDE );
LONG_PTR FAR PASCAL  DDEWddeWndProc( HWND, UINT, WPARAM, LPARAM );
BOOL    FAR PASCAL  AddAck( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddData( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddPoke( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddAdvise( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddExecute( LPWININFO, LPARAM );
BOOL    FAR PASCAL  AddRequestUnadvise( UINT, LPWININFO, LPARAM );
VOID    FAR PASCAL  DDEWndSetNext( HWND, HWND );
#ifdef DEADCODE
HWND    FAR PASCAL  DDEWndGetNext( HWND );
#endif
VOID    FAR PASCAL  DDEWndSetPrev( HWND, HWND );
VOID    FAR PASCAL  DDEWndDeleteFromList( HWND );
VOID    FAR PASCAL  DDEWndAddToList( HWND );
VOID    FAR PASCAL  DDEWndMoveToTermList( HWND );
VOID    FAR PASCAL  CheckAllTerminations( void );
BOOL    FAR PASCAL  WaitInitAddMsg( LPWININFO, unsigned, LPARAM );
VOID    FAR PASCAL  SendQueuedMessages( HWND, LPWININFO );
VOID    FAR PASCAL  DeleteQueuedMessages( LPWININFO );
ATOM    FAR PASCAL  GlobalAddAtomAndCheck( LPSTR );
VOID    FAR PASCAL  DoTerminate( LPWININFO lpWinInfo );
VOID    FAR PASCAL  ServiceInitiates( void );
int                 IpcDraw( HDC hDC, int x, int vertPos, int lineHeight );
LPBYTE              GetInitPktPassword( LPDDEPKTINIT lpDdePktInit );
LPBYTE              GetInitPktUser( LPDDEPKTINIT lpDdePktInit );
LPBYTE              GetInitPktDomain( LPDDEPKTINIT lpDdePktInit );
PQOS                GetInitPktQos( LPDDEPKTINIT lpDdePktInit, PQOS );
WORD                GetInitPktPasswordSize( LPDDEPKTINIT lpDdePktInit );
BOOL    FAR PASCAL  SetUpForPasswordPrompt( LPWININFO lpWinInfo );
void                GlobalFreehData(HANDLE  hData );

#ifdef  DUMP_ON
VOID
DumpToken( HANDLE hToken );
#endif // DUMP_ON

BOOL
_stdcall
NDDEValidateLogon(
    LPBYTE  lpChallenge,
    UINT    cbChallengeSize,
    LPBYTE  lpResponse,
    UINT    cbResponseSize,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    PHANDLE phLogonToken
    );





BOOL
FAR PASCAL
DDEIntfInit( void )
{
    WNDCLASS    wddeClass;

    wddeClass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wddeClass.hIcon          = (HICON)NULL;
    wddeClass.lpszMenuName   = (LPSTR)NULL;
    wddeClass.lpszClassName  = szNetDDEIntf;
    wddeClass.hbrBackground  = (HBRUSH)NULL;
    wddeClass.hInstance      = hInst;
    wddeClass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    wddeClass.lpfnWndProc    = DDEWddeWndProc;
    wddeClass.cbClsExtra     = 0;
    wddeClass.cbWndExtra     = WNDEXTRA;

    if (!RegisterClass((LPWNDCLASS) &wddeClass)) {
        return FALSE;
    }

    return( TRUE );
}





LONG_PTR
FAR PASCAL
DDEWddeWndProc (
    HWND        hWnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam )
{
    LPWININFO   lpWinInfo;
    HDDER       hDder;
    UINT_PTR    aItem;
    LPDDEPKT    lpDdePkt;
    HANDLE      hData;
    DWORD       sizePassword;
    LPBYTE      lpPasswordK1;
    DWORD       sizePasswordK1;
    DWORD       hSecurityKey = 0;
    LPBYTE      lpszPasswordBuf;
    BOOL        bLocal;
    BOOL        ok = TRUE;
    BOOL        bHasPasswordK1 = FALSE;
    PTHREADDATA ptd;
    char        PasswordK1Buf[1000];

    assert( IsWindow(hWnd) );
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );

    switch (message) {

    case WM_HANDLE_DDE_INITIATE:
        /*
         * Phase 3 of WM_DDE_INITIATE processing.
         * Get QOS of our client.
         * Get User info of our client.
         * If we are having problems, ask user for password.
         *
         * Continue below at WM_HANDLE_DDE_INITIATE_PKT.
         */
        TRACEINIT((szT, "DDEWddeWndProc: WM_HANDLE_DDE_INITIATE"));
        assert( lpWinInfo );
        if (lpWinInfo->nInitNACK == 0) {
            /* get the QOS on the first initiate */
            ok = DdeGetQualityOfService( lpWinInfo->hWndDDELocal,
                lpWinInfo->hWndDDE, &lpWinInfo->qosClient);
            if (!ok) {
                /*  DdeGetQualityOfService() failed: %1 */
                NDDELogError(MSG016, LogString("%d", GetLastError()), NULL);
            } else {
                GetUserDomain(
                    lpWinInfo->hWndDDELocal, lpWinInfo->hWndDDE,
                    lpWinInfo->szUserName,             // current user name
                    sizeof(lpWinInfo->szUserName),
                    lpWinInfo->szDomainName,           // current user domain
                    sizeof(lpWinInfo->szDomainName) );
            }
        }
        if( lpWinInfo->nInitNACK > 0 )  {
            /* NACKed at least once */
            if( (lpWinInfo->nInitNACK == 1)
                    && (lpWinInfo->dwSecurityType == NT_SECURITY_TYPE) )  {
                ok = GetUserDomainPassword(
                    lpWinInfo->hWndDDELocal,
                    lpWinInfo->hWndDDE,
                    lpWinInfo->szUserName,             // current user name
                    sizeof(lpWinInfo->szUserName),
                    lpWinInfo->szDomainName,           // current user domain
                    sizeof(lpWinInfo->szDomainName),
                    PasswordK1Buf,
                    sizeof(PasswordK1Buf),
                    lpWinInfo->lpSecurityKeyRcvd,
                    lpWinInfo->sizeSecurityKeyRcvd,
                    &sizePasswordK1,
                    &bHasPasswordK1 );
                lpPasswordK1 = PasswordK1Buf;
                hSecurityKey = lpWinInfo->hSecurityKeyRcvd;
            }
            if( !bHasPasswordK1 )  {
                ptd = TlsGetValue(tlsThreadData);
                if ( !(lpWinInfo->connectFlags & DDEF_NOPASSWORDPROMPT )
                    && ptd->hwndDDEAgent )  {
                    ok = SetUpForPasswordPrompt( lpWinInfo );
                }
                if (ptd->hwndDDEAgent == 0) {
                    ok = FALSE;
                    NDDELogError(MSG078, NULL);
                }
            }
            if( !ok )  {
                IpcAbortConversation( (HIPC)lpWinInfo->hWndDDE );
            } else if( bHasPasswordK1 ) {
                // go ahead and send the packet */
            } else {
                // don't send the initiate packet
                ok = FALSE;
            }
        }

        // ok == TRUE at this point means to send the initiate packet
        // ok == FALSE means don't send the initiate packet
        if( !ok )  {
            break;
        }
        // intentional fall-through

    case WM_HANDLE_DDE_INITIATE_PKT:
        /*
         * Phase 4 of WM_DDE_INITIATE processing.
         *
         * Get password from Sec Key if not already entered.
         * Create an init pkt.
         * Have Dder send it off.
         *
         * Continue at DderInitConversation().
         */
        if (lpWinInfo->wState == WST_TERMINATED) {
            ok = FALSE;
        }
        sizePassword = (DWORD)wParam;
        lpszPasswordBuf = (LPSTR) lParam;
        if( ok && !bHasPasswordK1 )  {
            lpPasswordK1 = DdeEnkrypt2( lpszPasswordBuf, sizePassword,
                lpWinInfo->lpSecurityKeyRcvd, lpWinInfo->sizeSecurityKeyRcvd,
                &sizePasswordK1 );
            hSecurityKey = lpWinInfo->hSecurityKeyRcvd;
#if DBG
            if (bDebugInfo && lpPasswordK1 && lpszPasswordBuf) {
                DPRINTF(("Password (%ld): %Fs", sizePassword, lpszPasswordBuf));
                DPRINTF(("Enkrypted 1 Password (%ld) (%x) Sent Out:", sizePasswordK1, lpPasswordK1));
                if( lpPasswordK1 ) {
                    HEXDUMP(lpPasswordK1, (int)sizePasswordK1);
                }
            }
#endif // DBG
        }
        if (ok) {
            lpDdePkt = CreateInitiatePkt(
                ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName,
                ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName,
                ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName,
                ourNodeName,
                ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                lpWinInfo->szUserName,
                lpWinInfo->szDomainName,
                lpWinInfo->dwSecurityType,
                &lpWinInfo->qosClient,
                lpPasswordK1,
                sizePasswordK1,
                hSecurityKey);     /* first time no password */
            if( lpDdePkt == NULL )  {
                ok = FALSE;
            }
        }

        if( ok )  {
            ptd = TlsGetValue(tlsThreadData);
            lpWinInfo->bInitiating = TRUE;
            hDder = DderInitConversation( (HIPC)hWnd, 0, lpDdePkt );
            if( (lstrlen(((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName) == 0)
                || (lstrcmpi( ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName,
                    ourNodeName ) == 0) )  {
                bLocal = TRUE;
            } else {
                bLocal = FALSE;
            }
            if( hDder == 0 )  {
                HeapFreePtr( lpDdePkt );
            }
            lpDdePkt = NULL;
            lpWinInfo->bInitiating = FALSE;
            if( hDder == 0 )  {
                if( bLocal && (dwReasonInitFail == RIACK_NEED_PASSWORD) )  {
                    ok = TRUE;
                } else {
                    ok = FALSE;
                }
            }
            /* note the hDder */
            lpWinInfo->hDder = hDder;

            /* mark that we sent the initiate packet */
            lpWinInfo->dwSent++;

            if( lpWinInfo->wState == WST_OK )  {
                /* already rcvd the initiate ack */
                SendQueuedMessages( hWnd, lpWinInfo );
            }
        }

        if( !ok )  {
            IpcAbortConversation( (HIPC)hWnd );
        }
        break;

    case WM_DDE_REQUEST:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK :
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK :
                assert( lpWinInfo->hDder );
                if (!AddRequestUnadvise( message, lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED :
            default:
                GlobalDeleteAtom( HIWORD(lParam) );
                break;
            }
        } else {
            GlobalDeleteAtom( HIWORD(lParam) );
        }
        break;

    case WM_DDE_ADVISE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                assert( lpWinInfo->hDder );
                if (!AddAdvise( lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_ADVISE, lParam,
                    (PUINT_PTR)&hData, &aItem );
                FreeDDElParam( WM_DDE_ADVISE, lParam );
                if ( hData )  {
                    GlobalFree( hData );
                }
                GlobalDeleteAtom( (ATOM)aItem );
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_ADVISE, lParam,
                (PUINT_PTR)&hData, &aItem );
            FreeDDElParam( WM_DDE_ADVISE, lParam );
            if ( hData )  {
                GlobalFree( hData );
            }
            GlobalDeleteAtom( (ATOM)aItem );
        }
        break;

    case WM_DDE_UNADVISE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                assert( lpWinInfo->hDder );
                if (!AddRequestUnadvise( message, lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED:
            default:
                GlobalDeleteAtom( HIWORD(lParam) );
                break;
            }
        } else {
            GlobalDeleteAtom( HIWORD(lParam) );
        }
        break;

    case WM_DDE_POKE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam)  )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                assert( lpWinInfo->hDder );
                if (!AddPoke( lpWinInfo, lParam )) {
                    /*
                     * failed to add message to queue - we
                     * have no choice but to shut this down since
                     * emulating a NACK or busy would require a
                     * queue entry anyway.
                     */
                    /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                    NDDELogError(MSG416, LogString("%x", message), NULL);
                    lpWinInfo->bRcvdTerminateLocally = TRUE;
                    DoTerminate( lpWinInfo );
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_POKE, lParam,
                    (PUINT_PTR)&hData, &aItem );
                FreeDDElParam( WM_DDE_POKE, lParam );
                if ( hData )  {
                    GlobalFreehData( hData );
                }
                GlobalDeleteAtom( (ATOM)aItem );
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_POKE, lParam,
                (PUINT_PTR)&hData, &aItem );
            FreeDDElParam( WM_DDE_POKE, lParam );
            if ( hData )  {
                GlobalFreehData( hData );
            }
            GlobalDeleteAtom( (ATOM)aItem );
        }
        break;

    case WM_DDE_DATA:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam)) {
            switch (lpWinInfo->wState) {
            case WST_OK:
                if( lpWinInfo->hDder )  {
                    if (!AddData( lpWinInfo, lParam )) {
                        /*
                         * failed to add message to queue - we
                         * have no choice but to shut this down since
                         * emulating a NACK or busy would require a
                         * queue entry anyway.
                         */
                        /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                        NDDELogError(MSG416, LogString("%x", message), NULL);
                        lpWinInfo->bRcvdTerminateLocally = TRUE;
                        DoTerminate( lpWinInfo );
                    }
                } else {
                    UnpackDDElParam( WM_DDE_DATA, lParam,
                        (PUINT_PTR)&hData, &aItem );
                    FreeDDElParam( WM_DDE_DATA, lParam );
                    if ( hData )  {
                        GlobalFreehData( hData );
                    }
                    GlobalDeleteAtom( (ATOM)aItem );
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_DATA, lParam,
                    (PUINT_PTR)&hData, &aItem );
                FreeDDElParam( WM_DDE_DATA, lParam );
                if ( hData )  {
                    GlobalFreehData( hData );
                }
                GlobalDeleteAtom( (ATOM)aItem );
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_DATA, lParam,
                (PUINT_PTR)&hData, &aItem );
            FreeDDElParam( WM_DDE_DATA, lParam );
            if ( hData )  {
                GlobalFreehData( hData );
            }
            GlobalDeleteAtom( (ATOM)aItem );
        }
        break;

    case WM_DDE_ACK:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow( (HWND)wParam ) )  {
            switch( lpWinInfo->wState )  {
            case WST_WAIT_NET_INIT_ACK:
                assert( FALSE );
                break;
            case WST_WAIT_INIT_ACK:
                GlobalDeleteAtom( HIWORD(lParam) );
                GlobalDeleteAtom( LOWORD(lParam) );
                lpWinInfo->hWndDDELocal = (HWND) wParam;
                lpWinInfo->wState = WST_OK;
                UpdateScreenState();
                break;
            case WST_OK:
                EnterCrit();
                ptd = TlsGetValue(tlsThreadData);
                if( ptd->bInitiating )  {
                    LeaveCrit();
                    lpWinInfo->nExtraInitiateAcks++;
                    PostMessage( (HWND)wParam, WM_DDE_TERMINATE,
                        (UINT_PTR)hWnd, 0L );
                } else if( lpWinInfo->hDder )  {
                    LeaveCrit();
                    if (!AddAck( lpWinInfo, lParam )) {
                        /*
                         * failed to add message to queue - we
                         * have no choice but to shut this down since
                         * emulating a NACK or busy would require a
                         * queue entry anyway.
                         */
                        /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                        NDDELogError(MSG416, LogString("%x", message), NULL);
                        lpWinInfo->bRcvdTerminateLocally = TRUE;
                        DoTerminate( lpWinInfo );
                    }
                }
                break;
            case WST_TERMINATED:
                AddAck( lpWinInfo, lParam);
                break;
            default:
                /*  WM_DDE_ACK received, WinInfo in unknown state: %1 */
                NDDELogError(MSG017, LogString("%d", lpWinInfo->wState), NULL);
                FreeDDElParam( WM_DDE_ACK, lParam );
                break;
            }
        } else {
            FreeDDElParam( WM_DDE_ACK, lParam );
        }
        break;

    case WM_DDE_EXECUTE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( IsWindow((HWND)wParam) )  {
            switch (lpWinInfo->wState) {
            case WST_WAIT_NET_INIT_ACK:
                WaitInitAddMsg( lpWinInfo, message, lParam );
                break;
            case WST_OK:
                if( lpWinInfo->hDder )  {
                    if (!AddExecute( lpWinInfo, lParam )) {
                        /*
                         * failed to add message to queue - we
                         * have no choice but to shut this down since
                         * emulating a NACK or busy would require a
                         * queue entry anyway.
                         */
                        /*  Unable to add %1 to DDE msg queue. Conversation Terminiated. */
                        NDDELogError(MSG416, LogString("%x", message), NULL);
                        lpWinInfo->bRcvdTerminateLocally = TRUE;
                        DoTerminate( lpWinInfo );
                    }
                } else {
                    UnpackDDElParam( WM_DDE_EXECUTE, lParam,
                        &aItem, (PUINT_PTR)&hData );
                    FreeDDElParam( WM_DDE_EXECUTE, lParam );
                    if( hData )  {
                        GlobalFree( hData );
                    }
                }
                break;
            case WST_TERMINATED:
            default:
                UnpackDDElParam( WM_DDE_EXECUTE, lParam,
                    &aItem, (PUINT_PTR)&hData );
                FreeDDElParam( WM_DDE_EXECUTE, lParam );
                if( hData )  {
                    GlobalFree( hData );
                }
                break;
            }
        } else {
            UnpackDDElParam( WM_DDE_EXECUTE, lParam,
                &aItem, (PUINT_PTR)&hData );
            FreeDDElParam( WM_DDE_EXECUTE, lParam );
            if( hData )  {
                GlobalFree( hData );
            }
        }
        break;

    case WM_DDE_TERMINATE:
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "rcvd", hWnd, message, wParam, lParam );
        }
#endif // DBG
        assert( lpWinInfo );
        if( (HWND)wParam == lpWinInfo->hWndDDELocal )  {
            /* note that we rcvd a terminate from the conversation locally */
            lpWinInfo->bRcvdTerminateLocally = TRUE;

            /* do rest of terminate logic */
            DoTerminate( lpWinInfo );
        } else {
            /* multiple initiate ack problem */
            lpWinInfo->nExtraInitiateAcks--;
            if( lpWinInfo->nExtraInitiateAcks < 0 )  {
                /*  Too many terminates received or wrong window    */
                NDDELogError(MSG018,
                    LogString("  hWnd: %0X, wParam: %0X, hWnd->localWnd: %0X",
                        hWnd, wParam, lpWinInfo->hWndDDELocal ),
                    LogString("  SL: %d, RL: %d, SN: %d, RN: %d",
                        lpWinInfo->bSentTerminateLocally,
                        lpWinInfo->bRcvdTerminateLocally,
                        lpWinInfo->bSentTerminateNet,
                        lpWinInfo->bRcvdTerminateNet ), NULL);
                lpWinInfo->bRcvdTerminateLocally = TRUE;
                DoTerminate( lpWinInfo );
            }
        }
        break;

    case WM_DESTROY:
        if( !bNetddeClosed && lpWinInfo )  {
            if( lpWinInfo->hDder )  {
                DderCloseConversation( lpWinInfo->hDder,
                    (HIPC) lpWinInfo->hWndDDE );
                lpWinInfo->hDder = 0;
            }
            DDEWndDeleteFromList( hWnd );
            if( lpWinInfo->qDDEIncomingCmd )  {

                /*
                 * USER cleans up the data that was posted, so
                 * we want to flush the incoming queue before
                 * freeing it.
                 */
                //while( DDEQRemove(lpWinInfo->qDDEIncomingCmd, &DDEQEnt ))
                //    ;

                DDEQFree( lpWinInfo->qDDEIncomingCmd );
                lpWinInfo->qDDEIncomingCmd = 0;
            }
            if( lpWinInfo->qDDEOutgoingCmd )  {
                DDEQFree( lpWinInfo->qDDEOutgoingCmd );
                lpWinInfo->qDDEOutgoingCmd = 0;
            }

            if( lpWinInfo->lpDdePktTerminate )  {
                HeapFreePtr( lpWinInfo->lpDdePktTerminate );
                lpWinInfo->lpDdePktTerminate = NULL;
            }
            if (lpWinInfo->lpSecurityKeyRcvd) {
                HeapFreePtr( lpWinInfo->lpSecurityKeyRcvd );
                lpWinInfo->lpSecurityKeyRcvd = NULL;
                lpWinInfo->sizeSecurityKeyRcvd = 0L;
            }

            if( lpWinInfo->fCallObjectCloseAuditAlarm )  {
                HANDLE  hAudit = (HANDLE)lpWinInfo->hAudit;

                ObjectCloseAuditAlarm( NDDE_AUDIT_SUBSYSTEM, (LPVOID)&hAudit,
                    lpWinInfo->fGenerateAuditOnClose );
                lpWinInfo->fCallObjectCloseAuditAlarm = FALSE;
            }

            HeapFreePtr( lpWinInfo );
            SetWindowLongPtr( hWnd, 0, 0L );
            UpdateScreenState();
        }
        break;

    default:
        if (message == wMsgDoTerminate) {
            DoTerminate((LPWININFO)lParam);
            break;
        }

        return DefWindowProc (hWnd, message, wParam, lParam);
    }
    return (LONG_PTR) 0;
}



/*
 * Phase 1 of WM_DDE_INITIATE processing.
 *
 * Make sure we are not shutting down.
 * Validate atoms:
 *      Make sure it starts with a \\ or else ignore.
 *      Make sure app name is reasonable.
 * Remember client module name.
 * Create the NetDDE server window. (DDEWddeWndProc)
 * Create associated conversation info. (WST_WAIT_NET_INIT_ACK)
 * Send an ACK reply.
 * Link new window into list of NetDDE windows. (DDEWndAddToList)
 *
 * Life continues at ServiceInitiates().
 */
VOID
FAR PASCAL
DDEHandleInitiate(
    HWND    hWndNetdde,
    HWND    hWndClient,
    ATOM    aApp,
    ATOM    aTopic )
{
    char        szApp[ 256 ];
    char        szTopic[ 256 ];
    char        nodeName[ 256 ];
    char        appName[ 256 ];
    char        clientNameFull[ 128 ];
    PSTR        pszClientName;
    PSTR        pszNodeName;
    PSTR        pszNodeNameTo;
    HWND        hWndDDE;
    BOOL        ok                  = TRUE;
    LPWININFO   lpWinInfo           = NULL;
    LPDDEPKT    lpDdePkt            = NULL;
    int         n;

    CheckCritIn();

    TRACEINIT((szT, "DDEHandleInitiate: PROCESSING WM_DDE_INITIATE message."));
    if( !bClosingAllConversations && aApp && aTopic )  {
        GlobalGetAtomName( aApp, szApp, sizeof(szApp) );
        GlobalGetAtomName( aTopic, szTopic, sizeof(szTopic) );

        if( (szApp[0] == '\\') && (szApp[1] == '\\') )  {
            /**** validate topic name ****/
            pszNodeName = &szApp[2];
            pszNodeNameTo = nodeName;
            while( *pszNodeName && (*pszNodeName != '\\') )  {
                *pszNodeNameTo++ = *pszNodeName++;
            }
            *pszNodeNameTo = '\0';

            if( (nodeName[0] == '\0') || (lstrlen(nodeName) > MAX_NODE_NAME)) {
                /*  Invalid network node name: "%1" from "%2" */
                NDDELogError(MSG019, (LPSTR)nodeName, (LPSTR)szApp, NULL );
                TRACEINIT((szT, "DDEHandleInitiate: Error1 Leaving."));
                return;
            }

            if( *pszNodeName != '\\' )  {
                /*  No application name: "%1"   */
                NDDELogError(MSG020, (LPSTR)szApp, NULL );
                TRACEINIT((szT, "DDEHandleInitiate: Error2 Leaving."));
                return;
            }
            pszNodeName++;      /* past the backslash */
            pszNodeNameTo = appName;
            while( *pszNodeName )  {
                *pszNodeNameTo++ = *pszNodeName++;
            }
            *pszNodeNameTo = '\0';

            if( appName[0] == '\0' )  {
                /*  Invalid application name: "%1" from "%2"    */
                NDDELogError(MSG021, (LPSTR)appName, (LPSTR)szApp, NULL );
                TRACEINIT((szT, "DDEHandleInitiate: Error3 Leaving."));
                return;
            }

            n = GetModuleFileName(
                (HANDLE)GetClassLongPtr( hWndClient, GCLP_HMODULE ),
                clientNameFull, sizeof(clientNameFull) );
            pszClientName = &clientNameFull[ n-1 ];

            while ( n--
                && (*pszClientName != '\\')
                && (*pszClientName != ':')
                && (*pszClientName != '/'))  {
                if (*pszClientName == '.') {    /* null the . */
                    *pszClientName = '\0';
                }
                pszClientName--;
            }
            pszClientName++;

            /* network name */
            LeaveCrit();
            hWndDDE = CreateWindow(
                (LPSTR) szNetDDEIntf,
                (LPSTR) GetAppName(),
                WS_CHILD,
                0,
                0,
                0,
                0,
                (HWND) hWndNetdde,
                (HMENU) NULL,
                (HANDLE) hInst,
                (LPSTR) NULL);

            if( hWndDDE )  {
                lpWinInfo = CreateWinInfo( nodeName, appName,
                    szTopic, pszClientName, hWndDDE );
                if( lpWinInfo )  {
                    lpWinInfo->bClientSideOfNet = TRUE;
                    lpWinInfo->hWndDDELocal = hWndClient;
                    lpWinInfo->hTask = GetWindowTask( hWndClient );
                    lpWinInfo->wState = WST_WAIT_NET_INIT_ACK;
                    InterlockedIncrement(&lpWinInfo->dwWaitingServiceInitiate);
                    lpWinInfo->connectFlags = ExtractFlags(appName);
                    UpdateScreenState();
                    EnterCrit();
                    nInitsWaiting++;
                    LeaveCrit();
                } else {
                    ok = FALSE;
                }
            } else {
                /*  Could not create server agent window for "%1" client */
                NDDELogError(MSG022, pszClientName, NULL);
                ok = FALSE;
                TRACEINIT((szT, "DDEHandleInitiate: Error4 Leaving."));
            }

            if( ok )  {
                aApp = GlobalAddAtom( szApp );
                aTopic = GlobalAddAtom( szTopic );
#if DBG
                if( bDebugDDE )  {
                    DebugDDEMessage( "sent", (HWND)-1, WM_DDE_ACK,
                        (WPARAM) hWndDDE,
                        MAKELONG(aApp,aTopic) );
                }
#endif // DBG
                SendMessage( hWndClient, WM_DDE_ACK,
                    (UINT_PTR)hWndDDE, MAKELONG(aApp, aTopic) );

                EnterCrit();
                DDEWndAddToList( hWndDDE );
                LeaveCrit();
            }
            if( !ok )  {
                if( hWndDDE )  {
                    DestroyWindow( hWndDDE );
                    hWndDDE = 0;
                }
                if( lpDdePkt )  {
                    HeapFreePtr( lpDdePkt );
                    lpDdePkt = NULL;
                }
            }
            EnterCrit();
        }
    }
    UpdateScreenState();
    TRACEINIT((szT, "DDEHandleInitiate: Leaving."));
}









BOOL
FAR PASCAL
AddAck(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    HANDLE      hData;
    BOOL        bRemoved;
    DDEQENT     DDEQEnt;
    UINT        wMsg;
    BOOL        bUseAtom;
    BOOL        bDeleteAtom;
    UINT_PTR    wStatus;
    UINT_PTR    aItem;
    BOOL        bLocalWndValid;
    char        szItemName[ 256 ];
    BOOL        bDoneProcessing     = FALSE;
    BOOL        bRtn = TRUE;
    LPDDEPKT    lpDdePkt;

    bLocalWndValid = IsWindow( lpWinInfo->hWndDDELocal );
    if( lpWinInfo->bClientSideOfNet )  {
        /* must be ack to a data command */
        UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
        FreeDDElParam( WM_DDE_ACK, lParam );
        wMsg = WM_DDE_ACK_DATA;
        bRemoved = DDEQRemove( lpWinInfo->qDDEIncomingCmd, &DDEQEnt );
        if( !bRemoved )  {
            /*  Extraneous WM_DDE_ACK from DDE Client "%1"  */
            NDDELogWarning(MSG023,
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL);
            bUseAtom = FALSE;
            bDeleteAtom = FALSE;
        } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_DATA )  {
            /*  WM_DDE_ACK from DDE Client "%1" not matching DATA: %2   */
            NDDELogWarning(MSG024,
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST), NULL );
            bUseAtom = FALSE;
            bDeleteAtom = FALSE;
        } else {
            /* ATOM:  delete the atom */
            bUseAtom = TRUE;
            bDeleteAtom = TRUE;
            wMsg = WM_DDE_ACK_DATA;

            /* MEMORY: if !fRelease or data was NACKed, free it */
            if( !DDEQEnt.fRelease || ((wStatus & ACK_MSG) != ACK_MSG) )  {
                if( bLocalWndValid && DDEQEnt.hData )  {
                    GlobalFreehData( (HANDLE)DDEQEnt.hData );
                }
            }
        }
    } else {
        assert( lpWinInfo->bServerSideOfNet );
        /* can be ACK to:
            WM_DDE_REQUEST
            WM_DDE_POKE
            WM_DDE_ADVISE
            WM_DDE_UNADVISE
            WM_DDE_EXECUTE
         */
        bRemoved = DDEQRemove( lpWinInfo->qDDEIncomingCmd, &DDEQEnt );
        if( !bRemoved )  {
            /*  Extraneous %1 from DDE Client "%2"  */
            NDDELogWarning(MSG023, "WM_DDE_ACK",
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL);
            bUseAtom = FALSE;
            bDeleteAtom = FALSE;
        } else
            switch( DDEQEnt.wMsg + WM_DDE_FIRST )  {
            case WM_DDE_REQUEST:                /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_REQUEST;
                break;

            case WM_DDE_UNADVISE:                /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_UNADVISE;
                break;

            case WM_DDE_POKE:                   /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_POKE;

                /* MEMORY: free if ACK or !fRelease */
                if( !DDEQEnt.fRelease || (wStatus != ACK_MSG) )  {
                    if( DDEQEnt.hData )  {
                        if( bLocalWndValid )  {
                            GlobalFreehData( (HANDLE)DDEQEnt.hData );
                        }
                    }
                }
                break;

            case WM_DDE_ADVISE:                /* ATOM:  delete the atom */
                UnpackDDElParam( WM_DDE_ACK, lParam, &wStatus, &aItem );
                FreeDDElParam( WM_DDE_ACK, lParam );
                bUseAtom = TRUE;
                bDeleteAtom = TRUE;
                wMsg = WM_DDE_ACK_ADVISE;

                /* MEMORY: free if NACK */
                if( wStatus == NACK_MSG )  {
                    if( DDEQEnt.hData )  {
                        if( bLocalWndValid )  {
                            GlobalFree( (HANDLE)DDEQEnt.hData );
                        }
                    }
                }
                break;

            case WM_DDE_EXECUTE:                /* ATOM:  N/A */
                bUseAtom = FALSE;
                bDeleteAtom = FALSE;
                wMsg = WM_DDE_ACK_EXECUTE;

                /* MEMORY: free */
                if( DDEQEnt.hData )  {
                    if( bLocalWndValid )  {
                        GlobalFree( (HANDLE)DDEQEnt.hData );
                    }
                }
                if( lpWinInfo->wState != WST_TERMINATED ) {
                    UnpackDDElParam( WM_DDE_ACK, lParam,
                        &wStatus, (PUINT_PTR)&hData );
                    FreeDDElParam( WM_DDE_ADVISE, lParam );
                    lpDdePkt = CreateAckExecutePkt(
                        wStatus & ACK_MSG ? 1 : 0,
                        wStatus & BUSY_MSG ? 1 : 0,
                        (BYTE) (wStatus & 0xFF) );
                    if( lpDdePkt )  {
                        lpWinInfo->dwSent++;
                        UpdateScreenStatistics();
                        DderPacketFromIPC( lpWinInfo->hDder,
                            (HIPC) lpWinInfo->hWndDDE, lpDdePkt );
                    } else {
                        bRtn = FALSE;
                    }
                }
                bDoneProcessing = TRUE;
                break;

            default:
                /*  INTERNAL ERROR -- Unknown DDE Command AddAck Server: %1 */
                NDDELogError(MSG042,
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST), NULL);
                bRtn = FALSE;
        }
    }

    if( !bDoneProcessing )  {
        if( bUseAtom )  {
            GlobalGetAtomName( (ATOM)aItem, szItemName,
                sizeof(szItemName) );
        } else {
            szItemName[0] = '\0';
        }
        if( bDeleteAtom )  {
            GlobalDeleteAtom( (ATOM)aItem );
        }
        if( lpWinInfo->wState != WST_TERMINATED ) {
            lpDdePkt = CreateGenericAckPkt( (WORD)wMsg, szItemName,
                ((BOOL)(wStatus & ACK_MSG ? 1 : 0)),
                ((BOOL)(wStatus & BUSY_MSG ? 1 : 0)),
                (BYTE) (wStatus & 0xFF) );
            if( lpDdePkt )  {
                lpWinInfo->dwSent++;
                UpdateScreenStatistics();
                DderPacketFromIPC( lpWinInfo->hDder,
                    (HIPC) lpWinInfo->hWndDDE, lpDdePkt );
            } else {
                bRtn = FALSE;
            }
        }
    }
    return( bRtn );
}









BOOL
FAR PASCAL
AddRequestUnadvise(
    UINT        wMsg,
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    LPDDEPKT    lpDdePkt;
    char        szItemName[ 256 ];
    DDEQENT     DDEQEnt;
    UINT_PTR    cfFormat;
    UINT_PTR    aItem;

    UnpackDDElParam( WM_DDE_REQUEST, lParam, &cfFormat, &aItem );
    FreeDDElParam( WM_DDE_REQUEST, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    assert( (wMsg == WM_DDE_REQUEST) || (wMsg == WM_DDE_UNADVISE) );
    DDEQEnt.wMsg        = wMsg - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = 0;

    if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
        return( FALSE );
    }


    if( wMsg == WM_DDE_REQUEST )  {
        lpDdePkt = CreateRequestPkt( szItemName, (WORD)cfFormat );
    } else {
        lpDdePkt = CreateUnadvisePkt( szItemName, (WORD)cfFormat );
    }
    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        UpdateScreenStatistics();
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }

    return( TRUE );
}









BOOL
FAR PASCAL
AddData(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    char        szItemName[ 256 ];
    HANDLE      hData;
    UINT_PTR    aItem;
    HANDLE      hDataComplex        = 0;
    DWORD       dwSize;
    LPSTR       lpMem;
    LPSTR       lpDataPortion;
    WORD        cfFormat;
    DDEQENT     DDEQEnt;
    DDEQENT     DDEQEntReq;
    BOOL        bRemoved;
    LPDDEPKT    lpDdePkt;
    BOOL        ok                  = TRUE;

    UnpackDDElParam( WM_DDE_DATA, lParam, (PUINT_PTR)&hData, &aItem );
    FreeDDElParam( WM_DDE_DATA, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_DATA - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (UINT_PTR)hData;

    if( hData )  {
        dwSize = (DWORD)GlobalSize(hData);
        lpMem = GlobalLock( hData );
        if( lpMem )  {
            /* initialize flags in DDEQEnt */
            assert( lpWinInfo->bServerSideOfNet );
            DDEQEnt.fRelease    = ((LPDDELN)lpMem)->fRelease;
            DDEQEnt.fAckReq     = ((LPDDELN)lpMem)->fAckReq;
            DDEQEnt.fResponse   = ((LPDDELN)lpMem)->fResponse;
            if( DDEQEnt.fAckReq )  {
                if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
                    GlobalUnlock( hData );
                    return( FALSE );
                }
            }
            if( DDEQEnt.fResponse )  {
                bRemoved = DDEQRemove( lpWinInfo->qDDEIncomingCmd,
                    &DDEQEntReq );
                if( !bRemoved )  {
                    /*  Extraneous WM_DDE_DATA response from DDE Server "%1"  */
                    NDDELogWarning(MSG025,
                        (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL);
                } else if( (DDEQEntReq.wMsg + WM_DDE_FIRST) != WM_DDE_REQUEST ) {
                    /*  %1 from DDE Server "%2" not matching %3: %4   */
                    NDDELogWarning(MSG026, "WM_DDE_DATA",
                        (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName),
                        "REQUEST",
                        LogString("0x%0X", DDEQEntReq.wMsg + WM_DDE_FIRST), NULL );
                }
            }
            cfFormat = (WORD)((LPDDELN)lpMem)->cfFormat;
            lpDataPortion = (LPSTR)lpMem + sizeof(DDELN);
            dwSize -= sizeof(DDELN);
        } else {
            dwSize = 0L;
            lpMem = NULL;
            lpDataPortion = NULL;
            cfFormat = 0;
        }
    } else {
        dwSize = 0L;
        lpMem = NULL;
        lpDataPortion = NULL;
        cfFormat = 0;
    }

    if( lpDataPortion )  {
        switch (cfFormat) {
            case CF_METAFILEPICT:
                if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                    &hDataComplex, lpWinInfo->bWin16Connection ) ) {
                    ok = FALSE;
                }
                break;
            case CF_BITMAP:
                if( !ConvertDataToPktBitmap( &lpDataPortion, &dwSize,
                    &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                    ok = FALSE;
                }
                break;
            case CF_ENHMETAFILE:
                if( !ConvertDataToPktEnhMetafile( &lpDataPortion, &dwSize,
                    &hDataComplex ) ) {
                    ok = FALSE;
                }
                break;
            case CF_PALETTE:
                if( !ConvertDataToPktPalette( &lpDataPortion, &dwSize,
                    &hDataComplex ) ) {
                    ok = FALSE;
                }
                break;
            case CF_DIB:
                if( !ConvertDataToPktDIB( &lpDataPortion, &dwSize,
                    &hDataComplex ) ) {
                    ok = FALSE;
                }
                break;
            default:
                if (cfFormat == cfPrinterPicture) {
                    if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                        &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                    ok = FALSE;
                    }
                }
                break;
        }
    }

    if (!ok) {
        if (hData)
            GlobalUnlock( hData );
        return FALSE;
    }

    lpDdePkt = CreateDataPkt( szItemName,
                              cfFormat,
                              (BOOL)DDEQEnt.fResponse,
                              (BOOL)DDEQEnt.fAckReq,
                              (BOOL)DDEQEnt.fRelease,
                              lpDataPortion,
                              dwSize );

    if( hData )  {
        GlobalUnlock( hData );
        if( !DDEQEnt.fAckReq )  {
            GlobalDeleteAtom( (ATOM)aItem );
            if( DDEQEnt.fRelease && (DDEQEnt.hData != 0) )  {
                assert( hData == (HANDLE)DDEQEnt.hData );
                GlobalFreehData( (HANDLE)DDEQEnt.hData );
            }
        }
    }
    if( hDataComplex )  {
        GlobalUnlock( hDataComplex );
        GlobalFree( hDataComplex );
    }

    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        UpdateScreenStatistics();
        DderPacketFromIPC( lpWinInfo->hDder,
            (HIPC) lpWinInfo->hWndDDE, lpDdePkt );
    } else {
        return( FALSE );
    }
    return( TRUE );
}









BOOL
FAR PASCAL
AddPoke(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    char        szItemName[ 256 ];
    HANDLE      hData;
    UINT_PTR    aItem;
    DWORD       dwSize;
    HANDLE      hDataComplex        = 0;
    LPSTR       lpMem               = (LPSTR) NULL;
    LPSTR       lpDataPortion;
    WORD        cfFormat;
    DDEQENT     DDEQEnt;
    LPDDEPKT    lpDdePkt            = (LPDDEPKT) NULL;
    BOOL        ok                  = TRUE;

    UnpackDDElParam( WM_DDE_POKE, lParam, (PUINT_PTR)&hData, &aItem );
    FreeDDElParam( WM_DDE_POKE, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_POKE - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (UINT_PTR)hData;

    if( hData )  {
        dwSize = (DWORD)GlobalSize(hData);
        lpMem = GlobalLock( hData );

        if( lpMem )  {
            /* initialize flags in DDEQEnt */
            assert( lpWinInfo->bClientSideOfNet );
            DDEQEnt.fRelease = ((LPDDELN)lpMem)->fRelease;
            if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
                GlobalUnlock( hData );
                return( FALSE );
            }
            cfFormat = (WORD) ((LPDDELN)lpMem)->cfFormat;
            lpDataPortion = (LPSTR)lpMem + sizeof(DDELN);
            dwSize -= sizeof(DDELN);
        } else {
            dwSize = 0L;
            lpMem = NULL;
            lpDataPortion = NULL;
            cfFormat = 0;
        }
    } else {
        dwSize = 0L;
        lpMem = NULL;
        lpDataPortion = NULL;
        cfFormat = 0;
    }

    switch (cfFormat) {
        case CF_METAFILEPICT:
            if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                ok = FALSE;
            }
            break;
        case CF_BITMAP:
            if( !ConvertDataToPktBitmap( &lpDataPortion, &dwSize,
                &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                ok = FALSE;
            }
            break;
        case CF_ENHMETAFILE:
            if( !ConvertDataToPktEnhMetafile( &lpDataPortion, &dwSize,
                &hDataComplex ) ) {
                ok = FALSE;
            }
            break;
        case CF_PALETTE:
            if( !ConvertDataToPktPalette( &lpDataPortion, &dwSize,
                &hDataComplex ) ) {
                ok = FALSE;
            }
            break;
        case CF_DIB:
            if( !ConvertDataToPktDIB( &lpDataPortion, &dwSize,
                &hDataComplex ) ) {
                ok = FALSE;
            }
            break;
        default:
            if (cfFormat == cfPrinterPicture) {
                if( !ConvertDataToPktMetafile( &lpDataPortion, &dwSize,
                    &hDataComplex, lpWinInfo->bWin16Connection  ) ) {
                ok = FALSE;
                }
            }
            break;
    }

    if (!ok) {
        if (hData)
            GlobalUnlock( hData );
        return FALSE;
    }

    lpDdePkt = CreatePokePkt( szItemName, cfFormat, (BOOL)DDEQEnt.fRelease,
                    lpDataPortion, dwSize );

    if( hDataComplex )  {
        GlobalUnlock( hDataComplex );
        GlobalFree( hDataComplex );
    }
    if( hData && lpMem )  {
        GlobalUnlock( hData );
    }

    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        UpdateScreenStatistics();
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }
    return( TRUE );
}









BOOL
FAR PASCAL
AddAdvise(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    char        szItemName[ 256 ];
    HANDLE      hData;
    UINT_PTR    aItem;
    LPDDELN     lpOptions;
    WORD        cfFormat;
    DDEQENT     DDEQEnt;
    LPDDEPKT    lpDdePkt;

    UnpackDDElParam( WM_DDE_ADVISE, lParam, (PUINT_PTR)&hData, &aItem );
    FreeDDElParam( WM_DDE_ADVISE, lParam );
    GlobalGetAtomName( (ATOM)aItem, szItemName, sizeof(szItemName) );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_ADVISE - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (ULONG_PTR)hData;

    if( hData == 0 )  {
        /*  NULL hData from WM_DDE_ADVISE Client: "%1"  */
        NDDELogWarning(MSG027,
            (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL );
        return( FALSE );
    }
    lpOptions = (LPDDELN) GlobalLock( hData );
    if( lpOptions )  {
        /* initialize flags in DDEQEnt */
        assert( lpWinInfo->bClientSideOfNet );
        DDEQEnt.fAckReq = lpOptions->fAckReq;
        DDEQEnt.fNoData = lpOptions->fNoData;
        if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
            GlobalUnlock( hData );
            return( FALSE );
        }
        cfFormat = (WORD) lpOptions->cfFormat;
        GlobalUnlock( hData );
    } else {
        cfFormat = 0;
    }

    lpDdePkt = CreateAdvisePkt( szItemName, cfFormat,
        (BOOL)DDEQEnt.fAckReq, (BOOL)DDEQEnt.fNoData );
    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        UpdateScreenStatistics();
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }

    return( TRUE );
}









BOOL
FAR PASCAL
AddExecute(
    LPWININFO   lpWinInfo,
    LPARAM      lParam )
{
    LPSTR       lpString;
    LPDDEPKT    lpDdePkt;
    UINT_PTR    uJunk;
    HANDLE      hData;
    DDEQENT     DDEQEnt;

    UnpackDDElParam( WM_DDE_EXECUTE, lParam, &uJunk, (PUINT_PTR)&hData );
    FreeDDElParam( WM_DDE_EXECUTE, lParam );

    /* basic DDEQEnt initialization */
    DDEQEnt.wMsg        = WM_DDE_EXECUTE - WM_DDE_FIRST;
    DDEQEnt.fRelease    = FALSE;
    DDEQEnt.fAckReq     = FALSE;
    DDEQEnt.fResponse   = FALSE;
    DDEQEnt.fNoData     = FALSE;
    DDEQEnt.hData       = (UINT_PTR)hData;

    if( !DDEQAdd( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt ) )  {
        return( FALSE );
    }

    lpString = GlobalLock( hData );
    if( lpString )  {
        lpDdePkt = CreateExecutePkt( lpString );
        GlobalUnlock( hData );
    } else {
        lpDdePkt = CreateExecutePkt( "" );
    }
    if( lpDdePkt )  {
        lpWinInfo->dwSent++;
        UpdateScreenStatistics();
        DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
            lpDdePkt );
    } else {
        return( FALSE );
    }

    return( TRUE );
}









VOID
FAR PASCAL
DDEWndAddToList( HWND hWnd )
{
    LPWININFO   lpWinInfo;

    assert( hWnd );
    assert( IsWindow(hWnd) );
    EnterCrit();
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
    assert( lpWinInfo );
    lpWinInfo->hWndPrev = 0;
    lpWinInfo->hWndNext = hWndDDEHead;
    lpWinInfo->bOnWindowList = TRUE;
    if( hWndDDEHead )  {
        DDEWndSetPrev( hWndDDEHead, hWnd );
    }
    hWndDDEHead = hWnd;
    LeaveCrit();
}

VOID
FAR PASCAL
DDEWndMoveToTermList( HWND hWnd )
{
    LPWININFO   lpWinInfo;

    assert( hWnd );
    assert( IsWindow(hWnd) );
    EnterCrit();
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
    assert( lpWinInfo );
    assert( lpWinInfo->bOnWindowList );
    DDEWndDeleteFromList( hWnd );

    lpWinInfo->hWndPrev = 0;
    lpWinInfo->hWndNext = hWndDDEHeadTerminating;
    lpWinInfo->bOnTermWindowList = TRUE;
    if( hWndDDEHeadTerminating )  {
        DDEWndSetPrev( hWndDDEHeadTerminating, hWnd );
    }
    hWndDDEHeadTerminating = hWnd;
    LeaveCrit();
}

VOID
FAR PASCAL
DDEWndDeleteFromList( HWND hWnd )
{
    HWND        hWndPrev;
    HWND        hWndNext;
    LPWININFO   lpWinInfo;

    assert( hWnd );
    assert( IsWindow(hWnd) );
    EnterCrit();
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
    assert( lpWinInfo );
    if( lpWinInfo->bOnWindowList )  {
        hWndPrev = lpWinInfo->hWndPrev;
        hWndNext = lpWinInfo->hWndNext;

        if( hWndPrev )  {
            DDEWndSetNext( hWndPrev, hWndNext );
        } else {
            assert( hWnd == hWndDDEHead );
            hWndDDEHead = hWndNext;
        }

        DDEWndSetPrev( hWndNext, hWndPrev );
        lpWinInfo->bOnWindowList = FALSE;
    } else if( lpWinInfo->bOnTermWindowList )  {
        hWndPrev = lpWinInfo->hWndPrev;
        hWndNext = lpWinInfo->hWndNext;

        if( hWndPrev )  {
            DDEWndSetNext( hWndPrev, hWndNext );
        } else {
            assert( hWnd == hWndDDEHeadTerminating );
            hWndDDEHeadTerminating = hWndNext;
        }

        DDEWndSetPrev( hWndNext, hWndPrev );
        lpWinInfo->bOnTermWindowList = FALSE;
    }
    LeaveCrit();
}









VOID
FAR PASCAL
DDEWndSetNext(
    HWND        hWnd,
    HWND        hWndNext )
{
    LPWININFO   lpWinInfo;

    if( hWnd )  {
        EnterCrit();
        assert( IsWindow(hWnd) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
        assert( lpWinInfo );
        lpWinInfo->hWndNext = hWndNext;
        LeaveCrit();
    }
}

#ifdef DEADCODE
HWND
FAR PASCAL
DDEWndGetNext( HWND     hWnd )
{
    LPWININFO   lpWinInfo;
    HWND        hWndNext;

    hWndNext = 0;
    if( hWnd )  {
        EnterCrit();
        assert( IsWindow(hWnd) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
        assert( lpWinInfo );
        hWndNext = lpWinInfo->hWndNext;
        LeaveCrit();
    }
    return( hWndNext );
}
#endif // DEADCODE

VOID
FAR PASCAL
DDEWndSetPrev(
    HWND        hWnd,
    HWND        hWndPrev )
{
    LPWININFO   lpWinInfo;

    if( hWnd )  {
        assert( IsWindow(hWnd) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWnd, 0 );
        assert( lpWinInfo );
        lpWinInfo->hWndPrev = hWndPrev;
    }
}








/*
 * Phase 1 of WM_DDE_INITIATE processing.
 *
 * For each window on the hWndDDEHead list that has not yet been processed...
 *    Post a WM_HANDLE_DDE_INITIATE to the NetDDE server window.
 *
 * This routine will fail to post the message if one is already in the target
 * window's queue.
 *
 * Life continues at DDEWddeWndProc(WM_HANDLE_DDE_INITIATE).
 */
VOID
FAR PASCAL
ServiceInitiates( void )
{
    MSG         msg;
    HWND        hWndDDE;
    HWND        hWndNext;
    LPWININFO   lpWinInfo;

    EnterCrit();
    if( nInitsWaiting )  {
        hWndDDE = hWndDDEHead;
        while( hWndDDE )  {
            assert( IsWindow(hWndDDE) );
            lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
            assert( lpWinInfo );
            hWndNext = lpWinInfo->hWndNext;

            if( (lpWinInfo->wState == WST_WAIT_NET_INIT_ACK)
                    && (lpWinInfo->hDder == 0)
                    && lpWinInfo->dwWaitingServiceInitiate )  {
                InterlockedDecrement(&lpWinInfo->dwWaitingServiceInitiate);
                nInitsWaiting--;
#if 0
                if( PeekMessage( &msg, hWndDDE, WM_HANDLE_DDE_INITIATE,
                        WM_HANDLE_DDE_INITIATE, PM_NOYIELD | PM_NOREMOVE ) ) {
                    DIPRINTF(("ServiceInitiates: multiple WM_HANDLE_DDE_INITIATEs in queue."));
                } else {
                    if (!PostMessage( hWndDDE, WM_HANDLE_DDE_INITIATE, 0, 0L) ) {
                        /* abort the conversation */
                        IpcAbortConversation( (HIPC)hWndDDE );
                    }
                }

#else
                //
                // WINSE #4298
                // we can't call PeekMessage because we can cause a deadlock.
                // if another thread has called SendMessage(ptd->hwndDDE, wMsgIpcInit...)
                // this will cause WM_DDE_INITIATE to be called which will
                // require access to the critical section we hold.
                //
                if( lpWinInfo->dwWaitingServiceInitiate ) {
                    DIPRINTF(("ServiceInitiates: multiple WM_HANDLE_DDE_INITIATEs in queue."));
                    // force back to zero to best mimic the old behavior of having
                    // TRUE/FALSE values
                    InterlockedExchange(&lpWinInfo->dwWaitingServiceInitiate, 0);
                } else {
                    if (!PostMessage( hWndDDE, WM_HANDLE_DDE_INITIATE, 0, 0L) ) {
                        /* abort the conversation */
                        IpcAbortConversation( (HIPC)hWndDDE );
                    }
                }
#endif
            }

            /* move on to next wdw */
            hWndDDE = hWndNext;
        }
    }
    LeaveCrit();
}









VOID
FAR PASCAL
TerminateAllConversations( void )
{
    HWND        hWndDDE;
    HWND        hWndNext;
    LPWININFO   lpWinInfo;

    EnterCrit();
    hWndDDE = hWndDDEHead;
    while( hWndDDE )  {
        assert( IsWindow(hWndDDE) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
        assert( lpWinInfo );
        hWndNext = lpWinInfo->hWndNext;

        /* abort the conversation */
        IpcAbortConversation( (HIPC)hWndDDE );

        /* move on to next wdw */
        hWndDDE = hWndNext;
    }
    LeaveCrit();
}









/*
 * This function is used to queue up incomming DDE messages that arrive from a clinet before
 * actual connection with the remote machine has been established.
 *
 * SendQueuedMessages() empties this queue when the connection is established - or not.
 * SAS 4/14/95
 */
BOOL
FAR PASCAL
WaitInitAddMsg(
    LPWININFO   lpWinInfo,
    unsigned    message,
    LPARAM      lParam )
{
    LPMSGQHDR   lpMsgQHdr;
    LPWIMSG     lpWIMsg;
    BOOL        bNeedNew;
    DWORD       wNewCount;
    HANDLE      hMemNew;
    BOOL        ok;

    ok = TRUE;

    /*
     * See if we need to allocate and initialize the queue.
     */
    if( lpWinInfo->hMemWaitInitQueue == 0 )  {
        lpWinInfo->hMemWaitInitQueue = GetGlobalAlloc(
                GMEM_MOVEABLE | GMEM_ZEROINIT,
                (DWORD)sizeof(MSGQHDR) + (WIQ_INCR * sizeof(WIMSG)) );
        if( lpWinInfo->hMemWaitInitQueue == 0 )  {
            MEMERROR();
            return(FALSE);
        }

        /*
         * Initialize with 0 messages
         */
        lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );
        lpMsgQHdr->wi_nMessagesLeft = WIQ_INCR;
        lpMsgQHdr->wi_nMessagesQueued = 0;
        GlobalUnlock( lpWinInfo->hMemWaitInitQueue );
    }

    lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );

    /*
     * point to next available slot
     */
    lpWIMsg = &lpMsgQHdr->wi_msg[ lpMsgQHdr->wi_nMessagesQueued ];
    lpMsgQHdr->wi_nMessagesQueued++;
    lpMsgQHdr->wi_nMessagesLeft--;

    if( lpMsgQHdr->wi_nMessagesLeft == 0 )  {
        /*
         * if full, remember to dynamically grow it before we leave.
         */
        bNeedNew = TRUE;
        wNewCount = lpMsgQHdr->wi_nMessagesQueued + WIQ_INCR;
    } else {
        bNeedNew = FALSE;
    }
    /*
     * place the data
     */
    lpWIMsg->message        = message;
    lpWIMsg->lParam         = lParam;

    GlobalUnlock( lpWinInfo->hMemWaitInitQueue );

    /*
     * grow the queue dynamically BEFORE we leave - why? cuz its cool to
     * waste memory needlessly!
     */
    if( bNeedNew )  {
        hMemNew = GlobalReAlloc( lpWinInfo->hMemWaitInitQueue,
                (DWORD)sizeof(MSGQHDR) + (wNewCount * sizeof(WIMSG)),
                GMEM_MOVEABLE );
        if( hMemNew )  {
            /*
             * update queue pointers to reflect new size.
             */
            lpWinInfo->hMemWaitInitQueue = hMemNew;
            lpMsgQHdr = (LPMSGQHDR)GlobalLock( hMemNew );
            lpMsgQHdr->wi_nMessagesLeft = WIQ_INCR;
            GlobalUnlock( hMemNew );
        } else {
            /*
             * This is @#$%!.  the memory may never be needed!
             * This is not a real overflow.
             */
            MEMERROR();
            /*  Overflow of queue (%1) waiting for initial advise   */
            NDDELogError(MSG028, LogString("%d", wNewCount), NULL);
            return(FALSE);
        }
    }
    return( TRUE );
}








/*
 * This routine empties the messages added by WaitInitAddMsg()
 * SAS 4/14/95
 */
VOID
FAR PASCAL
SendQueuedMessages(
    HWND        hWnd,
    LPWININFO   lpWinInfo )
{
    LPMSGQHDR   lpMsgQHdr;
    LPWIMSG     lpWIMsg;
    int         nCount;

    /*
     * If there is no queue - we're done!
     */
    if( lpWinInfo->hMemWaitInitQueue == 0 )  {
        return;
    }

    if( lpWinInfo->hDder && lpWinInfo->wState == WST_OK ) {
        lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );

        /*
         * Take it from the top...
         */
        lpWIMsg = &lpMsgQHdr->wi_msg[ 0 ];
        nCount = lpMsgQHdr->wi_nMessagesQueued;
        while( --nCount >= 0 )  {
            switch (lpWIMsg->message) {
            case WM_DDE_REQUEST:
                AddRequestUnadvise( lpWIMsg->message, lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_ADVISE:
                AddAdvise( lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_UNADVISE:
                AddRequestUnadvise( lpWIMsg->message, lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_POKE:
                AddPoke( lpWinInfo, lpWIMsg->lParam );
                break;
            case WM_DDE_EXECUTE:
                AddExecute( lpWinInfo, lpWIMsg->lParam );
                break;
            }
            lpWIMsg++;
        }
        GlobalUnlock( lpWinInfo->hMemWaitInitQueue );
    }

    /*
     * free the queue
     */
    GlobalFree( lpWinInfo->hMemWaitInitQueue );
    lpWinInfo->hMemWaitInitQueue = 0;
}








/*
 * This routine empties the messages added by WaitInitAddMsg()
 * and deletes any objects associated with the messages.
 * SAS 4/14/95
 */
VOID
FAR PASCAL
DeleteQueuedMessages( LPWININFO lpWinInfo )
{
    LPMSGQHDR   lpMsgQHdr;
    LPWIMSG     lpWIMsg;
    int         nCount;
    UINT_PTR    aItem;
    LPARAM      lParam;

    if( lpWinInfo->hMemWaitInitQueue == 0 )  {
        return;
    }

    lpMsgQHdr = (LPMSGQHDR)GlobalLock( lpWinInfo->hMemWaitInitQueue );
    lpWIMsg = &lpMsgQHdr->wi_msg[ 0 ];
    nCount = lpMsgQHdr->wi_nMessagesQueued;
    while( --nCount >= 0 )  {
        HANDLE hData;

        switch (lpWIMsg->message) {
        case WM_DDE_REQUEST:
            GlobalDeleteAtom(HIWORD(lpWIMsg->lParam));
            break;

        case WM_DDE_ADVISE:
            UnpackDDElParam( WM_DDE_ADVISE, lpWIMsg->lParam,
                    (PUINT_PTR)&hData, &aItem );

            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            lParam = ReuseDDElParam(lpWIMsg->lParam, WM_DDE_ADVISE,
                                    WM_DDE_ACK, 0, aItem);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalDeleteAtom((ATOM)aItem);
                FreeDDElParam(WM_DDE_ACK, lParam);
                GlobalFree(hData);
            }

            break;

        case WM_DDE_UNADVISE:
            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            aItem = HIWORD(lpWIMsg->lParam);
            lParam = PackDDElParam(WM_DDE_ACK, 0, aItem);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalDeleteAtom((ATOM)aItem);
                FreeDDElParam(WM_DDE_ACK, lParam);
            }

            break;

        case WM_DDE_POKE:
            UnpackDDElParam( WM_DDE_POKE, lpWIMsg->lParam,
                    (PUINT_PTR)&hData, &aItem );

            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            lParam = ReuseDDElParam(lpWIMsg->lParam, WM_DDE_POKE,
                                    WM_DDE_ACK, 0, aItem);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalDeleteAtom((ATOM)aItem);
                FreeDDElParam(WM_DDE_ACK, lParam);
                GlobalFreehData(hData);
            }
            break;

        case WM_DDE_EXECUTE:
            /*
             * If we've got the local terminate NACK first the
             * queued messages.
             */
            lParam = PackDDElParam(WM_DDE_ACK, 0, lpWIMsg->lParam);
            if (!PostMessage(lpWinInfo->hWndDDELocal, WM_DDE_ACK,
                        (WPARAM)lpWinInfo->hWndDDE, lParam)) {
                GlobalFree((HGLOBAL)lpWIMsg->lParam);
            }
            break;
        }
        lpWIMsg++;
    }
    GlobalUnlock( lpWinInfo->hMemWaitInitQueue );

    /*
     * free the queue
     */
    GlobalFree( lpWinInfo->hMemWaitInitQueue );
    lpWinInfo->hMemWaitInitQueue = 0;
}


/*
 * Function to add an atom and prove that it worked.
 * BUG? Why is this needed?
 * SAS 4/14/95
 */
ATOM
FAR PASCAL
GlobalAddAtomAndCheck( LPSTR lpszItem )
{
    ATOM        aItem;
    char        szAtom[ 256 ];

    if ( aItem = GlobalAddAtom( lpszItem ) )  {
        GlobalGetAtomName( aItem, szAtom, sizeof(szAtom) );
        if( lstrcmpi( szAtom, lpszItem ) != 0 )  {
            /*  Error adding atom: "%1" ==> %2,%\
                Atom retrieved: "%3"    */
            NDDELogError(MSG029, (LPSTR) lpszItem,
                LogString("0x%0X", aItem), (LPSTR) szAtom, NULL);
        }
    } else {
        NDDELogError(MSG030, lpszItem, NULL);
    }
    return( aItem );
}




/*
 *  Request NetDDE Agent to Exec share app if its ok
 *  I think we do this so that the share database is checked in
 *  the context of the user.
 *  SAS 4/14/95
 */
LRESULT
RequestExec(
    HANDLE          hWndDDE,
    LPSTR           lpszCmdLine,
    PNDDESHAREINFO  lpShareInfo)
{
    COPYDATASTRUCT  CopyData;
    PNDDEAGTCMD     pAgntCmd;
    DWORD           dwSize;
    LPSTR           lpszShareName;
    LPSTR           lpszTarget;
    PTHREADDATA     ptd;

    /*
     * Validate command line.
     */
    if( (lpszCmdLine == NULL) || (*lpszCmdLine == '\0') )  {
        /*  RequestExec(): Command Line non-existent. */
        NDDELogError(MSG031, NULL);
        return(-1);
    }

    /*
     * allocate packet for NddeAgent
     */
    lpszShareName = lpShareInfo->lpszShareName;
    dwSize = sizeof(NDDEAGTCMD)
                + lstrlen(lpszShareName) + 1
                + lstrlen(lpszCmdLine) + 1 + 1;

    pAgntCmd = (PNDDEAGTCMD)LocalAlloc(LPTR, dwSize);
    if( pAgntCmd == NULL )  {
        MEMERROR();
        return( -1 );
    }

    /*
     * pack in the data.
     */
    pAgntCmd->dwMagic = NDDEAGT_CMD_MAGIC;
    pAgntCmd->dwRev = NDDEAGT_CMD_REV;
    pAgntCmd->dwCmd = NDDEAGT_CMD_WINEXEC;
    pAgntCmd->qwModifyId[0] = lpShareInfo->qModifyId[0];
    pAgntCmd->qwModifyId[1] = lpShareInfo->qModifyId[1];
    pAgntCmd->fuCmdShow = lpShareInfo->nCmdShow;   /* Look In Share later */

    /* build sharename/cmdline string */
    lpszTarget = pAgntCmd->szData;
    lstrcpy( lpszTarget, lpszShareName );
    lpszTarget += lstrlen(lpszShareName) + 1;
    lstrcpy( lpszTarget, lpszCmdLine );
    lpszTarget += lstrlen(lpszCmdLine) + 1;
    *lpszTarget = '\0';

    /*
     * put packet into copydata struct and send it to NddeAgent.
     */
    CopyData.cbData = dwSize;
    CopyData.lpData = pAgntCmd;
    ptd = TlsGetValue(tlsThreadData);
    SendMessage(ptd->hwndDDEAgent, WM_COPYDATA,
        (WPARAM) hWndDDE, (LPARAM) &CopyData);

    /*
     * free our packet
     */
    LocalFree( pAgntCmd );

    return(uAgntExecRtn);
}





/*
 *  Request NetDDE Agent if its ok to do an Init to share app
 *  I think we do this so that the share database is checked in
 *  the context of the user.
 *  SAS 4/14/95
 */
LRESULT
RequestInit(
    HANDLE          hWndDDE,
    PNDDESHAREINFO  lpShareInfo)
{
    COPYDATASTRUCT  CopyData;
    PNDDEAGTCMD     pAgntCmd;
    DWORD           dwSize;
    LPSTR           lpszShareName;
    LPSTR           lpszTarget;
    PTHREADDATA     ptd;

    /*
     * allocate packet
     */
    lpszShareName = lpShareInfo->lpszShareName;
    dwSize = sizeof(NDDEAGTCMD)
                + lstrlen(lpszShareName) + 1 + 1;

    pAgntCmd = (PNDDEAGTCMD)LocalAlloc(LPTR, dwSize);
    if( pAgntCmd == NULL )  {
        MEMERROR();
        return( -1 );
    }

    /*
     * Fill packet
     */
    pAgntCmd->dwMagic = NDDEAGT_CMD_MAGIC;
    pAgntCmd->dwRev = NDDEAGT_CMD_REV;
    pAgntCmd->dwCmd = NDDEAGT_CMD_WININIT;
    pAgntCmd->qwModifyId[0] = lpShareInfo->qModifyId[0];
    pAgntCmd->qwModifyId[1] = lpShareInfo->qModifyId[1];

    /* build sharename/cmdline string */
    lpszTarget = pAgntCmd->szData;
    lstrcpy( lpszTarget, lpszShareName );
    lpszTarget += lstrlen(lpszShareName) + 1;
    *lpszTarget = '\0';

    /*
     * put packet into copydata and send it to NddeAgnt
     */
    CopyData.cbData = dwSize;
    CopyData.lpData = pAgntCmd;
    ptd = TlsGetValue(tlsThreadData);
    SendMessage(ptd->hwndDDEAgent, WM_COPYDATA,
        (WPARAM) hWndDDE, (LPARAM) &CopyData);

    /*
     * Free our packet.
     */
    LocalFree( pAgntCmd );

    return(uAgntExecRtn);
}



/*
 * This routine takes a given DDE app|topic pair and produces a
 * resulting app|topic pair and an appropriate command line.
 *
 * This conversion is based on the type of share.  appNames that
 * begin with NDDE$ have topics that specify the share to use.
 * They are either:
 *      NEW (.ole appended topic),
 *      OLD (.dde appended topic),
 * or STATIC. (all others)
 *
 * non-NDDE$ appnames are OLD shares and identify the sharename
 * directly. (ie "app|topic").
 *
 * For NEW (.ole) shares, the topic is a Ole CLASS name that is
 * looked up in the registry to determine the actual server name.
 *
 * The command line consists of the resultant "App Topic" string.
 *
 * Side effects: ForceClearImpersonation on failure.
 *
 * SAS 4/14/95
 */
BOOL
MapShareInformation(
    WORD                dd_type,
    LPSTR               lpAppName,
    LPSTR               lpTopicName,
    LPSTR               lpRsltAppName,
    LPSTR               lpRsltTopicName,
    LPSTR               lpszCmdLine,
    PNDDESHAREINFO      *lplpShareInfo,
    LONG                *lplActualShareType )
{
    LONG                lActualShareType;
    int                 nLenShareName;
    char                szShareName[ MAX_SHARENAMEBUF+1 ];
    BOOL                fAppNameIsShare;
    PNDDESHAREINFO      lpShareInfo = (PNDDESHAREINFO) NULL;
    BOOL                bWildApp = FALSE;
    BOOL                bWildTopic = FALSE;
    DWORD               dwShareBufSize;
    WORD                wShareItemCnt;
    UINT                uErrCode;

    *lplpShareInfo = (PNDDESHAREINFO) NULL;

    fAppNameIsShare = IsShare(lpAppName);
    if( fAppNameIsShare )  {
        /*
         * If the AppName has NDDE$ prepended, then lookup the share
         * and substitute the appropriate strings.
         */
        nLenShareName = strlen( lpTopicName );  // Topic == Sharename
        if (nLenShareName >= MAX_SHARENAMEBUF) {
            dwReasonInitFail = RIACK_SHARE_NAME_TOO_BIG;
            return(FALSE);
        }
        /*
         * Copy share name into a buffer where we can munge it.
         */
        lstrcpy( szShareName, lpTopicName );

        /*
         * Figure out which type of share it is...
         * .dde = OLD,  .ole = NEW  other = STATIC
         */
        lActualShareType = SHARE_TYPE_STATIC;
        if( nLenShareName >= 5 )  {
            if( _stricmp( &lpTopicName[nLenShareName-4], ".dde" ) == 0 )  {
                lActualShareType = SHARE_TYPE_OLD;
                szShareName[ nLenShareName-4 ] = '\0';

            } else if( _stricmp( &lpTopicName[nLenShareName-4], ".ole" )== 0) {
                lActualShareType = SHARE_TYPE_NEW;
                szShareName[ nLenShareName-4 ] = '\0';
            }
        }

    } else {
        /*
         * AppNames that don't start with NDDE$ are always OLD shares.
         */
        if ((lstrlen(lpAppName) + lstrlen(lpTopicName) + 1) < MAX_SHARENAMEBUF) {
            lActualShareType = SHARE_TYPE_OLD;
            wsprintf( szShareName, "%s|%s", lpAppName, lpTopicName );
        } else {
            dwReasonInitFail = RIACK_SHARE_NAME_TOO_BIG;
            return(FALSE);
        }
    }

    /*
     * We have the basic share name in szShareName and the type is set.
     * Now look up that share.
     */
    wShareItemCnt = 0;
    uErrCode = wwNDdeShareGetInfoA(     /* probe for size */
            szShareName, 2, NULL, 0L,
            &dwShareBufSize, &wShareItemCnt,
            &nW, &nX, &nY, &nZ );
    if( !fAppNameIsShare && ((uErrCode == NDDE_SHARE_NOT_EXIST)
            || (uErrCode == NDDE_INVALID_SHARE)) ) {

        /*
         * For non-NDDE$ shares, try wild topic
         */
        wsprintf( szShareName, "%s|*", lpAppName );
        bWildTopic = TRUE;
        wShareItemCnt = 0; // reset to 0 after GetInfoA call
        uErrCode = wwNDdeShareGetInfoA( szShareName, 2,
                NULL, 0L, &dwShareBufSize, &wShareItemCnt,
                &nW, &nX, &nY, &nZ );
        if( ((uErrCode == NDDE_SHARE_NOT_EXIST)
                || (uErrCode == NDDE_INVALID_SHARE)) ) {
            /*
             * try wild app and topic
             */
            lstrcpy( szShareName, "*|*" );
            bWildApp = TRUE;
            wShareItemCnt = 0;  // reset to 0 after GetInfoA call
            uErrCode = wwNDdeShareGetInfoA( szShareName, 2,
                    NULL, 0L, &dwShareBufSize, &wShareItemCnt,
                    &nW, &nX, &nY, &nZ );
        }
    }

    if (uErrCode == NDDE_BUF_TOO_SMALL) {
        /*
         * allocate enough space for the share data.
         */
        lpShareInfo = HeapAllocPtr(hHeap, GMEM_MOVEABLE, dwShareBufSize);
        if (lpShareInfo == NULL) {
            dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
            return(FALSE);
        }

        wShareItemCnt = 0;  // why is this nessary?
        /*
         * get actual info now
         */
        uErrCode = wwNDdeShareGetInfoA(
                szShareName, 2, (LPBYTE) lpShareInfo,
                dwShareBufSize, &dwShareBufSize, &wShareItemCnt,
                &nW, &nX, &nY, &nZ );

        if (uErrCode != NDDE_NO_ERROR) { // !NO=YES - ERROR!
            ForceClearImpersonation();  // does wwNDdeShareGetInfo have a side effect?
            dwReasonInitFail = RIACK_SHARE_ACCESS_ERROR + uErrCode;
            /*  GetShareInfo Error: %1  */
            NDdeGetErrorString(uErrCode, tmpBuf, sizeof(tmpBuf));
            NDDELogError(MSG032, (LPSTR) tmpBuf, NULL);
            HeapFreePtr(lpShareInfo);
            lpShareInfo = NULL;
            return(FALSE);
        } else {
            /*
             * Make sure the share is shared or local.
             */
            if( !lpShareInfo->fSharedFlag &&
                    (dd_type != DDTYPE_LOCAL_LOCAL) )  {

                ForceClearImpersonation(); // does wwNDdeShareGetInfo have a side effect?
                dwReasonInitFail = RIACK_NOT_SHARED;
                /*  Share "%1" not shared   */
                NDDELogError(MSG033, szShareName, NULL);
                HeapFreePtr(lpShareInfo);
                lpShareInfo = NULL;
                return(FALSE);
            }
        }
    } else {
NoShareError:
        /*
         * Failed to find share.
         */
        ForceClearImpersonation(); // does wwNDdeShareGetInfo have a side effect?
        dwReasonInitFail = RIACK_SHARE_ACCESS_ERROR + uErrCode;
        /*  GetShareInfo "%1" Size Error: %2 / %3   */
        NDdeGetErrorString(uErrCode, tmpBuf, sizeof(tmpBuf));
        NDDELogError(MSG034, szShareName,
            LogString("%d", uErrCode), tmpBuf, NULL);
        return(FALSE);
    }

    /*
     * at this point, we have the share information from the DSDM
     * Extract the App and Topic names from the share info.
     */
    if (!GetShareAppTopic(lActualShareType,
                          lpShareInfo,
                          lpRsltAppName,
                          lpRsltTopicName)) {
        uErrCode = NDDE_SHARE_NOT_EXIST;
        goto NoShareError;
    }

    /*
     * For non NDDE$ appnames, overide the share app and topic names
     * wih * where appropriate.
     */
    if( !fAppNameIsShare )  {
        if( bWildApp )  {
            lstrcpy( lpRsltAppName, lpAppName );
        }
        if( bWildTopic )  {
            lstrcpy( lpRsltTopicName, lpTopicName );
        }
    }

    if( lActualShareType == SHARE_TYPE_NEW )  { // .ole
        char    szBuff[80];
        HKEY    hkStdFileEditing;

        /*
         * This is an OLE/NEW share.  we need to lookup the apropriate
         * server for the AppName(ie ClassName) requested and set up
         * the command line appropriately.
         */
        lpszCmdLine[0] = '\0';

        wsprintf(szBuff, "%s\\protocol\\StdFileEditing", lpRsltAppName );
        if (RegOpenKey(HKEY_CLASSES_ROOT, szBuff,
                &hkStdFileEditing) == ERROR_SUCCESS) {

            DWORD cb;

            cb = sizeof(szBuff);
            if (RegQueryValue(hkStdFileEditing,
                        "server", szBuff, (PLONG)&cb) == ERROR_SUCCESS ) {
                wsprintf( lpszCmdLine, "%s %s",
                        (LPSTR)szBuff, (LPSTR)lpRsltTopicName );
            }
            RegCloseKey(hkStdFileEditing);
        }
        // BUG? if the registry fails here don't we have to fail or is
        // a "" cmdline ok?
    } else {
        /*
         * OLD (dde) and STATIC (clipbrd) shares just use the the
         * share's app|topic pair.
         */
        wsprintf( lpszCmdLine, "%s %s", lpRsltAppName, lpRsltTopicName );
    }

    *lplpShareInfo = lpShareInfo;
    *lplActualShareType = lActualShareType;

    return(TRUE);
}



HIPC
IpcInitConversation(
    HDDER       hDder,
    LPDDEPKT    lpDdePkt,
    BOOL        bStartApp,
    LPSTR       lpszCmdLine,
    WORD        dd_type)
{
    LPDDEPKTINIT            lpDdePktInit    = (LPDDEPKTINIT) lpDdePkt;
    LPDDEPKTCMN             lpDdePktCmn     = (LPDDEPKTCMN) lpDdePkt;
    LPDDEPKTIACK            lpDdePktIack    = NULL;
    HWND                    hWndDDE         = 0;
    DWORD_PTR               dwResult;
    LPWININFO               lpWinInfo       = NULL;
    ATOM                    aApp, aTopic;
    LPBYTE                  lpSecurityKey   = NULL;
    DWORD                   sizeSecurityKey = 0L;
    HANDLE                  hClientAccessToken  = 0;
    PNDDESHAREINFO          lpShareInfo     = NULL;
    PQOS                    pQos            = NULL;
    LPSTR                   lpFromNode      = NULL;
    LPSTR                   lpFromApp       = NULL;
    LPSTR                   lpAppName       = NULL;
    LPSTR                   lpTopicName     = NULL;
    BOOL                    ok              = TRUE;
    BOOL                    bTriedExec      = FALSE;
    BOOL                    bConnected      = FALSE;
    char                    rsltAppName[ 256 ];
    char                    rsltTopicName[ 256 ];
    DWORD                   dwGrantedAccess = 0;
    LONG                    lActualShareType;
    HANDLE                  hAudit = NULL;
    DWORD                   ret;
    BOOL                    fGenerateOnClose = FALSE;
    BOOL                    fCallObjectCloseAuditAlarm = FALSE;
    BOOL                    bQos;
    LONG                    lErr;
    LONG                    shareSI = OWNER_SECURITY_INFORMATION |
                                      DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR    pShareSD;
    DWORD                   cbSDRequired;
    DWORD                   nSizeToReturn;
    PTHREADDATA             ptd;
    BOOL                    bReleaseShare = FALSE;

#if DBG
    if (bDebugDdePkts) {
        DPRINTF(("IpcInitConversation:"));
        DebugDdePkt( lpDdePkt );
    }
#endif // DBG

    lpAppName =   GetStringOffset( lpDdePkt, lpDdePktInit->dp_init_offsToApp);
    lpTopicName = GetStringOffset( lpDdePkt, lpDdePktInit->dp_init_offsToTopic);

    if( (lpDdePktInit->dp_init_offsFromNode != sizeof(DDEPKTINIT)) ||
        (lpDdePktInit->dp_init_sizePassword == 0) )  {

        /* always need a password for NT */
        dwReasonInitFail = RIACK_NEED_PASSWORD;
        ok = FALSE;
    }

    if( ok )  {
        lpFromNode = GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromNode);
        lpFromApp = GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromApp);
        /* do the reverse krypt */
        ok = DdeSecKeyRetrieve( lpDdePktInit->dp_init_hSecurityKey,
                    &lpSecurityKey, &sizeSecurityKey);
        if (ok) {
            ok = NDDEValidateLogon(
                lpSecurityKey,
                sizeSecurityKey,
                GetInitPktPassword(lpDdePktInit),
                GetInitPktPasswordSize(lpDdePktInit),
                GetInitPktUser(lpDdePktInit),
                GetInitPktDomain(lpDdePktInit),
                &hClientAccessToken );
#if DBG
            if (bDumpTokens) {
                DumpToken( hClientAccessToken );
                DPRINTF(( "ValidateLogon of \"%s\" \\ \"%s\": %d",
                    GetInitPktDomain(lpDdePktInit),
                    GetInitPktUser(lpDdePktInit), ok ));
            }
#endif // DBG
            if( !ok )  {
                dwReasonInitFail = RIACK_NEED_PASSWORD;
            }

        } else {
            dwReasonInitFail = RIACK_NEED_PASSWORD;
        }
    }

    if( ok )  {
        ok = MapShareInformation( dd_type, lpAppName, lpTopicName,
                rsltAppName, rsltTopicName, lpszCmdLine,
                    &lpShareInfo, &lActualShareType );
        if (lpShareInfo) {
            bReleaseShare = TRUE;
        }
#if DBG
        if (bDebugInfo) {
            DPRINTF(("%x MapShareInformation( dd_type: %d, lpAppName: %s, lpTopicName: %s,",
                lpShareInfo,
                dd_type, lpAppName, lpTopicName));
            if (ok) {
                DPRINTF(("     rsltAppName: %s, rsltTopicName: %s, lpszCmdLine: %s): OK",
                    rsltAppName, rsltTopicName, lpszCmdLine));
            } else {
                DPRINTF(("     ): FAILED"));
            }
        }
#endif // DBG
    }

    ptd = TlsGetValue(tlsThreadData);

    if( ok ) {
        /* at this point, we know the app/topic pair, the command
            line and we know the guy has a valid logon */
        hAudit = (HANDLE)hDder;
        assert( hAudit );

        /* let's get security descriptor */
        cbSDRequired = 0;
        ret = wwNDdeGetShareSecurityA(
            lpShareInfo->lpszShareName,
            shareSI,
            (PSECURITY_DESCRIPTOR)&cbSDRequired,    /* dummy to satisfy RPC */
            0,
            FALSE,
            &cbSDRequired,
            &nSizeToReturn);
        if (ret != NDDE_BUF_TOO_SMALL) {
            DPRINTF(("Unable to get share \"%s\" SD size: %d",
                lpShareInfo->lpszShareName, ret));
            dwReasonInitFail = RIACK_NOPERM;
            ok = FALSE;
        } else {
            pShareSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT, cbSDRequired);
            if (pShareSD == NULL) {
                MEMERROR();
                ret = NDDE_OUT_OF_MEMORY;
            } else {
                ret = wwNDdeGetShareSecurityA(
                    lpShareInfo->lpszShareName,
                    shareSI,
                    pShareSD,
                    cbSDRequired,
                    FALSE,
                    &cbSDRequired,
                    &nSizeToReturn);
            }
            if (ret != NDDE_NO_ERROR) {
                DPRINTF(("Unable to get share \"%s\" SD: %d",
                    lpShareInfo->lpszShareName, ret));
                dwReasonInitFail = RIACK_NOPERM;
                LocalFree(pShareSD);
                ok = FALSE;
            }
        }

        if (ok) {
            ForceImpersonate( hClientAccessToken );
#if DBG
            if (bDebugInfo) {
                DumpWhoIAm( "After ForceImpersonate" );
            }
#endif // DBG
            /* let's see what the guy is allowed to do */
            ok = DetermineAccess(
                lpShareInfo->lpszShareName,
                pShareSD,
                &dwGrantedAccess,
                (LPVOID) &hAudit,
                &fGenerateOnClose );
            lErr = GetLastError();
            ForceClearImpersonation();

            if( !ok )  {
                /*  Access Denied. Granted access = %1, Error code: %2  */
                NDDELogWarning(MSG035,
                    LogString("0x%0X", dwGrantedAccess),
                    LogString("%d", lErr), NULL);
                dwReasonInitFail = RIACK_NOPERM;
                LocalFree(pShareSD);
            } else {
                LocalFree(pShareSD);
                /* mark that we should audit the close */
                fCallObjectCloseAuditAlarm = TRUE;

                /* something is allowed */
                switch( lActualShareType )  {
                case SHARE_TYPE_OLD:
                case SHARE_TYPE_NEW:
                    if( (dwGrantedAccess & NDDE_SHARE_INITIATE_LINK) == 0)  {
                        dwReasonInitFail = RIACK_NOPERM;
                        ok = FALSE;
                    }
                    break;
                case SHARE_TYPE_STATIC:
                    if( (dwGrantedAccess & NDDE_SHARE_INITIATE_STATIC)==0)  {
                        dwReasonInitFail = RIACK_NOPERM;
                        ok = FALSE;
                    }
                    break;
                default:
                    /*  Unknown Share Type: %1  */
                    NDDELogError(MSG036,
                        LogString("0x%0X", lActualShareType), NULL);
                    ok = FALSE;
                    break;
                }
            }
        }
    }

    if (ok) {
        /* now we know that the client may be allowed to initiate */
        hWndDDE = CreateWindow( (LPSTR) szNetDDEIntf,
            (LPSTR) GetAppName(),
            WS_CHILD,
            0,
            0,
            0,
            0,
            (HWND) ptd->hwndDDE,
            (HMENU) NULL,
            (HANDLE) hInst,
            (LPSTR) NULL);

        if( hWndDDE )  {
            lpWinInfo = CreateWinInfo(lpFromNode,
                rsltAppName, rsltTopicName,
                lpFromApp, hWndDDE );
            if( lpWinInfo )  {
#ifdef LATER
//
// JimA - 1/2/94
//   This check is not great, because it affects services like clipsrv if no
//   one is logged on.
//
                if (!ptd->hwndDDEAgent) {
                    NDDELogError(MSG078, NULL);
                    ok = FALSE;
                }
#endif

                if (lpDdePktInit->dp_init_dwSecurityType != NT_SECURITY_TYPE) {
                    lpWinInfo->bWin16Connection = TRUE;
                }

                lpWinInfo->fCallObjectCloseAuditAlarm =
                    fCallObjectCloseAuditAlarm;
                lpWinInfo->fGenerateAuditOnClose = fGenerateOnClose;

                pQos = &lpWinInfo->qosClient;
                if (GetInitPktQos(lpDdePktInit, pQos) == NULL) {
                    pQos->Length = sizeof(QOS);
                    pQos->ImpersonationLevel = SecurityImpersonation;
                    pQos->ContextTrackingMode = SECURITY_STATIC_TRACKING;
                    pQos->EffectiveOnly = TRUE;
                }
                bQos = DdeSetQualityOfService( hWndDDE, &lpWinInfo->qosClient,
                    (PQOS)NULL);
                lpWinInfo->bServerSideOfNet = TRUE;
                lpWinInfo->wState = WST_WAIT_INIT_ACK;

                if( lActualShareType == SHARE_TYPE_STATIC )  {
                    /* for CLIPSRV static conversation ... don't do the
                        item name comparisons */
                    lpShareInfo->cNumItems = 0;
                }

                DderUpdatePermissions(hDder, lpShareInfo, dwGrantedAccess );

                bReleaseShare = FALSE;

                UpdateScreenState();
                lpWinInfo->hDder = hDder;

                /* don't do it on subsequent errors */
                fCallObjectCloseAuditAlarm = FALSE;
            } else {
                ok = FALSE;
                dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
            }
        } else {
            /*  Could not create client agent window on our node%\
                for client app "%1" on node "%2"    */
            NDDELogError(MSG037, lpFromApp, lpFromNode, NULL);
            ok = FALSE;
            dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
        }
    }

    if( ok )  {
        /* we can't start services, we can't start an app if no-one is
            logged in, and we can't start an app if there's no cmd line
            to start it with */
        if( !lpShareInfo->fStartAppFlag || lpShareInfo->fService )  {
            dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
            bStartApp = FALSE;
        } else if( (ptd->hwndDDEAgent == NULL) || (lpszCmdLine[0] == '\0') )  {
            dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
            bStartApp = FALSE;
        } else {
            bStartApp = TRUE;
        }

        if (!lpShareInfo->fService) {   /* if its not a service, ask agent */
            if( ptd->hwndDDEAgent ) {        /* agent must exist */
                uAgntExecRtn = (UINT)-1;
                RequestInit(ptd->hwndDDE, lpShareInfo);
                if( uAgntExecRtn == NDDEAGT_INIT_OK )  {
                    ok = TRUE;
                } else {
                    dwReasonInitFail = RIACK_NOPERM_TO_INITAPP;
                    ok = FALSE;
                }
            } else {
                ok = FALSE;
                dwReasonInitFail = RIACK_NO_NDDE_AGENT;
            }
        }
    }


    while( ok && !bConnected )  {

        aApp = GlobalAddAtomAndCheck(rsltAppName);
        aTopic = GlobalAddAtomAndCheck(rsltTopicName);
        if ((aApp == 0) || (aTopic == 0)) {
            /*  IpcInitConversation: null App "%1" or Topic "%2" atoms  */
            NDDELogWarning(MSG038, rsltAppName, rsltTopicName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }
#if DBG
        if( bDebugDDE )  {
            DebugDDEMessage( "sent", (HWND)-1, WM_DDE_INITIATE,
                (UINT_PTR) hWndDDE, MAKELONG(aApp, aTopic) );
        }
#endif // DBG
        lstrcpy( szInitiatingNode,
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromNode) );
        lstrcpy( szInitiatingApp,
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsFromApp) );
        EnterCrit();
        ptd = TlsGetValue(tlsThreadData);
        ptd->bInitiating = TRUE;
        LeaveCrit();

        /*  Broadcast DDE Initiate as the Client */
        ForceImpersonate( hClientAccessToken );
#if DBG
        if (bDebugInfo) {
            DumpWhoIAm( "After ForceImpersonate" );
        }
#endif // DBG
        SendMessageTimeout( HWND_BROADCAST,
                            WM_DDE_INITIATE,
                            (UINT_PTR)hWndDDE,
                            MAKELONG(aApp, aTopic),
                            SMTO_NORMAL,
                            15000,
                            &dwResult );
        ForceClearImpersonation();
#if DBG
        if (bDebugInfo) {
            DumpWhoIAm( "After ForceClearImpersonation" );
        }
#endif // DBG

        EnterCrit();
        ptd = TlsGetValue(tlsThreadData);
        ptd->bInitiating = FALSE;
        LeaveCrit();
        GlobalDeleteAtom( aApp );
        GlobalDeleteAtom( aTopic );
        if( lpWinInfo->hWndDDELocal )  {
            /* success */
            bConnected = TRUE;
            DDEWndAddToList( hWndDDE );

            /* mark that we rcvd the init packet */
            lpWinInfo->dwRcvd++;
            UpdateScreenStatistics();
        } else {
            DIPRINTF(("StartApp: %d, TriedExec: %d, CmdLine: %Fs",
                    bStartApp, bTriedExec, lpszCmdLine));
            // security info was to not start the app or we already
            // tried starting it w/o success
            if( !bStartApp || bTriedExec )  {
                if( bTriedExec )  {
                    dwReasonInitFail = RIACK_NORESP_AFTER_STARTAPP;
                } else {
                    dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
                }
                ok = FALSE;
            } else {
                if( bStartApp )  {
                    if( ptd->hwndDDEAgent ) {
                        bTriedExec = TRUE;
                        uAgntExecRtn = (UINT)-1;
                        RequestExec(ptd->hwndDDE, lpszCmdLine, lpShareInfo);
                        if( uAgntExecRtn < 32 )  {
                            /*  EXEC of "%1" failed: status = %2    */
                            NDDELogError(MSG039, lpszCmdLine,
                                    LogString("%d", uAgntExecRtn), NULL);
                            ok = FALSE;
                            dwReasonInitFail = RIACK_STARTAPP_FAILED;
                        } else if( uAgntExecRtn == (UINT)-1 )  {
                            /*  EXEC of "%1" failed: unknown status!    */
                            NDDELogError(MSG040, lpszCmdLine, NULL);
                            /* try to initiate anyway */
                        }
                    } else {
                        ok = FALSE;
                        dwReasonInitFail = RIACK_NO_NDDE_AGENT;
                    }
                } else {
                    ok = FALSE;
                    dwReasonInitFail = RIACK_NOPERM_TO_STARTAPP;
                }
            }
        }
    }

    if( ok )  {
        lpDdePktIack = (LPDDEPKTIACK) CreateAckInitiatePkt( ourNodeName,
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToApp),
            GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToTopic),
            NULL, 0L, 0,
            TRUE, dwReasonInitFail );           /* ACK Conv, no key needed */
        if( lpDdePktIack )  {
            lpWinInfo->dwSent++;
            UpdateScreenStatistics();
            lpDdePktIack->dp_iack_dwSecurityType = NT_SECURITY_TYPE;
            DderPacketFromIPC( lpWinInfo->hDder, (HIPC) hWndDDE,
                (LPDDEPKT) lpDdePktIack );
        } else {
            dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
            ok = FALSE;
        }
    }

    if( !ok )  {
        if( hWndDDE )  {
            if( lpWinInfo )  {
                /* this prevents us from freeing the DDER twice */
                lpWinInfo->hDder = 0;
            }
            DestroyWindow( hWndDDE );
            hWndDDE = 0;
        }
    }

    if( fCallObjectCloseAuditAlarm )  {
        assert( hAudit );
        ObjectCloseAuditAlarm( NDDE_AUDIT_SUBSYSTEM, (LPVOID)&hAudit,
            fGenerateOnClose );
        fCallObjectCloseAuditAlarm = FALSE;
    }


    if( hClientAccessToken )  {
        CloseHandle( hClientAccessToken );
        hClientAccessToken = NULL;
    }
    UpdateScreenState();

    if (bReleaseShare) {
        OutputDebugString("\nlpShareInfo released\n\n");
        HeapFreePtr(lpShareInfo);
    }

    return( (HIPC) hWndDDE );
}


/*
    IpcAbortConversation()

        This function is called from DDER whenever the connection is broken,
        or internally whenever an ACK_INITIATE is FALSE.
 */
VOID
IpcAbortConversation( HIPC hIpc )
{
    HWND        hWndDDE;
    LPWININFO   lpWinInfo;

    DIPRINTF(( "IpcAbortConversation( %08lX )", hIpc ));
    hWndDDE = (HWND) hIpc;
    assert( hWndDDE );
    assert( IsWindow( hWndDDE ) );
    lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
    if (lpWinInfo == NULL)
        return;

    /* don't use the hDder after we get this notification */
    lpWinInfo->hDder = 0;

    /* pretend we sent and rcvd net terminates */
    lpWinInfo->bRcvdTerminateNet = TRUE;
    lpWinInfo->bSentTerminateNet = TRUE;

    /* do rest of terminate logic */
    SendMessage( lpWinInfo->hWndDDE,wMsgDoTerminate,0,(LPARAM)lpWinInfo );
}


VOID
FAR PASCAL
DoTerminate( LPWININFO lpWinInfo )
{
    WORD        wStateInitially;
    LPDDEPKTCMN lpDdePktCmn;
    LPDDEPKT    lpDdePktTerm;

    /* remember what state we were in */
    wStateInitially = lpWinInfo->wState;

    /* pre-mark that we're terminated */
    lpWinInfo->wState = WST_TERMINATED;
    UpdateScreenState();

    /*
     * NACK first the queued messages.
     */
    DeleteQueuedMessages( lpWinInfo );

    /* if necessary, sent TERMINATE to local task */
    if( lpWinInfo->bRcvdTerminateNet && !lpWinInfo->bSentTerminateLocally ) {
        PostMessage(lpWinInfo->hWndDDELocal,WM_DDE_TERMINATE,(WPARAM)lpWinInfo->hWndDDE,0);
        lpWinInfo->bSentTerminateLocally = TRUE;
    }

    /* if necessary, sent TERMINATE to remote network */
    /* although, we don't want to send it if we're still waiting for net
        init ack, or if termination is complete */

    if (wStateInitially != WST_WAIT_NET_INIT_ACK &&
        wStateInitially != WST_TERMINATION_COMPLETE &&
        lpWinInfo->bRcvdTerminateLocally &&
        !lpWinInfo->bSentTerminateNet) {

        lpWinInfo->bSentTerminateNet = TRUE;
        if( lpWinInfo->hDder )  {
            /* send the terminate to the network */
            lpDdePktCmn = (LPDDEPKTCMN) lpWinInfo->lpDdePktTerminate;
            ((LPDDEPKT)lpDdePktCmn)->dp_size = sizeof(DDEPKTTERM);
            lpDdePktCmn->dc_message = WM_DDE_TERMINATE;
            lpWinInfo->dwSent++;
            UpdateScreenStatistics();
            lpDdePktTerm = lpWinInfo->lpDdePktTerminate;
            /* make sure we don't free it */
            lpWinInfo->lpDdePktTerminate = NULL;
            DderPacketFromIPC( lpWinInfo->hDder, (HIPC) lpWinInfo->hWndDDE,
                lpDdePktTerm );
        }
    }

    /* if all 4 messages were sent and received, nobody is interested in us
        any more and we should free ourselves */
    if(    lpWinInfo->bRcvdTerminateNet
        && lpWinInfo->bSentTerminateNet
        && lpWinInfo->bRcvdTerminateLocally
        && lpWinInfo->bSentTerminateLocally )  {

        // 322098 (broken by 153542)
        lpWinInfo->wState = WST_TERMINATION_COMPLETE;

        /* got and sent all terminates ... free us */
        DestroyWindow( lpWinInfo->hWndDDE );
        CheckAllTerminations();
    }
}

BOOL
IpcXmitPacket(
    HIPC        hIpc,
    HDDER       hDder,
    LPDDEPKT    lpDdePkt )
{
    LPDDEPKTCMN         lpDdePktCmn;
    HWND                hWndDDE;
    HANDLE              hData;
    LPSTR               lpData;
    LPDDELN             lpOptions;
    LPSTR               lpszItemName;
    DDEQENT             DDEQEnt;
    DDEQENT             DDEQEntRmv;
    LPWININFO           lpWinInfo;
    LPDDEPKTIACK        lpDdePktIack;
    LPDDEPKTEACK        lpDdePktEack;
    LPDDEPKTGACK        lpDdePktGack;
    LPDDEPKTEXEC        lpDdePktExec;
    LPDDEPKTRQST        lpDdePktRqst;
    LPDDEPKTUNAD        lpDdePktUnad;
    LPDDEPKTDATA        lpDdePktData;
    LPDDEPKTPOKE        lpDdePktPoke;
    LPDDEPKTADVS        lpDdePktAdvs;
    BOOL                bRemoved;
    BOOL                bLocalWndValid;
    BOOL                bRtn = TRUE;
    WORD                wStatus;
    WORD                cfFormat;
    ATOM                aItem;

#if DBG
    DIPRINTF(( "IpcXmitPacket( %08lX, %08lX, %08lX )", hIpc,
            hDder, lpDdePkt ));
    DebugDdePkt( lpDdePkt );
#endif // DBG
    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;

    hWndDDE = (HWND) hIpc;
    if( hWndDDE && IsWindow( hWndDDE ) )  {
        if (GetWindowThreadProcessId(hWndDDE, NULL) != GetCurrentThreadId()) {
            IPCXMIT ix;

            ix.hIpc = hIpc;
            ix.hDder = hDder;
            ix.lpDdePkt = lpDdePkt;
            return SendMessage(GetParent(hWndDDE),
                               wMsgIpcXmit,
                               (DWORD_PTR)&ix,
                               0) != FALSE;
        }
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
        lpWinInfo->dwRcvd++;
        UpdateScreenStatistics();
    } else {
        /*  Message: %1 to a non-existent window: %2    */
        NDDELogError(MSG041,
            LogString("0x%0X", lpDdePktCmn->dc_message),
            LogString("0x%0X", hWndDDE), NULL);
        HeapFreePtr( lpDdePkt );
        return( FALSE );
    }

    /* check if our partner is still around */
    bLocalWndValid = IsWindow( lpWinInfo->hWndDDELocal );

    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_ACK_INITIATE:
        lpDdePktIack = (LPDDEPKTIACK) lpDdePkt;
        if( lpDdePktIack->dp_iack_fromDder )  {
            /* successful initiate */
            if( lpWinInfo->hDder && (lpWinInfo->hDder != hDder) )  {
                /*  INTERNAL ERROR -- IpcXmitPacket %1 hDder handles should match %2 */
                NDDELogError(MSG043,
                    LogString("0x%0X", hDder),
                    LogString("0x%0X", lpWinInfo->hDder), NULL );
#if DBG
                if (bDebugInfo) {
                    DebugDdeIntfState();
                    DebugDderState();
                    DebugRouterState();
                    DebugPktzState();
                    DPRINTF(( "" ));
                }
#endif // DBG
            }
            lpWinInfo->hDder = hDder;
            if( lpWinInfo->wState == WST_TERMINATED )  {
                /* terminate came in locally while we were waiting for net
                    init ack */
                SendMessage(lpWinInfo->hWndDDE,wMsgDoTerminate,0,(LPARAM)lpWinInfo);
            } else {
                /* notify the local window that the ack is back */
                if( lpWinInfo->hWndDDELocal
                        && IsWindow(lpWinInfo->hWndDDELocal) )  {
                    SendMessage( lpWinInfo->hWndDDELocal,
                        wMsgInitiateAckBack, (UINT_PTR)lpWinInfo->hWndDDE, 0L );
                }
                lpWinInfo->wState = WST_OK;
                lpWinInfo->dwSecurityType = lpDdePktIack->dp_iack_dwSecurityType;
                if (lpWinInfo->dwSecurityType != NT_SECURITY_TYPE) {
                    lpWinInfo->bWin16Connection = TRUE;
                }
                UpdateScreenState();
//DPRINTF(( "ack back ... bInitiating: %d", lpWinInfo->bInitiating ));
                if( !lpWinInfo->bInitiating )  {
                    SendQueuedMessages( hWndDDE, lpWinInfo );
                }
            }
        } else {
//DPRINTF(( "init nack: reason: %d", lpDdePktIack->dp_iack_reason ));
            if( (++lpWinInfo->nInitNACK > MAX_INIT_NACK)
                   || (lpDdePktIack->dp_iack_reason != RIACK_NEED_PASSWORD)) {
                /* notify the local window that the ack is back */
                if( lpWinInfo->hWndDDELocal
                        && IsWindow(lpWinInfo->hWndDDELocal) )  {
                    SendMessage( lpWinInfo->hWndDDELocal,
                        wMsgInitiateAckBack, (UINT_PTR)lpWinInfo->hWndDDE,
                        lpDdePktIack->dp_iack_reason );
                }

                /* unsuccessfull initiate */
                IpcAbortConversation( hIpc );
            } else {
                lpWinInfo->dwSecurityType = lpDdePktIack->dp_iack_dwSecurityType;
                if (lpWinInfo->sizeSecurityKeyRcvd =
                    lpDdePktIack->dp_iack_sizeSecurityKey) {
                    /* received a security key for password */
                    lpWinInfo->lpSecurityKeyRcvd = HeapAllocPtr( hHeap,
                        GMEM_MOVEABLE, lpWinInfo->sizeSecurityKeyRcvd);
                    if (lpWinInfo->lpSecurityKeyRcvd) {
                        lpWinInfo->hSecurityKeyRcvd =
                            lpDdePktIack->dp_iack_hSecurityKey;
                        hmemcpy(lpWinInfo->lpSecurityKeyRcvd,
                            GetStringOffset( lpDdePkt,
                                lpDdePktIack->dp_iack_offsSecurityKey),
                            lpWinInfo->sizeSecurityKeyRcvd);
                    } else {
                        lpWinInfo->sizeSecurityKeyRcvd = 0;
                    }
                }

                if (!PostMessage( hWndDDE, WM_HANDLE_DDE_INITIATE, 0, 0L) ) {
                    /* abort the conversation */
                    IpcAbortConversation( (HIPC)hWndDDE );
                }
            }
        }
        break;

    case WM_DDE_TERMINATE:
        /* mark that we got a terminate from the net */
        lpWinInfo->bRcvdTerminateNet = TRUE;
        SendMessage(lpWinInfo->hWndDDE,wMsgDoTerminate,0,(LPARAM)lpWinInfo);
        break;

    case WM_DDE_EXECUTE:
        lpDdePktExec = (LPDDEPKTEXEC) lpDdePkt;
        hData = GetGlobalAlloc(
            GMEM_MOVEABLE | GMEM_DDESHARE,
            lstrlen( lpDdePktExec->dp_exec_string )+1 );
        if( hData )  {
            lpData = GlobalLock( hData );
            if( lpData )  {
                lstrcpy( lpData, lpDdePktExec->dp_exec_string );
                GlobalUnlock( hData );
                DDEQEnt.wMsg            = WM_DDE_EXECUTE - WM_DDE_FIRST;
                DDEQEnt.fRelease        = FALSE;
                DDEQEnt.fAckReq         = FALSE;
                DDEQEnt.fResponse       = FALSE;
                DDEQEnt.fNoData         = FALSE;
                DDEQEnt.hData           = (ULONG_PTR)hData;
                if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
                    bRtn = FALSE;
                }
                if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
                    if( !PostMessage( lpWinInfo->hWndDDELocal,
                                      WM_DDE_EXECUTE,
                                      (UINT_PTR)lpWinInfo->hWndDDE,
                                      PackDDElParam( WM_DDE_EXECUTE,
                                                     (WPARAM)NULL,
                                                     (LPARAM)hData) ) ) {
                        bRtn = FALSE;
                        GlobalFree(hData);
                    }
                } else {
                    GlobalFree(hData);
                }

            } else {
                /*  Lock failed for %1 memory alloc */
                NDDELogError(MSG044, "WM_DDE_EXECUTE", NULL);
                bRtn = FALSE;
            }
        } else {
            MEMERROR();
            /*  Not enough memory for %1 bytes msg: WM_DDE_EXECUTE */
            NDDELogError(MSG045,
                LogString("%d", lstrlen( lpDdePktExec->dp_exec_string )+1), NULL);
            bRtn = FALSE;
        }
        break;

    case WM_DDE_REQUEST:
        lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
        wStatus = 0;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktRqst->dp_rqst_cfFormat,
            lpDdePktRqst->dp_rqst_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktRqst->dp_rqst_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(REQUEST): null Item atom for "%1" */
            NDDELogWarning(MSG046, lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        DDEQEnt.wMsg            = WM_DDE_REQUEST - WM_DDE_FIRST;
        DDEQEnt.fRelease        = FALSE;
        DDEQEnt.fAckReq         = FALSE;
        DDEQEnt.fResponse       = FALSE;
        DDEQEnt.fNoData         = FALSE;
        DDEQEnt.hData           = 0;

        if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
            return( FALSE );
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                              WM_DDE_REQUEST,
                              (UINT_PTR)lpWinInfo->hWndDDE,
                               PackDDElParam( WM_DDE_REQUEST,
                                              cfFormat,
                                              aItem) ) )  {
                bRtn = FALSE;
            }
        }
        break;

    case WM_DDE_UNADVISE:
        lpDdePktUnad = (LPDDEPKTUNAD) lpDdePkt;
        wStatus = 0;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktUnad->dp_unad_cfFormat,
            lpDdePktUnad->dp_unad_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktUnad->dp_unad_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "UNADVISE", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        DDEQEnt.wMsg            = WM_DDE_UNADVISE - WM_DDE_FIRST;
        DDEQEnt.fRelease        = FALSE;
        DDEQEnt.fAckReq         = FALSE;
        DDEQEnt.fResponse       = FALSE;
        DDEQEnt.fNoData         = FALSE;
        DDEQEnt.hData           = 0;

        if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
            return( FALSE );
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                WM_DDE_UNADVISE, (UINT_PTR)lpWinInfo->hWndDDE,
                PackDDElParam(WM_DDE_UNADVISE,cfFormat,aItem) ) )  {
                bRtn = FALSE;
            }
        }
        break;

    case WM_DDE_DATA:
        lpDdePktData = (LPDDEPKTDATA) lpDdePkt;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktData->dp_data_cfFormat,
            lpDdePktData->dp_data_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "DATA", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        if( lpDdePktData->dp_data_sizeData == 0L )  {
            hData = 0;
        } else {
            switch (cfFormat) {
                case CF_METAFILEPICT:
                    hData = ConvertPktToDataMetafile( lpDdePkt,
                        lpDdePktData, lpWinInfo->bWin16Connection  );
                    break;
                case CF_BITMAP:
                    hData = ConvertPktToDataBitmap( lpDdePkt,
                        lpDdePktData, lpWinInfo->bWin16Connection  );
                    break;
                case CF_ENHMETAFILE:
                    hData = ConvertPktToDataEnhMetafile( lpDdePkt, lpDdePktData );
                    break;
                case CF_PALETTE:
                    hData = ConvertPktToDataPalette( lpDdePkt, lpDdePktData );
                    break;
                case CF_DIB:
                    hData = ConvertPktToDataDIB( lpDdePkt, lpDdePktData );
                    break;
                default:
                    if (cfFormat == cfPrinterPicture )  {
                        hData = ConvertPktToDataMetafile( lpDdePkt,
                            lpDdePktData, lpWinInfo->bWin16Connection  );
                    } else {
                        hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
                            lpDdePktData->dp_data_sizeData+sizeof(DDELN) );
                        lpData = GlobalLock( hData );
                        if( lpData )  {
                            hmemcpy( ((LPDATA)lpData)->info,
                                GetStringOffset( lpDdePkt,
                                    lpDdePktData->dp_data_offsData ),
                                    lpDdePktData->dp_data_sizeData );
                            GlobalUnlock(hData);
                        } else {
                            MEMERROR();
                        }
                    }
                    break;
            }

            if( hData == 0 )  {
                return( FALSE );
            }

            lpData = GlobalLock( hData );
            if( lpData )  {
                /* zero out the DDELN structure */
                _fmemset( lpData, 0, sizeof(DDELN) );
                ((LPDDELN)lpData)->fResponse = lpDdePktData->dp_data_fResponse;
                ((LPDDELN)lpData)->fAckReq = lpDdePktData->dp_data_fAckReq;
                ((LPDDELN)lpData)->fRelease = TRUE;
                ((LPDDELN)lpData)->cfFormat = cfFormat;

                if( ((LPDDELN)lpData)->fResponse )  {
                    GlobalDeleteAtom( (ATOM)aItem );
                    DDEQRemove( lpWinInfo->qDDEOutgoingCmd, &DDEQEntRmv );
                    if( DDEQEntRmv.wMsg != (WM_DDE_REQUEST - WM_DDE_FIRST) ) {
                        /*  %1 from DDE Server "%2" not matching %3: %4   */
                        NDDELogWarning(MSG026, "WM_DDE_DATA",
                            (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName),
                            "REQUEST",
                            LogString("0x%0X", DDEQEntRmv.wMsg + WM_DDE_FIRST), NULL );
                    }
                }
                if( ((LPDDELN)lpData)->fAckReq )  {
                    DDEQEnt.wMsg        = WM_DDE_DATA - WM_DDE_FIRST;
                    DDEQEnt.fRelease    = TRUE;
                    DDEQEnt.fAckReq     = ((LPDDELN)lpData)->fAckReq;
                    DDEQEnt.fResponse   = ((LPDDELN)lpData)->fResponse;
                    DDEQEnt.fNoData     = FALSE;
                    DDEQEnt.hData       = (ULONG_PTR)hData;
                    if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
                        return( FALSE );
                    }
                }
                GlobalUnlock( hData );
            } else {
                /*  Lock failed for %1 memory alloc */
                NDDELogError(MSG044, "WM_DDE_DATA", NULL);
                return( FALSE );
            }
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                              WM_DDE_DATA,
                              (UINT_PTR)lpWinInfo->hWndDDE,
                PackDDElParam( WM_DDE_DATA,
                               (UINT_PTR)hData,
                               aItem) ) )  {
                bRtn = FALSE;
                GlobalFreehData(hData);
            }
        } else {
            GlobalFreehData(hData);
        }
        break;

    case WM_DDE_POKE:
        lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktPoke->dp_poke_cfFormat,
            lpDdePktPoke->dp_poke_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktPoke->dp_poke_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "POKE", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        if( lpDdePktPoke->dp_poke_sizeData == 0L )  {
            hData = 0;
        } else {
            switch (cfFormat) {
                case CF_METAFILEPICT:
                    hData = ConvertPktToDataMetafile( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke, lpWinInfo->bWin16Connection  );
                    break;
                case CF_BITMAP:
                    hData = ConvertPktToDataBitmap( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke, lpWinInfo->bWin16Connection  );
                    break;
                case CF_ENHMETAFILE:
                    hData = ConvertPktToDataEnhMetafile( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke );
                    break;
                case CF_PALETTE:
                    hData = ConvertPktToDataPalette( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke );
                    break;
                case CF_DIB:
                    hData = ConvertPktToDataDIB( lpDdePkt,
                        (LPDDEPKTDATA) lpDdePktPoke );
                    break;
                default:
                    if (cfFormat == cfPrinterPicture )  {
                        hData = ConvertPktToDataMetafile( lpDdePkt,
                            (LPDDEPKTDATA) lpDdePktPoke, lpWinInfo->bWin16Connection  );
                    } else {
                        hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
                            lpDdePktPoke->dp_poke_sizeData+sizeof(DDELN) );
                        lpData = GlobalLock( hData );
                        if( lpData )  {
                            hmemcpy( ((LPDATA)lpData)->info,
                                GetStringOffset( lpDdePkt,
                                    lpDdePktPoke->dp_poke_offsData ),
                                    lpDdePktPoke->dp_poke_sizeData );
                            GlobalUnlock(hData);
                        } else {
                            MEMERROR();
                        }
                    }
                    break;
            }

            if( hData == 0 )  {
                return( FALSE );
            }

            lpData = GlobalLock( hData );
            if( lpData )  {
                /* zero out the DDELN structure */
                assert( sizeof(DDELN) == sizeof(LONG) );
                * ((LONG FAR *)lpData) = 0L;

                ((LPDDELN)lpData)->fRelease = TRUE;
                ((LPDDELN)lpData)->cfFormat = cfFormat;

                assert( lpWinInfo->bServerSideOfNet );
                DDEQEnt.wMsg = WM_DDE_POKE - WM_DDE_FIRST;
                DDEQEnt.fRelease        = TRUE;
                DDEQEnt.fAckReq         = FALSE;
                DDEQEnt.fResponse       = FALSE;
                DDEQEnt.fNoData         = FALSE;
                DDEQEnt.hData           = (ULONG_PTR)hData;
                if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
                    return( FALSE );
                }

                GlobalUnlock( hData );
            } else {
                /*  Lock failed for %1 memory alloc */
                NDDELogError(MSG044, "WM_DDE_POKE", NULL);
                return( FALSE );
            }
        }
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                WM_DDE_POKE, (UINT_PTR)lpWinInfo->hWndDDE,
                PackDDElParam( WM_DDE_POKE,
                               (UINT_PTR)hData,
                               aItem) ) )  {
                bRtn = FALSE;
                GlobalFreehData(hData);
            }
        } else {
            GlobalFreehData(hData);
        }
        break;

    case WM_DDE_ADVISE:
        lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
        cfFormat = GetClipFormat( lpDdePkt, lpDdePktAdvs->dp_advs_cfFormat,
            lpDdePktAdvs->dp_advs_offsFormat );
        lpszItemName = GetStringOffset( lpDdePkt,
            lpDdePktAdvs->dp_advs_offsItemName );
        aItem = GlobalAddAtomAndCheck( lpszItemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "ADVISE", lpszItemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }

        hData = GetGlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE,
            (DWORD)sizeof(DDELN) );
        if( hData == 0 )  {
            MEMERROR();
            return( FALSE );
        }

        lpOptions = (LPDDELN) GlobalLock( hData );
        if( lpOptions )  {

            /* zero out the DDELN structure */
            assert( sizeof(DDELN) == sizeof(LONG) );
            * ((LONG FAR *)lpOptions) = 0L;

            /* copy in options */
            lpOptions->fAckReq = lpDdePktAdvs->dp_advs_fAckReq;
            lpOptions->fNoData = lpDdePktAdvs->dp_advs_fNoData;
            lpOptions->cfFormat = cfFormat;
            GlobalUnlock( hData );
        } else {
            /*  Lock failed for %1 memory alloc */
            NDDELogError(MSG044, "WM_DDE_ADVISE", NULL);
            return( FALSE );
        }

        assert( lpWinInfo->bServerSideOfNet );
        DDEQEnt.wMsg = WM_DDE_ADVISE - WM_DDE_FIRST;
        DDEQEnt.fRelease        = FALSE;
        DDEQEnt.fAckReq         = lpOptions->fAckReq;
        DDEQEnt.fResponse       = FALSE;
        DDEQEnt.fNoData         = lpOptions->fNoData;
        DDEQEnt.hData           = (ULONG_PTR)hData;
        if( !DDEQAdd( lpWinInfo->qDDEIncomingCmd, &DDEQEnt ) )  {
            return( FALSE );
        }

        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                WM_DDE_ADVISE, (UINT_PTR)lpWinInfo->hWndDDE,
                PackDDElParam( WM_DDE_ADVISE,
                               (UINT_PTR)hData,
                               aItem) ) )  {
                bRtn = FALSE;
                GlobalFree(hData);
            }
        } else {
            GlobalFreehData(hData);
        }
        break;

    case WM_DDE_ACK_EXECUTE:
        lpDdePktEack = (LPDDEPKTEACK) lpDdePkt;
        bRemoved = DDEQRemove( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt );
        if( !bRemoved )  {
            /*  Extraneous %1 from DDE Client "%2"  */
            NDDELogWarning(MSG023, "WM_DDE_ACK_EXECUTE",
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName), NULL);
        } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_EXECUTE )  {
            /*  %1 from DDE Server "%2" not matching %3: %4   */
            NDDELogWarning(MSG026, "WM_DDE_ACK_EXECUTE",
                (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName),
                "DATA",
                LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST), NULL );
        } else {
            wStatus = 0;
            if( lpDdePktEack->dp_eack_fAck )  {
                wStatus |= ACK_MSG;
            } else {
                wStatus |= NACK_MSG;
            }
            if( lpDdePktEack->dp_eack_fBusy )  {
                wStatus |= BUSY_MSG;
            }
            wStatus |= lpDdePktEack->dp_eack_bAppRtn;
            if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
                if( !PostMessage( lpWinInfo->hWndDDELocal,
                    WM_DDE_ACK, (UINT_PTR)lpWinInfo->hWndDDE,
                    PackDDElParam(WM_DDE_ACK,wStatus,DDEQEnt.hData) ) )  {
                    bRtn = FALSE;
                }
            }
        }
        break;

    case WM_DDE_ACK_ADVISE:
    case WM_DDE_ACK_REQUEST:
    case WM_DDE_ACK_UNADVISE:
    case WM_DDE_ACK_POKE:
    case WM_DDE_ACK_DATA:
        lpDdePktGack = (LPDDEPKTGACK) lpDdePkt;
        bRemoved = DDEQRemove( lpWinInfo->qDDEOutgoingCmd, &DDEQEnt );
        wStatus = 0;
        if( lpDdePktGack->dp_gack_fAck )  {
            wStatus |= ACK_MSG;
        } else {
            wStatus |= NACK_MSG;
        }
        if( lpDdePktGack->dp_gack_fBusy )  {
            wStatus |= BUSY_MSG;
        }
        wStatus |= lpDdePktGack->dp_gack_bAppRtn;

        /* keep atom use count same */
        aItem = GlobalAddAtomAndCheck( lpDdePktGack->dp_gack_itemName );
        if (aItem == 0) {
            /*  IpcXmitPacket(%1): null Item atom for "%2" */
            NDDELogWarning(MSG046, "ACK", lpDdePktGack->dp_gack_itemName, NULL);
#if DBG
            if (bDebugInfo) {
                debug_srv_client(hWndDDE, lpWinInfo);
            }
#endif // DBG
        }
        GlobalDeleteAtom( (ATOM)aItem );

        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ACK_ADVISE:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "ADVISE",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_ADVISE )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "ADVISE",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            } else {
                if( bLocalWndValid && (wStatus & ACK_MSG) )  {
                    if( DDEQEnt.hData )  {
                        GlobalFree( (HANDLE)DDEQEnt.hData );
                    }
                }
            }
            break;
        case WM_DDE_ACK_REQUEST:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "REQUEST",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_REQUEST )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "REQUEST",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            }
            break;
        case WM_DDE_ACK_UNADVISE:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "UNADVISE",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_UNADVISE )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "UNADVISE",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            }
            break;
        case WM_DDE_ACK_POKE:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "POKE",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_POKE )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "POKE",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            } else {
                if( bLocalWndValid && DDEQEnt.fRelease && (wStatus & ACK_MSG) ) {
                    if( DDEQEnt.hData )  {
                        GlobalFreehData( (HANDLE)DDEQEnt.hData );
                    }
                }
            }
            break;
        case WM_DDE_ACK_DATA:
            if( !bRemoved )  {
                /*  Extraneous ACK apparently to an %1.%\
                    From "%2" client -> "%3" app    */
                NDDELogWarning(MSG047, "DATA",
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsClientName),
                    (LPSTR)(((LPSTR)lpWinInfo) + lpWinInfo->offsAppName), NULL );
            } else if( (DDEQEnt.wMsg + WM_DDE_FIRST) != WM_DDE_DATA )  {
                /*  %1 ACK not to an %1 [%2]%\
                    From "%3" client -> "%4" app    */
                NDDELogWarning(MSG048, "DATA",
                    LogString("0x%0X", DDEQEnt.wMsg + WM_DDE_FIRST),
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
                    ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName, NULL );
            } else {
                if( bLocalWndValid && DDEQEnt.fRelease && (wStatus &ACK_MSG) ) {
                    if( DDEQEnt.hData )  {
                        GlobalFreehData( (HANDLE)DDEQEnt.hData );
                    }
                }
            }
            break;
        }

        /* post message to local DDE window */
        if( bLocalWndValid && !lpWinInfo->bSentTerminateLocally )  {
            if( !PostMessage( lpWinInfo->hWndDDELocal,
                WM_DDE_ACK,
                (UINT_PTR)lpWinInfo->hWndDDE,
                PackDDElParam(WM_DDE_ACK,wStatus,aItem) ) )  {
                bRtn = FALSE;
            }
        }
        break;

    default:
        NDDELogError(MSG049,
            LogString("0x%0X", lpDdePktCmn->dc_message), NULL);
        bRtn = FALSE;
    }

    /* free the packet */
    HeapFreePtr( lpDdePkt );

    return( bRtn );
}

VOID
FAR PASCAL
CheckAllTerminations( void )
{
}

LPWININFO
FAR PASCAL
CreateWinInfo(
    LPSTR   lpszNode,
    LPSTR   lpszApp,
    LPSTR   lpszTopic,
    LPSTR   lpszClient,
    HWND    hWndDDE )
{
    LPWININFO   lpWinInfo;
    BOOL        ok = TRUE;
    DWORD       size;

    AnsiUpper( lpszNode );
    AnsiUpper( lpszApp );
    AnsiUpper( lpszTopic );
    AnsiUpper( lpszClient );

    lpWinInfo = HeapAllocPtr( hHeap,
        GMEM_MOVEABLE | GMEM_ZEROINIT, size = (DWORD) sizeof(WININFO)
            + lstrlen(lpszNode) + 1
            + lstrlen(lpszApp) + 1
            + lstrlen(lpszTopic) + 1
            + lstrlen(lpszClient) + 1 );
    if( lpWinInfo )  {
        SetWindowLongPtr( hWndDDE, 0, (LONG_PTR) lpWinInfo );
        lpWinInfo->szUserName[0]        = '\0';
        lpWinInfo->szDomainName[0]      = '\0';
        lpWinInfo->szPassword[0]        = '\0';
        lpWinInfo->bWin16Connection     = FALSE;
        lpWinInfo->hWndDDE              = hWndDDE;
        lpWinInfo->lpSecurityKeyRcvd    = NULL;
        lpWinInfo->sizeSecurityKeyRcvd  = 0;
        lpWinInfo->nInitNACK            = 0;
        lpWinInfo->qDDEIncomingCmd      = DDEQAlloc();
        lpWinInfo->qDDEOutgoingCmd      = DDEQAlloc();
        if( (lpWinInfo->qDDEIncomingCmd == 0)
            || (lpWinInfo->qDDEOutgoingCmd == 0) )  {
            ok = FALSE;
        }

        /* copy in app, topic and client names */
        lstrcpy( lpWinInfo->data, lpszApp );
        lpWinInfo->offsAppName =
            (WORD)((LPSTR)&lpWinInfo->data[0] - (LPSTR)lpWinInfo);

        lpWinInfo->offsNodeName = lpWinInfo->offsAppName +
            lstrlen(lpszApp) + 1;
        lstrcpy( ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName,
            lpszNode );

        lpWinInfo->offsTopicName = lpWinInfo->offsNodeName +
            lstrlen(lpszNode) + 1;
        lstrcpy( ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName,
            lpszTopic );

        lpWinInfo->offsClientName = lpWinInfo->offsTopicName +
            lstrlen(lpszTopic) + 1;
        lstrcpy( ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
            lpszClient );

        /* assure that we have enough memory for the terminate packet */
        lpWinInfo->lpDdePktTerminate = (LPDDEPKT) HeapAllocPtr( hHeap,
            GMEM_MOVEABLE, (DWORD) sizeof(DDEPKTTERM) );
        if( !lpWinInfo->lpDdePktTerminate )  {
            ok = FALSE;
        }
    }

    if( !ok )  {
        if( lpWinInfo )  {
            if( lpWinInfo->qDDEIncomingCmd )  {
                DDEQFree( lpWinInfo->qDDEIncomingCmd );
                lpWinInfo->qDDEIncomingCmd = 0;
            }
            if( lpWinInfo->qDDEOutgoingCmd )  {
                DDEQFree( lpWinInfo->qDDEOutgoingCmd );
                lpWinInfo->qDDEOutgoingCmd = 0;
            }
            if( lpWinInfo->hMemWaitInitQueue )  {
                GlobalFree( lpWinInfo->hMemWaitInitQueue );
                lpWinInfo->hMemWaitInitQueue = 0;
            }
            if( lpWinInfo->lpDdePktTerminate )  {
                HeapFreePtr( lpWinInfo->lpDdePktTerminate );
                lpWinInfo->lpDdePktTerminate = NULL;
            }
            HeapFreePtr( lpWinInfo );
            lpWinInfo = NULL;
            SetWindowLongPtr( hWndDDE, 0, 0 );
        }
    }

    return( lpWinInfo );
}

VOID
FAR PASCAL
IpcFillInConnInfo(
        HIPC            hIpc,
        LPCONNENUM_CMR  lpConnEnum,
        LPSTR           lpDataStart,
        LPWORD          lpcFromBeginning,
        LPWORD          lpcFromEnd
)
{
    HWND                hWndDDE;
    LPWININFO           lpWinInfo;
    LPSTR               lpszAppName;
    LPSTR               lpszTopicName;
    LPDDECONNINFO       lpDdeConnInfo;
    WORD                wStringSize;
    LPSTR               lpszString;

    if( hIpc )  {
        hWndDDE = (HWND) hIpc;
        if( hWndDDE && IsWindow( hWndDDE ) )  {
            lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );

            lpConnEnum->nItems++;
            lpszAppName = ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName;
            lpszTopicName = ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName;
            lpConnEnum->cbTotalAvailable += sizeof(DDECONNINFO);
            wStringSize = lstrlen(lpszTopicName) + 1;
            if( !IsShare(lpszAppName) )  {
                wStringSize += lstrlen(lpszAppName) + 1;
            }
            lpConnEnum->cbTotalAvailable += wStringSize;
            if( lpConnEnum->lReturnCode == NDDE_NO_ERROR )  {
                if( ((int)(wStringSize+sizeof(DDECONNINFO))) >
                    (*lpcFromEnd - *lpcFromBeginning) )  {
                    lpConnEnum->lReturnCode = NDDE_BUF_TOO_SMALL;
                } else {
                    /* there is room! */
                    lpDdeConnInfo = (LPDDECONNINFO)
                        ((LPSTR)lpDataStart + *lpcFromBeginning);
                    *lpcFromBeginning += sizeof(DDECONNINFO);
                    *lpcFromEnd -= wStringSize;
                    lpszString = ((LPSTR)lpDataStart + *lpcFromEnd);
                    lpDdeConnInfo->ddeconn_Status = lpWinInfo->wState;
                    lpDdeConnInfo->ddeconn_ShareName =
                        (LPSTR)(LONG_PTR)*lpcFromEnd;
                    *lpszString = '\0';
                    if( !IsShare( lpszAppName ) )  {
                        lstrcpy( lpszString, lpszAppName );
                        lstrcat( lpszString, "|" );
                    }
                    lstrcat( lpszString, lpszTopicName );
                }
            }
        }
    }
}
#if DBG

VOID
FAR PASCAL
debug_srv_client(
    HWND        hWndDDE,
    LPWININFO   lpWinInfo)
{
    DPRINTF(( "  %04X: %Fp \\\\%Fs\\%Fs -> \\\\%Fs\\%Fs|%Fs",
        hWndDDE, lpWinInfo,
        lpWinInfo->bClientSideOfNet ?
            (LPSTR)ourNodeName : ((LPSTR)lpWinInfo) +
            lpWinInfo->offsNodeName,
        ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
        lpWinInfo->bClientSideOfNet ?
            ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName :
            (LPSTR)ourNodeName,
        ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName,
        ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName ));
}

VOID
FAR PASCAL
DebugDdeIntfState( void )
{
    LPWININFO   lpWinInfo;
    HWND        hWndDDE;

    EnterCrit();
    DPRINTF(( "DDEINTF State [Normal Windows]:" ));
    hWndDDE = hWndDDEHead;
    while( hWndDDE )  {
        assert( IsWindow(hWndDDE) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
        assert( lpWinInfo );
        debug_srv_client(hWndDDE, lpWinInfo);
        DPRINTF(( "  bClientSideOfNet:      %d\n"
                  "  bServerSideOfNet:      %d\n"
                  "  bOnWindowList:         %d\n"
                  "  bOnTermWindowList:     %d\n"
                  "  bSentTerminateNet:     %d\n"
                  "  bRcvdTerminateNet:     %d\n"
                  "  bSentTerminateLocally: %d\n"
                  "  bRcvdTerminateLocally: %d\n"
                  "  bInitiating:           %d\n"
                  "  nExtraInitiateAcks:    %d\n"
                  "  hWndDDE:               %04X\n"
                  "  hWndDDELocal:          %04X\n"
                  "  hDder:                 %Fp\n"
                  "  wState:                %d\n"
                  "  hWndPrev:              %04X\n"
                  "  hWndNext:              %04X\n"
                  "  dwSent:                %ld\n"
                  "  dwRcvd:                %ld\n"
                  ,
                lpWinInfo->bClientSideOfNet,
                lpWinInfo->bServerSideOfNet,
                lpWinInfo->bOnWindowList,
                lpWinInfo->bOnTermWindowList,
                lpWinInfo->bSentTerminateNet,
                lpWinInfo->bRcvdTerminateNet,
                lpWinInfo->bSentTerminateLocally,
                lpWinInfo->bRcvdTerminateLocally,
                lpWinInfo->bInitiating,
                lpWinInfo->nExtraInitiateAcks,
                lpWinInfo->hWndDDE,
                lpWinInfo->hWndDDELocal,
                lpWinInfo->hDder,
                lpWinInfo->wState,
                lpWinInfo->hWndPrev,
                lpWinInfo->hWndNext,
                lpWinInfo->dwSent,
                lpWinInfo->dwRcvd ));
        hWndDDE = lpWinInfo->hWndNext;
    }

    DPRINTF(( "DDEINTF State [Terminating Windows]:" ));
    hWndDDE = hWndDDEHeadTerminating;
    while( hWndDDE )  {
        assert( IsWindow(hWndDDE) );
        lpWinInfo = (LPWININFO) GetWindowLongPtr( hWndDDE, 0 );
        assert( lpWinInfo );
        DPRINTF(( "  %04X: %Fp \\\\%Fs\\%Fs -> \\\\%Fs\\%Fs|%Fs",
            hWndDDE, lpWinInfo,
            lpWinInfo->bClientSideOfNet ?
                (LPSTR)ourNodeName : ((LPSTR)lpWinInfo) +
                lpWinInfo->offsNodeName,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsClientName,
            lpWinInfo->bClientSideOfNet ?
                ((LPSTR)lpWinInfo) + lpWinInfo->offsNodeName :
                (LPSTR)ourNodeName,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsAppName,
            ((LPSTR)lpWinInfo) + lpWinInfo->offsTopicName ));

        DPRINTF(( "    %d %d %d %d %d %d %d %d %d %d %04X %04X %Fp %d %04X %04X %ld %ld",
            lpWinInfo->bClientSideOfNet,
            lpWinInfo->bServerSideOfNet,
            lpWinInfo->bOnWindowList,
            lpWinInfo->bOnTermWindowList,
            lpWinInfo->bSentTerminateNet,
            lpWinInfo->bRcvdTerminateNet,
            lpWinInfo->bSentTerminateLocally,
            lpWinInfo->bRcvdTerminateLocally,
            lpWinInfo->bInitiating,
            lpWinInfo->nExtraInitiateAcks,
            lpWinInfo->hWndDDE,
            lpWinInfo->hWndDDELocal,
            lpWinInfo->hDder,
            lpWinInfo->wState,
            lpWinInfo->hWndPrev,
            lpWinInfo->hWndNext,
            lpWinInfo->dwSent,
            lpWinInfo->dwRcvd ));
        hWndDDE = lpWinInfo->hWndNext;
    }
    LeaveCrit();
}
#endif // DBG

LPBYTE
GetInitPktPassword(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    LPBYTE          lpPasswd;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

    lpPasswd = (LPBYTE) GetStringOffset( lpSecurity,
                 secAligned.dp_sec_offsPassword);
    return lpPasswd;
}

PQOS
GetInitPktQos(
    LPDDEPKTINIT    lpDdePktInit,
    PQOS            pQosOut )
{
    LPDDEPKTSEC     lpSecurity;
    PQOS            pQos = (PQOS) NULL;
    DDEPKTSEC       secAligned;

    if (lpDdePktInit->dp_init_sizePassword) {
        lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
            lpDdePktInit->dp_init_offsPassword);
        hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

        if( secAligned.dp_sec_offsUserName == sizeof(DDEPKTSEC) )  {
            pQos = (PQOS) GetStringOffset( lpSecurity,
                secAligned.dp_sec_offsQos);

            /*
             * If there is no password, the qos may be garbage.  NT 1.0
             * puts a random value in the qos field.
             */
            if (secAligned.dp_sec_sizePassword == 0) {
                if ((PBYTE)pQos > ((PBYTE)lpDdePktInit +
                        lpDdePktInit->dp_init_ddePktCmn.dc_ddePkt.dp_size))
                    return NULL;
            }

            hmemcpy( (LPVOID)pQosOut, (LPVOID)pQos, sizeof(QOS));
        }
    }
    return(pQos);
}

LPBYTE
GetInitPktUser(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    LPBYTE          lpUser;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

    lpUser = (LPBYTE) GetStringOffset( lpSecurity,
        secAligned.dp_sec_offsUserName);
    return lpUser;
}

LPBYTE
GetInitPktDomain(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    LPBYTE          lpDomain;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );

    lpDomain = (LPBYTE) GetStringOffset( lpSecurity,
        secAligned.dp_sec_offsDomainName);
    return lpDomain;
}

WORD
GetInitPktPasswordSize(
    LPDDEPKTINIT    lpDdePktInit )
{
    LPDDEPKTSEC     lpSecurity;
    DDEPKTSEC       secAligned;

    lpSecurity = (LPDDEPKTSEC) GetStringOffset(lpDdePktInit,
        lpDdePktInit->dp_init_offsPassword);
    hmemcpy( (LPVOID)&secAligned, (LPVOID)lpSecurity, sizeof(DDEPKTSEC) );
    return( secAligned.dp_sec_sizePassword );
}

void
GlobalFreehData(
    HANDLE  hData )
{
    DWORD           dwErr;
    LPBYTE          lpData;
    HANDLE         *lphIndirect;
    HANDLE          hIndirect;
    LPMETAFILEPICT  lpMetafilePict;
    WORD            cfFormat;


    lpData = (LPBYTE) GlobalLock(hData);
    if (lpData == NULL) {
        dwErr = GetLastError();
        DPRINTF(("Unable to lock down hData on a GlobalFreehData(): %d", dwErr));
        return;
    }
    cfFormat = (WORD)((LPDDELN)lpData)->cfFormat;
    switch (cfFormat) {
        case CF_METAFILEPICT:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            lpMetafilePict = (LPMETAFILEPICT) GlobalLock(hIndirect);
            if (lpMetafilePict == NULL) {
                dwErr = GetLastError();
                DPRINTF(("Unable to lock down hMetaFilePict on a GlobalFreehData(): %d", dwErr));

            } else {
                DeleteMetaFile(lpMetafilePict->hMF);
                GlobalUnlock(hIndirect);
                GlobalFree(hIndirect);
            }
            break;
        case CF_DIB:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            GlobalFree(hIndirect);
            break;
        case CF_PALETTE:
        case CF_BITMAP:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            if (!DeleteObject(hIndirect)) {
                dwErr = GetLastError();
                DPRINTF(("Unable to delete object GlobalFreehData(): %d", dwErr));
            }
            break;
        case CF_ENHMETAFILE:
            lphIndirect = (HANDLE *) (lpData + sizeof(DDELN));
            hIndirect = *lphIndirect;
            DeleteEnhMetaFile(hIndirect);
            break;
        default:
            break;
    }
    GlobalUnlock(hData);
    GlobalFree(hData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\crc_16.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CRC_16.C;1  16-Dec-92,10:20:14  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1989-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#ifdef WIN32
#include "api1632.h"
#endif

#define LINT_ARGS
#include "windows.h"
#include "debug.h"

void FAR PASCAL crc_16( WORD FAR *ucrc, BYTE FAR *msg, int len );

/*************************************************************************\
* 									  *
*     NAME:								  *
*									  *
*	void crc_16( &crc, &msg, len )					  *
*     									  *
*     FUNCTION:								  *
*									  *
*	This function is used to compute 16-bit CRC as is used in BSC	  *
*	and known as CRC-16.  It is defined by the following		  *
*	polynomial (X**16 + X**15 + X**2 + 1).				  *
* 									  *
*     PARAMETERS:							  *
*									  *
*	WORD *crc	pointer to the 16-bit checksum currently	  *
*			being computed.  Note that the CRC must		  *
*			be initialized to 0xffff.			  *
*									  *
*	BYTE *msg	pointer to the first byte to be included	  *
*			in the crc computation				  *
* 									  *
*	int  len	number of bytes to be included in the crc	  *
*			computation					  *
*									  *
*     RETURN:		NONE.  Resulting crc is in the first argument	  *
* 									  *
\*************************************************************************/

void
FAR PASCAL
crc_16( ucrc, msg, len )
    WORD FAR	*ucrc;
    BYTE FAR	*msg;
    int		len;
{
    register WORD crc;
    register short bit;
    short chr;
    register short feedbackBit;
    register BYTE ch;

    crc = *ucrc;
/*DPRINTF(( "Start %08lX for %d w/ %04X", msg, len, crc ));*/
    for ( chr = 0; chr < len; chr++ ) {
	ch = *msg++;
/*DPRINTF(( "ch: %02X", ch ));*/
	for ( bit = 0; bit <= 7; bit++ ) {
	    feedbackBit = ( ch ^ crc ) & 1;
	    crc >>= 1;
	    if ( feedbackBit == 1 ) {
/*		crc |= 0x8000; */
/*		crc ^= 0x2001;	/* Polynomial terms represented here:	  */
				/* Bits 13 and 0 represent X**15 and X**2 */
				/* X**16 and 1 handled by the algorithm	  */

	    /* Note that since *crc has been shifted right, the two	  */
	    /* statements above could be replaced by a single statement:  */
	    /*		crc ^= 0xa001;					  */
		crc ^= 0xa001;
	    }
	    ch >>= 1;
	}
    }
/*DPRINTF(( "  rslt: %04X", crc ));*/
    *ucrc = crc;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ninstall\ninstall.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NINSTALL.C;2  23-Dec-92,18:47:52  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

//#define   NOISY
//#define   DEBUG
#define     ERRPOPUPS

#include    <windows.h>   // required for all Windows applications
#include    <string.h>
#include    <stdlib.h>
#include	<time.h>
#include    "debug.h"
#include    "hardware.h"
#include    "proflspt.h"
#include    "shrtrust.h"

#ifdef ERRPOPUPS
#define     EMSGBOX(h, c, t, s)      MessageBox(h, c, t, s)
char    ebuf[200];
#else
#define     EMSGBOX(h, c, t, s)
#endif // ERRPOPUPS

#ifdef NOISY
#define     NMSGBOX(h, c, t, s)      MessageBox(h, c, t, s)
#else
#define     NMSGBOX(h, c, t, s)
#endif // NOISY

typedef struct {
    LPSTR   szValueName;
    DWORD   dwType;
    union U {
        DWORD   dwValue;
        LPSTR   szValue;
    } Value;
} NDDE_PARAM, *PNDDE_PARAM;

NDDE_PARAM  GeneralParam[] = {
                    "DebugEnabled", REG_DWORD, 0x1,
                    "DebugInfo", REG_DWORD, 0x0,
                    "DebugDdePkts", REG_DWORD, 0x0,
                    "DumpTokens", REG_DWORD, 0x0,
                    "DebugDdeMessages", REG_DWORD, 0x0,
                    "LogPermissionViolations", REG_DWORD, 0x1,
                    "LogExecFailures", REG_DWORD, 0x1,
                    "LogRetries", REG_DWORD, 0x1,
                    "DefaultRouteDisconnect", REG_DWORD, 0x1,
                    "DefaultRoute", REG_SZ, (DWORD)"",
                    "DefaultRouteDisconnectTime", REG_DWORD, 30,
                    "DefaultConnectionDisconnect", REG_DWORD, 0x1,
                    "DefaultConnectionDisconnectTime", REG_DWORD, 30,
                    "DefaultTimeSlice", REG_DWORD, 1000,
                    "NDDELogInfo", REG_DWORD, 0,
                    "NDDELogWarnings", REG_DWORD, 0,
                    "NDDELogErrors", REG_DWORD, 1,
                    "SecKeyAgeLimit", REG_DWORD, 3600,
                    NULL, 0, 0 };

NDDE_PARAM  NddeAgntParam[] = {
                    "DebugEnabled", REG_DWORD, 0x1,
                    "DebugInfo", REG_DWORD, 0x0,
                    NULL, 0, 0 };

NDDE_PARAM  NddeAPIParam[] = {
                    "NDDELogInfo", REG_DWORD, 0,
                    "NDDELogWarnings", REG_DWORD, 0,
                    "NDDELogErrors", REG_DWORD, 1,
                    "DebugEnabled", REG_DWORD, 0x1,
                    "DebugInfo", REG_DWORD, 0x0,
                    NULL, 0, 0 };

NDDE_PARAM  NetBIOSParam[] = {
                    "NDDELogInfo", REG_DWORD, 0,
                    "NDDELogWarnings", REG_DWORD, 0,
                    "NDDELogErrors", REG_DWORD, 1,
                    "DebugEnabled", REG_DWORD, 0x1,
                    "DebugInfo", REG_DWORD, 0x0,
                    "UseNetbiosPost", REG_DWORD, 0x1,
                    "LogAll", REG_DWORD, 0x0,
                    "LogUnusual", REG_DWORD, 0x1,
                    "Maxunack", REG_DWORD, 10,
                    "TimeoutRcvConnCmd", REG_DWORD, 60000,
                    "TimeoutRcvConnRsp", REG_DWORD, 60000,
                    "TimeoutMemoryPause", REG_DWORD, 10000,
                    "TimeoutKeepAlive", REG_DWORD, 60000,
                    "TimeoutXmtStuck", REG_DWORD, 120000,
                    "TimeoutSendRsp", REG_DWORD, 60000,
                    "MaxNoResponse", REG_DWORD, 3,
                    "MaxXmtErr", REG_DWORD, 3,
                    "MaxMemErr", REG_DWORD, 3,
                    "NumNetBIOS", REG_DWORD, 1,
                    "StartLananum", REG_DWORD, 0,
                    NULL, 0, 0 };

typedef struct {
    LPSTR           szSectionName;
    PNDDE_PARAM     pNddeParam;
} NDDE_PARAM_SECT, *PNDDE_PARAM_SECT;

NDDE_PARAM_SECT NddeParamSects[] = {
                "General",  &GeneralParam[0],
                "NddeAgnt", &NddeAgntParam[0],
                "NetBIOS", &NetBIOSParam[0],
                "NddeAPI", &NddeAPIParam[0],
                NULL, NULL};


TCHAR   szShareKey[]        = "SOFTWARE\\Microsoft\\NetDDE\\DDE Shares";
TCHAR   szEventLogKey[]     = "SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\NetDDE";
CHAR    szEventMsgFile[]    = "%SystemRoot%\\System32\\NetDDE.exe";
CHAR    szInstall[]         = "NetDDE Install";
TCHAR   szNetDDE[]          = TEXT("NetDDE");
TCHAR   szNetDDEdsdm[]      = TEXT("NetDDEdsdm");

#define NDDE_LOG_TYPES  EVENTLOG_ERROR_TYPE | \
                        EVENTLOG_WARNING_TYPE | \
                        EVENTLOG_INFORMATION_TYPE | \
                        EVENTLOG_AUDIT_SUCCESS | \
                        EVENTLOG_AUDIT_FAILURE

#ifdef NDDE_TAKEOWNERSHIP
BOOL	TakeOwnership( void );
#endif

BOOL    CreateShareDB();
BOOL    CreateEventLog();
BOOL    InitNddeParams();


BOOL	BuildShareDatabaseKeySD( PSECURITY_DESCRIPTOR *ppSD );

/*
 * Stop and delete any existing NetDDE service.
 * (Re)Create the NetDDE service.
 * Stop and delete any existing NetDDEdsdm service.
 * (Re)Create the NetDDEdsdm service.
 * CreateShareDB()
 * CreateEventLog()
 * InitNddeParams()
 */
int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    INT       nCmdShow)
{
    SC_HANDLE   schSCManager;
    SC_HANDLE   schService;
    LPTSTR      lpszNetDDEPathName = NULL;
    LPCTSTR     lpszNetDDEExeName  = TEXT("netdde.exe");
    UINT        cchSysPath;
    BOOL        bOk = TRUE;

    LPCTSTR     lpszDependentList = TEXT("NetDDEdsdm\0");

#if DBG
    DebugInit("NInstall");
    DPRINTF(("NetDDE Install Starting."));
#endif

    cchSysPath  = 0;
    cchSysPath  = GetSystemDirectory( lpszNetDDEPathName, cchSysPath );
    cchSysPath += 10;
    lpszNetDDEPathName = (LPTSTR)LocalAlloc( LPTR, cchSysPath );
    GetSystemDirectory( lpszNetDDEPathName, cchSysPath );
    if( lpszNetDDEPathName[lstrlen(lpszNetDDEPathName)-1] != TEXT('\\') ) {
	lstrcat( lpszNetDDEPathName, TEXT("\\") );
    }
    lstrcat( lpszNetDDEPathName, lpszNetDDEExeName );

    schSCManager = OpenSCManager(
           	NULL,                   /* local machine           */
           	NULL,                   /* ServicesActive database */
           	SC_MANAGER_ALL_ACCESS); /* full access rights      */

    if (schSCManager == NULL)  {
        EMSGBOX( NULL, "OpenSCManager failed", szInstall,
                MB_OK | MB_ICONEXCLAMATION );
        return( FALSE );
    }

    /* see if one exists */
    schService = OpenService(
            schSCManager,        /* SCManager database      */
            szNetDDE,     /* name of service         */
            DELETE);            /* only need DELETE access */
    if( schService )  {
        if (! DeleteService(schService) )  {
            EMSGBOX( NULL, "DeleteService NetDDE Service failed", szInstall,
                    MB_OK | MB_ICONEXCLAMATION );
            return( FALSE );
        }
        CloseServiceHandle( schService );
    }

    schService = CreateService(
            schSCManager,              /* SCManager database  */
            szNetDDE,            /* name of service     */
    	    szNetDDE,
            SERVICE_ALL_ACCESS,        /* desired access      */
            SERVICE_WIN32_SHARE_PROCESS, /* service type      */
            SERVICE_AUTO_START,        /* start type          */
            SERVICE_ERROR_NORMAL,      /* error control type  */
            lpszNetDDEPathName,        /* service's binary    */
            NULL,                      /* no load order group */
            NULL,                      /* no tag ID           */
            lpszDependentList,          /* "NetDDEdsdm"     */
            NULL,                      /* LocalSystem account */
            NULL);                     /* no password         */

    if (schService == NULL)  {
#ifdef  ERRPOPUPS
        wsprintf( ebuf, "Adding NetDDE Service failed: %d", GetLastError() );
        EMSGBOX( NULL, ebuf, szInstall, MB_OK | MB_ICONEXCLAMATION );
#endif
        bOk = FALSE;
    } else {
        CloseServiceHandle( schService );
        NMSGBOX( NULL, "Added NetDDE Service successfully.",
                szInstall, MB_OK );
    }

    schService = OpenService(
            schSCManager,       /* SCManager database      */
            szNetDDEdsdm,       /* name of service         */
            DELETE);            /* only need DELETE access */
    if( schService )  {
        if (! DeleteService(schService) )  {
            EMSGBOX( NULL, "Delete DSDM Service failed", szInstall,
                    MB_OK | MB_ICONEXCLAMATION );
            return( FALSE );
        }
        CloseServiceHandle( schService );
    }


    schService = CreateService(
            schSCManager,              /* SCManager database  */
            szNetDDEdsdm,    	       /* name of service     */
    	    TEXT("NetDDE DSDM"),
            SERVICE_ALL_ACCESS,        /* desired access      */
            SERVICE_WIN32_SHARE_PROCESS, /* service type      */
            SERVICE_AUTO_START,        /* start type          */
            SERVICE_ERROR_NORMAL,      /* error control type  */
            lpszNetDDEPathName,        /* service's binary    */
            NULL,                      /* no load order group */
            NULL,                      /* no tag ID           */
            NULL,                      /* no dependencies     */
            NULL,                      /* LocalSystem account */
            NULL);                     /* no password         */

    if (schService == NULL)  {
#ifdef  ERRPOPUPS
        wsprintf( ebuf, "Adding DSDM Service failed: %d", GetLastError() );
        EMSGBOX( NULL, ebuf, szInstall, MB_OK | MB_ICONEXCLAMATION );
#endif
    } else {
        CloseServiceHandle( schService );
        NMSGBOX( NULL, "Added DSDM Service successfully.",
                szInstall, MB_OK );
    }

    if( !CloseServiceHandle( schSCManager ) ) {
        EMSGBOX( NULL, "CloseServiceHandle() failed", szInstall,
                MB_OK | MB_ICONEXCLAMATION );
    }


    if (bOk) {
        bOk = CreateShareDB();
    }

    if (bOk) {
        bOk = CreateEventLog();
    }

    if (bOk) {
        bOk = InitNddeParams();
    }

    return (0); // Returns the value from PostQuitMessage

    lpCmdLine; // This will prevent 'unused formal parameter' warnings
}

/*
 * Create DDE Share DB in registry if necessary.
 * Get serial number from registry - or create one if needed. (init to 0)
 * Make sure this is being run with administrator priviliges.
 *
 */
BOOL
CreateShareDB()
{
    HKEY            hKey;
    LONG            lRtn;
    DWORD           dwType;
    LONG            lSerialNumber[2];
    HANDLE          hClientToken;
    TOKEN_GROUPS    *pTokenGroups;
    DWORD           lTokenInfo;
    SID_IDENTIFIER_AUTHORITY	NtAuthority = SECURITY_NT_AUTHORITY;
    PSID			AdminsAliasSid;
    BOOL			bAdmin;
    TCHAR			szNull[ 50 ];
    DWORD			dwAccountName;
    DWORD			dwDomainName;
    int				i;
    SID_NAME_USE    snu;
    TCHAR           szAccountName[ 5000 ];
    TCHAR           szDomainName[ 5000 ];
    SECURITY_ATTRIBUTES		sA;
    PSECURITY_DESCRIPTOR	pSD;
    BOOL			OK;
    DWORD			dwDisp;
    DWORD			lSize;
    BOOL            bOK = TRUE;
    int             InstanceId;
    time_t          time_tmp;


    /*  Create the DDE Share database in the registry if it does not exist. */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            szShareKey,
            0,
            KEY_WRITE|KEY_READ,
            &hKey );

    if( lRtn == ERROR_SUCCESS ) {
	/*
     * Check that the SerialNumber key value exists in the Registry.
     */
        lRtn = RegQueryValueEx( hKey,
                KEY_MODIFY_ID,
                NULL,
                &dwType,
                (LPBYTE)&lSerialNumber,
                &lSize );
        if( lRtn != ERROR_MORE_DATA ) {
#ifdef  ERRPOPUPS
            wsprintf( ebuf, "Serial Number Query Error = %d", lRtn );
            EMSGBOX( NULL, ebuf, szInstall, MB_OK );
#endif
	    /*
         * Need to create the SerialNumber key value.
         */
            lSerialNumber[0] = lSerialNumber[1] = 0;
            lRtn = RegSetValueEx( hKey,
                KEY_MODIFY_ID,
                0,
                REG_BINARY,
                (LPBYTE)&lSerialNumber,
                2 * sizeof( LONG ) );
            if( lRtn == ERROR_SUCCESS ) {
                NMSGBOX( NULL, "Created the SerialNumber"
                        " key value successfully.", szInstall, MB_OK );
            } else {
                EMSGBOX( NULL, "Could not create the SerialNumber"
                        " key value.", szInstall, MB_OK | MB_ICONEXCLAMATION );
                bOK = FALSE;
            }
        }
        RegCloseKey( hKey );
    } else {
	/*
     * Need to create the ShareDatabase in the Registry.
	 * We need to be in the Administrator Group to do this!
     */
        if( !OpenProcessToken( GetCurrentProcess(),
			       TOKEN_QUERY,
			       &hClientToken ) ) {
            EMSGBOX( NULL, "Could not read the Process Token", szInstall,
                    MB_OK | MB_ICONEXCLAMATION );
            return FALSE;
        }
        pTokenGroups = (TOKEN_GROUPS *)LocalAlloc( 0, 5000 );
        if( !GetTokenInformation( hClientToken, TokenGroups,
				  (LPVOID) pTokenGroups, 5000,
				  &lTokenInfo ) ) {
            LocalFree( pTokenGroups );
            pTokenGroups = (TOKEN_GROUPS *)LocalAlloc( 0, lTokenInfo );
            if( !GetTokenInformation( hClientToken, TokenGroups,
				      (LPVOID) pTokenGroups, lTokenInfo,
				      &lTokenInfo ) ) {

                EMSGBOX( NULL, "Could not read the token information",
                        szInstall, MB_OK | MB_ICONEXCLAMATION );
                return FALSE;
            }
        }

        OK = AllocateAndInitializeSid( &NtAuthority,
					2,
					SECURITY_BUILTIN_DOMAIN_RID,
					DOMAIN_ALIAS_RID_ADMINS,
					0, 0, 0, 0, 0, 0,
					&AdminsAliasSid );

        bAdmin    = FALSE;
        szNull[0] = '\0';
        for( i=0; i < (int)pTokenGroups->GroupCount && !bAdmin; i++ ) {
            if( !IsValidSid( pTokenGroups->Groups[i].Sid ) ) {
                EMSGBOX( NULL, "Invalid Group Sid", szInstall,
                        MB_OK | MB_ICONEXCLAMATION );
                return FALSE;
            }
            dwAccountName = 5000;
            dwDomainName  = 5000;
            OK = LookupAccountSid( szNull,
                    pTokenGroups->Groups[i].Sid,
                    szAccountName, &dwAccountName,
                    szDomainName,  &dwDomainName, &snu);
            if( OK ) {
                if( EqualSid( pTokenGroups->Groups[i].Sid, AdminsAliasSid )) {
                    bAdmin = TRUE;
                }
            }
        }

        LocalFree( pTokenGroups );
        FreeSid( AdminsAliasSid );
        if( !bAdmin ) {
            EMSGBOX( NULL, "You must be an Administrator to create the"
                    " DDE Shares database", szInstall, MB_OK );
            return FALSE;
        }
        OK = BuildShareDatabaseKeySD( &pSD );

        sA.nLength              = sizeof( SECURITY_ATTRIBUTES );
        sA.lpSecurityDescriptor = (LPVOID) pSD;
        sA.bInheritHandle       = FALSE;
#ifdef NDDE_TAKEOWNERSHIP
        TakeOwnership();
#endif
        lRtn = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
			szShareKey, 0,
			TEXT("NetDDEShare"),
			REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS & (~DELETE),
			&sA,
			&hKey,
			&dwDisp );

        if( lRtn == ERROR_SUCCESS ) {
            switch( dwDisp ) {
            case REG_CREATED_NEW_KEY:
		        /*
                 * Need to create the SerialNumber key value.
                 */
                lSerialNumber[0] = lSerialNumber[1] = 0;
                lRtn = RegSetValueEx( hKey,
                    KEY_MODIFY_ID, 0,
                    REG_BINARY,
                    (LPBYTE)&lSerialNumber,
                    2 * sizeof( LONG ) );
                if( lRtn != ERROR_SUCCESS ) {
                    EMSGBOX( NULL, "Could not create the SerialNumber"
                            " key value.", szInstall,
                            MB_OK | MB_ICONEXCLAMATION );
                    bOK = FALSE;
                }
                /*
                 * Need to create data base instance value
                 */
                srand((int) time(&time_tmp));
                InstanceId = rand();
                lRtn = RegSetValueEx( hKey,
                    KEY_DB_INSTANCE, 0,
                    REG_BINARY,
                    (LPBYTE)&InstanceId,
                    sizeof( int ) );
                if( lRtn == ERROR_SUCCESS ) {
                    NMSGBOX( NULL, "Created the DDE Shares"
                            " Database successfully.", szInstall, MB_OK );
                } else {
                    EMSGBOX( NULL, "Could not create the Instance Id"
                            " key value.", szInstall,
                            MB_OK | MB_ICONEXCLAMATION );
                    bOK = FALSE;
                }

                break;

            default:
                EMSGBOX( NULL, "Error creating the DDE Shares"
                        " database", szInstall,
                        MB_OK | MB_ICONEXCLAMATION );
                bOK = FALSE;
                break;
            }

            RegCloseKey( hKey );
        } else {
	        EMSGBOX( NULL, "Failed creating the DDE Shares"
    		        " database", szInstall, MB_OK | MB_ICONEXCLAMATION );
            bOK = FALSE;
        }
    }
    return(bOK);
}



BOOL
CreateEventLog()
{
    HKEY        hKey;
    LONG        lRtn;
    DWORD       dwType;
    BOOL        bOk = TRUE;

    lRtn = RegOpenKey(HKEY_LOCAL_MACHINE,
        szEventLogKey, &hKey);
    if (lRtn != ERROR_SUCCESS) {
        lRtn = RegCreateKey(HKEY_LOCAL_MACHINE,
            szEventLogKey, &hKey);
        if (lRtn == ERROR_SUCCESS) {
            lRtn = RegSetValueEx(hKey, "EventMessageFile",
                0, REG_EXPAND_SZ,
                (LPBYTE) szEventMsgFile,
                strlen(szEventMsgFile) + 1);
            if (lRtn == ERROR_SUCCESS) {
                dwType = NDDE_LOG_TYPES;
                lRtn = RegSetValueEx(hKey, "TypesSupported",
                    0, REG_DWORD,
                    (LPBYTE) &dwType,
                    sizeof(DWORD) );
                if (lRtn == ERROR_SUCCESS) {
                    NMSGBOX( NULL, "Added NetDDE Event Log Entry successfully.",
                            szInstall, MB_OK );
                } else {
            		EMSGBOX( NULL, "Error setting NetDDE Event Types",
            		        szInstall, MB_OK | MB_ICONEXCLAMATION );
                bOk = FALSE;
                }
            } else {
        		EMSGBOX( NULL, "Error setting NetDDE Event Msg File",
        		        szInstall, MB_OK | MB_ICONEXCLAMATION );
                bOk = FALSE;
            }
            RegCloseKey(hKey);
        } else {
    		EMSGBOX( NULL, "Error creating NetDDE Event Log Key",
    		        szInstall, MB_OK | MB_ICONEXCLAMATION );
            bOk = FALSE;
        }
    } else { /* if successful, must exist already */
  	    NMSGBOX( NULL, "NetDDE Event Log Entry already exists.",
                szInstall, MB_OK );
        RegCloseKey(hKey);
    }
    return(bOk);
}


/*
 * Slap NddeParaamSects into registry.
 */
BOOL
InitNddeParams()
{
    PNDDE_PARAM pParamList;
    LPSTR       szSection;
    LPSTR       szValue;
    DWORD       dwType;
    BOOL        bParamExists;
    int         k;

    k = 0;
    while (szSection = NddeParamSects[k].szSectionName) {
        pParamList = NddeParamSects[k++].pNddeParam;
        while (szValue = pParamList->szValueName) {
            dwType = pParamList->dwType;
            switch (dwType) {
            case REG_SZ:
                bParamExists = TestPrivateProfile(szSection, szValue, NULL);
                if (!bParamExists) {
                    MyWritePrivateProfileString(szSection, szValue,
                            pParamList->Value.szValue, NULL);
                }
                DPRINTF(("Adding(%d): %s, %s, %s", bParamExists, szSection,
                        szValue, pParamList->Value.szValue));
                break;

            case REG_DWORD:
    		    bParamExists = TestPrivateProfile(szSection, szValue, NULL);
    		    if (!bParamExists) {
    		        WritePrivateProfileLong(szSection, szValue,
    			            pParamList->Value.dwValue, NULL);
    		    }
                DPRINTF(("Adding(%d): %s, %s, %d", bParamExists, szSection,
                        szValue, pParamList->Value.dwValue));
                break;

            default:
#ifdef  ERRPOPUPS
                wsprintf(ebuf, "Unknown NetDDE Param Type: %d for %s %s",
                        dwType, szSection, szValue);
            	EMSGBOX( NULL, ebuf,
                        szInstall, MB_OK | MB_ICONEXCLAMATION );
#endif // ERRPOPUPS
                break;
            }
            pParamList++;
        }
    }
    return(TRUE);
}



#ifdef NDDE_TAKEOWNERSHIP
BOOL
TakeOwnership( void )
{
    HANDLE hToken;
    LUID   toLuid;
    TOKEN_PRIVILEGES tkp;

    if( !OpenProcessToken( GetCurrentProcess(),
	        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) ) {
    	EMSGBOX( NULL, "Error getting Process Token.",
                szInstall, MB_OK | MB_ICONEXCLAMATION );
    	return FALSE;
    }
    if( !LookupPrivilegeValue( (LPSTR) NULL, "SeTakeOwnershipPrivilege",
				&toLuid ) ) {
    	EMSGBOX( NULL, "LookupPrivilegeValue failed.",
                szInstall, MB_OK | MB_ICONEXCLAMATION );
    	return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = toLuid;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges( hToken, FALSE, &tkp, sizeof(TOKEN_PRIVILEGES),
	        (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL );

    if( GetLastError() != NO_ERROR ) {
    	EMSGBOX( NULL, "Could not AdjustTokenPrivileges.", szInstall,
    	        MB_OK | MB_ICONEXCLAMATION );
    	return FALSE;
    }
    return TRUE;
}
#endif // NDDE_TAKEOWNERSHIP

/*
 * Build up an ACE with the following:
 *  Create an Admin SID - give them ALL_ACCESS except DELETE
 *  Create a Power User SID - give them selected rights
 *  Create a Normal User SID - give them same selected rights
 *  Create an SID for everyone - give them READ and WRITE rights
 * Create an ACL with ACE properties
 * Create an SID and place ACL into it.
 * Return SID
 */
BOOL
BuildShareDatabaseKeySD( PSECURITY_DESCRIPTOR *ppSD )
{
    PSID			AdminsAliasSid;
    PSID			PowerUsersAliasSid;
    PSID			UsersAliasSid;
    PSID			WorldSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority    = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SECURITY_DESCRIPTOR		aSD;
    PSECURITY_DESCRIPTOR	pSD;
    int				AceCount;
    PSID			AceSid[10];
    ACCESS_MASK			AceMask[10];
    BYTE			AceFlags[10];
    PACL			TmpAcl;
    PACCESS_ALLOWED_ACE		TmpAce;
    DWORD			lSD;
    LONG			DaclLength;
    BOOL			OK;
    int				i;

    OK = InitializeSecurityDescriptor( &aSD, SECURITY_DESCRIPTOR_REVISION );

    OK = AllocateAndInitializeSid( &NtAuthority,
				    2,
				    SECURITY_BUILTIN_DOMAIN_RID,
				    DOMAIN_ALIAS_RID_ADMINS,
				    0, 0, 0, 0, 0, 0,
				    &AdminsAliasSid );

    if( !OK ) {
    	EMSGBOX( NULL, "Failed to initialize the Security Descriptor.",
    	        szInstall, MB_OK | MB_ICONEXCLAMATION );
    	FreeSid( AdminsAliasSid );
    	return FALSE;
    }

    AceCount = 0;

    AceSid[AceCount]   = AdminsAliasSid;
    AceMask[AceCount]  = KEY_ALL_ACCESS & (~DELETE);
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &NtAuthority,
				    2,
				    SECURITY_BUILTIN_DOMAIN_RID,
				    DOMAIN_ALIAS_RID_POWER_USERS,
				    0, 0, 0, 0, 0, 0,
				    &PowerUsersAliasSid );
    if( !OK ) {
	EMSGBOX( NULL, "Failed to initialize the Power_Users Sid.",
	        szInstall, MB_OK | MB_ICONEXCLAMATION );
	FreeSid( AdminsAliasSid );
	return FALSE;
    }

    AceSid[AceCount]   = PowerUsersAliasSid;
    AceMask[AceCount]  = KEY_SET_VALUE |
                         KEY_CREATE_SUB_KEY |
			             KEY_QUERY_VALUE |
                         KEY_ENUMERATE_SUB_KEYS |
			             KEY_NOTIFY |
                         KEY_CREATE_LINK |
			             READ_CONTROL;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &NtAuthority,
				    2,
				    SECURITY_BUILTIN_DOMAIN_RID,
				    DOMAIN_ALIAS_RID_USERS,
				    0, 0, 0, 0, 0, 0,
				    &UsersAliasSid );

    if( !OK ) {
	EMSGBOX( NULL, "Failed to initialize the Users Sid.",
	        szInstall, MB_OK | MB_ICONEXCLAMATION );
	FreeSid( AdminsAliasSid );
	FreeSid( PowerUsersAliasSid );
	return FALSE;
    }

    AceSid[AceCount]   = UsersAliasSid;
    AceMask[AceCount]  = KEY_SET_VALUE |
                         KEY_CREATE_SUB_KEY |
			             KEY_QUERY_VALUE |
                         KEY_ENUMERATE_SUB_KEYS |
			             KEY_NOTIFY |
                         KEY_CREATE_LINK |
			             READ_CONTROL;
    AceFlags[AceCount] = 0;
    AceCount++;

    OK = AllocateAndInitializeSid( &WorldAuthority,
				    1,
				    SECURITY_WORLD_RID,
				    0, 0, 0, 0, 0, 0, 0,
				    &WorldSid );
    if( !OK ) {
	EMSGBOX( NULL, "Failed to initialize the Everyone Sid.",
	        szInstall, MB_OK | MB_ICONEXCLAMATION );
	FreeSid( AdminsAliasSid );
	FreeSid( PowerUsersAliasSid );
	FreeSid( UsersAliasSid );
	return FALSE;
    }

    AceSid[AceCount]   = WorldSid;
    AceMask[AceCount]  = KEY_READ |
                         KEY_WRITE;
    AceFlags[AceCount] = 0;
    AceCount++;

    /*
     * make aSD owned by Admins
     */
    OK = SetSecurityDescriptorOwner( &aSD, AdminsAliasSid, FALSE);
    if( !OK ) {
    	EMSGBOX( NULL, "Failed setting SD Owner.", szInstall,
    	        MB_OK | MB_ICONEXCLAMATION );
    	FreeSid( AdminsAliasSid );
    	FreeSid( PowerUsersAliasSid );
    	FreeSid( UsersAliasSid );
    	FreeSid( WorldSid );
    	return FALSE;
    }
    /*
     * make aSD a member of Admins.
     */
    OK = SetSecurityDescriptorGroup( &aSD, AdminsAliasSid, FALSE );
    if( !OK ) {
    	EMSGBOX( NULL, "Failed setting SD Group.", szInstall,
    	        MB_OK | MB_ICONEXCLAMATION );
    	FreeSid( AdminsAliasSid );
    	FreeSid( PowerUsersAliasSid );
    	FreeSid( UsersAliasSid );
    	FreeSid( WorldSid );
    	return FALSE;
    }

    /*
     * Setup the default ACL for a new DDE Share Object.
     */
    DaclLength = (DWORD)sizeof(ACL);
    for( i=0; i<AceCount; i++ ) {
    	DaclLength += GetLengthSid( AceSid[i] ) +
                (DWORD)sizeof( ACCESS_ALLOWED_ACE ) -
                (DWORD)sizeof(DWORD);
    }
    TmpAcl = (PACL)LocalAlloc( 0, DaclLength );
    OK = InitializeAcl( TmpAcl, DaclLength, ACL_REVISION2 );
    if( !OK ) {
    	EMSGBOX( NULL, "InitializeAcl error.", szInstall,
    	        MB_OK | MB_ICONEXCLAMATION );
    }
    /*
     * Move our ACE into the ACL
     */
    for( i=0; i<AceCount; i++ ) {
    	OK = AddAccessAllowedAce( TmpAcl, ACL_REVISION2, AceMask[i],
    				  AceSid[i] );
    	if( !OK ) {
    	    EMSGBOX( NULL, "AddAccessAllowedAce error.", szInstall,
                    MB_OK | MB_ICONEXCLAMATION );
    	}
    	OK = GetAce( TmpAcl, i, (LPVOID *)&TmpAce );
    	if( !OK ) {
    	    EMSGBOX( NULL, "GetAce error.", szInstall, MB_OK | MB_ICONEXCLAMATION );
    	}
    	TmpAce->Header.AceFlags = AceFlags[i];
    }
    /*
     * place ACL into aSD
     */
    OK   = SetSecurityDescriptorDacl ( &aSD, TRUE, TmpAcl, FALSE );
    if( !OK ) {
    	EMSGBOX( NULL, "SetSecurityDescriptorDacl error.", szInstall,
    	        MB_OK | MB_ICONEXCLAMATION );
    }
    lSD  = GetSecurityDescriptorLength( &aSD );
    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, lSD );
    /*
     * Make aSD self relative
     */
    OK   = MakeSelfRelativeSD( &aSD, pSD, &lSD );
    if( !OK ) {
    	EMSGBOX( NULL, "MakeSelfRelativeSD error.", szInstall,
    	        MB_OK | MB_ICONEXCLAMATION );
	    *ppSD = NULL;
    } else {
	    *ppSD = pSD;
    }

    FreeSid( AdminsAliasSid );
    FreeSid( PowerUsersAliasSid );
    FreeSid( UsersAliasSid );
    FreeSid( WorldSid );

    LocalFree( TmpAcl );

    return OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\csv.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CSV.C;1  16-Dec-92,10:20:18  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.                *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "host.h"
#include "windows.h"
#include "csv.h"

#ifdef  _WINDOWS

#ifdef HASUI
/*
    Used by most dialog procs to center dialog screen
*/
VOID
FAR PASCAL
CenterDlg(HWND hDlg)
{
    int         screenHeight;
    int         screenWidth;
    RECT        rect;

    GetWindowRect( hDlg, &rect );

    screenHeight = GetSystemMetrics( SM_CYSCREEN );
    screenWidth  = GetSystemMetrics( SM_CXSCREEN );
    MoveWindow( hDlg, 
        (screenWidth  - (rect.right-rect.left)) / 2,
        (screenHeight - (rect.bottom-rect.top)) / 2,
        rect.right-rect.left,
        rect.bottom-rect.top,
        FALSE );
}
#endif // HASUI
#endif

static PSTR     pszLastIn;
static PSTR     pszLastOut;
static char     szToken[ 1024 ];        /* max token 1024 long */

PSTR
FAR PASCAL
CsvToken( PSTR pszBuf )
{
    PSTR        pszCur;
    PSTR        pszOut;
    PSTR        pszReturn;
    BOOL        fDone = FALSE;
    BOOL        fQuote = FALSE;

    if( pszBuf )  {
        pszLastIn = pszBuf;
        pszLastOut = szToken;
    }
    
    pszCur = pszLastIn;
    pszOut = pszLastOut;

    switch( *pszCur )  {
    case '\0':
    case '\n':
        /* check for empty string */
        return( (PSTR)NULL );
    case '"':
        fQuote = TRUE;
        pszCur++;       /* past the quote */
        break;
    }
    while( !fDone && (*pszCur != '\0') && (*pszCur != '\n') )  {
        if( fQuote && (*pszCur == '"') )  {
            if( *(pszCur+1) == '"' )  {
                /* escaped quote */
                *pszOut++ = '"';
                pszCur += 2;    /* past both quotes */
            } else {
                /* done with string */
                fDone = TRUE;
                pszCur++;       /* past quote */
                
                if( (*pszCur == '\n') || (*pszCur == ',') )  {
                    /* past comma or newline */
                    pszCur++;
                }
            }
        } else if( !fQuote && (*pszCur == ',') )  {
            fDone = TRUE;
            /* go past comma */
            pszCur++;
        } else {
            *pszOut++ = *pszCur++;
        }
    }
    *pszOut++ = '\0';
    pszLastIn = pszCur;
    pszReturn = pszLastOut;
    pszLastOut = pszOut;
    
    return( pszReturn );
}

BOOL
FAR PASCAL
TokenBool( PSTR pszToken, BOOL bDefault )
{
    if( pszToken )  {
        if( lstrcmpi( pszToken, "1" ) == 0 )  {
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        return( bDefault );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\lsaval.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"
#include "ntmsv1_0.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#define SKIP_DEBUG_WIN32
#include "debug.h"

void    DumpWhoIAm( char * lpszMsg );

typedef int BOOL;
typedef unsigned int UINT;
typedef unsigned int *PUINT;
typedef unsigned char *LPBYTE;
HANDLE  LsaHandle;
ULONG   AuthenticationPackage;

#define BUF_SIZ 512
char    prtbuf[BUF_SIZ];


void
replstar(
    IN char *  starred,
    OUT LPWSTR UnicodeOut
    )
/*++ replstar

Routine Description:

    replaces the '*' in the string with either spaces or NULL
    if it's the only memeber of the string.  Used by parse().

    Converts the resultant string to unicode.

Arguments:

    char *  starred -

Return Value:

    void -
Warnings:
--*/
{
    char *cp;
    STRING AnsiString;
    UNICODE_STRING UnicodeString;

    if ( !strcmp(starred,"*") ) {
        *starred = '\0';
    } else {
        for ( cp = starred; *cp; ++cp )
            if (*cp == '*')
                *cp = ' ';
    }

    //
    // Convert the result to unicode
    //

    AnsiString.Buffer = starred;
    AnsiString.Length = AnsiString.MaximumLength =
        (USHORT) strlen( starred );

    UnicodeString.Buffer = UnicodeOut;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = BUF_SIZ * sizeof(WCHAR);

    (VOID) RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    return;
}

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )
/*++ NlpPutString

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( Where != NULL && *Where != NULL);

    if ( InString->Length > 0 )
    {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = InString->Length;
        *Where += OutString->MaximumLength;

        RtlCopyString( (PSTRING) OutString, (PSTRING) InString );

    }
    else
    {
        RtlInitUnicodeString(OutString, NULL);
    }

    return;
}


char *
PrintWCS(
    IN  PWCH    pwc,
    IN  ULONG   Length
    )
/*++ PrintWCS

Routine Description:

    return an ANSI type character string given a Unicode string and length
    used in printing out the buffers since our wide strings aren't null
    terminated.

Arguments:
        IN  PWCH    pwc     - unicode string.buffer
        IN  ULONG   Length  - length

Return Value:

    char * - pointer to an ANSI string

Warnings:

    probably not a good idea to use it twice in the same Printf call,
    since it uses the same prtbuf for static storage

--*/
{
    ULONG   i;
    char *bufp    = prtbuf;

    if ( Length == 0 || pwc == NULL ) {
        return "(NULL)";
    }

    Length /= sizeof(WCHAR);

    for ( i = 0; i < Length; ++i, pwc++ )
    {
        sprintf(bufp,"%wc", *pwc );
        ++bufp;
    }
    return prtbuf;
}

char *
PrintLogonId(
    IN  PLUID   LogonId
    )
/*++ PrintLogonId

Routine Description:

    return an ANSI type character string given a logon Id

Arguments:
    IN  PLUID   LogonId - LUID to return in ANSI

Return Value:

    char * - pointer to an ANSI string

Warnings:

    probably not a good idea to use it twice in the same Printf call,
    since it uses the same prtbuf for static storage

--*/
{
    sprintf( prtbuf, "%lX.%lX", LogonId->HighPart, LogonId->LowPart );
    return prtbuf;
}
/* end of "char * PrintLogonId()" */



char *
PrintBytes(
     IN PVOID Buffer,
     IN ULONG Size
 )
/*++ PrintBytes

Routine Description:

    return an ANSI type character string given several binary bytes.

Arguments:
    IN  PVOID   Buffer - Pointer to binary bytes
    IN  ULONG   Size   - Number of bytes to print

Return Value:

    char * - pointer to an ANSI string

Warnings:

    probably not a good idea to use it twice in the same Printf call,
    since it uses the same prtbuf for static storage

--*/
{
    ULONG   i;
    char *bufp    = prtbuf;

    for ( i = 0; i < Size; ++i )
    {
        if ( i != 0 ) {
            *(bufp++) = '.';
        }
        sprintf(bufp,"%2.2x", ((PUCHAR)Buffer)[i] );
        bufp+=2;
    }
    return prtbuf;
}



BOOL
LogonNetwork(
    IN  LPWSTR      Username,
    IN  PUCHAR      ChallengeToClient,
    IN  PMSV1_0_GETCHALLENRESP_RESPONSE ChallengeResponse,
    IN  UINT        cbChallengeResponse,
    IN  LPWSTR      Domain,
    OUT PLUID       LogonId,
    OUT PHANDLE     TokenHandle
    )
/*++ LogonNetwork

Routine Description:

    Logs a user onto the network

Arguments:
        IN  LPWSTR  Username    - self explanatory
        IN  ChallengeToClient   -  The challenge sent to the client
        IN  ChallengeResponse   -  The response sent from the client
        IN  LPWSTR  Domain      - Logon Domain Name
        OUT PLUID   LogonId     - Unique generated logon id
        OUT PHANDLE TokenHandle - handle to the logon token

Return Value:

    BOOL -

Warnings:

--*/
{
    NTSTATUS            Status;
    UNICODE_STRING      TempString;
    UNICODE_STRING      TempString2;
    UNICODE_STRING      OriginName;
    PMSV1_0_LM20_LOGON  Auth;
    PCHAR               Auth1[BUF_SIZ*5]; /* lots o' space */
    PUCHAR              Strings;
    PMSV1_0_LM20_LOGON_PROFILE ProfileBuffer;
    ULONG               ProfileBufferSize;
    NTSTATUS            SubStatus;
    TOKEN_SOURCE        SourceContext;
    QUOTA_LIMITS        QuotaLimits;


    /*
     *  Fill in the Authentication structure.
     */
    Auth = (PMSV1_0_LM20_LOGON) Auth1;

    Strings = (PUCHAR)(Auth + 1);

    Auth->MessageType = MsV1_0Lm20Logon;
    RtlMoveMemory( Auth->ChallengeToClient,
                   ChallengeToClient,
                   MSV1_0_CHALLENGE_LENGTH );

    /* Init Strings
     *  username
     */
    RtlInitUnicodeString( &TempString, Username );
    NlpPutString( &Auth->UserName, &TempString, &Strings );

    /*
     *  workstation name
     */
    RtlInitUnicodeString( &TempString, L"NetDDE" );
    NlpPutString( &Auth->Workstation, &TempString, &Strings );

    /*
     *  Challenge Response
     */

    Auth->CaseSensitiveChallengeResponse.Length = 0;
    Auth->CaseSensitiveChallengeResponse.MaximumLength = 0;
    Auth->CaseSensitiveChallengeResponse.Buffer = NULL;


#ifdef OLD
    RtlInitUnicodeString(
        (PUNICODE_STRING)&TempString2,
        (PCWSTR)ChallengeResponse );
#else
    TempString2.Buffer = (PWSTR)ChallengeResponse;
    TempString2.Length = (USHORT)cbChallengeResponse;
    TempString2.MaximumLength = TempString2.Length;
#endif
    if( TempString2.Length > 24 )  {
        TempString2.Length = 24;
    }
    NlpPutString(
        (PUNICODE_STRING)&Auth->CaseInsensitiveChallengeResponse,
        (PUNICODE_STRING)&TempString2,
        &Strings );
    /*
     *  domain
     */
    RtlInitUnicodeString( &TempString, Domain );
    NlpPutString( &Auth->LogonDomainName, &TempString, &Strings );


    RtlInitUnicodeString( &OriginName, L"NetDDE" );

    //
    // Initialize source context structure
    //
    strncpy(SourceContext.SourceName, "NetDDE  ", sizeof(SourceContext.SourceName));

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaLogonUser(
                    LsaHandle,
                    (PSTRING)&OriginName,
                    Network,
                    AuthenticationPackage,
                    // LATER? AuthenticationPackage | LSA_CALL_LICENSE_SERVER,
                    Auth,
                    (ULONG)(Strings - (PUCHAR)Auth),
                    NULL,
                    &SourceContext,
                    (PVOID *)&ProfileBuffer,
                    &ProfileBufferSize,
                    LogonId,
                    TokenHandle,
                    &QuotaLimits,
                    &SubStatus );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        // LSA Can't be trusted to not scrog our variables
        *TokenHandle = NULL;
        return( FALSE );
    }
    LsaFreeReturnBuffer( ProfileBuffer );

    return( TRUE );
}

BOOL
Challenge(
    UCHAR *ChallengeToClient
    )
/*++ Challenge

Routine Description:

    get a challenge

Arguments:
        OUT  ChallengeToClient -  Returns the challenge to send to the client

Return Value:
    NTSTATUS -
Warnings:
--*/
{
    NTSTATUS Status;
    NTSTATUS ProtocolStatus;
    ULONG    ResponseSize;
    MSV1_0_LM20_CHALLENGE_REQUEST Request;
    PMSV1_0_LM20_CHALLENGE_RESPONSE Response;

#ifdef HARD_CODE_CHALLENGE
    { int i;
        for( i=0; i<8; i++ )  {
            ChallengeToClient[i] = 0;
        }
    }
    return STATUS_SUCCESS;
#endif

    /*
     *  Fill in the Authentication structure.
     */

    Request.MessageType = MsV1_0Lm20ChallengeRequest;

    Status = LsaCallAuthenticationPackage (
                    LsaHandle,
                    AuthenticationPackage,
                    &Request,
                    sizeof(Request),
                    (PVOID *)&Response,
                    &ResponseSize,
                    &ProtocolStatus );

    if ( !NT_SUCCESS( Status ) || !NT_SUCCESS( ProtocolStatus) )
    {
        return( FALSE );
    }

    RtlMoveMemory( ChallengeToClient,
                   Response->ChallengeToClient,
                   MSV1_0_CHALLENGE_LENGTH );

    LsaFreeReturnBuffer( Response );

    return( TRUE );
}

BOOL
LocalLSAInit( void )
{
    STRING      LogonProcessName;
    STRING      PackageName;
    NTSTATUS    Status;
    LSA_OPERATIONAL_MODE SecurityMode;
    static BOOL bInit = FALSE;
    static BOOL bOk = FALSE;

    if( bInit )  {
        return( bOk );
    }
    bInit = TRUE;
    RtlInitAnsiString( &LogonProcessName, "NetDDE" );
    Status = LsaRegisterLogonProcess(
                &LogonProcessName,
                &LsaHandle,
                &SecurityMode );

    if ( !NT_SUCCESS( Status ) )
    {
        return( FALSE );
    }

    RtlInitAnsiString( &PackageName,  MSV1_0_PACKAGE_NAME );

    Status = LsaLookupAuthenticationPackage(
                LsaHandle,
                &PackageName,
                &AuthenticationPackage );

    if ( !NT_SUCCESS( Status ) )
    {
        return( FALSE );
    }

    bOk = TRUE;
    return( TRUE );
}


BOOL NDDEGetChallenge(
    LPBYTE lpChallenge,
    UINT cbSize,
    PUINT lpcbChallengeSize
    )
{
    if( LocalLSAInit() )  {
        *lpcbChallengeSize = 8;
        Challenge( lpChallenge );
        return( TRUE );
    } else {
        return( FALSE );
    }
}

BOOL
NDDEValidateLogon(
    LPBYTE  lpChallenge,
    UINT    cbChallengeSize,
    LPBYTE  lpResponse,
    UINT    cbResponseSize,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    PHANDLE phLogonToken
    )
{
    WCHAR       wcUser[ BUF_SIZ ];
    WCHAR       wcDomain[ BUF_SIZ ];
    LUID        LogonId;
    BOOL        nlRet;

    if( !LocalLSAInit() )  {
        return( FALSE );
    }
    replstar( lpszUserName, wcUser );
    replstar( lpszDomainName, wcDomain );
    nlRet = LogonNetwork( wcUser, lpChallenge,
        (PMSV1_0_GETCHALLENRESP_RESPONSE)lpResponse,
        cbResponseSize, wcDomain, &LogonId, phLogonToken );
    return( nlRet );
}

BOOL
NDDEGetChallengeResponse(
    LUID        LogonId,
    LPSTR       lpszPasswordK1,
    int         cbPasswordK1,
    LPSTR       lpszChallenge,
    int         cbChallenge,
    int         *pcbPasswordK1,
    BOOL        *pbHasPasswordK1 )
{
    BOOL        ok = TRUE;
    NTSTATUS Status;
    NTSTATUS ProtocolStatus;
    ULONG    ResponseSize;
    PMSV1_0_GETCHALLENRESP_RESPONSE Response;
    PMSV1_0_GETCHALLENRESP_REQUEST Request;

    PCHAR          Auth1[BUF_SIZ];
    PUCHAR         Strings;


    if( !LocalLSAInit() )  {
        *pbHasPasswordK1 = FALSE;
        return( FALSE );
    }
    Request = (PMSV1_0_GETCHALLENRESP_REQUEST) Auth1;
    Request->MessageType = MsV1_0Lm20GetChallengeResponse;
    Request->ParameterControl = 0;
    Request->ParameterControl |= USE_PRIMARY_PASSWORD;
    Request->LogonId = LogonId;
    Strings = (PUCHAR)(Request + 1);
    RtlMoveMemory( Request->ChallengeToClient,
                   lpszChallenge,
                   cbChallenge );

    RtlInitUnicodeString( &Request->Password, NULL );
    Status = LsaCallAuthenticationPackage (
                    LsaHandle,
                    AuthenticationPackage,
                    Request,
                    sizeof(MSV1_0_GETCHALLENRESP_REQUEST),
                    (PVOID *)&Response,
                    &ResponseSize,
                    &ProtocolStatus );
    if ( !NT_SUCCESS( Status ) || !NT_SUCCESS( ProtocolStatus) )
    {
        return( FALSE );
    }

    *pcbPasswordK1 = (Response)->CaseInsensitiveChallengeResponse.Length;
    memcpy( lpszPasswordK1,
        (Response)->CaseInsensitiveChallengeResponse.Buffer,
        (Response)->CaseInsensitiveChallengeResponse.Length );
    *pbHasPasswordK1 = TRUE;

    LsaFreeReturnBuffer( Response );

    return( TRUE );
}

HANDLE
OpenCurrentUserKey(ULONG DesiredAccess)
{
    NTSTATUS    Status;
    HANDLE      CurrentUserKey;

    Status = RtlOpenCurrentUser( DesiredAccess, &CurrentUserKey);
    if (NT_SUCCESS( Status) ) {
        return(CurrentUserKey);
    } else {
        DPRINTF(("Unable to open current user key: %d", Status));
        return(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\dder.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DDER.C;9  9-Dec-92,8:34:44  LastEdit=IGORM  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
$History: End */

/*
TODO
    - make sure we're freeing lpDdePkts properly for all cases
*/
#include    "host.h"
#include        <windows.h>
#include        <hardware.h>

#ifdef _WINDOWS
#include    <memory.h>
#include    <string.h>
#include    <time.h>
#endif

#include    "dde.h"
#include    "wwdde.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "pktz.h"
#include    "dder.h"
#include    "ipc.h"
#include    "router.h"
#include    "internal.h"
#include    "wwassert.h"
#include    "hexdump.h"
#include    "host.h"
#include    "userdde.h"
#include    "scrnupdt.h"
#include    "security.h"
#include    "seckey.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "netddesh.h"

#ifdef _WINDOWS
#include    "nddeapi.h"
#include    "nddeapis.h"
#include    "winmsg.h"
#endif

USES_ASSERT

/*
states
*/
#define DDER_INIT               (1)
#define DDER_WAIT_IPC_INIT      (2)
#define DDER_WAIT_ROUTER        (3)
#define DDER_WAIT_NET_INIT      (4)
#define DDER_CONNECTED          (5)
#define DDER_CLOSED             (6)


/*
DDER
    Structure for each DDER
*/
typedef struct s_dder {
/*  dd_prev, dd_next: links for all DDERs */
struct s_dder FAR   *dd_prev;
struct s_dder FAR   *dd_next;

/* dd_state: current state of DDER */
WORD                 dd_state;

/* dd_type: type of connection: DDTYPE_LOCAL_NET, DDTYPE_NET_LOCAL or
    DDTYPE_LOCAL_LOCAL */
WORD                 dd_type;

/* dd_hDderRemote: handle to corresponding DDER on remote system.
    NULL if local-local */
HDDER                dd_hDderRemote;

/* dd_hRouter: handle to router for this DDER.  NULL if local-local */
HROUTER              dd_hRouter;

/* dd_hIpcClient:  handle to IPC Client, NULL iff net->local */
HIPC                 dd_hIpcClient;

/* dd_hIpcServer:  handle to IPC Server, NULL iff local->net */
HIPC                 dd_hIpcServer;

/* dd_dderPrevForRouter: links of DDER's associated with router */
HDDER                dd_dderPrevForRouter;
HDDER                dd_dderNextForRouter;

/* statistics */
DWORD                   dd_sent;
DWORD                   dd_rcvd;

/* permission */
BOOL                    dd_bAdvisePermitted;
BOOL                    dd_bRequestPermitted;
BOOL                    dd_bPokePermitted;
BOOL                    dd_bExecutePermitted;
BOOL                    dd_bSecurityViolated;
BOOL                    dd_bClientTermRcvd;
BOOL                    dd_bWantToFree;
BOOL                    dd_pad;

/* dd_pktInitiate: initiate packet saved from waiting for router */
LPDDEPKTINIT            dd_lpDdePktInitiate;

/* dd_pktInitAck: initiate ack packet that guarantees that we have
    memory for it */
LPDDEPKTIACK            dd_lpDdePktInitAck;

/* terminate packets for client and server */
LPDDEPKTTERM            dd_lpDdePktTermServer;

/*  client's access token */
HANDLE                  dd_hClientAccessToken;

/*  pointer to share info */
PNDDESHAREINFO          dd_lpShareInfo;
} DDER;
typedef DDER FAR *LPDDER;

/*
External variables used
*/
#if DBG
extern  BOOL    bDebugInfo;
#endif // DBG
extern  HHEAP   hHeap;
extern  char    ourNodeName[ MAX_NODE_NAME+1 ];
extern  BOOL    bLogPermissionViolations;
extern  BOOL    bDefaultStartApp;
extern  DWORD   dwSecKeyAgeLimit;
extern  UINT    wMsgIpcInit;
/*
Local variables
*/
static  LPDDER          lpDderHead;

/*
Local routines
*/
#if DBG
VOID    FAR PASCAL DebugDderState(void);
VOID    DumpDder(LPDDER);
#endif // DBG

VOID    DderFree( HDDER hDder );
HDDER   DderCreate( void );
VOID    DderSendInitiateNackPacket( LPDDEPKTIACK lpDdePktInitAck,
        HDDER hDder, HDDER hDderDst, HROUTER hRouter, DWORD dwReason );

BOOL    SecurityValidate( LPDDER lpDder, LPSTR lpItem, BOOL bAllowed );

BOOL _stdcall NDDEGetChallenge(
LPBYTE lpChallenge,
UINT cbSize,
PUINT lpcbChallengeSize
);

DWORD   dwReasonInitFail;

#ifdef BYTE_SWAP
static VOID     ConvertDdePkt( LPDDEPKT lpDdePkt, BOOL bIncoming );
#else
#define ConvertDdePkt(x,y)
#endif



VOID
DderConnectionComplete(
HDDER   hDder,
HROUTER hRouter )
{
    LPDDER      lpDder;
    HDDER       hDderNext;
    BOOL        bFree = FALSE;

    DIPRINTF(( "DderConnectionComplete( %08lX, %08lX )", hDder, hRouter ));
    if( hDder == 0 )  {
        return;
    }

    lpDder = (LPDDER) hDder;

    hDderNext = lpDder->dd_dderNextForRouter;

    if( lpDder->dd_state == DDER_WAIT_ROUTER )  {
        assert( lpDder->dd_type == DDTYPE_LOCAL_NET );
        if( hRouter == 0 )  {
        /* couldn't get connection */
        assert( lpDder->dd_hIpcClient );

        /* abort the conversation */
        IpcAbortConversation( lpDder->dd_hIpcClient );
        lpDder->dd_hIpcClient = 0;

        bFree = TRUE;
        } else {
        /* got connection, send the init to the other side */
        lpDder->dd_state = DDER_WAIT_NET_INIT;
        UpdateScreenState();

        /* remember the router */
        lpDder->dd_hRouter = hRouter;

        /* convert byte-ordering */
        ConvertDdePkt( (LPDDEPKT)lpDder->dd_lpDdePktInitiate, FALSE );

        lpDder->dd_sent++;
        UpdateScreenStatistics();

        /* send the packet */
        RouterPacketFromDder( lpDder->dd_hRouter, (HDDER)lpDder,
            (LPDDEPKT)lpDder->dd_lpDdePktInitiate );

        /* mark that we don't have the initiate packet anymore */
        lpDder->dd_lpDdePktInitiate = NULL;
        }
    }

    /* tell next hDder in list */
    if( hDderNext )  {
        DderConnectionComplete( hDderNext, hRouter );
    }

    if( bFree && hDder )  {
        DderFree( hDder );
    }
}


VOID
DderConnectionBroken( HDDER hDder )
{
    LPDDER      lpDder;
    HDDER       hDderNext;

    DIPRINTF(( "DderConnectionBroken( %08lX )", hDder ));

    if( hDder == 0 )  {
        return;
    }

    lpDder = (LPDDER) hDder;

    hDderNext = lpDder->dd_dderNextForRouter;

    /* assure that we don't talk to router anymore */
    lpDder->dd_hRouter = 0;

    if ( (lpDder->dd_type != DDTYPE_LOCAL_NET) &&
        (lpDder->dd_type != DDTYPE_NET_LOCAL) ) {
        InternalError("Bad DD type, %8lX lpDder->dd_type: %d",
            hDder, lpDder->dd_type);
        }

    /* abort DDE conversations */
    if( lpDder->dd_hIpcClient )  {
        IpcAbortConversation( lpDder->dd_hIpcClient );
        lpDder->dd_hIpcClient = 0;
    }
    if( lpDder->dd_hIpcServer )  {
        IpcAbortConversation( lpDder->dd_hIpcServer );
        lpDder->dd_hIpcServer = 0;
    }

    /* release us */
    DderFree( hDder );

    /* tell next hDder in list */
    if( hDderNext )  {
        DderConnectionBroken( hDderNext );
    }
}

VOID
DderSendInitiateNackPacket(
    LPDDEPKTIACK    lpDdePktInitAck,
    HDDER           hDder,
    HDDER           hDderDest,
    HROUTER         hRouter,
    DWORD           dwReason )
{
    LPDDEPKT        lpDdePkt        = (LPDDEPKT) lpDdePktInitAck;
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKTCMN     lpDdePktCmn;
    LPDDEPKTIACK    lpDdePktIack;
    LPBYTE          lpSecurityKey   = NULL;
    DWORD           sizeSecurityKey = 0L;
    DWORD           hSecurityKey;

    assert( lpDdePktInitAck );
    assert( hRouter );

    if( dwReason == RIACK_NEED_PASSWORD )  {
        lpDdePktInit = (LPDDEPKTINIT) lpDdePktInitAck;
        DdeSecKeyObtainNew( &hSecurityKey, &lpSecurityKey, &sizeSecurityKey );
        if( lpSecurityKey )  {
                lpDdePktIack = (LPDDEPKTIACK) CreateAckInitiatePkt( ourNodeName,
                    GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToApp),
                    GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToTopic),
                    lpSecurityKey, sizeSecurityKey, hSecurityKey,
                    FALSE, dwReason);
                if( lpDdePktIack )  {    /* created new one, dump old */
                    HeapFreePtr(lpDdePkt);
                    lpDdePkt = (LPDDEPKT) lpDdePktIack;
                    lpDdePkt->dp_hDstDder = hDderDest;
                } else {
                    dwReason = RIACK_DEST_MEMORY_ERR;
                }
        } else {
                dwReason = RIACK_DEST_MEMORY_ERR;
        }
    }

    if (dwReason != RIACK_NEED_PASSWORD) {   /* convert INIT to NACK initiate packet */
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktInitAck;
        lpDdePkt->dp_size = sizeof(DDEPKTIACK);
        lpDdePkt->dp_hDstDder = hDderDest;

        lpDdePktCmn->dc_message = WM_DDE_ACK_INITIATE;
        lpDdePktInitAck->dp_iack_offsFromNode = 0;
        lpDdePktInitAck->dp_iack_offsFromApp = 0;
        lpDdePktInitAck->dp_iack_offsFromTopic = 0;
        lpDdePktInitAck->dp_iack_fromDder = 0;
        lpDdePktInitAck->dp_iack_reason = dwReason;
    }

    /* convert byte-ordering */
    ConvertDdePkt( lpDdePkt, FALSE );

    /* xmit the packet */
    RouterPacketFromDder( hRouter, hDder, lpDdePkt );
}

BOOL
SecurityCheckPkt(
    LPDDER      lpDder,
    LPDDEPKT    lpDdePkt,
    LPDDEPKT   *lplpDdePkt )
{
    BOOL            bSend           = TRUE;
    BOOL            bViolation      = FALSE;
    LPDDEPKTCMN     lpDdePktCmn     = (LPDDEPKTCMN) lpDdePkt;
    LPDDEPKTADVS    lpDdePktAdvs;
    LPDDEPKTRQST    lpDdePktRqst;
    LPDDEPKTPOKE    lpDdePktPoke;
    LPSTR           lpItem          = NULL;

    if( lpDder->dd_bSecurityViolated )  {
        /* already terminated because of security ... ignore pkt */
        bSend = FALSE;
        HeapFreePtr( lpDdePkt );
    } else {
        /* must check this message */
        bViolation = FALSE;
        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ADVISE:
                lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
                lpItem = GetStringOffset(lpDdePkt, lpDdePktAdvs->dp_advs_offsItemName);
                if( !SecurityValidate( lpDder, lpItem, lpDder->dd_bAdvisePermitted ) )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: %1 on "%2"  */
                        NDDELogWarning(MSG102, "DDE_ADVISE", (LPSTR)lpItem, NULL);
                    }
                }
                break;

        case WM_DDE_REQUEST:
                lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
                lpItem = GetStringOffset(lpDdePkt, lpDdePktRqst->dp_rqst_offsItemName);
                if( !SecurityValidate( lpDder, lpItem, lpDder->dd_bRequestPermitted ) )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: %1 on "%2"  */
                        NDDELogWarning(MSG102, "DDE_REQUEST", (LPSTR)lpItem, NULL);
                    }
                }
                break;

        case WM_DDE_POKE:
                lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
                lpItem = GetStringOffset(lpDdePkt,
                lpDdePktPoke->dp_poke_offsItemName);
                if( !SecurityValidate( lpDder, lpItem, lpDder->dd_bPokePermitted ) )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: %1 on "%2"  */
                        NDDELogWarning(MSG102, "DDE_POKE", (LPSTR)lpItem, NULL);
                    }
                }
                break;

        case WM_DDE_EXECUTE:
                if( !lpDder->dd_bExecutePermitted )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: DDE_EXECUTE"  */
                        NDDELogWarning(MSG103, NULL);
                    }
                }
                break;

        default:
            break;
    }

        if( bViolation )  {
                /*
             * free the packet that the client is trying to send
             */
                HeapFreePtr( lpDdePkt );

                /*
             * pretend the client sent a terminate
             */
                lpDdePkt = (LPDDEPKT) lpDder->dd_lpDdePktTermServer;
                lpDder->dd_lpDdePktTermServer = NULL;
                FillTerminatePkt( lpDdePkt );

                /*
             * note that we've had this violation, so that we
                 * ignore any future packets from this client
                 */
                lpDder->dd_bSecurityViolated = TRUE;
        }
    }
    *lplpDdePkt = lpDdePkt;
    return( bSend );
}

VOID
DderPacketFromRouter(
    HROUTER     hRouter,
    LPDDEPKT    lpDdePkt )
{
    HDDER           hDder;
    LPDDER          lpDder;
    LPDDEPKTCMN     lpDdePktCmn     = (LPDDEPKTCMN) lpDdePkt;
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKTIACK    lpDdePktInitAck;
    HIPC            hIpcDest;
    HDDER           hDderDest;
    BOOL            bFree           = FALSE;
    BOOL            bSend           = TRUE;

    DIPRINTF(( "DderPacketFromRouter( %08lX, %08lX )", hRouter, lpDdePkt ));
    /* convert byte-ordering */
    ConvertDdePkt( lpDdePkt, TRUE );

    hDder = lpDdePkt->dp_hDstDder;
    DIPRINTF(( "    hDder: %08lX", hDder ));

    assert( hRouter );
    lpDder = (LPDDER) hDder;
    if( lpDder == NULL )  {
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        assert( lpDdePktCmn->dc_message == WM_DDE_INITIATE );

        /* must be an initiate request */
        dwReasonInitFail = RIACK_UNKNOWN;
        hDder = DderInitConversation( 0, hRouter, lpDdePkt );
        if( hDder == 0 )  {
        /* couldn't create the conversation */

        /* use init packet to nack */
        hDderDest = lpDdePktInit->dp_init_fromDder;
        DderSendInitiateNackPacket( (LPDDEPKTIACK) lpDdePkt, hDder,
            hDderDest, hRouter, dwReasonInitFail );
        } else {
        RouterAssociateDder( hRouter, hDder );
        lpDder = (LPDDER) hDder;
        lpDder->dd_rcvd++;
        UpdateScreenStatistics();
        }
    } else {
        /* valid DDER */
        if( lpDder->dd_type == DDTYPE_LOCAL_NET )  {
        assert( lpDder->dd_hIpcClient );
        hIpcDest = lpDder->dd_hIpcClient;
        } else {
        assert( lpDder->dd_type == DDTYPE_NET_LOCAL );
        assert( lpDder->dd_hIpcServer );
        hIpcDest = lpDder->dd_hIpcServer;
        }

        lpDder->dd_rcvd++;
        UpdateScreenStatistics();

        /* look at message that is being sent */
        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ACK_INITIATE:
        lpDdePktInitAck = (LPDDEPKTIACK) lpDdePkt;
        lpDder->dd_hDderRemote = lpDdePktInitAck->dp_iack_fromDder;
        if( lpDder->dd_hDderRemote == 0 )  {
            bFree = TRUE;
            lpDder->dd_state = DDER_CLOSED;
        } else {
            lpDder->dd_state = DDER_CONNECTED;
        }
        UpdateScreenState();

        /* tell IPC */
        IpcXmitPacket( hIpcDest, (HDDER)lpDder, lpDdePkt );
        break;
        case WM_DDE_TERMINATE:
        bSend = TRUE;
        if( lpDder->dd_type == DDTYPE_NET_LOCAL )  {
            lpDder->dd_bClientTermRcvd = TRUE;
            if( lpDder->dd_bSecurityViolated )  {
                bSend = FALSE;      /* already been sent */
                if( lpDder->dd_bWantToFree )  {
                    bFree = TRUE;
                }
            }
        }
        if( bSend )  {
            /* tell IPC */
            IpcXmitPacket( hIpcDest, (HDDER)lpDder, lpDdePkt );
        }
        break;

        default:
        if( lpDder->dd_type == DDTYPE_LOCAL_NET )  {
            /* must be from server to client, just send the msg along */
            bSend = TRUE;
        } else {
            /*it's from a client to a srvr ... must validate permissions*/
            bSend = SecurityCheckPkt( lpDder, lpDdePkt, &lpDdePkt );
        }
        if( bSend )  {
            /* on messages other than ack_init, well just pass
                through to IPC */
            IpcXmitPacket( hIpcDest, (HDDER)lpDder, lpDdePkt );
        }
        }
    }
    if( bFree && hDder )  {
        DderFree( hDder );
    }
}

VOID
DderPacketFromIPC(
    HDDER       hDder,
    HIPC        hIpcFrom,
    LPDDEPKT    lpDdePkt )
{
    LPDDER              lpDder;
    HIPC                hIpcDest;
    BOOL                bFree = FALSE;
    BOOL                bSend = TRUE;
    LPDDEPKTINIT        lpDdePktInit;
    LPDDEPKTIACK        lpDdePktInitAck;
    LPDDEPKTCMN         lpDdePktCmn;

    assert( hDder );
    lpDder = (LPDDER) hDder;

#if DBG
    if( bDebugInfo ) {
        DPRINTF(( "DderPacketFromIPC( %08lX, %08lX, %08lX )",
        hDder, hIpcFrom, lpDdePkt ));
        DebugDdePkt( lpDdePkt );
    }
#endif // DBG

    /* if the message was a NACK initiate message, let's close down */
    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_INITIATE:
        dwReasonInitFail = RIACK_UNKNOWN;
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        break;

    case WM_DDE_ACK_INITIATE:
        /* if the other side is NACKing the initiate,
        pass it on and then free us */
        lpDdePktInitAck = (LPDDEPKTIACK) lpDdePkt;
        if( lpDdePktInitAck->dp_iack_fromDder == 0 )  {
                bFree = TRUE;
                lpDder->dd_state = DDER_CLOSED;
        } else {
                /* save our hDder in this packet */
                lpDdePktInitAck->dp_iack_fromDder = hDder;
                lpDder->dd_state = DDER_CONNECTED;
        }
        if( lpDder->dd_type == DDTYPE_LOCAL_LOCAL )  {
                lpDder->dd_hIpcServer = hIpcFrom;
        }

        UpdateScreenState();
        break;
    }
    switch( lpDder->dd_type )  {
    case DDTYPE_LOCAL_NET:
    case DDTYPE_NET_LOCAL:
        lpDdePkt->dp_hDstDder = lpDder->dd_hDderRemote;

        /*
         * convert byte-ordering
         */
        ConvertDdePkt( lpDdePkt, FALSE );

        lpDder->dd_sent++;
        UpdateScreenStatistics();
        RouterPacketFromDder( lpDder->dd_hRouter, hDder, lpDdePkt );
        break;

    case DDTYPE_LOCAL_LOCAL:
        if( hIpcFrom == lpDder->dd_hIpcClient )  {
                hIpcDest = lpDder->dd_hIpcServer;
                if( lpDdePktCmn->dc_message == WM_DDE_TERMINATE )  {
                    lpDder->dd_bClientTermRcvd = TRUE;
                    if( lpDder->dd_bSecurityViolated )  {
                        bSend = FALSE;      /* already been sent */
                        if( lpDder->dd_bWantToFree )  {
                            bFree = TRUE;
                        }
                    }
                } else {
                    bSend = SecurityCheckPkt( lpDder, lpDdePkt, &lpDdePkt );
            }
        } else {
        bSend = TRUE;
        if( hIpcFrom != lpDder->dd_hIpcServer )  {
            InternalError(
                "Expecting from %08lX to be %08lX or %08lX",
                hIpcFrom, lpDder->dd_hIpcServer,
                lpDder->dd_hIpcClient );
        }
        hIpcDest = lpDder->dd_hIpcClient;
        }

        if( bSend )  {
                assert( hIpcDest );
                lpDder->dd_sent++;
                lpDder->dd_rcvd++;
                UpdateScreenStatistics();

                /*
             * xmit packet to other side
             */
                IpcXmitPacket( hIpcDest, hDder, lpDdePkt );
        }
        break;
    }

    /*
     * don't free it if we are in the middle of waiting for ipc init
     * to return
     */
    if( bFree && hDder && (lpDder->dd_state != DDER_WAIT_IPC_INIT) )  {
        DderFree( hDder );
    }
}


/*
 * Phase 5 of WM_DDE_INITIATE processing.
 *
 *
 */
HDDER
DderInitConversation(
    HIPC        hIpc,
    HROUTER     hRouter,
    LPDDEPKT    lpDdePkt )
{
    HDDER               hDder;
    LPDDER              lpDder;
    LPDDEPKTINIT        lpDdePktInit;
    LPSTR               lpszPktItem;
    BOOL                ok = TRUE;
    BOOL                bStart;
    BOOL                bSavedPkt = FALSE;
    char                cmdLine[ MAX_APP_NAME + MAX_TOPIC_NAME + 2];

    LPBYTE              lpSecurityKey   = NULL;
    DWORD               sizeSecurityKey = 0L;
    DWORD               hSecurityKey;
    LPDDEPKTIACK        lpDdePktIack;

    PTHREADDATA         ptd;
    IPCINIT             pii;

    DIPRINTF(( "DderInitConversation( %08lX, %08lX, %08lX )",
            hIpc, hRouter, lpDdePkt ));

    hDder = DderCreate();
    dwReasonInitFail = RIACK_UNKNOWN;
    if( hDder )  {
        lpDder = (LPDDER) hDder;
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        if( !hRouter )  {
            /* this came from IPC */

            /* blank out appropriate fields of msg */
            lpDdePkt->dp_hDstDder = 0;
            lpDdePkt->dp_hDstRouter = 0;
            lpDdePkt->dp_routerCmd = 0;
            lpDder->dd_lpDdePktInitiate = lpDdePktInit;

            /* mark that we saved the packet */
            bSavedPkt = TRUE;
        }

        lpszPktItem = GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToNode);
        /*
         * if destination node is blank, assume our node
         */
        DIPRINTF(("   with \"%Fs\"", lpszPktItem ));
        if( (lstrcmpi( lpszPktItem, ourNodeName ) == 0) ||
                (lstrlen(lpszPktItem) == 0) )  {
            /*
             * destination is our node
             */
            if( hRouter )  {
                /*
                 * this came from router
                 */
                assert( hIpc == 0 );
                lpDder->dd_type = DDTYPE_NET_LOCAL;
                lpDder->dd_hRouter = hRouter;
                lpDder->dd_hDderRemote = lpDdePktInit->dp_init_fromDder;
            } else {
                /*
                 * this came from IPC
                 */
                assert( hIpc != 0 );
                lpDder->dd_type = DDTYPE_LOCAL_LOCAL;
                lpDder->dd_hIpcClient = hIpc;
            }
        } else {
            /*
             * destination is another node
             * this came from IPC
             */
            assert( hIpc != 0 );
            assert( hRouter == 0 );
            lpDder->dd_type = DDTYPE_LOCAL_NET;
            lpDdePktInit->dp_init_fromDder = (HDDER) lpDder;
            lpDder->dd_hIpcClient = hIpc;
        }
        switch( lpDder->dd_type )  {
        case DDTYPE_NET_LOCAL:
            lpDder->dd_state = DDER_WAIT_IPC_INIT;
            bStart = FALSE;
            cmdLine[0] = '\0';

            pii.hDder = hDder;
            pii.lpDdePkt = lpDdePkt;
            pii.bStartApp = bStart;
            pii.lpszCmdLine = cmdLine;
            pii.dd_type = lpDder->dd_type;

            /*
             * Try sending wMsgIpcInit to each NetDDE window (one for each
             * desktop) and see if a connection results.
             */
            for (ptd = ptdHead;
                    dwReasonInitFail != RIACK_NEED_PASSWORD &&
                    ptd != NULL;
                        ptd = ptd->ptdNext) {

                lpDder->dd_hIpcServer = SendMessage(
                        ptd->hwndDDE,
                        wMsgIpcInit,
                        (WPARAM)&pii,
                        0);

                if (lpDder->dd_hIpcServer != 0)
                    break;

            }

            if( lpDder->dd_hIpcServer == 0 )  {
                DIPRINTF(("Ipc Net->Local failed.  Status = %d\n", dwReasonInitFail));
                if (dwReasonInitFail == RIACK_UNKNOWN) {
                    dwReasonInitFail = RIACK_STARTAPP_FAILED;
                }
                lpDder->dd_hRouter = 0;
                ok = FALSE;
            }
            if (lpDdePktInit->dp_init_hSecurityKey != 0) {
                DdeSecKeyRelease( lpDdePktInit->dp_init_hSecurityKey );
                lpDdePktInit->dp_init_hSecurityKey = 0;
            }
            break;

        case DDTYPE_LOCAL_LOCAL:
            lpDder->dd_state = DDER_WAIT_IPC_INIT;
            bStart = FALSE;
            cmdLine[0] = '\0';

            pii.hDder = hDder;
            pii.lpDdePkt = lpDdePkt;
            pii.bStartApp = bStart;
            pii.lpszCmdLine = cmdLine;
            pii.dd_type = lpDder->dd_type;

            for (ptd = ptdHead; dwReasonInitFail == RIACK_UNKNOWN &&
                    ptd != NULL; ptd = ptd->ptdNext) {
                lpDder->dd_hIpcServer = SendMessage(ptd->hwndDDE, wMsgIpcInit,
                        (WPARAM)&pii, 0);
                if (lpDder->dd_hIpcServer != 0)
                    break;
                if (dwReasonInitFail == RIACK_NOPERM_TO_STARTAPP) {
                    dwReasonInitFail = RIACK_UNKNOWN;
                    continue;
                }
                if( dwReasonInitFail == RIACK_NEED_PASSWORD )  {
                            DdeSecKeyObtainNew( &hSecurityKey, &lpSecurityKey,
                                        &sizeSecurityKey );
                            if( lpSecurityKey )  {
                                lpDdePktIack = (LPDDEPKTIACK)
                                    CreateAckInitiatePkt( ourNodeName,
                                        GetStringOffset(lpDdePkt,
                                            lpDdePktInit->dp_init_offsToApp),
                                        GetStringOffset(lpDdePkt,
                                            lpDdePktInit->dp_init_offsToTopic),
                                        lpSecurityKey, sizeSecurityKey, hSecurityKey,
                                        FALSE, dwReasonInitFail );
                                if( lpDdePktIack )  {
                                    IpcXmitPacket( lpDder->dd_hIpcClient,
                                                (HDDER)lpDder, (LPDDEPKT)lpDdePktIack );
                                } else {
                                    dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
                                }
                            } else {
                                dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
                            }
                    break;
                    }
            }
            if( lpDder->dd_hIpcServer == 0 )  {
                DIPRINTF(("Ipc Local->Local failed.  Status = %d\n", dwReasonInitFail));
                if (dwReasonInitFail == RIACK_UNKNOWN)
                    dwReasonInitFail = RIACK_STARTAPP_FAILED;
                lpDder->dd_hRouter = 0;
                ok = FALSE;
            }
            if (lpDdePktInit->dp_init_hSecurityKey != 0) {
                DdeSecKeyRelease( lpDdePktInit->dp_init_hSecurityKey );
                lpDdePktInit->dp_init_hSecurityKey = 0;
            }
            break;

        case DDTYPE_LOCAL_NET:
            lpDder->dd_state = DDER_WAIT_ROUTER;
            /*
             * note that RouterGetRouterForDder() will associate Dder with
             * the router if OK
             */
            if( !RouterGetRouterForDder( GetStringOffset(lpDdePkt,
                    lpDdePktInit->dp_init_offsToNode), hDder ) )  {
                dwReasonInitFail = RIACK_ROUTE_NOT_ESTABLISHED;
                ok = FALSE;
            }
            break;

        default:
            InternalError( "DderInitConversation: Unknown type: %d",
                lpDder->dd_type );
        }

        if( !ok )  {
            if( bSavedPkt )  {
                lpDder->dd_lpDdePktInitiate = NULL;
                bSavedPkt = FALSE;
            }
            DderFree( hDder );
            hDder = 0;
        }
    }
    UpdateScreenState();

    /*
     * if we didn't "save" the packet and we're returning ok ... free it
     */
    if( !bSavedPkt && hDder )  {
        HeapFreePtr( lpDdePkt );
    }

    return( hDder );
}

VOID
DderSetNextForRouter(
    HDDER   hDder,
    HDDER   hDderNext )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    lpDder->dd_dderNextForRouter = hDderNext;
}

VOID
DderSetPrevForRouter(
    HDDER   hDder,
    HDDER   hDderPrev )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    lpDder->dd_dderPrevForRouter = hDderPrev;
}

VOID
DderGetNextForRouter(
    HDDER       hDder,
    HDDER FAR  *lphDderNext )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    *lphDderNext = lpDder->dd_dderNextForRouter;
}

VOID
DderGetPrevForRouter(
    HDDER       hDder,
    HDDER FAR  *lphDderPrev )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    *lphDderPrev = lpDder->dd_dderPrevForRouter;
}

HDDER
DderCreate( void )
{
    LPDDER      lpDder;
    HDDER       hDder;
    BOOL        ok = TRUE;

    lpDder = (LPDDER) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        (DWORD)sizeof(DDER) );
    if( lpDder )  {
        hDder = (HDDER) lpDder;
        lpDder->dd_prev                 = NULL;
        lpDder->dd_next                 = NULL;
        lpDder->dd_state                = 0;
        lpDder->dd_type                 = 0;
        lpDder->dd_hDderRemote          = 0;
        lpDder->dd_hRouter              = 0;
        lpDder->dd_hIpcClient           = 0;
        lpDder->dd_hIpcServer           = 0;
        lpDder->dd_dderPrevForRouter    = 0;
        lpDder->dd_dderNextForRouter    = 0;
        lpDder->dd_lpDdePktInitiate     = NULL;
        lpDder->dd_lpDdePktInitAck      = NULL;
        lpDder->dd_lpDdePktTermServer   = NULL;
        lpDder->dd_sent                 = 0;
        lpDder->dd_rcvd                 = 0;
        lpDder->dd_bAdvisePermitted     = TRUE;
        lpDder->dd_bRequestPermitted    = TRUE;
        lpDder->dd_bPokePermitted       = TRUE;
        lpDder->dd_bExecutePermitted    = TRUE;
        lpDder->dd_bSecurityViolated    = FALSE;
        lpDder->dd_bClientTermRcvd      = FALSE;
        lpDder->dd_bWantToFree          = FALSE;
        lpDder->dd_lpShareInfo          = NULL;
        lpDder->dd_hClientAccessToken   = 0;
        if( ok )  {
            lpDder->dd_lpDdePktInitAck = (LPDDEPKTIACK) HeapAllocPtr( hHeap,
                GMEM_MOVEABLE, (DWORD)sizeof(DDEPKTIACK) );
            if( lpDder->dd_lpDdePktInitAck == NULL )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpDder->dd_lpDdePktTermServer =
                (LPDDEPKTTERM) HeapAllocPtr( hHeap,
                    GMEM_MOVEABLE, (DWORD)sizeof(DDEPKTTERM) );
            if( lpDder->dd_lpDdePktTermServer == NULL )  {
                ok = FALSE;
                HeapFreePtr(lpDder->dd_lpDdePktInitAck);
            }
        }
        if( ok )  {
            /* link into list of DDERs */
            if( lpDderHead )  {
                lpDderHead->dd_prev = lpDder;
            }
            lpDder->dd_next = lpDderHead;
            lpDderHead = lpDder;
        } else {
            HeapFreePtr(lpDder);
            hDder = (HDDER) 0;
            dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
        }
    } else {
        hDder = (HDDER) 0;
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( hDder );
}

/*
    DderCloseConversation()

        This is called by the IPC after it has handled the terminates, etc.
        The IPC should not reference the hDder after calling this, since
        the hDder will be freed (at least in the hIpcFrom's eyes) upon this
        routine returning
 */
VOID
DderCloseConversation(
    HDDER   hDder,
    HIPC    hIpcFrom )
{
    LPDDER              lpDder;
    BOOL                bFree = FALSE;
    HIPC                hIpcOther;

    DIPRINTF(( "DderCloseConversation( %08lX, %08lX )", hDder, hIpcFrom ));

    assert( hDder );
    lpDder = (LPDDER) hDder;

    switch( lpDder->dd_type )  {
    case DDTYPE_LOCAL_NET:
    case DDTYPE_NET_LOCAL:
        /*
         * assume that IPC took care of transmitting TERMINATES and waiting
         * for return TERMINATE, etc.
         */
        bFree = TRUE;
        break;

    case DDTYPE_LOCAL_LOCAL:
        if( hIpcFrom == lpDder->dd_hIpcClient )  {
            lpDder->dd_hIpcClient = 0;
            hIpcOther = lpDder->dd_hIpcServer;
        } else {
            assert( hIpcFrom == lpDder->dd_hIpcServer );
            lpDder->dd_hIpcServer = 0;
            hIpcOther = lpDder->dd_hIpcClient;
        }
        if( hIpcOther == 0 )  {
            /*
             * both sides have told us to close ... really close
             */
            bFree = TRUE;
        }
        break;
    }

    if (bFree) {
        if( lpDder->dd_bSecurityViolated )  {
            DIPRINTF(( "  Security was violated, rcvdTerm:%d, want:%d",
                    lpDder->dd_bClientTermRcvd,
                    lpDder->dd_bWantToFree ));
            /*
             * For security violations, don't free the DDER until we
             * receive the client side termination
             */
            if( !lpDder->dd_bClientTermRcvd )  {
                lpDder->dd_bWantToFree = TRUE;
                bFree = FALSE;
            }
        }
    }
    DIPRINTF(( "DderCloseConversation, freeing? %d", bFree ));
    if( bFree )  {
        DderFree( hDder );
    }
}

VOID
FAR PASCAL
DderUpdatePermissions(
    HDDER                   hDder,
    PNDDESHAREINFO          lpShareInfo,
    DWORD                   dwGrantedAccess)
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    if( !lpShareInfo )  {
        return;
    }

    lpDder->dd_bAdvisePermitted =
            (dwGrantedAccess & NDDE_SHARE_ADVISE ? TRUE : FALSE);
    lpDder->dd_bRequestPermitted =
            (dwGrantedAccess & NDDE_SHARE_REQUEST ? TRUE : FALSE);
    lpDder->dd_bPokePermitted =
            (dwGrantedAccess & NDDE_SHARE_POKE ? TRUE : FALSE);
    lpDder->dd_bExecutePermitted =
            (dwGrantedAccess & NDDE_SHARE_EXECUTE ? TRUE : FALSE);

    if (lpDder->dd_lpShareInfo) {
        HeapFreePtr(lpDder->dd_lpShareInfo);
    }
    lpDder->dd_lpShareInfo = lpShareInfo;
}

VOID
DderFree( HDDER hDder )
{
    LPDDER      lpDder;
    LPDDER      lpDderPrev;
    LPDDER      lpDderNext;

    lpDder = (LPDDER) hDder;
#if DBG
    if( bDebugInfo ) {
        DPRINTF(( "DderFree( %08lX )", hDder ));
        DumpDder(lpDder);
    }
#endif // DBG

    if( lpDder->dd_hRouter )  {
        RouterDisassociateDder( lpDder->dd_hRouter, (HDDER) lpDder );
        lpDder->dd_hRouter = 0;
    }

    /*
     * unlink dde pkts created
     */
    if( lpDder->dd_lpDdePktInitAck )  {
        HeapFreePtr( lpDder->dd_lpDdePktInitAck );
        lpDder->dd_lpDdePktInitAck = NULL;
    }
    if( lpDder->dd_lpDdePktTermServer )  {
        HeapFreePtr( lpDder->dd_lpDdePktTermServer );
        lpDder->dd_lpDdePktTermServer = NULL;
    }
    if( lpDder->dd_lpDdePktInitiate )  {
        HeapFreePtr( lpDder->dd_lpDdePktInitiate );
        lpDder->dd_lpDdePktInitiate = NULL;
    }

    if (lpDder->dd_lpShareInfo) {
        HeapFreePtr( lpDder->dd_lpShareInfo);
        lpDder->dd_lpShareInfo = NULL;
    }

    /*
     * unlink from DDER list
     */
    lpDderPrev = lpDder->dd_prev;
    lpDderNext = lpDder->dd_next;
    if( lpDderPrev )  {
        lpDderPrev->dd_next = lpDderNext;
    } else {
        lpDderHead = lpDderNext;
    }
    if( lpDderNext )  {
        lpDderNext->dd_prev = lpDderPrev;
    }

    UpdateScreenState();
    HeapFreePtr( lpDder );
}

#ifdef  BYTE_SWAP
VOID
ConvertDdePkt(
    LPDDEPKT    lpDdePkt,
    BOOL        bIncoming )
{
    LPDDEPKTCMN         lpDdePktCmn;
    LPDDEPKTINIT        lpDdePktInit;
    LPDDEPKTIACK        lpDdePktInitAck;
    LPDDEPKTGACK        lpDdePktGack;
    LPDDEPKTTERM        lpDdePktTerm;
    LPDDEPKTEXEC        lpDdePktExec;
    LPDDEPKTEACK        lpDdePktEack;
    LPDDEPKTRQST        lpDdePktRqst;
    LPDDEPKTUNAD        lpDdePktUnad;
    LPDDEPKTPOKE        lpDdePktPoke;
    LPDDEPKTDATA        lpDdePktData;
    LPDDEPKTADVS        lpDdePktAdvs;

    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    lpDdePkt->dp_hDstDder = HostToPcLong( lpDdePkt->dp_hDstDder );

    if( bIncoming )  {
        lpDdePktCmn->dc_message = HostToPcWord( lpDdePktCmn->dc_message );
    }
    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_INITIATE:
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        lpDdePktInit->dp_init_fromDder =
            HostToPcLong( lpDdePktInit->dp_init_fromDder );
        lpDdePktInit->dp_init_offsFromNode =
            HostToPcWord( lpDdePktInit->dp_init_offsFromNode );
        lpDdePktInit->dp_init_offsFromApp =
            HostToPcWord( lpDdePktInit->dp_init_offsFromApp );
        lpDdePktInit->dp_init_offsToNode =
            HostToPcWord( lpDdePktInit->dp_init_offsToNode );
        lpDdePktInit->dp_init_offsToApp =
            HostToPcWord( lpDdePktInit->dp_init_offsToApp );
        lpDdePktInit->dp_init_offsToTopic =
            HostToPcWord( lpDdePktInit->dp_init_offsToTopic );
        lpDdePktInit->dp_init_hSecurityKey =
            HostToPcLong( lpDdePktInit->dp_init_hSecurityKey );
        lpDdePktInit->dp_init_dwSecurityType =
            HostToPcLong( lpDdePktInit->dp_init_dwSecurityType );
        lpDdePktInit->dp_init_sizePassword =
            HostToPcLong( lpDdePktInit->dp_init_sizePassword );
        break;

    case WM_DDE_ACK_INITIATE:
        lpDdePktInitAck = (LPDDEPKTIACK) lpDdePkt;
        lpDdePktInitAck->dp_iack_fromDder =
            HostToPcLong( lpDdePktInitAck->dp_iack_fromDder );
        lpDdePktInitAck->dp_iack_reason =
            HostToPcLong( lpDdePktInitAck->dp_iack_reason );
        lpDdePktInitAck->dp_iack_offsFromNode =
            HostToPcWord( lpDdePktInitAck->dp_iack_offsFromNode );
        lpDdePktInitAck->dp_iack_offsFromApp =
            HostToPcWord( lpDdePktInitAck->dp_iack_offsFromApp );
        lpDdePktInitAck->dp_iack_offsFromTopic =
            HostToPcWord( lpDdePktInitAck->dp_iack_offsFromTopic );
        lpDdePktInitAck->dp_iack_hSecurityKey =
            HostToPcLong( lpDdePktInitAck->dp_iack_hSecurityKey );
        lpDdePktInitAck->dp_iack_dwSecurityType =
            HostToPcLong( lpDdePktInitAck->dp_iack_dwSecurityType );
        lpDdePktInitAck->dp_iack_sizeSecurityKey =
            HostToPcLong( lpDdePktInitAck->dp_iack_sizeSecurityKey );
        break;

    case WM_DDE_TERMINATE:
    case WM_DDE_EXECUTE:
    case WM_DDE_ACK_EXECUTE:
    case WM_DDE_ACK_ADVISE:
    case WM_DDE_ACK_REQUEST:
    case WM_DDE_ACK_UNADVISE:
    case WM_DDE_ACK_POKE:
    case WM_DDE_ACK_DATA:
    case WM_DDE_WWTEST:
        break;

    case WM_DDE_REQUEST:
        lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
        lpDdePktRqst->dp_rqst_cfFormat =
            HostToPcWord( lpDdePktRqst->dp_rqst_cfFormat );
        lpDdePktRqst->dp_rqst_offsFormat =
            HostToPcWord( lpDdePktRqst->dp_rqst_offsFormat );
        lpDdePktRqst->dp_rqst_offsItemName =
            HostToPcWord( lpDdePktRqst->dp_rqst_offsItemName );
        break;

    case WM_DDE_UNADVISE:
        lpDdePktUnad = (LPDDEPKTUNAD) lpDdePkt;
        lpDdePktUnad->dp_unad_cfFormat =
            HostToPcWord( lpDdePktUnad->dp_unad_cfFormat );
        lpDdePktUnad->dp_unad_offsFormat =
            HostToPcWord( lpDdePktUnad->dp_unad_offsFormat );
        lpDdePktUnad->dp_unad_offsItemName =
            HostToPcWord( lpDdePktUnad->dp_unad_offsItemName );
        break;

    case WM_DDE_DATA:
        lpDdePktData = (LPDDEPKTDATA) lpDdePkt;
        lpDdePktData->dp_data_cfFormat =
            HostToPcWord( lpDdePktData->dp_data_cfFormat );
        lpDdePktData->dp_data_offsFormat =
            HostToPcWord( lpDdePktData->dp_data_offsFormat );
        lpDdePktData->dp_data_offsItemName =
            HostToPcWord( lpDdePktData->dp_data_offsItemName );
        lpDdePktData->dp_data_sizeData =
            HostToPcLong( lpDdePktData->dp_data_sizeData );
        lpDdePktData->dp_data_offsData =
            HostToPcWord( lpDdePktData->dp_data_offsData );
        break;

    case WM_DDE_POKE:
        lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
        lpDdePktPoke->dp_poke_cfFormat =
            HostToPcWord( lpDdePktPoke->dp_poke_cfFormat );
        lpDdePktPoke->dp_poke_offsFormat =
            HostToPcWord( lpDdePktPoke->dp_poke_offsFormat );
        lpDdePktPoke->dp_poke_offsItemName =
            HostToPcWord( lpDdePktPoke->dp_poke_offsItemName );
        lpDdePktPoke->dp_poke_sizeData =
            HostToPcLong( lpDdePktPoke->dp_poke_sizeData );
        lpDdePktPoke->dp_poke_offsData =
            HostToPcWord( lpDdePktPoke->dp_poke_offsData );
        break;

    case WM_DDE_ADVISE:
        lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
        lpDdePktAdvs->dp_advs_cfFormat =
            HostToPcWord( lpDdePktAdvs->dp_advs_cfFormat );
        lpDdePktAdvs->dp_advs_offsFormat =
            HostToPcWord( lpDdePktAdvs->dp_advs_offsFormat );
        lpDdePktAdvs->dp_advs_offsItemName =
            HostToPcWord( lpDdePktAdvs->dp_advs_offsItemName );
        break;

    default:
        InternalError( "DDER: must handle conversion for message: %04X",
            lpDdePktCmn->dc_message );
    }

    if( !bIncoming ) {
        lpDdePktCmn->dc_message = HostToPcWord( lpDdePktCmn->dc_message );
    }
}
#endif

#ifdef _WINDOWS

#ifdef HASUI

#include <stdio.h>
#include "tmpbuf.h"


int
DderDraw(
    HDC     hDC,
    int     x,
    int     vertPos,
    int     lineHeight )
{
    LPDDER      lpDder;
    char        szType[ 20 ];

    lpDder = lpDderHead;
    while( lpDder )  {
        switch( lpDder->dd_type ) {
        case DDTYPE_LOCAL_NET:
            strcpy( szType, "LOCAL->NET" );
            break;

        case DDTYPE_NET_LOCAL:
            strcpy( szType, "NET->LOCAL" );
            break;

        case DDTYPE_LOCAL_LOCAL:
            strcpy( szType, "LOCAL<->LOCAL" );
            break;

        default:
            sprintf( szType, "unkn:%04X", lpDder->dd_type );
        }

        if( bShowStatistics )  {
            sprintf( tmpBuf, " %7ld %7ld %-16.16Fs %-33.33Fs",
                    lpDder->dd_sent, lpDder->dd_rcvd, (LPSTR)szType, (LPSTR)" " );
        } else {
            sprintf( tmpBuf, " %-16.16Fs %-33.33Fs",
                    (LPSTR)szType, (LPSTR)" " );
        }
        switch( lpDder->dd_state )  {
        case DDER_INIT:
            strcat( tmpBuf, " Initializing" );
            break;

        case DDER_WAIT_IPC_INIT:
            strcat( tmpBuf, " Wait for Local Init" );
            break;

        case DDER_WAIT_ROUTER:
            strcat( tmpBuf, " Wait for Router" );
            break;

        case DDER_WAIT_NET_INIT:
            strcat( tmpBuf, " Wait Net Init" );
            break;

        case DDER_CONNECTED:
            strcat( tmpBuf, " Connected" );
            break;

        case DDER_CLOSED:
            strcat( tmpBuf, " Closed" );
            break;

        default:
            sprintf( &tmpBuf[ lstrlen(tmpBuf) ], " unkn:%04lX",
                lpDder->dd_state );
            break;
        }
        TextOut( hDC, x, vertPos, tmpBuf, lstrlen(tmpBuf) );
        vertPos += lineHeight;
        lpDder = lpDder->dd_next;
    }
    return( vertPos );
}
#endif // HASUI
#endif

VOID FAR PASCAL IpcFillInConnInfo(
        HIPC            hIpc,
        LPCONNENUM_CMR  lpConnEnum,
        LPSTR           lpDataStart,
        LPWORD          lpcFromBeginning,
        LPWORD          lpcFromEnd );

HDDER
FAR PASCAL
DderFillInConnInfo(
        HDDER           hDder,
        LPCONNENUM_CMR  lpConnEnum,
        LPSTR           lpDataStart,
        LPWORD          lpcFromBeginning,
        LPWORD          lpcFromEnd
)
{
    HDDER               hDderNext = (HDDER) 0;
    LPDDER              lpDder;

    if( hDder )  {
        lpDder = (LPDDER)hDder;
        hDderNext = (HDDER)lpDder->dd_next;
        if( lpDder->dd_type == DDTYPE_NET_LOCAL )  {
            IpcFillInConnInfo( lpDder->dd_hIpcServer, lpConnEnum,
                    lpDataStart, lpcFromBeginning, lpcFromEnd );
        }
    }
    return( hDderNext );
}

#if DBG
VOID
DumpDder(LPDDER lpDder)
{
    DPRINTF(( "%Fp:\n"
              "  dd_prev              %Fp\n"
              "  dd_next              %Fp\n"
              "  dd_state             %d\n"
              "  dd_type              %d\n"
              "  dd_hDderRemote       %Fp\n"
              "  dd_hRouter           %Fp\n"
              "  dd_hIpcClient        %Fp\n"
              "  dd_hIpcServer        %Fp\n"
              "  dd_dderPrevForRouter %Fp\n"
              "  dd_dderNextForRouter %Fp\n"
              "  dd_bAdvisePermitted  %d\n"
              "  dd_bRequestPermitted %d\n"
              "  dd_bPokePermitted    %d\n"
              "  dd_bExecutePermitted %d\n"
              "  dd_bSecurityViolated %d\n"
              "  dd_sent              %ld\n"
              "  dd_rcvd              %ld\n"
              ,
            lpDder,
            lpDder->dd_prev,
            lpDder->dd_next,
            lpDder->dd_state,
            lpDder->dd_type,
            lpDder->dd_hDderRemote,
            lpDder->dd_hRouter,
            lpDder->dd_hIpcClient,
            lpDder->dd_hIpcServer,
            lpDder->dd_dderPrevForRouter,
            lpDder->dd_dderNextForRouter,
            lpDder->dd_bAdvisePermitted,
            lpDder->dd_bRequestPermitted,
            lpDder->dd_bPokePermitted,
            lpDder->dd_bExecutePermitted,
            lpDder->dd_bSecurityViolated,
            lpDder->dd_sent,
            lpDder->dd_rcvd ));
}

VOID
FAR PASCAL
DebugDderState( void )
{
    LPDDER      lpDder;

    lpDder = lpDderHead;
    DPRINTF(( "DDER State:" ));
    while( lpDder )  {
        DumpDder(lpDder);
        lpDder = lpDder->dd_next;
    }
}
#endif // DBG

typedef struct seckey_tag {
    struct seckey_tag FAR       *sk_prev;
    struct seckey_tag FAR       *sk_next;
    time_t                       sk_creationTime;
    DWORD                        sk_handle;
    LPVOID                       sk_key;
    DWORD                        sk_size;
} SECKEY;
typedef SECKEY FAR *LPSECKEY;

LPSECKEY        lpSecKeyHead;
DWORD           dwHandle = 1L;

LPSECKEY
FAR PASCAL
DdeSecKeyFind( DWORD hSecurityKey )
{
    LPSECKEY    lpSecKey;

    lpSecKey = lpSecKeyHead;
    while( lpSecKey )  {
        if( lpSecKey->sk_handle == hSecurityKey )  {
            return( lpSecKey );
        }
        lpSecKey = lpSecKey->sk_next;
    }
    return( (LPSECKEY) 0 );
}

VOID
FAR PASCAL
DdeSecKeyFree( LPSECKEY lpSecKeyFree )
{
    LPSECKEY    prev;
    LPSECKEY    next;

    prev = lpSecKeyFree->sk_prev;
    next = lpSecKeyFree->sk_next;
    if( prev )  {
        prev->sk_next = next;
    } else {
        lpSecKeyHead = next;
    }
    if( next )  {
        next->sk_prev = prev;
    }
    HeapFreePtr( lpSecKeyFree->sk_key );
    HeapFreePtr( lpSecKeyFree );
}


VOID
FAR PASCAL
DdeSecKeyObtainNew(
            LPDWORD lphSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey
)
{
    LPSECKEY    lpSecKey;
    LPVOID      lpKey;
    DWORD       dwSize;
    UINT        uSize;

    *lphSecurityKey = (DWORD) 0;
    *lplpSecurityKey = (LPSTR) NULL;
    *lpsizeSecurityKey = 0;

    lpSecKey = HeapAllocPtr( hHeap, GMEM_MOVEABLE | GMEM_ZEROINIT,
        (DWORD)sizeof(SECKEY) );
    if( lpSecKey )  {
        dwSize = 8;
        lpKey = HeapAllocPtr( hHeap, GMEM_MOVEABLE | GMEM_ZEROINIT,
            (DWORD)dwSize );
        if( lpKey )  {
            if( !NDDEGetChallenge( lpKey, dwSize, &uSize ) )  {
                _fmemcpy( lpKey, "12345678", (int)dwSize );
            }

            lpSecKey->sk_creationTime   = time(NULL);
            lpSecKey->sk_handle         = dwHandle++;
            lpSecKey->sk_key            = lpKey;
            lpSecKey->sk_size           = dwSize;

            /* put into the list */
            lpSecKey->sk_prev           = NULL;
            lpSecKey->sk_next           = lpSecKeyHead;
            if( lpSecKeyHead )  {
                lpSecKeyHead->sk_prev = lpSecKey;
            }
            lpSecKeyHead = lpSecKey;

            *lphSecurityKey = (DWORD) lpSecKey->sk_handle;
            *lplpSecurityKey = (LPSTR) lpSecKey->sk_key;
            *lpsizeSecurityKey = lpSecKey->sk_size;
        } else {
            HeapFreePtr( lpKey );
        }
    }
}

BOOL
FAR PASCAL
DdeSecKeyRetrieve(
            DWORD hSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey
)
{
    LPSECKEY    lpSecKey;

    lpSecKey = DdeSecKeyFind( hSecurityKey );
    if( lpSecKey )  {
        *lplpSecurityKey = lpSecKey->sk_key;
        *lpsizeSecurityKey = lpSecKey->sk_size;
        return( TRUE );
    } else {
        return( FALSE );
    }
}


VOID
FAR PASCAL
DdeSecKeyAge( void )
{
    LPSECKEY    lpSecKey;
    LPSECKEY    lpSecKeyNext;
    time_t      curTime;

    curTime = time(NULL);
    lpSecKey = lpSecKeyHead;
    while( lpSecKey )  {
        lpSecKeyNext = lpSecKey->sk_next;
        if( (curTime - lpSecKey->sk_creationTime) > (long) dwSecKeyAgeLimit )  {
            DdeSecKeyFree( lpSecKey );
        }
        lpSecKey = lpSecKeyNext;
    }
}


VOID
FAR PASCAL
DdeSecKeyRelease( DWORD hSecurityKey )
{
    LPSECKEY    lpSecKey;

    lpSecKey = DdeSecKeyFind( hSecurityKey );
    if( lpSecKey )  {
        DdeSecKeyFree( lpSecKey );
    }
}

BOOL
SecurityValidate( LPDDER lpDder, LPSTR lpszActualItem, BOOL bAllowed )
{
    LPSTR       lpszItem;
    LONG        n;
    BOOL        ok = FALSE;

    if( !bAllowed) {
        DPRINTF(("SecurityValidate: Not allowed to access share info."));
        return( FALSE );
    } else if (!lpDder->dd_lpShareInfo )  {
        DPRINTF(("SecurityValidate: No share info. exists."));
        return( FALSE );        /* no share info, no access */
    } else if ((n = lpDder->dd_lpShareInfo->cNumItems) == 0 )  {
        /* any item allowed */
        ok = TRUE;
    } else {
        lpszItem = lpDder->dd_lpShareInfo->lpszItemList;
        while( n-- && (*lpszItem != '\0') )  {
            if( lstrcmpi( lpszActualItem, lpszItem ) == 0 )  {
                    ok = TRUE;
                    break;
            } else {
                    lpszItem += lstrlen(lpszItem) + 1;
            }
        }
        if (!ok) {
            DPRINTF(("SecurityValidate: Item not in itemlist."));
        }
    }
    return( ok );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\getroute.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "GETROUTE.C;1  16-Dec-92,10:20:24  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "host.h"
#include "windows.h"
#include "netbasic.h"
#include "netintf.h"
#include "security.h"
#include "debug.h"
#include "api1632.h"
#include "proflspt.h"

extern char szNetddeIni[];

extern BOOL     bDefaultRouteDisconnect;
extern int      nDefaultRouteDisconnectTime;

BOOL
GetRoutingInfo(
    LPSTR       lpszNodeName,
    LPSTR       lpszRouteInfo,
    int         nMaxRouteInfo,
    BOOL FAR   *pbDisconnect,
    int FAR    *pnDelay )
{
    char        line[300];

    /* defaults */
    *pbDisconnect = bDefaultRouteDisconnect;
    *pnDelay = nDefaultRouteDisconnectTime;
    *lpszRouteInfo = '\0';

    if( MyGetPrivateProfileString( "Routes", lpszNodeName, "",
            (LPSTR) line, sizeof(line), szNetddeIni ) == 0 )  {
        return( FALSE );
    }

    if( line[0] != '\0' )  {
        lstrcpyn( lpszRouteInfo, line, nMaxRouteInfo );
    } else {
        lstrcpyn( lpszRouteInfo, lpszNodeName, nMaxRouteInfo );
    }

    return( TRUE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\pktz.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "PKTZ.C;1  16-Dec-92,10:20:56  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

/*
    TODO:
        - PktzNetHdrWithinAck() doesn't handle wrap-around case!  Neither does
            PktzOkToXmit() when looking for packet id to send
 */

#include    "host.h"

#ifdef _WINDOWS
#include    <memory.h>
#include    <string.h>
#endif

#include    "windows.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "ddepkt.h"
#include    "pktz.h"
#include    "router.h"
#include    "timer.h"
#include    "internal.h"
#include    "wwassert.h"
#include    "hmemcpy.h"
#include    "host.h"
#include    "scrnupdt.h"
#include    "security.h"
#include    "rerr.h"
#include    "ddepkts.h"    /* only for debug() */
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "api1632.h"
#include    "netddesh.h"

USES_ASSERT

#ifdef BYTE_SWAP
VOID     ConvertDdePkt( LPDDEPKT lpDdePkt );
#else
#define ConvertDdePkt(x)
#endif


/*
    External variables used
 */
#if DBG
extern BOOL     bDebugInfo;
#endif // DBG

extern  BOOL    bLogRetries;
extern  HHEAP   hHeap;
extern  char    ourNodeName[ MAX_NODE_NAME+1 ];
extern  DWORD   dflt_timeoutRcvConnCmd;
extern  DWORD   dflt_timeoutRcvConnRsp;
extern  DWORD   dflt_timeoutMemoryPause;
extern  DWORD   dflt_timeoutKeepAlive;
extern  DWORD   dflt_timeoutXmtStuck;
extern  DWORD   dflt_timeoutSendRsp;
extern  WORD    dflt_wMaxNoResponse;
extern  WORD    dflt_wMaxXmtErr;
extern  WORD    dflt_wMaxMemErr;


/*
    Local variables
 */
LPPKTZ  lpPktzHead      = NULL;
static  char    OurDialect[]    = "CORE1.0";


/*
    Local routines
 */
VOID    PktzClose( HPKTZ hPktz );
VOID    PktzDestroyCurrentConnections( void );
VOID    PktzGotPktOk( LPPKTZ lpPktz, PKTID pktid );
VOID    PktzFreeDdePkt( LPPKTZ lpPktz, LPDDEPKT lpDdePkt );
VOID    PktzFree( LPPKTZ lpPktz );
BOOL    PktzProcessControlInfo( LPPKTZ lpPktz, LPNETPKT lpPacket );
BOOL    PktzProcessPkt( LPPKTZ lpPktz, LPNETPKT lpPacket );
VOID    PktzTimerExpired( HPKTZ hPktz, DWORD dwTimerId, DWORD_PTR lpExtra );
BOOL    PktzConnectionComplete( HPKTZ hPktz, BOOL fOk );
VOID    PktzOkToXmit( HPKTZ hPktz );
BOOL    PktzRcvdPacket( HPKTZ hPktz );
VOID    PktzConnectionBroken( HPKTZ hPktz );
BOOL    PktzXmitErrorOnPkt( LPPKTZ lpPktz, PKTID pktIdToRexmit, BYTE pktStatus );
VOID    PktzLinkToXmitList( LPPKTZ lpPktz, LPNETHDR lpNetHdr );
BOOL    PktzNetHdrWithinAck( LPPKTZ lpPktz, LPNETHDR lpNetHdr, PKTID pktId );
LPNETHDR PktzGetFreePacket( LPPKTZ lpPktz );
VOID    FAR PASCAL DebugPktzState( void );
BOOL    PktzAnyActiveForNetIntf( LPSTR lpszIntfName );

#ifdef  HASUI
#ifdef  _WINDOWS
int     PktzDraw( HDC hDC, int x, int vertPos, int lineHeight );
#pragma alloc_text(IDLE_TEXT,PktzSlice)
#pragma alloc_text(PKTZ_XMIT,PktzOkToXmit)
#pragma alloc_text(GUI_TEXT,PktzDraw,DebugPktzState,PktzCloseAll)
#pragma alloc_text(GUI_TEXT,PktzCloseByName,PktzEnumConnections)
#pragma alloc_text(GUI_TEXT,PktzAnyActiveForNetIntf)
#endif
#endif

/*
    PktzNew()

        This function is called by CONNMGR when we get a new connection from
        a netintf (bClient is FALSE), and called by CONNMGR when we need to
        create a new physical connection (bClient is TRUE)
 */
HPKTZ
PktzNew(
    LPNIPTRS    lpNiPtrs,
    BOOL        bClient,
    LPSTR       lpszNodeName,
    LPSTR       lpszNodeInfo,
    CONNID      connId,
    BOOL        bDisconnect,
    int         nDelay )
{
    HPKTZ       hPktz;
    LPPKTZ      lpPktz;
    LPNETHDR    lpNetCur;
    LPNETHDR    lpNetPrev;
    int         i;
    BOOL        ok;

    hPktz = (HPKTZ) HeapAllocPtr( hHeap, GMEM_MOVEABLE, (DWORD)sizeof(PKTZ) );
    if( hPktz )  {
        ok = TRUE;
        lpPktz = (LPPKTZ) hPktz;
        lpPktz->pk_connId                   = connId;
        lpPktz->pk_fControlPktNeeded= FALSE;
        lpPktz->pk_pktidNextToSend      = (PKTID) 0;
        lpPktz->pk_pktidNextToBuild     = (PKTID) 1;
        lpPktz->pk_lastPktStatus        = 0;
        lpPktz->pk_lastPktRcvd          = (PKTID) 0;
        lpPktz->pk_lastPktOk            = (PKTID) 0;
        lpPktz->pk_lastPktOkOther       = (PKTID) 0;
        lpPktz->pk_pktidNextToRecv      = (PKTID) 1;
        lpPktz->pk_pktOffsInXmtMsg      = 0;
        lpPktz->pk_lpDdePktSave         = (LPDDEPKT) NULL;

        lstrcpyn( lpPktz->pk_szAliasName, lpszNodeName,
            sizeof(lpPktz->pk_szAliasName) );
        lpPktz->pk_szAliasName[ sizeof(lpPktz->pk_szAliasName)-1 ] = '\0';

        lstrcpyn( lpPktz->pk_szDestName, lpszNodeName,
            sizeof(lpPktz->pk_szDestName) );
        lpPktz->pk_szDestName[ sizeof(lpPktz->pk_szDestName)-1 ] = '\0';

        lpPktz->pk_lpNiPtrs             = lpNiPtrs;
        lpPktz->pk_sent                 = 0;
        lpPktz->pk_rcvd                 = 0;
        lpPktz->pk_hTimerKeepalive      = (HTIMER) NULL;
        lpPktz->pk_hTimerXmtStuck       = (HTIMER) NULL;
        lpPktz->pk_hTimerRcvNegCmd      = (HTIMER) NULL;
        lpPktz->pk_hTimerRcvNegRsp      = (HTIMER) NULL;
        lpPktz->pk_hTimerMemoryPause    = (HTIMER) NULL;
        lpPktz->pk_hTimerCloseConnection= (HTIMER) NULL;
        lpPktz->pk_pktUnackHead         = NULL;
        lpPktz->pk_pktUnackTail         = NULL;
        lpPktz->pk_controlPkt           = NULL;
        lpPktz->pk_rcvBuf               = NULL;
        lpPktz->pk_pktFreeHead          = NULL;
        lpPktz->pk_pktFreeTail          = NULL;
        lpPktz->pk_ddePktHead           = NULL;
        lpPktz->pk_ddePktTail           = NULL;
        lpPktz->pk_prevPktz             = NULL;
        lpPktz->pk_nextPktz             = NULL;
        lpPktz->pk_prevPktzForNetintf   = NULL;
        lpPktz->pk_nextPktzForNetintf   = NULL;
        lpPktz->pk_hRouterHead          = 0;
        lpPktz->pk_hRouterExtraHead     = 0;
        lpPktz->pk_timeoutRcvNegCmd     = dflt_timeoutRcvConnCmd;
        lpPktz->pk_timeoutRcvNegRsp     = dflt_timeoutRcvConnRsp;
        lpPktz->pk_timeoutMemoryPause   = dflt_timeoutMemoryPause;
        lpPktz->pk_timeoutKeepAlive     = dflt_timeoutKeepAlive;
        lpPktz->pk_timeoutXmtStuck      = dflt_timeoutXmtStuck;
        lpPktz->pk_timeoutSendRsp       = dflt_timeoutSendRsp;
        lpPktz->pk_wMaxNoResponse       = dflt_wMaxNoResponse;
        lpPktz->pk_wMaxXmtErr           = dflt_wMaxXmtErr;
        lpPktz->pk_wMaxMemErr           = dflt_wMaxMemErr;
        lpPktz->pk_fDisconnect          = bDisconnect;
        lpPktz->pk_nDelay               = nDelay;

        /* link into list of packetizers */
        if( lpPktzHead )  {
            lpPktzHead->pk_prevPktz = lpPktz;
        }
        lpPktz->pk_nextPktz     = lpPktzHead;
        lpPktzHead              = lpPktz;

        (*lpPktz->pk_lpNiPtrs->GetConnectionConfig) ( lpPktz->pk_connId,
            &lpPktz->pk_maxUnackPkts, &lpPktz->pk_pktSize,
            &lpPktz->pk_timeoutRcvNegCmd, &lpPktz->pk_timeoutRcvNegRsp,
            &lpPktz->pk_timeoutMemoryPause, &lpPktz->pk_timeoutKeepAlive,
            &lpPktz->pk_timeoutXmtStuck, &lpPktz->pk_timeoutSendRsp,
            &lpPktz->pk_wMaxNoResponse, &lpPktz->pk_wMaxXmtErr,
            &lpPktz->pk_wMaxMemErr );

        /* allocate packet buffer space for the max # of unack packets.
            This way, we know we won't run out of memory
         */
        lpNetPrev = NULL;
        ok = TRUE;
        for( i=0; ok && (i<(int)lpPktz->pk_maxUnackPkts); i++ )  {
            lpNetCur = HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                (DWORD)(sizeof(NETHDR) + lpPktz->pk_pktSize) );
            if( lpNetCur )  {
                lpNetCur->nh_prev               = lpNetPrev;
                lpNetCur->nh_next               = (LPNETHDR) NULL;
                lpNetCur->nh_noRsp              = 0;
                lpNetCur->nh_xmtErr             = 0;
                lpNetCur->nh_memErr             = 0;
                lpNetCur->nh_timeSent           = 0;
                lpNetCur->nh_hTimerRspTO        = (HTIMER) NULL;

                /* link onto list of free packets */
                if( lpNetPrev )  {
                    lpNetPrev->nh_next          = lpNetCur;
                } else {
                    lpPktz->pk_pktFreeHead      = lpNetCur;
                }
                lpPktz->pk_pktFreeTail  = lpNetCur;
                lpNetPrev = lpNetCur;
            } else {
                ok = FALSE;
            }
        }
        if( ok )  {
            /* allocate buffer for rcv packet */
            lpPktz->pk_rcvBuf = (LPVOID) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                (DWORD)(lpPktz->pk_pktSize) );
            if( lpPktz->pk_rcvBuf == NULL )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            /* allocate buffer for control packet */
            lpPktz->pk_controlPkt = (LPNETPKT) HeapAllocPtr( hHeap,
                GMEM_MOVEABLE, (DWORD)(sizeof(NETPKT)) );
            if( lpPktz->pk_controlPkt == NULL )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            /* allocated all memory, ready to move on */
            if( bClient )  {
                /* wait for netintf connect() to succeed */
                lpPktz->pk_state                = PKTZ_WAIT_PHYSICAL_CONNECT;
                UpdateScreenState();

                /* actually start the connect */
                lpPktz->pk_connId =
                    (*lpPktz->pk_lpNiPtrs->AddConnection) (
#ifdef _WINDOWS
                        lpszNodeInfo );
#else
                        lpszNodeInfo, hPktz );
#endif
                if( lpPktz->pk_connId == (CONNID) 0 )  {
                    /* not enough memory or resources for connection,
                        or in some cases, we immediately know if
                        connection failed */
                    ok = FALSE;
                }
            } else {
                /* server */

                /* wait for other side to send us the connect cmd */
                lpPktz->pk_state                = PKTZ_WAIT_NEG_CMD;
                UpdateScreenState();

                /* set up timer for how long to wait for the connect
                    command from the other side */
                lpPktz->pk_hTimerRcvNegCmd = TimerSet(
                    lpPktz->pk_timeoutRcvNegCmd, PktzTimerExpired,
                    (DWORD_PTR)hPktz, TID_NO_RCV_CONN_CMD, (DWORD_PTR)NULL );
                if( lpPktz->pk_hTimerRcvNegCmd == (HTIMER) NULL )  {
                    /* no timers left */
                    ok = FALSE;
                }
            }
        }

        if( !ok )  {
            PktzFree( lpPktz );
            hPktz = 0;
        }
    }

    return( hPktz );
}

/*
    link onto the list of routers associated with this pktz
 */
VOID
PktzAssociateRouter(
    HPKTZ   hPktz,
    HROUTER hRouter,
    WORD    hRouterExtra )
{
    LPPKTZ      lpPktz;

    lpPktz = (LPPKTZ) hPktz;

    if( (lpPktz->pk_hRouterHead == 0) && lpPktz->pk_hTimerCloseConnection){
        TimerDelete( lpPktz->pk_hTimerCloseConnection );
        lpPktz->pk_hTimerCloseConnection = 0;
    }

    /* link router into head of list */
    if( lpPktz->pk_hRouterHead )  {
        RouterSetPrevForPktz(
            lpPktz->pk_hRouterHead, lpPktz->pk_hRouterExtraHead,
            hRouter, hRouterExtra );
    }
    RouterSetNextForPktz(
        hRouter, hRouterExtra,
        lpPktz->pk_hRouterHead, lpPktz->pk_hRouterExtraHead );
    lpPktz->pk_hRouterHead = hRouter;
    lpPktz->pk_hRouterExtraHead = hRouterExtra;

    switch( lpPktz->pk_state )  {
    case PKTZ_CONNECTED:
    case PKTZ_PAUSE_FOR_MEMORY:
        /* connected ... tell him already */
        RouterConnectionComplete( hRouter, hRouterExtra, (HPKTZ) lpPktz );
        break;
    }
}

/*
    unlink from the list of routers associated with this pktz
 */
VOID
PktzDisassociateRouter(
    HPKTZ   hPktz,
    HROUTER hRouter,
    WORD    hRouterExtra )
{
    LPPKTZ      lpPktz;
    HROUTER     hRouterPrev;
    WORD        hRouterExtraPrev;
    HROUTER     hRouterNext;
    WORD        hRouterExtraNext;

    lpPktz = (LPPKTZ) hPktz;
    RouterGetNextForPktz( hRouter, hRouterExtra,
        &hRouterNext, &hRouterExtraNext );
    RouterGetPrevForPktz( hRouter, hRouterExtra,
        &hRouterPrev, &hRouterExtraPrev );
    if( hRouterPrev )  {
        RouterSetNextForPktz( hRouterPrev, hRouterExtraPrev,
            hRouterNext, hRouterExtraNext );
    } else {
        lpPktz->pk_hRouterHead = hRouterNext;
        lpPktz->pk_hRouterExtraHead = hRouterExtraNext;
    }
    if( hRouterNext )  {
        RouterSetPrevForPktz( hRouterNext, hRouterExtraNext,
            hRouterPrev, hRouterExtraPrev );
    }
    if( lpPktz->pk_fDisconnect && (lpPktz->pk_hRouterHead == 0) )  {
        lpPktz->pk_hTimerCloseConnection = TimerSet(
            lpPktz->pk_nDelay * 1000L, PktzTimerExpired,
            (DWORD_PTR)lpPktz, TID_CLOSE_PKTZ, (DWORD_PTR)NULL );
        if( lpPktz->pk_hTimerCloseConnection == (HTIMER) NULL )  {
            /*  %1 will not auto-close ... not enough timers    */
            NDDELogError(MSG105, "Connection", NULL);
        }
    }
}

/*
    PktzOkToXmit

        Called when the netintf is ready to xmit another packet
 */
VOID
PktzOkToXmit( HPKTZ hPktz )
{
    LPPKTZ      lpPktz;
    LPNETHDR    lpSend;
    LPNETPKT    lpPacket;
    LPDDEPKT    lpDdePktFrom;
    LPDDEPKT    lpDdePktFromNext;
    LPDDEPKT    lpDdePktTo;
    BOOL        bControlPktOnly;
    BOOL        donePkt;
    BOOL        done;
    BOOL        found;
    DWORD       dwThis;
    DWORD       dwLeft;
    DWORD       msgSize;
    DWORD       dwStatus;
    int         nDone = 0;

    /* general init */
    lpPktz = (LPPKTZ) hPktz;
    lpSend = NULL;
    bControlPktOnly = FALSE;

    /* don't proceed if netintf isn't ready to xmit */
    dwStatus = (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
        ( lpPktz->pk_connId );
    if( !(dwStatus & NDDE_CONN_OK) || !(dwStatus & NDDE_READY_TO_XMT) )  {
        return;
    }

    /* if we got here, the netintf is ready to xmit ... delete xmt stuck
        timer
     */
    if( lpPktz->pk_hTimerXmtStuck )  {
        TimerDelete( lpPktz->pk_hTimerXmtStuck );
        lpPktz->pk_hTimerXmtStuck = 0;
    }

    /* check for odd states */
    if( lpPktz->pk_state == PKTZ_PAUSE_FOR_MEMORY )  {
        if( lpPktz->pk_fControlPktNeeded )  {
            bControlPktOnly = TRUE;
        } else {
            /* when waiting for memory problems to clear, don't send
                anything except control packets */
            return;
        }
    } else if( lpPktz->pk_state == PKTZ_CLOSE )  {
        return;
    }

    /* used to try to keep # lpPktz->pk_curOutstanding ...
        we now calculate this as idToSend - lastIdOtherSideSawOk - 1.
        Of course, this calculation is only OK if
        idToSend > lastIdOtherSideSawOk!
     */
    if( (lpPktz->pk_pktidNextToSend > lpPktz->pk_lastPktOkOther)
        && ((lpPktz->pk_pktidNextToSend - 1 - lpPktz->pk_lastPktOkOther)
                >= (DWORD)lpPktz->pk_maxUnackPkts) )  {
        /* nothing to do until other side gives us some info
            regarding the packets we have outstanding or we time out
            waiting for a response for them */
        if( lpPktz->pk_fControlPktNeeded )  {
            /*  However, we must send a control packet here or the possibility
                of deadlock exists */
            bControlPktOnly = TRUE;
        } else {
            return;
        }
    }

    if( !bControlPktOnly )  {
        /* find next pkt id to send */
        found = FALSE;
        done = FALSE;
        lpSend = lpPktz->pk_pktUnackTail;

        /* if the packet that we're supposed to send has already been seen
            OK by the other side, let's try to send the one after this.

            This check prevents a hole when the no-response timer expires,
            we set nextToSend to x, then we process a control packet saying
            that x was rcvd OK (this deletes x from unack list), then we get
            to the send state and if x isn't found ... we don't xmit!
         */
        if( lpPktz->pk_pktidNextToSend <= lpPktz->pk_lastPktOkOther )  {
            DIPRINTF(( "Adjusting next to send from %08lX to %08lX",
                    lpPktz->pk_pktidNextToSend, lpPktz->pk_lastPktOkOther+1 ));
            lpPktz->pk_pktidNextToSend = lpPktz->pk_lastPktOkOther+1;
        }
        while( lpSend && !done )  {
            lpPacket = (LPNETPKT) ( ((LPSTR)lpSend) + sizeof(NETHDR) );
            if( lpPacket->np_pktID == lpPktz->pk_pktidNextToSend )  {
                found = TRUE;
                done = TRUE;
            } else if( lpPacket->np_pktID < lpPktz->pk_pktidNextToSend )  {
                /* this packet in the list is before the one we should send,
                    therefore we know that the one we want is not in the list
                 */
                done = TRUE;
            } else {
                /* move on to the previous packet */
                lpSend = lpSend->nh_prev;
            }
        }

        if( !found )  {
            /* didn't find the packet on the xmit list */

            /* is there anything to send? */
            if( lpPktz->pk_ddePktHead == NULL )  {
                /* no DDE Packets to send ... any control packets needed? */
                if( lpPktz->pk_fControlPktNeeded )  {
                    bControlPktOnly = TRUE;
                    found = TRUE;
                } else {
                    /* nothing to send! */
                    return;
                }
            }
        }

        if( !found )  {
            /* double-check that the id we're looking for is 1 greater than
                the last one we sent */
            if( lpPktz->pk_pktUnackTail )  {
                lpPacket = (LPNETPKT)
                    ( ((LPSTR)lpPktz->pk_pktUnackTail) + sizeof(NETHDR) );
                assert( lpPktz->pk_pktidNextToSend == (lpPacket->np_pktID+1) );
                assert( lpPktz->pk_pktidNextToSend == lpPktz->pk_pktidNextToBuild );
            }

            /* get a nethdr packet from free list */
            lpSend = PktzGetFreePacket( lpPktz );
            assert( lpSend );   /* we checked max outstanding */

            lpPacket = (LPNETPKT) ( ((LPSTR)lpSend) + sizeof(NETHDR) );
            lpDdePktTo = (LPDDEPKT) ( ((LPSTR)lpPacket) + sizeof(NETPKT) );

            /* check if we were in the middle of a DDE packet */
            if( lpPktz->pk_pktOffsInXmtMsg != 0L ) {
                /* we were in the middle of a DDE Packet */
                lpDdePktFrom = lpPktz->pk_ddePktHead;
                if( (lpDdePktFrom->dp_size - lpPktz->pk_pktOffsInXmtMsg)
                    > (lpPktz->pk_pktSize-sizeof(NETPKT)) )  {
                    dwThis = lpPktz->pk_pktSize - sizeof(NETPKT);
                    donePkt = FALSE;
                } else {
                    dwThis =
                        (lpDdePktFrom->dp_size - lpPktz->pk_pktOffsInXmtMsg);
                    donePkt = TRUE;
                }

                /* copy this portion of data in */
                hmemcpy( (LPSTR)lpDdePktTo,
                    ( ((LPHSTR)lpDdePktFrom) + lpPktz->pk_pktOffsInXmtMsg ),
                    dwThis );
                lpPacket->np_pktSize            = (WORD) dwThis;
                lpPacket->np_pktOffsInMsg       = lpPktz->pk_pktOffsInXmtMsg;
                lpPacket->np_msgSize            = lpDdePktFrom->dp_size;
                lpPacket->np_type               = NPKT_ROUTER;
                lpPacket->np_pktID              = lpPktz->pk_pktidNextToBuild;

                /* bump id of next pkt to build */
                lpPktz->pk_pktidNextToBuild++;

                /* link into list to send */
                PktzLinkToXmitList( lpPktz, lpSend );

                /* get rid of DDE packet if done */
                if( donePkt )  {
                    PktzFreeDdePkt( lpPktz, lpDdePktFrom );
                    lpPktz->pk_pktOffsInXmtMsg = 0L;
                } else {
                    lpPktz->pk_pktOffsInXmtMsg += dwThis;
                }
            } else {
                /* not in middle of packet ... lets do a new one */
                done = FALSE;
                nDone = 0;
                dwLeft = lpPktz->pk_pktSize - sizeof(NETPKT);
                dwThis = 0;
                msgSize = 0L;
                lpDdePktFrom = lpPktz->pk_ddePktHead;
                while( !done && lpDdePktFrom )  {
                    if( lpDdePktFrom->dp_size <= (DWORD)dwLeft )  {
                        /* fits completely in network packet */

                        /* copy it in */
                        hmemcpy( (LPSTR)lpDdePktTo, (LPSTR)lpDdePktFrom,
                            lpDdePktFrom->dp_size );

                        /* byte-ordering problems if any */
                        ConvertDdePkt( lpDdePktTo );

                        /* adjust number in packet and number left */
                        dwThis   += lpDdePktFrom->dp_size;
                        msgSize += lpDdePktFrom->dp_size;
                        dwLeft   -= lpDdePktFrom->dp_size;

                        /* advance lpDdePktTo pointer past this info */
                        lpDdePktTo = (LPDDEPKT) ( ((LPHSTR)lpDdePktTo) +
                            lpDdePktFrom->dp_size );

                        /* free DDE Packet and move on to next DDE pkt */
                        lpDdePktFromNext = lpDdePktFrom->dp_next;
                        PktzFreeDdePkt( lpPktz, lpDdePktFrom );
                        lpDdePktFrom = lpDdePktFromNext;

                        /* mark that we did another DDE packet */
                        nDone++;
                    } else {
                        /* doesn't fit cleanly into packet */
                        if( nDone == 0 )  {
                            /* needs to be split across many pkts */
                            msgSize = lpDdePktFrom->dp_size;
                            dwThis = lpPktz->pk_pktSize - sizeof(NETPKT);

                            /* copy first bit of DDE packet into net pkt */
                            hmemcpy( (LPSTR)lpDdePktTo, (LPSTR)lpDdePktFrom,
                                dwThis );

                            /* byte-ordering problems if any */
                            ConvertDdePkt( lpDdePktTo );

                            lpPktz->pk_pktOffsInXmtMsg += dwThis;
                            done = TRUE;
                        } else {
                            /* we've done some ... this is enough for now */
                            done = TRUE;
                        }
                    }
                }

                /* packet is built */
                lpPacket->np_pktSize            = (WORD) dwThis;
                lpPacket->np_pktOffsInMsg       = 0;
                lpPacket->np_msgSize            = msgSize;
                lpPacket->np_type               = NPKT_ROUTER;
                lpPacket->np_pktID              = lpPktz->pk_pktidNextToBuild;

                /* bump id of next pkt to build */
                lpPktz->pk_pktidNextToBuild++;

                /* link into list to send */
                PktzLinkToXmitList( lpPktz, lpSend );
            }
        }
    }

    /* by this time, we've checked all the odd cases, and lpSend points to
        a packet that is wither a control packet or a packet on the unack
        list that needs to be transmitted.  All we need to do is xmit it. */
    if( lpSend || bControlPktOnly )  {
        if( bControlPktOnly )  {
            lpPacket = (LPNETPKT) lpPktz->pk_controlPkt;
            lpPacket->np_pktID          = 0;
            lpPacket->np_type           = NPKT_CONTROL;
            lpPacket->np_pktSize        = 0;
            lpPacket->np_pktOffsInMsg   = 0;
            lpPacket->np_msgSize        = 0;
        } else {
            lpPacket = (LPNETPKT) ( ((LPSTR)lpSend) + sizeof(NETHDR) );
        }
        lpPacket->np_magicNum           = NDDESignature;
        lpPacket->np_lastPktOK          = lpPktz->pk_lastPktOk;
        lpPacket->np_lastPktRcvd        = lpPktz->pk_lastPktRcvd;
        lpPacket->np_lastPktStatus      = lpPktz->pk_lastPktStatus;

        lpPktz->pk_sent++;
        UpdateScreenStatistics();

        DIPRINTF(( "PKTZ Transmitting %08lX ...", lpPacket->np_pktID ));

        /* actually transmit the packet */
        (*lpPktz->pk_lpNiPtrs->XmtPacket) ( lpPktz->pk_connId, lpPacket,
            (WORD) (lpPacket->np_pktSize + sizeof(NETPKT)) );

        /* reset needing a control packet */
        lpPktz->pk_fControlPktNeeded = FALSE;

        /* start a timer for xmt stuck */
        if( lpPktz->pk_timeoutXmtStuck )  {
            assert( lpPktz->pk_hTimerXmtStuck == 0 );
            lpPktz->pk_hTimerXmtStuck = TimerSet( lpPktz->pk_timeoutXmtStuck,
                PktzTimerExpired, (DWORD_PTR)lpPktz, TID_XMT_STUCK, (DWORD)0 );
        }

        /* kill the keepalive timer and restart it */
        if( lpPktz->pk_hTimerKeepalive )  {
            TimerDelete( lpPktz->pk_hTimerKeepalive );
            lpPktz->pk_hTimerKeepalive = 0;
        }
        if( lpPktz->pk_timeoutKeepAlive )  {
            lpPktz->pk_hTimerKeepalive = TimerSet(
                lpPktz->pk_timeoutKeepAlive, PktzTimerExpired,
                (DWORD_PTR)lpPktz, TID_KEEPALIVE, (DWORD)0 );
        }

        if( lpPacket->np_type != NPKT_CONTROL )  {
            /* bump pkt id that we should send */
            lpPktz->pk_pktidNextToSend++;

            /* if not a control packet, start a send response timeout */
            assert( lpSend->nh_hTimerRspTO == 0 );
            lpSend->nh_hTimerRspTO = TimerSet( lpPktz->pk_timeoutSendRsp,
                PktzTimerExpired, (DWORD_PTR)lpPktz, TID_NO_RESPONSE,
                (DWORD_PTR)lpSend );
            if( lpSend->nh_hTimerRspTO == (HTIMER) NULL )  {
                /* ??? */
            }
        }
    }
}

/*
    PktzRcvdPacket()

        Called when we know there is a packet available from the netintf

        If this returns FALSE, the hPktz may no longer be valid!
 */
BOOL
PktzRcvdPacket( HPKTZ hPktz )
{
    DWORD       wProcessed;     /* how many bytes of pkt processed */
    LPNETPKT    lpPacket;
    LPDDEPKT    lpDdePktFrom;
    DDEPKT      ddePktAligned;
    NETPKT      netPktAligned;
    LPDDEPKT    lpDdePktNew;
    LPDDEPKT    lpDdePktNext;
    LPDDEPKT    lpDdePktHead;
    LPDDEPKT    lpDdePktLast;
    LPPKTZ      lpPktz = (LPPKTZ) hPktz;
    WORD        len;
    WORD        status;
    BOOL        ok;
    BOOL        done;
    BOOL        fPartial;

    /* get the packet from the netwoirk interface */
    ok = (*lpPktz->pk_lpNiPtrs->RcvPacket)
        ( lpPktz->pk_connId, lpPktz->pk_rcvBuf, &len, &status );
    if( !ok )  {
        return( FALSE );
    }

    lpPktz->pk_rcvd++;
    UpdateScreenStatistics();

    /* set lpPacket to point to what we just rcvd */
    lpPacket = (LPNETPKT)lpPktz->pk_rcvBuf;

    DIPRINTF(( "PKTZ: Rcvd Packet %08lX", lpPacket->np_pktID ));

    /* process control information */
    ok = PktzProcessControlInfo( lpPktz, lpPacket );
    /* hPktz may be invalid after this call */
    if( !ok )  {
        return( FALSE );
    }

    /* is this the packet we were expecting to see? */
    if( lpPacket->np_pktID != lpPktz->pk_pktidNextToRecv )  {
        /* ignore the contents of the message */
        if( lpPacket->np_pktID != 0L )  {
            if (bLogRetries) {
                /*  Packet out of sequence from "%1"
                    Received: %2, Expecting %3, Status: %4  */
                NDDELogWarning(MSG106, lpPktz->pk_szDestName,
                    LogString("0x%0X", lpPacket->np_pktID),
                    LogString("0x%0X", lpPktz->pk_pktidNextToRecv),
                    LogString("0x%0X", (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
                                            (lpPktz->pk_connId)), NULL);
            }
            /* mark that we must send info back to the other side */
            lpPktz->pk_fControlPktNeeded = TRUE;

            if( lpPacket->np_pktID > lpPktz->pk_pktidNextToRecv )  {
                /* received a packet beyond the one that we expected ...
                    ask the other side to retransmit this one */
                lpPktz->pk_lastPktStatus = PS_DATA_ERR;
                lpPktz->pk_lastPktRcvd = lpPktz->pk_pktidNextToRecv;
            }
        }
    } else {
        /* was the packet that we were expecting */
        if( status & NDDE_PKT_DATA_ERR )  {
            lpPktz->pk_lastPktStatus = PS_DATA_ERR;
            lpPktz->pk_lastPktRcvd = lpPacket->np_pktID;

            /* mark that we must send info back to the other side */
            lpPktz->pk_fControlPktNeeded = TRUE;
        } else {
            assert( status & NDDE_PKT_HDR_OK );
            assert( status & NDDE_PKT_DATA_OK );
            if( lpPacket->np_type == NPKT_PKTZ )  {
                if( !PktzProcessPkt( lpPktz, lpPacket ) )  {
                    /**** NOTE: lpPktz could be invalid after this call ****/
                    return( FALSE );
                }
            } else {
                lpDdePktFrom = (LPDDEPKT)(((LPSTR)lpPacket) + sizeof(NETPKT));
                /* make sure we're aligned */
                hmemcpy( (LPVOID)&netPktAligned, (LPVOID)lpPacket,
                    sizeof(netPktAligned) );
                if( netPktAligned.np_pktOffsInMsg == 0 )  {
                    /* first packet of msg */

                    lpDdePktHead = NULL;
                    lpDdePktLast = NULL;
                    ok = TRUE;
                    done = FALSE;
                    fPartial = FALSE;
                    wProcessed = 0;
                    do {
                        /* make sure we're aligned */
                        hmemcpy( (LPVOID)&ddePktAligned,
                            (LPVOID)lpDdePktFrom, sizeof(ddePktAligned) );

                        /* byte-ordering problems if any */
                        ConvertDdePkt( lpDdePktFrom );

                        lpDdePktNew = HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                            ddePktAligned.dp_size );
                        if( lpDdePktNew )  {
                            /* copy in at least first portion of packet */
                            hmemcpy( lpDdePktNew, lpDdePktFrom,
                                min(ddePktAligned.dp_size,
                                    (DWORD)netPktAligned.np_pktSize) );

                            if( ddePktAligned.dp_size >
                                    (DWORD)netPktAligned.np_pktSize){
                                /* partial DDE packet in */
                                fPartial = TRUE;

                                /* remember where we should start */
                                lpPktz->pk_lpDdePktSave = lpDdePktNew;
                                done = TRUE;
                            } else {
                                /* full packet */
                                wProcessed += lpDdePktNew->dp_size;

                                /* link onto end of temporary list */
                                lpDdePktNew->dp_next = NULL;
                                lpDdePktNew->dp_prev = lpDdePktLast;
                                if( lpDdePktLast )  {
                                    lpDdePktLast->dp_next = lpDdePktNew;
                                } else {
                                    lpDdePktHead = lpDdePktNew;
                                }
                                lpDdePktLast = lpDdePktNew;
                            }
                        } else {
                            ok = FALSE; /* memory error */
                        }
                        if( ok && !done )  {
                            if( (int)wProcessed >= netPktAligned.np_pktSize )  {
                                done = TRUE;
                            } else {
                                /* move onto the next DDE packet in msg */
                                lpDdePktFrom = (LPDDEPKT)
                                    ( ((LPHSTR)lpDdePktFrom)
                                        + lpDdePktNew->dp_size );
                            }
                        }
                    } while( ok && !done );
                    if( !ok )  {
                        /* memory error */
                        lpPktz->pk_lastPktRcvd = netPktAligned.np_pktID;
                        lpPktz->pk_lastPktStatus = PS_MEMORY_ERR;

                        /* mark that we must send info back to the other side
                         */
                        lpPktz->pk_fControlPktNeeded = TRUE;
                    } else {
                        /* got memory for all DDE packets */

                        /* mark that we got this pkt OK */
                        PktzGotPktOk( lpPktz, netPktAligned.np_pktID );

                        /* don't distribute if partial packet */
                        if( !fPartial )  {
                            /* distribute each packet */
                            lpDdePktNew = lpDdePktHead;
                            while( lpDdePktNew )  {
                                /* save dp_next, since distributing it could
                                    change dp_next */
                                lpDdePktNext = lpDdePktNew->dp_next;

                                /* distribute this packet */
                                RouterPacketFromNet( (HPKTZ)lpPktz,
                                    lpDdePktNew );

                                /* move on to next */
                                lpDdePktNew = lpDdePktNext;
                            }
                        }
                    }
                } else {
                    /* second or later packet of msg */
                    hmemcpy( (LPHSTR)lpPktz->pk_lpDdePktSave
                        + netPktAligned.np_pktOffsInMsg,
                        lpDdePktFrom,
                        netPktAligned.np_pktSize );

                    /* mark that we got this packet OK */
                    PktzGotPktOk( lpPktz, netPktAligned.np_pktID );

                    if( (netPktAligned.np_pktOffsInMsg +
                            netPktAligned.np_pktSize)
                                == netPktAligned.np_msgSize )  {
                        /* done with message */
                        /* distribute this packet */
                        RouterPacketFromNet( (HPKTZ)lpPktz,
                            lpPktz->pk_lpDdePktSave );
                    }
                }
            }
        }
    }
    /**** NOTE: lpPktz could be invalid after this call ****/
    return ok;
}

/*
    PktzConnectionComplete()

        Called when the netintf has completed the connection one way or
        another
 */
BOOL
PktzConnectionComplete(
    HPKTZ   hPktz,
    BOOL    fOk )
{
    LPPKTZ      lpPktz;
    LPNEGCMD    lpNegCmd;
    LPNETHDR    lpNetHdr;
    LPNETPKT    lpPacket;
    WORD        cmdSize;
    WORD        wProtocolBytes;
    LPSTR       lpszNextString;
    WORD        offsNextString;
    BOOL        ok = TRUE;

    lpPktz = (LPPKTZ) hPktz;

    if( fOk )  {
        /* connection was fine */

        /* note that we're waiting for the connect rsp */
        lpPktz->pk_state = PKTZ_WAIT_NEG_RSP;
        UpdateScreenState();

        lpNetHdr = PktzGetFreePacket( lpPktz );
        if( lpNetHdr == NULL )  {
            /* should be first message we sent! */
            assert( FALSE );
            /* ??? */
        } else {
            /* build packet for response */
            lpNegCmd = (LPNEGCMD)
                (((LPSTR)lpNetHdr) + sizeof(NETHDR) + sizeof(NETPKT));
            lpNegCmd->nc_type                   =
                PcToHostWord( PKTZ_NEG_CMD );
            lpNegCmd->nc_pktSize                =
                PcToHostWord( lpPktz->pk_pktSize );
            lpNegCmd->nc_maxUnackPkts           =
                PcToHostWord( lpPktz->pk_maxUnackPkts );
            lpszNextString = (LPSTR) lpNegCmd->nc_strings;
            offsNextString = 0;

            /* copy in source node name */
            lstrcpy( lpszNextString, ourNodeName );
            lpNegCmd->nc_offsSrcNodeName = offsNextString;
            offsNextString += lstrlen(lpszNextString) + 1;
            lpszNextString += lstrlen(lpszNextString) + 1;

            /* copy in dest node name */
            lstrcpy( lpszNextString, lpPktz->pk_szDestName );
            lpNegCmd->nc_offsDstNodeName = offsNextString;
            offsNextString += lstrlen(lpszNextString) + 1;
            lpszNextString += lstrlen(lpszNextString) + 1;

            /* copy in the protocol dialects that we are interested in */
            wProtocolBytes = 0;
            lpNegCmd->nc_offsProtocols = offsNextString;

            /* copy these 4 lines for each new protocol dialect added */
            lstrcpy( lpszNextString, OurDialect );
            wProtocolBytes += lstrlen(lpszNextString) + 1;
            offsNextString += lstrlen(lpszNextString) + 1;
            lpszNextString += lstrlen(lpszNextString) + 1;

            /* packet is filled in, just need to remember the size
                and do appropriate byte-swaps
             */
            cmdSize = (WORD) (sizeof(NEGCMD) + offsNextString - 1);

            lpNegCmd->nc_offsSrcNodeName =
                PcToHostWord( lpNegCmd->nc_offsSrcNodeName );
            lpNegCmd->nc_offsDstNodeName =
                PcToHostWord( lpNegCmd->nc_offsDstNodeName );
            lpNegCmd->nc_offsProtocols =
                PcToHostWord( lpNegCmd->nc_offsProtocols );
            lpNegCmd->nc_protocolBytes =
                PcToHostWord( wProtocolBytes );

            assert( lpPktz->pk_pktidNextToBuild == 1 );
            lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
            lpPacket->np_pktSize        = cmdSize;
            lpPacket->np_pktOffsInMsg   = 0;
            lpPacket->np_msgSize        = lpPacket->np_pktSize;
            lpPacket->np_type           = NPKT_PKTZ;
            lpPacket->np_pktID          = lpPktz->pk_pktidNextToBuild;

            /* bump id of next pkt to build */
            lpPktz->pk_pktidNextToBuild++;

            /* link into list to send */
            PktzLinkToXmitList( lpPktz, lpNetHdr );
        }
    } else {
        /* connection failed */

        lpPktz->pk_state = PKTZ_CLOSE;

        /* tell all routers of failure */
        RouterConnectionComplete( lpPktz->pk_hRouterHead,
            lpPktz->pk_hRouterExtraHead, (HPKTZ) NULL );

        /* disconnect the connection ... this tells netintf that we're
            through with this connId, etc. */
        (*lpPktz->pk_lpNiPtrs->DeleteConnection) ( lpPktz->pk_connId );

        /* free us ... we're no longer needed */
        PktzFree( lpPktz );
        ok = FALSE;
    }

    return( ok );
}

/*
    PktzFree()

        Called when we are completely done with a pktz
 */
VOID
PktzFree( LPPKTZ lpPktz )
{
    LPPKTZ      lpPktzPrev;
    LPPKTZ      lpPktzNext;

    LPNETHDR    lpNetCur;
    LPNETHDR    lpNetPrev;

    LPDDEPKT    lpDdeCur;
    LPDDEPKT    lpDdePrev;

    DIPRINTF(( "PktzFree( %08lX )", lpPktz ));

    /* delete any timers */
    TimerDelete( lpPktz->pk_hTimerKeepalive );
    lpPktz->pk_hTimerKeepalive = 0;
    TimerDelete( lpPktz->pk_hTimerXmtStuck );
    lpPktz->pk_hTimerXmtStuck = 0;
    TimerDelete( lpPktz->pk_hTimerRcvNegCmd );
    lpPktz->pk_hTimerRcvNegCmd = 0;
    TimerDelete( lpPktz->pk_hTimerRcvNegRsp );
    lpPktz->pk_hTimerRcvNegRsp = 0;
    TimerDelete( lpPktz->pk_hTimerMemoryPause );
    lpPktz->pk_hTimerMemoryPause = 0;
    TimerDelete( lpPktz->pk_hTimerCloseConnection );
    lpPktz->pk_hTimerCloseConnection = 0;

    /* free unack packet buffers */
    lpNetCur = lpPktz->pk_pktFreeTail;
    while( lpNetCur )  {
        lpNetPrev = lpNetCur->nh_prev;
        HeapFreePtr( lpNetCur );
        lpNetCur = lpNetPrev;
    }

    /* free rcv buffer */
    if( lpPktz->pk_rcvBuf )  {
        HeapFreePtr( lpPktz->pk_rcvBuf );
        lpPktz->pk_rcvBuf = NULL;
    }

    /* free Net Control Packet */
    if (lpPktz->pk_controlPkt) {
        HeapFreePtr(lpPktz->pk_controlPkt);
    }

    /* free outstanding unack packet buffers */
    lpNetCur = lpPktz->pk_pktUnackTail;
    while( lpNetCur )  {
        TimerDelete( lpNetCur->nh_hTimerRspTO );
        lpNetCur->nh_hTimerRspTO = 0;
        lpNetPrev = lpNetCur->nh_prev;
        HeapFreePtr( lpNetCur );
        lpNetCur = lpNetPrev;
    }

    /* free remaining DDE packets */
    lpDdeCur = lpPktz->pk_ddePktTail;
    while( lpDdeCur )  {
        lpDdePrev = lpDdeCur->dp_prev;
        HeapFreePtr( lpDdeCur );
        lpDdeCur = lpDdePrev;
    }

    /* unlink from list of packetizers */
    lpPktzPrev = lpPktz->pk_prevPktz;
    lpPktzNext = lpPktz->pk_nextPktz;
    if( lpPktzPrev )  {
        lpPktzPrev->pk_nextPktz = lpPktzNext;
    } else {
        lpPktzHead = lpPktzNext;
    }
    if( lpPktzNext )  {
        lpPktzNext->pk_prevPktz = lpPktzPrev;
    }

    /* free pktz */
    HeapFreePtr( lpPktz );
    UpdateScreenState();
}

VOID
PktzTimerExpired(
    HPKTZ   hPktz,
    DWORD   dwTimerId,
    DWORD_PTR lpExtra )
{
    LPPKTZ      lpPktz;
    LPNETHDR    lpNetHdr;
    LPNETPKT    lpPacket;
    LPPKTZCMD   lpPktzCmd;

    DIPRINTF(( "PktzTimerExpired( %08lX, %08lX, %08lX )",
            hPktz, dwTimerId, lpExtra ));

    lpPktz = (LPPKTZ) hPktz;
    switch( (int)dwTimerId )  {

    case TID_KEEPALIVE:
        DIPRINTF(( " KEEPALIVE Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerKeepalive = (HTIMER) NULL;

        /* mark that at least we should send a control packet just to keep the
           other guy around
         */
        lpPktz->pk_fControlPktNeeded = TRUE;

        /* no packets outstanding and no packets waiting to be built ...
            try to build one just to keep connection alive
         */
        if( (lpPktz->pk_pktUnackHead == NULL)
            && (lpPktz->pk_ddePktHead == NULL) )  {
            lpNetHdr = PktzGetFreePacket( lpPktz );
            if( lpNetHdr )  {
                /* build packet for keepalive */
                lpPktzCmd = (LPPKTZCMD)
                    (((LPSTR)lpNetHdr) + sizeof(NETHDR) + sizeof(NETPKT));
                lpPktzCmd->pc_type              = PKTZ_KEEPALIVE;

                lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
                lpPacket->np_pktSize            = sizeof(PKTZCMD);
                lpPacket->np_pktOffsInMsg       = 0;
                lpPacket->np_msgSize            = lpPacket->np_pktSize;
                lpPacket->np_type               = NPKT_PKTZ;
                lpPacket->np_pktID              = lpPktz->pk_pktidNextToBuild;

                /* bump id of next pkt to build */
                lpPktz->pk_pktidNextToBuild++;

                /* link into list to send */
                PktzLinkToXmitList( lpPktz, lpNetHdr );
            }
        }
        break;

    case TID_XMT_STUCK:
        DIPRINTF(( " XMT_STUCK Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerXmtStuck = (HTIMER) NULL;

        /* the other side must be dead if we can't transmit for this long */
        /* Transmit timeout (%2 secs) to "%1" ... closing connection    */
        NDDELogError(MSG107, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutXmtStuck/1000L), NULL );

        /* close this packetizer */
        PktzClose( (HPKTZ) lpPktz );
        break;

    case TID_CLOSE_PKTZ:
        /* note that timer went off */
         DIPRINTF(( "TID_CLOSE_PKTZ ... closing pktz %lx", lpPktz ));
        lpPktz->pk_hTimerCloseConnection = (HTIMER) NULL;

        /* close the connection */
        PktzClose( hPktz );
        break;

    case TID_NO_RCV_CONN_CMD:
        DIPRINTF(( " NO_RCV_CONN_CMD Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerRcvNegCmd = (HTIMER) NULL;

        /*  No connect commnad for (%2 secs) from "%1"
            ... closing connection   */
        NDDELogError(MSG108, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutRcvNegCmd/1000L), NULL);

        /* close this packetizer */
        PktzClose( hPktz );
        break;

    case TID_NO_RCV_CONN_RSP:
        DIPRINTF(( " NO_RCV_CONN_RSP Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerRcvNegRsp = (HTIMER) NULL;

        /*  No connect commnad response for (%2 secs) from "%1"
            ... closing connection  */
        NDDELogError(MSG109, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutRcvNegRsp/1000L), NULL);

        /* close this packetizer */
        PktzClose( hPktz );
        break;

    case TID_MEMORY_PAUSE:

        DIPRINTF(( " MEMORY_PAUSE Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerMemoryPause = (HTIMER) NULL;

        /*  Pausing (%2 secs) for remote side to get memory ... retrying    */
        NDDELogInfo(MSG110, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutMemoryPause/1000L), NULL);

        assert( lpPktz->pk_state == PKTZ_PAUSE_FOR_MEMORY );

        /* just set state to connected and try again */
        lpPktz->pk_state = PKTZ_CONNECTED;
        break;

    case TID_NO_RESPONSE:
        DIPRINTF(( " No Response Timer" ));
        lpNetHdr = (LPNETHDR) lpExtra;
        /* note that the timer went off */
        lpNetHdr->nh_hTimerRspTO = 0;

        lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
        if (bLogRetries) {
            /*  No response %2/%3 from remote side "%1" for pktid %4    */
            NDDELogWarning(MSG111, lpPktz->pk_szDestName,
                LogString("%d", lpNetHdr->nh_noRsp),
                LogString("%d", lpPktz->pk_wMaxNoResponse),
                LogString("%d", lpPacket->np_pktID), NULL);
        }
        lpNetHdr->nh_noRsp++;
        if( lpNetHdr->nh_noRsp > lpPktz->pk_wMaxNoResponse )  {
            /*  Too many no response retries (%2) for same packet from "%1"
                ... closing connection  */
            NDDELogError(MSG112, lpPktz->pk_szDestName,
                LogString("%d", lpNetHdr->nh_noRsp), NULL);
            PktzClose( hPktz );
        } else {
            lpPktz->pk_pktidNextToSend = lpPacket->np_pktID;
            lpNetHdr = lpNetHdr->nh_next;
            while( lpNetHdr )  {
                /* this packet was sent after the one that needs
                    to be retransmitted.  We should pretend we never
                    sent this packet. */
            if (lpNetHdr->nh_hTimerRspTO) {
                TimerDelete( lpNetHdr->nh_hTimerRspTO );
                lpNetHdr->nh_hTimerRspTO = 0;
            }
                lpNetHdr = lpNetHdr->nh_next;
            }
        }
        break;
    default:
        InternalError( "Unexpected pktz timer id: %08lX", dwTimerId );
    }
}

/*
    PktzSlice()

        Must be called frequently to assure timely response
 */
VOID
PktzSlice( void )
{
    LPPKTZ      lpPktz;
    LPPKTZ      lpPktzNext;
    DWORD       dwStatus;
    BOOL        ok;

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        /* save this in case pktz gets deleted inside */
        lpPktzNext = lpPktz->pk_nextPktz;
        ok = TRUE;

        /* get current state of netintf */
        dwStatus = (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
            ( lpPktz->pk_connId );

        switch( lpPktz->pk_state )  {
        case PKTZ_WAIT_PHYSICAL_CONNECT:
            /* check to see if we're done */
            if( dwStatus & NDDE_CONN_CONNECTING )  {
                /* continue to wait */
            } else if( dwStatus & NDDE_CONN_OK )  {
                ok = PktzConnectionComplete( (HPKTZ)lpPktz, TRUE );
                if( ok )  {
                    /* try to xmit starting pkt, if appropriate */
                    PktzOkToXmit( (HPKTZ)lpPktz );
                }
            } else {
                PktzConnectionComplete( (HPKTZ)lpPktz, FALSE );
            }
            break;
        case PKTZ_CONNECTED:
        case PKTZ_WAIT_NEG_CMD:
        case PKTZ_WAIT_NEG_RSP:
            /* check to see if we're done */
            if( (dwStatus & NDDE_CONN_STATUS_MASK) == 0 )  {
                PktzConnectionBroken( (HPKTZ)lpPktz );
            } else {
                if( (dwStatus & NDDE_CONN_OK)
                        && (dwStatus & NDDE_CALL_RCV_PKT) ) {
                    ok = PktzRcvdPacket( (HPKTZ)lpPktz );
                    /* lpPktz may be invalid after this call */
                }
                if( ok && (dwStatus & NDDE_CONN_OK)
                        && (dwStatus & NDDE_READY_TO_XMT) )  {
                    PktzOkToXmit( (HPKTZ)lpPktz );
                }
            }
            break;
        case PKTZ_PAUSE_FOR_MEMORY:
            if( (dwStatus & NDDE_CONN_STATUS_MASK) == 0 )  {
                PktzConnectionBroken( (HPKTZ)lpPktz );
            }
            break;
        case PKTZ_CLOSE:
            break;
        default:
            InternalError( "PKTZ %08lX in unknown state: %ld",
                (HPKTZ)lpPktz, (DWORD)lpPktz->pk_state );
            break;
        }
        lpPktz = lpPktzNext;
    }
}

/*
    PktzProcessControlInfo()

        Called for each packet that we receive ... this is where we process
        all the "control" information in the rcvd packet, such as which packet
        the other side has received OK thru, etc.

        NOTE: lpPktz may be invalid after this call if it returns FALSE

 */
BOOL
PktzProcessControlInfo(
    LPPKTZ      lpPktz,
    LPNETPKT    lpPacket )
{
    LPNETHDR    lpNetHdr;
    LPNETHDR    lpNetHdrNext;
    LPNETHDR    lpNetHdrPrev;
    BOOL        ok = TRUE;

    /* if we got an acknowledgment and we have some outstanding packets... */
    if( lpPacket->np_lastPktOK != 0 )  {
        /* this represenets an acknowledgment from the other side of packets
           that we have transmitted.
         */
        lpNetHdr = lpPktz->pk_pktUnackHead;
        while( lpNetHdr &&
            PktzNetHdrWithinAck( lpPktz, lpNetHdr, lpPacket->np_lastPktOK )) {

            /* this unack packet was ACKed by this message */

            /* kill the send response timer for this packet */
            TimerDelete( lpNetHdr->nh_hTimerRspTO );
            lpNetHdr->nh_hTimerRspTO = 0;

            /* free the packet, by moving it from the unack list to
                the pkt available list */
            lpNetHdrPrev = lpNetHdr->nh_prev;
            lpNetHdrNext = lpNetHdr->nh_next;

            /* unlink from pktUnack list */
            assert( lpNetHdrPrev == NULL );     /* should be unlinking head */
            if( lpNetHdrNext )  {
                lpNetHdrNext->nh_prev = NULL;
            } else {
                lpPktz->pk_pktUnackTail = NULL;
            }
            lpPktz->pk_pktUnackHead = lpNetHdrNext;

            /* link into head of pktFree list */
            lpNetHdr->nh_prev = NULL;
            lpNetHdr->nh_next = lpPktz->pk_pktFreeHead;
            if( lpPktz->pk_pktFreeHead )  {
                lpPktz->pk_pktFreeHead->nh_prev = lpNetHdr;
            } else {
                lpPktz->pk_pktFreeTail = lpNetHdr;
            }
            lpPktz->pk_pktFreeHead = lpNetHdr;

            /* go on to the next packet */
            lpNetHdr = lpNetHdrNext;
        }
    }

    /* note that the other side has rcvd OK through this */
    lpPktz->pk_lastPktOkOther = lpPacket->np_lastPktOK;

    if( lpPacket->np_lastPktOK != lpPacket->np_lastPktRcvd )  {
        /* a packet that we transmitted had an error in it */
        ok = PktzXmitErrorOnPkt( lpPktz, lpPacket->np_lastPktRcvd,
            lpPacket->np_lastPktStatus );
        /* lpPktz may be invalid after this call */
    }

    /* lpPktz may be invalid after this call */
    return( ok );
}

/*
    PktzProcessPkt()

        This is called for pktz-pktz packets only which for now is either
        PKTZ_NEG_CMD or PKTZ_NEG_RSP or PKTZ_KEEPALIVE
 */
BOOL
PktzProcessPkt(
    LPPKTZ      lpPktz,
    LPNETPKT    lpPacket )
{
    LPNEGRSP    lpNegRsp;
    LPNEGCMD    lpNegCmd;
    LPPKTZCMD   lpPktzCmd;
    LPSTR       lpProtocol;
    WORD        oldPkState;
    LPNETHDR    lpNetHdr;
    WORD        wErrorClass;
    WORD        wErrorNum;
    char        szNetintf[ MAX_NI_NAME+1 ];
    char        szConnInfo[ MAX_CONN_INFO+1 ];
    int         i = 0;
    WORD        wProtocol;
    WORD        wBytesConsumed;
    BOOL        ok = TRUE;

#define GetLPSZNegCmdString(lpNegCmd,offs)      \
    (LPSTR)(((lpNegCmd)->nc_strings)+offs)

    /* set up pointer to data portion of packet */
    lpPktzCmd = (LPPKTZCMD) (((LPSTR)lpPacket) + sizeof(NETPKT));

    /* convert byte-ordering */
    lpPktzCmd->pc_type = PcToHostWord( lpPktzCmd->pc_type );

    /* mark that we got this pkt OK */
    PktzGotPktOk( lpPktz, lpPacket->np_pktID );

    if( lpPktzCmd->pc_type == PKTZ_KEEPALIVE )  {
        /* ignore keepalive packets */
    } else if( lpPktzCmd->pc_type == PKTZ_NEG_CMD )  {
        lpNegCmd = (LPNEGCMD) lpPktzCmd;
        lpNegCmd->nc_pktSize =
            PcToHostWord( lpNegCmd->nc_pktSize );
        lpNegCmd->nc_maxUnackPkts =
            PcToHostWord( lpNegCmd->nc_maxUnackPkts );
        lpNegCmd->nc_offsSrcNodeName =
            PcToHostWord( lpNegCmd->nc_offsSrcNodeName );
        lpNegCmd->nc_offsDstNodeName =
            PcToHostWord( lpNegCmd->nc_offsDstNodeName );
        lpNegCmd->nc_offsProtocols =
            PcToHostWord( lpNegCmd->nc_offsProtocols );
        lpNegCmd->nc_protocolBytes =
            PcToHostWord( lpNegCmd->nc_protocolBytes );

        /* got the neg cmd from the other side that we were waiting for */

        oldPkState = lpPktz->pk_state;
        /* kill the timer associated with this */
        TimerDelete( lpPktz->pk_hTimerRcvNegCmd );
        lpPktz->pk_hTimerRcvNegCmd = 0;

        /* copy in node name of other side */
        lstrcpy( lpPktz->pk_szDestName,
            GetLPSZNegCmdString( lpNegCmd, lpNegCmd->nc_offsSrcNodeName ) );

        /* set up timeouts based on other side's name */
        GetConnectionInfo( lpPktz->pk_szDestName, szNetintf,
            szConnInfo, sizeof(szConnInfo),
            &lpPktz->pk_fDisconnect, &lpPktz->pk_nDelay );

        if( oldPkState == PKTZ_WAIT_NEG_CMD )  {
            /* if other side wants lesser # of max unack pkts, so be it */
            if( lpNegCmd->nc_maxUnackPkts < lpPktz->pk_maxUnackPkts )  {
                lpPktz->pk_maxUnackPkts = lpNegCmd->nc_maxUnackPkts;
            }

            /* if other side wants smaller packets, so be it */
            if( lpNegCmd->nc_pktSize < lpPktz->pk_pktSize )  {
                lpPktz->pk_pktSize = lpNegCmd->nc_pktSize;
            }

            /* tell the network interface about these changes,
                in case he cares */
            (*lpPktz->pk_lpNiPtrs->SetConnectionConfig) ( lpPktz->pk_connId,
                lpPktz->pk_maxUnackPkts, lpPktz->pk_pktSize,
                lpPktz->pk_szDestName );
        }

        /* figure out which protocol */
        wProtocol = NEGRSP_PROTOCOL_NONE;
        wErrorClass = NEGRSP_ERRCLASS_NONE;
        wErrorNum = 0;
        wBytesConsumed = 0;
        lpProtocol = GetLPSZNegCmdString( lpNegCmd,
            lpNegCmd->nc_offsProtocols );

        i = 0;
        while( (wProtocol==NEGRSP_PROTOCOL_NONE)
            && (wBytesConsumed < lpNegCmd->nc_protocolBytes) )  {
            if( lstrcmpi( lpProtocol, OurDialect ) == 0 )  {
                wProtocol = (WORD) i;
            } else {
                /* advance to next string */
                wBytesConsumed += lstrlen( lpProtocol ) + 1;
                lpProtocol += lstrlen( lpProtocol ) + 1;
                i++;
            }
        }

        /* make sure the names matched */
        if( lstrcmpi( ourNodeName, GetLPSZNegCmdString(
                lpNegCmd, lpNegCmd->nc_offsDstNodeName ) ) != 0 )  {
            wErrorClass = NEGRSP_ERRCLASS_NAME;
            wErrorNum = NEGRSP_ERRNAME_MISMATCH;
        } else { /* make sure they are not us */
            if ( lstrcmpi( ourNodeName, GetLPSZNegCmdString(
                    lpNegCmd, lpNegCmd->nc_offsSrcNodeName ) ) == 0 ) {
                wErrorClass = NEGRSP_ERRCLASS_NAME;
                wErrorNum = NEGRSP_ERRNAME_DUPLICATE;
            }
        }

        /* create the response to send back */
        /* get a packet */
        lpNetHdr = PktzGetFreePacket( lpPktz );
        if( lpNetHdr == NULL )  {
            /* should be first message we sent! */
            assert( FALSE );
            /* ??? */
        } else {
            /* build packet for response */
            lpNegRsp = (LPNEGRSP)
                (((LPSTR)lpNetHdr) + sizeof(NETHDR) + sizeof(NETPKT));
            lpNegRsp->nr_type           =
                                    PcToHostWord( PKTZ_NEG_RSP );
            lpNegRsp->nr_pktSize        =
                                    PcToHostWord( lpPktz->pk_pktSize );
            lpNegRsp->nr_maxUnackPkts   =
                                    PcToHostWord( lpPktz->pk_maxUnackPkts );
            lpNegRsp->nr_protocolIndex  =
                                    PcToHostWord( wProtocol );
            lpNegRsp->nr_errorClass     =
                                    PcToHostWord( wErrorClass );
            lpNegRsp->nr_errorNum       =
                                    PcToHostWord( wErrorNum );

            lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
            lpPacket->np_pktSize        = sizeof(NEGRSP);
            lpPacket->np_pktOffsInMsg   = 0;
            lpPacket->np_msgSize        = lpPacket->np_pktSize;
            lpPacket->np_type           = NPKT_PKTZ;
            lpPacket->np_pktID          = lpPktz->pk_pktidNextToBuild;

            /* note that the connection is completed */
            if( oldPkState == PKTZ_WAIT_NEG_CMD )  {
                lpPktz->pk_state = PKTZ_CONNECTED;
                UpdateScreenState();
            }

            /* bump id of next pkt to build */
            lpPktz->pk_pktidNextToBuild++;

            /* link into list to send */
            PktzLinkToXmitList( lpPktz, lpNetHdr );

            if( oldPkState == PKTZ_WAIT_NEG_CMD )  {
                /* notify all routers that were waiting */
                RouterConnectionComplete( lpPktz->pk_hRouterHead,
                    lpPktz->pk_hRouterExtraHead, (HPKTZ) lpPktz );
            }
        }
    } else if( (lpPktz->pk_state == PKTZ_WAIT_NEG_RSP)
        && (lpPktzCmd->pc_type == PKTZ_NEG_RSP) )  {
        /* got the neg rsp from the other side that we were waiting for */

        /* kill the timer associated with this */
        TimerDelete( lpPktz->pk_hTimerRcvNegRsp );
        lpPktz->pk_hTimerRcvNegRsp = 0;

        lpNegRsp = (LPNEGRSP) lpPktzCmd;

        /* convert byte-order */
        lpNegRsp->nr_pktSize =
                            PcToHostWord( lpNegRsp->nr_pktSize );
        lpNegRsp->nr_maxUnackPkts =
                            PcToHostWord( lpNegRsp->nr_maxUnackPkts );
        lpNegRsp->nr_protocolIndex =
                            PcToHostWord( lpNegRsp->nr_protocolIndex );
        lpNegRsp->nr_errorClass =
                            PcToHostWord( lpNegRsp->nr_errorClass );
        lpNegRsp->nr_errorNum =
                            PcToHostWord( lpNegRsp->nr_errorNum );

        if( (lpNegRsp->nr_errorClass == NEGRSP_ERRCLASS_NONE)
            && (lpNegRsp->nr_protocolIndex != NEGRSP_PROTOCOL_NONE)
            && (lpNegRsp->nr_protocolIndex == 0) )  {
            /* connection OK */

            /* if other side wants lesser # of max unack pkts, so be it */
            if( lpNegRsp->nr_maxUnackPkts < lpPktz->pk_maxUnackPkts )  {
                lpPktz->pk_maxUnackPkts = lpNegRsp->nr_maxUnackPkts;
            }

            /* if other side wants smaller packets, so be it */
            if( lpNegRsp->nr_pktSize < lpPktz->pk_pktSize )  {
                lpPktz->pk_pktSize = lpNegRsp->nr_pktSize;
            }

            /* tell the network interface about these changes,
                in case he cares */
            (*lpPktz->pk_lpNiPtrs->SetConnectionConfig) ( lpPktz->pk_connId,
                lpPktz->pk_maxUnackPkts, lpPktz->pk_pktSize,
                lpPktz->pk_szDestName );

            /* note that the connection is completed */
            lpPktz->pk_state = PKTZ_CONNECTED;
            UpdateScreenState();

            /* notify all routers that were waiting */
            RouterConnectionComplete( lpPktz->pk_hRouterHead,
                lpPktz->pk_hRouterExtraHead, (HPKTZ) lpPktz );
        } else {
            /* connection failed */
            if( lpNegRsp->nr_protocolIndex == NEGRSP_PROTOCOL_NONE )  {
                /*  "%1" node does not speak any of our protocols    */
                NDDELogError(MSG113, lpPktz->pk_szDestName, NULL);
            } else if( lpNegRsp->nr_protocolIndex != 0 )  {
                /*  "%1" node selected an invalid protocol: %2  */
                NDDELogError(MSG114, lpPktz->pk_szDestName,
                    LogString("%d", lpNegRsp->nr_protocolIndex), NULL );
            } else switch( lpNegRsp->nr_errorClass )  {
            case NEGRSP_ERRCLASS_NAME:
                switch( lpNegRsp->nr_errorClass )  {
                case NEGRSP_ERRNAME_MISMATCH:
                    /*  "%1" their name was not "%2"    */
                    NDDELogError(MSG115,
                        lpPktz->pk_szDestName,
                        lpPktz->pk_szDestName, NULL );
                    break;
                case NEGRSP_ERRNAME_DUPLICATE:
                    /*  "%1" their name was same as ours "%2"    */
                    NDDELogError(MSG142,
                        lpPktz->pk_szDestName,
                        ourNodeName, NULL );
                    break;
                default:
                    /*  Unusual connect name error %2 from %1   */
                    NDDELogError(MSG116, lpPktz->pk_szDestName,
                        LogString("0x%0X", lpNegRsp->nr_errorNum), NULL );
					break;
                }
                break;
            default:
                /*  Unusual connect error from %1. Class: %2, Error: %3 */
                NDDELogError(MSG117, lpPktz->pk_szDestName,
                    LogString("0x%0X", lpNegRsp->nr_errorClass),
                    LogString("0x%0X", lpNegRsp->nr_errorNum), NULL );
                break;
            }

            /* notify all routers that were waiting */
            RouterConnectionComplete( lpPktz->pk_hRouterHead,
                lpPktz->pk_hRouterExtraHead, (HPKTZ) NULL );

            /* disconnect from connId */
            (*lpPktz->pk_lpNiPtrs->DeleteConnection) ( lpPktz->pk_connId );

            /* free this packetizer */
            PktzFree( lpPktz );
            ok = FALSE;
        }
    } else {
        /* ignore the packet if it wasn't sent during the correct mode
            or we have the wrong version # interface */
    }
    return( ok );
}

/*
    PktzNetHdrWithinAck

        PktzNetHdrWithinAck() determines if the packet specified in lpNetHdr
        is in the range to be considered ACKed by the packet id "pktid".

        Generically, this could be as simple as:
            Is lpPacket->np_pktid <= pktid?

        However, because of wraparound, we must make the check a bit more
        sophisticated.
 */
BOOL
PktzNetHdrWithinAck(
    LPPKTZ      lpPktz,
    LPNETHDR    lpNetHdr,
    PKTID       pktId )
{
    LPNETPKT    lpPacket;

    lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );

    if( lpPacket->np_pktID <= pktId )  {
        return( TRUE );
    } else {
        return( FALSE );
    }
}

/*
    PktzGetFreePacket()

        Returns a packet to be sent from the free list
 */
LPNETHDR
PktzGetFreePacket( LPPKTZ lpPktz )
{
    LPNETHDR    lpCur;

    lpCur = lpPktz->pk_pktFreeHead;
    if( lpCur )  {
        lpPktz->pk_pktFreeHead = lpCur->nh_next;
        if( lpPktz->pk_pktFreeHead )  {
            lpPktz->pk_pktFreeHead->nh_prev = NULL;
        } else {
            lpPktz->pk_pktFreeTail = NULL;
        }

        /* init fields of nethdr */
        lpCur->nh_prev          = NULL;
        lpCur->nh_next          = NULL;
        lpCur->nh_noRsp         = 0;
        lpCur->nh_xmtErr        = 0;
        lpCur->nh_memErr        = 0;
        lpCur->nh_timeSent      = 0;
        lpCur->nh_hTimerRspTO   = 0;
    }

    return( lpCur );
}

/*
    PktzXmitErrorOnPkt

        A packet that we transmitted had an error in it.  We must reset the
        pkt xmit side to ensure that this is the next packet that we send,
        and consider that all packets that were sent after this have
        never been sent (so we must kill timers associated with them, etc.)

        The "pktStatus" field tells us why we need to retransmit that packet,
        and we need to increment the count of how many times this pacekt has
        been rejected for this reason.  If we exceed the max count, we should
        kill the connection.
 */
BOOL
PktzXmitErrorOnPkt(
    LPPKTZ  lpPktz,
    PKTID   pktIdToRexmit,
    BYTE    pktStatus )
{
    LPNETHDR    lpNetHdr;
    LPNETPKT    lpPacket;
    BOOL        found;
    BOOL        ok = TRUE;

    lpNetHdr = lpPktz->pk_pktUnackHead;

    found = FALSE;
    ok = TRUE;
    while( lpNetHdr && ok )  {
        lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
        if( lpPacket->np_pktID == pktIdToRexmit )  {
            found = TRUE;
            switch( pktStatus )  {
            case PS_NO_RESPONSE:
                lpNetHdr->nh_noRsp++;
                if( lpNetHdr->nh_noRsp > lpPktz->pk_wMaxNoResponse )  {
                    /*  Too many transmit retries (%2) for same packet to "%1"
                        ... closing connection  */
                    NDDELogError(MSG118, lpPktz->pk_szDestName,
                        LogString("%d", lpNetHdr->nh_noRsp), NULL);
                    ok = FALSE;
                }
                break;
            case PS_DATA_ERR:
                if (bLogRetries) {
                    /*  Transmit error on pktid %2 to "%1"  */
                    NDDELogError(MSG119, lpPktz->pk_szDestName,
                        LogString("0x%0X", pktIdToRexmit), NULL);
                }
                lpNetHdr->nh_xmtErr++;
                if( lpNetHdr->nh_xmtErr > lpPktz->pk_wMaxXmtErr )  {
                    /*  Too many retries to "%1" for xmit errs (%2)
                        ... closing connection  */
                    NDDELogError(MSG120, lpPktz->pk_szDestName,
                        LogString("%d", lpNetHdr->nh_xmtErr), NULL);
                    ok = FALSE;
                }
                break;
            case PS_MEMORY_ERR:
                /*  Memory error on pktid %2 xmitted to "%1"    */
                NDDELogError(MSG121, lpPktz->pk_szDestName,
                    LogString("0x%0X", lpNetHdr->nh_xmtErr), NULL);
                lpNetHdr->nh_memErr++;
                if( lpNetHdr->nh_memErr > lpPktz->pk_wMaxMemErr )  {
                    /*  Too many xmit retries to "%1" for memory errors (%2)
                        ... closing connection  */
                    NDDELogError(MSG122, lpPktz->pk_szDestName,
                        LogString("%d", lpNetHdr->nh_memErr), NULL);
                    ok = FALSE;
                } else {
                    lpPktz->pk_hTimerMemoryPause =
                        TimerSet( lpPktz->pk_timeoutMemoryPause,
                                  PktzTimerExpired,
                                  (DWORD_PTR)lpPktz,
                                  TID_MEMORY_PAUSE,
                                  (DWORD_PTR)lpNetHdr );
                    if( lpPktz->pk_hTimerMemoryPause == (HTIMER) NULL )  {
                        /* Out of timers to start a memory pause for a xmit to "%1" */
                        NDDELogError(MSG123, lpPktz->pk_szDestName, NULL );
                        ok = FALSE;
                    } else {
                        /* change state to waiting for memory.  Shouldn't
                           send anything but control packets until memory
                           condition clears
                         */
                        lpPktz->pk_state = PKTZ_PAUSE_FOR_MEMORY;
                        UpdateScreenState();
                    }
                }
                break;
            default:
                InternalError(
                    "PktzXmitErrorOnPkt( %08lX, %08lX, %d ) unkn status",
                    lpPktz, pktIdToRexmit, pktStatus );
            }
        }
        if( found )  {
            /* this packet was the one that needed to be retransmitted, or
                was sent after the one that needs to be retransmitted.  Either
                way, we should pretend we never sent this packet */
            TimerDelete( lpNetHdr->nh_hTimerRspTO );
            lpNetHdr->nh_hTimerRspTO = 0;
        }
        lpNetHdr = lpNetHdr->nh_next;
    }

    assert( found );
    lpPktz->pk_pktidNextToSend = pktIdToRexmit;
    if( !ok )  {
        /* must close the connection */
        PktzClose( (HPKTZ) lpPktz );
    }
    /* lpPktz may be invalid after this call */
    return( ok );
}

/*
    PktzLinkToXmitList()

        This routine makes sure that the packet is on the list to get sent.
        Packet is already not on free list ... just needs linked to xmt list.
 */
VOID
PktzLinkToXmitList(
    LPPKTZ      lpPktz,
    LPNETHDR    lpNetHdr )
{
    LPNETPKT    lpPacket;

    DIPRINTF(( "PktzLinkToXmitList( %08lX, %08lX ) before linking",
            lpPktz, lpNetHdr ));
    lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );

    lpNetHdr->nh_prev = lpPktz->pk_pktUnackTail;
    lpNetHdr->nh_next = NULL;
    if( lpPktz->pk_pktUnackTail )  {
        lpPktz->pk_pktUnackTail->nh_next = lpNetHdr;
    } else {
        lpPktz->pk_pktUnackHead = lpNetHdr;
    }
    lpPktz->pk_pktUnackTail = lpNetHdr;

    /* set up so xmit will send this packet next */
    lpPktz->pk_pktidNextToSend = lpPacket->np_pktID;
}

/*
    PktzClose()

        Only called internally when we need to break the connection or the
        connection is already broken
 */
VOID
PktzClose( HPKTZ hPktz )
{
    LPPKTZ      lpPktz;

    DIPRINTF(( "PktzClose( %08lX )", hPktz ));

    lpPktz = (LPPKTZ) hPktz;

    if( lpPktz )  {
        /* Notify all routers of closure */
        RouterConnectionBroken( lpPktz->pk_hRouterHead,
            lpPktz->pk_hRouterExtraHead, hPktz, TRUE /*from PKTZ*/ );

        /* disconnect from connId */
        (*lpPktz->pk_lpNiPtrs->DeleteConnection) ( lpPktz->pk_connId );

        /* free this packetizer */
        PktzFree( lpPktz );
    }
}

/*
    Called (in essence) by the netintf when the connection has been broken
    abnormally
 */
VOID
PktzConnectionBroken( HPKTZ hPktz )
{
    DIPRINTF(( "PktzConnectionBroken( %08lX )", hPktz ));
    PktzClose( hPktz );
}

/*
    PktzFreeDdePkt()

        Frees a packet that we already transmitted.  Frees from list of DDE
        packets to be sent as well as freeing the memory associated with the
        packet
 */
VOID
PktzFreeDdePkt(
    LPPKTZ      lpPktz,
    LPDDEPKT    lpDdePkt )
{
    assert( lpDdePkt == lpPktz->pk_ddePktHead );
    lpPktz->pk_ddePktHead = lpDdePkt->dp_next;
    if( lpPktz->pk_ddePktHead )  {
        ( (LPDDEPKT)(lpPktz->pk_ddePktHead) )->dp_prev = NULL;
    } else {
        lpPktz->pk_ddePktTail = NULL;
    }
    HeapFreePtr( lpDdePkt );
}

/*
    PktzGetPktzForRouter()

        Called by the router when we need to establish a connection to another
        node.  If we already have the connection, we just return that
        connection ... otherwise we use the specified netintf to connect
 */
BOOL
PktzGetPktzForRouter(
    LPNIPTRS    lpNiPtrs,
    LPSTR       lpszNodeName,
    LPSTR       lpszNodeInfo,
    HROUTER     hRouter,
    WORD        hRouterExtra,
    WORD FAR   *lpwHopErr,
    BOOL        bDisconnect,
    int         nDelay,
    HPKTZ       hPktzDisallowed )
{
    LPPKTZ      lpPktz;
    HPKTZ       hPktz;
    BOOL        found;
    BOOL        ok;

    lpPktz = lpPktzHead;
    found = FALSE;
    ok = FALSE;
    while( !found && lpPktz )  {
        if ( (lpPktz->pk_state != PKTZ_CLOSE)
			   && ((lstrcmpi( lpszNodeName, lpPktz->pk_szDestName ) == 0)
            || (lstrcmpi( lpszNodeName, lpPktz->pk_szAliasName ) == 0)) )  {
            found = TRUE;

            /* for a NET-NET connection, we must disallow the same PKTZ
                for both sides of the NET-NET, since the router uses
                the PKTZ to determine which leg of the NET-NET connection
                the packet came in on.

                The error case that this catches is on node "D" for a route
                like:  A+C+D+C+B, since "C" is the "in" and "out" pktz
                for "D".
             */
            if( lpPktz == (LPPKTZ)hPktzDisallowed )  {
                *lpwHopErr = RERR_DIRECT_LOOP;
                return( FALSE );
            }
            /* tell this pktz that this router should be associated with him
             */
            PktzAssociateRouter( (HPKTZ)lpPktz, hRouter, hRouterExtra );
            ok = TRUE;
        }
        lpPktz = lpPktz->pk_nextPktz;
    }
    if( !found )  {
        /* create a pktz for this node connection */
        hPktz = PktzNew( lpNiPtrs, TRUE /* client */,
            lpszNodeName, lpszNodeInfo, (CONNID)0, bDisconnect, nDelay );
        if( hPktz )  {
            lpPktz = (LPPKTZ) hPktz;

            /* tell this pktz that this router should be associated with him
             */
            PktzAssociateRouter( (HPKTZ)lpPktz, hRouter, hRouterExtra );
            ok = TRUE;
        } else {
            ok = FALSE;
            *lpwHopErr = RERR_NEXT_NODE_CONN_FAILED;
        }
    }
    return( ok );
}

/*
    PktzDestroyCurrentConnections()

        This is called to destroy all current physical connections.  This is
        done when the user wants to close down NetDDE
 */
VOID
PktzDestroyCurrentConnections( void )
{
    LPPKTZ      lpPktz;
    LPPKTZ      lpPktzNext;

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        lpPktzNext = lpPktz->pk_nextPktz;
        PktzClose( (HPKTZ) lpPktz );
        lpPktz = lpPktzNext;
    }
}

/*
    PktzLinkDdePktToXmit()

        This is called by the router when it has a packet for us to transmit
 */
VOID
PktzLinkDdePktToXmit(
    HPKTZ       hPktz,
    LPDDEPKT    lpDdePkt )
{
    LPPKTZ      lpPktz;
    BOOL        bWasEmpty = FALSE;
#ifndef _WINDOWS
    DWORD       dwStatus;
#endif

    lpPktz = (LPPKTZ) hPktz;

    /* link this packet onto the end of the list */
    lpDdePkt->dp_prev = lpPktz->pk_ddePktTail;
    lpDdePkt->dp_next = NULL;
    if( lpPktz->pk_ddePktTail )  {
        ((LPDDEPKT)lpPktz->pk_ddePktTail)->dp_next = lpDdePkt;
    }
    lpPktz->pk_ddePktTail = lpDdePkt;
    if( lpPktz->pk_ddePktHead == NULL )  {
        lpPktz->pk_ddePktHead = lpDdePkt;
        bWasEmpty = TRUE;
    }

#ifdef _WINDOWS
    {
        MSG     msg;

        if (ptdHead != NULL) {
            /* kick off pktz slice at next opportunity, if a timer message
                isn't already waiting */
            if( !PeekMessage( &msg, ptdHead->hwndDDE, WM_TIMER, WM_TIMER,
                    PM_NOREMOVE | PM_NOYIELD ) )  {
                PostMessage( ptdHead->hwndDDE, WM_TIMER, 0, 0L );
            }
        }
    }
#else
    /* if lpPktz->pk_ddePktHead was == NULL, tell pktz to get going */
    if( bWasEmpty )  {
        dwStatus = (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
            ( lpPktz->pk_connId );
        if( (dwStatus & NDDE_CONN_OK) && (dwStatus & NDDE_READY_TO_XMT) )  {
            PktzOkToXmit( (HPKTZ)lpPktz );
        }
    }
#endif
}

/*
    PktzGotPktOk()

        Called when we know this pkt id has been rcvd OK
 */
VOID
PktzGotPktOk(
    LPPKTZ  lpPktz,
    PKTID   pktid )
{
    assert( pktid == lpPktz->pk_pktidNextToRecv );
    lpPktz->pk_lastPktRcvd      = pktid;
    lpPktz->pk_lastPktStatus    = PS_OK;
    lpPktz->pk_lastPktOk        = pktid;
    lpPktz->pk_pktidNextToRecv++;

    /* mark that we must send info back to the other side
     */
    lpPktz->pk_fControlPktNeeded = TRUE;
}

#ifdef _WINDOWS

#ifdef HASUI

#include <stdio.h>
#include "tmpbuf.h"

int
PktzDraw(
    HDC     hDC,
    int     x,
    int     vertPos,
    int     lineHeight )
{
    LPPKTZ      lpPktz;
    char        name[ 50 ];

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        /* get layer name */
        lstrcpy( name, lpPktz->pk_lpNiPtrs->dllName );
        if( bShowStatistics )  {
            sprintf( tmpBuf, " %7ld %7ld %-16.16Fs %-33.33Fs",
                lpPktz->pk_sent, lpPktz->pk_rcvd,
                (LPSTR) name,
                (LPSTR) _fstrupr(lpPktz->pk_szDestName) );
        } else {
            sprintf( tmpBuf, " %-16.16Fs %-33.33Fs",
                (LPSTR) name,
                (LPSTR) _fstrupr(lpPktz->pk_szDestName) );
        }
        switch( lpPktz->pk_state )  {
        case PKTZ_CONNECTED:
            strcat( tmpBuf, " Connected" );
            break;
        case PKTZ_WAIT_PHYSICAL_CONNECT:
            strcat( tmpBuf, " Wait Network Connect" );
            break;
        case PKTZ_WAIT_NEG_CMD:
            strcat( tmpBuf, " Wait Connect Cmd" );
            break;
        case PKTZ_WAIT_NEG_RSP:
            strcat( tmpBuf, " Wait Connect Rsp" );
            break;
        case PKTZ_PAUSE_FOR_MEMORY:
            strcat( tmpBuf, " Pause for Memory" );
            break;
        case PKTZ_CLOSE:
            strcat( tmpBuf, " Disconnected" );
            break;
        default:
            sprintf( &tmpBuf[ strlen(tmpBuf) ], " unknown (%04lX)",
                lpPktz->pk_state );
            break;
        }
        TextOut( hDC, x, vertPos, tmpBuf, strlen(tmpBuf) );
        vertPos += lineHeight;
        lpPktz = lpPktz->pk_nextPktz;
    }
    return( vertPos );
}

#endif // HASUI

#endif

#if DBG

VOID
FAR PASCAL
DebugPktzState( void )
{
    LPPKTZ      lpPktz;
    char        name[ 50 ];

    lpPktz = lpPktzHead;
    DPRINTF(( "PKTZ State:" ));
    while( lpPktz )  {
        /* get layer name */
        lstrcpy( name, lpPktz->pk_lpNiPtrs->dllName );
        DPRINTF(( "  %Fp:\n"
                  "  name                 %Fs\n"
                  "  pk_connId            %Fp\n"
                  "  pk_state             %d\n"
                  "  pk_fControlPktNeeded %d\n"
                  "  pk_pktidNextToSend   %08lX\n"
                  "  pk_pktidNextToBuild  %08lX\n"
                  "  pk_lastPktStatus     %02X\n"
                  "  pk_lastPktRcvd       %08lX\n"
                  "  pk_lastPktOk         %08lX\n"
                  "  pk_lastPktOkOther    %08lX\n"
                  ,
            lpPktz,
            (LPSTR) name,
            lpPktz->pk_connId,
            lpPktz->pk_state,
            lpPktz->pk_fControlPktNeeded,
            lpPktz->pk_pktidNextToSend,
            lpPktz->pk_pktidNextToBuild,
            lpPktz->pk_lastPktStatus,
            lpPktz->pk_lastPktRcvd,
            lpPktz->pk_lastPktOk,
            lpPktz->pk_lastPktOkOther ));
        DPRINTF(( "    %08lX %ld \"%Fs\" \"%Fs\" %d %d %ld %ld %ld %ld %ld %ld",
            lpPktz->pk_pktidNextToRecv,
            lpPktz->pk_pktOffsInXmtMsg,
            lpPktz->pk_szDestName,
            lpPktz->pk_szAliasName,
            lpPktz->pk_pktSize,
            lpPktz->pk_maxUnackPkts,
            lpPktz->pk_timeoutRcvNegCmd,
            lpPktz->pk_timeoutRcvNegRsp,
            lpPktz->pk_timeoutMemoryPause,
            lpPktz->pk_timeoutKeepAlive,
            lpPktz->pk_timeoutXmtStuck,
            lpPktz->pk_timeoutSendRsp ));
        DPRINTF(( "    %d %d %d %d %d %ld %ld %Fp %Fp %Fp %Fp %Fp %Fp",
            lpPktz->pk_wMaxNoResponse,
            lpPktz->pk_wMaxXmtErr,
            lpPktz->pk_wMaxMemErr,
            lpPktz->pk_fDisconnect,
            lpPktz->pk_nDelay,
            lpPktz->pk_sent,
            lpPktz->pk_rcvd,
            lpPktz->pk_hTimerKeepalive,
            lpPktz->pk_hTimerXmtStuck,
            lpPktz->pk_hTimerRcvNegCmd,
            lpPktz->pk_hTimerRcvNegRsp,
            lpPktz->pk_hTimerMemoryPause,
            lpPktz->pk_hTimerCloseConnection ));
        DPRINTF(( "    %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %d",
            lpPktz->pk_pktUnackHead,
            lpPktz->pk_pktUnackTail,
            lpPktz->pk_pktFreeHead,
            lpPktz->pk_pktFreeTail,
            lpPktz->pk_ddePktHead,
            lpPktz->pk_ddePktTail,
            lpPktz->pk_prevPktz,
            lpPktz->pk_nextPktz,
            lpPktz->pk_prevPktzForNetintf,
            lpPktz->pk_nextPktzForNetintf,
            lpPktz->pk_hRouterHead,
            lpPktz->pk_hRouterExtraHead ));
        lpPktz = lpPktz->pk_nextPktz;
    }
}
#endif // DBG


#ifdef  _WINDOWS
VOID
PktzCloseAll( void )
{
    LPPKTZ      lpPktz;
    LPPKTZ      lpPktzNext;

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        lpPktzNext = lpPktz->pk_nextPktz;
        PktzClose( (HPKTZ) lpPktz );
        lpPktz = lpPktzNext;
    }
}

VOID
PktzCloseByName( LPSTR lpszName )
{
    LPPKTZ      lpPktz;
    LPPKTZ      lpPktzNext;

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        lpPktzNext = lpPktz->pk_nextPktz;
        if( lstrcmpi( lpPktz->pk_szDestName, lpszName ) == 0 )  {
            PktzClose( (HPKTZ) lpPktz );
            break;      /* while loop */
        }
        lpPktz = lpPktzNext;
    }
}

VOID FAR PASCAL NetddeEnumConnection( HWND hDlg, LPSTR lpszName );

VOID
PktzEnumConnections( HWND hDlg )
{
    LPPKTZ      lpPktz;

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        NetddeEnumConnection( hDlg, lpPktz->pk_szDestName );
        lpPktz = lpPktz->pk_nextPktz;
    }
}

BOOL
PktzAnyActiveForNetIntf( LPSTR lpszIntfName )
{
    LPPKTZ      lpPktz;

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        /* get layer name */
        if( lstrcmpi( lpPktz->pk_lpNiPtrs->dllName, lpszIntfName ) == 0 )  {
            return( TRUE );
        }
        lpPktz = lpPktz->pk_nextPktz;
    }
    return( FALSE );
}
#endif

#ifdef BYTE_SWAP
VOID
ConvertDdePkt( LPDDEPKT lpDdePkt )
{
    lpDdePkt->dp_size = HostToPcLong( lpDdePkt->dp_size );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\timer.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "TIMER.C;1  16-Dec-92,10:21:24  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include <time.h>

#include    "host.h"
#include    "windows.h"
#include    "netbasic.h"
#include    "timer.h"
#include    "debug.h"
#include    "internal.h"
#include    "wwassert.h"

#define NO_DEBUG_TIMERS
USES_ASSERT

#define TM_MAGIC 0x72732106

typedef struct s_timer {
    struct s_timer FAR  *tm_prev;
    struct s_timer FAR  *tm_next;
    long                 tm_magic;
    time_t               tm_expireTime;
    FP_TimerCallback     tm_timerCallback;
    DWORD_PTR            tm_dwUserInfo1;
    DWORD                tm_dwUserInfo2;
    DWORD_PTR            tm_dwUserInfo3;
} TIMER;
typedef TIMER FAR *LPTIMER;

#ifdef  DEBUG_TIMERS
VOID DebugTimerList( void );
#endif

/*
    Local variables
 */
LPTIMER         lpTimerHead = NULL;
LPTIMER         lpTimerTail = NULL;

#ifdef  DEBUG_TIMERS
static int  TimerLock = 0;
#endif


#ifdef  DEBUG_TIMERS
VOID
VerifyTimerList( void )
{
    LPTIMER     lpTimer;
    LPTIMER     lpTimerPrev, lpTimerNext;

    if( lpTimerHead )  {
        if (lpTimer = lpTimerHead->tm_prev) {
            DebugTimerList();
        }
        assert( lpTimerHead->tm_prev == NULL );
    } else {
        assert( lpTimerTail == NULL );
    }
    if( lpTimerTail )  {
        assert( lpTimerTail->tm_next == NULL );
    } else {
        assert( lpTimerHead == NULL );
    }

    lpTimer = lpTimerHead;
    lpTimerPrev = NULL;
    while( lpTimer )  {
        assert( lpTimer->tm_magic == TM_MAGIC );
        assert( lpTimerPrev == lpTimer->tm_prev );
        if( !lpTimer->tm_prev )  {
            assert( lpTimer == lpTimerHead );
        }
        if( !lpTimer->tm_next )  {
            assert( lpTimer == lpTimerTail );
        }
        lpTimerPrev = lpTimer;
        lpTimer = lpTimer->tm_next;
    }
    assert( lpTimerTail == lpTimerPrev );
}
#endif

#if DBG
#ifdef DEBUG_TIMERS
VOID DebugTimerList( void )
{
    LPTIMER     lpTimer;

    DPRINTF(( "Timer List @ %ld: ", time(NULL) ));
    if (!(lpTimer = lpTimerHead)) {
        return;
    }
    if (lpTimer->tm_prev) {
        DPRINTF(("Timer list going backwards from: %p!", lpTimer));
        lpTimer = lpTimer->tm_prev;
    while( lpTimer )  {
        DPRINTF(( "%08lX mg: %08X, pr:%08lX, nxt:%08lX, expTime:%ld %08lX %08lX %08lX",
            lpTimer, lpTimer->tm_magic,
            lpTimer->tm_prev, lpTimer->tm_next, lpTimer->tm_expireTime,
            lpTimer->tm_timerCallback, lpTimer->tm_dwUserInfo1,
            lpTimer->tm_dwUserInfo2, lpTimer->tm_dwUserInfo3 ));
        lpTimer = lpTimer->tm_prev;
    }
    lpTimer = lpTimerHead;
    DPRINTF(("Timer list now going forward starting at: %p.", lpTimer));
    }
    while( lpTimer )  {
        DPRINTF(( "%08lX mg: %08X, pr:%08lX, nxt:%08lX, expTime:%ld %08lX %08lX %08lX",
            lpTimer, lpTimer->tm_magic,
            lpTimer->tm_prev, lpTimer->tm_next, lpTimer->tm_expireTime,
            lpTimer->tm_timerCallback, lpTimer->tm_dwUserInfo1,
            lpTimer->tm_dwUserInfo2, lpTimer->tm_dwUserInfo3 ));
        lpTimer = lpTimer->tm_next;
    }
    DPRINTF(( "" ));
}
#endif // DEBUG_TIMERS
#endif // DBG

HTIMER
TimerSet(
    long                timeoutPeriod,          /* msec */
    FP_TimerCallback    TimerCallback,
    DWORD_PTR           dwUserInfo1,
    DWORD               dwUserInfo2,
    DWORD_PTR           dwUserInfo3 )
{
    LPTIMER     lpTimer;
    long        timeInSecs;

    timeInSecs = (timeoutPeriod + 999L ) / 1000L;

#ifdef  DEBUG_TIMERS
    assert( TimerLock++ == 0);
    VerifyTimerList();
#endif

    lpTimer = (LPTIMER) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        (DWORD) sizeof( TIMER ) );
    if( lpTimer )  {
        lpTimer->tm_magic               = TM_MAGIC;
        lpTimer->tm_prev                = lpTimerTail;
        lpTimer->tm_next                = NULL;
        lpTimer->tm_expireTime          = time(NULL) + timeInSecs;
        lpTimer->tm_timerCallback       = TimerCallback;
        lpTimer->tm_dwUserInfo1         = dwUserInfo1;
        lpTimer->tm_dwUserInfo2         = dwUserInfo2;
        lpTimer->tm_dwUserInfo3         = dwUserInfo3;

        if( lpTimerTail )  {
            lpTimerTail->tm_next = lpTimer;
        } else {
            lpTimerHead = lpTimer;
        }
        lpTimerTail = lpTimer;
#ifdef  DEBUG_TIMERS
        VerifyTimerList();
#endif
    }
#ifdef  DEBUG_TIMERS
    TimerLock--;
#endif
    return( (HTIMER) lpTimer );
}

BOOL
TimerDelete( HTIMER hTimer )
{
    LPTIMER     lpTimer;
    LPTIMER     lpTimerPrev;
    LPTIMER     lpTimerNext;

#ifdef  DEBUG_TIMERS
    assert( TimerLock++ == 0 );
#endif
    if( hTimer )  {
        lpTimer = (LPTIMER) hTimer;
#ifdef  DEBUG_TIMERS
        assert( lpTimer->tm_magic == TM_MAGIC );
        VerifyTimerList();
#endif
        /* delete from list */
        lpTimerPrev = lpTimer->tm_prev;
        lpTimerNext = lpTimer->tm_next;

        if( lpTimerPrev )  {
            lpTimerPrev->tm_next = lpTimerNext;
        } else {
            lpTimerHead = lpTimerNext;
        }
        if( lpTimerNext )  {
            lpTimerNext->tm_prev = lpTimerPrev;
        } else {
            lpTimerTail = lpTimerPrev;
        }
        lpTimer->tm_magic = 0;
        HeapFreePtr( lpTimer );
    }
#ifdef  DEBUG_TIMERS
    VerifyTimerList();
    TimerLock--;
#endif
    return( TRUE );
}

VOID
TimerSlice( void )
{
    LPTIMER     lpTimer;
    LPTIMER     lpTimerNext;
    LPTIMER     lpTimerPrev;
    time_t      timeNow;
    BOOL        bAnyTimersHit = TRUE;
	static time_t LastTime;

#ifdef  DEBUG_TIMERS
    VerifyTimerList();
#endif

    timeNow = time( NULL );

// the following is supposed to be an optimization: if we
// get called in the same second as the last call we exit
// without checking the whole list of timers with predictable
// results. Note that the static LastTime is uninitialized, so
// there is a 1 in 2^32 chance that we will erroneously drop
// the first call to TimerSlice();  clausgi 5-6-92

	if ( timeNow == LastTime )
		return;
	else
		LastTime = timeNow;
    while( bAnyTimersHit )  {
        bAnyTimersHit = FALSE;
        lpTimer = lpTimerHead;
        while( lpTimer && !bAnyTimersHit )  {
            assert( lpTimer->tm_magic == TM_MAGIC );
            lpTimerNext = lpTimer->tm_next;
            lpTimerPrev = lpTimer->tm_prev;
            if( timeNow >= lpTimer->tm_expireTime )  {
                (*lpTimer->tm_timerCallback)( lpTimer->tm_dwUserInfo1,
                    lpTimer->tm_dwUserInfo2, lpTimer->tm_dwUserInfo3 );
#ifdef  DEBUG_TIMERS
                DPRINTF(("TimerSlice return: %p<-%p->%p", lpTimerPrev, lpTimer, lpTimerNext));
#endif
                TimerDelete( (HTIMER) lpTimer );
#ifdef  DEBUG_TIMERS
                DPRINTF(("TimerHead: %p", lpTimerHead));
#endif

                /* since many timers may be deleted when we call this routine
                    we mark that we hit a timer and then we start over from
                    the beginning of the list
                 */
                bAnyTimersHit = TRUE;
            }
            lpTimer = lpTimerNext;
        }
    }
#ifdef  DEBUG_TIMERS
    VerifyTimerList();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\router.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "ROUTER.C;1  16-Dec-92,10:21:02  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#define NO_DEBUG
/*
    TODO
        - make sure we are freeing lpDdePkt properly on commands that are
            sent to the router.  Keep in mind that sometimes we use the
            incoming cmd to ensure that we have enough memory for it.
 */

#include    "host.h"
#ifdef _WINDOWS
#include    <memory.h>
#include    <stdio.h>
#endif
#include    <string.h>

#include    "windows.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "ddepkt.h"
#include    "pktz.h"
#include    "dder.h"
#include    "router.h"
#include    "internal.h"
#include    "wwassert.h"
#include    "hexdump.h"
#include    "host.h"
#include    "scrnupdt.h"
#include    "ddepkts.h"
#include    "security.h"
#include    "rerr.h"
#include    "timer.h"
#include    "nddemsg.h"
#include    "nddelog.h"

#ifdef _WINDOWS
#include    "nddeapi.h"
#include    "nddeapis.h"
#include    "winmsg.h"
#endif

#ifdef WIN32
#include    "api1632.h"
#endif

USES_ASSERT


/*
    States for router
 */
#define ROUTER_WAIT_PKTZ                        (1)
#define ROUTER_WAIT_MAKE_HOP_RSP                (2)
#define ROUTER_CONNECTED                        (3)
#define ROUTER_DISCONNECTED                     (4)

/*
    Types of routers
 */
#define RTYPE_LOCAL_NET         (1)
#define RTYPE_NET_NET           (2)

/*
    Router Commands
 */
#define RCMD_MAKE_HOP_CMD       (1)
#define RCMD_MAKE_HOP_RSP       (2)
#define RCMD_HOP_BROKEN         (3)
#define RCMD_ROUTE_TO_DDER      (4)


/*
    MAKE_HOP_CMD

        This is sent from the originating node to the next node along the
        chain.
 */
typedef struct {
    /* this is the DDE packet overhead */
    DDEPKT      mhc_ddePktHdr;

    /* this is the hRouter for the hop immediately preceding this hop */
    HROUTER     mhc_hRouterPrevHop;

    /* this is the number of hops processed.  This prevents circular routes
        from becoming infinite */
    short       mhc_nHopsLeft;

    /* this is the name of the node that started the whole chain of hops */
    short       mhc_offsNameOriginator;

    /* this is the final destination name that we are trying to get to */
    short       mhc_offsNameFinalDest;

    /* this is additional routing information passed on from the previous
        hop.  If ourNodeName == mhc_nameFinalDest, this should be empty. */
    short       mhc_offsAddlInfo;

    DWORD       mhc_pad1;
} MAKEHOPCMD;
typedef MAKEHOPCMD FAR *LPMAKEHOPCMD;

/*
    MAKE_HOP_RSP

        This is sent in response for each node along the path.
 */
typedef struct {
    /* this is the DDE packet overhead */
    DDEPKT      mhr_ddePktHdr;

    /* this is the router that is sending the response */
    HROUTER     mhr_hRouterSendingRsp;

    /* this is the router that the response is for */
    HROUTER     mhr_hRouterForRsp;

    /* this is the byte that tells of success(1) or failure(0) */
    WORD        mhr_success;

    /* this is an error message in case mhr_success == 0 */
    WORD        mhr_errCode;

    /* node name with error (only applicable if mhr_success == 0) */
    short       mhr_offsErrNode;
} MAKEHOPRSP;
typedef MAKEHOPRSP FAR *LPMAKEHOPRSP;

/*
    HOP_BROKEN_CMD

        This is sent when the connection is broken
 */
typedef struct {
    /* this is the DDE packet overhead */
    DDEPKT      hbc_ddePktHdr;

    /* this is the router that the response is for */
    HROUTER     hbc_hRouterForRsp;
} HOPBRKCMD;
typedef HOPBRKCMD FAR *LPHOPBRKCMD;

/*
    RTINFO
        Info for routing
 */
typedef struct {
    /* ri_hPktz: hPktz associated with this route */
    HPKTZ       ri_hPktz;

    /* ri_hRouterDest: hRouter on other side of connection */
    HROUTER     ri_hRouterDest;

    /* these 4 fields are links for associating router with packetizers */
    HROUTER     ri_hRouterPrev;
    WORD        ri_hRouterExtraPrev;
    HROUTER     ri_hRouterNext;
    WORD        ri_hRouterExtraNext;

    /* ri_lpHopBrkCmd: always have memory for hop broken cmd */
    LPHOPBRKCMD ri_lpHopBrkCmd;

    unsigned    ri_hopRspProcessed      : 1;
    unsigned    ri_hopBrokenSent        : 1;
    unsigned    ri_hopBrokenRcvd        : 1;
} RTINFO;
typedef RTINFO FAR *LPRTINFO;

/*
    ROUTER

        Structure per router.
 */
typedef struct s_router {
    /* prev/next for all routers */
    struct s_router FAR        *rt_prev;
    struct s_router FAR        *rt_next;

    /* rt_state */
    WORD                        rt_state;

    /* rt_type: one of RTYPE_LOCAL_NET or RTYPE_NET_NET */
    WORD                        rt_type;

    /* rt_destName: originating node name */
    char                        rt_origName[ MAX_NODE_NAME+1 ];

    /* rt_destName: destination node name */
    char                        rt_destName[ MAX_NODE_NAME+1 ];

    /* rt_startNode: starting node name for connect */
    char                        rt_startNode[ MAX_NODE_NAME+1 ];

    /* rt_sent,rt_rcvd: counts of packets */
    DWORD                       rt_sent;
    DWORD                       rt_rcvd;

    /* disconnect when not in use and what the delay should be */
    BOOL                        rt_fDisconnect; /* leave this BOOL!! */
    int                         rt_nDelay;
    BOOL                        rt_fSpecificNetintf;
    int                         rt_nLastNetintf;
    int                         rt_nHopsLeft;

    /* save some information for trying successive netintfs */
    BOOL                        rt_pktz_bDisconnect;
    int                         rt_pktz_nDelay;

    /* rt_routeInfo: addl info necessary for routing */
    char                        rt_routeInfo[ MAX_ROUTE_INFO+1 ];

    /* rt_rinfo: information for each of 2 possible connections */
    RTINFO                      rt_rinfo[ 2 ];

    /* rt_hDderHead: head of list of associated DDERs */
    HDDER                       rt_hDderHead;

    /* rt_lpMakeHopRsp: response for MakeHopCmd */
    LPMAKEHOPRSP                rt_lpMakeHopRsp;

    /* rt_hTimerClose: timer for closing this route */
    HTIMER                      rt_hTimerCloseRoute;
} ROUTER;
typedef ROUTER FAR *LPROUTER;

/*
    External variables used
 */
#if DBG
extern BOOL     bDebugInfo;
#endif // DBG
extern HHEAP    hHeap;
extern char     ourNodeName[ MAX_NODE_NAME+1 ];
extern BOOL     bDefaultRouteDisconnect;
extern int      nDefaultRouteDisconnectTime;
extern char     szDefaultRoute[];

/* Timer IDs */
#define TID_CLOSE_ROUTE                 1

/*
    Local variables
 */
static  LPROUTER        lpRouterHead;

/*
    Local routines
 */
VOID    RouterTimerExpired( HROUTER hRouter, DWORD dwTimerId, DWORD_PTR lpExtra );
BOOL    RouterStripStartingNode( LPSTR lpszAddlInfo, LPSTR lpszNode,
            WORD FAR *lpwHopErr );
VOID    RouterCloseBeforeConnected( LPROUTER lpRouter, WORD hRouterExtra );
VOID    RouterSendHopRsp( LPMAKEHOPRSP lpMakeHopRsp, HPKTZ hPktz,
         HROUTER hRouterSrc, HROUTER hRouterDest, BYTE bSucc,
         WORD wHopErr, LPSTR lpszErrNode );
VOID    RouterSendHopBroken( LPROUTER lpRouter, LPRTINFO lpRtInfo );
HROUTER RouterCreateLocalToNet( const LPSTR lpszNodeName );
VOID    RouterProcessHopCmd( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID    RouterProcessHopRsp( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID    RouterProcessHopBroken( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID    RouterProcessDderPacket( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
HROUTER RouterCreate( void );
VOID    RouterFree( LPROUTER lpRouter );
BOOL    RouterConnectToNode( LPROUTER lpRouter, WORD hRouterExtra,
            WORD FAR *lpwHopErr );
BOOL    RouterExpandFirstNode( LPROUTER lpRouter, WORD FAR *lpwHopErr );
#if	DBG
VOID    RouterDisplayError( LPROUTER lpRouter, LPSTR lpszNode, WORD wHopErr );
#endif // DBG
VOID    FAR PASCAL DebugRouterState( void );
#define GetLPSZFromOffset(lpptr,offs)   (((LPSTR)(lpptr))+offs)

#ifdef WIN32
HDDER FAR PASCAL DderFillInConnInfo( HDDER hDder, LPCONNENUM_CMR lpConnEnum,
              LPSTR lpDataStart, LPWORD lpcFromBeginning, LPWORD lpcFromEnd );
#endif

#ifndef WIN32
#ifdef _WINDOWS
int     RouterDraw( BOOL bShowThru, HDC hDC, int x, int vertPos, int lineHeight );
#pragma alloc_text(GUI_TEXT,RouterDraw,DebugRouterState)
#pragma alloc_text(GUI_TEXT,RouterCloseByName,RouterEnumConnections)
#endif
#endif

#ifdef  BYTE_SWAP
VOID     ConvertDdePkt( LPDDEPKT lpDdePkt );
#else
#define ConvertDdePkt(x)
#endif

HROUTER
RouterCreate( void )
{
    HROUTER     hRouter;
    LPROUTER    lpRouter;
    int         i;
    BOOL        ok;

    ok = TRUE;
    lpRouter = (LPROUTER) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        (DWORD)sizeof(ROUTER) );
    if( lpRouter )  {
        hRouter = (HROUTER) lpRouter;
        lpRouter->rt_prev               = NULL;
        lpRouter->rt_next               = NULL;
        lpRouter->rt_state              = 0;
        lpRouter->rt_type               = 0;
        lpRouter->rt_sent               = 0;
        lpRouter->rt_rcvd               = 0;
        lpRouter->rt_fDisconnect        = FALSE;
        lpRouter->rt_nDelay             = 0;
        lpRouter->rt_fSpecificNetintf   = FALSE;
        lpRouter->rt_nLastNetintf       = 0;
        lpRouter->rt_nHopsLeft          = 100;
        lpRouter->rt_origName[0]        = '\0';
        lpRouter->rt_startNode[0]       = '\0';
        lpRouter->rt_destName[0]        = '\0';
        lpRouter->rt_routeInfo[0]       = '\0';
        lpRouter->rt_hDderHead          = 0;
        lpRouter->rt_lpMakeHopRsp       = NULL;
        lpRouter->rt_hTimerCloseRoute   = 0;
        for( i=0; i<2; i++ )  {
            lpRouter->rt_rinfo[i].ri_hPktz              = 0;
            lpRouter->rt_rinfo[i].ri_hRouterDest        = 0;
            lpRouter->rt_rinfo[i].ri_hRouterPrev        = 0;
            lpRouter->rt_rinfo[i].ri_hRouterExtraPrev   = 0;
            lpRouter->rt_rinfo[i].ri_hRouterNext        = 0;
            lpRouter->rt_rinfo[i].ri_hRouterExtraNext   = 0;
            lpRouter->rt_rinfo[i].ri_hopRspProcessed    = FALSE;
            lpRouter->rt_rinfo[i].ri_hopBrokenSent      = FALSE;
            lpRouter->rt_rinfo[i].ri_hopBrokenRcvd      = FALSE;
            lpRouter->rt_rinfo[i].ri_lpHopBrkCmd        =
                (LPHOPBRKCMD) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                    (DWORD) sizeof(HOPBRKCMD) );
            if( lpRouter->rt_rinfo[i].ri_lpHopBrkCmd == NULL )  {
                ok = FALSE;
            }
        }

        lpRouter->rt_lpMakeHopRsp = (LPMAKEHOPRSP) HeapAllocPtr( hHeap,
            GMEM_MOVEABLE, (DWORD) sizeof(MAKEHOPRSP) + MAX_NODE_NAME + 1 );
        if( lpRouter->rt_lpMakeHopRsp == NULL )  {
            ok = FALSE;
        }
        if( ok )  {
            /* link into list of routers */
            if( lpRouterHead )  {
                lpRouterHead->rt_prev = lpRouter;
            }
            lpRouter->rt_next = lpRouterHead;
            lpRouterHead = lpRouter;
        }
        if( !ok )  {
            RouterFree( lpRouter );
            hRouter = (HROUTER) 0;
        }
    } else {
        hRouter = (HROUTER) 0;
    }
    return( hRouter );
}

VOID
RouterProcessHopCmd(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPMAKEHOPCMD        lpMakeHopCmd;
    BOOL                ok;
    HROUTER             hRouter;
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfo;
    LPSTR               lpszAddlInfo;
    LPSTR               lpszNameFinalDest;
    LPSTR               lpszNameOriginator;
    WORD                wHopErr;

    ok = TRUE;
    DIPRINTF(( "RouterProcessHopCmd( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpMakeHopCmd = (LPMAKEHOPCMD) lpDdePkt;
    lpMakeHopCmd->mhc_hRouterPrevHop =
        HostToPcLong( lpMakeHopCmd->mhc_hRouterPrevHop );
    lpMakeHopCmd->mhc_nHopsLeft =
        HostToPcWord( lpMakeHopCmd->mhc_nHopsLeft );
    lpMakeHopCmd->mhc_offsNameOriginator =
        HostToPcWord( lpMakeHopCmd->mhc_offsNameOriginator );
    lpMakeHopCmd->mhc_offsNameFinalDest =
        HostToPcWord( lpMakeHopCmd->mhc_offsNameFinalDest );
    lpMakeHopCmd->mhc_offsAddlInfo =
        HostToPcWord( lpMakeHopCmd->mhc_offsAddlInfo );

    lpszAddlInfo = GetLPSZFromOffset( lpMakeHopCmd,
        lpMakeHopCmd->mhc_offsAddlInfo );
    lpszNameFinalDest = GetLPSZFromOffset( lpMakeHopCmd,
        lpMakeHopCmd->mhc_offsNameFinalDest );
    lpszNameOriginator = GetLPSZFromOffset( lpMakeHopCmd,
        lpMakeHopCmd->mhc_offsNameOriginator );

    hRouter = RouterCreate();
    if( hRouter == 0 )  {
        ok = FALSE;
        wHopErr = RERR_NO_MEMORY;
    }

    if( ok )  {
        lpRouter = (LPROUTER) hRouter;

        /* do not disconnect routes that were created by other side */
        lpRouter->rt_fDisconnect = FALSE;

        lpRouter->rt_rcvd++;
        UpdateScreenStatistics();

        /* check if we are the final destination */
        if( lstrcmpi( ourNodeName, lpszNameFinalDest ) == 0 ) {
            DIPRINTF(( "We are final dest" ));
            /* we are the final destination */
            if( lpszAddlInfo[0] != '\0' )  {
                /* routeInfo should always be NULL if we are the final dest */
                wHopErr = RERR_ADDL_INFO;
                ok = FALSE;
            }
            if( ok )  {
                lpRouter->rt_type = RTYPE_LOCAL_NET;
                lpRouter->rt_state = ROUTER_CONNECTED;
                lstrcpy( lpRouter->rt_destName,
                    lpszNameOriginator );

                /* retrieve disconnect and delay information */
                GetRoutingInfo( lpRouter->rt_destName,
                    lpRouter->rt_routeInfo,
                    sizeof(lpRouter->rt_routeInfo),
                    &lpRouter->rt_fDisconnect, &lpRouter->rt_nDelay );
                UpdateScreenState();

                lpRtInfo = &lpRouter->rt_rinfo[ 0 ];
                lpRtInfo->ri_hPktz = hPktzFrom;
                lpRtInfo->ri_hRouterDest = lpMakeHopCmd->mhc_hRouterPrevHop;
                assert( lpRtInfo->ri_hRouterDest );

                /* associate us with this pktz */
                /* Note that this call will result in a call to
                    RouterConnectionComplete() */
                PktzAssociateRouter( hPktzFrom, hRouter, 0 );

                lpRtInfo->ri_hopRspProcessed = TRUE;

                /* tell the packetizer of the success */
                RouterSendHopRsp( lpRouter->rt_lpMakeHopRsp,
                    lpRtInfo->ri_hPktz,
                    (HROUTER) lpRouter,
                    lpRtInfo->ri_hRouterDest,
                    1 /* success */,
                    0 /* no err msg */,
                    (LPSTR) NULL );
                lpRouter->rt_lpMakeHopRsp = NULL;       /* just used it */
            }
        } else {
            DIPRINTF(( "We are NOT final dest, just hop along the way" ));
            /* we are not the final destination ... need more hops */
            if( lpszAddlInfo[0] == '\0' )  {
                /* should always have addl routing info if we're not the
                    final node */
                wHopErr = RERR_NO_ADDL_INFO;
                ok = FALSE;
            }
            if( --lpMakeHopCmd->mhc_nHopsLeft <= 0 )  {
                wHopErr = RERR_TOO_MANY_HOPS;
                ok = FALSE;
            }
            if( ok )  {
                lpRouter->rt_type = RTYPE_NET_NET;
                /* for net-net routers, we leave destName blank */
                lpRouter->rt_destName[0] = '\0';
                /* remember how many hops were left */
                lpRouter->rt_nHopsLeft = lpMakeHopCmd->mhc_nHopsLeft;
                lstrcpy( lpRouter->rt_origName, lpszNameOriginator );
                lstrcpy( lpRouter->rt_destName, lpszNameFinalDest );
                lstrcpy( lpRouter->rt_routeInfo,lpszAddlInfo );
                lpRtInfo = &lpRouter->rt_rinfo[ 0 ];
                lpRtInfo->ri_hPktz = hPktzFrom;
                lpRtInfo->ri_hRouterDest = lpMakeHopCmd->mhc_hRouterPrevHop;
                assert( lpRtInfo->ri_hRouterDest );

                /* associate us with this pktz */
                /* Note that this call will result in a call to
                    RouterConnectionComplete().  This is why we fool it
                    by saying we're connected, we ignore that call */
                lpRouter->rt_state = ROUTER_CONNECTED;
                PktzAssociateRouter( hPktzFrom, hRouter, 0 );
                lpRouter->rt_state = ROUTER_WAIT_PKTZ;
                UpdateScreenState();

                /* get us our pktz for the other side */
                ok = RouterConnectToNode( lpRouter, 1, &wHopErr );
            }
        }
    }

    if( ok )  {
        HeapFreePtr( lpDdePkt );
    } else {
        /* send back a failure response, using the incoming packet as memory
         */
        assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );
        RouterSendHopRsp( (LPMAKEHOPRSP)lpDdePkt,
            hPktzFrom,
            hRouter,
            lpMakeHopCmd->mhc_hRouterPrevHop,
            0 /* failure */,
            wHopErr,
            ourNodeName );

        if( hRouter )  {
            RouterFree( (LPROUTER) hRouter );
        }
    }
}

VOID
RouterProcessHopRsp(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPMAKEHOPRSP        lpMakeHopRsp;
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfo;

    DIPRINTF(( "RouterProcessHopRsp( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpMakeHopRsp = (LPMAKEHOPRSP) lpDdePkt;
    lpMakeHopRsp->mhr_hRouterSendingRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterSendingRsp );
    lpMakeHopRsp->mhr_hRouterForRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterForRsp );
    lpMakeHopRsp->mhr_success =
        HostToPcWord( lpMakeHopRsp->mhr_success );
    lpMakeHopRsp->mhr_errCode =
        HostToPcWord( lpMakeHopRsp->mhr_errCode );
    lpMakeHopRsp->mhr_offsErrNode =
        HostToPcWord( lpMakeHopRsp->mhr_offsErrNode );

    assert( lpMakeHopRsp->mhr_hRouterForRsp );
    lpRouter = (LPROUTER) lpMakeHopRsp->mhr_hRouterForRsp;

    lpRouter->rt_rcvd++;
    UpdateScreenStatistics();

    if( lpMakeHopRsp->mhr_success )  {
        /* hop was successful! */
        assert( lpMakeHopRsp->mhr_hRouterSendingRsp != 0 );
        assert( lpRouter->rt_state == ROUTER_WAIT_MAKE_HOP_RSP );

        /* note that we are connected */
        lpRouter->rt_state = ROUTER_CONNECTED;
        UpdateScreenState();
        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            /* local-net connection */
            lpRtInfo = &lpRouter->rt_rinfo[0];
            lpRtInfo->ri_hopRspProcessed = TRUE;
            assert( lpRtInfo->ri_hPktz == hPktzFrom );
            /* remember the router */
            lpRtInfo->ri_hRouterDest = lpMakeHopRsp->mhr_hRouterSendingRsp;
            assert( lpRtInfo->ri_hRouterDest );

            /* tell all the associated DDERs */
            DderConnectionComplete( lpRouter->rt_hDderHead,
                (HROUTER)lpRouter );

            /* free the packet */
            HeapFreePtr( lpDdePkt );
        } else {
            assert( lpRouter->rt_type == RTYPE_NET_NET );
            /* net-net connection */
            lpRtInfo = &lpRouter->rt_rinfo[1];
            lpRtInfo->ri_hopRspProcessed = TRUE;
            assert( lpRtInfo->ri_hPktz == hPktzFrom );
            /* remember the router */
            lpRtInfo->ri_hRouterDest = lpMakeHopRsp->mhr_hRouterSendingRsp;
            assert( lpRtInfo->ri_hRouterDest );

            /* send back a success response using incoming */
            lpRouter->rt_rinfo[0].ri_hopRspProcessed = TRUE;
            assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );
            RouterSendHopRsp( (LPMAKEHOPRSP)lpDdePkt,
                lpRouter->rt_rinfo[0].ri_hPktz,
                (HROUTER) lpRouter,
                lpRouter->rt_rinfo[0].ri_hRouterDest,
                1 /* success */,
                0 /* no err msg */,
                (LPSTR) NULL );
        }
    } else {
        /* hop connection failed! */
        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            /* notify all DDERs of problem */
#if DBG
            RouterDisplayError( lpRouter, GetLPSZFromOffset( lpMakeHopRsp,
                    lpMakeHopRsp->mhr_offsErrNode ), lpMakeHopRsp->mhr_errCode );
#endif // DBG
            DderConnectionBroken( lpRouter->rt_hDderHead );

            /* free the packet */
            HeapFreePtr( lpDdePkt );
        } else {
            assert( lpRouter->rt_type == RTYPE_NET_NET );
            /* send back a failure response, using the incoming packet
                as memory */
            lpRouter->rt_rinfo[0].ri_hopRspProcessed = TRUE;
            assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );
            RouterSendHopRsp( (LPMAKEHOPRSP)lpDdePkt,
                lpRouter->rt_rinfo[0].ri_hPktz,
                (HROUTER) NULL,
                lpRouter->rt_rinfo[0].ri_hRouterDest,
                0 /* failure */,
                lpMakeHopRsp->mhr_errCode,
                GetLPSZFromOffset( lpMakeHopRsp,
                    lpMakeHopRsp->mhr_offsErrNode ) );
        }

        /* free the router */
        RouterFree( lpRouter );
    }
}

VOID
RouterProcessHopBroken(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPROUTER            lpRouter;
    LPHOPBRKCMD         lpHopBrkCmd;

    DIPRINTF(( "RouterProcessHopBroken( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpHopBrkCmd = (LPHOPBRKCMD) lpDdePkt;
    lpHopBrkCmd->hbc_hRouterForRsp =
        HostToPcLong( lpHopBrkCmd->hbc_hRouterForRsp );
    DIPRINTF(( "RouterForRsp:    \"%08lX\"", lpHopBrkCmd->hbc_hRouterForRsp ));

    if( lpHopBrkCmd->hbc_hRouterForRsp == 0 )  {
        /*  Unexpectedly got a NULL router in ProcessHopBroken! */
        NDDELogError(MSG124, NULL);
        return;
    }

    lpRouter = (LPROUTER) lpHopBrkCmd->hbc_hRouterForRsp;

    lpRouter->rt_rcvd++;
    UpdateScreenStatistics();

    /* hop connection failed! */
    if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
        assert( lpRouter->rt_rinfo[0].ri_hPktz == hPktzFrom );
        RouterConnectionBroken( (HROUTER) lpRouter, 0, hPktzFrom,
            FALSE /* not from PKTZ */ );
    } else {
        if( lpRouter->rt_rinfo[0].ri_hPktz == hPktzFrom )  {
            RouterConnectionBroken( (HROUTER) lpRouter, 0, hPktzFrom,
                FALSE /* not from PKTZ */ );
        } else {
            assert( lpRouter->rt_rinfo[1].ri_hPktz == hPktzFrom );
            RouterConnectionBroken( (HROUTER) lpRouter, 1, hPktzFrom,
                FALSE /* not from PKTZ */ );
        }
    }

    /* free the packet */
    HeapFreePtr( lpDdePkt );
}

VOID
RouterProcessDderPacket(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfoXfer;

    DIPRINTF(( "RouterProcessDderPacket( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpRouter = (LPROUTER) lpDdePkt->dp_hDstRouter;
    assert( lpRouter );

    lpRouter->rt_rcvd++;
    UpdateScreenStatistics();

    if( lpRouter->rt_state == ROUTER_CONNECTED )  {
        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            DderPacketFromRouter( (HROUTER)lpRouter, lpDdePkt );
        } else {
            if( lpRouter->rt_rinfo[0].ri_hPktz == hPktzFrom )  {
                lpRtInfoXfer = &lpRouter->rt_rinfo[1];
            } else {
                assert( lpRouter->rt_rinfo[1].ri_hPktz == hPktzFrom );
                lpRtInfoXfer = &lpRouter->rt_rinfo[0];
            }

            /* modify the router for the next node */
            lpDdePkt->dp_hDstRouter = lpRtInfoXfer->ri_hRouterDest;
            assert( lpDdePkt->dp_hDstRouter );

            lpRouter->rt_sent++;
            UpdateScreenStatistics();

            /* byte-ordering */
            ConvertDdePkt( lpDdePkt );

            /* actually xmit the packet */
            if( lpRtInfoXfer->ri_hPktz )  {
                PktzLinkDdePktToXmit( lpRtInfoXfer->ri_hPktz, lpDdePkt );
            } else {
                /* link not around ... just dump it */
                HeapFreePtr( lpDdePkt );
            }
        }
    } else {
        /* destroy message */
        HeapFreePtr( lpDdePkt );
    }
}

VOID
RouterPacketFromNet(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    DIPRINTF(( "RouterPacketFromNet( hPktz:%08lX, %08lX )", hPktzFrom, lpDdePkt ));
    /* byte-ordering */
    ConvertDdePkt( lpDdePkt );

    switch( lpDdePkt->dp_routerCmd )  {
    case RCMD_MAKE_HOP_CMD:
        assert( lpDdePkt->dp_hDstRouter == 0 );
        RouterProcessHopCmd( hPktzFrom, lpDdePkt );
        break;
    case RCMD_MAKE_HOP_RSP:
        RouterProcessHopRsp( hPktzFrom, lpDdePkt );
        break;
    case RCMD_HOP_BROKEN:
        RouterProcessHopBroken( hPktzFrom, lpDdePkt );
        break;
    case RCMD_ROUTE_TO_DDER:
        RouterProcessDderPacket( hPktzFrom, lpDdePkt );
        break;
    default:
        InternalError( "Router got unknown cmd %08lX from net",
            (DWORD) lpDdePkt->dp_routerCmd );
    }
}


/*
    RouterConnectionComplete()

        Called by PKTZ layer when the physical connection has been determined.
 */
VOID
RouterConnectionComplete(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HPKTZ   hPktz )
{
    LPROUTER            lpRouter;
    HROUTER             hRouterNext;
    HPKTZ               hPktzDisallow;
    DWORD               dwSize;
    WORD                hRouterExtraNext;
    LPMAKEHOPCMD        lpMakeHopCmd;
    LPDDEPKT            lpDdePkt;
    BOOL                ok;
    WORD                wHopErr;
    LPNIPTRS            lpNiPtrs;
    LPSTR               lpsz;
    WORD                offs;

    DIPRINTF(( "RouterConnectionComplete( %08lX, %04X, %08lX )",
            hRouter, hRouterExtra, hPktz ));

    if( hRouter == 0 )  {
        return;
    }
    lpRouter = (LPROUTER) hRouter;
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    /* remember next router to notify */
    hRouterNext = lpRouter->rt_rinfo[ hRouterExtra ].ri_hRouterNext;
    hRouterExtraNext = lpRouter->rt_rinfo[ hRouterExtra ].ri_hRouterExtraNext;

    /* only care about this if we are waiting for a pktz and haven't
        already got notified of this completion.
     */
    if( (lpRouter->rt_state == ROUTER_WAIT_PKTZ)
        && (lpRouter->rt_rinfo[ hRouterExtra ].ri_hPktz == 0) )  {

        /* save hPktz for future use */
        lpRouter->rt_rinfo[ hRouterExtra ].ri_hPktz = hPktz;

        DIPRINTF(( " Router %08lX waiting for pktz", lpRouter ));
        if( hPktz == 0 )  {
            /* physical connection failed */
            ok = FALSE;
            if( !lpRouter->rt_fSpecificNetintf )  {
                while (!ok) { /* try the next network interface */
                    if (!GetNextMappingNetIntf( &lpNiPtrs,
                        &lpRouter->rt_nLastNetintf ))
                            break;
                        if( hRouterExtra == 1 )  {
                    /* don't allow connection to same pktz as the input */
                            assert( lpRouter->rt_type == RTYPE_NET_NET );
                            hPktzDisallow = lpRouter->rt_rinfo[0].ri_hPktz;
                        } else {
                            hPktzDisallow = (HPKTZ) 0;
                        }
                ok = PktzGetPktzForRouter( lpNiPtrs, lpRouter->rt_startNode,
                            lpRouter->rt_startNode, hRouter, hRouterExtra, &wHopErr,
                            lpRouter->rt_pktz_bDisconnect, lpRouter->rt_pktz_nDelay,
                            hPktzDisallow );
            }
        }
            if( !ok )  {
                RouterCloseBeforeConnected( lpRouter, hRouterExtra );
            }
        } else {
            /* physical connection established OK */

            /* create a hop cmd */
            dwSize = sizeof(MAKEHOPCMD)
                + lstrlen(lpRouter->rt_origName) + 1
                + lstrlen(lpRouter->rt_destName ) + 1
                + lstrlen(lpRouter->rt_routeInfo ) + 1;
            lpMakeHopCmd = HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize );
            if( lpMakeHopCmd )  {
                lpDdePkt = &lpMakeHopCmd->mhc_ddePktHdr;
                lpDdePkt->dp_size = dwSize;
                lpDdePkt->dp_prev = NULL;
                lpDdePkt->dp_next = NULL;
                lpDdePkt->dp_hDstDder = 0;
                lpDdePkt->dp_hDstRouter = 0;
                lpDdePkt->dp_routerCmd = RCMD_MAKE_HOP_CMD;
                offs = sizeof(MAKEHOPCMD);

                lpsz = ((LPSTR)lpMakeHopCmd)+offs;
                lpMakeHopCmd->mhc_offsNameOriginator = offs;
                lstrcpy( lpsz, lpRouter->rt_origName);
                offs += lstrlen(lpsz)+1;

                lpsz = ((LPSTR)lpMakeHopCmd)+offs;
                lpMakeHopCmd->mhc_offsNameFinalDest = offs;
                lstrcpy( lpsz, lpRouter->rt_destName );
                offs += lstrlen(lpsz)+1;

                lpsz = ((LPSTR)lpMakeHopCmd)+offs;
                lpMakeHopCmd->mhc_offsAddlInfo = offs;
                lstrcpy( lpsz, lpRouter->rt_routeInfo );
                offs += lstrlen(lpsz)+1;

                lpMakeHopCmd->mhc_nHopsLeft = (short) lpRouter->rt_nHopsLeft;

                lpMakeHopCmd->mhc_hRouterPrevHop =
                    HostToPcLong( (HROUTER) lpRouter );
                lpMakeHopCmd->mhc_nHopsLeft =
                    HostToPcWord( lpMakeHopCmd->mhc_nHopsLeft );
                lpMakeHopCmd->mhc_offsNameOriginator =
                    HostToPcWord( lpMakeHopCmd->mhc_offsNameOriginator );
                lpMakeHopCmd->mhc_offsNameFinalDest =
                    HostToPcWord( lpMakeHopCmd->mhc_offsNameFinalDest );
                lpMakeHopCmd->mhc_offsAddlInfo =
                    HostToPcWord( lpMakeHopCmd->mhc_offsAddlInfo );

                /* set our new state */
                lpRouter->rt_state = ROUTER_WAIT_MAKE_HOP_RSP;
                UpdateScreenState();

                DIPRINTF(( "Sending make hop cmd" ));
                /* actually xmit the packet */
                lpRouter->rt_sent++;
                UpdateScreenStatistics();
                /* byte-ordering */
                ConvertDdePkt( lpDdePkt );
                PktzLinkDdePktToXmit( hPktz, lpDdePkt );
            } else {
                /* no memory for next hop cmd ... fail this hop */
                RouterCloseBeforeConnected( lpRouter, hRouterExtra );
            }
        }
    }

    if( hRouterNext )  {
        RouterConnectionComplete( hRouterNext, hRouterExtraNext, hPktz );
    }
}

VOID
RouterCloseBeforeConnected(
    LPROUTER    lpRouter,
    WORD        hRouterExtra )
{
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
        /* local->net */

        /* tell all DDERs of failure */
        DderConnectionComplete( lpRouter->rt_hDderHead, (HROUTER) NULL );

#if DBG
        RouterDisplayError( lpRouter, ourNodeName,
            RERR_NEXT_NODE_CONN_FAILED );
#endif // DBG
        /* close us */
        RouterFree( lpRouter );
    } else {
        /* net->net */

        /* send back NACK response to other net */
        assert( lpRouter->rt_lpMakeHopRsp );
        lpRouter->rt_rinfo[ !hRouterExtra ].ri_hopRspProcessed = TRUE;
        RouterSendHopRsp( lpRouter->rt_lpMakeHopRsp,
            lpRouter->rt_rinfo[ !hRouterExtra ].ri_hPktz,
            (HROUTER) lpRouter,
            lpRouter->rt_rinfo[ !hRouterExtra ].ri_hRouterDest,
            0 /* failure */,
            RERR_NEXT_NODE_CONN_FAILED,
            ourNodeName );
        lpRouter->rt_lpMakeHopRsp = NULL;       /* just sent it */

        /* close us */
        RouterFree( lpRouter );
    }
}

VOID
RouterSendHopRsp(
    LPMAKEHOPRSP    lpMakeHopRsp,
    HPKTZ           hPktz,
    HROUTER         hRouterSrc,
    HROUTER         hRouterDest,
    BYTE            bSucc,
    WORD            wHopErr,
    LPSTR           lpszErrNode )
{
    LPDDEPKT            lpDdePkt;
    LPSTR               lpsz;
    DWORD               dwSize;

    assert( lpMakeHopRsp );
    lpDdePkt = &lpMakeHopRsp->mhr_ddePktHdr;
    if( lpszErrNode )  {
        dwSize = sizeof(MAKEHOPRSP) + lstrlen(lpszErrNode) + 1;
    } else {
        dwSize = sizeof(MAKEHOPRSP) + 1;
    }
    lpDdePkt->dp_size = dwSize;
    lpDdePkt->dp_prev = NULL;
    lpDdePkt->dp_next = NULL;
    lpDdePkt->dp_hDstDder = 0;
    lpDdePkt->dp_hDstRouter = hRouterDest;
    lpDdePkt->dp_routerCmd = RCMD_MAKE_HOP_RSP;
    lpMakeHopRsp->mhr_hRouterSendingRsp = hRouterSrc;
    lpMakeHopRsp->mhr_hRouterForRsp = hRouterDest;
    lpMakeHopRsp->mhr_success = bSucc;
    lpMakeHopRsp->mhr_errCode = wHopErr;
    lpMakeHopRsp->mhr_offsErrNode = sizeof(MAKEHOPRSP);
    lpsz = GetLPSZFromOffset(lpMakeHopRsp,sizeof(MAKEHOPRSP));
    if( lpszErrNode )  {
        lstrcpy( lpsz, lpszErrNode );
    } else {
        lpsz[0] = '\0';
    }

    lpMakeHopRsp->mhr_hRouterSendingRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterSendingRsp );
    lpMakeHopRsp->mhr_hRouterForRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterForRsp );
    lpMakeHopRsp->mhr_success =
        HostToPcWord( lpMakeHopRsp->mhr_success );
    lpMakeHopRsp->mhr_errCode =
        HostToPcWord( lpMakeHopRsp->mhr_errCode );
    lpMakeHopRsp->mhr_offsErrNode =
        HostToPcWord( lpMakeHopRsp->mhr_offsErrNode );

    /* actually xmit the packet */
    if( hRouterSrc )  {
        ((LPROUTER)hRouterSrc)->rt_sent++;
        UpdateScreenStatistics();
    }

    /* byte-ordering */
    ConvertDdePkt( lpDdePkt );

    PktzLinkDdePktToXmit( hPktz, lpDdePkt );
}

VOID
RouterSendHopBroken(
    LPROUTER    lpRouter,
    LPRTINFO    lpRtInfo )
{
    LPHOPBRKCMD         lpHopBrkCmd;
    LPDDEPKT            lpDdePkt;

    lpHopBrkCmd = lpRtInfo->ri_lpHopBrkCmd;
    assert( lpHopBrkCmd );
    /* set to NULL to avoid being deleted twice */
    lpRtInfo->ri_lpHopBrkCmd = NULL;
    assert( lpHopBrkCmd );
    lpDdePkt = &lpHopBrkCmd->hbc_ddePktHdr;
    lpDdePkt->dp_size = sizeof(HOPBRKCMD);
    lpDdePkt->dp_prev = NULL;
    lpDdePkt->dp_next = NULL;
    lpDdePkt->dp_hDstDder = 0;
    lpDdePkt->dp_hDstRouter = lpRtInfo->ri_hRouterDest;
    assert( lpRtInfo->ri_hRouterDest );
    lpDdePkt->dp_routerCmd = RCMD_HOP_BROKEN;
    lpHopBrkCmd->hbc_hRouterForRsp = HostToPcLong(lpRtInfo->ri_hRouterDest);
    DIPRINTF(( "Sending hop broken to %08lX", lpHopBrkCmd->hbc_hRouterForRsp ));
    assert( lpHopBrkCmd->hbc_hRouterForRsp );

    lpRouter->rt_sent++;
    UpdateScreenStatistics();

    /* byte-ordering */
    ConvertDdePkt( lpDdePkt );

    /* actually xmit the packet */
    assert( lpRtInfo->ri_hPktz );
    PktzLinkDdePktToXmit( lpRtInfo->ri_hPktz, lpDdePkt );
}

/*
    RouterBreak() causes the connection of a local-net to be broken
 */
VOID
RouterBreak( LPROUTER lpRouter )
{
    LPRTINFO            lpRtInfoToClose;

    assert( lpRouter );
    lpRouter->rt_state = ROUTER_DISCONNECTED;
    UpdateScreenState();
    lpRtInfoToClose = &lpRouter->rt_rinfo[ 0 ];

    /* send a broken cmd
     */
    if( lpRtInfoToClose->ri_hPktz )  {
        if( !lpRtInfoToClose->ri_hopBrokenSent )  {
            if( lpRtInfoToClose->ri_hRouterDest )  {
                RouterSendHopBroken( lpRouter, lpRtInfoToClose );
                lpRtInfoToClose->ri_hopBrokenSent = TRUE;
            } else {
                /* no route established - pretend we rcvd and sent */
                lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
                lpRtInfoToClose->ri_hopBrokenSent = TRUE;
            }
        }
    } else {
        /* both sides rcvd hop broken */
        lpRtInfoToClose->ri_hopBrokenSent = TRUE;
        lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
    }

    /* free the router if we've rcvd other side */
    if( lpRtInfoToClose->ri_hopBrokenSent
        && lpRtInfoToClose->ri_hopBrokenRcvd )  {
        /* free the router */
        RouterFree( lpRouter );
    }
}

/*
    Called by PKTZ as well as internally when the connection has been
        broken.  When called by PKTZ, this means that we should no longer
        talk to that PKTZ.  If called internally, we should unlink ourselves
        from the pktz list.
 */
VOID
RouterConnectionBroken(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HPKTZ   hPktz,
    BOOL    bFromPktz )
{
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfoClosed;
    LPRTINFO            lpRtInfoToClose;
    HROUTER             hRouterNext;
    WORD                hRouterExtraNext;

    DIPRINTF(( "RouterConnectionBroken( %08lX, %04X, %08lX, %d )",
            hRouter, hRouterExtra, hPktz, bFromPktz ));
    if( hRouter == 0 )  {
        assert( bFromPktz );
        return;
    }
    lpRouter = (LPROUTER) hRouter;
#if DBG
    if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
        && (lpRouter->rt_state == ROUTER_WAIT_PKTZ) )  {

        /* show the error message */
        RouterDisplayError( lpRouter, ourNodeName,
            RERR_NEXT_NODE_CONN_FAILED );
    }
#endif // DBG

    lpRouter->rt_state = ROUTER_DISCONNECTED;
    UpdateScreenState();

    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRtInfoClosed = &lpRouter->rt_rinfo[ hRouterExtra ];
    lpRtInfoToClose = &lpRouter->rt_rinfo[ !hRouterExtra ];

    /* remember next router to notify */
    hRouterNext = lpRtInfoClosed->ri_hRouterNext;
    hRouterExtraNext = lpRtInfoClosed->ri_hRouterExtraNext;

    if( bFromPktz )  {
        /* note that we shouldn't talk to this hPktz */
        lpRtInfoClosed->ri_hPktz = 0;
        lpRtInfoClosed->ri_hRouterPrev = 0;
        lpRtInfoClosed->ri_hRouterExtraPrev = 0;
        lpRtInfoClosed->ri_hRouterNext = 0;
        lpRtInfoClosed->ri_hRouterExtraNext = 0;
        lpRtInfoClosed->ri_hopBrokenSent = TRUE;
        lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;
    } else {
        /* note that we rcvd the hop broken */
        lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;

        /* check if we already sent hop broken */
        if( !lpRtInfoClosed->ri_hopBrokenSent )  {
            /* send the hop broken back to the other side so he can close */
            if( lpRtInfoClosed->ri_hRouterDest )  {
                RouterSendHopBroken( lpRouter, lpRtInfoClosed );
                lpRtInfoClosed->ri_hopBrokenSent = TRUE;
                if( !lpRtInfoClosed->ri_hopRspProcessed )  {
                    /* we won't be hearing from this node if we never
                        sent the hop rsp
                     */
                    lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;
                }
            } else {
                /* no route established - pretend we sent/rcvd */
                lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;
                lpRtInfoClosed->ri_hopBrokenSent = TRUE;
            }
        }
    }


    if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
        /* notify all DDERs of problem */
        DderConnectionBroken( lpRouter->rt_hDderHead );

        /* free the router */
        RouterFree( lpRouter );
    } else {
        /* send back a broken cmd
         */
        if( lpRtInfoToClose->ri_hPktz )  {
            if( !lpRtInfoToClose->ri_hopBrokenSent )  {
                if( lpRtInfoToClose->ri_hRouterDest )  {
                    RouterSendHopBroken( lpRouter, lpRtInfoToClose );
                    lpRtInfoToClose->ri_hopBrokenSent = TRUE;
                    if( !lpRtInfoToClose->ri_hopRspProcessed )  {
                        /* we won't be hearing from this node if we never
                            sent the hop rsp
                         */
                        lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
                    }
                } else {
                    /* no route established - pretend we sent/rcvd */
                    lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
                    lpRtInfoToClose->ri_hopBrokenSent = TRUE;
                }
            }
        } else {
            /* both sides rcvd hop broken */
            lpRtInfoToClose->ri_hopBrokenSent = TRUE;
            lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
        }

        /* free the router if we've rcvd other side */
        if( lpRtInfoToClose->ri_hopBrokenSent
            && lpRtInfoToClose->ri_hopBrokenRcvd )  {
            /* free the router */
            RouterFree( lpRouter );
        }
    }

    if( hRouterNext && bFromPktz )  {
        RouterConnectionBroken( hRouterNext, hRouterExtraNext,
            hPktz, bFromPktz );
    }
}

VOID
RouterGetNextForPktz(
    HROUTER         hRouter,
    WORD            hRouterExtra,
    HROUTER FAR    *lphRouterNext,
    WORD FAR       *lphRouterExtraNext )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    *lphRouterNext = lpRtInfo->ri_hRouterNext;
    *lphRouterExtraNext = lpRtInfo->ri_hRouterExtraNext;
}

VOID
RouterGetPrevForPktz(   HROUTER hRouter,
                        WORD hRouterExtra,
                        HROUTER FAR *lphRouterPrev,
                        WORD FAR *lphRouterExtraPrev )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    *lphRouterPrev = lpRtInfo->ri_hRouterPrev;
    *lphRouterExtraPrev = lpRtInfo->ri_hRouterExtraPrev;
}

VOID
RouterSetNextForPktz(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HROUTER hRouterNext,
    WORD    hRouterExtraNext )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    lpRtInfo->ri_hRouterNext            = hRouterNext;
    lpRtInfo->ri_hRouterExtraNext       = hRouterExtraNext;
}

VOID
RouterSetPrevForPktz(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HROUTER hRouterPrev,
    WORD    hRouterExtraPrev )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    lpRtInfo->ri_hRouterPrev            = hRouterPrev;
    lpRtInfo->ri_hRouterExtraPrev       = hRouterExtraPrev;
}

VOID
RouterPacketFromDder(
    HROUTER     hRouter,
    HDDER       hDder,
    LPDDEPKT    lpDdePkt )
{
    LPROUTER    lpRouter;
    DIPRINTF(( "RouterPacketFromDder( %08lX, %08lX, %08lX )", hRouter, hDder, lpDdePkt ));

    lpRouter = (LPROUTER) hRouter;

    /* ignore packet if not connected */
    if( lpRouter->rt_state == ROUTER_CONNECTED )  {
        assert( lpRouter->rt_type == RTYPE_LOCAL_NET );
        lpDdePkt->dp_hDstRouter = lpRouter->rt_rinfo[0].ri_hRouterDest;
        assert( lpRouter->rt_rinfo[0].ri_hRouterDest );
        lpDdePkt->dp_routerCmd = RCMD_ROUTE_TO_DDER;

        DIPRINTF(( "Sending DDER cmd" ));
        lpRouter->rt_sent++;
        UpdateScreenStatistics();

        /* byte-ordering */
        ConvertDdePkt( lpDdePkt );

        /* actually xmit the packet */
        PktzLinkDdePktToXmit( lpRouter->rt_rinfo[0].ri_hPktz, lpDdePkt );
    } else {
        /* we aren't connected - destroy this msg */
        HeapFreePtr( lpDdePkt );
    }
}

VOID
RouterAssociateDder(
    HROUTER hRouter,
    HDDER   hDder )
{
    LPROUTER    lpRouter;

    DIPRINTF(( "RouterAssociateDder( %08lX, %08lX )", hRouter, hDder ));
    lpRouter = (LPROUTER) hRouter;
    if( hDder )  {
        if((lpRouter->rt_hDderHead == 0) && lpRouter->rt_hTimerCloseRoute){
            /* kill the timer for this route */
            TimerDelete( lpRouter->rt_hTimerCloseRoute );
            lpRouter->rt_hTimerCloseRoute = 0;
        }

        /* link into list of associated DDERs */
        if( lpRouter->rt_hDderHead )  {
            DderSetPrevForRouter( lpRouter->rt_hDderHead, hDder );
        }
        DderSetNextForRouter( hDder, lpRouter->rt_hDderHead );
        lpRouter->rt_hDderHead = hDder;

        switch( lpRouter->rt_state )  {
        case ROUTER_CONNECTED:
            /* already has connection set up */
            DderConnectionComplete( hDder, (HROUTER) lpRouter );
            break;
        }
    }
}

VOID
RouterDisassociateDder(
    HROUTER hRouter,
    HDDER   hDder )
{
    LPROUTER    lpRouter;
    HDDER       hDderPrev;
    HDDER       hDderNext;

    DIPRINTF(( "RouterDisassociateDder( %08lX, %08lX )", hRouter, hDder ));
    lpRouter = (LPROUTER) hRouter;
    DderGetNextForRouter( hDder, &hDderNext );
    DderGetPrevForRouter( hDder, &hDderPrev );
    if( hDderPrev )  {
        DderSetNextForRouter( hDderPrev, hDderNext );
    } else {
        lpRouter->rt_hDderHead = hDderNext;
    }
    if( hDderNext )  {
        DderSetPrevForRouter( hDderNext, hDderPrev );
    }
    if( lpRouter->rt_fDisconnect
        && (lpRouter->rt_type == RTYPE_LOCAL_NET)
        && (lpRouter->rt_hDderHead == 0) )  {
        lpRouter->rt_hTimerCloseRoute = TimerSet(
            lpRouter->rt_nDelay * 1000L, RouterTimerExpired,
            (DWORD_PTR)lpRouter, TID_CLOSE_ROUTE, (DWORD_PTR)NULL );
        if( lpRouter->rt_hTimerCloseRoute == (HTIMER) NULL )  {
            /*  %1 will not auto-close ... not enough timers    */
            NDDELogError(MSG105, "Route", NULL);
        }
    }
}

VOID
RouterTimerExpired(
    HROUTER hRouter,
    DWORD   dwTimerId,
    DWORD_PTR lpExtra )
{
    LPROUTER    lpRouter = (LPROUTER) hRouter;
    switch( (int)dwTimerId )  {
    case TID_CLOSE_ROUTE:
        /* note that timer went off */
        lpRouter->rt_hTimerCloseRoute = 0;

        /* close the route */
        RouterBreak( (LPROUTER) hRouter );
        break;
    default:
        InternalError( "Unexpected router timer id: %08lX", dwTimerId );
    }
}

/*
    RouterGetRouterForDder()

        Establishes a connection to the specified node name and tells the DDER
        of the result via a call to DderConnectionComplete() when done
 */
BOOL
RouterGetRouterForDder(
    const LPSTR lpszNodeName,
    HDDER       hDder )
{
    LPROUTER    lpRouter;
    HROUTER     hRouter;
    BOOL        found;
    BOOL        ok;

    lpRouter = lpRouterHead;
    found = FALSE;
    ok = FALSE;
    while( !found && lpRouter )  {
        if( (lpRouter->rt_type != RTYPE_NET_NET)
            && (lpRouter->rt_state != ROUTER_DISCONNECTED)
            && (lstrcmpi( lpszNodeName, lpRouter->rt_destName ) == 0) )  {
            found = TRUE;

            /* tell this router that this DDER should be associated */
            RouterAssociateDder( (HROUTER)lpRouter, hDder );
            ok = TRUE;
        }
        lpRouter = lpRouter->rt_next;
    }
    if( !found )  {
        /* create a new router for this connection */
        hRouter = RouterCreateLocalToNet( lpszNodeName );
        if( hRouter )  {
            lpRouter = (LPROUTER) hRouter;

            /* tell this router that this DDER should be associated */
            RouterAssociateDder( (HROUTER)lpRouter, hDder );

            ok = TRUE;
        } else {
            ok = FALSE;
        }
    }

    return( ok );
}

HROUTER
RouterCreateLocalToNet( const LPSTR lpszNodeName )
{
    HROUTER     hRouter;
    LPROUTER    lpRouter;
    BOOL        ok = TRUE;
    WORD        wHopErr;

    hRouter = RouterCreate();
    if( hRouter )  {
        lpRouter = (LPROUTER) hRouter;
        lpRouter->rt_type = RTYPE_LOCAL_NET;
        lstrcpy( lpRouter->rt_origName, ourNodeName );
        lstrcpy( lpRouter->rt_destName, lpszNodeName );

        if( GetRoutingInfo( lpszNodeName, lpRouter->rt_routeInfo,
            sizeof(lpRouter->rt_routeInfo),
            &lpRouter->rt_fDisconnect, &lpRouter->rt_nDelay ) )  {
            /* found an entry in the routing table */
        } else if( szDefaultRoute[0] != '\0' )  {
            /* there is a default route ... prepend the default route +
                this node name */
            if( (_fstrlen( szDefaultRoute ) + 1 + _fstrlen(lpszNodeName)) >
                MAX_ROUTE_INFO )  {
                wHopErr = RERR_ROUTE_TOO_LONG;
                ok = FALSE;
            } else {
                _fstrcpy( lpRouter->rt_routeInfo, szDefaultRoute );
                if( lpszNodeName[0] != '\0' )  {
            if (lstrcmpi( szDefaultRoute, lpszNodeName)) {
                        _fstrcat( lpRouter->rt_routeInfo, "+" );
                        _fstrcat( lpRouter->rt_routeInfo, lpszNodeName );
            }
                }
            }
        } else {
            /* no entry in routing table and no default ... just use the
                node name as the route */
            _fstrcpy( lpRouter->rt_routeInfo, lpszNodeName );
        }

        if( ok )  {
            ok = RouterConnectToNode( lpRouter, 0, &wHopErr );
        }
        if( !ok )  {
#if DBG
            RouterDisplayError( lpRouter, ourNodeName, wHopErr );
#endif // DBG
            RouterFree( (LPROUTER) hRouter );
            hRouter = (HROUTER) NULL;
        }
    }

    return( hRouter );
}

/*
    RouterConnectToNode()
 */
BOOL
RouterConnectToNode(
    LPROUTER    lpRouter,
    WORD        hRouterExtra,
    WORD FAR   *lpwHopErr )
{
    LPNIPTRS    lpNiPtrs;
    char        nodeStart[ MAX_NODE_NAME+1 ];
    char        szNetintf[ MAX_NI_NAME+1 ];
    char        szConnInfo[ MAX_CONN_INFO+1 ];
    BOOL        bDisconnect;
    int         nDelay;
    BOOL        ok = TRUE;
    BOOL        found;
    HPKTZ       hPktzDisallow;

    /* this is in here just to be sure that it's checked */
    assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );

    /* expand the first node to it's fullest */
    ok = RouterExpandFirstNode( lpRouter, lpwHopErr );
    if( ok )  {
        lpRouter->rt_state = ROUTER_WAIT_PKTZ;
        UpdateScreenState();

        /* strip off the starting node from the addl info */
        ok = RouterStripStartingNode( lpRouter->rt_routeInfo, nodeStart,
            lpwHopErr );
    }

    if( !ok )
        return(ok);
    ok = FALSE;

    lpRouter->rt_nLastNetintf = -1;
    while (!ok && !lpRouter->rt_fSpecificNetintf) {
        found = GetConnectionInfo( nodeStart, szNetintf, szConnInfo,
            sizeof(szConnInfo), &bDisconnect, &nDelay );
        if( found && (szNetintf[0] != '\0') )  {
            lpRouter->rt_fSpecificNetintf = TRUE;
            if( !NameToNetIntf( szNetintf, &lpNiPtrs ) )  {
                *lpwHopErr = RERR_CONN_NETINTF_INVALID;
                return(ok);
            }
        } else {
            lpRouter->rt_fSpecificNetintf = FALSE;
            strcpy( szConnInfo, nodeStart );
            _fstrcpy( lpRouter->rt_startNode, nodeStart );
            if ( !GetNextMappingNetIntf( &lpNiPtrs,
                    &lpRouter->rt_nLastNetintf ) )  {
                *lpwHopErr = RERR_CONN_NO_MAPPING_NI;
                return(ok);
            }
        }

        assert( (hRouterExtra == 0) || (hRouterExtra == 1) );
        lpRouter->rt_pktz_bDisconnect = bDisconnect;
        lpRouter->rt_pktz_nDelay = nDelay;
        if( hRouterExtra == 1 )  {
            /* don't allow connection to same pktz as the input */
            assert( lpRouter->rt_type == RTYPE_NET_NET );
            hPktzDisallow = lpRouter->rt_rinfo[0].ri_hPktz;
        } else {
            hPktzDisallow = (HPKTZ) NULL;
        }
        ok = PktzGetPktzForRouter( lpNiPtrs, nodeStart, szConnInfo,
            (HROUTER)lpRouter, hRouterExtra, lpwHopErr,
            lpRouter->rt_pktz_bDisconnect, lpRouter->rt_pktz_nDelay,
            hPktzDisallow );
    }

    return( ok );
}

BOOL
RouterExpandFirstNode(
    LPROUTER    lpRouter,
    WORD FAR   *lpwHopErr )
{
    char        routeInfo[ MAX_ROUTE_INFO+1 ];
    char        expandedStartNodeInfo[ MAX_ROUTE_INFO+1 ];
    char        startNode[ MAX_NODE_NAME+1 ];
    char        lastRouteInfo[ MAX_ROUTE_INFO+1 ];
    BOOL        ok = TRUE;
    BOOL        done = FALSE;
    BOOL        bDisconnect;
    int         nDelay;
    int         nExpands = 0;   /* here just in case there is some odd
                                    case that we don't catch */

    _fstrcpy( lastRouteInfo, lpRouter->rt_routeInfo );
    while( ok && !done && (++nExpands < 100) )  {
        _fstrcpy( routeInfo, lpRouter->rt_routeInfo );
        ok = RouterStripStartingNode( routeInfo, startNode, lpwHopErr );
        if( ok )  {
            if( GetRoutingInfo( startNode, expandedStartNodeInfo,
                   sizeof(expandedStartNodeInfo), &bDisconnect, &nDelay ) )  {
                if( (_fstrlen( routeInfo ) + 1
                     + _fstrlen(expandedStartNodeInfo)) > MAX_ROUTE_INFO ) {
                    *lpwHopErr = RERR_ROUTE_TOO_LONG;
                    ok = FALSE;
                } else {
                    _fstrcpy( lpRouter->rt_routeInfo, expandedStartNodeInfo );
                    if( routeInfo[0] != '\0' )  {
                        _fstrcat( lpRouter->rt_routeInfo, "+" );
                        _fstrcat( lpRouter->rt_routeInfo, routeInfo );
                    }
                }
            } else {
                /* start node not found in routing table */
                done = TRUE;
            }
        }
        if( lstrcmpi( lpRouter->rt_routeInfo, lastRouteInfo ) == 0 ) {
            /* hasn't changed */
            done = TRUE;
        }
        if (ok) {
            _fstrcpy( lastRouteInfo, lpRouter->rt_routeInfo );
        }
    }

    if( nExpands >= 100 )  {
        /*  Exceeded 100 expands in routing lookup!
            Route info bogus: %1    */
        NDDELogError(MSG125, routeInfo, NULL);
    }
    return( ok );
}

/*
    RouterStripStartingNode()

        This routine will take the "routeInfo" as an input and will strip
        off 1 node name, returning that in lpszNode.  Thus, both
        lpszRouteInfo and lpszNode will be modified
 */
BOOL
RouterStripStartingNode(
    LPSTR       lpszRouteInfo,
    LPSTR       lpszNode,
    WORD FAR   *lpwHopErr )
{
    LPSTR       lpszTok;

    lpszTok = _fstrchr( lpszRouteInfo, '+' );
    if( lpszTok )  {
        *lpszTok = '\0';
        if( lstrlen( lpszRouteInfo ) > MAX_NODE_NAME )  {
            *lpwHopErr = RERR_NODE_NAME_TOO_LONG;
            return( FALSE );
        }
        _fstrcpy( lpszNode, lpszRouteInfo );
        _fstrcpy( lpszRouteInfo, lpszTok+1 );
    } else {
        /* all one token */
        if( lstrlen( lpszRouteInfo ) > MAX_NODE_NAME )  {
            *lpwHopErr = RERR_NODE_NAME_TOO_LONG;
            return( FALSE );
        }
        lstrcpy( lpszNode, lpszRouteInfo );
        lpszRouteInfo[0] = '\0';
    }
    return( TRUE );
}

VOID
RouterFree( LPROUTER lpRouter )
{
    LPROUTER    lpRouterPrev;
    LPROUTER    lpRouterNext;
    int         i;
    LPRTINFO    lpRtInfo;

    DIPRINTF(( "RouterFree( %08lX )", lpRouter ));
    /* free response buffers */
    if( lpRouter->rt_lpMakeHopRsp )  {
        HeapFreePtr( lpRouter->rt_lpMakeHopRsp );
        lpRouter->rt_lpMakeHopRsp = NULL;
    }

    /* kill timer if it's alive */
    if( lpRouter->rt_hTimerCloseRoute )  {
        TimerDelete( lpRouter->rt_hTimerCloseRoute );
        lpRouter->rt_hTimerCloseRoute = 0;
    }

    /* unlink from Pktz lists */
    for( i=0; i<2; i++ )  {
        lpRtInfo = &lpRouter->rt_rinfo[i];
        if( lpRtInfo->ri_lpHopBrkCmd )  {
            HeapFreePtr( lpRtInfo->ri_lpHopBrkCmd );
            lpRtInfo->ri_lpHopBrkCmd = NULL;
        }

        if( lpRtInfo->ri_hPktz )  {
            PktzDisassociateRouter( lpRtInfo->ri_hPktz,
                (HROUTER) lpRouter, (WORD) i );
            lpRtInfo->ri_hPktz = 0;
        }
    }

    /* unlink from Router list */
    lpRouterPrev = lpRouter->rt_prev;
    lpRouterNext = lpRouter->rt_next;
    if( lpRouterPrev )  {
        lpRouterPrev->rt_next = lpRouterNext;
    } else {
        lpRouterHead = lpRouterNext;
    }
    if( lpRouterNext )  {
        lpRouterNext->rt_prev = lpRouterPrev;
    }

    HeapFreePtr( lpRouter );
    UpdateScreenState();
}

#ifdef _WINDOWS

#ifdef HASUI

#include <stdio.h>
#include "tmpbuf.h"


int
RouterDraw(
    BOOL    bShowThru,
    HDC     hDC,
    int     x,
    int     vertPos,
    int     lineHeight )
{
    LPROUTER    lpRouter;

    lpRouter = lpRouterHead;
    while( lpRouter )  {
        if( ((lpRouter->rt_type == RTYPE_NET_NET) && bShowThru)
            || ((lpRouter->rt_type == RTYPE_LOCAL_NET) && !bShowThru) )  {
            if( bShowStatistics )  {
                sprintf( tmpBuf, " %7ld %7ld %-16.16Fs %-33.33Fs",
                    lpRouter->rt_sent, lpRouter->rt_rcvd,
                    lpRouter->rt_type == RTYPE_NET_NET ?
                        _fstrupr(lpRouter->rt_origName) : (LPSTR)"",
                    (LPSTR) _fstrupr(lpRouter->rt_destName) );
            } else {
                sprintf( tmpBuf, " %-16.16Fs %-33.33Fs",
                    lpRouter->rt_type == RTYPE_NET_NET ?
                        _fstrupr(lpRouter->rt_origName) : (LPSTR)"",
                    (LPSTR) _fstrupr(lpRouter->rt_destName) );
            }
            switch( lpRouter->rt_state )  {
            case ROUTER_WAIT_PKTZ:
                strcat( tmpBuf, " Wait Network Interface" );
                break;
            case ROUTER_WAIT_MAKE_HOP_RSP:
                strcat( tmpBuf, " Wait Route Response" );
                break;
            case ROUTER_CONNECTED:
                strcat( tmpBuf, " Connected" );
                break;
            case ROUTER_DISCONNECTED:
                strcat( tmpBuf, " Disconnected" );
                break;
            default:
                sprintf( &tmpBuf[ strlen(tmpBuf) ], " unknown (%04lX)",
                    lpRouter->rt_state );
                break;
            }
            TextOut( hDC, x, vertPos, tmpBuf, strlen(tmpBuf) );
            vertPos += lineHeight;
        }
        lpRouter = lpRouter->rt_next;
    }
    return( vertPos );
}

#endif // HASUI

#endif


#if DBG
VOID
FAR PASCAL
DebugRouterState( void )
{
    LPROUTER    lpRouter;

    lpRouter = lpRouterHead;
    DPRINTF(( "ROUTER State:" ));
    while( lpRouter )  {
        DPRINTF(( "  %Fp:\n"
                  "  rt_prev      %Fp\n"
                  "  rt_next      %Fp\n"
                  "  rt_state     %d\n"
                  "  rt_type      %d\n"
                  "  rt_origName  %Fs\n"
                  "  rt_destName  %Fs\n"
                  "  rt_startNode %Fs\n"
                  "  rt_sent      %ld\n"
                  "  rt_rcvd      %ld\n"
                  ,
            lpRouter,
            lpRouter->rt_prev,
            lpRouter->rt_next,
            lpRouter->rt_state,
            lpRouter->rt_type,
            lpRouter->rt_origName,
            lpRouter->rt_destName,
            lpRouter->rt_startNode,
            lpRouter->rt_sent,
            lpRouter->rt_rcvd ));
        DPRINTF(( "    %d %d %d %d %d %d %d \"%Fs\" %Fp",
            lpRouter->rt_fDisconnect,
            lpRouter->rt_nDelay,
            lpRouter->rt_fSpecificNetintf,
            lpRouter->rt_nLastNetintf,
            lpRouter->rt_nHopsLeft,
            lpRouter->rt_pktz_bDisconnect,
            lpRouter->rt_pktz_nDelay,
            lpRouter->rt_routeInfo,
            lpRouter->rt_hDderHead ));
        DPRINTF(( "    0: %Fp %Fp %Fp %d %Fp %d %d %d %d",
            lpRouter->rt_rinfo[0].ri_hPktz,
            lpRouter->rt_rinfo[0].ri_hRouterDest,
            lpRouter->rt_rinfo[0].ri_hRouterPrev,
            lpRouter->rt_rinfo[0].ri_hRouterExtraPrev,
            lpRouter->rt_rinfo[0].ri_hRouterNext,
            lpRouter->rt_rinfo[0].ri_hRouterExtraNext,
            lpRouter->rt_rinfo[0].ri_hopRspProcessed,
            lpRouter->rt_rinfo[0].ri_hopBrokenSent,
            lpRouter->rt_rinfo[0].ri_hopBrokenRcvd ));
        DPRINTF(( "    1: %Fp %Fp %Fp %d %Fp %d %d %d %d",
            lpRouter->rt_rinfo[1].ri_hPktz,
            lpRouter->rt_rinfo[1].ri_hRouterDest,
            lpRouter->rt_rinfo[1].ri_hRouterPrev,
            lpRouter->rt_rinfo[1].ri_hRouterExtraPrev,
            lpRouter->rt_rinfo[1].ri_hRouterNext,
            lpRouter->rt_rinfo[1].ri_hRouterExtraNext,
            lpRouter->rt_rinfo[0].ri_hopRspProcessed,
            lpRouter->rt_rinfo[1].ri_hopBrokenSent,
            lpRouter->rt_rinfo[1].ri_hopBrokenRcvd ));
        lpRouter = lpRouter->rt_next;
    }
}
#endif // DBG

#ifdef  _WINDOWS
VOID
RouterCloseByName( LPSTR lpszName )
{
    LPROUTER    lpRouter;
    LPROUTER    lpRouterNext;

    lpRouter = lpRouterHead;
    while( lpRouter )  {
        lpRouterNext = lpRouter->rt_next;
        if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
            && (lpRouter->rt_state == ROUTER_CONNECTED)
            && (lstrcmpi( lpRouter->rt_destName, lpszName ) == 0) )  {
            RouterBreak( lpRouter );
            break;      // while loop
        }
        lpRouter = lpRouterNext;
    }
}

BOOL
FAR PASCAL
RouterCloseByCookie( LPSTR lpszName, DWORD_PTR dwCookie )
{
    LPROUTER    lpRouter;
    LPROUTER    lpRouterNext;
    BOOL	bKilled = FALSE;

    lpRouter = lpRouterHead;
    while( !bKilled && lpRouter )  {
        lpRouterNext = lpRouter->rt_next;
        if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
            && (lpRouter->rt_state == ROUTER_CONNECTED)
            && (lstrcmpi( lpRouter->rt_destName, lpszName ) == 0)
            && (dwCookie == (DWORD_PTR)lpRouter) )  {
            RouterBreak( lpRouter );
            bKilled = TRUE;
        }
        lpRouter = lpRouterNext;
    }
    return( bKilled );
}

int
FAR PASCAL
RouterCount( void )
{
    LPROUTER    lpRouter;
    int		nCount = 0;

    lpRouter = lpRouterHead;
    while( lpRouter )  {
        nCount++;
        lpRouter = lpRouter->rt_next;
    }
    return( nCount );
}

VOID
FAR PASCAL
RouterFillInEnum( LPSTR lpBuffer, DWORD cBufSize )
{
    LPROUTER    	lpRouter;
    int             nCount = 0;
    DWORD           cbDone = 0;
    LPDDESESSINFO	lpDdeSessInfo;

    lpRouter = lpRouterHead;
    lpDdeSessInfo = (LPDDESESSINFO)lpBuffer;
    /* as long as there are routers and memory available */
    while( lpRouter && ((cbDone + sizeof(DDESESSINFO)) <= cBufSize) )  {
        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            lstrcpy( lpDdeSessInfo->ddesess_ClientName,
                lpRouter->rt_destName );
            lpDdeSessInfo->ddesess_Status = lpRouter->rt_state;
            lpDdeSessInfo->ddesess_Cookie = (DWORD_PTR)lpRouter;
            cbDone += sizeof(DDESESSINFO);
            lpDdeSessInfo++;
        }
        lpRouter = lpRouter->rt_next;
    }
}

VOID
FAR PASCAL
RouterFillInConnInfo(
    LPROUTER 		lpRouter,
    LPCONNENUM_CMR 	lpConnEnum,
    LPSTR		lpDataStart,
    LPWORD		lpcFromBeginning,
    LPWORD		lpcFromEnd )
{
    HDDER		hDder;

    hDder = lpRouter->rt_hDderHead;
    /* as long as there are DDERs and memory available */
    while( hDder )  {
        hDder = DderFillInConnInfo( hDder, lpConnEnum,
            lpDataStart, lpcFromBeginning, lpcFromEnd );
    }
}

VOID
FAR PASCAL
RouterEnumConnectionsForApi( LPCONNENUM_CMR lpConnEnum )
{
    LPROUTER    	lpRouter;
    LPROUTER    	lpRouterNext;
    BOOL		bFound = FALSE;
    DWORD		cbDone;
    WORD		cFromBeginning;
    WORD		cFromEnd;

    lpConnEnum->lReturnCode = NDDE_INVALID_SESSION;
    lpRouter = lpRouterHead;
    while( !bFound && lpRouter )  {
        lpRouterNext = lpRouter->rt_next;
        if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
            && (lpRouter->rt_state == ROUTER_CONNECTED)
            && (lstrcmpi( lpRouter->rt_destName, lpConnEnum->clientName) == 0)
            && (lpConnEnum->cookie == (DWORD_PTR)lpRouter) )  {
            cbDone = 0;
            lpConnEnum->lReturnCode = NDDE_NO_ERROR;
            lpConnEnum->nItems = 0;
            lpConnEnum->cbTotalAvailable = 0;
            cFromBeginning = 0;
            cFromEnd = (WORD)lpConnEnum->cBufSize;
            bFound = TRUE;
            RouterFillInConnInfo( lpRouter, lpConnEnum,
                (((LPSTR)lpConnEnum) + sizeof(CONNENUM_CMR)),
                &cFromBeginning,
                &cFromEnd );
        }
        lpRouter = lpRouterNext;
    }
}

VOID FAR PASCAL NetddeEnumRoute( HWND hDlg, LPSTR lpszName );

VOID
RouterEnumConnections( HWND hDlg )
{
    LPROUTER    lpRouter;

    lpRouter = lpRouterHead;
    while( lpRouter )  {
        if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
            && (lpRouter->rt_state == ROUTER_CONNECTED) )  {
            NetddeEnumRoute( hDlg, lpRouter->rt_destName );
        }
        lpRouter = lpRouter->rt_next;
    }
}
#endif // _WINDOWS

#ifdef  BYTE_SWAP
VOID
ConvertDdePkt( LPDDEPKT lpDdePkt )
{
    lpDdePkt->dp_hDstRouter = HostToPcLong( lpDdePkt->dp_hDstRouter );
    lpDdePkt->dp_routerCmd = HostToPcLong( lpDdePkt->dp_routerCmd );
}
#endif // BYTE_SWAP


#if DBG
VOID
RouterDisplayError(
    LPROUTER    lpRouter,
    LPSTR       lpszNode,
    WORD        wHopErr )
{
    DWORD       EventId = MSG130;

    if (wHopErr < RERR_MAX_ERR ) {
        EventId += wHopErr;
    }
    NDDELogError(EventId, LogString("%d", wHopErr),
        lpRouter->rt_origName, lpRouter->rt_destName, lpszNode, NULL );
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\userdde.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "USERDDE.C;2  4-Dec-92,12:23:48  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "host.h"

#include    <memory.h>
#include    <string.h>

#include    "windows.h"
#include    "dde.h"
#include    "netbasic.h"
#include    "wwdde.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "userdde.h"
#include    "debug.h"
#include    "hexdump.h"
#include    "wwassert.h"
#include    "api1632.h"
#include    "nddemsg.h"
#include    "nddelog.h"


USES_ASSERT

#define MAX_CF_NAME     128
/*
    External variables used
 */
#if DBG
extern  BOOL    bDebugDdePkts;
#endif // DBG
extern  HHEAP   hHeap;
extern  char    ourNodeName[ MAX_NODE_NAME+1 ];
extern  DWORD   dwReasonInitFail;
extern  DWORD   dwSecurityType;

/*
    Local routines
 */
WORD GetFormatForXfer( WORD cfFormat, LPSTR lpszFormatName );
WORD    FAR PASCAL XRegisterClipboardFormat( LPSTR lpszFormatName );

LPDDEPKT
CreateInitiatePkt(
    LPSTR   lpszToNode,
    LPSTR   lpszToApp,
    LPSTR   lpszToTopic,
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    DWORD   dwSecurityType,
    PQOS    pqosClient,
    LPBYTE  lpPassword,
    DWORD   dwPasswordSize,
    DWORD   hSecurityKey)
{
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    LPSTR           lpszPktItem;
    LPDDEPKTSEC     lpSecItem;
    LPDDEPKTSEC     lpSecAligned;
    int             lenFromNode;
    int             lenFromApp;
    int             lenToNode;
    int             lenToApp;
    int             lenToTopic;
    DWORD           dwSize;
    DWORD           dwSecSize;
    DWORD           dwQosSize;
    WORD            nextOffset;

/*
{ char buf[200];
wsprintf( buf, "lpszToNode: \"%s\"\r\n", lpszToNode ); OutputDebugString( buf );
wsprintf( buf, "lpszToApp: \"%s\"\r\n", lpszToApp ); OutputDebugString( buf );
wsprintf( buf, "lpszToTopic: \"%s\"\r\n", lpszToTopic ); OutputDebugString( buf );
wsprintf( buf, "lpszFromNode: \"%s\"\r\n", lpszFromNode ); OutputDebugString( buf );
wsprintf( buf, "lpszFromApp: \"%s\"\r\n", lpszFromApp ); OutputDebugString( buf );
wsprintf( buf, "lpszUserName: \"%s\"\r\n", lpszUserName ); OutputDebugString( buf );
wsprintf( buf, "lpszDomainName: \"%s\"\r\n", lpszDomainName ); OutputDebugString( buf );
wsprintf( buf, "dwPasswordSize: \"%ld\"\r\n", dwPasswordSize ); OutputDebugString( buf );
}
*/
    if ((lenFromNode = lstrlen(lpszFromNode)) == 0)
        lenFromNode = MAX_NODE_NAME;
    if ((lenFromApp = lstrlen(lpszFromApp)) == 0)
        lenFromApp = MAX_APP_NAME;
    if ((lenToNode = lstrlen(lpszToNode)) == 0)
        lenToNode = MAX_NODE_NAME;
    if ((lenToApp = lstrlen(lpszToApp)) == 0)
        lenToApp = MAX_APP_NAME;
    if ((lenToTopic = lstrlen(lpszToTopic)) == 0)
        lenToTopic = MAX_TOPIC_NAME;
    if( dwSecurityType == NT_SECURITY_TYPE )  {
        dwQosSize = sizeof(QOS);
    } else {
        dwQosSize = 0;
    }
    dwSecSize =  dwPasswordSize + dwQosSize +
        sizeof(DDEPKTSEC) + lstrlen(lpszUserName) + 1 +
        lstrlen(lpszDomainName) + 1;

    nextOffset = sizeof(DDEPKTINIT);
    dwSize = nextOffset + ++lenFromNode + ++lenFromApp +
        ++lenToNode + ++lenToApp + ++lenToTopic + dwSecSize;

    lpDdePktInit = (LPDDEPKTINIT) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize );
    lpSecAligned = (LPDDEPKTSEC) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSecSize );
    if( lpDdePktInit && lpSecAligned )  {
        lpDdePkt = (LPDDEPKT) lpDdePktInit;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktInit;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_INITIATE;
        lpDdePktInit->dp_init_dwSecurityType = dwSecurityType;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromNode = nextOffset );
        lstrcpy( lpszPktItem, lpszFromNode);
        nextOffset += (WORD)lenFromNode;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromApp = nextOffset );
        lstrcpy( lpszPktItem, lpszFromApp);
        nextOffset += (WORD)lenFromApp;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToNode = nextOffset );
        lstrcpy( lpszPktItem, lpszToNode);
        nextOffset += (WORD)lenToNode;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToApp = nextOffset );
        lstrcpy( lpszPktItem, lpszToApp);
        nextOffset += (WORD)lenToApp;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToTopic = nextOffset );
        lstrcpy( lpszPktItem, lpszToTopic);
        nextOffset += (WORD)lenToTopic;

        lpSecItem = (LPDDEPKTSEC) GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsPassword = nextOffset );
        lpDdePktInit->dp_init_sizePassword = dwSecSize;

        /* create the sec pkt aligned, then do it */
        nextOffset = sizeof(DDEPKTSEC);
        lpszPktItem = GetStringOffset( lpSecAligned,
            lpSecAligned->dp_sec_offsUserName = nextOffset);
        lstrcpy(lpszPktItem, lpszUserName);
        lpSecAligned->dp_sec_sizeUserName = (WORD)lstrlen(lpszUserName);
        nextOffset += lstrlen(lpszUserName) + 1;

        lpszPktItem = GetStringOffset( lpSecAligned,
            lpSecAligned->dp_sec_offsDomainName = nextOffset);
        lstrcpy(lpszPktItem, lpszDomainName);
        lpSecAligned->dp_sec_sizeDomainName = (WORD)lstrlen(lpszDomainName);
        nextOffset += lstrlen(lpszDomainName) + 1;

        if (lpSecAligned->dp_sec_sizePassword = (WORD) dwPasswordSize) {
            lpszPktItem = GetStringOffset( lpSecAligned,
                lpSecAligned->dp_sec_offsPassword = nextOffset);
            hmemcpy( lpszPktItem, lpPassword, dwPasswordSize );
            nextOffset += (INT) dwPasswordSize;
        } else {
            lpSecAligned->dp_sec_offsPassword = 0;
        }

        if( dwSecurityType == NT_SECURITY_TYPE )  {
            lpszPktItem = GetStringOffset( lpSecAligned,
                lpSecAligned->dp_sec_offsQos = nextOffset);
            hmemcpy( lpszPktItem, pqosClient,
                lpSecAligned->dp_sec_sizeQos = (WORD) dwQosSize );
        } else {
            lpSecAligned->dp_sec_offsQos = 0;
            lpSecAligned->dp_sec_sizeQos = 0;
        }

        hmemcpy( lpSecItem, lpSecAligned, dwSecSize );
        HeapFreePtr( lpSecAligned );
        lpDdePktInit->dp_init_hSecurityKey = hSecurityKey;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_INITIATE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateAckInitiatePkt(
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszFromTopic,
    LPBYTE  lpSecurityKey,
    DWORD   dwSecurityKeySize,
    DWORD   hSecurityKey,
    BOOL    bSuccess,
    DWORD   dwReason )
{
    LPDDEPKTIACK    lpDdePktIack;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    LPSTR           lpszPktItem;
    int             lenFromNode;
    int             lenFromApp;
    int             lenFromTopic;
    DWORD           dwSize;
    WORD            nextOffset;

    if (lenFromNode = lstrlen(lpszFromNode))
        lenFromNode++;
    if (lenFromApp = lstrlen(lpszFromApp))
        lenFromApp++;
    if (lenFromTopic = lstrlen(lpszFromTopic))
        lenFromTopic++;
    nextOffset = sizeof(DDEPKTIACK);
    dwSize = nextOffset + lenFromNode + lenFromApp +
        lenFromTopic + dwSecurityKeySize;

    lpDdePktIack = (LPDDEPKTIACK) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize );
    if( lpDdePktIack )  {
        lpDdePkt = (LPDDEPKT) lpDdePktIack;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktIack;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_ACK_INITIATE;

        if (lenFromNode) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsFromNode = nextOffset );
            lstrcpy( lpszPktItem, lpszFromNode);
            nextOffset += (WORD)lenFromNode;
        } else
            lpDdePktIack->dp_iack_offsFromNode = 0;

        if (lenFromApp) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsFromApp = nextOffset );
            lstrcpy( lpszPktItem, lpszFromApp);
            nextOffset += (WORD)lenFromApp;
        } else
            lpDdePktIack->dp_iack_offsFromApp = 0;

        if (lenFromTopic) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsFromTopic = nextOffset );
            lstrcpy( lpszPktItem, lpszFromTopic);
            nextOffset += (WORD)lenFromTopic;
        } else
            lpDdePktIack->dp_iack_offsFromTopic = 0;

        if (lpDdePktIack->dp_iack_sizeSecurityKey = dwSecurityKeySize) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsSecurityKey = nextOffset );
            hmemcpy( lpszPktItem, lpSecurityKey, dwSecurityKeySize);
            lpDdePktIack->dp_iack_hSecurityKey = hSecurityKey;
            lpDdePktIack->dp_iack_dwSecurityType = dwSecurityType;
        } else {
            lpDdePktIack->dp_iack_offsSecurityKey = 0;
            lpDdePktIack->dp_iack_hSecurityKey = 0xFFFFFFFF;       /* compatibility */
            lpDdePktIack->dp_iack_dwSecurityType = 0xFFFFFFFF;     /* compatibility */
        }

        lpDdePktIack->dp_iack_fromDder = bSuccess;
        lpDdePktIack->dp_iack_reason = dwReason;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_INITIATE_ACK",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateAckExecutePkt(
    BOOL    fAck,
    BOOL    fBusy,
    BYTE    bAppRtn )
{
    LPDDEPKTEACK    lpDdePktEack;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    DWORD           dwSize;

    lpDdePktEack = (LPDDEPKTEACK) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = sizeof(DDEPKTEACK) );
    if( lpDdePktEack )  {
        lpDdePkt = (LPDDEPKT) lpDdePktEack;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktEack;
        lpDdePkt->dp_size = sizeof(DDEPKTEACK);
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_ACK_EXECUTE;
        lpDdePktEack->dp_eack_fAck    = (BYTE) fAck;
        lpDdePktEack->dp_eack_fBusy   = (BYTE) fBusy;
        lpDdePktEack->dp_eack_bAppRtn = bAppRtn;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_EXECUTE_ACK",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateGenericAckPkt(
    WORD    wDdeMsg,
    LPSTR   lpszItem,
    BOOL    fAck,
    BOOL    fBusy,
    BYTE    bAppRtn )
{
    LPDDEPKTGACK    lpDdePktGack;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    DWORD           dwSize;

    lpDdePktGack = (LPDDEPKTGACK) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = sizeof(DDEPKTGACK) + lstrlen(lpszItem) );
    if( lpDdePktGack )  {
        lpDdePkt = (LPDDEPKT) lpDdePktGack;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktGack;
        lpDdePkt->dp_size = sizeof(DDEPKTGACK) + lstrlen(lpszItem);
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = wDdeMsg;
        lpDdePktGack->dp_gack_fAck    = (BYTE) fAck;
        lpDdePktGack->dp_gack_fBusy   = (BYTE) fBusy;
        lpDdePktGack->dp_gack_bAppRtn = bAppRtn;
        lstrcpy( lpDdePktGack->dp_gack_itemName, lpszItem );
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_ACK",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateExecutePkt( LPSTR lpszCommand )
{
    LPDDEPKTEXEC    lpDdePktExec;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    DWORD           dwSize;

    lpDdePktExec = (LPDDEPKTEXEC) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = (DWORD)sizeof(DDEPKTEXEC) + lstrlen(lpszCommand) );
    if( lpDdePktExec )  {
        lpDdePkt = (LPDDEPKT) lpDdePktExec;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktExec;
        lpDdePkt->dp_size = sizeof(DDEPKTEXEC) + lstrlen(lpszCommand);
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_EXECUTE;
        lstrcpy( lpDdePktExec->dp_exec_string, lpszCommand );
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_EXECUTE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateTerminatePkt( void )
{
    LPDDEPKT        lpDdePkt;
    DWORD           dwSize;

    lpDdePkt = (LPDDEPKT) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = (DWORD)sizeof(DDEPKTTERM) );
    if( lpDdePkt )  {
        FillTerminatePkt( lpDdePkt );
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_TERMINATE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

VOID
FillTerminatePkt( LPDDEPKT lpDdePkt )
{
    LPDDEPKTCMN     lpDdePktCmn;

    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    lpDdePkt->dp_size = sizeof(DDEPKTTERM);
    lpDdePkt->dp_hDstDder = 0;
    lpDdePkt->dp_hDstRouter = 0;
    lpDdePkt->dp_routerCmd = 0;
    lpDdePktCmn->dc_message = WM_DDE_TERMINATE;
}

LPDDEPKT
CreateRequestPkt(
    LPSTR   lpszItem,
    WORD    cfFormat )
{
    LPDDEPKTRQST    lpDdePktRqst;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;
    WORD            nextOffset;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTRQST) + lenCf + lenItem;
    lpDdePktRqst = (LPDDEPKTRQST) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktRqst )  {
        lpDdePkt = (LPDDEPKT) lpDdePktRqst;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktRqst;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_REQUEST;
        nextOffset = sizeof(DDEPKTRQST);

        /* put in item name */
        lpDdePktRqst->dp_rqst_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktRqst->dp_rqst_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktRqst->dp_rqst_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktRqst->dp_rqst_offsFormat = 0;
        } else {
            lpDdePktRqst->dp_rqst_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktRqst->dp_rqst_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_REQUEST",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateUnadvisePkt(
    LPSTR   lpszItem,
    WORD    cfFormat )
{
    LPDDEPKTUNAD    lpDdePktUnad;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTRQST) + lenCf + lenItem;
    lpDdePktUnad = (LPDDEPKTUNAD) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktUnad )  {
        lpDdePkt = (LPDDEPKT) lpDdePktUnad;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktUnad;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_UNADVISE;
        nextOffset = sizeof(DDEPKTUNAD);

        /* put in item name */
        lpDdePktUnad->dp_unad_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktUnad->dp_unad_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktUnad->dp_unad_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktUnad->dp_unad_offsFormat = 0;
        } else {
            lpDdePktUnad->dp_unad_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktUnad->dp_unad_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_UNADVISE",
            LogString("%d", dwSize), NULL);
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateDataPkt(
    LPSTR   lpszItem,
    WORD    cfFormat,
    BOOL    fResponse,
    BOOL    fAckReq,
    BOOL    fRelease,
    LPVOID  lpData,
    DWORD   dwSizeOfData )
{
    LPDDEPKTDATA    lpDdePktData;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    int             align;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;
    LPSTR           lpszPktData;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    /* add 1 DWORD to size to allow for DWORD alignment of lpData */
    dwSize = sizeof(DDEPKTDATA) + lenCf + lenItem + dwSizeOfData + sizeof(DWORD);
    lpDdePktData = (LPDDEPKTDATA) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktData )  {
        lpDdePkt = (LPDDEPKT) lpDdePktData;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktData;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_DATA;
        nextOffset = sizeof(DDEPKTDATA);

        /* put in item name */
        lpDdePktData->dp_data_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktData->dp_data_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktData->dp_data_offsFormat = 0;
        } else {
            lpDdePktData->dp_data_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }

        /* put in data */
        lpDdePktData->dp_data_sizeData = dwSizeOfData;
        if( dwSizeOfData == 0 )  {
            lpDdePktData->dp_data_offsData = 0;
        } else {
// TEMP: until SetMetaFileBitsEx() fix
            if (align = (nextOffset & 0x3)) { /* is it on a double word boundar? */
                align = (~align + 1) & 0x3;
                nextOffset += (WORD)align;
                lpDdePkt->dp_size += align;
            }
            lpDdePktData->dp_data_offsData = nextOffset;
            lpszPktData = GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsData );
            hmemcpy( lpszPktData, lpData, dwSizeOfData );
        }

        /* put in flags */
        lpDdePktData->dp_data_fResponse = (BYTE) fResponse;
        lpDdePktData->dp_data_fAckReq = (BYTE) fAckReq;
        lpDdePktData->dp_data_fRelease = (BYTE) fRelease;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_DATA",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreateAdvisePkt(
    LPSTR   lpszItem,
    WORD    cfFormat,
    BOOL    fAckReq,
    BOOL    fNoData )
{
    LPDDEPKTADVS    lpDdePktAdvs;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTADVS) + lenCf + lenItem;
    lpDdePktAdvs = (LPDDEPKTADVS) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktAdvs )  {
        lpDdePkt = (LPDDEPKT) lpDdePktAdvs;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktAdvs;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_ADVISE;
        nextOffset = sizeof(DDEPKTADVS);

        /* put in flags */
        lpDdePktAdvs->dp_advs_fAckReq = (BYTE)fAckReq;
        lpDdePktAdvs->dp_advs_fNoData = (BYTE)fNoData;

        /* put in item name */
        lpDdePktAdvs->dp_advs_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktAdvs->dp_advs_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktAdvs->dp_advs_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktAdvs->dp_advs_offsFormat = 0;
        } else {
            lpDdePktAdvs->dp_advs_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktAdvs->dp_advs_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_ADVISE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
CreatePokePkt(
    LPSTR   lpszItem,
    WORD    cfFormat,
    BOOL    fRelease,
    LPVOID  lpData,
    DWORD   dwSizeOfData )
{
    LPDDEPKTPOKE    lpDdePktPoke;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;
    LPSTR           lpszPktData;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTPOKE) + lenCf + lenItem + dwSizeOfData;
    lpDdePktPoke = (LPDDEPKTPOKE) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktPoke )  {
        lpDdePkt = (LPDDEPKT) lpDdePktPoke;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktPoke;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_POKE;
        nextOffset = sizeof(DDEPKTPOKE);

        /* put in item name */
        lpDdePktPoke->dp_poke_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktPoke->dp_poke_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktPoke->dp_poke_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktPoke->dp_poke_offsFormat = 0;
        } else {
            lpDdePktPoke->dp_poke_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktPoke->dp_poke_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }

        /* put in data */
        lpDdePktPoke->dp_poke_sizeData = dwSizeOfData;
        if( dwSizeOfData == 0 )  {
            lpDdePktPoke->dp_poke_offsData = 0;
        } else {
            lpDdePktPoke->dp_poke_offsData = nextOffset;
            lpszPktData = GetStringOffset( lpDdePkt,
                lpDdePktPoke->dp_poke_offsData );
            hmemcpy( lpszPktData, lpData, dwSizeOfData );
        }

        /* put in flags */
        lpDdePktPoke->dp_poke_fRelease = (BYTE) fRelease;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_POKE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

#if DBG

VOID
DebugDdePkt( LPDDEPKT lpDdePkt )
{
    LPDDEPKTCMN     lpDdePktCmn;
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKTIACK    lpDdePktIack;
    LPDDEPKTGACK    lpDdePktGack;
    LPDDEPKTEXEC    lpDdePktExec;
    LPDDEPKTEACK    lpDdePktEack;
    LPDDEPKTRQST    lpDdePktRqst;
    LPDDEPKTUNAD    lpDdePktUnad;
    LPDDEPKTADVS    lpDdePktAdvs;
    LPDDEPKTPOKE    lpDdePktPoke;
    LPDDEPKTDATA    lpDdePktData;
    LPDDEPKTTEST    lpDdePktTest;
    LPSTR           lpszPktItem;

    if( !bDebugDdePkts )  {
        return;
    }
    DPRINTF(( "DDEPKT: %08lX", lpDdePkt ));
    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_WWTEST:
        DPRINTF(( "  WM_DDE_WWTEST" ));
        lpDdePktTest = (LPDDEPKTTEST) lpDdePkt;
        DPRINTF(( "   Test #: %d", lpDdePktTest->dp_test_nTestNo ));
        DPRINTF(( "   Pkt #: %d of %d", lpDdePktTest->dp_test_nPktNo,
            lpDdePktTest->dp_test_nTotalPkts ));
        DPRINTF(( "   Size: %ld", lpDdePkt->dp_size ));
        break;
    case WM_DDE_INITIATE:
        DPRINTF(( "  WM_DDE_INITIATE" ));
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        DPRINTF(( "   fromDder: %08lX", lpDdePktInit->dp_init_fromDder ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromNode );
        DPRINTF(( "   fromNode: \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromApp );
        DPRINTF(( "   fromApp:  \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToNode );
        DPRINTF(( "   toNode:   \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToApp );
        DPRINTF(( "   toApp:    \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToTopic );
        DPRINTF(( "   toTopic:  \"%Fs\"", lpszPktItem ));
        if (lpDdePktInit->dp_init_offsFromNode == sizeof(DDEPKTINIT)) {
            if (lpDdePktInit->dp_init_offsPassword) {
                DPRINTF(( "    Password: "));
                HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktInit->dp_init_offsPassword),
                    (int)lpDdePktInit->dp_init_sizePassword );
            }
        }
        DPRINTF(( "" ));
        break;
    case WM_DDE_ACK_INITIATE:
        DPRINTF(( "  WM_DDE_ACK_INITIATE" ));
        lpDdePktIack = (LPDDEPKTIACK) lpDdePkt;
        DPRINTF(( "   fromDder: %08lX, dp_iack_reason: %08lx",
            lpDdePktIack->dp_iack_fromDder, lpDdePktIack->dp_iack_reason));

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktIack->dp_iack_offsFromNode );
        DPRINTF(( "   fromNode: \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktIack->dp_iack_offsFromApp );
        DPRINTF(( "   fromApp:  \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktIack->dp_iack_offsFromTopic );
        DPRINTF(( "   toNode:   \"%Fs\"", lpszPktItem ));
        if (lpDdePktIack->dp_iack_offsFromNode == sizeof(DDEPKTIACK)) {
            if (lpDdePktIack->dp_iack_offsSecurityKey) {
                DPRINTF(( "    Security Key: "));
                HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktIack->dp_iack_offsSecurityKey),
                    (int)lpDdePktIack->dp_iack_sizeSecurityKey );
            }
        }
        DPRINTF(( "" ));
        break;
    case WM_DDE_ACK_EXECUTE:
        DPRINTF(( "  WM_DDE_ACK_EXECUTE" ));
        lpDdePktEack = (LPDDEPKTEACK) lpDdePkt;
        DPRINTF(( "   fAck:    %02X", lpDdePktEack->dp_eack_fAck ));
        DPRINTF(( "   fBusy:   %02X", lpDdePktEack->dp_eack_fBusy ));
        DPRINTF(( "   bAppRtn: %02X", lpDdePktEack->dp_eack_bAppRtn ));
        break;
    case WM_DDE_ACK_ADVISE:
    case WM_DDE_ACK_REQUEST:
    case WM_DDE_ACK_UNADVISE:
    case WM_DDE_ACK_POKE:
    case WM_DDE_ACK_DATA:
        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ACK_ADVISE:
            DPRINTF(( "  WM_DDE_ACK_ADVISE" ));
            break;
        case WM_DDE_ACK_REQUEST:
            DPRINTF(( "  WM_DDE_ACK_REQUEST" ));
            break;
        case WM_DDE_ACK_UNADVISE:
            DPRINTF(( "  WM_DDE_ACK_UNADVISE" ));
            break;
        case WM_DDE_ACK_POKE:
            DPRINTF(( "  WM_DDE_ACK_POKE" ));
            break;
        case WM_DDE_ACK_DATA:
            DPRINTF(( "  WM_DDE_ACK_DATA" ));
            break;
        }
        lpDdePktGack = (LPDDEPKTGACK) lpDdePkt;
        DPRINTF(( "   fAck:    %02X", lpDdePktGack->dp_gack_fAck ));
        DPRINTF(( "   fBusy:   %02X", lpDdePktGack->dp_gack_fBusy ));
        DPRINTF(( "   bAppRtn: %02X", lpDdePktGack->dp_gack_bAppRtn ));
        DPRINTF(( "   item:    \"%Fs\"", lpDdePktGack->dp_gack_itemName ));
        break;
    case WM_DDE_EXECUTE:
        DPRINTF(( "  WM_DDE_EXECUTE" ));
        lpDdePktExec = (LPDDEPKTEXEC) lpDdePkt;
        DPRINTF(( "   cmd: \"%Fs\"", lpDdePktExec->dp_exec_string ));
        break;
    case WM_DDE_REQUEST:
        DPRINTF(( "  WM_DDE_REQUEST" ));
        lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktRqst->dp_rqst_cfFormat ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktRqst->dp_rqst_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktRqst->dp_rqst_offsItemName ));
        if( lpDdePktRqst->dp_rqst_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktRqst->dp_rqst_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktRqst->dp_rqst_offsItemName ) ));
        break;
    case WM_DDE_UNADVISE:
        DPRINTF(( "  WM_DDE_UNADVISE" ));
        lpDdePktUnad = (LPDDEPKTUNAD) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktUnad->dp_unad_cfFormat ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktUnad->dp_unad_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktUnad->dp_unad_offsItemName ));
        if( lpDdePktUnad->dp_unad_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktUnad->dp_unad_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktUnad->dp_unad_offsItemName ) ));
        break;
    case WM_DDE_ADVISE:
        DPRINTF(( "  WM_DDE_ADVISE" ));
        lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktAdvs->dp_advs_cfFormat ));
        DPRINTF(( "   fAckReq:    %02X", lpDdePktAdvs->dp_advs_fAckReq ));
        DPRINTF(( "   fNoData:    %02X", lpDdePktAdvs->dp_advs_fNoData ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktAdvs->dp_advs_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktAdvs->dp_advs_offsItemName ));
        if( lpDdePktAdvs->dp_advs_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktAdvs->dp_advs_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktAdvs->dp_advs_offsItemName ) ));
        break;
    case WM_DDE_DATA:
        DPRINTF(( "  WM_DDE_DATA" ));
        lpDdePktData = (LPDDEPKTDATA) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktData->dp_data_cfFormat ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktData->dp_data_offsFormat ));
        DPRINTF(( "   fResponse:  %02X", lpDdePktData->dp_data_fResponse ));
        DPRINTF(( "   fAckReq:    %02X", lpDdePktData->dp_data_fAckReq ));
        DPRINTF(( "   fRelease:   %02X", lpDdePktData->dp_data_fRelease ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktData->dp_data_offsItemName ));
        if( lpDdePktData->dp_data_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsItemName ) ));
        DPRINTF(( "   offsData:   %04X", lpDdePktData->dp_data_offsData ));
        DPRINTF(( "   sizeData:   %08lX", lpDdePktData->dp_data_sizeData ));
        HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData),
            (int)lpDdePktData->dp_data_sizeData );
        break;
    case WM_DDE_POKE:
        DPRINTF(( "  WM_DDE_POKE" ));
        lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktPoke->dp_poke_cfFormat ));
        DPRINTF(( "   fRelease:   %02X", lpDdePktPoke->dp_poke_fRelease ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktPoke->dp_poke_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktPoke->dp_poke_offsItemName ));
        if( lpDdePktPoke->dp_poke_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktPoke->dp_poke_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktPoke->dp_poke_offsItemName ) ));
        DPRINTF(( "   offsData:   %04X", lpDdePktPoke->dp_poke_offsData ));
        DPRINTF(( "   sizeData:   %08lX", lpDdePktPoke->dp_poke_sizeData ));
        HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktPoke->dp_poke_offsData),
            (int)lpDdePktPoke->dp_poke_sizeData );
        break;
    case WM_DDE_TERMINATE:
        DPRINTF(( "  WM_DDE_TERMINATE" ));
        break;
    default:
        DPRINTF(( "DebugDdePkt: UNKNOWN CMD: %04X", lpDdePktCmn->dc_message ));
    }
    DPRINTF(( "" ));
}
#endif // DBG


WORD
GetClipFormat(
    LPDDEPKT    lpDdePkt,
    WORD        cfFormat,
    WORD        wOffsFormat )
{
    LPSTR       lpszCfName;
    extern WORD wClipFmtInTouchDDE;

    if( cfFormat == CF_INTOUCH_SPECIAL )  {
        cfFormat = wClipFmtInTouchDDE;
    } else if( cfFormat >= 0xC000 )  {
        lpszCfName = GetStringOffset( lpDdePkt, wOffsFormat );
        cfFormat = XRegisterClipboardFormat( lpszCfName );
    }
    return( cfFormat );
}

typedef struct {
    char        cfName[ MAX_CF_NAME+1 ];
    WORD        cfFormat;
} CFSTRUCT;

#ifdef NOINTERNALCFS
#define MAX_CFSTRUCTS   50
CFSTRUCT        cfStructs[ MAX_CFSTRUCTS ];
int             nCfStructs;
#endif // NOINTERNALCFS

WORD
FAR PASCAL
XRegisterClipboardFormat( LPSTR lpszCfName )
{
#ifdef NOINTERNALCFS
    int         i;
    CFSTRUCT   *pCfStruct;
#endif

    if( lstrcmpi( lpszCfName, "text" ) == 0 )  {
        return( CF_TEXT );
    } else if( lstrcmpi( lpszCfName, "bitmap" ) == 0 )  {
        return( CF_BITMAP );
    } else if( lstrcmpi( lpszCfName, "metafilepict" ) == 0 )  {
        return( CF_METAFILEPICT );
    } else if( lstrcmpi( lpszCfName, "sylk" ) == 0 )  {
        return( CF_SYLK );
    } else if( lstrcmpi( lpszCfName, "dif" ) == 0 )  {
        return( CF_DIF );
    } else if( lstrcmpi( lpszCfName, "tiff" ) == 0 )  {
        return( CF_TIFF );
    } else if( lstrcmpi( lpszCfName, "oemtext" ) == 0 )  {
        return( CF_OEMTEXT );
    } else if( lstrcmpi( lpszCfName, "dib" ) == 0 )  {
        return( CF_DIB );
    } else if( lstrcmpi( lpszCfName, "palette" ) == 0 )  {
        return( CF_PALETTE );
    }

// the following WW code caches format strings, seems to be only
// to support platforms w/out cf atom table... this is not interesting
// to winball, so #define NOINTERNALCFS to get this stuff back

#ifdef NOINTERNALCFS
    pCfStruct = cfStructs;
    for( i=0; i<nCfStructs; i++,pCfStruct++ )  {
        if( lstrcmpi( pCfStruct->cfName, lpszCfName ) == 0 )  {
            return( pCfStruct->cfFormat );
        }
    }
    nCfStructs++;
    if( nCfStructs > MAX_CFSTRUCTS )  {
        DPRINTF(( "Too many private clipboard formats (%d max)", MAX_CFSTRUCTS ));
        return( 0 );
    } else {
        pCfStruct->cfFormat = (WORD) RegisterClipboardFormat( lpszCfName );
        lstrcpy( pCfStruct->cfName, lpszCfName );
        return( pCfStruct->cfFormat );

    }
#else // (#ifndef NOINTERNALCFS)
	return (WORD)RegisterClipboardFormat ( lpszCfName );
#endif
}

WORD
GetFormatForXfer(
    WORD    cfFormat,
    LPSTR   lpszFormatName )
{
    extern WORD wClipFmtInTouchDDE;

    if( cfFormat == 0 )  {
        lpszFormatName[0] = '\0';
        return( 0 );
    }

    if( cfFormat == wClipFmtInTouchDDE )  {
        lpszFormatName[0] = '\0';
        return( CF_INTOUCH_SPECIAL );
    } else if( cfFormat >= 0xC000 )  {
        GetClipboardFormatName( cfFormat, lpszFormatName, MAX_CF_NAME );
        return( cfFormat );
    } else {
        lpszFormatName[0] = '\0';
        return( cfFormat );
    }
}

LPDDEPKT
FAR PASCAL
CreateTestPkt(
    int     nTestNo,
    int     nPacket,
    int     nNum,
    DWORD   dwSize )
{
    LPDDEPKTTEST        lpDdePktTest;
    LPDDEPKT            lpDdePkt = NULL;
    LPDDEPKTCMN         lpDdePktCmn;

    lpDdePktTest = (LPDDEPKTTEST)HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize );
    if( lpDdePktTest )  {
        lpDdePkt = (LPDDEPKT) lpDdePktTest;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktTest;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_WWTEST;
        lpDdePktTest->dp_test_nTestNo           = (BYTE) nTestNo;
        lpDdePktTest->dp_test_nPktNo            = (BYTE) nPacket;
        lpDdePktTest->dp_test_nTotalPkts        = (BYTE) nNum;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_TEST",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}

LPDDEPKT
DdePktCopy( LPDDEPKT lpDdePktOld )
{
    LPDDEPKT    lpDdePktNew;

    lpDdePktNew = (LPDDEPKT) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        lpDdePktOld->dp_size );
    if( lpDdePktNew )  {
        hmemcpy( lpDdePktNew, lpDdePktOld, lpDdePktOld->dp_size );
    } else {
        /*  Unable to allocate enough (%1) memory for packet copy   */
        NDDELogError(MSG101, LogString("%d", lpDdePktOld->dp_size), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }
    return( lpDdePktNew );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\dbgdde.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DBGDDE.C;1  16-Dec-92,10:22:16  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "windows.h"
#include "dde.h"

#define LINT_ARGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "debug.h"
#include "dbgdde.h"

int     dbgDdeDataDisplayMax = 20;

VOID    FAR PASCAL GetFormatName( WORD, PSTR, int );

#if DBG
VOID
FAR PASCAL
DebugDDEMessage(
    PSTR            szType,
    HWND            hWnd,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam)
{
    BOOL        bShowAtomHi;
    BOOL        bShowAtomLo;
    char        atomName[ 256 ];
    char        atomNameLo[ 256 ];
    char        formatName[ 256 ];
    char        value[ 256 ];
    char        msgName[ 50 ];
    DDEDATA*    lpDdeData;
    WORD        cfFormat;
    HANDLE      hData;
    UINT_PTR    uLo, uHi;

    bShowAtomHi = TRUE;
    bShowAtomLo = FALSE;
    formatName[0] = '\0';
    value[0] = '\0';

    if( InSendMessage() && (message == WM_DDE_ACK) ) {
    	uLo = (UINT)(LOWORD(lParam));
    	uHi = (UINT)(HIWORD(lParam));
    } else {
    	if( !UnpackDDElParam( message, lParam, &uLo, &uHi ) ) {
    	    DPRINTF(("UnpackDDElParam() failed in DebugDDEMessage()"));
    	    return;
    	}
    }
    switch( message )  {
    case WM_DDE_ACK:
        strcpy( msgName, "WM_DDE_ACK" );
        break;

    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        switch( message )  {
        case WM_DDE_DATA:
            strcpy( msgName, "WM_DDE_DATA" );
            break;

        case WM_DDE_POKE:
            strcpy( msgName, "WM_DDE_POKE" );
            break;

        case WM_DDE_ADVISE:
            strcpy( msgName, "WM_DDE_ADVISE" );
            break;
        }
        hData = (HANDLE)uLo;
        if( hData )  {
            lpDdeData = (DDEDATA*)GlobalLock( hData );
            if( lpDdeData )  {
                cfFormat = lpDdeData->cfFormat;
                if( (dbgDdeDataDisplayMax != 0) && (cfFormat == CF_TEXT) )  {
                    if( message == WM_DDE_DATA )  {
                        sprintf( value, " \"%.*Fs\" %d/%d",
                            dbgDdeDataDisplayMax,
                            lpDdeData->Value,
                            lpDdeData->fResponse,
                            lpDdeData->fAckReq );
                    } else if( message == WM_DDE_POKE )  {
                        sprintf( value, " \"%.*Fs\"",
                            dbgDdeDataDisplayMax, lpDdeData->Value );
                    }
                } else {
                    if( message == WM_DDE_DATA )  {
                        sprintf( value, " %d/%d",
                            lpDdeData->fResponse,
                            lpDdeData->fAckReq );
                    }
                }
                GlobalUnlock( hData );
                GetFormatName( cfFormat, formatName, sizeof(formatName) );
            } else {
                strcpy( value, " NULL-Lock" );
            }
        }
        break;

    case WM_DDE_REQUEST:
        strcpy( msgName, "WM_DDE_REQUEST" );
        GetFormatName( (WORD)uLo, formatName, sizeof(formatName) );
        break;

    case WM_DDE_EXECUTE:
        bShowAtomHi = FALSE;
        hData = (HANDLE)uHi;
        if( hData )  {
            lpDdeData = (DDEDATA*)GlobalLock( hData );
            if( lpDdeData )  {
                value[0] = '\"';
                strncpy( value + 1, (LPSTR)lpDdeData, sizeof(formatName) - 2);
                value[sizeof(formatName) - 2] = '\0';
                strcat(value, "\"");
                GlobalUnlock( hData );
            }
        }
        strcpy( msgName, "WM_DDE_EXECUTE" );
        break;

    case WM_DDE_UNADVISE:
        strcpy( msgName, "WM_DDE_UNADVISE" );
        break;

    case WM_DDE_TERMINATE:
        bShowAtomHi = FALSE;
        strcpy( msgName, "WM_DDE_TERMINATE" );
        break;

    case WM_DDE_INITIATE:
        bShowAtomLo = TRUE;
        strcpy( msgName, "WM_DDE_INITIATE" );
        break;

    default:
        bShowAtomHi = FALSE;
        sprintf( msgName, "UNK(%04X)", message );
    }

    atomName[0] = '\0';
    if( bShowAtomHi )  {
        if( uHi )  {
            GlobalGetAtomName( (ATOM)uHi, atomName, sizeof(atomName) );
        } else {
            strcpy( atomName, "NULL!" );
        }
    }
    atomNameLo[0] = '\0';
    if( bShowAtomLo )  {
        if( uHi )  {
            GlobalGetAtomName( (ATOM)uLo, atomNameLo, sizeof(atomNameLo) );
        } else {
            strcpy( atomNameLo, "NULL!" );
        }
        strcat(atomNameLo, "|");
    }
    DPRINTF(( "%Fs %-16Fs %08X %08X %04X %04X [%Fs%Fs%Fs]%Fs",
        (LPSTR)szType, (LPSTR)msgName,
        hWnd, wParam, uLo, uHi, (LPSTR)atomNameLo, (LPSTR)atomName,
        (LPSTR)formatName, (LPSTR)value ));
}
#endif // DBG




VOID
FAR PASCAL
GetFormatName(
    WORD    cfFormat,
    PSTR    pszFormat,
    int     nMax)
{
    wsprintf( pszFormat, ":Format#%04X", cfFormat );

    switch( cfFormat )  {
    case CF_TEXT:
        lstrcpy( pszFormat, ":TEXT" );
        break;
    case CF_BITMAP:
        lstrcpy( pszFormat, ":BITMAP" );
        break;
    case CF_METAFILEPICT:
        lstrcpy( pszFormat, ":METAFILEPICT" );
        break;
    case CF_SYLK:
        lstrcpy( pszFormat, ":SYLK" );
        break;
    case CF_DIF:
        lstrcpy( pszFormat, ":DIF" );
        break;
    case CF_TIFF:
        lstrcpy( pszFormat, ":TIFF" );
        break;
    case CF_OEMTEXT:
        lstrcpy( pszFormat, ":OEMTEXT" );
        break;
    case CF_DIB:
        lstrcpy( pszFormat, ":DIB" );
        break;
    case CF_PALETTE:
        lstrcpy( pszFormat, ":PALETTE" );
        break;
    default:
        if( cfFormat >= 0xC000 )  {
            GetClipboardFormatName( cfFormat, &pszFormat[1], nMax-1 );
            pszFormat[0] = ':';
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\makefile.inc ===
$(O)\setup_netdde.c : nscommn.c ..\..\incs\shrtrust.h
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    setup_netdde.c

Abstract:

    This is used by syssetup to enable netdde.  It's generated from various files under
    windows\netdde.  Do not edit by hand.

Revision History:

--*/

<<
    type ..\..\incs\shrtrust.h >> $@
    hextract -o $@ -lt setup -bt begin_setup end_setup nscommn.c
    $(PUBLISH_CMD) {$@=$(PROJECT_INC_PATH)\setup_netdde.c}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\hexdump.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "HEXDUMP.C;1  16-Dec-92,10:22:30  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#define LINT_ARGS
#include        <stdio.h>
#include        <string.h>
#include        <ctype.h>
#include        "windows.h"
#include        "hexdump.h"
#include        "debug.h"

#if DBG
static char     buffer[200];
static char     buf1[50];
static char     buf2[50];

VOID
FAR PASCAL
hexDump(
    LPSTR    string,
    int      len)
{
    int         i;
    int         first = TRUE;

    buffer[0] = '\0';
    buf2[0] = '\0';

    for( i=0; i<len;  )  {
        if( (i++ % 16) == 0 )  {
            if( !first )  {
                strcat( buffer, buf2 );
                DPRINTF(( buffer ));
            }
            wsprintf( buffer, "  %08lX: ", string );
            strcpy( buf2, "   " );
            first = FALSE;
        }
        wsprintf( buf1, "%c", isprint((*string)&0xFF) ? *string&0xFF : '.' );
        strcat( buf2, buf1 );
        if( (i % 16) == 8 )  {
            strcat( buf2, "-" );
        }

        wsprintf( buf1, "%02X%c", *string++ & 0xFF,
            ((i % 16) == 8) ? '-' : ' ' );
        strcat( buffer, buf1 );
    }
    strcat( buffer, buf2 );
    DPRINTF(( buffer ));
    DPRINTF(( "" ));
}

#ifdef  DEBUG_HEAP
#define MAX_HEAP_ALLOCS 512

int     CurrentAllocs = 0;
int     MemAllocated = 0;

LPVOID AllocPtrs[MAX_HEAP_ALLOCS];
int    AllocSizes[MAX_HEAP_ALLOCS];

extern  BOOL    bDebugHeap;

int DebugHeapInit(void)
{
    int k;

    for (k = 0; k < MAX_HEAP_ALLOCS; k++) {
        AllocPtrs[k] = 0;
        AllocSizes[k] = 0;
    }
    return(1);
}

LPVOID DebugHeapAlloc(int size)
{
    LPVOID  ptr;
    int     k;

    if (bDebugHeap) {
        ptr = malloc(size);
        MemAllocated += size;
        CurrentAllocs++;
        DPRINTF(("Allocated: %08X:%05d, Total Allocs: %d, of: %d",
            ptr, size, CurrentAllocs, MemAllocated));
        if (CurrentAllocs >= MAX_HEAP_ALLOCS) {
            DPRINTF(("Too many heap chunks allocated without sufficient releases."));
            for (k = 0; k < MAX_HEAP_ALLOCS/4; k++) {
                DPRINTF(("%08X:%08X %08X:%08X %08X:%08X %08X:%08X",
                    AllocPtrs[k*4], AllocSizes[k*4],
                    AllocPtrs[k*4+1], AllocSizes[k*4+1],
                    AllocPtrs[k*4+2], AllocSizes[k*4+2],
                    AllocPtrs[k*4+3], AllocSizes[k*4+3] ));
            }
            exit(-1);
        }
        for ( k = 0; k < CurrentAllocs; k++ ) {
            if (AllocSizes[k] == 0) {
                AllocSizes[k] = size;
                AllocPtrs[k] = ptr;
                break;
            }
        }
        return(ptr);
    } else {
        return(malloc(size));
    }
}

void DebugHeapFree(LPVOID ptr)
{
    int k;

    if (bDebugHeap) {
        for (k = 0; k < MAX_HEAP_ALLOCS; k++) {
            if (AllocPtrs[k] == ptr) {
                if (AllocSizes[k] == 0) {
                    DPRINTF(("Redundant free of %08X!", ptr));
                    break;
                }
                MemAllocated -= AllocSizes[k];
                CurrentAllocs--;
                AllocSizes[k] = 0;
                break;
            }
        }
        if (k >= MAX_HEAP_ALLOCS) {
            DPRINTF(("Could not find %08X pointer!", ptr));
        }
        free(ptr);
    } else {
        free(ptr);
    }

}
#endif  // DEBUG_HEAP
#endif  // DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\ntddecmn\verify.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "VERIFY.C;1  16-Dec-92,10:21:36  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "host.h"
#include "windows.h"
#include "netbasic.h"
#include "netpkt.h"
#include "netintf.h"
#include "verify.h"
#include "crc.h"
#include "cks32.h"
#include "debug.h"
#include "internal.h"
#include "hexdump.h"

BOOL
FAR PASCAL VerifyHdr( LPNETPKT lpPacket )
{
    DWORD	chksum;
    WORD	crc;

    switch( lpPacket->np_verifyMethod )  {
    case VERMETH_CRC16:
	crc = 0xFFFF;
	crc_16( &crc,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	if( crc != (WORD)PcToHostLong(lpPacket->np_cksHeader) )  {
	    DPRINTF(( "Header CRC Err: %08lX vs. %08lX", (DWORD)crc, lpPacket->np_cksHeader ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT) );
	    return( FALSE );
	}
	break;
    case VERMETH_CKS32:
	Checksum32( &chksum,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	if( chksum != PcToHostLong(lpPacket->np_cksHeader) )  {
	    DPRINTF(( "Header CKS Err: %08lX vs. %08lX", chksum, lpPacket->np_cksHeader ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT) );
	    return( FALSE );
	}
	break;
    default:
	DPRINTF(( "VerifyHdr: VerifyMethod incorrect: %08lX", (DWORD)lpPacket->np_verifyMethod ));
	HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT) );
	/* if the verifyMethod isn't set properly - throw the header out */
	return( FALSE );
    }

    return( TRUE );
}

BOOL
FAR PASCAL VerifyData( LPNETPKT lpPacket )
{
    WORD	crc;
    DWORD	chksum;

    if( lpPacket->np_pktSize == 0 )  {
	/* no data, just return OK */
	return( TRUE );
    }

    switch( lpPacket->np_verifyMethod )  {
    case VERMETH_CRC16:
	crc = 0xFFFF;
	crc_16( &crc,
	    ((BYTE FAR *)&lpPacket->np_cksData)
		+ sizeof(lpPacket->np_cksData),
	    lpPacket->np_pktSize );
	if( crc != (WORD)PcToHostLong(lpPacket->np_cksData) )  {
	    DPRINTF(( "Data CRC Err: %08lX vs. %08lX", (DWORD)crc, lpPacket->np_cksData ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT)+lpPacket->np_pktSize );
	    return( FALSE );
	}
	break;
    case VERMETH_CKS32:
	Checksum32( &chksum,
	    ((BYTE FAR *)&lpPacket->np_cksData)
		+ sizeof(lpPacket->np_cksData),
	    lpPacket->np_pktSize );
	if( chksum != PcToHostLong(lpPacket->np_cksData) )  {
	    DPRINTF(( "Data CKS Err: %08lX vs. %08lX", (DWORD)chksum, lpPacket->np_cksData ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT)+lpPacket->np_pktSize );
	    return( FALSE );
	}
	break;
    default:
	DPRINTF(( "VerifyData: VerifyMethod incorrect: %08lX", (DWORD)lpPacket->np_verifyMethod ));
	HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT)+lpPacket->np_pktSize );
	/* if the verifyMethod isn't set properly - throw the header out */
	return( FALSE );
    }
    return( TRUE );
}

VOID
FAR PASCAL PreparePktVerify( BYTE verifyMethod, LPNETPKT lpPacket )
{
    WORD	crc;
    DWORD	chksum;

    lpPacket->np_verifyMethod = verifyMethod;

    switch( lpPacket->np_verifyMethod )  {
    case VERMETH_CRC16:
	/* verify data */
	if( HostToPcWord( lpPacket->np_pktSize ) != 0 )  {
	    crc = 0xFFFF;
	    crc_16( &crc,
		((BYTE FAR *)&lpPacket->np_cksData)
		    + sizeof(lpPacket->np_cksData),
		HostToPcWord( lpPacket->np_pktSize ) );
	    lpPacket->np_cksData = HostToPcLong( (DWORD)crc );
	} else {
	    lpPacket->np_cksData = 0;
	}

	/* verify hdr */
	crc = 0xFFFF;
	crc_16( &crc,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	lpPacket->np_cksHeader = HostToPcLong( (DWORD)crc );
	break;
    case VERMETH_CKS32:
	/* verify data */
	if( HostToPcWord( lpPacket->np_pktSize ) != 0 )  {
	    Checksum32( &chksum,
		((BYTE FAR *)&lpPacket->np_cksData)
		    + sizeof(lpPacket->np_cksData),
		HostToPcWord( lpPacket->np_pktSize ) );
	    lpPacket->np_cksData = HostToPcLong( chksum );
	} else {
	    lpPacket->np_cksData = 0;
	}
	
	/* verify hdr */
	Checksum32( &chksum,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	lpPacket->np_cksHeader = HostToPcLong( chksum );
	break;
    default:
	InternalError( "PreparePkt: VerifyMethod incorrect: %08lX",
	    (DWORD)lpPacket->np_verifyMethod );
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\nddelog.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDELOG.C;2  27-Jan-93,15:51:56  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <windows.h>
#include    <stdio.h>
#include    <stdarg.h>
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "debug.h"


extern BOOL	bNDDELogInfo;
extern BOOL bNDDELogWarnings;
extern BOOL bNDDELogErrors;


VOID
NDDELogEventA(
    DWORD  EventId,                // message id
    WORD   fwEventType,            // event type
    WORD   cStrings,               // how many strings
    LPSTR *aszMsg)                 // pointer to strings
{
    HANDLE  hLog;
    BOOL    ok;

    hLog = RegisterEventSourceA(NULL, "NetDDE");
    if (hLog == NULL) {
        DPRINTF(( "Unable to register event source. (%d) msg:%d",
            GetLastError(), EventId ));
    } else {
        ok = ReportEventA(hLog, fwEventType,
            0, EventId, NULL, cStrings, 0,
            aszMsg, NULL);
        if (!ok) {
            DPRINTF(( "Error logging event. (%d) msg:%d",
                GetLastError(), EventId ));
        }
        DeregisterEventSource(hLog);
    }
}


VOID
NDDELogEventW(
    DWORD  EventId,                // message id
    WORD   fwEventType,            // event type
    WORD   cStrings,               // how many strings
    LPWSTR *aszMsg)                // pointer to strings
{
    HANDLE  hLog;
    BOOL    ok;

    hLog = RegisterEventSourceW(NULL, L"NetDDE");
    if (hLog == NULL) {
        DPRINTF(( "Unable to register event source. (%d) msg:%d",
            GetLastError(), EventId ));
    } else {
        ok = ReportEventW(hLog, fwEventType,
            0, EventId, NULL, cStrings, 0,
            aszMsg, NULL);
        if (!ok) {
            DPRINTF(( "Error logging event. (%d) msg:%d",
                GetLastError(), EventId ));
        }
        DeregisterEventSource(hLog);
    }
}


VOID
NDDELogDataA(
    DWORD   EventId,                // message id
    DWORD   cbData,                 // number of data bytes
    LPVOID  lpvData)                // pointer to raw data
{
    HANDLE  hLog;
    BOOL    ok;

    if (!bNDDELogInfo) {
        return;
    }
    hLog = RegisterEventSourceA(NULL, "NetDDE");
    if (hLog == NULL) {
        DPRINTF(( "Unable to register event source. (%d) msg:%d",
            GetLastError(), EventId ));
    } else {
        ok = ReportEventA(hLog, EVENTLOG_INFORMATION_TYPE,
            0, EventId, NULL, 0, cbData,
            NULL, lpvData);
        if (!ok) {
            DPRINTF(( "Error logging event. (%d) msg:%d",
                GetLastError(), EventId ));
        }
        DeregisterEventSource(hLog);
    }
}

VOID
NDDELogDataW(
    DWORD   EventId,                // message id
    DWORD   cbData,                 // number of data bytes
    LPVOID  lpvData)                // pointer to raw data
{
    HANDLE  hLog;
    BOOL    ok;

    if (!bNDDELogInfo) {
        return;
    }
    hLog = RegisterEventSourceW(NULL, L"NetDDE");
    if (hLog == NULL) {
        DPRINTF(( "Unable to register event source. (%d) msg:%d",
            GetLastError(), EventId ));
    } else {
        ok = ReportEventW(hLog, EVENTLOG_INFORMATION_TYPE,
            0, EventId, NULL, 0, cbData,
            NULL, lpvData);
        if (!ok) {
            DPRINTF(( "Error logging event. (%d) msg:%d",
                GetLastError(), EventId ));
        }
        DeregisterEventSource(hLog);
    }
}

VOID
NDDELogErrorA(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPSTR   aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogErrors) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPSTR);

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventA(EventId, EVENTLOG_ERROR_TYPE, count, (LPSTR *) aszMsg);
    } else {
        NDDELogEventA(EventId, EVENTLOG_ERROR_TYPE, 0, NULL);
    }
}

VOID
NDDELogErrorW(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPWSTR  aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogErrors) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPWSTR);

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPWSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventW(EventId, EVENTLOG_ERROR_TYPE, count, (LPWSTR *) aszMsg);
    } else {
        NDDELogEventW(EventId, EVENTLOG_ERROR_TYPE, 0, NULL);
    }
}

VOID
NDDELogWarningA(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPSTR   aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogWarnings) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventA(EventId, EVENTLOG_WARNING_TYPE, count, (LPSTR *)aszMsg);
    } else {
        NDDELogEventA(EventId, EVENTLOG_WARNING_TYPE, 0, NULL);
    }
}

VOID
NDDELogWarningW(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPWSTR  aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogWarnings) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPWSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPWSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventW(EventId, EVENTLOG_WARNING_TYPE, count,(LPWSTR *)aszMsg);
    } else {
        NDDELogEventW(EventId, EVENTLOG_WARNING_TYPE, 0, NULL);
    }
}

VOID
NDDELogInfoA(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPSTR   aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;


    if (!bNDDELogInfo) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPSTR );
    }

    va_end(arg_ptr);

    if (count) {
       NDDELogEventA(EventId,EVENTLOG_INFORMATION_TYPE,count,(LPSTR *)aszMsg);
    } else {
       NDDELogEventA(EventId, EVENTLOG_INFORMATION_TYPE, 0, NULL);
    }
}

VOID
NDDELogInfoW(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPWSTR  aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;


    if (!bNDDELogInfo) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPWSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPWSTR );
    }

    va_end(arg_ptr);

    if (count) {
      NDDELogEventW(EventId,EVENTLOG_INFORMATION_TYPE,count,(LPWSTR *)aszMsg);
    } else {
      NDDELogEventW(EventId, EVENTLOG_INFORMATION_TYPE, 0, NULL);
    }
}

LPSTR
LogStringA( LPSTR   lpFormat, ...)
{
    static char szStringBuf[MAX_VAR_ARGS][MAX_LOG_STRING];
    static int  nextString = 0;
    va_list	marker;

    LPSTR   lpCurrent = (LPSTR) szStringBuf[nextString++];

    va_start(marker, lpFormat);
    vsprintf(lpCurrent, lpFormat, marker);
    if (nextString == MAX_VAR_ARGS) {
        nextString = 0;
    }
    va_end(marker);
    return(lpCurrent);
}

LPWSTR
LogStringW( LPWSTR   lpFormat, ...)
{
    static wchar_t szStringBufW[MAX_VAR_ARGS][MAX_LOG_STRING];
    static int   nextStringW = 0;
    va_list	 marker;

    LPWSTR   lpCurrent = (LPWSTR) szStringBufW[nextStringW++];

    va_start(marker, lpFormat);
    vswprintf(lpCurrent, lpFormat, marker);
    if (nextStringW == MAX_VAR_ARGS) {
        nextStringW = 0;
    }
    va_end(marker);
    return(lpCurrent);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\toolkit.c ===
#include "windows.h"

int
WinMain( HINSTANCE x, HINSTANCE y, LPSTR z, int a )
{
return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\nscommn.c ===
/*
 * NSCOMMN.C    (Netdde-Setup COMMoN code)
 *
 * Code common to NetDDE setup utilities and NT setup
 */
#include    <windows.h>   // required for all Windows applications
#include    <string.h>
#include    <stdlib.h>
#include    <stdio.h>
#include	<time.h>

#include    "shrtrust.h"

// begin_setup

#if DBG
#define KdPrint(_x_) DbgPrint _x_
#else
#define KdPrint(_x_)
#endif

ULONG DbgPrint(PCH Format, ...);

BOOL GetDBSerialNumber(DWORD *lpdwId);
BOOL GetDBInstance(char *lpszBuf);

TCHAR    szShareKey[] = DDE_SHARES_KEY;
CHAR    szSetup[] = "NetDDE Setup";

#define	SHARES_TO_INIT 3

CHAR *szShareNames[SHARES_TO_INIT] = {
    "Chat$"     ,
    "Hearts$"   ,
    "CLPBK$"
};

BOOL
CreateShareDBInstance()
{
    HKEY            hKey;
    LONG            lRtn;
    BOOL            bOK = TRUE;
    DWORD           InstanceId;
    time_t          time_tmp;

    /*  Create the DDE Share database in the registry if it does not exist. */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		  szShareKey,
		  0,
		  KEY_SET_VALUE,
		  &hKey );

    if( lRtn == ERROR_SUCCESS ) {
        /*
         * create data base instance value
         */
        srand((int) time(&time_tmp));
        InstanceId = rand() * rand();
        lRtn = RegSetValueEx( hKey,
            KEY_DB_INSTANCE, 0,
            REG_DWORD,
            (LPBYTE)&InstanceId,
            sizeof( DWORD ) );
        if( lRtn == ERROR_SUCCESS ) {
        } else {
            KdPrint(("SETUPDLL: CreateShareDBInstnace: RegSetValueEx %x failed (%u)\n",InstanceId,lRtn));
            bOK = FALSE;
        }
        RegCloseKey( hKey );
    } else {
    /* Share DB key should have been created from default hives */
        KdPrint(("SETUPDLL: CreateShareDBInstnace: RegOpenKey %s failed (%u)\n",szShareKey,lRtn));
        bOK = FALSE;
    }
    return(bOK);
}

BOOL
CreateDefaultTrust(
HKEY hKeyUserRoot)
{
    HKEY    hKey;
    DWORD   dwDisp;
    DWORD   ret;
    BOOL    bOK;
    char    szTrustedShareKey[TRUSTED_SHARES_KEY_MAX];
    char    szShareKey[DDE_SHARE_KEY_MAX];
    char    szDBInstance[TRUSTED_SHARES_KEY_SIZE + 1];
    DWORD   dwId[2];
    DWORD   dwFlag;
    int	    nLoop;


    if (!GetDBInstance(szDBInstance)) {
        return(FALSE);
    }

    if (!GetDBSerialNumber(dwId)) {
        KdPrint(("SETUPDLL: CreateDefaultTrust: GetDBSerialNumber failed.\n"));
        return(FALSE);
    }

    for (nLoop = 0, bOK = TRUE;
        (nLoop < SHARES_TO_INIT) && bOK ;
            nLoop++) {
        /*
         * For each share to init...
         */

        KdPrint(("Shareing %s\n", szShareNames[nLoop]));

        /*
         * Build up szTrustedSharesKey IAW the DBInstance sring.
         */
        sprintf( szTrustedShareKey,
                "%s\\%s\\%s",
                TRUSTED_SHARES_KEY_A,
                szDBInstance,
                szShareNames[nLoop] );

        /*
         * Create the trusted share key (hKey)
         */
        ret = RegCreateKeyExA( hKeyUserRoot, szTrustedShareKey,
        		0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
        		NULL,
        		&hKey,
        		&dwDisp );

        if( ret != ERROR_SUCCESS )  {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegCreateKeyEx failed on HKEY_CURRENT_USER\\%s. (%u)\n",
                    szTrustedShareKey, ret));
            return(FALSE);
        }

        /*
         * Get the serial number of the database.  Note that the SN of each
         * trust share must == the SN of the database.  Since the non-trusted
         * shares may not have the latest database SN, update all of them to
         * the current database SN as well.  This allows apps like winchat to
         * work when they are called from outside the machine even though they
         * have never been run - which would fix the SNs of their trusts because
         * they automatically set up their trusts.
         */

        /*
         * Set the SN of the trusted share
         */
        ret = RegSetValueEx( hKey,
		       KEY_MODIFY_ID,
		       0,
		       REG_BINARY,
		       (LPBYTE)&dwId,
		       KEY_MODIFY_ID_SIZE );

        if (ret == ERROR_SUCCESS) {
            /*
             * set the StartApp flag to 1
             */
            dwFlag = 1;
            ret = RegSetValueEx( hKey,
                KEY_START_APP,
                0,
                REG_DWORD,
                (LPBYTE)&dwFlag,
                sizeof( DWORD ) );

            if (ret == ERROR_SUCCESS) {
                /*
                 * Set the InitAllowed flag to 1 too.
                 */
   	            ret = RegSetValueEx( hKey,
                    KEY_INIT_ALLOWED,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwFlag,
                    sizeof( DWORD ) );
            }
	    }

        RegCloseKey(hKey);

		if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx failed (%u)\n",ret));
            return(FALSE);
        }

        /*
         * Build up szShareKey
         */
        sprintf( szShareKey,
            "%s\\%s",
            DDE_SHARES_KEY_A,
            szShareNames[nLoop] );

        /*
         * Now open up the base share
         */
        ret = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                szShareKey,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
        		&hKey);

		if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegOpenKeyEx failed on HKEY_LOCAL_MACHINE\\%s. (%u)\n",
                    szShareKey, ret));
            if (ret != ERROR_ACCESS_DENIED) {
                return(FALSE);
            }
        }

        if (ret == ERROR_SUCCESS) {
            ret = RegSetValueEx( hKey,
    		       KEY_MODIFY_ID,
    		       0,
    		       REG_BINARY,
    		       (LPBYTE)&dwId,
    		       KEY_MODIFY_ID_SIZE );

            RegCloseKey(hKey);

    		if (ret != ERROR_SUCCESS) {
                KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx on HKEY_LOCAL_MACHINE\\%s failed (%u)\n",
                        KEY_MODIFY_ID, ret));
                return(FALSE);
            }
        }

    } // end for

    return(TRUE);
}



BOOL
GetDBInstance(char *lpszBuf)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwInstance;
    DWORD   dwType = REG_DWORD;
    DWORD   cbData = sizeof(DWORD);

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegOpenKeyEx %s failed (%u)\n",szShareKey,lRtn));
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_DB_INSTANCE,
                NULL,
                &dwType,
                (LPBYTE)&dwInstance, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegQueryValueEx failed (%u)\n",lRtn));
        return(FALSE);
    }
    sprintf(lpszBuf, "%s%08X", TRUSTED_SHARES_KEY_PREFIX, dwInstance);
    return(TRUE);
}

BOOL
GetDBSerialNumber(
DWORD *lpdwId)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwType = REG_BINARY;
    DWORD   cbData = KEY_MODIFY_ID_SIZE;

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_MODIFY_ID,
                NULL,
                &dwType,
                (LPBYTE)lpdwId, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    return(TRUE);
}

// end_setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\dump.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DUMP.C;1  16-Dec-92,10:22:22  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "windows.h"
#include "debug.h"
#include <string.h>

/*  Functions declared in 'debug.h' */

BOOL
DumpDacl( LPTSTR szDumperName, PSECURITY_DESCRIPTOR pSD )
{
    PACCESS_ALLOWED_ACE	pAce;
    PACCESS_DENIED_ACE	pDAce;
    TCHAR			szAceType[ 50 ];
    DWORD			i;
    PSID			pSid;
    PACL			pAcl;
    BOOL			OK, bDaclDefaulted, bDaclPresent;

    /* Dump Dacl entries. */
    DPRINTF(("======================="));
    OK = GetSecurityDescriptorDacl( pSD, &bDaclPresent,
				    &pAcl, &bDaclDefaulted );
    if( OK ) {
	DPRINTF(("%s - AceCount = %d", szDumperName, pAcl->AceCount));
	for( i=0; i < (DWORD)pAcl->AceCount; i++ ) {
	    OK = GetAce( pAcl, i, (LPVOID *)&pAce );
	    if( !OK ) {
		return FALSE;
	    }
	    pDAce = (ACCESS_DENIED_ACE *)pAce;
	    pSid = (PSID)&pAce->SidStart;
	    switch( pAce->Header.AceType ) {
	    case ACCESS_ALLOWED_ACE_TYPE:
		strcpy( szAceType, "ACCESS_ALLOWED_ACE_TYPE" );
		break;
	    case ACCESS_DENIED_ACE_TYPE:
		strcpy( szAceType, "ACCESS_DENIED_ACE_TYPE" );
		break;
	    case SYSTEM_AUDIT_ACE_TYPE:
		strcpy( szAceType, "SYSTEM_AUDIT_ACE_TYPE" );
		break;
	    case SYSTEM_ALARM_ACE_TYPE:
		strcpy( szAceType, "SYSTEM_ALARM_ACE_TYPE" );
		break;
	    default:
		strcpy( szAceType, "Unknown ACE type" );
		break;
	    }
	    DPRINTF(("%s - pAce     = (%p)", szDumperName, pAce));
	    DPRINTF(("%s - AceType  = (%s)", szDumperName, szAceType));
	    DPRINTF(("%s - AceFlags = (%x)", szDumperName, pAce->Header.AceFlags));
	    DPRINTF(("%s - AceSize  = (%d)", szDumperName, pAce->Header.AceSize));
	    DPRINTF(("%s - AceMask  = (%x)", szDumperName, pAce->Mask));
	    DPRINTF(("%s - pSid     = (%p)", szDumperName, pSid));
	    DumpSid( szDumperName, pSid );
	}
    }

    return OK;
}

BOOL
DumpSid( LPTSTR szDumperName, PSID pSid )
{
    SID_NAME_USE	snu;
    TCHAR		szNull[ 50 ];
    TCHAR		szAccountName[ 5000 ];
    TCHAR		szDomainName[ 5000 ];
    DWORD		dwAccountName;
    DWORD		dwDomainName;
    BOOL		OK;
    DWORD		dwSidLen;
    DWORD		dwSsaCount;
    int			i;
    PSID_IDENTIFIER_AUTHORITY pSidAuthority;

    szNull[0] = '\0';
    OK        = FALSE;

    if( IsValidSid( pSid ) ) {
	dwSidLen      = GetLengthSid( pSid );
	dwSsaCount    = (DWORD) *GetSidSubAuthorityCount( pSid );
	pSidAuthority = GetSidIdentifierAuthority( pSid );
	DPRINTF(("%s - Sid Length        = (%d)", szDumperName, dwSidLen));
	DPRINTF(("%s - Sid SA Count      = (%d)", szDumperName, dwSsaCount));
	DPRINTF(("%s - Sid ID Authority  = {%x,%x,%x,%x,%x,%x}", szDumperName,
	    pSidAuthority->Value[0],
	    pSidAuthority->Value[1],
	    pSidAuthority->Value[2],
	    pSidAuthority->Value[3],
	    pSidAuthority->Value[4],
	    pSidAuthority->Value[5]));
	for( i=0; i<(int)dwSsaCount; i++ ) {
	    DPRINTF(("%s - Sid Sub Authority = {%x}", szDumperName,
		    *GetSidSubAuthority( pSid, i )));
	}
	dwAccountName = 5000;
	dwDomainName  = 5000;
	OK = LookupAccountSid( szNull, pSid,
			       szAccountName, &dwAccountName,
			       szDomainName,  &dwDomainName, &snu);
	if( OK ) {
	    DPRINTF(("%s - AccountName       = (%s)", szDumperName,
		szAccountName));
	    DPRINTF(("%s - DomainName        = (%s)", szDumperName,
		szDomainName));
	    DPRINTF(("%s - Name Use          = (%d)", szDumperName,
		snu));
	} else {
	    /* Do other types of checking -- SidPrefix? Authority? */
	    DPRINTF(("%s - No Sid Account    = (%d)", szDumperName,
		GetLastError()));
	}
    } else {
	DPRINTF(("%s - IsValidSid        = (%d)", szDumperName, GetLastError()));
    }

    return OK;
}

VOID
DumpToken( HANDLE hToken )
{
    char	buf[ 5000 ];
    DWORD	dwSize;
    BOOL	ok;
    PTOKEN_USER pTU = (PTOKEN_USER)buf;

    ok = GetTokenInformation( hToken, TokenUser, buf, sizeof(buf), &dwSize );
    if( ok )  {
        DumpSid( "LoggedOn Token User", pTU->User.Sid );
        ok = GetTokenInformation( hToken, TokenOwner, buf, sizeof(buf), &dwSize );
        if( ok )  {
            DumpSid( "LoggedOn Token Owner", pTU->User.Sid );
        } else {
            DPRINTF(( "GetTokenInfo Owner failed: %d", GetLastError() ));
        }
    } else {
        DPRINTF(( "GetTokenInfo User failed: %d", GetLastError() ));
    }
}

BOOL
GetTokenUserDomain( HANDLE hToken, PSTR user, DWORD nUser,
    PSTR domain, DWORD nDomain )
{
    BOOL            ok = TRUE;
    HANDLE          hMemory = 0;
    TOKEN_USER    * pUserToken = NULL;
    char            pComputerName[] = "";
    DWORD           UserTokenLen;
    PSID            pUserSID;
    SID_NAME_USE    UserSIDType;

    user[0] = '\0';
    domain[0] = '\0';

    ok = GetTokenInformation( hToken, TokenUser,
        pUserToken, 0, &UserTokenLen);
    if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        hMemory = LocalAlloc(LPTR, UserTokenLen);
        if (hMemory) {
            pUserToken = (TOKEN_USER *)LocalLock(hMemory);
            ok = GetTokenInformation( hToken, TokenUser,
                pUserToken, UserTokenLen, &UserTokenLen );
        } else {
            // MEMERROR();
        }
    }
    if (ok) {
        pUserSID = pUserToken->User.Sid;
        ok = LookupAccountSid(pComputerName,
            pUserSID,
            user,
            &nUser,
            domain,
            &nDomain,
            &UserSIDType);
    }

    return( ok );
}

void
DumpWhoIAm( LPSTR lpszMsg )
{
    HANDLE      hToken;
    char        user[100], domain[100];

    if( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE,
            &hToken )) {
        GetTokenUserDomain( hToken, user, 100, domain, 100 );
        DPRINTF(( "%s: THREAD: %s\\%s", lpszMsg, domain, user ));
    } else if( OpenProcessToken( GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken )) {
        GetTokenUserDomain( hToken, user, 100, domain, 100 );
        DPRINTF(( "%s: PROCESS: %s\\%s", lpszMsg, domain, user ));
    } else {
        DPRINTF(( "%s: PROCESS: couldn't open tokens", lpszMsg ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\ntdebug.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NTDEBUG.C;1  16-Dec-92,10:22:54  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#include <time.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "windows.h"
#include "hardware.h"
#include "proflspt.h"

char szDebugFileName[256] = "netdde.log";
static char szAppName[128] = "NetDDE";
static BOOL bDebugEnabled;
BOOL fPrintToDebugger = FALSE;

#define MAX_LINE_LEN1    1024
#define MAX_LINE_LEN2    1280

void
print_buf(char *pbuf)
{
    FILE    *fp;

    fp = fopen(szDebugFileName, "at");
    if( fp )  {
    	fputs(pbuf, fp);
    	fclose(fp);
    }
    if (fPrintToDebugger)
        OutputDebugStringA(pbuf);
}

VOID
_cdecl
debug( LPSTR name1, ...)

{
    char       *buf1;
    char       *buf2;
    char        stime[ 27 ];
    char       *p;
    time_t      curtime;
    va_list	marker;


    if( !bDebugEnabled )  {
	    return;
    }

    if ( NULL == (buf1 = LocalAlloc(GPTR, MAX_LINE_LEN1)) )  {
        return;
    }
    if ( NULL == (buf2 = LocalAlloc(GPTR, MAX_LINE_LEN2)) )  {
        LocalFree(buf1);
        return;
    }

    time( &curtime );
    strcpy( stime, ctime(&curtime) );
    stime[24] = '\0';

    strcpy(buf2, name1);
    p = buf2;
    while (p = strstr(p, "%F")) {
        strcpy(p+1, p+2);
    }

    va_start(marker, name1);
    _vsnprintf( buf1, MAX_LINE_LEN1, buf2,  marker );
    _snprintf(  buf2, MAX_LINE_LEN2, "%s %-8s %s\n", stime, szAppName, buf1 );
    print_buf(buf2);
    va_end(marker);

    LocalFree(buf1);
    LocalFree(buf2);
}

void
_cdecl
InternalError( LPSTR   name1, ... )
{
    char       *buf1;
    char       *buf2;
    char        stime[ 27 ];
    time_t      curtime;
    va_list	marker;

    if ( NULL == (buf1 = LocalAlloc(GPTR, MAX_LINE_LEN1)) )  {
        return;
    }
    if ( NULL == (buf2 = LocalAlloc(GPTR, MAX_LINE_LEN2)) )  {
        LocalFree(buf1);
        return;
    }

    time( &curtime );
    strcpy( stime, ctime(&curtime) );
    stime[24] = '\0';
    va_start(marker, name1);
    _vsnprintf( buf1, MAX_LINE_LEN1, name1, marker );
    _snprintf(  buf2, MAX_LINE_LEN2, "INTERNAL ERROR: %s %s\n", stime, buf1 );
    print_buf(buf2);

    LocalFree(buf1);
    LocalFree(buf2);
}

void
FAR PASCAL
AssertLog(
    LPSTR   filename,
    int     len )
{
    char       *buf;
    char        stime[ 27 ];
    time_t      curtime;

    if ( NULL == (buf = LocalAlloc(GPTR, MAX_LINE_LEN1)) )  {
        return;
    }
    time( &curtime );
    strcpy( stime, ctime(&curtime) );
    stime[24] = '\0';

    _snprintf( buf, MAX_LINE_LEN1, "ASSERTION: %s %s Line %d\n", stime, filename, len );
    print_buf( buf );

    LocalFree(buf);
}


VOID
FAR PASCAL
DebugInit( LPSTR lpszDebugName )
{
    char szDebugDir[256] = "netdde.log";

    GetSystemDirectory( szDebugDir, sizeof(szDebugDir) );
    MyGetPrivateProfileString( "General", "DebugPath",
        szDebugDir, szDebugFileName, sizeof(szDebugFileName), "netdde.ini");
    lstrcat( szDebugFileName, "\\netdde.log" );

    bDebugEnabled = MyGetPrivateProfileInt( "General", "DebugEnabled",
	    TRUE, "netdde.ini" );

    lstrcpy( szAppName, lpszDebugName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\udspt.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "UDSPT.C;1  16-Dec-92,10:23:14  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#define LINT_ARGS
#include <stdio.h>
#include "windows.h"
#include "tmpbuf.h"

extern char     szAppName[];

PSTR
FAR PASCAL
GetAppName(void)
{
    return( szAppName );
}

/*
    This routine is a general way to get memory.
 */

HANDLE
FAR PASCAL
GetGlobalAlloc(
    WORD    wFlags,
    DWORD   lSize)
{
    HANDLE      hMem;

    /* try the regular alloc first */
    hMem = GlobalAlloc( wFlags, lSize );
    if( hMem == (HANDLE) NULL )  {

        /* try compacting the global heap */
        GlobalCompact( (DWORD)0x7FFFFFFFL );
        hMem = GlobalAlloc( wFlags, lSize );
    }

    if( hMem == (HANDLE) NULL )  {
        wsprintf( tmpBuf, "Out of Memory (%ld bytes needed)", lSize );
        MessageBox( GetFocus(), tmpBuf, GetAppName(),
            MB_OK | MB_ICONHAND | MB_SYSTEMMODAL );
    }

    return( hMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\trustshr\dialogs.h ===
#define IDC_SHARENAME               101
#define IDC_MODIFYID                102
#define IDC_UPDATE_MODIFYID         103
#define IDC_CMDSHOW		    104
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\trustshr\dialogs.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DIALOGS.C;1  16-Dec-92,10:24:02  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#ifdef WIN32
#include "api1632.h"
#endif
#define LINT_ARGS
#include <string.h>
#include <stdlib.h>
#include "windows.h"
#include "trustshr.h"
#include "shrtrust.h"
#include "dialogs.h"
#include "nddeapi.h"

ULONG	uCreateParam;

extern char *lpCommonTree;
extern char szApp[];

BOOL GetNddeShareModifyId(  LPSTR lpszShareName,  LPDWORD lpdwId );
BOOL FAR PASCAL AddShareDlg(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
{
    static BOOL     fPropertiesCalled;

    switch (message) {
    case WM_INITDIALOG:		   /* message: initialize dialog box */
	lParam = uCreateParam;
	if( lParam ) {
        DWORD   dwDisp;
	    UINT 	ret;
	    HKEY 	hKey;
	    char	szShareKey[ 1024 ];
	    char	szVal[ 100 ];
	    extern char	szComputerName[];
        extern char szDBInstance[];

	    fPropertiesCalled = TRUE;

	    wsprintf( szShareKey, "%s\\%s\\%s", lpCommonTree,
		szDBInstance, (LPSTR)lParam );
	    ret = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                szShareKey,
		        0,
                L"",
                KEY_READ,
                &hKey,
                &dwDisp );

	    if( ret == ERROR_SUCCESS )  {
    		DWORD	dwId[2];
    		DWORD	cbId = sizeof(dwId);
    		UINT	fuCmdShow;
    		DWORD	cbShow = sizeof(fuCmdShow);
    		DWORD	dwType = REG_BINARY;
    		
    		SendDlgItemMessage ( hDlg, IDC_SHARENAME, EM_SETREADONLY,
    		    TRUE, 0L);

    		SetDlgItemText ( hDlg, IDC_SHARENAME, (LPSTR)lParam );
    		if( RegQueryValueEx( hKey, KEY_MODIFY_ID, NULL, &dwType,
    		    (LPBYTE)&dwId, &cbId ) == ERROR_SUCCESS )  {
    		    wsprintf( szVal, "%08lX%08lX", dwId[0], dwId[1] );
    		    SetDlgItemText( hDlg, IDC_MODIFYID, szVal );
    		}
    		if( RegQueryValueEx( hKey, KEY_CMDSHOW, NULL, &dwType,
    		    (LPBYTE)&fuCmdShow, &cbShow ) == ERROR_SUCCESS )  {
    		    wsprintf( szVal, "%d", fuCmdShow );
    		    SetDlgItemText( hDlg, IDC_CMDSHOW, szVal );
    		} else {
    		    SetDlgItemText( hDlg, IDC_CMDSHOW, "0" );
    		}
    		RegCloseKey( hKey );
	    }
	} else {
	    fPropertiesCalled = FALSE;
	    SetDlgItemText( hDlg, IDC_MODIFYID, "0000000000000000" );
	}
	SetFocus( GetDlgItem( hDlg, IDC_SHARENAME ) );
	return( FALSE );

    case WM_COMMAND:
	switch ( LOWORD(wParam) ) {
	case IDC_UPDATE_MODIFYID:
	    {
		char	szShareName[ 512 ];
		char	szVal[ 512 ];
		DWORD	dwId[2];

		SendDlgItemMessage ( hDlg, IDC_SHARENAME, WM_GETTEXT,
		    MAX_NDDESHARENAME, (LPARAM)(LPSTR)szShareName );
		if( GetNddeShareModifyId( szShareName, &dwId[0] ) )  {
		    wsprintf( szVal, "%08lX%08lX", dwId[0], dwId[1] );
		    SetDlgItemText( hDlg, IDC_MODIFYID, szVal );
		}
	    }
	    break;
	case IDOK:
	    {
		char	szShareName[ 512 ];
		char	szShareKey[ 1024 ];
		char	szModifyId[ 1024 ];
		char	szTmp[ 20 ];
		DWORD	dwDisp;
		DWORD	ret;
		BOOL	ok;
		HKEY	hKey;
		DWORD	dwId[2];
		DWORD	cbId = sizeof(dwId);
		UINT	fuCmdShow;
		DWORD	cbShow = sizeof(fuCmdShow);
		extern char	szComputerName[];
        extern char szDBInstance[];

		SendDlgItemMessage ( hDlg, IDC_SHARENAME, WM_GETTEXT,
		    MAX_NDDESHARENAME, (LPARAM)(LPSTR)szShareName );
		SendDlgItemMessage ( hDlg, IDC_MODIFYID, WM_GETTEXT,
		    sizeof(szModifyId), (LPARAM)(LPSTR)szModifyId );
		if( strlen(szModifyId ) != 16 )  {
		    MessageBox( NULL, "SerialNumber must be 16 hex digits",
			szApp, MB_TASKMODAL | MB_ICONSTOP | MB_OK );
		    SetFocus( GetDlgItem( hDlg, IDC_MODIFYID ) );
		    return( TRUE );
		}
		fuCmdShow = GetDlgItemInt( hDlg, IDC_CMDSHOW, &ok, TRUE );
		if( !ok )  {
		    MessageBox( NULL, "Invalid CmdShow",
			szApp, MB_TASKMODAL | MB_ICONSTOP | MB_OK );
		    SetFocus( GetDlgItem( hDlg, IDC_CMDSHOW ) );
		    return( TRUE );
		}
		wsprintf( szShareKey, "%s\\%s\\%s", lpCommonTree,
		    szDBInstance, szShareName );
		ret = RegCreateKeyEx( HKEY_CURRENT_USER, szShareKey,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_WRITE,
		    NULL,
		    &hKey,
		    &dwDisp );
		if( ret == ERROR_SUCCESS )  {
		    char	*px;

		    _fstrncpy( szTmp, szModifyId, 8 );
		    szTmp[8] = '\0';
		    dwId[0] = strtol( szTmp, &px, 16 );

		    _fstrncpy( szTmp, &szModifyId[8], 8 );
		    szTmp[8] = '\0';
		    dwId[1] = strtol( szTmp, &px, 16 );

		    ret = RegSetValueEx( hKey,
		       KEY_MODIFY_ID,
		       0,
		       REG_BINARY,
		       (LPBYTE)&dwId,
		       cbId );
		    ret = RegSetValueEx( hKey,
		       KEY_CMDSHOW,
		       0,
		       REG_DWORD,
		       (LPBYTE)&fuCmdShow,
		       cbShow );

		    RegCloseKey( hKey );
		}
			
		if ( ret == ERROR_SUCCESS )  {
		    EndDialog(hDlg, TRUE);
		} else {
		    MessageBox( NULL, "Error interfacing with registry",
			szApp, MB_TASKMODAL | MB_ICONSTOP | MB_OK );
		    SetFocus( GetDlgItem( hDlg, IDC_SHARENAME ) );
		}
	    }
	    return (TRUE);

	case IDCANCEL:
	    EndDialog(hDlg, FALSE );
	    return (TRUE);
	}
	break;
    }
    return (FALSE);			      /* Didn't process a message    */
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\trustshr\trustshr.h ===
#define IDM_ADDSHARE 100
#define	IDM_DELETE 101
#define	IDM_GETUSERPASSWD 102
#define	IDM_GETCACHEPASSWD 103
#define	IDM_PROPERTIES		104
#define	IDM_ENUM_FROM_NETDDE		105
#define	IDM_VALIDATE		106

/*	int PASCAL WinMain(HANDLE, HANDLE, LPSTR, int); */
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
long FAR PASCAL MainWndProc(HWND, unsigned, UINT, LONG);
BOOL FAR PASCAL About(HWND, unsigned, UINT, LONG);

extern ULONG	uCreateParam;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\toolkit\proflspt.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "PROFLSPT.C;2  23-Dec-92,17:54:44  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#define NOCOMM
#include <stdlib.h>
#include <string.h>
#include "windows.h"
#include "tmpbuf.h"
#include "proflspt.h"

#define NDDE_REG_PARAMETERS "Software\\Microsoft\\NetDDE\\Parameters"

BOOL
WINAPI
TestPrivateProfile(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    LPCSTR  lpszFile )
{
    HKEY        hKey;
    LONG        ret;
    char        szKeySpec[ 1024 ];
    DWORD       cbId = 1024;
    DWORD       dwType = 0;

    wsprintf( szKeySpec, "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
        szKeySpec,
        0,
        KEY_READ,
        &hKey );
    if( ret == ERROR_SUCCESS )  {
        ret = RegQueryValueEx( hKey,
            (LPSTR)lpszKey,
            NULL,
            &dwType,
            (LPBYTE)szKeySpec,
            &cbId );
        RegCloseKey( hKey );
    }
    return(ret == ERROR_SUCCESS);
}



BOOL
WINAPI
MyWritePrivateProfileString(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    LPCSTR  lpszString,
    LPCSTR  lpszFile )
{
    HKEY    hKey;
    int     ret = -1;
    char    szKeySpec[ 1024 ];
    WCHAR   szValueBuf[512];
    WCHAR   szKeyBuf[256];
    DWORD   cbSize;
    DWORD   dwDisposition;

    wsprintf( szKeySpec, "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    cbSize = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
        lpszString, -1,
        (LPWSTR)szValueBuf, 512);

    if (cbSize) {
        ret = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
            szKeySpec,
            0,
            "NetDDEParameter",
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            (LPSECURITY_ATTRIBUTES) NULL,
            &hKey,
            &dwDisposition );

        if( ret == ERROR_SUCCESS )  {
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                lpszKey, -1,
                (LPWSTR)szKeyBuf, 256);

            ret = RegSetValueExW( hKey,
                (LPWSTR)szKeyBuf,
                (DWORD_PTR)NULL,
                REG_SZ,
                (LPBYTE)szValueBuf,
                cbSize * sizeof(WCHAR) );

            RegCloseKey( hKey );
        }
    }

    return( ret == ERROR_SUCCESS );
}


BOOL
FAR PASCAL
MyWritePrivateProfileInt(
    LPSTR   lpAppName,
    LPSTR   lpKeyName,
	int     nValue,
    LPSTR   lpFileName )
{
    HKEY    hKey;
    int     ret;
    char    szKeySpec[ 1024 ];
    DWORD   dwDisposition;

    wsprintf( szKeySpec, "%s\\%s", NDDE_REG_PARAMETERS, lpAppName );

    ret = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          szKeySpec,
                          0,
                          "NetDDEParameter",
                          REG_OPTION_NON_VOLATILE,
                          KEY_ALL_ACCESS,
                          (LPSECURITY_ATTRIBUTES) NULL,
                          &hKey,
                          &dwDisposition );

    if( ret == ERROR_SUCCESS )  {

        ret = RegSetValueEx( hKey,
                             (LPSTR)lpKeyName,
                             (DWORD_PTR)NULL,
                             REG_DWORD,
                             (LPBYTE)&nValue,
                             sizeof(nValue) );
        RegCloseKey( hKey );
    }

    return( ret == ERROR_SUCCESS );
}



BOOL
FAR PASCAL
WritePrivateProfileLong(
    LPSTR   lpAppName,
    LPSTR   lpKeyName,
    LONG    lValue,
    LPSTR   lpFileName )
{
    return( MyWritePrivateProfileInt( lpAppName, lpKeyName,
        lValue, lpFileName ) );
}


UINT
WINAPI
MyGetPrivateProfileInt(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    INT     dwDefault,
    LPCSTR  lpszFile )
{
    HKEY    hKey;
    int     ret;
    char    szKeySpec[ 1024 ];
    BOOL    bRetrieved = FALSE;
    DWORD   dwValue;
    DWORD   cbId = sizeof(dwValue);
    DWORD   dwType = 0;

    wsprintf( szKeySpec, "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
        szKeySpec,
        0,
        KEY_READ,
        &hKey );

    if( ret == ERROR_SUCCESS )  {
	    ret = RegQueryValueEx( hKey,
            (LPSTR)lpszKey,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &cbId );

        if( ret == ERROR_SUCCESS )  {
            if( dwType == REG_DWORD )  {
                bRetrieved = TRUE;
            }
        }
	RegCloseKey( hKey );
    }
    if( bRetrieved )  {
        return( dwValue );
    } else {
        return( dwDefault );
    }
}




DWORD
WINAPI
MyGetPrivateProfileString(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    LPCSTR  lpszDefault,
    LPSTR   lpszReturnBuffer,
    DWORD   cbReturnBuffer,
    LPCSTR  lpszFile )
{
    HKEY    hKey;
    int     ret;
    char    szKeySpec[ 1024 ];
    WCHAR   szKeyBuf[256];
    WCHAR   szValueBuf[512];
    BOOL    bRetrieved = FALSE;
    DWORD   cbId = 512*sizeof(WCHAR);
    DWORD   dwType = 0;
    BOOL    fWide;

    wsprintf( szKeySpec, "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        szKeySpec,
                        0,
                        KEY_READ,
                        &hKey );

    if( ret == ERROR_SUCCESS )  {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                             lpszKey, -1,
                             (LPWSTR)szKeyBuf, 256);

        ret = RegQueryValueExW( hKey,
                                (LPWSTR)szKeyBuf,
                                NULL,
                                &dwType,
                                (LPBYTE)szValueBuf,
                                &cbId );

        if (ret == ERROR_SUCCESS) {

            if( dwType == REG_SZ )  {
                cbId = WideCharToMultiByte(
                           CP_ACP,
                           WC_COMPOSITECHECK,
                           (LPWSTR) szValueBuf,
                           cbId / sizeof(WCHAR),
                           lpszReturnBuffer,
                           cbReturnBuffer,
                           NULL,
                           &fWide );
                if (cbId) {
                    bRetrieved = TRUE;
                }
            }
        }

        RegCloseKey( hKey );
    }

    if( !bRetrieved )  {
        strncpy( lpszReturnBuffer, lpszDefault, cbReturnBuffer );
    }

    if( cbReturnBuffer > 0 )  {
        lpszReturnBuffer[cbReturnBuffer-1] = '\0';
    }

    return( lstrlen(lpszReturnBuffer) );
}



LONG
FAR PASCAL
GetPrivateProfileLong(
    LPSTR   lpAppName,
    LPSTR   lpKeyName,
    LONG    lDefault,
    LPSTR   lpFileName )
{
    return( MyGetPrivateProfileInt( lpAppName, lpKeyName,
        lDefault, lpFileName ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\netdde\src\trustshr\trustshr.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "TRUSTSHR.C;1  16-Dec-92,10:24:02  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "windows.h"
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <stdio.h>
#include "debug.h"
#include "trustshr.h"
#include "nddeapi.h"
#include "dialogs.h"
#include "shrtrust.h"

#define DEBUG_VALIDATE

extern BOOL FAR PASCAL AddShareDlg(HWND hDlg, unsigned message, WORD wParam, LONG lParam);
VOID     RefreshShareWindow ( VOID );
void     GetDBInstance(char *lpszBuf);
BOOL     NddeTrustedShareDel( LPSTR lpszShareName );
VOID     CleanupTrustedShares( void );

char		szComputerName[ MAX_COMPUTERNAME_LENGTH ];
char        szDBInstance[16];
HINSTANCE 	hInst;			
HWND		hwndListBox;
HWND		hwndApp;
char		szBuf[128];
char		szApp[] = "Trusted Share Manager";
TCHAR       szShareKeyRoot[] = TRUSTED_SHARES_KEY;
char       *lpCommonTree;


#if DBG
BOOL    bDebugInfo = FALSE;
#endif // DBG
int PASCAL WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
HINSTANCE hInstance;			
HINSTANCE hPrevInstance;			
LPSTR lpCmdLine;			
int nCmdShow;				
{
    MSG msg;				

    lpCommonTree = strchr(szShareKeyRoot, '\\') + 1;

    if (!hPrevInstance)			
		if (!InitApplication(hInstance))
			return (FALSE);		

    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

#if DBG
    DebugInit( "TrustShr" );
    bDebugInfo = MyGetPrivateProfileInt("TrustShr",
        "DebugInfo", FALSE, "netdde.ini");
#endif


    while (GetMessage(&msg, NULL, 0, 0) )		   {
		TranslateMessage(&msg);	
		DispatchMessage(&msg);	
    }
    return (msg.wParam);	
}


BOOL InitApplication(hInstance)
HANDLE hInstance;			
{
    WNDCLASS  wc;

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;

    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, "TRUSTSHR_ICON");
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  "TrustShareMenu";
    wc.lpszClassName = "TrustShareWClass";
    return (RegisterClass(&wc));
}


BOOL InitInstance(hInstance, nCmdShow)
    HANDLE          hInstance;
    int             nCmdShow;
{
    HWND        hWnd;
    DWORD	cbName = MAX_COMPUTERNAME_LENGTH;

    hInst = hInstance;

    GetComputerName( szComputerName, &cbName );
    GetDBInstance(szDBInstance);
    hwndApp = hWnd = CreateWindow(
        "TrustShareWClass",
        szApp,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        300,
        220,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (!hWnd)
        return (FALSE);

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
    return (TRUE);
}


long FAR PASCAL MainWndProc(hWnd, message, wParam, lParam)
HWND hWnd;				
UINT message;			
UINT wParam;				
LONG lParam;				
{
    switch (message) {
	case WM_CREATE:
        DIPRINTF(("WM_CREATE: %0X", (UINT) hWnd));
		hwndListBox = CreateWindow ( "listbox",
		    NULL,
		    WS_CHILD | LBS_STANDARD | LBS_DISABLENOSCROLL |
			    LBS_NOINTEGRALHEIGHT,
		    0, 0, 0, 0,
		    hWnd,
		    NULL,
		    hInst,
		    NULL
		);
		ShowWindow ( hwndListBox, SW_SHOW );
		RefreshShareWindow();
		break;

	case WM_SIZE:
		MoveWindow ( hwndListBox, -1, -1,
			LOWORD(lParam)+2, HIWORD(lParam)+2, TRUE);
		break;

	case WM_INITMENU:
		{
		int idx = (int)SendMessage( hwndListBox,LB_GETCURSEL,0,0L );
		EnableMenuItem( (HMENU)wParam, IDM_DELETE, idx != LB_ERR ? FALSE:TRUE );
		EnableMenuItem( (HMENU)wParam, IDM_PROPERTIES,
			idx != LB_ERR ? FALSE:TRUE );
		break;
		}

	case WM_COMMAND:	
		switch ( LOWORD(wParam) ) {
                case 0:
		    if( HIWORD(wParam) == LBN_DBLCLK )  {
			PostMessage( hWnd, WM_COMMAND, IDM_PROPERTIES, 0L );
		    }
		    break;
                case IDM_ADDSHARE:

		    uCreateParam = 0L;
                    if ( DialogBox(hInst, "IDD_ADDSHARE",
                        hWnd, (DLGPROC)AddShareDlg ) )
                            RefreshShareWindow();

                    break;
                case IDM_DELETE:
                    {
                        int idx = (int)SendMessage( hwndListBox,LB_GETCURSEL,0,0L );
                        if ( idx == LB_ERR )
                            break;
                        SendMessage(hwndListBox,LB_GETTEXT, idx,
			    (LPARAM)(LPSTR)szBuf );
			NddeTrustedShareDel( szBuf );
                        RefreshShareWindow();
                        break;
                    }
                case IDM_VALIDATE:
		    CleanupTrustedShares();
		    MessageBox( NULL,
			"Completed Validation of Trusted Shares",
			szApp, MB_TASKMODAL | MB_OK );
		    RefreshShareWindow();
		    break;
                case IDM_PROPERTIES:
                    {
                        int idx = (int)SendMessage( hwndListBox,LB_GETCURSEL,0,0L );
                        if ( idx == LB_ERR )
                            break;
                        SendMessage(hwndListBox,LB_GETTEXT, idx, (LPARAM)(LPSTR)szBuf );

			uCreateParam = (LPARAM)(LPSTR)szBuf;
                        if (DialogBox(hInst, "IDD_ADDSHARE",
                            hWnd, (DLGPROC)AddShareDlg ))
                            RefreshShareWindow();

                        break;
                    }
		}
		break;

	case WM_DESTROY:		
	    PostQuitMessage(0);
	    break;

	default:			
	    return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}

VOID RefreshShareWindow ( VOID )
{
    HKEY	hKeyRoot;
    int		ret;
    int		idx = 0;
    DWORD	cbShareName;
    char	szShareName[ 1024 ];
    char	szShareKey[ 1024 ];

    SendMessage ( hwndListBox, LB_RESETCONTENT, 0, 0L );

    wsprintf( szShareKey, "%s\\%s", lpCommonTree, szDBInstance );
    ret = RegOpenKeyEx( HKEY_CURRENT_USER, szShareKey,
	0, KEY_READ, &hKeyRoot );
    if( ret == ERROR_SUCCESS )  {
	while( ret == ERROR_SUCCESS )  {
	    cbShareName = sizeof(szShareName);
	    ret = RegEnumKeyEx( hKeyRoot, idx++, szShareName,
		&cbShareName, NULL, NULL, NULL, NULL );
	    if( ret == ERROR_SUCCESS )  {
		SendMessage(hwndListBox, LB_ADDSTRING, 0,
		    (LPARAM)szShareName );
	    }
	}
	RegCloseKey( hKeyRoot );
    }
}


/*
    NddeTrustedShareDel() deletes the specified share name from the
    list of trusted shares
 */
BOOL
NddeTrustedShareDel( LPSTR lpszShareName )
{
    char	szShareInstance[ 1024 ];
    HKEY	hKey;
    DWORD	ret;

    wsprintf( szShareInstance, "%s\\%s", lpCommonTree, szDBInstance );
    ret = RegOpenKeyEx( HKEY_CURRENT_USER, szShareInstance,
	0, KEY_WRITE | KEY_READ, &hKey );
    if( ret == ERROR_SUCCESS )  {
	RegDeleteKey( hKey, lpszShareName );
	RegCloseKey( hKey );
	return( TRUE );
    } else {
	return( FALSE );
    }
}

/*
    Given a share name, GetNddeShareModifyId() will retrieve the modify id
    associated with the DSDM share
 */
BOOL
GetNddeShareModifyId(
    LPSTR lpszShareName,
    LPDWORD lpdwId )
{
    char		BigBuf[ 10000 ];
    PNDDESHAREINFO	lpDdeI = (PNDDESHAREINFO)&BigBuf;
    DWORD		avail = 0;
    WORD		items = 0;
    char		szServerName[ MAX_COMPUTERNAME_LENGTH + 3 ];
    UINT		nRet;
    BOOL		bRetrieved = FALSE;


    strcpy(szServerName, "\\\\");
    strcat(szServerName, szComputerName);
    /* get the share information out of the DSDM DB */
    nRet = NDdeShareGetInfo ( szServerName, lpszShareName, 2, (LPBYTE)lpDdeI,
	sizeof(BigBuf), &avail, &items );

    DIPRINTF(("NDdeShareGetInfo(%s:%s) returns %d", szServerName,
            lpszShareName, nRet));
    if( nRet == NDDE_NO_ERROR )  {
        DIPRINTF(("NDdeShareGetInfo() ModifyId: %08X:%08X",
                lpDdeI->qModifyId[0],
                lpDdeI->qModifyId[1] ));
	/* compare modify ids */
	bRetrieved = TRUE;
	lpdwId[0] = lpDdeI->qModifyId[0];
	lpdwId[1] = lpDdeI->qModifyId[1];
    }
    return( bRetrieved );
}

/*
    Given a computername and share name, GetTrustedShareInfo() will
    retrieve the modify id associated with the trusted share
 */
BOOL
GetTrustedShareInfo(
    LPSTR lpszShareKeyComputer,
    LPSTR lpszShareName,
    LPDWORD lpdwId,
    UINT *lpfuCmdShow)
{
    HKEY		hKeySpec;
    int			ret;
    char		szShareKeySpec[ 1024 ];
    BOOL		bRetrieved = FALSE;

    wsprintf( szShareKeySpec, "%s\\%s", lpszShareKeyComputer, lpszShareName );
    ret = RegOpenKeyEx( HKEY_CURRENT_USER, szShareKeySpec,
        0, KEY_READ, &hKeySpec );
    if( ret == ERROR_SUCCESS )  {
        DWORD	dwId[2];
        DWORD	cbId = sizeof(dwId);
        DWORD	dwType = REG_BINARY;
        DWORD	cbShow = sizeof(*lpfuCmdShow);

	if( RegQueryValueEx( hKeySpec, KEY_MODIFY_ID, NULL,
	    &dwType, (LPBYTE)lpdwId, &cbId ) == ERROR_SUCCESS )  {
	    bRetrieved = TRUE;
	}
	if( RegQueryValueEx( hKeySpec, KEY_CMDSHOW, NULL,
	    &dwType, (LPBYTE)lpfuCmdShow, &cbShow ) != ERROR_SUCCESS )  {
	    *lpfuCmdShow = 0;
	}
	RegCloseKey( hKeySpec );
	UNREFERENCED_PARAMETER(dwId);
    }
    return( bRetrieved );
}

BOOL
CompareModifyIds( LPSTR lpszShareKeyComputer, LPSTR lpszShareName )
{
    DWORD	dwIdNdde[2];
    DWORD	dwIdTrusted[2];
    BOOL	bRetrievedNdde;
    BOOL	bRetrievedTrusted;
    BOOL	bMatch = FALSE;
    UINT	fuCmdShow;

#ifdef DEBUG_VALIDATE
    char	msg[ 200 ];
    wsprintf( msg, "Deleting TrustedShare: \"%s\"\n\n", lpszShareName );
#endif

    bRetrievedNdde = GetNddeShareModifyId( lpszShareName, &dwIdNdde[0] );
    bRetrievedTrusted = GetTrustedShareInfo( lpszShareKeyComputer,
	lpszShareName, &dwIdTrusted[0], &fuCmdShow );
    if( bRetrievedNdde && bRetrievedTrusted )  {
	if( (dwIdNdde[0] == dwIdTrusted[0])
	    && (dwIdNdde[1] == dwIdTrusted[1]) )  {
	    bMatch = TRUE;
#ifdef DEBUG_VALIDATE
	} else {
	    char	x[150];
	    wsprintf( x, "SerialNumbers did not match:\n\nNDDE: %08lX %08lX vs. TRUST: %08lX %08lX",
		dwIdNdde[0], dwIdNdde[1],
		dwIdTrusted[0], dwIdTrusted[1] );
	    strcat( msg, x );
#endif
	}
#ifdef DEBUG_VALIDATE
    } else if( !bRetrievedNdde )  {
	strcat( msg, "Could not retrieve NDDE information" );
    } else if( !bRetrievedTrusted )  {
	strcat( msg, "Could not retrieve TrustedShare information" );
#endif
    }

#ifdef DEBUG_VALIDATE
    if( !bMatch )  {
	MessageBox( NULL, msg, szApp, MB_TASKMODAL | MB_OK );
    }
#endif
    return( bMatch );
}

/*
    CleanupTrustedShares() goes through all the truested shares for this user
    on this machine and makes certain that noone has modified the shares
    since the time the user said they were ok.
 */
VOID
CleanupTrustedShares( void )
{
    HKEY		hKeyRoot;
    int			ret;
    int			idx = 0;
    DWORD		cbShareName;
    char		szShareName[ 1024 ];
    char		szShareInstance[ 1024 ];
    BOOL		bDeleted;

    wsprintf( szShareInstance, "%s\\%s", lpCommonTree, szDBInstance );
    ret = RegOpenKeyEx( HKEY_CURRENT_USER, szShareInstance,
            0, KEY_READ, &hKeyRoot );
    if( ret == ERROR_SUCCESS )  {
	
        bDeleted = FALSE;
	/* enunerate all the shares for this computer */
	while( ret == ERROR_SUCCESS )  {
	    cbShareName = sizeof(szShareName);
	    ret = RegEnumKeyEx( hKeyRoot, idx++, szShareName,
		&cbShareName, NULL, NULL, NULL, NULL );
	    if( ret == ERROR_SUCCESS )  {
		/* compare the modify ids */
		if( !CompareModifyIds( szShareInstance, szShareName ) )  {
		
		    /* if they don't match exactly ... get rid of it */
		    NddeTrustedShareDel( szShareName );
		    bDeleted = TRUE;
		}
	    }
	    if( bDeleted )  {
		/* reset the idx to 0 so we'll go through all
		    the trusted shares again */
		idx = 0;
		
		/* close and reopen to force the clearing of the key */
		RegCloseKey( hKeyRoot );
		ret = RegOpenKeyEx( HKEY_CURRENT_USER, szShareInstance,
		    0, KEY_READ, &hKeyRoot );
		bDeleted = FALSE;
	    }
	}
	RegCloseKey( hKeyRoot );
    }
}

void
GetDBInstance(char *lpszBuf)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwInstance;
    DWORD   dwType = REG_DWORD;
    DWORD   cbData = sizeof(DWORD);
    TCHAR   szShareDBKey[] = DDE_SHARES_KEY;

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareDBKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        DPRINTF(("Unable to open DDE Shares DB Key: %d", lRtn));
        strcpy(lpszBuf, TRUSTED_SHARES_KEY_DEFAULT_A);
        return;
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_DB_INSTANCE,
                NULL,
                &dwType,
                (LPBYTE)&dwInstance, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        DPRINTF(("Unable to query DDE Shares DB Instance Value: %d", lRtn));
        strcpy(lpszBuf, TRUSTED_SHARES_KEY_DEFAULT_A);
        return;
    }
    sprintf(lpszBuf, "%s%08X", TRUSTED_SHARES_KEY_PREFIX_A, dwInstance);
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\common\debug.cpp ===
#include <windows.h>

#include <debug.h>
#include <crtdbg.h>
#include <tstr.h>

#include <stdarg.h>


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


#define TRACE_HRESULT   0x01
#define TRACE_Win32     0x02


void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ...);

void WriteFilename( TSTR & msg, LPCTSTR pFile );

void StackTrace( TSTR & str );


LPCTSTR g_pLevelStrs [ ] = 
{
    TEXT("DBG"),
    TEXT("INF"),
    TEXT("WRN"),
    TEXT("ERR"),
    TEXT("PRM"),
    TEXT("PRW"),
    TEXT("IOP"),
    TEXT("ASD"),
    TEXT("ASR"),
    TEXT("CAL"),
    TEXT("RET"),
    TEXT("???"),
};


static
void InternalTrace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, DWORD dwFlags, const void * pThis, HRESULT hr, LPCTSTR pStr )
{
    if( dwLevel >= ARRAYSIZE( g_pLevelStrs ) )
        dwLevel = ARRAYSIZE( g_pLevelStrs ) - 1; // "???" unknown entry

    // Basic message stuff - pid, tid... (also pass this and use object ptr?)
    // TODO - allow naming of threads?

    DWORD pid = GetCurrentProcessId();
    DWORD tid = GetCurrentThreadId();
    
    // Module:file:line pid:tid str
    TSTR msg(512);
    msg << g_pLevelStrs[ dwLevel ] << TEXT(" ");

    if( ! pFile )
	    WriteFilename( msg, TEXT("[missing file]") );
	else
	    WriteFilename( msg, pFile );

    msg << TEXT(":")
        << uLineNo << TEXT(" ")
        << WriteHex( pid ) << TEXT(":")
        << WriteHex( tid ) << TEXT(" ");

    if( pThis )
    {
        msg << TEXT("this=") << WriteHex( pThis, 8 ) << TEXT(" ");
    }

    if( dwFlags & TRACE_HRESULT )
    {
        msg << WriteError( hr ) << TEXT(" ");
    }

    if( dwFlags & TRACE_Win32 )
    {
        msg << WriteError( GetLastError() ) << TEXT(" ");
    }

    if( ! pStr )
	    msg << TEXT("[missing string]") << TEXT("\r\n");
	else
	    msg << pStr << TEXT("\r\n");

    // For the moment, just send to DBWIN...
//	OutputDebugString( msg );
    OutputDebugStringDBWIN( msg );

#ifdef DEBUG
    if( dwLevel == _TRACE_ASSERT_D || dwLevel == _TRACE_ERR )
    {
    	_ASSERT(0);
//        DebugBreak();
    }
#endif // DEBUG
}


void _Trace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, 0, pThis, 0, pStr );
}

void _TraceHR( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, HRESULT hr, LPCTSTR pStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_HRESULT, pThis, hr, pStr );
}

void _TraceW32( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_Win32, pThis, 0, pStr );
}



// Add just the 'filename' part of the full path, minus base and extention.
// So for "g:\dev\vss\msaa\common\file.cpp", write "file".
// The start of this string is that last found ':', '\', or start of string if those are not present.
// The end of this string is the last '.' found after the start position, otherwise the end of the string.
void WriteFilename( TSTR & str, LPCTSTR pPath )
{
    LPCTSTR pScan = pPath;
    LPCTSTR pStart = pPath;
    LPCTSTR pEnd = NULL;

    // Scan till we hit the end, or a '.'...
    while( *pScan != '\0' )
    {
        if( *pScan == '.' )
        {
            pEnd = pScan;
            pScan++;
        }
        if( *pScan == '\\' || *pScan == ':'  )
        {
            pScan++;
            pStart = pScan;
            pEnd = NULL;
        }
        else
        {
            pScan++;
        }
    }

    if( pEnd == NULL )
        pEnd = pScan;

    str.append( pStart, pEnd - pStart );
}









void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ... )
{
    // create the output buffer
    TCHAR achBuffer[500];
    va_list args;
    va_start(args, lpOutputString);
    wvsprintf(achBuffer, lpOutputString, args);
    va_end(args);


    // make sure DBWIN is open and waiting
    HANDLE heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
    if( !heventDBWIN )
    {
        //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
        return;            
    }

    // get a handle to the data synch object
    HANDLE heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
    if ( !heventData )
    {
        // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
        CloseHandle(heventDBWIN);
        return;            
    }
    
    HANDLE hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
    if (!hSharedFile) 
    {
        //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    LPSTR lpszSharedMem = (LPSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
    if (!lpszSharedMem) 
    {
        //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    // wait for buffer event
    WaitForSingleObject(heventDBWIN, INFINITE);

    // write it to the shared memory
    *((LPDWORD)lpszSharedMem) = GetCurrentProcessId();
#ifdef UNICODE
	CHAR szBuf[500];
	wcstombs(szBuf, achBuffer, sizeof( szBuf ) );
    sprintf(lpszSharedMem + sizeof(DWORD), "%s", szBuf);
#else
    sprintf(lpszSharedMem + sizeof(DWORD), "%s", achBuffer);
#endif

    // signal data ready event
    SetEvent(heventData);

    // clean up handles
    CloseHandle(hSharedFile);
    CloseHandle(heventData);
    CloseHandle(heventDBWIN);

    return;
}












// Prototype stack trace code...





typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

typedef struct _KDHELP {
    DWORD   Thread;
    DWORD   ThCallbackStack;
    DWORD   NextCallback;
    DWORD   FramePointer;
    DWORD   KiCallUserMode;
    DWORD   KeUserCallbackDispatcher;
    DWORD   SystemRangeStart;
    DWORD   ThCallbackBStore;
    DWORD  Reserved[8];
} KDHELP, *PKDHELP;

typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    LPCVOID lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );






typedef BOOL (WINAPI * PFN_SymInitialize)( HANDLE, LPSTR, BOOL );
typedef BOOL (WINAPI * PFN_StackWalk)( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
                                       PREAD_PROCESS_MEMORY_ROUTINE,
                                       PFUNCTION_TABLE_ACCESS_ROUTINE,
                                       PGET_MODULE_BASE_ROUTINE,
                                       PTRANSLATE_ADDRESS_ROUTINE );
typedef LPVOID (WINAPI * PFN_SymFunctionTableAccess)( HANDLE, DWORD );
typedef DWORD (WINAPI * PFN_SymGetModuleBase)( HANDLE, DWORD );
typedef BOOL (WINAPI * PFN_SymGetSymFromAddr)( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
typedef BOOL (WINAPI * PFN_SymCleanup)( HANDLE hProcess );


PFN_SymInitialize           pfnSymInitialize;
PFN_StackWalk               pfnStackWalk;
PFN_SymFunctionTableAccess  pfnSymFunctionTableAccess;
PFN_SymGetModuleBase        pfnSymGetModuleBase;
PFN_SymGetSymFromAddr       pfnSymGetSymFromAddr;
PFN_SymCleanup              pfnSymCleanup;


#ifdef _ALPHA_
#define CH_MACHINE IMAGE_FILE_MACHINE_ALPHA
#else
#define CH_MACHINE IMAGE_FILE_MACHINE_I386
#endif


#define MAX_SYM_LEN 128

void StackTrace1( EXCEPTION_POINTERS *exp, TSTR & str );

#define MY_DBG_EXCEPTION 3

void StackTrace( TSTR & str )
{
    __try {
        // raise an exception to get the exception record to start the stack walk
        RaiseException(MY_DBG_EXCEPTION, 0, 0, NULL);
    }
    __except( StackTrace1( GetExceptionInformation(), str ), EXCEPTION_CONTINUE_EXECUTION ) {
    }
}



void StackTrace1( EXCEPTION_POINTERS *exp, TSTR & str )
{
    CONTEXT * context = exp->ContextRecord;


HMODULE hModule = LoadLibrary( TEXT( "dbghelp" ) );
pfnSymInitialize =          (PFN_SymInitialize)             GetProcAddress( hModule, "SymInitialize" );
pfnStackWalk =              (PFN_StackWalk)                 GetProcAddress( hModule, "StackWalk" );
pfnSymFunctionTableAccess = (PFN_SymFunctionTableAccess)    GetProcAddress( hModule, "SymFunctionTableAccess" );
pfnSymGetModuleBase =       (PFN_SymGetModuleBase)          GetProcAddress( hModule, "SymGetModuleBase" );
pfnSymGetSymFromAddr =      (PFN_SymGetSymFromAddr)         GetProcAddress( hModule, "SymGetSymFromAddr" );
pfnSymCleanup =             (PFN_SymCleanup)                GetProcAddress( hModule, "SymCleanup" );



    HANDLE hProcess = GetCurrentProcess();
    HANDLE hThread = GetCurrentThread();

    pfnSymInitialize( hProcess, NULL, TRUE );

    IMAGEHLP_SYMBOL * psym = (IMAGEHLP_SYMBOL *) new char[ sizeof(IMAGEHLP_SYMBOL) + MAX_SYM_LEN ];

    STACKFRAME frame;
    memset( &frame, 0, sizeof( frame ) );

#if defined (_M_IX86)
    // Initialize the STACKFRAME structure for the first call.  This is only
    // necessary for Intel CPUs, and isn't mentioned in the documentation.
    frame.AddrPC.Offset       = context->Eip;
    frame.AddrPC.Mode         = AddrModeFlat;
    frame.AddrFrame.Offset    = context->Ebp;
    frame.AddrFrame.Mode      = AddrModeFlat;
    frame.AddrStack.Offset    = context->Esp;
    frame.AddrStack.Mode      = AddrModeFlat;
#endif // _M_IX86

    for( ; ; )
    {
        BOOL bSWRet = pfnStackWalk( CH_MACHINE,
                                    hProcess,
                                    hThread,
                                    & frame,
                                    NULL, // CONTEXT - NULL for i386
                                    NULL, // Use ReadProcessMemory
                                    pfnSymFunctionTableAccess,
                                    pfnSymGetModuleBase,
                                    NULL );
        if( ! bSWRet )
        {
            break;
        }
/*
        frame.AddrPC
        frame.AddrReturn
        frame.AddrFrame
        frame.AddrStack
        frame.Params[ 4 ]
*/
        psym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        psym->MaxNameLength = MAX_SYM_LEN;

        DWORD dwDisplacement;
        if( pfnSymGetSymFromAddr( hProcess, frame.AddrPC.Offset, & dwDisplacement, psym ) )
        {
        }
        else
        {
        }

    }

    delete psym;

    pfnSymCleanup( hProcess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\inc\fwd_macros.h ===
#ifndef _FWD_MACROS_H_
#define _FWD_MACROS_H_


#define AS_DECL_0
#define AS_CALL_0

#define AS_DECL_1(t1,a1) (t1 a1)
#define AS_CALL_1(t1,a1) (a1)

#define AS_DECL_2(t1,a1,t2,a2) (t1 a1,t2 a2)
#define AS_CALL_2(t1,a1,t2,a2) (a1,a2)

#define AS_DECL_3(t1,a1,t2,a2,t3,a3) (t1 a1,t2 a2,t3 a3)
#define AS_CALL_3(t1,a1,t2,a2,t3,a3) (a1,a2,a3)

#define AS_DECL_4(t1,a1,t2,a2,t3,a3,t4,a4) (t1 a1,t2 a2,t3 a3,t4 a4)
#define AS_CALL_4(t1,a1,t2,a2,t3,a3,t4,a4) (a1,a2,a3,a4)

#define AS_DECL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5)
#define AS_CALL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (a1,a2,a3,a4,a5)

#define AS_DECL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6)
#define AS_CALL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (a1,a2,a3,a4,a5,a6)

#define AS_DECL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7)
#define AS_CALL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (a1,a2,a3,a4,a5,a6,a7)

#define AS_DECL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8)
#define AS_CALL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (a1,a2,a3,a4,a5,a6,a7,a8)

#define AS_DECL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9)
#define AS_CALL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (a1,a2,a3,a4,a5,a6,a7,a8,a9)

#define AS_DECL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10)
#define AS_CALL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)

#define AS_DECL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10,t11 a11)
#define AS_CALL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)


#define AS_DECL( n, p )  AS_DECL_ ## n p
#define AS_CALL( n, p )  AS_CALL_ ## n p


#endif // _FWD_MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\inc\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_



// Debug     - used to track specific problems during debugging. Debug's are temporary,
//             and should be removed (or promoted to Info/Warning's) before check-in.
// Info      - general information during normal operation
// Warning   - warnings, recoverable errors
// Error     - things that shouldn't happen
// Param     - incorect params passed in, etc.
// Interop   - unexpected return codes/behavior from other (external) components
// Assert    - Assert-level really-shouldn't-happen errors.


#define _TRACE_DEBUG    0
#define _TRACE_INFO     1
#define _TRACE_WARNING  2
#define _TRACE_ERROR    3

#define _TRACE_PARAM    4
#define _TRACE_PARAWARN 5
#define _TRACE_INTEROP  6

#define _TRACE_ASSERT_D 7   // Debug-build assert - really does assert
#define _TRACE_ASSERT_R 8   // Release-build assert - only logs error, doesn't halt program

#define _TRACE_CALL     9
#define _TRACE_RET      10



void _Trace     ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void *  pThis, LPCTSTR pStr );
// Also adds message corresponding to HRESULT...
void _TraceHR   ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, HRESULT hr, LPCTSTR pStr );
// Also adds message corresponding to GetLastError()...
void _TraceW32  ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pStr );


//
// _DTrace* is debug-only, while _Trace is debug and release...
//

#ifdef _DEBUG

#define _DTrace( pFile, uLineNo, dwLevel, pThis, pStr )         _Trace( pFile, uLineNo, dwLevel, pThis, pStr )
#define _DTraceHR( pFile, uLineNo, dwLevel, pThis, hr, pStr )   _TraceHR( pFile, uLineNo, dwLevel, pThis, hr, pStr )
#define _DTraceW32( pFile, uLineNo, dwLevel, pThis, pStr )      _TraceW32( pFile, uLineNo, dwLevel, pThis, pStr )

#define _TRACE_ASSERT _TRACE_ASSERT_D


class DebugCallRetTracker
{
    const void *    m_pThis;
    LPCTSTR         m_pMethodName;
    LPCTSTR         m_pFile;
    ULONG           m_Line;

public:

    DebugCallRetTracker( const void * pThis, LPCTSTR pMethodName, LPCTSTR pFile, ULONG Line )
        : m_pThis( pThis ),
          m_pMethodName( pMethodName ),
          m_pFile( pFile ),
          m_Line( Line )
    {
        _Trace( m_pFile, m_Line, _TRACE_CALL, m_pThis, m_pMethodName ); 
    }

    ~DebugCallRetTracker( )
    {
        _Trace( m_pFile, m_Line, _TRACE_RET, m_pThis, m_pMethodName ); 
    }
};


#define IMETHOD( name )     DebugCallRetTracker IMETHOD_temp_var( this, TEXT( # name ), TEXT( __FILE__ ), __LINE__ )


#else // _DEBUG

#define _DTrace( pFile, uLineNo, dwLevel, pThis, pStr )
#define _DTraceHR( pFile, uLineNo, dwLevel, hr, pThis, pStr )
#define _DTraceW32( pFile, uLineNo, dwLevel, pThis, pStr )

#define IMETHOD( name )

#define _TRACE_ASSERT _TRACE_ASSERT_R

#endif // _DEBUG


#define Assert( cond )          if( cond ) { } else _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_ASSERT, NULL, TEXT( # cond ) )
#define AssertMsg( cond, str )  if( cond ) { } else _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_ASSERT, NULL, str )

#define TraceDebug( str )           _DTrace( TEXT( __FILE__ ), __LINE__, _TRACE_DEBUG, NULL, str )
#define TraceInfo( str )            _DTrace( TEXT( __FILE__ ), __LINE__, _TRACE_INFO, NULL, str )
#define TraceWarning( str )         _DTrace( TEXT( __FILE__ ), __LINE__, _TRACE_WARNING, NULL, str )
#define TraceError( str )           _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_ERROR, NULL, str )
#define TraceParam( str )           _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_PARAM, NULL, str )
#define TraceParamWarn( str )       _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_PARAMWARN, NULL, str )
#define TraceInterop( str )         _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_INTEROP, NULL, str )

#define TraceDebugHR( hr, str )     _DTraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_DEBUG, NULL, hr, str )
#define TraceInfoHR( hr, str )      _DTraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_INFO, NULL, hr, str )
#define TraceWarningHR( hr, str )   _DTraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_WARNING, NULL, hr, str )
#define TraceErrorHR( hr, str )     _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_ERROR, NULL, hr, str )
#define TraceParamHR( hr, str )     _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_PARAM, NULL, hr, str )
#define TraceParamWarnHR( hr, str ) _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_PARAMWARN, NULL, hr, str )
#define TraceInteropHR( hr, str )   _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_INTEROP, NULL, hr, str )

#define TraceDebugW32( str )        _DTraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_DEBUG, NULL, str )
#define TraceInfoW32( str )         _DTraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_INFO, NULL, str )
#define TraceWarningW32( str )      _DTraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_WARNING, NULL, str )
#define TraceErrorW32( str )        _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_ERROR, NULL, str )
#define TraceParamW32( str )        _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_PARAM, NULL, str )
#define TraceParamWarnW32( str )    _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_PARAMWARN, NULL, str )
#define TraceInteropW32( str )      _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_INTEROP, NULL, str )



#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\inc\list_dl.h ===
template <class T> class List_dl;
template <class T> class Iter_dl;


template <class T>
class Link_dl
{
    Link_dl<T> *  m_pPrev;
    Link_dl<T> *  m_pNext;

    friend class List_dl<T>;
    friend class Iter_dl<T>;

public:

    Link_dl()
        : m_pPrev( NULL ),
          m_pNext( NULL )
    {
        // Do nothing
    }

    ~Link_dl()
    {
        AssertMsg( m_pNext == NULL && m_pPrev == NULL,
                   TEXT("~Link_dl(), link still on a list?") );
    }

    T * getNext() const
    {
        return (T *) m_pNext;
    }

    T * getPrev() const
    {
        return (T *) m_pPrev;
    }
};


template <class T>
class List_dl
{
    Link_dl<T> *  m_pHead;
    Link_dl<T> *  m_pTail;

    friend class Iter_dl<T>;

public:

    List_dl()
        : m_pHead( NULL ),
          m_pTail( NULL )
    {
        // Do nothing
    }

    ~List_dl()
    {
        AssertMsg( m_pHead == NULL && m_pTail == NULL, TEXT("~List_dl(), list not empty?") );
    }

    void AddToHead( Link_dl<T> * pEl )
    {
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                        TEXT("dl-addToHead(), link still on some other list?") );

        pEl->m_pPrev = NULL;
        pEl->m_pNext = m_pHead;
        if( m_pHead )
            m_pHead->m_pPrev = pEl;
        else
            m_pTail = pEl;
        m_pHead = pEl;
    }

    void AddToTail( Link_dl<T> * pEl )
    {
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                TEXT("dl-addToTail(), link still on some other list?") );

        pEl->m_pPrev = m_pTail;
        pEl->m_pNext = NULL;
        if( m_pTail )
            m_pTail->m_pNext = pEl;
        else
            m_pHead = pEl;
        m_pTail = pEl;
    }

    void InsertBefore( Link_dl<T> * pRef, Link_dl<T> * pEl )
    {
        AssertMsg( ! pRef || pRef->m_pNext != NULL || pRef->m_pPrev != NULL || m_pHead == pRef,
                TEXT("dl-InsertBefore(), pRef is not on the list?") );
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                TEXT("dl-InsertBefore(), pEl is still on some other list?") );

        if( ! pRef )
            AddToTail( pEl );
        else
        {
            pEl->m_pNext = pRef;
            pEl->m_pPrev = pRef->m_pPrev;

            if( pRef->m_pPrev )
                pRef->m_pPrev->m_pNext = pEl;
            else
                m_pHead = pEl;

            pRef->m_pPrev = pEl;
        }
    }

    void InsertAfter( Link_dl<T> * pRef, Link_dl<T> * pEl )
    {
        AssertMsg( ! pRef || pRef->m_pNext != NULL || pRef->m_pPrev != NULL || m_pHead == pRef,
                TEXT("dl-InsertAfter(), pRef is not on the list?") );
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                TEXT("dl-InsertAfter(), pEl is still on some other list?") );

        if( ! pRef )
            AddToHead( pEl );
        else
        {
            pEl->m_pNext = pRef->m_pPref;
            pEl->m_pPrev = pRef;

            if( pRef->m_pNext )
                pRef->m_pNext->m_pPrev = pEl;
            else
                m_pTail = pEl;

            pRef->m_pNext = pEl;
        }
    }

    void remove( Link_dl<T> * pEl )
    {
        AssertMsg( pEl->m_pNext != NULL || pEl->m_pPrev != NULL || m_pHead == pEl,
                TEXT("dl-remove(), pEl is not on the list") );

        if( pEl->m_pPrev )
            pEl->m_pPrev->m_pNext = pEl->m_pNext;
        else
            m_pHead = pEl->m_pNext;
        if( pEl->m_pNext )
            pEl->m_pNext->m_pPrev = pEl->m_pPrev;
        else
            m_pTail = pEl->m_pNext;

        pEl->m_pPrev = NULL;
        pEl->m_pNext = NULL;
    }

    bool empty() const
    {
        return m_pHead == NULL;
    }

    T * getHead() const
    {
        return (T *) m_pHead;
    }

    T * getTail() const
    {
        return (T *) m_pTail;
    }
};



template <class T>
class Iter_dl
{

    Link_dl<T> *  m_pPos;

public:

    Iter_dl( const List_dl<T> & l )
    {
        m_pPos = l.m_pHead;
    }

    BOOL AtEnd() const
    {
        return m_pPos == NULL;
    }

    T * operator ++ (int) 
    {
        m_pPos = m_pPos->m_pNext;
        return (T *) m_pPos;
    }

    T * operator ++ () 
    {
        m_pPos = m_pPos->m_pNext;
        return (T *) m_pPos;
    }

    T * operator -- (int) 
    {
        m_pPos = m_pPos->m_pPrev;
        return (T *) m_pPos;
    }

    T * operator -- () 
    {
        m_pPos = m_pPos->m_pPrev;
        return (T *) m_pPos;
    }

    T * operator -> () const
    {
        return (T *) m_pPos;
    }

    T * operator () () const
    {
        return (T *) m_pPos;
    }


    operator T * () const
    {
        return (T *) m_pPos;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\common_src.cpp ===
// this is acting like a lib untile we make one

#include "..\common\debug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\inc\msctfx.h ===
DEFINE_GUID( IID_ITfSource,                 0x4ea48a35, 0x60ae, 0x446f, 0x8f, 0xd6, 0xe6, 0xa8, 0xd8, 0x24, 0x59, 0xf7);
DEFINE_GUID( IID_ITfKeystrokeMgr,           0xaa80e7f0, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfThreadMgr,              0xaa80e801, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfServiceProvider,        0xaa80e806, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfActivateInputProcessor, 0x32239201, 0xbbab, 0x47e5, 0xa5, 0x10, 0x66, 0x5f, 0xa3, 0xbd, 0x62, 0x64);
DEFINE_GUID( IID_ITfHotKeyMgr,              0xa998fa53, 0x6ada, 0x4f5a, 0x84, 0xed, 0xc2, 0x67, 0x0f, 0xbd, 0x0b, 0xdd);

DEFINE_GUID( IID_ITextStoreACPServices,     0xaa80e901, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITextStoreAnchorServices,  0xaa80e9fe, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);

DEFINE_GUID( CLSID_ThreadMgr,               0xaa80e7f1, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);

DEFINE_GUID( IID_ITfTextStoreACP,           0xaa80e800, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfTextStoreAnchor,		0xaa80e9ff, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);

DEFINE_GUID( IID_ITfCompartmentMgr,         0x7dcf57ac, 0x18ad, 0x438b, 0x82, 0x4d, 0x97, 0x9b, 0xff, 0xb7, 0x4b, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\dict.cpp ===
// Dict.cpp : Implementation of CDict
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAAdapter.h"
#include "Dict.h"

#include <initguid.h>
#include <tsattrs.h>
#include <math.h>


const int STR_RESOURCE_OFFSET				= 4000;
const int STR_WEIGHT_RESOURCE_OFFSET		= 4400;
const int STR_COLOR_RESOURCE_OFFSET			= 4500;
const int STR_BOOL_TRUE						= 4421;
const int STR_BOOL_FALSE					= 4422;

#define ARRAYSIZE( a )  (sizeof(a)/sizeof(a[0]))

DEFINE_GUID(GUID_NULL, 0x00000000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);

TermInfo g_Terms [ ] = 
{
    {&TSATTRID_Font,							NULL,								L"font",				0,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_FaceName,					&TSATTRID_Font,						L"facename",			1,	CDict::ConvertBSTRToString },
    {&TSATTRID_Font_SizePts,					&TSATTRID_Font,						L"sizePts",				2,	CDict::ConvertPtsToString },
    {&TSATTRID_Font_Style,						&TSATTRID_Font,						L"style",				3,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Bold,					&TSATTRID_Font_Style,				L"bold",				4,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Italic,				&TSATTRID_Font_Style,				L"italic",				5,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_SmallCaps,			&TSATTRID_Font_Style,				L"smallcaps",			6,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Capitalize,			&TSATTRID_Font_Style,				L"capitalize",			7,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Uppercase,			&TSATTRID_Font_Style,				L"uppercase",			8,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Lowercase,			&TSATTRID_Font_Style,				L"lowercase",			9,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation,			NULL,								L"animation",			10,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_LasVegasLights,		&TSATTRID_Font_Style_Animation,	L"LasVegas_lights",	11,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_BlinkingBackground,	&TSATTRID_Font_Style_Animation,	L"blinking_background",12,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_SparkleText,		&TSATTRID_Font_Style_Animation,	L"sparkle_text",	13,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_MarchingBlackAnts,	&TSATTRID_Font_Style_Animation,	L"marching_black_ants",14,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_MarchingRedAnts,	&TSATTRID_Font_Style_Animation,	L"marching_red_ants",15,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_Shimmer,	&TSATTRID_Font_Style_Animation,		L"shimmer",				16,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_WipeDown,	&TSATTRID_Font_Style_Animation,		L"wipeDown",			17,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_WipeRight,	&TSATTRID_Font_Style_Animation,		L"wipeRight",			18,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Emboss,				&TSATTRID_Font_Style,				L"emboss",				19,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Engrave,				&TSATTRID_Font_Style,				L"engrave",				20,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Kerning,				&TSATTRID_Font_Style,				L"kerning",				21,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Outlined,				&TSATTRID_Font_Style,				L"outlined",			22,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Position,				&TSATTRID_Font_Style,				L"position",			23,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Protected,			&TSATTRID_Font_Style,				L"potected",			24,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Shadow,				&TSATTRID_Font_Style,				L"shadow",				25,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Spacing,				&TSATTRID_Font_Style,				L"spacing",				26,	CDict::ConvertPtsToString },
    {&TSATTRID_Font_Style_Weight,				&TSATTRID_Font_Style,				L"weight",				27,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Height,				&TSATTRID_Font_Style,				L"height",				28,	CDict::ConvertPtsToString },
    {&TSATTRID_Font_Style_Underline,			&TSATTRID_Font_Style,				L"underline",			29,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Underline_Single,		&TSATTRID_Font_Style_Underline,		L"single",				30,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Underline_Double,		&TSATTRID_Font_Style_Underline,		L"double",				31,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Strikethrough,		&TSATTRID_Font_Style,				L"strike_through",		32,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Strikethrough_Single,	&TSATTRID_Font_Style_Strikethrough,	L"strike_through_single",33,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Strikethrough_Double,	&TSATTRID_Font_Style_Strikethrough,	L"strike_through_double",34,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Overline,				&TSATTRID_Font_Style,				L"overline",			35,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Overline_Single,		&TSATTRID_Font_Style,				L"overline_single",		36,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Overline_Double,		&TSATTRID_Font_Style,				L"overline_double",		37,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Blink,				&TSATTRID_Font_Style,				L"blink",				38,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Subscript,			&TSATTRID_Font_Style,				L"subscript",			39,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Superscript,			&TSATTRID_Font_Style,				L"superscript",			40,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Color,				&TSATTRID_Font_Style,				L"color",				41,	CDict::ConvertColorToString },
    {&TSATTRID_Font_Style_BackgroundColor,		&TSATTRID_Font_Style,				L"background_color",	42,	CDict::ConvertColorToString },
    {&TSATTRID_Text,							NULL,								L"text",				43,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_VerticalWriting,			&TSATTRID_Text,						L"vertical writing",	44,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_RightToLeft,				&TSATTRID_Text,						L"righttoleft",			45,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Orientation,				&TSATTRID_Text,						L"orientation",			46,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Language,					&TSATTRID_Text,						L"language",			47,	CDict::ConvertLangIDToString },
    {&TSATTRID_Text_ReadOnly,					&TSATTRID_Text,						L"read only",			48,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_EmbeddedObject,				&TSATTRID_Text,						L"embedded_object",		49,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Link,						&TSATTRID_Text,						L"link",				50,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment,					NULL,								L"alignment",			51,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Left,   			&TSATTRID_Text,						L"left",				52,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Right,  			&TSATTRID_Text,						L"right",				53,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Center, 			&TSATTRID_Text,						L"center",				54,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Justify,			&TSATTRID_Text,						L"justify",				55,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Hyphenation,				&TSATTRID_Text,						L"hyphenation",			56,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para,						&TSATTRID_Text,						L"paragraph",			57,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_FirstLineIndent,		&TSATTRID_Text_Para,				L"first_line_indent",	58,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_LeftIndent,			&TSATTRID_Text_Para,				L"left-indent",			59,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_RightIndent,			&TSATTRID_Text_Para,				L"right_indent",		60,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_SpaceAfter,			&TSATTRID_Text_Para,				L"space_after",			61,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_SpaceBefore,			&TSATTRID_Text_Para,				L"space_before",		62,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_LineSpacing,			NULL,								L"line_spacing",		63,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Single,   	&TSATTRID_Text_Para,				L"single",				64,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_OnePtFive,	&TSATTRID_Text_Para,				L"one_pt_five",			65,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Double, 	&TSATTRID_Text_Para,				L"double",				66,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_AtLeast,	&TSATTRID_Text_Para,				L"at_least",			67,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Exactly,	&TSATTRID_Text_Para,				L"exactly",				68,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Multiple, 	&TSATTRID_Text_Para,				L"multiple",			69,	CDict::ConvertBoolToString },
    {&TSATTRID_List,							NULL,								L"list",				70,	CDict::ConvertBoolToString },
    {&TSATTRID_List_LevelIndel,					&TSATTRID_List,						L"indent level",		71,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type,             			NULL,								L"type",				72,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_Bullet,      			&TSATTRID_List,						L"bullet",				73,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_Arabic,      			&TSATTRID_List,						L"arabic",				74,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_LowerLetter, 			&TSATTRID_List,						L"lower_letter",		75,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_UpperLetter, 			&TSATTRID_List,						L"upper_letter",		76,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_LowerRoman,  			&TSATTRID_List,						L"lower_roman",			77,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_UpperRoman,  			&TSATTRID_List,						L"upper_roman",			78,	CDict::ConvertBoolToString },
    {&TSATTRID_App,								NULL,								L"Application",			79,	CDict::ConvertBoolToString },
    {&TSATTRID_App_IncorrectSpelling,			&TSATTRID_App,						L"incorrect spelling",	80, CDict::ConvertBoolToString },
    {&TSATTRID_App_IncorrectGrammar,			&TSATTRID_App,						L"incorrect grammar",	81, CDict::ConvertBoolToString },
};

COLORREF g_ColorArray [] =
{
	RGB( 0xF0, 0xF8, 0xFF ),   // rgb 240,248,255	AliceBlue  		
	RGB( 0xFA, 0xEB, 0xD7 ),   // rgb 250,235,215	AntiqueWhite  	
	RGB( 0x00, 0xFF, 0xFF ),   // rgb 0,255,255		Aqua  			
	RGB( 0x7F, 0xFF, 0xD4 ),   // rgb 127,255,212	Aquamarine  	
	RGB( 0xF0, 0xFF, 0xFF ),   // rgb 240,255,255	Azure  			
	RGB( 0xF5, 0xF5, 0xDC ),   // rgb 245,245,220	Beige  			
	RGB( 0xFF, 0xE4, 0xC4 ),   // rgb 255,228,196	Bisque  		
	RGB( 0x00, 0x00, 0x00 ),   // rgb 0,0,0			Black  			
	RGB( 0xFF, 0xEB, 0xCD ),   // rgb 255,235,205	BlanchedAlmond  
	RGB( 0x00, 0x00, 0xFF ),   // rgb 0,0,255		Blue  			
	RGB( 0x8A, 0x2B, 0xE2 ),   // rgb 138,43,226	BlueViolet  	
	RGB( 0xA5, 0x2A, 0x2A ),   // rgb 165,42,42		Brown  			
	RGB( 0xDE, 0xB8, 0x87 ),   // rgb 222,184,135	BurlyWood  		
	RGB( 0x5F, 0x9E, 0xA0 ),   // rgb 95,158,160	CadetBlue  		
	RGB( 0x7F, 0xFF, 0x00 ),   // rgb 127,255,0		Chartreuse  	
	RGB( 0xD2, 0x69, 0x1E ),   // rgb 210,105,30	Chocolate  		
	RGB( 0xFF, 0x7F, 0x50 ),   // rgb 255,127,80	Coral  			
	RGB( 0x64, 0x95, 0xED ),   // rgb 100,149,237	CornflowerBlue  
	RGB( 0xFF, 0xF8, 0xDC ),   // rgb 255,248,220	Cornsilk  		
	RGB( 0xDC, 0x14, 0x3C ),   // rgb 220,20,60		Crimson  		
	RGB( 0x00, 0xFF, 0xFF ),   // rgb 0,255,255		Cyan  			
	RGB( 0x00, 0x00, 0x8B ),   // rgb 0,0,139		DarkBlue  		
	RGB( 0x00, 0x8B, 0x8B ),   // rgb 0,139,139		DarkCyan  		
	RGB( 0xB8, 0x86, 0x0B ),   // rgb 184,134,11	DarkGoldenrod  	
	RGB( 0xA9, 0xA9, 0xA9 ),   // rgb 169,169,169	DarkGray  		
	RGB( 0x00, 0x64, 0x00 ),   // rgb 0,100,0		DarkGreen 	 	
	RGB( 0xBD, 0xB7, 0x6B ),   // rgb 189,183,107	DarkKhaki  		
	RGB( 0x8B, 0x00, 0x8B ),   // rgb 139,0,139		DarkMagenta  	
	RGB( 0x55, 0x6B, 0x2F ),   // rgb 85,107,47		DarkOliveGreen  
	RGB( 0xFF, 0x8C, 0x00 ),   // rgb 255,140,0		DarkOrange  	
	RGB( 0x99, 0x32, 0xCC ),   // rgb 153,50,204	DarkOrchid  	
	RGB( 0x8B, 0x00, 0x00 ),   // rgb 139,0,0		DarkRed  		
	RGB( 0xE9, 0x96, 0x7A ),   // rgb 233,150,122	DarkSalmon  	
	RGB( 0x8F, 0xBC, 0x8F ),   // rgb 143,188,143	DarkSeaGreen  	
	RGB( 0x48, 0x3D, 0x8B ),   // rgb 72,61,139		DarkSlateBlue  	
	RGB( 0x2F, 0x4F, 0x4F ),   // rgb 47,79,79		DarkSlateGray  	
	RGB( 0x00, 0xCE, 0xD1 ),   // rgb 0,206,209		DarkTurquoise  	
	RGB( 0x94, 0x00, 0xD3 ),   // rgb 148,0,211		DarkViolet  	
	RGB( 0xFF, 0x14, 0x93 ),   // rgb 255,20,147	DeepPink  		
	RGB( 0x00, 0xBF, 0xFF ),   // rgb 0,191,255		DeepSkyBlue  	
	RGB( 0x69, 0x69, 0x69 ),   // rgb 105,105,105	DimGray  		
	RGB( 0x1E, 0x90, 0xFF ),   // rgb 30,144,255	DodgerBlue  	
	RGB( 0xB2, 0x22, 0x22 ),   // rgb 178,34,34		FireBrick  		
	RGB( 0xFF, 0xFA, 0xF0 ),   // rgb 255,250,240	FloralWhite  	
	RGB( 0x22, 0x8B, 0x22 ),   // rgb 34,139,34		ForestGreen  	
	RGB( 0xFF, 0x00, 0xFF ),   // rgb 255,0,255		Fuchsia  		
	RGB( 0xDC, 0xDC, 0xDC ),   // rgb 220,220,220	Gainsboro  		
	RGB( 0xF8, 0xF8, 0xFF ),   // rgb 248,248,255	GhostWhite  	
	RGB( 0xFF, 0xD7, 0x00 ),   // rgb 255,215,0		Gold  			
	RGB( 0xDA, 0xA5, 0x20 ),   // rgb 218,165,32	Goldenrod  		
	RGB( 0x80, 0x80, 0x80 ),   // rgb 128,128,128	Gray  			
	RGB( 0x00, 0x80, 0x00 ),   // rgb 0,128,0		Green  			
	RGB( 0xAD, 0xFF, 0x2F ),   // rgb 173,255,47	GreenYellow  	
	RGB( 0xF0, 0xFF, 0xF0 ),   // rgb 240,255,240	Honeydew  		
	RGB( 0xFF, 0x69, 0xB4 ),   // rgb 255,105,180	HotPink  		
	RGB( 0xCD, 0x5C, 0x5C ),   // rgb 205,92,92		IndianRed  		
	RGB( 0x4B, 0x00, 0x82 ),   // rgb 75,0,130		Indigo  		
	RGB( 0xFF, 0xFF, 0xF0 ),   // rgb 255,255,240	Ivory  			
	RGB( 0xF0, 0xE6, 0x8C ),   // rgb 240,230,140	Khaki  			
	RGB( 0xE6, 0xE6, 0xFA ),   // rgb 230,230,250	Lavender  		
	RGB( 0xFF, 0xF0, 0xF5 ),   // rgb 255,240,245	LavenderBlush  	
	RGB( 0x7C, 0xFC, 0x00 ),   // rgb 124,252,0		LawnGreen  		
	RGB( 0xFF, 0xFA, 0xCD ),   // rgb 255,250,205	LemonChiffon  	
	RGB( 0xAD, 0xD8, 0xE6 ),   // rgb 173,216,230	LightBlue  		
	RGB( 0xF0, 0x80, 0x80 ),   // rgb 240,128,128	LightCoral  	
	RGB( 0xE0, 0xFF, 0xFF ),   // rgb 224,255,255	LightCyan  		
	RGB( 0xFA, 0xFA, 0xD2 ),   // rgb 250,250,210	LightGoldenrodYellow
	RGB( 0x90, 0xEE, 0x90 ),   // rgb 144,238,144	LightGreen  	
	RGB( 0xD3, 0xD3, 0xD3 ),   // rgb 211,211,211	LightGrey  		
	RGB( 0xFF, 0xB6, 0xC1 ),   // rgb 255,182,193	LightPink  		
	RGB( 0xFF, 0xA0, 0x7A ),   // rgb 255,160,122	LightSalmon  	
	RGB( 0x20, 0xB2, 0xAA ),   // rgb 32,178,170	LightSeaGreen  	
	RGB( 0x87, 0xCE, 0xFA ),   // rgb 135,206,250	LightSkyBlue  	
	RGB( 0x77, 0x88, 0x99 ),   // rgb 119,136,153	LightSlateGray  
	RGB( 0xB0, 0xC4, 0xDE ),   // rgb 176,196,222	LightSteelBlue  
	RGB( 0xFF, 0xFF, 0xE0 ),   // rgb 255,255,224	LightYellow  	
	RGB( 0x00, 0xFF, 0x00 ),   // rgb 0,255,0		Lime  			
	RGB( 0x32, 0xCD, 0x32 ),   // rgb 50,205,50		LimeGreen  		
	RGB( 0xFA, 0xF0, 0xE6 ),   // rgb 250,240,230	Linen  			
	RGB( 0xFF, 0x00, 0xFF ),   // rgb 255,0,255		Magenta  		
	RGB( 0x80, 0x00, 0x00 ),   // rgb 128,0,0		Maroon  		
	RGB( 0x66, 0xCD, 0xAA ),   // rgb 102,205,170	MediumAquamarine
	RGB( 0x00, 0x00, 0xCD ),   // rgb 0,0,205		MediumBlue  	
	RGB( 0xBA, 0x55, 0xD3 ),   // rgb 186,85,211	MediumOrchid  	
	RGB( 0x93, 0x70, 0xDB ),   // rgb 147,112,219	MediumPurple  	
	RGB( 0x3C, 0xB3, 0x71 ),   // rgb 60,179,113	MediumSeaGreen  
	RGB( 0x7B, 0x68, 0xEE ),   // rgb 123,104,238	MediumSlateBlue 
	RGB( 0x00, 0x00, 0xFA ),   // rgb 0,0,154		MediumSpringGreen
	RGB( 0x48, 0xD1, 0xCC ),   // rgb 72,209,204	MediumTurquoise 
	RGB( 0xC7, 0x15, 0x85 ),   // rgb 199,21,133	MediumVioletRed 
	RGB( 0x19, 0x19, 0x70 ),   // rgb 25,25,112		MidnightBlue  	
	RGB( 0xF5, 0xFF, 0xFA ),   // rgb 245,255,250	MintCream  		
	RGB( 0xFF, 0xE4, 0xE1 ),   // rgb 255,228,225	MistyRose  		
	RGB( 0xFF, 0xE4, 0xB5 ),   // rgb 255,228,181	Moccasin  		
	RGB( 0xFF, 0xDE, 0xAD ),   // rgb 255,222,173	NavajoWhite  	
	RGB( 0x00, 0x00, 0x80 ),   // rgb 0,0,128		Navy  			
	RGB( 0xFD, 0xF5, 0xE6 ),   // rgb 253,245,230	OldLace  		
	RGB( 0x80, 0x80, 0x00 ),   // rgb 128,128,0		Olive  			
	RGB( 0x6B, 0x8E, 0x23 ),   // rgb 107,142,35	OliveDrab  		
	RGB( 0xFF, 0xA5, 0x00 ),   // rgb 255,165,0		Orange  		
	RGB( 0xFF, 0x45, 0x00 ),   // rgb 255,69,0		OrangeRed  		
	RGB( 0xDA, 0x70, 0xD6 ),   // rgb 218,112,214	Orchid  		
	RGB( 0xEE, 0xE8, 0xAA ),   // rgb 238,232,170	PaleGoldenrod  	
	RGB( 0x98, 0xFB, 0x98 ),   // rgb 152,251,152	PaleGreen  		
	RGB( 0xAF, 0xEE, 0xEE ),   // rgb 175,238,238	PaleTurquoise  	
	RGB( 0xDB, 0x70, 0x93 ),   // rgb 219,112,147	PaleVioletRed  	
	RGB( 0xFF, 0xEF, 0xD5 ),   // rgb 255,239,213	PapayaWhip  	
	RGB( 0xFF, 0xDA, 0xB9 ),   // rgb 255,218,185	PeachPuff  		
	RGB( 0xCD, 0x85, 0x3F ),   // rgb 205,133,63	Peru  			
	RGB( 0xFF, 0xC0, 0xCB ),   // rgb 255,192,203	Pink  			
	RGB( 0xDD, 0xA0, 0xDD ),   // rgb 221,160,221	Plum  			
	RGB( 0xB0, 0xE0, 0xE6 ),   // rgb 176,224,230	PowderBlue  	
	RGB( 0x80, 0x00, 0x80 ),   // rgb 128,0,128		Purple  		
	RGB( 0xFF, 0x00, 0x00 ),   // rgb 255,0,0		Red  			
	RGB( 0xBC, 0x8F, 0x8F ),   // rgb 188,143,143	RosyBrown  		
	RGB( 0x41, 0x69, 0xE1 ),   // rgb 65,105,225	RoyalBlue  		
	RGB( 0x8B, 0x45, 0x13 ),   // rgb 139,69,19		SaddleBrown  	
	RGB( 0xFA, 0x80, 0x72 ),   // rgb 250,128,114	Salmon  		
	RGB( 0xF4, 0xA4, 0x60 ),   // rgb 244,164,96	SandyBrown  	
	RGB( 0x2E, 0x8B, 0x57 ),   // rgb 46,139,87		SeaGreen  		
	RGB( 0xFF, 0xF5, 0xEE ),   // rgb 255,245,238	Seashell  		
	RGB( 0xA0, 0x52, 0x2D ),   // rgb 160,82,45		Sienna  		
	RGB( 0xC0, 0xC0, 0xC0 ),   // rgb 192,192,192	Silver  		
	RGB( 0x87, 0xCE, 0xEB ),   // rgb 135,206,235	SkyBlue  		
	RGB( 0x6A, 0x5A, 0xCD ),   // rgb 106,90,205	SlateBlue  		
	RGB( 0x70, 0x80, 0x90 ),   // rgb 112,128,144	SlateGray  		
	RGB( 0xFF, 0xFA, 0xFA ),   // rgb 255,250,250	Snow  			
	RGB( 0x00, 0xFF, 0x7F ),   // rgb 0,255,127		SpringGreen  	
	RGB( 0x46, 0x82, 0xB4 ),   // rgb 70,130,180	SteelBlue  		
	RGB( 0xD2, 0xB4, 0x8C ),   // rgb 210,180,140	Tan  			
	RGB( 0x00, 0x80, 0x80 ),   // rgb 0,128,128		Teal  			
	RGB( 0xD8, 0xBF, 0xD8 ),   // rgb 216,191,216	Thistle  		
	RGB( 0xFF, 0x63, 0x47 ),   // rgb 255,99,71		Tomato  		
	RGB( 0x40, 0xE0, 0xD0 ),   // rgb 64,224,208	Turquoise  		
	RGB( 0xEE, 0x82, 0xEE ),   // rgb 238,130,238	Violet  		
	RGB( 0xF5, 0xDE, 0xB3 ),   // rgb 245,222,179	Wheat  			
	RGB( 0xFF, 0xFF, 0xFF ),   // rgb 255,255,255	White  			
	RGB( 0xF5, 0xF5, 0xF5 ),   // rgb 245,245,245	WhiteSmoke  	
	RGB( 0xFF, 0xFF, 0x00 ),   // rgb 255,255,0		Yellow  		
	RGB( 0x9A, 0xCD, 0x32 )	// rgb 154,205,50		YellowGreen  	
};




BSTR BStrFromStringResource( HINSTANCE hInstance, UINT id, WORD langid, LCID & lcid );


CDict::CDict()
{
    IMETHOD( CDict );

    for (int i = 0;i < ARRAYSIZE( g_Terms ); i++)
    {
		m_mapDictionary[*g_Terms[i].pTermID] = &g_Terms[i];
    	m_mapMnemonicDictionary[g_Terms[i].pszMnemonic] = &g_Terms[i];
    }
}

CDict::~CDict()
{
    IMETHOD( ~CDict );
	if( m_hinstResDll )
		FreeLibrary( m_hinstResDll );
}



HRESULT STDMETHODCALLTYPE
CDict::GetLocalizedString (
	REFGUID			Term,
	LCID			lcid,
	BSTR *			pResult,
	LCID *			plcid			
)
{
    IMETHOD( GetLocalizedString );

	*plcid = lcid;
	
	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
	    *pResult = NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pResult = BStrFromStringResource( m_hinstResDll, 
										   STR_RESOURCE_OFFSET + pInfo.idString, 
										   LANGIDFROMLCID( lcid ),
										   *plcid );
	}

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CDict::GetParentTerm (
	REFGUID			Term,
	GUID *			pParentTerm
)
{
    IMETHOD( GetParentTerm );

	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
		*pParentTerm = GUID_NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pParentTerm = *pInfo.pParentID;
	}

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CDict::GetMnemonicString (
	REFGUID			Term,
	BSTR *			pResult
)
{
    IMETHOD( GetMnemonicString );
    

	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
	    *pResult = NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pResult = SysAllocString( pInfo.pszMnemonic );
	}

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CDict::LookupMnemonicTerm (
	BSTR			bstrMnemonic,
	GUID *			pTerm
)
{
    IMETHOD( LookupMnemonicTerm );

	const DictMnemonicMap::iterator it = m_mapMnemonicDictionary.find(bstrMnemonic);
	if (it == m_mapMnemonicDictionary.end())
	{
		*pTerm = GUID_NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pTerm = *pInfo.pTermID;
	}

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CDict::ConvertValueToString (
	REFGUID			Term,
	LCID			lcid,
	VARIANT			varValue,
	BSTR *			pbstrResult,
	LCID *			plcid			
)
{
    IMETHOD( ConvertValue );

	*plcid = lcid;
	
	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
	    *pbstrResult = NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pbstrResult = (this->*pInfo.mfpConvertToString)( varValue, *plcid );
	}
	
    return S_OK;
}

// Methods Convert????ToString are called by ConvertValueToString via a 
// member funtion pointer in the TerInfo struct that is stored in the map

BSTR CDict::ConvertPtsToString( const VARIANT & value, LCID & lcid )
{
	TCHAR data[5];

	// see if we using metric
	GetLocaleInfo( lcid, LOCALE_IMEASURE, data, ARRAYSIZE( data ) );

	WCHAR result[16];

	// convert to centementers or inches
	if ( lstrcmp( data, TEXT("0") ) == 0 )
	{
		swprintf( result, L"%.2f", value.lVal / 72.0 * 2.54 );
		wcscat(result, L" cm" );
	}
	else
	{
		swprintf( result, L"%.2f", value.lVal / 72.0 );
		wcscat(result, L" in" );
	}

	return SysAllocString( result );
}

BSTR CDict::ConvertBoolToString( const VARIANT & value, LCID & lcid )
{
	const WORD lang = LANGIDFROMLCID( lcid );
	if ( value.boolVal )
		return BStrFromStringResource( m_hinstResDll, STR_BOOL_TRUE, lang, lcid );
	else
		return BStrFromStringResource( m_hinstResDll, STR_BOOL_FALSE, lang, lcid );
}

BSTR CDict::ConvertColorToString( const VARIANT & value, LCID & lcid )
{
	const COLORREF cr = value.lVal;
	double MinDistance = 450.0;  //  larger than the max distance
	int color;

	// Go thru all the colors we have names for and find the closest one
	for ( int i = 0; i < ARRAYSIZE( g_ColorArray ); i++ )
	{
		double distance = ColorDistance( cr, g_ColorArray[i] );
		if ( distance <= MinDistance )
		{
			MinDistance = distance;
			color = i;
			if ( distance == 0.0 )
				break;
		}
	}

	return BStrFromStringResource( m_hinstResDll, 
								   STR_COLOR_RESOURCE_OFFSET + color, 
								   LANGIDFROMLCID( lcid ),
								   lcid );
}

BSTR CDict::ConvertWeightToString( const VARIANT & value, LCID & lcid )
{
	_ASSERTE( ( (value.lVal / 100) < 9 ) && ( (value.lVal / 100) ) > 0 );

	return BStrFromStringResource( m_hinstResDll, 
								   STR_WEIGHT_RESOURCE_OFFSET + (value.lVal / 100), 
								   LANGIDFROMLCID( lcid ),
								   lcid );
}

BSTR CDict::ConvertLangIDToString( const VARIANT & value, LCID & lcid )
{
	TCHAR data[128];

	GetLocaleInfo( lcid, LOCALE_SLANGUAGE, data, ARRAYSIZE( data ) );

	return T2BSTR(data);
}

BSTR CDict::ConvertBSTRToString( const VARIANT & value, LCID & lcid )
{

	return value.bstrVal;
}

// Distance is calculated the same as 3 dimensional cartesion distance.
// This will find how far away the two colors are
double CDict::ColorDistance(COLORREF crColor1, COLORREF crColor2)
{
    DWORD   dwDeltaRed;
    DWORD   dwDeltaGreen;
    DWORD   dwDeltaBlue;
    double  dfDistance;


    dwDeltaRed = abs(GetRValue(crColor1) - GetRValue(crColor2));
    dwDeltaGreen = abs(GetGValue(crColor1) - GetGValue(crColor2));
    dwDeltaBlue = abs(GetBValue(crColor1) - GetBValue(crColor2));
    dfDistance = sqrt(dwDeltaRed * dwDeltaRed + dwDeltaGreen * dwDeltaGreen + dwDeltaBlue * dwDeltaBlue);

    return dfDistance;
}

BOOL CALLBACK EnumResLangProc( HINSTANCE hModule, 
							   LPCTSTR lpszType, 
							   LPCTSTR lpszName, 
							   WORD wIDLanguage,  
							   LONG_PTR lParam )
{
	WORD Langid = *( WORD * )lParam;

	if ( Langid == wIDLanguage )
	{
		*( WORD * )lParam = 0;  // indicate we found it
		return FALSE;
	}
	
	if ( PRIMARYLANGID( Langid ) == PRIMARYLANGID( wIDLanguage ) )
		*( WORD * )lParam = wIDLanguage;

	return TRUE;
}


/*
 *  BStrFromStringResource
 *
 *  See KB Q196899 for details on how this works.
 *  A problem with LoadStringW is that it returns NULL on 9x - even
 *  though the string is available as UNICODE in the resource file.
 *
 *  (Another problem with LoadString is that there's no way
 *  to determine the length of the string in advance, so you have
 *  to guess the length of buffer to allocate.)
 *  This technique uses Find/Load/LockResource to get to the
 *  string in memory, and creates the BSTR direcly from that.
 *
 */

BSTR BStrFromStringResource( HINSTANCE hInstance, UINT id )
{
	LCID lcid;
    // MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) causes lang associted with calling thread to be used...
    return BStrFromStringResource( hInstance, id, LANGIDFROMLCID( GetThreadLocale() ), lcid );
}


BSTR BStrFromStringResource( HINSTANCE hInstance, UINT id, WORD lcid, LCID & Actuallcid)
{
    // String resources are stored in blocks of 16,
    // with the resource ID being the string ID / 16.
    // See KB Q196899 for more information.
    UINT block = (id >> 4) + 1;   // Compute block number.
    UINT offset = id & 0xf;      // Compute offset into block.

	WORD langid = LANGIDFROMLCID( lcid );
    WORD RealLangid = langid;
    WORD SortID = SORTIDFROMLCID( lcid  );

    // Make sure the language they want in in the resource file
    // if not use the one the matches the best
	EnumResourceLanguages( hInstance, RT_STRING, MAKEINTRESOURCE( block ), EnumResLangProc, ( DWORD_PTR )&RealLangid );

	if ( RealLangid )
	{
		// if the language they asked for is not in the resource file use the language of the thread
		if ( RealLangid == langid )
		{
			WORD ThreadLang = LANGIDFROMLCID( GetThreadLocale() );
			SortID = SORT_DEFAULT;

			RealLangid = ThreadLang;
			EnumResourceLanguages( hInstance, 
								   RT_STRING, 
								   MAKEINTRESOURCE( block ), 
								   EnumResLangProc, 
								   ( DWORD_PTR )&RealLangid );
			
			if ( RealLangid == ThreadLang )
				return NULL;	// we can't find any language that makes sence 
				
			if ( RealLangid == 0 )
				RealLangid = LANGIDFROMLCID( ThreadLang );
		}
		
		Actuallcid = MAKELCID( RealLangid, SortID );
	}
	else		// we found it 
	{
		RealLangid = langid;
		Actuallcid = lcid;
	}
	
    HRSRC hrsrc = FindResourceEx( hInstance, RT_STRING, MAKEINTRESOURCE( block ), langid );
    if( ! hrsrc )
	{
		DWORD err = GetLastError();

		// this is here until I figure out why FindResourceEx does not work
		hrsrc = FindResource( hInstance, MAKEINTRESOURCE( block ), RT_STRING );
		if( ! hrsrc )
			return NULL;
	}

    HGLOBAL hglobal = LoadResource( hInstance, hrsrc );
    if( ! hglobal )
        return NULL;

    LPWSTR pstr = (LPWSTR) LockResource( hglobal );
    if( ! pstr )
        return NULL;

    // Block contains 16 [<len><string...>] pairs.
    // Skip over as many strings (using the len header) as needed...
    for( UINT i = 0; i < offset; i++ )
    {
        pstr += *pstr + 1;
    }

    // Got the string we want - now use it to create a BStr.
    // (Note that the string is not NUL-terminated - but it
    // does have a length prefix, so we use that instead.)
    return SysAllocStringLen( pstr + 1, *pstr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__C3CDDC0F_06F6_44FD_B799_8F9F366B2F14__INCLUDED_)
#define AFX_DLLDATAX_H__C3CDDC0F_06F6_44FD_B799_8F9F366B2F14__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__C3CDDC0F_06F6_44FD_B799_8F9F366B2F14__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

//#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "com_external_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\inc\tstr.h ===
//
// TSTR - represents a writable position in a string.
//
// Has methods to safely append to the string. Will not overrun buffer,
// truncates if reaches the end.
//
//
// Sample usage:
//
//     void SomeFunc( TSTR & str )
//     {
//         int i = 42;
//         str << TEXT("Value is: ") << i;
//     }
//
// Can be used with TCHAR*-style APIs, by using the ptr(), left() and
// advance() members. ptr() returns pointer to current write position,
// left() returns number of chars left, and advance() updates the write
// position.
//
//     void MyGetWindowText( StrWrPos & str )
//     {
//         int len = GetWindowText( hWnd, str.ptr(), str.left() );
//         str.advance( len );
//     }
//
// This makes sure that the text will not be truncated
//     void MyGetWindowText( StrWrPos & str )
//     {
//			str.anticipate( GetWindowTextLength( hWnd );  
//     		int len = GetWindowText( hWnd, str.ptr(), str.left() );
//         	str.advance( len );
//     }
//
// Sample usage:
//
//     void Func( TSTR & str );
//
//     TSTR s(128);
//     s << TEXT("Text added: [");
//     Func( s ); // add more text to string
//     s << TEXT("]");
//
//     SetWindowText( hwnd, s );
//

//
// WriteHex - helper class to output hex values:
//
// Sample usage:
//
//    str << TEXT("Value is:") << WriteHex( hwnd, 8 );
//
// Can optionally specify number of digits to output. (result will be
// 0-padded.)
//

//
// WriteError - helper class to output COM error values:
//
// Sample usage:
//
//    hr = ProcessData();
//    if( hr != S_OK )
//    {
//        str << WriteError( hr, TEXT("in ProcessData()");
//        LogError( str.str() );
//    }
//

#ifndef _TSTR_H_
#define _TSTR_H_

#if ! defined( _BASETSD_H_ ) || defined( NEED_BASETSD_DEFINES )
// These allow us to compile with the pre-Win64 SDK (eg. using visual studio)
typedef unsigned long UINT_PTR;
typedef DWORD DWORD_PTR;
#define PtrToInt  (int)

#endif
#define LONG_TEXT_LENGTH 40

#include <oaidl.h>
#include <crtdbg.h>
#include <string>
typedef std::basic_string<TCHAR> tstring;
typedef std::string ASTR;			// save these names for where we expand
typedef std::wstring WSTR;			// the usage of this stuff to include them

class TSTR : public tstring
{
	// this is only used for ptr, left and advance functions.  
	ULONG m_lTheRealSize;

public:

	TSTR() : m_lTheRealSize(-1) { }

	TSTR(const TCHAR *s) : tstring(s, static_cast<size_type>(lstrlen(s))), m_lTheRealSize(-1) { }

	TSTR(const TCHAR *s, size_type n) : tstring(s, n), m_lTheRealSize(-1) { }

	TSTR(const tstring& rhs) : tstring(rhs), m_lTheRealSize(-1) { }
	
	TSTR(const tstring& rhs, size_type pos, size_type n) : tstring(rhs, pos, n), m_lTheRealSize(-1) { }
	
	TSTR(size_type n, TCHAR c) : tstring(n, c), m_lTheRealSize(-1) { }

	TSTR(size_type n) : tstring(), m_lTheRealSize(-1) { reserve( n + 1 ); }

	TSTR(const_iterator first, const_iterator last) : tstring(first, last), m_lTheRealSize(-1) { }

    operator const TCHAR * () 
    {
        return c_str();
    }

	TCHAR * ptr()              
	{
		_ASSERT(m_lTheRealSize == -1);
		m_lTheRealSize = size();

		TCHAR *pEnd = &(*end());
		resize(capacity());

		return pEnd; 
	}

	unsigned int left()	
	{
		unsigned int left;

		if (m_lTheRealSize == -1)
			left = ( capacity() - size() ) - 1;
		else
			left =  ( capacity() - m_lTheRealSize ) - 1;

		return left;
	}

	void advance( unsigned int c )
	{
		_ASSERT(m_lTheRealSize != -1);  // ptr has not been called so we should not need to advance
		if (m_lTheRealSize != -1)
		{
			at( m_lTheRealSize + c ) = NULL;	// make sure this stays null terminated
			resize(m_lTheRealSize + c);

			m_lTheRealSize = -1;
		}
	}

	void reset()
	{
		resize(0);
		m_lTheRealSize = -1;
	}

	void anticipate( unsigned int c )
	{
		if ( c > 0 )
		{
			unsigned int cSize;

			if ( m_lTheRealSize == -1 )
				cSize = size();
			else
				cSize = m_lTheRealSize;

			const unsigned int i = capacity() - cSize;

			if ( i < c )
				reserve( cSize + c + 1 );
		}
	}

};

inline 
TSTR & operator << ( TSTR & str, const TCHAR * obj )
{
	if ( obj )
		str.append( obj );
	return str;
}

inline 
TSTR & operator << ( TSTR & str, TCHAR obj )
{
	str.append( &obj, 1 );
	return str;
}

inline 
TSTR & operator << ( TSTR & str, long obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_ltow( obj, sz, 10 ));	
	return str;
#else
	str.append(_ltoa( obj, sz, 10 ));
	return str;
#endif
}

inline 
TSTR & operator << ( TSTR & str, unsigned long obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_ultow( obj, sz, 10 ));
	return str;
#else
	str.append(_ultoa( obj, sz, 10 ));
	return str;
#endif
}

inline 
TSTR & operator << ( TSTR & str, int obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_itow( obj, sz, 10 ));
	return str;
#else
	str.append(_itoa( obj, sz, 10 ));
	return str;
#endif
}

inline 
TSTR & operator << ( TSTR & str, unsigned int obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_ultow( static_cast<unsigned long>(obj), sz, 10 ));
	return str;
#else
	str.append(_ultoa( static_cast<unsigned long>(obj), sz, 10 ));
	return str;
#endif

}

#ifndef UNICODE
inline 
TSTR & operator << ( TSTR & str, const WCHAR * obj )
{
	if ( obj )
	{
		str.anticipate( wcslen( obj ) + 1 );
		
		int len = WideCharToMultiByte( CP_ACP, 0, obj, -1, str.ptr(), str.left(), NULL, NULL );
    
		// Len, in this case, includes the terminating NUL - so subtract it, if
		// we got one...
		if( len > 0 )
			len--;

		str.advance( len );
	}
	return str;
}
#endif

//
// WriteHex - helper class to output hex values:
//
// See top of file for usage notes.
//

class WriteHex
{
    DWORD_PTR m_dw;
	int   m_Digits;
public:

    // If Digits not specified, uses only as many as needed.
	WriteHex( DWORD dw, int Digits = -1 ) : m_dw( dw ), m_Digits( Digits ) { }

    // For pointer, pads if necessary to get std. ptr size.
    // (sizeof(ptr)*2, since 2 digits per byte in ptr).
	WriteHex( const void * pv, int Digits = sizeof(void*)*2 ) : m_dw( (DWORD_PTR)pv ), m_Digits( Digits ) { }

	void Write( TSTR & str ) const
	{
		static const TCHAR * HexChars = TEXT("0123456789ABCDEF");

		//str << TEXT("0x");


		int Digit;
		if( m_Digits == -1 )
		{
			// Work out number of digits...
			Digit = 0;
			DWORD test = m_dw;
			while( test )
			{
				Digit++;
				test >>= 4;
			}

			// Special case for 0 - still want one digit.
			if( Digit == 0 )
				Digit = 1;
		}
		else
			Digit = m_Digits;

		while( Digit )
		{
			Digit--;
			str << HexChars[ ( m_dw >> (Digit * 4) ) & 0x0F ];
		}
	}
};

inline
TSTR & operator << ( TSTR & s, const WriteHex & obj )
{
	obj.Write( s );
	return s;
}

//
// WriteError - helper class to output COM error values:
//
// See top of file for usage notes.
//

class WriteError
{
    HRESULT m_hr;
	LPCTSTR m_pWhere;
public:
	WriteError( HRESULT hr, LPCTSTR pWhere = NULL )
		: m_hr( hr ),
		  m_pWhere( pWhere )
	{ }

	void Write( TSTR & str ) const
	{
		str << TEXT("[Error");
		if( m_pWhere )
			str << TEXT(" ") << m_pWhere;
		str << TEXT(": hr=0x") << WriteHex( m_hr ) << TEXT(" - ");
		if( m_hr == S_FALSE )
		{
			str << TEXT("S_FALSE");
		}
		else
		{
			int len = FormatMessage( 
					FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					m_hr,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
					str.ptr(),
					str.left(),
					NULL );
			if( len > 2 )
				len -= 2; // Ignore trailing /r/n that FmtMsg() adds...
			str.advance( len );
		}
		str << TEXT("]");
	}
};

inline
TSTR & operator << ( TSTR & s, const WriteError & obj )
{
	obj.Write( s );
	return s;
}

inline
TSTR & operator << ( TSTR & s, const GUID & guid )
{
    s << TEXT("{") << WriteHex( guid.Data1, 8 )  // DWORD
      << TEXT("-") << WriteHex( guid.Data2, 4 )  // WORD
      << TEXT("-") << WriteHex( guid.Data3, 4 )  // WORD
      << TEXT("-")
      << WriteHex( guid.Data4[ 0 ], 2 )
      << WriteHex( guid.Data4[ 1 ], 2 )
      << TEXT("-");

    for( int i = 2 ; i < 8 ; i++ )
    {
        s << WriteHex( guid.Data4[ i ], 2 ); // BYTE
    }
    s << TEXT("}");
    return s;
}

inline
TSTR & operator << ( TSTR & s, const VARIANT & var )
{
    s << TEXT("[");
    switch( var.vt )
    {
        case VT_EMPTY:
        {
            s << TEXT("VT_EMPTY");
            break;
        }

        case VT_I4:
        {
            s << TEXT("VT_I4=0x");
            s << WriteHex( var.lVal );
            break;
        }

        case VT_I2:
        {
            s << TEXT("VT_I2=0x");
            s << WriteHex( var.iVal );
            break;
        }

        case VT_BOOL:
        {
            s << TEXT("VT_BOOL=");
            if( var.boolVal == VARIANT_TRUE )
                s << TEXT("TRUE");
            else if( var.boolVal == VARIANT_FALSE )
                s << TEXT("FALSE");
            else
                s << TEXT("?") << var.boolVal;
            break;
        }

        case VT_R4:
        {
            float fltval = var.fltVal;
            int x = (int)(fltval * 100);

            s << TEXT("VT_R4=") << x/100 << TEXT(".") 
                                << x/10 % 10 
                                << x % 10;
            break;
        }

        case VT_BSTR:
        {
            s << TEXT("VT_BSTR=\"") << var.bstrVal << TEXT("\"");
            break;
        }

        case VT_UNKNOWN:
        {
            s << TEXT("VT_UNKNOWN=0x") << WriteHex( var.punkVal, 8 );
            break;
        }

        case VT_DISPATCH:
        {
            s << TEXT("VT_DISPATCH=0x") << WriteHex( var.pdispVal, 8 );
            break;
        }

        default:
        {
            s << TEXT("VT_? ") << (long)var.vt;
            break;
        }
    }

    s << TEXT("]");
    return s;
}

inline
TSTR & operator << ( TSTR & s, const POINT & pt )
{
    s << TEXT("{x:") << pt.x
      << TEXT(" y:") << pt.y
      << TEXT("}");
    return s;
}

inline
TSTR & operator << ( TSTR & s, const RECT & rc )
{
    s << TEXT("{l:") << rc.left
      << TEXT(" t:") << rc.top
      << TEXT(" r:") << rc.right
      << TEXT(" b:") << rc.bottom
      << TEXT("}");
    return s;
}


#endif // _TSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\docwrap.h ===
// DocWrap.h : Declaration of the CDocWrap

#ifndef __DOCWRAP_H_
#define __DOCWRAP_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDocWrap


class IWrapMgr;


class ATL_NO_VTABLE CDocWrap : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDocWrap, &CLSID_DocWrap>,
	public IDocWrap
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_DOCWRAP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDocWrap)
	COM_INTERFACE_ENTRY(IDocWrap)
END_COM_MAP()


	CDocWrap();
	~CDocWrap();

    // IDocWrap

    HRESULT STDMETHODCALLTYPE SetDoc (
        REFIID      riid,
        IUnknown *  punk
    );
    
    HRESULT STDMETHODCALLTYPE GetWrappedDoc (
        REFIID      riid,
        IUnknown ** ppunk
    );
        
private:

    IID         m_iid;
    IUnknown *  m_punkDoc;
    IWrapMgr *  m_pWrapMgr;

    void _Clear();
};

#endif //__DOCWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\docwrap.cpp ===
// DocWrapImpl.cpp : Implementation of CDocWrap
#include "stdafx.h"
#include "MSAAText.h"
#include "DocWrap.h"

#include <list_dl.h>
#include "VersionInfo.h"

#include <msctf.h>
#include <msctfp.h>
#define INITGUID
#include <msctfx.h>

#include <tStr.h>

#include <fwd_macros.h> // currently in the DocModel\inc dir... adjust appropriately if porting...


/*
 *  IDoc   - the variant of the ITextStoreACP we're using (ACP/Anchor)
 *  ISink  - the corresponding Sink interface (ACP/Anchor)
 *
 *  ICicDoc - the Cicero doc interface, which extends IDoc
 *  ICicSink - the Cicero sink interface, which extends ISink
 *
 *  CDocWrap - the document wrapper class, implements ICicDoc (which includes IDoc)
 *  CSinkWrap - the sink wrapper class, implements ICicSink (which includes ISink)
 *
 */


class BasicDocTraitsAnchor
{
public:
    typedef struct ITextStoreAnchor         IDoc;
    typedef struct ITextStoreAnchorSink     ISink;

    typedef struct ITextStoreAnchor         ICicDoc;
    typedef struct ITextStoreAnchorServices ICicSink;

    typedef class  CDocWrapAnchor           CDocWrap;
    typedef class  CSinkWrapAnchor          CSinkWrap;

    typedef struct ITextStoreAnchorEx       IDocEx;
    typedef struct ITextStoreSinkAnchorEx   ISinkEx;

    typedef IAnchor * PosType;
};


class BasicDocTraitsACP
{
public:
    typedef struct ITextStoreACP            IDoc;
    typedef struct ITextStoreACPSink        ISink;

    typedef struct ITextStoreACP            ICicDoc;
    typedef struct ITextStoreACPServices    ICicSink;

    typedef class  CDocWrapACP              CDocWrap;
    typedef class  CSinkWrapACP             CSinkWrap;


    typedef struct ITextStoreACPEx          IDocEx;
    typedef struct ITextStoreACPSinkEx      ISinkEx;

    typedef LONG PosType;
};


// DocWrapExcept contains exception wrapper classes for
// some of the above interfaces...
#include "DocWrapExcept.h"


// Add the appropriate exception wrappers to the set of
// doc traits.

class DocTraitsAnchor: public BasicDocTraitsAnchor
{
public:

    typedef SEHWrapPtr_TextStoreAnchor IDocSEHWrap;
};


class DocTraitsACP: public BasicDocTraitsACP
{
public:

    typedef SEHWrapPtr_TextStoreACP IDocSEHWrap;
};


/////////////////////////////////////////////////////////////////




// Create an instance of a local non-externally-createable class.
// Just a wrapper for CComObject::CreateInstance, but also AddRef's so that
// the returned object has a ref of 1.
template< class C >
HRESULT CreateLocalInstance( C ** p )
{
    CComObject< C > * p2 = NULL;

    HRESULT hr = CComObject< C >::CreateInstance( & p2 );

    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("CreateLocalInstance") );
        return hr;
    }
    
    if( p2 == NULL || hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("CreateLocalInstance returned NULL") );
        return E_UNEXPECTED;
    }

    p2->AddRef();
    *p = p2;
    return S_OK;
}



// Check hr and condition - return appropriate error if not S_OK and ! cond.
#define CHECK_HR_RETURN( hr, cond ) /**/ \
    if( (hr) != S_OK ) \
        return FAILED( (hr) ) ? (hr) : E_UNEXPECTED; \
    if( (hr) == S_OK && ! ( cond ) ) \
        return E_UNEXPECTED;



template < class T >
inline 
void SafeReleaseClear( T * & ptr )
{
    if( ptr )
    {
        ptr->Release();
        ptr = NULL;
    }
}

class CPrivateAddRef
{
public:
	CPrivateAddRef( long &rc ) : m_refcount( rc ) { m_refcount++; }
	~CPrivateAddRef() { m_refcount--; }
private:
	long &m_refcount;
};


class _declspec(uuid("{54D5D291-D8D7-4870-ADE1-331D86FD9430}")) IWrapMgr: public IUnknown
{
public:
    virtual void    STDMETHODCALLTYPE SetDoc( IUnknown * pDoc ) = 0;
    virtual HRESULT STDMETHODCALLTYPE CreateWrappedDoc( IUnknown ** ppDoc ) = 0;
};




template < class DocTraits >
class ATL_NO_VTABLE CWrapMgr :
	public CComObjectRootEx< CComSingleThreadModel >,
    public IWrapMgr
{
public:

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP( CWrapMgr< DocTraits > )
	COM_INTERFACE_ENTRY( IWrapMgr )
END_COM_MAP()

private:

    // Ptr to the original document.
    // Each DocWrapper also has a copy of this ptr - but only we have a refcount on it.
//    DocTraits::IDoc *               m_pDoc;
    DocTraits::IDocSEHWrap            m_pDoc;

    // Used to remember who requested a sync lock...
    DocTraits::CDocWrap *           m_pLockRequestedBy;

    BOOL                            m_fInSyncLockRequest;

    // Used to remember currently requested lock (ro vs rw)
    DWORD                           m_dwPendingLock;

    // Our sink - called by the doc
    DocTraits::CSinkWrap *          m_pSinkWrap;

    // Current sink event mask - all client sink masks or'd together.
    DWORD                           m_dwSinkMask;
    BOOL                            m_fSinkActive;

public:


    // List of DocWraps (one per client)
    List_dl< DocTraits::CDocWrap >  m_DocWraps;

    LONG m_lIterationRefCount;
    
    //
    // Ctor, Dtor...
    //

    CWrapMgr()
        : m_pDoc( NULL ),
          m_pSinkWrap( NULL ),
          m_dwSinkMask( 0 ),
          m_fSinkActive( FALSE ),
          m_pLockRequestedBy( NULL ),
          m_fInSyncLockRequest( FALSE ),
          m_dwPendingLock( 0 ),
          m_lIterationRefCount( 0 )

    {
        // Done.
        TraceInfo( TEXT("WrapMgr ctor") );
    }



    ~CWrapMgr()
    {
        TraceInfo( TEXT("WrapMgr dtor") );

        AssertMsg( m_pDoc, TEXT("CWrapMgr::SetDoc never called?") );
        
        m_pDoc->Release();
        
        Assert( m_DocWraps.empty() );
        Assert( m_pSinkWrap == NULL );
        Assert( m_dwSinkMask == 0 );
    }


    //
    // IWrapMgr interface - used by the DocWrap holder to give us a doc and ask for wrappers for it...
    //

    void STDMETHODCALLTYPE SetDoc( IUnknown * pDoc )
    {
        _SetDoc( static_cast< DocTraits::IDoc * >( pDoc ) );
    }


    HRESULT STDMETHODCALLTYPE CreateWrappedDoc( IUnknown ** ppDoc )
    {
        return _CreateWrappedDoc( reinterpret_cast< DocTraits::IDoc ** >( ppDoc ) );
    }

	void RemoveDeadDocs()
	{
        for( Iter_dl < DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; )
        {
			Iter_dl < DocTraits::CDocWrap > dead = i;

			i++;
        	
        	if (dead->m_bUnadvised && m_lIterationRefCount == 0)
			    m_DocWraps.remove( dead );
        }
	}

    //
    // Called by DocWrap, to tell us when it's been released, and to get us (the wrapper manager)
    // to handle a call that affects other wrappers on the same doc - advise/unadvise and lock calls.
    //

    void DocWrap_NotifyDisconnect( DocTraits::CDocWrap * pFrom )
    {
        // A DocWrap has been released by a client and is going away...

        // TODO - if using locks, check pFrom for lock, if it has it, release, broadcast relase.
        // - how can this scenario occur?
        // - doc is released in callback. Weird, but valid?

    }
    
    HRESULT DocWrap_HandleRequestLock( DocTraits::CDocWrap * pFrom, DWORD dwLockFlags, HRESULT * phrSession )
    {
        // Other clients may request a lock while it's being held by someone else, but the
        // current holder should not request a lock.
        // (This can happen when client1 is holding a lock, and issues an editing operation.
        // The wrapper broadcasts a OnTextChange event to other clients, and they may request locks.)
        AssertMsg( m_pLockRequestedBy != pFrom, TEXT("Lock owner re-request held lock? (Reentrancy?)") );

        if( dwLockFlags == 0 ||
            dwLockFlags & ~ ( TS_LF_SYNC | TS_LF_READ | TS_LF_READWRITE ) )  // check that only these bits present
        {
            AssertMsg( FALSE, TEXT("Bad lock flags") );
            return E_INVALIDARG;
        }


        if( dwLockFlags & TS_LF_SYNC )
        {
            // Can't process a SYNC call while someone else is holding the lock...
            if( m_pLockRequestedBy )
            {
                return E_FAIL;
            }

            // Sync lock - can just pass through - need to set up m_pLockRequestedBy so that the
            // sink can pass it onto the correct client.
            m_pLockRequestedBy = pFrom;
            m_fInSyncLockRequest = TRUE;
            HRESULT hr = m_pDoc->RequestLock( dwLockFlags, phrSession );
            m_fInSyncLockRequest = FALSE;
            m_pLockRequestedBy = NULL;
            return hr;
        } // sync lock
        else
        {
            // if async lock, update/upgrade the wrap's pending lock mask if necessary...
            // This test (which assumes that dwLockFlags != 0) upgrades to r/w if necessary.

            // TODO - should this update only be done conditionally if RequestLock succeeds?
            // (or no upgrade necessary?)
            Assert( dwLockFlags != 0 );
            if( pFrom->m_dwPendingLock != TS_LF_READWRITE )
                pFrom->m_dwPendingLock = dwLockFlags;
            
            if( m_pLockRequestedBy )
            {
                // someone else is currently holding the lock.
                // All we have to do is update the doc's PendingLock flags (see above)  - they will
                // be picked up and handled by the loop in Handle_OnLockGranted when the current
                // lock holder returns.
                // Nothing else to do here.
                
                // But send it on the doc anyway if it's the same person
                if ( m_pLockRequestedBy == pFrom )
                {
                    return m_pDoc->RequestLock( m_dwPendingLock, phrSession );
                }
                
                return S_OK;
            }
            else
            {
                // We don't have a lock yet.

                // Check our current request, if any, and if necessary, request a write,
                // even if we've already requested a read.

                
                // Update combined mask if necessary...
                DWORD dwNewLock = m_dwPendingLock;
                // Calculate required lock...
                if( dwNewLock != TS_LF_READWRITE )
                    dwNewLock = dwLockFlags;

                HRESULT hr = E_FAIL;

                // Do we need to request a new lock/upgrade?
                if( dwNewLock != m_dwPendingLock )
                {
                    // May get an immediate response even for an async request, so need to set this up
                    // event if not a sync request...
                    m_pLockRequestedBy = pFrom;

                    DWORD OldPendingLock = m_dwPendingLock;
                    m_dwPendingLock = dwNewLock;

                    HRESULT hrOut = E_FAIL;
                    hr = m_pDoc->RequestLock( m_dwPendingLock, & hrOut );

                    m_pLockRequestedBy = NULL;

                    if( hr != S_OK )
                    {
                        // After all that, the request failed...
                        // Revert to previous pending lock...
                        m_dwPendingLock = OldPendingLock;

                        // fall out...
                    }
                    else
                    {
                        // Regardless of fail/success, copy the outgoing hr.
                        // Clearing of the pending flags is done in OnLockgranted, not here.

                        // Shouldn't get this for an async request...
                        Assert( hrOut !=  TS_E_SYNCHRONOUS );

                        *phrSession = hrOut;
                    }
                }
                else
                {
                    // Our existing pending lock covers this request - success.
                    *phrSession = TS_S_ASYNC;
                    hr = S_OK;
                }

                return hr;
            }
        } // async lock
    }


    HRESULT DocWrap_UpdateSubscription()
    {
        Assert( ( m_dwSinkMask & ~ TS_AS_ALL_SINKS ) == 0 );
        // If there are no active sinks, then SinkMask should be 0.
        Assert( m_fSinkActive || m_dwSinkMask == 0 );

        // Work out required mask - by or'ing masks of all doc's sinks...
        DWORD NewMask = 0;
        BOOL NewfSinkActive = FALSE;
        for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
        {
            if( i->m_Sink.m_pSink != NULL )
            {
                Assert( ( i->m_Sink.m_dwMask & ~ TS_AS_ALL_SINKS ) == 0 );
                NewMask |= i->m_Sink.m_dwMask;
                NewfSinkActive = TRUE;
            }
        }

        Assert( ( NewMask & ~ TS_AS_ALL_SINKS ) == 0 );
        // If there are no active sinks, then NewMask should be 0.
        Assert( NewfSinkActive || NewMask == 0 );


        // Tricky bit:
        // NewMask==0 does not mean that there's no sinks - some may have
        // dwMask == 0 to receive LockGranted calls.
        // So to check if the status has changed, we need to take whether
        // there are any active sinks (not just the masks) into account.

        if( NewfSinkActive == m_fSinkActive && NewMask == m_dwSinkMask )
        {
            // No change - nothing to do.
            return S_OK;
        }

        // Three possibilities:
        // (a) free to unregister,
        // (b) need to register
        // (c) need to update existing registration.
        // We handle (b) and (c) as the same case.

        if( ! NewfSinkActive )
        {
            // No sinks - can unregister...

            m_fSinkActive = FALSE;
            m_dwSinkMask = 0;

            if( ! m_pSinkWrap )
            {
                Assert( FALSE );
                // Odd - where did our sink wrap go - we didn't unregister it yet, so it should
                // still be around...
                // (Possible that server pre-emptively released us - so not an error.)
            }
            else
            {
                // Don't do anything else with m_pSinkWrap - the doc should release it.
                HRESULT hr = m_pDoc->UnadviseSink( static_cast< DocTraits::ICicSink * >( m_pSinkWrap ) );
                // shouldn't fail...
                Assert( hr == S_OK );

                // Doc should have released the sink (which would have called us back to NULL out
                // m_pSinkWrap...)
                Assert( m_pSinkWrap == NULL );
            }
            return S_OK;
        }
        else
        {
            // Update existing / add new...

            // If we already had an existing sink, there should be a sinkwrap...
            // (unless doc let it go prematurely...)
            Assert( ! m_fSinkActive || m_pSinkWrap  );

            BOOL NeedRelease = FALSE;
            if( ! m_pSinkWrap )
            {
                HRESULT hr = CreateLocalInstance( & m_pSinkWrap );
                if( hr != S_OK )
                    return hr;
                
                m_pSinkWrap->Init( this, & m_DocWraps );

                // After doing the Advise, release our ref on the sink, so that only
                // the doc holds a ref and controls its liftetime.
                // We still keep a pointer, but it's a "weak reference" - if the 
                // sink goes away (because the doc releases its reference), the sink
                // notifies us so we can NULL-out the ptr. (see SinkWrap_NotifyDisconnect)
                NeedRelease = TRUE;
            }

            

            // Always try advising with the Cicero sink first - if that
            // doesn't work, fall back to the ITextStoreACP one.
            //
            // (Use of static_cast is necessary here to avoid ambiguity over
            // which IUnknown we convert to - the ICicSink one, or the
            // IServiceProvider one. We want the ICicSink one, to match the
            // IID passed in.)

            HRESULT hr = m_pDoc->AdviseSink( __uuidof( DocTraits::ICicSink ), static_cast< DocTraits::ICicSink * >( m_pSinkWrap ), NewMask );
            if( hr != S_OK )
            {
                hr = m_pDoc->AdviseSink( __uuidof( DocTraits::ISink ), static_cast< DocTraits::ISink * >( m_pSinkWrap ), NewMask );
            }

            if( NeedRelease )
            {
                m_pSinkWrap->Release();
            }

            if( hr == S_OK )
            {
                m_fSinkActive = TRUE;
                m_dwSinkMask = NewMask;
            }
            else
            {
                AssertMsg( FALSE, TEXT("AdviseSink failed") );
            }

            return hr;
        }
    }


    void  DocWrap_NotifyRevoke()
    {

        // Send OnDisconnect to any SinkEx sinks,
		CPrivateAddRef MyAddRef(m_lIterationRefCount);

        for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
        {
            // Is this the SinkExt sink?
            if( i->m_Sink.m_iid == __uuidof( DocTraits::ISinkEx ) )
            {
                DocTraits::ISinkEx * pSink = static_cast< DocTraits::ISinkEx * >( i->m_Sink.m_pSink );

				if ( pSink )
					pSink->OnDisconnect();
            }
        }

        for( Iter_dl < DocTraits::CDocWrap > j ( m_DocWraps ) ; ! j.AtEnd() ; )
        {
			Iter_dl < DocTraits::CDocWrap > DocToDelete = j;
	        j++;

	        m_DocWraps.remove( DocToDelete );
	        DocToDelete->Release();
       }
        

    }


    //
    // Called by SinkWrap to let us know when its been released...
    //

    void SinkWrap_NotifyDisconnect()
    {
        // The sink has been released by the application - it's now deleteing itself,
        // so we NULL-out our weak reference to it. (If we need another one in future,
        // we'll create a new one.)
        
        // Clear our sinks to reflect this...
        for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
        {
            i->m_Sink.ClearAndRelease();
        }
        
        m_pSinkWrap = NULL;
    }

    HRESULT SinkWrap_HandleOnLockGranted ( DWORD dwLockFlags )
    {
        // Is this servicing a sync or async request?
        Assert( ( dwLockFlags & ~ ( TS_LF_SYNC | TS_LF_READ | TS_LF_READWRITE ) ) == 0 );

		CPrivateAddRef MyAddRef(m_lIterationRefCount);

        if( m_fInSyncLockRequest )
        {
            // Sync lock - just pass it straight through to whoever requested it...
            Assert( dwLockFlags & TS_LF_SYNC );
            Assert( m_pLockRequestedBy && m_pLockRequestedBy->m_Sink.m_pSink );

            if( ! m_pLockRequestedBy || ! m_pLockRequestedBy->m_Sink.m_pSink )
                return E_UNEXPECTED;
            
            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * > ( m_pLockRequestedBy->m_Sink.m_pSink );

            HRESULT hr = pSink->OnLockGranted( dwLockFlags );
            return hr;
        }
        else
        {
            // Async lock - hand it out to whoever wanted it...
            Assert( ! ( dwLockFlags & TS_LF_SYNC ) );

            // If we're waiting for a r/w lock, the lock granted should be r/w too...
            Assert( ! ( m_dwPendingLock & TS_LF_READWRITE ) || ( dwLockFlags & TS_LF_READWRITE ) );


            // Clear the pending lock, since we're now servicing them...
            m_dwPendingLock = 0;

            // Keep looking through the docs, servicing locks. We loop because some docs may
            // request locks while another holds the lock, so we have to come back an service them.
            // When we loop through all docs without seeing any locks, then we know all locks
            // have been serviced.
            //
            // If this is a read lock, then we can only service read locks now - we'll have to
            // ask for a separate write lock later if we need one.
            BOOL fNeedWriteLock = FALSE;
            for( ; ; )
            {
                BOOL fWorkDone = FALSE;

                // Forward to all clients who had requested a lock...
                for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
                {
                    // Is the mask we've been granted sufficient for the client's request (if any)?
                    DWORD ReqdLock = i->m_dwPendingLock;
                    if( ReqdLock )
                    {
                        if( ( ReqdLock | dwLockFlags ) == dwLockFlags )
                        {
                            // tell the doc wrapper that it is in OnLockGranted and what kind of lock it has
                            i->m_dwGrantedLock = ReqdLock;
                            
                            // Clear the mask...
                            i->m_dwPendingLock = 0;

                            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * > ( i->m_Sink.m_pSink );

// How about...
// (a) also call Next before callback.
// (b) store current value of iter in mgr - in doc's release, it can check, and bump if necessary;
                            pSink->OnLockGranted( ReqdLock );

                            // tell the doc wrapper that it is no longer in OnLockGranted
                            i->m_dwGrantedLock = 0;
                            
                            fWorkDone = TRUE;
                        }
                        else
                        {
                            // This client wants a write lock, but we've only got a read lock...
                            fNeedWriteLock = TRUE;
                        }
                    }
                }

                // If we didn't need to handle any lock requests the last time around the loop,
                // then our work is done. (If we did handle any lock requests, we should go back
                // and re-check all docs, in case one of them requested a lock while one of the
                // locks we serviced was holding it.)
                if( ! fWorkDone )
                    break;
            }


            if( fNeedWriteLock )
            {
// TODO - need to find a way to handle this. Can we call the doc's RequestLock again now?
                AssertMsg( FALSE, TEXT("Write lock requested while holding read lock - not implemented yet") );
            }

            // All done!
            return S_OK;
        }
    }



private:
    
    //
    // Internal functions...
    //


    void _SetDoc( DocTraits::IDoc * pDoc )
    {
        AssertMsg( ! m_pDoc, TEXT("CWrapMgr::SetDoc should be called once when m_pDoc is NULL") );
        m_pDoc = pDoc;
        m_pDoc->AddRef();
    }



    HRESULT _CreateWrappedDoc( DocTraits::IDoc ** ppDoc )
    {
        *ppDoc = NULL;

        // Create a doc wrapper...
        DocTraits::CDocWrap * pCDocWrap;
        HRESULT hr = CreateLocalInstance( & pCDocWrap );
        CHECK_HR_RETURN( hr, pCDocWrap != NULL );

        pCDocWrap->Init( this, m_pDoc );

        // Add to our list...
        m_DocWraps.AddToHead( pCDocWrap );
        
        // And return it...
        *ppDoc = pCDocWrap;
        return S_OK;
    }
};








struct SinkInfo
{
    IUnknown *      m_pSink;
    IID             m_iid;
    DWORD           m_dwMask;
    IUnknown *      m_pCanonicalUnk; // IUnknown used for identity comparisons
    


    void Validate()
    {
#ifdef DEBUG
        if( m_pSink )
        {           
            Assert( m_pCanonicalUnk != NULL );
            // Check that mask contains only valid bits
            Assert( ( m_dwMask & ~ TS_AS_ALL_SINKS ) == 0 );
        }        
        else        
        {            
            Assert( m_pCanonicalUnk == NULL );
            Assert( m_dwMask == 0 );       
        }
#endif    
    }



    SinkInfo()
        : m_pSink( NULL ),
          m_pCanonicalUnk( NULL ),
          m_dwMask( 0 )
    {
        Validate();
        // Done.
    }

    ~SinkInfo()
    {
        Validate();
        AssertMsg( m_pSink == NULL && m_pCanonicalUnk == NULL, TEXT("Sink not cleared" ) );
    }

    void Set( IUnknown * pSink, REFIID iid, DWORD dwMask, IUnknown * pCanonicalUnk )
    {
        Validate();

        AssertMsg( m_pSink == NULL, TEXT("Set() sink that's already in use" ) );

        m_pSink = pSink;
        m_pSink->AddRef();
        m_iid = iid;
        m_dwMask = dwMask;
        m_pCanonicalUnk = pCanonicalUnk;
        m_pCanonicalUnk->AddRef();

        Validate();
    }

    void UpdateMask( DWORD dwMask )
    {
        Validate();

        AssertMsg( m_pSink != NULL, TEXT("UpdateMask() on empty sink") );

        m_dwMask = dwMask;

        Validate();
    }

    void ClearAndRelease()
    {
        Validate();

        if( m_pSink )
        {
            m_pSink->Release();
            m_pSink = NULL;
            m_pCanonicalUnk->Release();
            m_pCanonicalUnk = NULL;
            m_dwMask = 0;
        }
    }
};






// Fwd. decl for the sink-wrap class, needed since we grant it frienship in the 
// DocWrap class...
template< class DocTraits >
class CSinkWrapBase;



//
//  CDocWrapBase
//
//  - Base from which Anchor and ACP document wrappers are derived.
//
//  This class contains ACP/Anchor-neutral wrapping code - anything that is
//  ACP/Anchor-specific is handled in the derived ..ACP or ...Anchor class
//  instead.
//
//  This class derives from the full Cicero doc interface (DocTraits::ICicDoc -
//  which is a typedef for ITfTextStore[Anchor]), which in turn includes the
//  ITextStoreACP doc interface. Currently the Cicero interface doesn't add any
//  additional methods.
//
//  This class is also on a list of document wrappers - so we're derived from
//  Link_dl. (The list is managed by the wrapper manager.) The list will be a
//  list of derived classes, so the type of the link is of the derived class
//  (DocTraits::CDocWrap - which is a typedef for CDocWrapACP/Anchor), instead
//  of being based on this class.
//  (At the moment we don't actually use any of the derived-class functionality,
//  but may do so in future.)

// {B5DCFDAF-FBAD-4ef6-A5F8-E7CC0833A3B1}
static const GUID DOCWRAP_IMPLID = { 0xb5dcfdaf, 0xfbad, 0x4ef6, { 0xa5, 0xf8, 0xe7, 0xcc, 0x8, 0x33, 0xa3, 0xb1 } };

template< class _DocTraits >
class ATL_NO_VTABLE CDocWrapBase :
	public CComObjectRootEx< CComSingleThreadModel >,
    public Link_dl< _DocTraits::CDocWrap >,
    public _DocTraits::ICicDoc,

    public _DocTraits::IDocEx,

    public IClonableWrapper,
    public IInternalDocWrap,
    public ICoCreateLocally,
    public CVersionInfo,
    public IServiceProvider
{
public:

    // This typedef makes the DocTraits type visible in this and in the
    // Anchor/ACP-specific derived classes. (Otherwise, as a template
    // parameter in this class, it would not be available to them.)
    typedef _DocTraits DocTraits;

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP( CDocWrapBase< DocTraits > )
    COM_INTERFACE_ENTRY( DocTraits::IDoc )
	COM_INTERFACE_ENTRY( DocTraits::ICicDoc )
    COM_INTERFACE_ENTRY( DocTraits::IDocEx )
    COM_INTERFACE_ENTRY( IClonableWrapper )
    COM_INTERFACE_ENTRY( IInternalDocWrap )
    COM_INTERFACE_ENTRY( ICoCreateLocally )
    COM_INTERFACE_ENTRY( IVersionInfo )
    COM_INTERFACE_ENTRY( IServiceProvider )
END_COM_MAP()



private:

    // WrapMgr uses the Link_dl base when adding this to its list.
    friend CWrapMgr< DocTraits >;

    // Used by WrapMgr to track what type of lock was requested. 
    DWORD                   m_dwPendingLock;

    // Used by WrapMgr to track what type of lock granted. 
    DWORD                   m_dwGrantedLock;

    // SinkWrapBase - and its derived Anchor/ACP-specific class - uses the list
    // and the members of SinkInfo when broadcasting
    friend CSinkWrapBase< DocTraits >;
    friend DocTraits::CSinkWrap;


protected:

    // Each doc can have a corresponding sink:
    SinkInfo                m_Sink;

    // Link back to the wrapper manager - so we can tell it when we're going
    // away. We also get it to handle calls which affect other wrappers on the
    // same document - especially sinks and locks.
    CWrapMgr< DocTraits > * m_pMgr;

    // Used by derived classes to forward calls to doc...
//    DocTraits::IDoc *       m_pDoc;
    DocTraits::IDocSEHWrap  m_pDoc;

    // TEMP  BUGBUG - used to access the attribute extentions for the moment...
    DocTraits::IDocEx *     m_pDocEx;

    bool m_bUnadvised;



    HRESULT STDMETHODCALLTYPE VerifyLock( DWORD dwLockFlags)
    {
        IMETHOD( VerifyLock );

        if ( m_dwGrantedLock )
        {
            // We have a lock, make sure it's the right kind
            if ( (dwLockFlags & TS_LF_READWRITE) == m_dwGrantedLock || (dwLockFlags & TS_LF_READWRITE) == TS_LF_READ )
                return S_OK;
        }

        TraceDebug( TEXT("Lock rejected") );

        return S_FALSE;
    }
    
    // This macro just forwards the call directly to the doc...
#define DocWrap_FORWARD( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        IMETHOD( fname );\
        return m_pDoc-> fname AS_CALL( c, params ) ;\
    }

    // This macro just forwards the call directly to the doc after checking for the correct lock
#define DocWrap_FORWARD_READLOCK( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        IMETHOD( fname );\
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )\
            return TS_E_NOLOCK;\
        return m_pDoc-> fname AS_CALL( c, params ) ;\
    }


#define DocWrap_FORWARDEXT( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        IMETHOD( fname );\
        if( ! m_pDocEx )\
            return E_NOTIMPL;\
        return m_pDocEx-> fname AS_CALL( c, params ) ;\
    }


    // This slightly more complicated one (!) forwards to the doc,
    // and if the call succeeds, then broadcasts to all sinks except the one
    // for this document.
    // So if one client does a SetText, that SetText goes through, and
    // all other clietns with callbacks for the TS_AS_TEXT_CHANGE event will
    // also get an OnTextChange event.
#define DocWrap_FORWARD_AND_SINK( fname, c, params, mask, callsink )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params )\
    {\
        IMETHOD( fname );\
        Assert( m_pMgr );\
        if ( VerifyLock( TS_LF_READWRITE ) == S_FALSE )\
            return TS_E_NOLOCK;\
        m_pMgr->RemoveDeadDocs();\
        CPrivateAddRef MyAddRef(m_pMgr->m_lIterationRefCount);\
        HRESULT hr = m_pDoc-> fname AS_CALL( c, params );\
        if( hr != S_OK )\
        {\
			TraceDebugHR( hr, TEXT("failed") );\
            return hr;\
        }\
        for( Iter_dl < DocTraits::CDocWrap > i ( m_pMgr->m_DocWraps ) ; ! i.AtEnd() ; i++ )\
        {\
            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * >( i->m_Sink.m_pSink );\
            DWORD dwMask = i->m_Sink.m_dwMask;\
            DocTraits::CDocWrap * pTheDoc = i;\
            if( pTheDoc != this && pSink && ( dwMask & mask ) )\
            {\
                callsink ;\
            }\
        }\
        return S_OK ;\
    }

public:


    //
    // Ctor, Dtor, and initialization...
    //

    CDocWrapBase()
        : m_pDoc( NULL ),
          m_pMgr( NULL ),
          m_dwPendingLock( 0 ),
          m_dwGrantedLock( 0 ),
          m_pDocEx( NULL ),
          m_bUnadvised( false )
    {

    }

    ~CDocWrapBase()
    {
        AssertMsg( m_pMgr != NULL, TEXT("CDocWrapBase::Init never got called?") );

        // Clear up sink...
        if( m_Sink.m_pSink )
        {
            m_Sink.ClearAndRelease();

            // Manager will unadvise, if we were the last to go...
            m_pMgr->DocWrap_UpdateSubscription();
        }

        m_pMgr->DocWrap_NotifyDisconnect( static_cast< DocTraits::CDocWrap * >( this ) );
        m_pMgr->Release();

        if( m_pDocEx )
            m_pDocEx->Release();
    }

    void Init( CWrapMgr< DocTraits > *  pMgr, DocTraits::IDoc * pDoc )
    {
        AssertMsg( m_pMgr == NULL, TEXT("CDocWrapBase::Init should only be called once when m_pMgr is NULL") );
        m_pMgr = pMgr;
        m_pMgr->AddRef();

        m_pDoc = pDoc;
        AddRef();			// Keep our own ref count so it dosn't go away until we remove from the list
        
        CVersionInfo::Add( DOCWRAP_IMPLID, 1, 0, L"Microsoft MSAA Wrapper 1.0", L"na", NULL);
        
        m_pDoc->QueryInterface( __uuidof( DocTraits::IDocEx ), (void **) & m_pDocEx );
    }


    //
    // Implementation of ACP/Anchor-neutral methods...
    // These ones require special handling...
    //

    HRESULT STDMETHODCALLTYPE AdviseSink( REFIID riid, IUnknown *punk, DWORD dwMask )
    {
        IMETHOD( AdviseSink );

        Assert( m_pMgr );

        if( punk == NULL )
        {
            return E_INVALIDARG;
        }

        // Accept the following sinks:
        // * Original ITextStoreACPSink,
        // * Cicero sink (ITextStoreACP + Cicero extentions)
        // * ITextStoreACPSinkEx sink (ITextStoreACP + OnDisconnect method)
        if( riid != __uuidof( DocTraits::ISink )
         && riid != __uuidof( DocTraits::ICicSink )
         && riid != __uuidof( DocTraits::ISinkEx ) )
        {
            return E_NOINTERFACE;
        }

        // check mask contains only valid bits
        if( dwMask & ~ ( TS_AS_ALL_SINKS ) )
        {
            return E_INVALIDARG;
        }
        
        // Get canonical unknown (for interface comparing...)
        IUnknown * pCanonicalUnk = NULL;
        HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
        if( hr != S_OK || pCanonicalUnk == NULL )
        {
            return E_FAIL;
        }

        // If this is first, set it...
        if( m_Sink.m_pSink == NULL )
        {
            // Allow the doc to work out the update cumulative mask and re-advise the doc if necessary...
            m_Sink.Set( punk, riid, dwMask, pCanonicalUnk );

            // Manager will scan through all sink masks, and re-Advise if necessary.
            hr = m_pMgr->DocWrap_UpdateSubscription();

            if( hr != S_OK )
            {
                // advising didn't work, or something else went wrong - revert back to empty sink...
                m_Sink.ClearAndRelease();
            }
        }
        else
        {
            // Not the first time - check if we're updating the existing mask...
            if( pCanonicalUnk != m_Sink.m_pCanonicalUnk )
            {
                // Attempt to register a different sink - error...
                hr = CONNECT_E_ADVISELIMIT;
            }
            else
            {
                // Remember the old mask - if the update doesn't work, revert back to this.
                DWORD OldMask = m_Sink.m_dwMask;
                m_Sink.UpdateMask( dwMask );

                // Manager will scan through all dwMasks, and re-Advise if necessary.
                hr = m_pMgr->DocWrap_UpdateSubscription();

                if( hr != S_OK )
                    m_Sink.UpdateMask( OldMask );
            }
        }

        pCanonicalUnk->Release();
        return hr;
    }



    HRESULT STDMETHODCALLTYPE UnadviseSink( IUnknown *punk )
    {
        IMETHOD( UnadviseSink );

        Assert( m_pMgr );

        if( punk == NULL )
        {
            return E_POINTER;
        }

        // Get canonical unknown (for interface comparing...)
        IUnknown * pCanonicalUnk = NULL;
        HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );

        if( hr != S_OK || pCanonicalUnk == NULL )
        {
            return E_FAIL;
        }
    
        if( pCanonicalUnk != m_Sink.m_pCanonicalUnk )
        {
            // Sink doesn't match!
            return E_INVALIDARG;
        }

        m_Sink.ClearAndRelease();

        // Manager will scan through all dwMasks, and re-Advise if necessary.
        hr = m_pMgr->DocWrap_UpdateSubscription();

        // Not much we can do if the update fails - but even if it does fail,
        // we want to disconnect this sink, and not fail the Unadvise.
        Assert( hr == S_OK );

        pCanonicalUnk->Release();

        m_bUnadvised = true;

		return S_OK;  // NOT hr, since this should always succeed.
    }




    HRESULT STDMETHODCALLTYPE RequestLock( DWORD dwLockFlags, HRESULT * phrSession )
    {
        IMETHOD( RequestLock );

        Assert( m_pMgr );
        // The cast here is safe, since we'll only be used as a derived class
        DocTraits::CDocWrap * pThisAsDerived = static_cast< DocTraits::CDocWrap * >( this );

        return m_pMgr->DocWrap_HandleRequestLock( pThisAsDerived, dwLockFlags, phrSession );
    }


    //
    // These Anchor/ACP-neutral methods can just be forwarded directly to the real doc...
    //

    DocWrap_FORWARD( GetStatus,                 1,  ( TS_STATUS *,               pdcs ) )

    DocWrap_FORWARD_READLOCK( QueryInsert,   	5,  ( DocTraits::PosType,       InsertStart,
    												  DocTraits::PosType,       InsertEnd,
    												  ULONG,					cch,
                                                      DocTraits::PosType *,     ppaInsertStart,
                                                      DocTraits::PosType *,     ppaInsertEnd ) )

    DocWrap_FORWARD_READLOCK( QueryInsertEmbedded,		3,	( const GUID *,				pguidService,
													  const FORMATETC *,		pFormatEtc,
													  BOOL *,					pfInsertable ) )
       
    DocWrap_FORWARD( GetScreenExt,              2,  ( TsViewCookie,				vcView,
    												  RECT *,                   prc ) )

    DocWrap_FORWARD( GetWnd,                    2,  ( TsViewCookie,				vcView,
													  HWND *,                   phwnd ) )

    DocWrap_FORWARD_READLOCK( GetFormattedText, 3,  ( DocTraits::PosType,       Start,
                                                      DocTraits::PosType,       End,
                                                      IDataObject **,           ppDataObject ) )

    DocWrap_FORWARD_READLOCK( GetTextExt,                5,  ( TsViewCookie,				vcView,
													  DocTraits::PosType,       Start,
                                                      DocTraits::PosType,       End,
                                                      RECT *,                   prc,
                                                      BOOL *,                   pfClipped ) )

    DocWrap_FORWARDEXT( ScrollToRect,           4,  ( DocTraits::PosType,       Start,
                                                      DocTraits::PosType,       End,
                                                      RECT,                     rc,
                                                      DWORD,                    dwPosition ) )

    DocWrap_FORWARD( GetActiveView,				1,  ( TsViewCookie *,			pvcView ) )
    
    // IClonableWrapper

	HRESULT STDMETHODCALLTYPE CloneNewWrapper( REFIID	riid, void ** ppv )
    {
        IMETHOD( CloneNewWrapper );

        // Just call through to CWrapMgr's CreateWrappedDoc...

        Assert( m_pMgr );

        IUnknown * punk;
        HRESULT hr = m_pMgr->CreateWrappedDoc( & punk );
        if( hr != S_OK )
            return hr;

        hr = punk->QueryInterface( riid, ppv );
        punk->Release();
        return hr;
    }

    // IInternalDocWrap

	HRESULT STDMETHODCALLTYPE NotifyRevoke()
    {
        // Just pass on to the CWrapMgr...
        Assert( m_pMgr );

        m_pMgr->DocWrap_NotifyRevoke();

        return S_OK;
    }
    
    // ICoCreateLocally
	#include <Rpcdce.h>
	HRESULT STDMETHODCALLTYPE CoCreateLocally (
		REFCLSID		rclsid,
		DWORD			dwClsContext,
		REFIID			riid,
		IUnknown **		punk,
		REFIID			riidParam,
		IUnknown *		punkParam,
		VARIANT			varParam
	)
	{ 
	    IMETHOD( CoCreateLocally );

		LPCTSTR pPrivs = NULL;				//Pointer to handle to privilege information

		HRESULT hrSec = CoQueryClientBlanket( 0, 0, 0, 0, 0, (void **)&pPrivs, 0 );
		if ( hrSec != S_OK )
			return hrSec;

		TSTR strUser(128);
		DWORD nSize = strUser.left();
		if ( !GetUserName( strUser.ptr(), &nSize ) )
		    return E_ACCESSDENIED;
		    
		strUser.advance( nSize - 1 );
		
		TSTR strClientUser( pPrivs );
		const int nSlashPos = strClientUser.find( TEXT("\\") );
		if ( nSlashPos > 0 )
			strClientUser = strClientUser.substr( nSlashPos + 1, strClientUser.size() - nSlashPos );

		TraceDebug( TSTR() << TEXT("Current user = ") << strUser << TEXT(", Client user = ") << strClientUser );
		if ( strClientUser.compare( strUser ) != 0 )
			if ( strClientUser.compare( TEXT("SYSTEM") ) != 0 )
				return E_ACCESSDENIED;

		HRESULT hr = CoCreateInstance(rclsid, NULL, dwClsContext, riid, (void **)punk);
 		if (hr != S_OK)
 			return hr;

		CComPtr<ICoCreatedLocally> pICoCreatedLocally;
		hr = (*punk)->QueryInterface(IID_ICoCreatedLocally, (void **)&pICoCreatedLocally);
 		if (hr != S_OK)
 			return hr;

		hr = pICoCreatedLocally->LocalInit(m_pDoc, riidParam, punkParam, varParam);
 		if (hr != S_OK)
 			return hr;

	    return S_OK;
	}

    //
    // IServiceProvider - Cicero uses this to 'drill through' to the original anchor to pull out
    // internal information. Just pass it through...
    //
    HRESULT STDMETHODCALLTYPE QueryService( REFGUID guidService, REFIID riid, void **ppvObject )
    {
        IMETHOD( QueryService );

        *ppvObject = NULL;

        CComPtr<IServiceProvider> pISP;
        HRESULT hr = m_pDoc->QueryInterface( IID_IServiceProvider, (void **) & pISP );
        if( hr != S_OK || pISP == NULL )
            return E_FAIL;

        hr = pISP->QueryService( guidService, riid, ppvObject );

        return hr;
    }
};


//
// CTextStoreWrapACP - ACP version of ITextStoreACP wrapper...
//

class ATL_NO_VTABLE CDocWrapACP : 
    public CDocWrapBase< DocTraitsACP >
{
public:

    // ITextStoreACP
    DocWrap_FORWARD_READLOCK( GetSelection,              4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ACP *, pSelection, ULONG *, pcFetched ) )
    DocWrap_FORWARD_READLOCK( GetText,                   9,  ( LONG, acpStart, 
													  LONG, acpEnd,
													  WCHAR *, pchPlain, 
													  ULONG, cchPlainReq, 
													  ULONG *, pcchPlainRet, 
													  TS_RUNINFO *, prgRunInfo, 
													  ULONG, cRunInfoReq, 
													  ULONG *, pcRunInfoRet, 
													  LONG *, pacpNext ) )
    DocWrap_FORWARD_READLOCK( GetEmbedded,       4,  ( LONG, Pos, REFGUID, rguidService, REFIID, riid, IUnknown **, ppunk ) )
    DocWrap_FORWARD_READLOCK( GetEndACP,         1,  ( LONG *, pacp ) )
    DocWrap_FORWARD_READLOCK( GetACPFromPoint,    4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, LONG *, pacp ) )
    DocWrap_FORWARD( RequestSupportedAttrs, 3,  ( DWORD,                    dwFlags,
    												  ULONG, 					cFilterAttrs,
													  const TS_ATTRID *,		paFilterAttrs ) )
    DocWrap_FORWARD_READLOCK( RequestAttrsAtPosition, 4,  ( DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,        paFilterAttrs,
                                                      DWORD,                    dwFlags ) )
    DocWrap_FORWARD_READLOCK( RequestAttrsTransitioningAtPosition,
                                                4,  ( DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,        paFilterAttrs,
                                                      DWORD,                    dwFlags ) )
    DocWrap_FORWARD_READLOCK( FindNextAttrTransition,    8,  ( LONG, acpStart, LONG, acpEnd, ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, LONG *, pacpNext, BOOL *, pfFound, LONG *, plFoundOffset ) )
    DocWrap_FORWARD( RetrieveRequestedAttrs,    3,  ( ULONG,                    ulCount,
                                                      TS_ATTRVAL *,             paAttrVals,
                                                      ULONG *,                  pcFetched ) )
    DocWrap_FORWARD_AND_SINK( SetSelection,     2,  ( ULONG, ulCount, const TS_SELECTION_ACP *, pSelection ),
                              TS_AS_SEL_CHANGE,   pSink->OnSelectionChange() )

    DocWrap_FORWARD_AND_SINK( SetText,          6,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, const WCHAR *, pchText, ULONG, cch, TS_TEXTCHANGE *, pChange ),
                             TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )

    DocWrap_FORWARD_AND_SINK( InsertEmbedded,   5,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, IDataObject *, pDataObject, TS_TEXTCHANGE *, pChange ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )

    DocWrap_FORWARD_AND_SINK( InsertTextAtSelection, 6, ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )

    DocWrap_FORWARD_AND_SINK( InsertEmbeddedAtSelection, 5, ( DWORD, dwFlags, IDataObject *, pDataObject, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )


};

//
// CTextStoreWrapAnchor - Anchor version of ITextStoreACP wrapper
//

class ATL_NO_VTABLE CDocWrapAnchor : 
    public CDocWrapBase< DocTraitsAnchor >
{
/*
    // Used when generating OnTextChange events in response to InsertEmbedded.
    // See forwarding macro for InsertEmbedded below...
    void ProcessInsertEmbeddedOnTextChange( DocTraits::ISink * pSink, DWORD dwFlags, IAnchor * paPos )
    {
        // Want to send a TextChange with anchors before and after the insert position -
        // we have the before position - clone and move it to get the after position.
        IAnchor * pAnchorAfter = NULL;
        HRESULT hr = paPos->Clone( & pAnchorAfter );
        if( hr != S_OK || pAnchorAfter == NULL )
        {
            TraceInteropHR( hr, TEXT("IAnchor::Clone failed") );
            return;
        }

        LONG cchShifted = 0;
        hr = pAnchorAfter->Shift( 1, & cchShifted, NULL );
        if( hr != S_OK || cchShifted != 1 )
        {
            TraceInteropHR( hr, TEXT("IAnchor::Shift failed?") );
            return;
        }

        pSink->OnTextChange( dwFlags, paPos, pAnchorAfter );

        pAnchorAfter->Release();
    }
*/

public:

	CDocWrapAnchor() : m_cMaxAttrs(0), 
					   m_cAttrsTAP(0), 
					   m_iAttrsTAP(0), 
					   m_cAttrsTAPSize(0), 
					   m_paAttrsTAP(NULL),
					   m_paAttrsSupported(NULL)

	{

	}

	~CDocWrapAnchor()
	{
		ResetAttrs();
		if ( m_paAttrsTAP )
		{
			delete [] m_paAttrsTAP;
			m_paAttrsTAP = NULL;
		}
		if ( m_paAttrsSupported )
		{
			delete [] m_paAttrsSupported;
			m_paAttrsSupported = NULL;
		}
	}

    // ITextStoreAnchor
    DocWrap_FORWARD_READLOCK( GetSelection,              4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ANCHOR *, pSelection, ULONG *, pcFetched ) )
    DocWrap_FORWARD_READLOCK( GetText,                   7,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, WCHAR *, pchText, ULONG, cchReq, ULONG *, pcch, BOOL, fUpdateAnchor ) )
    DocWrap_FORWARD_READLOCK( GetEmbedded,               5,  ( DWORD,					dwFlags,
													  IAnchor *,				Pos,
                                                      REFGUID,                  rguidService,
                                                      REFIID,                   riid,
                                                      IUnknown **,              ppunk ) )
    DocWrap_FORWARD_READLOCK( GetStart,                  1,  ( IAnchor **, ppaStart ) )
    DocWrap_FORWARD_READLOCK( GetEnd,                    1,  ( IAnchor **, ppaEnd ) )
    DocWrap_FORWARD_READLOCK( GetAnchorFromPoint,        4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, IAnchor **, ppaSite ) )
//	DocWrap_FORWARD( RequestSupportedAttrs,     3,  ( DWORD,                    dwFlags,
//													  ULONG, 					cFilterAttrs,
//													  const TS_ATTRID *,		paFilterAttrs ) )
//	DocWrap_FORWARD_READLOCK( RequestAttrsAtPosition,    4,  ( DocTraits::PosType,       Pos,
//													  ULONG,                    cFilterAttrs,
//													  const TS_ATTRID *,        paFilterAttrs,
//													  DWORD,                    dwFlags ) )
//	DocWrap_FORWARD_READLOCK( RequestAttrsTransitioningAtPosition,
//												4,  ( DocTraits::PosType,       Pos,
//													  ULONG,                    cFilterAttrs,
//													  const TS_ATTRID *,         paFilterAttrs,
//													  DWORD,                    dwFlags ) )
//	DocWrap_FORWARD_READLOCK( FindNextAttrTransition,    7,  ( IAnchor *, paStart, IAnchor *, paEnd,  ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, BOOL *, pfFound, LONG *, plFoundOffset ) )


    DocWrap_FORWARD_AND_SINK( SetSelection,     2,  ( ULONG, ulCount, const TS_SELECTION_ANCHOR *, pSelection ),
                              TS_AS_SEL_CHANGE,   pSink->OnSelectionChange() )

    DocWrap_FORWARD_AND_SINK( SetText,          5,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, const WCHAR *, pchText, ULONG, cch ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, paStart, paEnd ) )

    DocWrap_FORWARD_AND_SINK( InsertEmbedded,   4,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, IDataObject *, pDataObject ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, paStart, paEnd ) )

    DocWrap_FORWARD_AND_SINK( InsertTextAtSelection, 5, ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch,  IAnchor **, ppaStart, IAnchor **, ppaEnd ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, *ppaStart, *ppaEnd ) )

    DocWrap_FORWARD_AND_SINK( InsertEmbeddedAtSelection, 4, ( DWORD, dwFlags, IDataObject *, pDataObject,  IAnchor **, ppaStart, IAnchor **, ppaEnd ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, *ppaStart, *ppaEnd ) )

    HRESULT STDMETHODCALLTYPE RequestSupportedAttrs ( DWORD				dwFlags,
													  ULONG 			cFilterAttrs,
													  const TS_ATTRID *	paFilterAttrs )
    {
        IMETHOD( RequestSupportedAttrs );
       	ResetAttrs();
        return m_pDoc->RequestSupportedAttrs( dwFlags, cFilterAttrs, paFilterAttrs ) ;
    }
    
    HRESULT STDMETHODCALLTYPE RequestAttrsAtPosition ( DocTraits::PosType	Pos,
													   ULONG				cFilterAttrs,
													   const TS_ATTRID *	paFilterAttrs,
													   DWORD				dwFlags ) 
    {
        IMETHOD( RequestAttrsAtPosition );
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )
            return TS_E_NOLOCK;
       	ResetAttrs();
        return m_pDoc->RequestAttrsAtPosition( Pos, cFilterAttrs, paFilterAttrs, dwFlags ) ;
    }

	HRESULT STDMETHODCALLTYPE RequestAttrsTransitioningAtPosition ( IAnchor * paStart,
																	ULONG cFilterAttrs,
																	const TS_ATTRID * paFilterAttrs,
																	DWORD dwFlags )
	{
        IMETHOD( RequestAttrsTransitioningAtPosition );
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )
            return TS_E_NOLOCK;
       	ResetAttrs();

		// call through to the doc
        HRESULT hr  = m_pDoc->RequestAttrsTransitioningAtPosition( paStart, cFilterAttrs, paFilterAttrs, dwFlags );
        if ( hr != E_NOTIMPL )
        	return hr;
        	
        // if the server does not support this do it ourselves
		// make sure there is really something to do
        if ( paStart == NULL )
        	return S_OK;
		
		// make sure we can hold the attributes we find
        hr = AllocateAttrs( cFilterAttrs );
        if ( FAILED(hr) )
        	return hr;

		ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;

		TS_ATTRVAL * paCurrent = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
		if ( !paCurrent )
			return E_OUTOFMEMORY;

		hr = GetAttr ( paStart, cFilterAttrs, paFilterAttrs, dwFlags, paCurrent);
        if ( FAILED(hr) )
        	return hr;

		LONG cchShifted;
		ULONG iAttrs = 0;
		TS_ATTRVAL * paComp = NULL;
		CComPtr <IAnchor> paPos;
		paStart->Clone( &paPos );
		hr = paPos->Shift( 0, -1, &cchShifted, NULL );	// TODO fix hidden text
		if ( SUCCEEDED(hr) && cchShifted == -1 )
		{
			paComp = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
			if ( !paComp )
				return E_OUTOFMEMORY;
			hr = GetAttr ( paPos, cFilterAttrs, paFilterAttrs, dwFlags, paComp);
	        if ( FAILED(hr) )
	        	return hr;
    		if ( dwFlags & TS_ATTR_FIND_WANT_END )
				CompareAttrs ( paCurrent, paComp, cAlloAttrs, iAttrs, TRUE );
            else
				CompareAttrs ( paComp, paCurrent, cAlloAttrs, iAttrs, TRUE );
	    }

		if ( !( dwFlags & TS_ATTR_FIND_WANT_VALUE ) )
		{
			for ( int i= 0; i < cFilterAttrs; i++ )
			{
				VariantClear( &m_paAttrsTAP[i].varValue );
			}
		}

		m_cAttrsTAP = iAttrs;
		
		return S_OK;
	}

	
	HRESULT STDMETHODCALLTYPE FindNextAttrTransition ( IAnchor * paStart, 
													   IAnchor * paEnd, 
													   ULONG cFilterAttrs, 
													   const TS_ATTRID * paFilterAttrs, 
													   DWORD dwFlags, 
													   BOOL * pfFound, 
													   LONG * plFoundOffset )
	{
        IMETHOD( FindNextAttrTransition );
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )
            return TS_E_NOLOCK;
        
        HRESULT hr  = m_pDoc->FindNextAttrTransition( paStart, paEnd, cFilterAttrs, paFilterAttrs, dwFlags, pfFound, plFoundOffset );
        if ( hr != E_NOTIMPL )
        	return hr;

		*pfFound = FALSE;
		*plFoundOffset = 0;
		
        // if the server does not support this do it ourselves
		// make sure there is really something to do
        if ( paStart == NULL )
        	return S_OK;

		// make sure we can hold the attributes we find
        hr = AllocateAttrs( cFilterAttrs );
        if ( FAILED(hr) )
		{
			TraceDebugHR( hr, TEXT("AllocateAttrs failed ") );
        	return hr;
		}
        ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;
 
		TS_ATTRVAL * paCurrent = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
		TS_ATTRVAL * paNext = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
		if ( !paCurrent || !paNext )
			return E_OUTOFMEMORY;

		hr = GetAttr ( paStart, cFilterAttrs, paFilterAttrs, dwFlags, paCurrent);
        if ( FAILED(hr) )
		{
			TraceDebugHR( hr, TEXT("Current GetAttr failed ") );
		    return hr;
		}

		LONG cchShifted;
		ULONG iAttrs = 0;
		BOOL fDone = TRUE;
		const LONG cchShift = ( dwFlags & TS_ATTR_FIND_BACKWARDS ) ? -1 : 1;
				
		CComPtr <IAnchor> paPos, paEndOfDoc;
		hr = paStart->Clone( &paPos );
		if ( FAILED(hr) )
		{
			TraceDebugHR( hr, TEXT("Clone failed ") );
        	return hr;
		}
		if ( paEnd == NULL )
		{
			if ( dwFlags & TS_ATTR_FIND_BACKWARDS )
			{
				m_pDoc->GetStart( &paEndOfDoc );
			}
			else
			{
			    BOOL fRegion = FALSE;
        		hr = paStart->Clone( &paEndOfDoc );
        		while ( fRegion )
        		{
				    paEndOfDoc->Shift( 0, LONG_MAX, &cchShifted, NULL );
				    paEndOfDoc->ShiftRegion( 0, TS_SD_FORWARD, &fRegion );
        		}
			}
		}
		
		while ( iAttrs == 0 )
		{
			hr = paPos->Shift( 0, cchShift, &cchShifted, NULL );	// TODO fix hidden text
			if ( SUCCEEDED(hr) && cchShifted == cchShift )
			{			
				*plFoundOffset += 1;
				hr = paPos->IsEqual( paEnd ? paEnd : paEndOfDoc, &fDone );
		        if ( FAILED(hr) )
				{
					TraceDebugHR( hr, TEXT("IsEqual failed ") );
		        	return hr;
				}
				if ( fDone )
					break;
					
				hr = GetAttr ( paPos, cFilterAttrs, paFilterAttrs, dwFlags, paNext);
		        if ( FAILED(hr) )
				{
					TraceDebugHR( hr, TEXT("Next GetAttr failed ") );
		        	return hr;
				}
		        CompareAttrs ( paCurrent, paNext, cFilterAttrs, iAttrs, FALSE );
				if ( iAttrs )
				{
					*pfFound = TRUE;
				}
	        }
	        else
	        {
				TraceDebugHR( hr, TEXT("Shift failed ") );
		       	return hr;
	        }
        }

		return S_OK;
	}
	
	HRESULT STDMETHODCALLTYPE RetrieveRequestedAttrs ( ULONG ulCount,
													   TS_ATTRVAL * paAttrVals,
													   ULONG * pcFetched )
	{
		// if there is no outstanding requests we satisfy then call through to the doc
		if ( m_cAttrsTAP == 0 )
			return m_pDoc->RetrieveRequestedAttrs( ulCount, paAttrVals, pcFetched );
	
		if ( ( m_cAttrsTAP - m_iAttrsTAP ) < ulCount )
			*pcFetched = m_cAttrsTAP - m_iAttrsTAP;
		else
			*pcFetched = ulCount;
			
		memcpy(paAttrVals, &m_paAttrsTAP[m_iAttrsTAP], *pcFetched * sizeof(TS_ATTRVAL));
		memset(&m_paAttrsTAP[m_iAttrsTAP], 0, *pcFetched * sizeof(TS_ATTRVAL));
		m_iAttrsTAP += *pcFetched;

		if ( m_iAttrsTAP == m_cAttrsTAP )
			ResetAttrs();
			
		return S_OK;
	}
	
private:
	ULONG m_cMaxAttrs;
	ULONG m_iAttrsTAP;
	ULONG m_cAttrsTAP;
	ULONG m_cAttrsTAPSize;
	TS_ATTRVAL * m_paAttrsTAP;
	TS_ATTRID * m_paAttrsSupported;

private:

	HRESULT STDMETHODCALLTYPE CompareAttrs ( TS_ATTRVAL * paAttr1, 
											 TS_ATTRVAL * paAttr2, 
											 ULONG cAttrs,
											 ULONG &iAttrs,
											 BOOL fCopy)
	{
	    cAttrs = cAttrs ? cAttrs : m_cMaxAttrs;
	    
		for ( int i = 0; i < cAttrs; i++ )
		{
			for ( int j = 0; j < cAttrs; j++ )
			{
				if ( paAttr1[i].idAttr == paAttr2[j].idAttr )
				{
					if ( CComVariant( paAttr1[i].varValue ) != CComVariant( paAttr2[j].varValue ) )
					{
						if ( fCopy )
						{
							char * cBuf = ( char * )&m_paAttrsTAP[iAttrs];
							memcpy( cBuf, ( char * )&paAttr2[j], sizeof(TS_ATTRVAL) );
						}
						iAttrs++;
					}
					break;
				}
			}
		}

		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE GetAttr ( IAnchor * paStart,
										ULONG cFilterAttrs,
										const TS_ATTRID * paFilterAttrs,
										DWORD dwFlags,
										TS_ATTRVAL * paAttrVals) 
	{
		ULONG cFetched;
        HRESULT hr;
	
		ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;
		const TS_ATTRID * paActualFilterAttrs = paFilterAttrs ? paFilterAttrs : m_paAttrsSupported;

        hr = m_pDoc->RequestAttrsAtPosition( paStart, cAlloAttrs, paActualFilterAttrs, 0 );
        if ( FAILED(hr) )
        	return hr;

        hr = m_pDoc->RetrieveRequestedAttrs( cAlloAttrs, paAttrVals, &cFetched );
        if ( FAILED(hr) )
        	return hr;

		return S_OK;

	}

	HRESULT STDMETHODCALLTYPE AllocateAttrs ( ULONG cFilterAttrs ) 
	{
		if ( cFilterAttrs == 0 && m_cMaxAttrs == 0 )
		{
			const LONG cAttrs = 512;
			
	        HRESULT hr = m_pDoc->RequestSupportedAttrs( 0, 0, NULL );
	        if ( FAILED(hr) )
	        	return hr;

			TS_ATTRVAL * paSupported = new TS_ATTRVAL[ cAttrs ];
			if ( !paSupported )
				return E_OUTOFMEMORY;
				
	        hr = m_pDoc->RetrieveRequestedAttrs( cAttrs, paSupported, &m_cMaxAttrs );
	        if ( SUCCEEDED(hr) )
	        {
    	        m_paAttrsSupported = new TS_ATTRID[ m_cMaxAttrs ];
                if ( m_paAttrsSupported )
                {
        	        for ( int i = 0; i < m_cMaxAttrs; i++ )
        	        {
                        m_paAttrsSupported[i] = paSupported[i].idAttr;
        	        }
                }
	        }
	        
			delete [] paSupported;

			if ( FAILED(hr) )
			    return hr;
			if ( !m_paAttrsSupported )
			    return E_OUTOFMEMORY;
		}

		ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;
		if ( m_cAttrsTAPSize < cAlloAttrs )
		{
			if ( m_paAttrsTAP )
				delete [] m_paAttrsTAP;

			m_paAttrsTAP =  new TS_ATTRVAL[ cAlloAttrs ];
			if ( !m_paAttrsTAP )
			{
				m_cAttrsTAPSize = 0;
				return E_OUTOFMEMORY;
			}	
			m_cAttrsTAPSize = cAlloAttrs;
		}
		
		return S_OK;
	}

	void ResetAttrs()
	{
		m_cAttrsTAP = 0;
		m_iAttrsTAP = 0;
	}
};






/* 12e53b1b-7d7f-40bd-8f88-4603ee40cf58 */
const IID IID_PRIV_CINPUTCONTEXT = { 0x12e53b1b, 0x7d7f, 0x40bd, {0x8f, 0x88, 0x46, 0x03, 0xee, 0x40, 0xcf, 0x58} };

/* aabf7f9a-4487-4b2e-8164-e54c5fe19204 */
const GUID GUID_SERVICE_CTF = { 0xaabf7f9a, 0x4487, 0x4b2e, {0x81, 0x64, 0xe5, 0x4c, 0x5f, 0xe1, 0x92, 0x04} };


//
//  CDocSinkWrapBase
//
//  - Base from which Anchor and ACP sink wrappers are derived.
//
//  This class contains ACP/Anchor-neutral wrapping code - anything that is
//  ACP/Anchor-specific is handled in the derived ..ACP or ...Anchor class
//  instead.
//
//  Since this class is the sink for the wrapper, it derives from the full Cicero
//  sink (DocTraits::ICicSink - which is a typedef for ITfTextStoreSink[Anchor]),
//  and that in turn includes the ITextStoreACP sink.
//

template < class _DocTraits >
class ATL_NO_VTABLE CSinkWrapBase :
	public CComObjectRootEx<CComSingleThreadModel>,
    public _DocTraits::ISink,
    public _DocTraits::ICicSink,
    public IServiceProvider
{
public:

    // This typedef makes the DocTraits type visible in this and in the
    // Anchor/ACP-specific derived classes. (Otherwise, as a template
    // parameter in this class, it would not be available to them.)
    typedef _DocTraits DocTraits;

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP( CSinkWrapBase<DocTraits> )
    COM_INTERFACE_ENTRY( DocTraits::ISink )
	COM_INTERFACE_ENTRY( DocTraits::ICicSink )
	COM_INTERFACE_ENTRY( IServiceProvider )
END_COM_MAP()

/*
    static HRESULT InternalQueryInterface( void* pThis, const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject )
    {
        // Hack for cicero - they expect to be able to QI for IID_PRIV_CINPUTCONTEXT and get
        // a ptr to one of ther internal class types (ick!)
        // This breaks COM identity, but hey, it's a private IID, and is only ever used
        // locally.
        // We can't do that sort of goo using the interface map (above), so have to hijack InternalQI instead.
        if( iid == IID_PRIV_CINPUTCONTEXT )
        {
            CSinkWrapBase<DocTraits> * pTHIS = (CSinkWrapBase<DocTraits> *)pThis;

            // Look for the cicero sink...
            // recognize it by the iid - it will have reg'd with a ITf (not TextStore) IID...
            for( Iter_dl< DocTraits::CDocWrap > i ( pTHIS->m_pMgr->m_DocWraps ) ; ! i.AtEnd(); i++ )
            {
                if( i->m_Sink.m_pSink && i->m_Sink.m_iid == __uuidof( DocTraits::ICicSink ) )
                {
                    return i->m_Sink.m_pSink->QueryInterface( iid, ppvObject );
                }
            }

            return E_NOINTERFACE;
        }

        return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface( pThis, pEntries, iid, ppvObject );
    }
*/
protected:

    // Protected stuff - used in this class, and by the ACP/Anchor-specific
    // derived classes.

    // Link back to the wrap manager. Used to tell it when we are going
    // away...
    CWrapMgr< DocTraits > *   m_pMgr;

    // Ptr to the manager's list of docs (which contain sinks)...
    List_dl< DocTraits::CDocWrap > *  m_pDocs;


    // This macro forwards a call by iterating all the sinks in the manager,
    // and forwarding if their mask has the right bit set.
    // Note - this CANNOT be used for OnLockGranted.
#define CSinkWrap_FORWARD( mask, fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params )\
    {\
        IMETHOD( fname );\
        Assert( m_pMgr && m_pDocs );\
        m_pMgr->RemoveDeadDocs();\
        CPrivateAddRef MyAddRef(m_pMgr->m_lIterationRefCount);\
        for( Iter_dl < DocTraits::CDocWrap > i ( *m_pDocs ) ; ! i.AtEnd() ; i++ )\
        {\
            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * >( i->m_Sink.m_pSink );\
            DWORD dwMask = i->m_Sink.m_dwMask;\
            if( pSink && ( mask == 0 || ( dwMask & mask ) ) )\
            {\
                pSink-> fname AS_CALL( c, params );\
            }\
        }\
        return S_OK ;\
    }




    // This macro forwards Cicero's TextStoreSink calls - they're not really sinks since
    // the return values are significant - true broadcast is not supported; only the
    // first sink in the manager which supports the interface is used - and its
    // return value gets returned.

#define CSinkWrap_FORWARD_CICERO( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params )\
    {\
        IMETHOD( fname );\
        Assert( m_pMgr && m_pDocs );\
        for( Iter_dl < DocTraits::CDocWrap > i ( *m_pDocs ) ; ! i.AtEnd() ; i++ )\
        {\
        	if ( i->m_Sink.m_pSink )\
			{\
				CComPtr< DocTraits::ICicSink > pTheSink;\
        		HRESULT hr = i->m_Sink.m_pSink->QueryInterface( __uuidof(DocTraits::ICicSink), (void **)&pTheSink );\
				if( hr == S_OK )\
				{\
					return pTheSink-> fname AS_CALL( c, params );\
				}\
			}\
        }\
        return E_FAIL ;\
    }


public:

    //
    // Ctor, Dtor and initialization...
    //

    CSinkWrapBase()
        : m_pMgr( NULL ),
          m_pDocs( NULL )
    {
        
    }

    ~CSinkWrapBase()
    {
        AssertMsg( m_pMgr != NULL && m_pDocs != NULL, TEXT("CSinkWrapBase::Init never got called?") );
        m_pMgr->SinkWrap_NotifyDisconnect();
        m_pMgr->Release();
    }

    void Init( CWrapMgr< DocTraits > * pMgr, List_dl< DocTraits::CDocWrap > * pDocs )
    {
        AssertMsg( m_pMgr == NULL && m_pDocs == NULL, TEXT("CSinkWrapBase::Init should only be called once when m_pMgr is NULL") );
        m_pMgr = pMgr;
        m_pMgr->AddRef();

        m_pDocs = pDocs;
    }

    //
    // IServiceProvider - Cicero uses this to 'drill through' to the original anchor to pull out
    // internal information. Just pass it through...
    //
    HRESULT STDMETHODCALLTYPE QueryService( REFGUID guidService, REFIID riid, void **ppvObject )
    {
        IMETHOD( QueryService );

        // Find the cicero sink...

        DocTraits::ICicSink * pTheSink = NULL;

        // Look for the cicero sink...
        // The cicero sink supports the Services interfaces and other don't
		for( Iter_dl< DocTraits::CDocWrap > i ( m_pMgr->m_DocWraps ) ; ! i.AtEnd(); i++ )
        {
        	if ( i->m_Sink.m_pSink )
            {
                if( i->m_Sink.m_pSink->QueryInterface( __uuidof(DocTraits::ICicSink), (void **)&pTheSink ) == S_OK )
                {
				    break;
                }
            } 
        }

        if( pTheSink == NULL )
            return E_FAIL;

        CComPtr<IServiceProvider> pISP;
        HRESULT hr = pTheSink->QueryInterface( IID_IServiceProvider, (void **) & pISP );
        if( hr != S_OK || pISP == NULL )
            return E_FAIL;

        hr = pISP->QueryService( guidService, riid, ppvObject );

        return hr;
    }

    //
    // ACP/Anchor-neutral sinks - just broadcast these...
    //

    CSinkWrap_FORWARD( TS_AS_SEL_CHANGE,     OnSelectionChange,		0, () )
    CSinkWrap_FORWARD( TS_AS_LAYOUT_CHANGE,  OnLayoutChange,		2, ( TsLayoutCode, lcode, TsViewCookie, vcView ) )
    CSinkWrap_FORWARD( 0,                    OnStatusChange,		1, ( DWORD, dwFlags ) )
    CSinkWrap_FORWARD( 0,					 OnStartEditTransaction,0, () )
    CSinkWrap_FORWARD( 0,					 OnEndEditTransaction,  0, () )

    
    //
    // Special case for OnLockGranted...
    // Handle single-client sync requests, and multiple queued async requests...
    //

    HRESULT STDMETHODCALLTYPE OnLockGranted ( DWORD dwLockFlags )
    {
        IMETHOD( OnLockGranted );

        Assert( m_pMgr );
        return m_pMgr->SinkWrap_HandleOnLockGranted( dwLockFlags );
    }
};







//
// CSinkWrapACP
//
// - ACP sink wrapper
//
// Derived from the CSinkWrapBase, this adds ACP-specific methods; including
// those from both ITextStoreACP and the cicero-specific ITfTextStoreSink
// interfaces.
//

class ATL_NO_VTABLE CSinkWrapACP : 
    public CSinkWrapBase< DocTraitsACP >
{

public:
    //
    // ITextStoreACPSink ACP/Anchor-specific methods - broadcast to all interested sinks...
    // (See CSinkWrapBase for the forwarding macro.)
    //

    CSinkWrap_FORWARD( TS_AS_TEXT_CHANGE,  OnTextChange,       2, ( DWORD, dwFlags, const TS_TEXTCHANGE *, pChange ) )
    CSinkWrap_FORWARD( 0,                  OnAttrsChange,      4, ( LONG, acpStart, LONG, acpEnd, ULONG, cAttrs, const TS_ATTRID *, paAttrs ) )


    //
    // Cicero-specific sink methods - forward these to the first available sink that implements the cicero interface...
    // (See CSinkWrapBase for the forwarding macro.)
    //

    CSinkWrap_FORWARD_CICERO( Serialize,     	4, (ITfProperty *, pProp, ITfRange *, pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *, pHdr, IStream *, pStream) )
    CSinkWrap_FORWARD_CICERO( Unserialize,   	4, (ITfProperty *, pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *, pHdr, IStream *, pStream, ITfPersistentPropertyLoaderACP *, pLoader) )
    CSinkWrap_FORWARD_CICERO( ForceLoadProperty,1, (ITfProperty *, pProp) )
    CSinkWrap_FORWARD_CICERO( CreateRange,   	3, (LONG, acpStart, LONG, acpEnd, ITfRangeACP **, ppRange) )

};




//
// CSinkWrapAnchor
//
// - Anchor sink wrapper
//
// Derived from the CSinkWrapBase, this adds Anchor-specific methods; including
// those from both ITextStoreACP and the cicero-specific ITfTextStoreSink
// interfaces.
//

class ATL_NO_VTABLE CSinkWrapAnchor : 
    public CSinkWrapBase< DocTraitsAnchor >
{

public:
    //
    // ITextStoreACPSink ACP/Anchor-specific methods - broadcast to all interested sinks...
    // (See CSinkWrapBase for the forwarding macro.)
    //

    CSinkWrap_FORWARD( TS_AS_TEXT_CHANGE,  OnTextChange,       3, ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd ) )
    CSinkWrap_FORWARD( 0,                  OnAttrsChange,      4, ( IAnchor *, paStart, IAnchor *, paEnd, ULONG, cAttrs, const TS_ATTRID *, paAttrs ) )


    //
    // Cicero-specific sink methods - forward these to the first available sink that implements the cicero interface...
    // (See CSinkWrapBase for the forwarding macro.)
    //
    
    CSinkWrap_FORWARD_CICERO( Serialize,     	4, (ITfProperty *, pProp, ITfRange *, pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *, pHdr, IStream *, pStream) )
    CSinkWrap_FORWARD_CICERO( Unserialize,   	4, (ITfProperty *, pProp, const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *, pHdr, IStream *, pStream, ITfPersistentPropertyLoaderAnchor *, pLoader) )
    CSinkWrap_FORWARD_CICERO( ForceLoadProperty,1, (ITfProperty *, pProp) )
    CSinkWrap_FORWARD_CICERO( CreateRange,   	3, (IAnchor *, paStart, IAnchor *, paEnd, ITfRangeAnchor **, ppRange) )


};













CDocWrap::CDocWrap()
    : m_punkDoc( NULL ),
      m_pWrapMgr( NULL )
{
    IMETHOD( CDocWrap );
    // Done.
}

CDocWrap::~CDocWrap()
{
    IMETHOD( ~CDocWrap );

    _Clear();
}


HRESULT STDMETHODCALLTYPE CDocWrap::SetDoc( REFIID riid, IUnknown * pDocIn )
{
    IMETHOD( SetDoc );

    _Clear();

    if( pDocIn == NULL )
    {
        TraceInfo( TEXT("CDocWrapp::SetDoc( NULL ) - doc cleared") );
        return S_OK;
    }

    HRESULT hr;
    if( riid == IID_ITextStoreACP || riid == IID_ITfTextStoreACP )
    {
        CWrapMgr< DocTraitsACP > * pWrapMgrACP;
        hr = CreateLocalInstance( & pWrapMgrACP );
        m_pWrapMgr = pWrapMgrACP;
    }
    else if( riid == IID_ITextStoreAnchor || riid == IID_ITfTextStoreAnchor )
    {
        CWrapMgr< DocTraitsAnchor > * pWrapMgrAnchor;
        hr = CreateLocalInstance( & pWrapMgrAnchor );
        m_pWrapMgr = pWrapMgrAnchor;
    }
    else
    {
        TraceParam( TEXT("CDocWrapp::SetDoc - given unknown IID") );
        return E_NOINTERFACE;
    }

    CHECK_HR_RETURN( hr, m_pWrapMgr != NULL );

    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("Couldn't create CWrapMgr") );
        return FAILED( (hr) ) ? (hr) : E_UNEXPECTED;
    }
    if( hr == S_OK && ! m_pWrapMgr )
    {
        TraceErrorHR( hr, TEXT("Couldn't create CWrapMgr") );
        return E_UNEXPECTED;
    }


    m_pWrapMgr->SetDoc( pDocIn );
    m_iid = riid;
    m_punkDoc = pDocIn;
    m_punkDoc->AddRef();

    TraceInfo( TEXT("CDocWrap::SetDoc - new doc set.") );
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CDocWrap::GetWrappedDoc( REFIID riid, IUnknown ** pWrappedDocOut )
{
    IMETHOD( GetWrappedDoc );

    if( ! m_punkDoc || ! m_pWrapMgr )
    {
        TraceParam( TEXT("GetWrappedDoc called without prior successful call to SetDoc") );
        return E_FAIL;
    }
    if( ! pWrappedDocOut )
    {
        TraceParam( TEXT("GetWrappedDoc called without NULL pWrappedDocOut param") );
        return E_POINTER;
    }

    // Check that requested iid matches...
    // We allow Doc/ITf mixes, provided the interfaces match ACP/Anchor-wise.
    if( m_iid == IID_ITextStoreAnchor || m_iid == IID_ITfTextStoreAnchor )
    {
        if( riid != IID_ITextStoreAnchor && riid != IID_ITfTextStoreAnchor )
        {
            TraceParam( TEXT("Interface requested by GetWrappedDoc doesn't match that suplied by SetDoc") );
            return E_NOINTERFACE;
        }
    }
    else
    {
        if( riid != IID_ITextStoreACP && riid != IID_ITfTextStoreACP )
        {
            TraceParam( TEXT("Interface requested by GetWrappedDoc doesn't match that suplied by SetDoc") );
            return E_NOINTERFACE;
        }
    }


    TraceInfo( TEXT("GetWrappedDoc succeeded") );

    return m_pWrapMgr->CreateWrappedDoc( pWrappedDocOut );
}



void CDocWrap::_Clear()
{
    SafeReleaseClear( m_pWrapMgr );
    SafeReleaseClear( m_punkDoc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\docwrapexcept.h ===
// DocWrapExcept
//
// Classes that wrap interface pointers. All methods are passed through, but any
// SEH-type exceptions are caught, logged, and result in an error.
//
// Note that COM interfaces are not supposed to throw exceptions - this code exists
// as a robustness/preventative measure.
//
// This file in #included by DocWrapImpl.cpp. It exists as a separate file just to
// avoid clutter - this code is not currently reused anywhere else.

// Code below assumes the following have already beein defined (in DocWrapImpl.cpp):
//     class BasicDocTraitsAnchor
//     class BasicDocTraitsACP

#include <tStr.h>

void HandleException( DWORD dwException, LPCTSTR pFName )
{
    TraceError( TSTR() << TEXT("Exception 0x") << WriteHex( dwException ) << TEXT(" thrown from ") << pFName );
}


// If we want to use the IMETHOD(name) call tracking macro here, we need to disable warning 4509,
// which warns against mixing object that have destructors (used by IMETHOD) and SEH.
//
// #pragma warning( disable : 4509 )

// Forwarding macro:
// Calls through the interface - assumes a member variable pThis of the correct type.
// Exceptions are logged (in HandleException), and a failure code returned.
#define EXCEPT_FORWARD( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        __try {\
            return m_pThis-> fname AS_CALL( c, params ) ;\
        }\
        __except( HandleException( GetExceptionCode(), TEXT( # fname ) ), EXCEPTION_EXECUTE_HANDLER ) {\
            return E_FAIL;\
        }\
    }


// This class acts as a 'holder' for the class that actually does the forwarding.
// Template parameter I is the original interface being wrapped, template parameter
// W is the wrapping/forwarding interface.
// This class just takes care of basic 'smart pointer' housekeeping - assignment,
// operator->, etc.
//
// Assumes that the wrapper class will have an accessible member pThis of type I*.

template < class I, class W >
class SEHWrapPtr
{
    W   m_SEHWrap;
public:

    SEHWrapPtr( I * pThis )
    {
        m_SEHWrap.m_pThis = pThis;
    }

    operator I * ( )
    {
        return m_SEHWrap.m_pThis;
    }

    W * operator -> () 
    {
        return & m_SEHWrap;
    }

    operator & ()
    {
        return & m_SEHWrap.m_pThis;
    }

    void operator = ( I * pI )
    {
        m_SEHWrap.m_pThis = pI;
    }
};


// SEH Wrapper for IUnknown. Other SEH wrappers that wrap COM interfaces derive from this.

template < class I >
struct SEHWrap_IUnknown
{
public:
    I * m_pThis;

    EXCEPT_FORWARD( AddRef,                     0,  ( ) )
    EXCEPT_FORWARD( Release,                    0,  ( ) )
    EXCEPT_FORWARD( QueryInterface,             2,  ( REFIID, riid, void **, ppv ) )
};


// This wrapper wraps methods which are common to ITextStoreACP and ITextStoreAnchor.
// Derived classes add in the ACP- and Anchor- specific methods.

template < class DocTraits >
struct SEHWrap_TextStoreBase : public SEHWrap_IUnknown < DocTraits::IDoc >
{
public:

    EXCEPT_FORWARD( AdviseSink,                 3,  ( REFIID, riid, IUnknown *, punk, DWORD, dwMask ) )
    EXCEPT_FORWARD( UnadviseSink,               1,  ( IUnknown *, punk ) )
    EXCEPT_FORWARD( RequestLock,                2,  ( DWORD, dwLockFlags, HRESULT *, phrSession ) )

    EXCEPT_FORWARD( GetStatus,                  1,  ( TS_STATUS *,               pdcs ) )

    EXCEPT_FORWARD( QueryInsert,              	5,  ( DocTraits::PosType,       InsertStart,
    												  DocTraits::PosType,       InsertEnd,
    												  ULONG,					cch,
                                                      DocTraits::PosType *,     ppaInsertStart,
                                                      DocTraits::PosType *,     ppaInsertEnd ) )

    EXCEPT_FORWARD( QueryInsertEmbedded,		3,	( const GUID *,				pguidService,
													  const FORMATETC *,		pFormatEtc,
													  BOOL *,					pfInsertable ) )
       
        
    EXCEPT_FORWARD( GetScreenExt,               2,  ( TsViewCookie,				vcView,
    												  RECT *,                   prc ) )

    EXCEPT_FORWARD( GetWnd,                     2,  ( TsViewCookie, 			vcView,
													  HWND *,                   phwnd ) )

    EXCEPT_FORWARD( GetFormattedText,           3,  ( DocTraits::PosType,       Start,
                                                      DocTraits::PosType,       End,
                                                      IDataObject **,           ppDataObject ) )

    EXCEPT_FORWARD( GetTextExt,                 5,  ( TsViewCookie,				vcView,
													  DocTraits::PosType,       Start,
                                                      DocTraits::PosType,       End,
                                                      RECT *,                   prc,
                                                      BOOL *,                   pfClipped ) )

    EXCEPT_FORWARD( RequestSupportedAttrs,          3,  ( DWORD,                    dwFlags,
													  ULONG, 					cFilterAttrs,
													  const TS_ATTRID *,			paFilterAttrs ) )

    EXCEPT_FORWARD( RequestAttrsAtPosition,         4,  ( DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,         paFilterAttrs,
                                                      DWORD,                    dwFlags ) )

    EXCEPT_FORWARD( RequestAttrsTransitioningAtPosition,
                                                4,  ( DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,         paFilterAttrs,
                                                      DWORD,                    dwFlags ) )

    EXCEPT_FORWARD( RetrieveRequestedAttrs,     3,  ( ULONG,                    ulCount,
                                                      TS_ATTRVAL *,              paAttrVals,
                                                      ULONG *,                  pcFetched ) )


    EXCEPT_FORWARD( GetActiveView,				1,  ( TsViewCookie *,			pvcView ) )

/*
    EXCEPT_FORWARDEXT( ScrollToRect,            4,  ( DocTraits::PosType,       Start,
                                                      DocTraits::PosType,       End,
                                                      RECT,                     rc,
                                                      DWORD,                    dwPosition ) )
*/
};


struct SEHWrap_TextStoreACP : public SEHWrap_TextStoreBase< BasicDocTraitsACP >
{
    EXCEPT_FORWARD( GetSelection,               4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ACP *, pSelection, ULONG *, pcFetched ) )
    EXCEPT_FORWARD( GetText,                    9, ( LONG, acpStart, LONG, acpEnd, WCHAR *, pchPlain, ULONG, cchPlainReq, ULONG *, pcchPlainRet, TS_RUNINFO *, prgRunInfo, ULONG, cRunInfoReq, ULONG *, pcRunInfoRet, LONG *, pacpNext ) )
    EXCEPT_FORWARD( GetEmbedded,                4,  ( LONG, Pos, REFGUID, rguidService, REFIID, riid, IUnknown **, ppunk ) )
    EXCEPT_FORWARD( GetEndACP,                  1,  ( LONG *, pacp ) )
    EXCEPT_FORWARD( GetACPFromPoint,            4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, LONG *, pacp ) )
    EXCEPT_FORWARD( FindNextAttrTransition,     8,  ( LONG, acpStart, LONG, acpEnd, ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, LONG *, pacpNext, BOOL *, pfFound, LONG *, plFoundOffset ) )
    EXCEPT_FORWARD( SetSelection,               2,  ( ULONG, ulCount, const TS_SELECTION_ACP *, pSelection ) )
    EXCEPT_FORWARD( SetText,                    6,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, const WCHAR *, pchText, ULONG, cch, TS_TEXTCHANGE *, pChange ) )
    EXCEPT_FORWARD( InsertEmbedded,             5,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, IDataObject *, pDataObject, TS_TEXTCHANGE *, pChange ) )
    EXCEPT_FORWARD( InsertTextAtSelection,		6,  ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange ) )
    EXCEPT_FORWARD( InsertEmbeddedAtSelection,	5,  ( DWORD, dwFlags, IDataObject *, pDataObject, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange ) )
};


struct SEHWrap_TextStoreAnchor : public SEHWrap_TextStoreBase< BasicDocTraitsAnchor >
{
    EXCEPT_FORWARD( GetSelection,               4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ANCHOR *, pSelection, ULONG *, pcFetched ) )
    EXCEPT_FORWARD( GetText,                    7,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, WCHAR *, pchText, ULONG, cchReq, ULONG *, pcch, BOOL, fUpdateAnchor ) )
    EXCEPT_FORWARD( GetEmbedded,                5,  ( DWORD, dwFlags, IAnchor *, Pos, REFGUID, rguidService, REFIID, riid, IUnknown **, ppunk ) )
    EXCEPT_FORWARD( GetStart,                   1,  ( IAnchor **, ppaStart ) )
    EXCEPT_FORWARD( GetEnd,                     1,  ( IAnchor **, ppaEnd ) )
    EXCEPT_FORWARD( GetAnchorFromPoint,         4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, IAnchor **, ppaSite ) )
    EXCEPT_FORWARD( FindNextAttrTransition,     7,  ( IAnchor *, paStart, IAnchor *, paEnd,  ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, BOOL *, pfFound, LONG *, plFoundOffset ) )
    EXCEPT_FORWARD( SetSelection,               2,  ( ULONG, ulCount, const TS_SELECTION_ANCHOR *, pSelection ) )
    EXCEPT_FORWARD( SetText,                    5,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, const WCHAR *, pchText, ULONG, cch ) )
    EXCEPT_FORWARD( InsertEmbedded,             4,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, IDataObject *, pDataObject ) )
    EXCEPT_FORWARD( InsertTextAtSelection,		5,  ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch,  IAnchor **, ppaStart, IAnchor **, ppaEnd ) )
    EXCEPT_FORWARD( InsertEmbeddedAtSelection,	4,  ( DWORD, dwFlags, IDataObject *, pDataObject,  IAnchor **, ppaStart, IAnchor **, ppaEnd ) )
};


// Finally, put the wrapper classes together with the holder classes to create 'smart pointer'-like
// SEH wrappers:
typedef SEHWrapPtr< ITextStoreACP, SEHWrap_TextStoreACP > SEHWrapPtr_TextStoreACP;
typedef SEHWrapPtr< ITextStoreAnchor, SEHWrap_TextStoreAnchor > SEHWrapPtr_TextStoreAnchor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\dict.h ===
// DictImpl.h : Declaration of the CDict

#ifndef __DICT_H_
#define __DICT_H_

#include "resource.h"       // main symbols
#include <map>
/////////////////////////////////////////////////////////////////////////////
// CDict

class CDict;

struct TermInfo
{
    const TS_ATTRID *	pTermID;
    const TS_ATTRID *   pParentID;
    WCHAR *             pszMnemonic;
    ULONG               idString;
    BSTR ( CDict::*mfpConvertToString ) ( const VARIANT &, LCID & );
};


struct GUIDLess
{
	bool operator ()(const GUID& g1, const GUID& g2) const
	{
		const ULONG *lpGUID1 = (ULONG *)&g1;
		const ULONG *lpGUID2 = (ULONG *)&g2;
		for (int i = 0; i < 4; i++)
		{
			if (lpGUID1[i] < lpGUID2[i])
				return true;
			if (lpGUID1[i] > lpGUID2[i])
				return false;
		}
						
		return false; 
	}
};

struct WCHARLess
{
	bool operator ()(const WCHAR* s1, const WCHAR* s2) const
	{
		if (wcscmp(s1, s2) < 0)
			return true;
		else
			return false; 
	}
};

typedef std::map<const TS_ATTRID, const TermInfo*, GUIDLess> DictMap;
typedef std::map<const WCHAR *, const TermInfo*, WCHARLess> DictMnemonicMap;


class ATL_NO_VTABLE CDict : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDict, &CLSID_AccDictionary>,
	public IAccDictionary
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_MSAADICT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDict)
	COM_INTERFACE_ENTRY(IAccDictionary)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
#ifdef DEBUG
		m_hinstResDll = LoadLibraryEx( TEXT("C:\\tools\\OLEACCRC.DLL"), NULL, LOAD_LIBRARY_AS_DATAFILE );
		if( m_hinstResDll )
		{
			// load it from where I put it for debug purposes
			return S_OK;
		}
#endif
		m_hinstResDll = LoadLibraryEx( TEXT("OLEACCRC.DLL"), NULL, LOAD_LIBRARY_AS_DATAFILE );
		if( ! m_hinstResDll )
		{
			return E_FAIL;
		}

		return S_OK;
	}

    CDict();
    ~CDict();
    // IAccDictionary

	HRESULT STDMETHODCALLTYPE GetLocalizedString (
								REFGUID			Term,
								LCID			lcid,
								BSTR *			pResult,
								LCID *			plcid			
	);
	
	HRESULT STDMETHODCALLTYPE GetParentTerm (
								REFGUID			Term,
								GUID *			pParentTerm
	);

	HRESULT STDMETHODCALLTYPE GetMnemonicString (
								REFGUID			Term,
								BSTR *			pResult
	);

	HRESULT STDMETHODCALLTYPE LookupMnemonicTerm (
								BSTR			bstrMnemonic,
								GUID *			pTerm
	);
	
	HRESULT STDMETHODCALLTYPE ConvertValueToString (
								REFGUID			Term,
								LCID			lcid,
								VARIANT			varValue,
								BSTR *			pbstrResult,
								LCID *			plcid			
	);
	
	// The following convert member functions are called from ConvertValueToString
	// by accessing a member function pointer in the dictionary
	BSTR ConvertPtsToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertBoolToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertColorToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertWeightToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertLangIDToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertBSTRToString( const VARIANT & value, LCID & lcid );

private:
	double CDict::ColorDistance(COLORREF crColor1, COLORREF crColor2);

private:
    DictMap m_mapDictionary;
    DictMnemonicMap m_mapMnemonicDictionary;
	HINSTANCE m_hinstResDll;
};

#endif //__DICT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\msaaclientadapter.cpp ===
// MSAAClientAdapter.cpp : Implementation of AccClientDocMgr
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAClientAdapter.h"
#include "MSAAStore.h"


/////////////////////////////////////////////////////////////////////////////
// AccClientDocMgr

CAccClientDocMgr::CAccClientDocMgr()
{
    IMETHOD( CAccClientDocMgr );
}


CAccClientDocMgr::~CAccClientDocMgr()
{
    IMETHOD( ~CAccClientDocMgr );
	m_pAccStore->Release();
}


HRESULT STDMETHODCALLTYPE CAccClientDocMgr::GetDocuments (
	IEnumUnknown ** enumUnknown
)
{
    IMETHOD( GetDocuments );
	return m_pAccStore->GetDocuments( enumUnknown );
}


HRESULT STDMETHODCALLTYPE CAccClientDocMgr::LookupByHWND (
	HWND		hWnd,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByHWND );
	return m_pAccStore->LookupByHWND( hWnd, riid, ppunk );
}


HRESULT STDMETHODCALLTYPE CAccClientDocMgr::LookupByPoint (
	POINT		pt,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByPoint );
	return m_pAccStore->LookupByPoint( pt, riid, ppunk );
}

HRESULT STDMETHODCALLTYPE CAccClientDocMgr::GetFocused (
	REFIID	riid,
	IUnknown **	ppunk
)
{
    IMETHOD( GetFocused );
	return m_pAccStore->GetFocused( riid, ppunk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\msaaadapter.h ===
// MSAAAdapter.h : Declaration of the CAccServerDocMgr

#ifndef __MSAAADAPTER_H_
#define __MSAAADAPTER_H_

#include "resource.h"       // main symbols
#include <list_dl.h>

/////////////////////////////////////////////////////////////////////////////
// CAccServerDocMgr

struct ITextStoreAnchor; // fwd. decl.
struct IAccStore; // fwd. decl.

class ATL_NO_VTABLE CAccServerDocMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccServerDocMgr, &CLSID_AccServerDocMgr>,
	public IAccServerDocMgr
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_ACCSERVERDOCMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccServerDocMgr)
	COM_INTERFACE_ENTRY(IAccServerDocMgr)
END_COM_MAP()



    CAccServerDocMgr();
    ~CAccServerDocMgr();

    // IAccServerDocMgr

    HRESULT STDMETHODCALLTYPE NewDocument ( 
        REFIID		riid,
		IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE RevokeDocument (
        IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE OnDocumentFocus (
        IUnknown *	punk
	);


private:
    
    struct DocAssoc: public Link_dl< DocAssoc >
    {
        IUnknown *          m_pdocOrig;     // original doc interface
        IUnknown *          m_pdocAnchor;   // wrapped anchor

        // How are pdocOrig and pdocAnchor related? 
        //
        // pdocOrig is the canonical IUnknown of the original doc ptr passed in to NewDocument.
        //
        // pdocAnchor is a wrapped version of the original doc ptr passed in.
        //
        // - if the original doc is ACP, an ACP->Anchor wrap layer is applied.
        //     (this shouldn't be used much, since Cicero hand us pre-wrapped IAnchor interfaces.)
        //
        // - if the original doc doesn't support multiple clients (via IClonableWrapper),
        //     a multi-client wrap layer is applied.
        //
        // If the passed in anchor supports IAnchor and IClonableWrapper (which is the
        // usual case when we get a doc from Cicero - it does the ACP wrapping, and uses
        // the DocWrap to allow it to share it with MSAA), then no further wrapping will
        // be applied.
    };

    List_dl< DocAssoc >     m_Docs;

    IAccStore *            m_pAccStore;
};

#endif //__MSAAADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\msaaclientadapter.h ===
// MSAAClientAdapter.h : Declaration of the CAccClientDocMgr

#ifndef __MSAACLIENTADAPTER_H_
#define __MSAACLIENTADAPTER_H_

#include "resource.h"       // main symbols
/////////////////////////////////////////////////////////////////////////////
// CAccClientDocMgr
class ATL_NO_VTABLE CAccClientDocMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccClientDocMgr, &CLSID_AccClientDocMgr>,
	public IAccClientDocMgr
{
public:
	CAccClientDocMgr();
	~CAccClientDocMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_ACCCLIENTDOCMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccClientDocMgr)
	COM_INTERFACE_ENTRY(IAccClientDocMgr)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
        bool fInit = false;
        HANDLE hInit = OpenEvent( SYNCHRONIZE, FALSE, TEXT("MSAA_STORE_EVENT") );
        if ( hInit )
        {
            fInit = true;
            CloseHandle( hInit );
        }

		HRESULT hr = CoCreateInstance( CLSID_AccStore, NULL, CLSCTX_LOCAL_SERVER, IID_IAccStore, (void **) & m_pAccStore );

        // if this Event does not exist then the store is being created for the first time
        // so lets wait a little bit to let the store settle down.
        if ( !hInit )
            Sleep (500);

		return hr;
	}

// IAccClientDocMgr
public:

	HRESULT STDMETHODCALLTYPE GetDocuments (
		IEnumUnknown ** enumUnknown
	);

	HRESULT STDMETHODCALLTYPE LookupByHWND (
		HWND		hWnd,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE LookupByPoint (
		POINT		pt,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE GetFocused (
		REFIID	riid,
		IUnknown **	ppunk
	);

private:

	IAccStore * m_pAccStore;
};

#endif //__MSAACLIENTADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\msaaadapter.cpp ===
// MSAAAdapter.cpp : Implementation of CAccServerDocMgr
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAAdapter.h"

#define INITGUID
#include <msctfx.h>

#include "MSAAStore.h"

// - in AnchorWrap.cpp
HRESULT WrapACPToAnchor( ITextStoreACP * pDocAcp, ITextStoreAnchor ** ppDocAnchor );



CAccServerDocMgr::CAccServerDocMgr()
    : m_pAccStore( NULL )
{
    IMETHOD( CAccServerDocMgr );
}

CAccServerDocMgr::~CAccServerDocMgr()
{
    IMETHOD( ~CAccServerDocMgr );

    if( m_pAccStore )
    {
        m_pAccStore->Release();
    }
}


BOOL CheckForWrapper( ITextStoreAnchor ** ppDoc )
{
    // Is this a cloneable wrapper? If not, need to wrap it...

    IClonableWrapper * pClonableWrapper = NULL;
    HRESULT hr = (*ppDoc)->QueryInterface( IID_IClonableWrapper, (void **) & pClonableWrapper );

    if( hr == S_OK && pClonableWrapper )
    {
        // It already supports IClonableWrapper - nothing else to do...
        pClonableWrapper->Release();
        return TRUE;
    }

    // Need to use doc wrapper to get clonable (multi-client) support

    IDocWrap * pDocWrap = NULL;
    hr = CoCreateInstance( CLSID_DocWrap, NULL, CLSCTX_SERVER, IID_IDocWrap, (void **) & pDocWrap );
    if( hr != S_OK || ! pDocWrap )
        return FALSE;

    hr = pDocWrap->SetDoc( IID_ITextStoreAnchor, *ppDoc );
    if( hr != S_OK )
    {
        pDocWrap->Release();
        return FALSE;
    }

    ITextStoreAnchor * pNewDoc = NULL;
    hr = pDocWrap->GetWrappedDoc( IID_ITextStoreAnchor, (IUnknown **) & pNewDoc );
    pDocWrap->Release();

    if( hr != S_OK || ! pNewDoc )
        return FALSE;

    // This time round, QI should work (since we're talking to a wrapper)...

    pClonableWrapper = NULL;
    hr = pNewDoc->QueryInterface( IID_IClonableWrapper, (void **) & pClonableWrapper );
    if( hr != S_OK || ! pClonableWrapper )
    {
        pNewDoc->Release();
        return FALSE;
    }

    // Yup, it worked - replace the input doc with the new wrapped doc...
    pClonableWrapper->Release();
    (*ppDoc)->Release();
    *ppDoc = pNewDoc;
    return TRUE;
}




HRESULT STDMETHODCALLTYPE CAccServerDocMgr::NewDocument ( 
    REFIID		riid,
	IUnknown *	punk
)
{
    IMETHOD( NewDocument );

    // Check for known IIDs...

    CComPtr<ITextStoreAnchor> pDoc;
    if( riid == IID_ITextStoreAnchor || riid == IID_ITfTextStoreAnchor )
    {
        pDoc = (ITextStoreAnchor *) punk;
    }
    else if( riid == IID_ITextStoreACP || riid == IID_ITfTextStoreACP )
    {
        TraceParam( TEXT("Got ACP doc, but ACP->Anchor wrapping not currently supported") );
        return E_NOTIMPL;
/*
// We don't currently support ACP- interfaces directly - cicero always gives us
// Anchor interfaces, wrapping ACPs if necesary.
        HRESULT hr = WrapACPToAnchor( static_cast<ITextStoreACP *>( punk ), & pDoc );
        if( hr != S_OK )
            return hr;
*/
    }
    else
    {
        TraceParam( TEXT("Got unknown interface - wasn't ITextStoreAnchor/ITfTextStoreAnchor") );
        return E_NOINTERFACE;
    }


    // Wrap the doc if necessary, to get multi-client support (via IClonableWrapper)...
    if( ! CheckForWrapper( & pDoc.p ) )
    {
        return E_FAIL;
    }


    if( ! m_pAccStore )
    {
        m_pAccStore = NULL;
        HRESULT hr = CoCreateInstance( CLSID_AccStore, NULL, CLSCTX_LOCAL_SERVER, IID_IAccStore, (void **) & m_pAccStore );
        if( ! m_pAccStore )
        {
            TraceErrorHR( hr, TEXT("CoCreate(AccStore)") );
            return hr;
        }
    }

    // TODO - what IID here?
    HRESULT hr = m_pAccStore->Register( IID_ITextStoreAnchor, pDoc.p );

    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("m_pAccStore->Register()") );
        return hr;
    }


    IUnknown * pCanonicalUnk = NULL;
    hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
    if( hr == S_OK && pCanonicalUnk != NULL )
    {
        DocAssoc * pDocAssoc = new DocAssoc;
        if ( !pDocAssoc )
        {
            return E_OUTOFMEMORY;
        }
        
        pDocAssoc->m_pdocAnchor = pDoc;
        pDocAssoc->m_pdocOrig = pCanonicalUnk;
        m_Docs.AddToHead( pDocAssoc );
    }
    else
    {
        AssertMsg( FALSE, TEXT("QI(IUnknown) failed") );
        return hr;
    }

    pDoc.p->AddRef(); 

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccServerDocMgr::RevokeDocument (
    IUnknown *	punk
)
{
    IMETHOD( RevokeDocument );

	if ( !punk )
		return E_INVALIDARG;

    // Get the canonical IUnknown for comparison purposes...
    IUnknown * pCanonicalUnk = NULL;
    if( punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk ) != S_OK || pCanonicalUnk == NULL )
    {
        return E_FAIL;
    }


    // Do we recognise this doc?
    DocAssoc * pDocAssoc = NULL;
    for( Iter_dl< DocAssoc > i ( m_Docs ) ; ! i.AtEnd() ; i++ )
    {
        if( i->m_pdocOrig == pCanonicalUnk )
        {
            pDocAssoc = i;
            break;
        }
    }

    pCanonicalUnk->Release();

    if( ! pDocAssoc )
    {
        // Not found
        return E_INVALIDARG;
    }

    // Unregister with the store...
    HRESULT hr = m_pAccStore->Unregister( pDocAssoc->m_pdocAnchor );
    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("m_pAccStore->Unregister()") );
    }


    // Try calling IInternalDocWrap::NotifyRevoke() to tell the DocWrapper that the doc is
    // going away. (It will forward this to any interested clients.)
    IInternalDocWrap * pInternalDocWrap = NULL;
    hr = pDocAssoc->m_pdocAnchor->QueryInterface( IID_IInternalDocWrap, (void **) & pInternalDocWrap );

    if( hr == S_OK && pInternalDocWrap )
    {
        pInternalDocWrap->NotifyRevoke();
        pInternalDocWrap->Release();
    }
    else
    {
        TraceErrorHR( hr, TEXT("pdocAnchor didn't support IInternalDocWrap - was it wrapped properly?") );
    }


    // Remove from internal list...
    m_Docs.remove( pDocAssoc );
    pDocAssoc->m_pdocOrig->Release();
    pDocAssoc->m_pdocAnchor->Release();
    delete pDocAssoc;

    // Done.
    return hr;
}

HRESULT STDMETHODCALLTYPE CAccServerDocMgr::OnDocumentFocus (
    IUnknown *	punk
)
{
    IMETHOD( OnDocumentFocus );

    if( ! m_pAccStore )
    {
        m_pAccStore = NULL;
        HRESULT hr = CoCreateInstance( CLSID_AccStore, NULL, CLSCTX_LOCAL_SERVER, IID_IAccStore, (void **) & m_pAccStore );
        if( ! m_pAccStore )
        {
            TraceErrorHR( hr, TEXT("CoCreate(AccStore)") );
            return hr;
        }
    }
	return m_pAccStore->OnDocumentFocus( punk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\msaastore.cpp ===
// MSAAStore.cpp : Implementation of CAccStore
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAStore.h"

#include <windowsx.h>

#include <algorithm>
#include <stack>
using namespace std;

#include <debug.h>
#include <TSTR.h>

#define ARRAYSIZE( a )  (sizeof(a)/sizeof(a[0]))

CAccStore * m_pTheStore = NULL;

POINT ptListOffset;
POINT ptDumpOffset;
BOOL fGotSize = FALSE;


BOOL_PTR CALLBACK DialogProc ( HWND hwndDlg,
                           UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam )
{
	return m_pTheStore->DialogProc ( hwndDlg, uMsg, wParam, lParam );
}

BOOL_PTR CAccStore::DialogProc ( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_INITDIALOG:
        {
            RECT rcWnd;
            GetClientRect( hwndDlg, & rcWnd );

            RECT rcList;
            GetWindowRect( GetDlgItem( hwndDlg, IDC_LIST ), & rcList );
            MapWindowPoints( NULL, hwndDlg, (POINT *) & rcList, 2 );
            ptListOffset.x = rcWnd.right - ( rcList.right - rcList.left );
            ptListOffset.y = rcWnd.bottom - ( rcList.bottom - rcList.top );

            RECT rcDump;
            GetWindowRect( GetDlgItem( hwndDlg, ID_DUMP ), & rcDump );
            MapWindowPoints( NULL, hwndDlg, (POINT *) & rcDump, 2 );
            ptDumpOffset.x = rcWnd.right - rcDump.left;
            ptDumpOffset.y = rcWnd.bottom - rcDump.top;

            fGotSize = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            if( LOWORD( wParam ) == ID_DUMP )
            {
                Assert( m_pTheStore );
                DumpInfo();
                break;
            }
            break;
        }

        case WM_SIZE:
        {
            if( wParam != SIZE_MINIMIZED && fGotSize )
            {
                int width = LOWORD( lParam );
                int height = HIWORD( lParam );

                SetWindowPos( GetDlgItem( hwndDlg, IDC_LIST ), NULL,
                              0, 0,
                              width - ptListOffset.x, height - ptListOffset.y, SWP_NOMOVE | SWP_NOZORDER );

                SetWindowPos( GetDlgItem( hwndDlg, ID_DUMP ), NULL,
                              width - ptDumpOffset.x, height - ptDumpOffset.y,
                              0, 0,
                              SWP_NOSIZE | SWP_NOZORDER );
            }
            break;
        }
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAccStore

CAccStore::CAccStore() : m_hwndDlg(NULL), m_hList(NULL), m_ShowDialog(NULL), m_punkFocused(NULL), m_pCtl(NULL), m_hInit(NULL)
{
    IMETHOD( CAccStore );

    Assert( m_pTheStore == NULL );

    m_pTheStore = this;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_MSAAControl,
                     NULL, 
                     CLSCTX_INPROC_SERVER, 
                     IID_ITfMSAAControl, 
                     (void**)&m_pCtl);
    if ( hr != S_OK )
    {
        Log( TSTR() << TEXT("CoCreateInstance failed for CLSID_MSAAControl hr=") << WriteHex(hr) );
    }
    else
    {
        hr = m_pCtl->SystemEnableMSAA();
        if ( hr != S_OK )
            Log( TSTR() << TEXT("SystemEnableMSAA failed hr=") << WriteHex(hr) );
    }

    // this lets someone in another procces se if the store is up
    m_hInit = CreateEvent( NULL, FALSE, TRUE, TEXT("MSAA_STORE_EVENT") );

	CRegKey crkShowDialog;
	DWORD dwShowDialog = 0;

    if ( ( crkShowDialog.Open(HKEY_CURRENT_USER, TEXT("Control Panel\\Accessibility"), KEY_READ) == ERROR_SUCCESS ) &&
    	 ( crkShowDialog.QueryValue( dwShowDialog, TEXT("ShowDialog") ) == ERROR_SUCCESS ) &&
    	 ( dwShowDialog ) )
   	{
		m_ShowDialog = true;
	}
	else
	{
		m_ShowDialog = false;
	}
	
	if ( m_ShowDialog )
	{
		m_hwndDlg = CreateDialog( _Module.GetModuleInstance(), MAKEINTRESOURCE( IDD_MAIN ), NULL, ::DialogProc );
		m_hList = GetDlgItem( m_hwndDlg, IDC_LIST );
		Log( TEXT("*** CAccStore ctor ***") );
        if ( m_pCtl == NULL )
    		Log( TEXT("m_pCtl is null") );
	}
}


CAccStore::~CAccStore()
{
    IMETHOD( ~CAccStore );

	EraseDeadDocuments();

    if ( m_punkFocused )
        m_punkFocused->Release();

    if ( m_pCtl )
    {
        m_pCtl->SystemDisableMSAA();
        m_pCtl->Release();
    }

    if ( m_hInit ) 
        CloseHandle( m_hInit );

    m_pTheStore = NULL;
    Log( TEXT("*** CAccStore dtor ***") );
	if ( m_ShowDialog )
	{
	    EndDialog( m_hwndDlg, TRUE );
	}
}



HRESULT STDMETHODCALLTYPE CAccStore::Register (
	REFIID		riid,
	IUnknown *	punk
)
{
    IMETHOD( Register );

	EraseDeadDocuments();

    if( riid != IID_ITextStoreAnchor )
    {
        Log( TEXT("Register - unknown IID") );
        return E_NOINTERFACE;
    }

    // Get the canonical IUnknown - we use this to compare against the interface
    // passed to Unregister.
    // Note that this is from the original interface peassed in, not a wrapped
    // version...
    IUnknown * pCanonicalUnk = NULL;
    HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
    if( hr != S_OK || ! pCanonicalUnk )
    {
        Log( TEXT("QueryInterface failed") );
        return E_FAIL;
    }

    // Now check that the doc pointer is a clonable wrapper - if not,
    // wrap it using DocWrap. We need a clonable wrapper so we can hand
    // out individual 'head' interfaces to multiple clients.

    ITextStoreAnchor * pDoc = reinterpret_cast< ITextStoreAnchor * >( punk );
    pDoc->AddRef();
    
    IClonableWrapper * pClonableWrapper = NULL;
    hr = pDoc->QueryInterface( IID_IClonableWrapper, (void **) & pClonableWrapper );
    if( hr != S_OK || ! pClonableWrapper )
    {
        // Uh-oh - we were supposed to be given a doc that (a) supports IDocAnchor, and (b)
        // supports IClonableWrapper (so is usable by multiple clients).
        // return failure...
        
    	TraceDebugHR( hr, TEXT( "QueryInterface for IID_IClonableWrapper failed") );

        pDoc->Release();
        pCanonicalUnk->Release();
        return E_FAIL;
    }


	// Add info to list...
    m_DocList.push_back( new DocInfo(pCanonicalUnk, pDoc, pClonableWrapper) );

    Log( TSTR() << TEXT("Register ") << WriteHex(pCanonicalUnk) << TEXT(", ") << WriteHex(pDoc) << TEXT(", ") << WriteHex(pClonableWrapper) );

    DumpInfo( m_DocList.back() );

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccStore::Unregister (
	IUnknown *	punk
)
{
    IMETHOD( Unregister );
    
    Log( TEXT("Unregister") );

    IUnknown * pCanonicalUnk = NULL;
    HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
    if( hr != S_OK || ! pCanonicalUnk )
    {
        return E_FAIL;
    }

	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predCanonicalUnk(pCanonicalUnk) );
	if ( it != m_DocList.end() )
	{
	    DocInfo * pDocInfo = *it;
        if ( m_ShowDialog )
            DumpInfo( pDocInfo );
        
        m_DocList.erase( it );
        delete pDocInfo;
    }
    else
    {
        Log( TSTR() << TEXT("Unregister of ") << WriteHex(pCanonicalUnk) << TEXT(" failed canonical unknown not found"));
    }

    pCanonicalUnk->Release();

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccStore::GetDocuments (
	IEnumUnknown ** enumUnknown
)
{
	EraseDeadDocuments();

	EnumDocs * EnumDocuments = new EnumDocs;

	EnumDocuments->Init(NULL, m_DocList);

	HRESULT hr = EnumDocuments->QueryInterface(IID_IEnumUnknown, (void **)enumUnknown);

	return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccStore::LookupByHWND (
	HWND		hWnd,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByHWND );

    Log( TEXT("LookupByHWND") );

    *ppunk = NULL;
    DocInfo * pInfo = _LookupDoc( hWnd );
    if( ! pInfo )
        return E_FAIL;

    return pInfo->m_pClonableWrapper->CloneNewWrapper( riid, (void **) ppunk );
}


HRESULT STDMETHODCALLTYPE CAccStore::LookupByPoint (
	POINT		pt,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByHWND );

    Log( TEXT("LookupByPoint") );

    *ppunk = NULL;
    DocInfo * pInfo = _LookupDoc( pt );
    if( ! pInfo )
        return E_FAIL;

    return pInfo->m_pClonableWrapper->CloneNewWrapper( riid, (void **) ppunk );
}

HRESULT STDMETHODCALLTYPE CAccStore::OnDocumentFocus (
    IUnknown *	punk
)
{
    IMETHOD( OnDocumentFocus );

    if ( m_punkFocused )
        m_punkFocused->Release();
        
   	m_punkFocused = punk;
   	
    if ( m_punkFocused )
    	m_punkFocused->AddRef();

	Log( TSTR() << TEXT("OnDocumentFocus ") << WriteHex(punk) );

	if ( m_ShowDialog )
    {
	    if ( punk )
	    {
		    ITextStoreAnchor * pITextStoreAnchor;
	        HRESULT hr = punk->QueryInterface( IID_ITextStoreAnchor, (void **) &pITextStoreAnchor );
	        Log( TSTR() << TEXT("QueryInterface for IID_ITextStoreAnchor hr=") << WriteHex(hr) << TEXT(" pITextStoreAnchor=") << pITextStoreAnchor );
#if(WINVER>=0x0500)
		    HWND hwnd;
		    TCHAR szWindowText[128];

            pITextStoreAnchor->GetWnd( NULL, & hwnd );
		    Log( TSTR() << TEXT("hwnd for focused doc is ") << WriteHex(hwnd) );
		    GetWindowText( GetAncestor( hwnd, GA_ROOT ), szWindowText, ARRAYSIZE( szWindowText ) );
	        Log( TSTR() << TEXT("OnDocumentFocus succeded for ") << szWindowText );
#endif
		    pITextStoreAnchor->Release();
	    }
    }	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CAccStore::GetFocused (
	REFIID	riid,
	IUnknown **	ppunk
)
{
    IMETHOD( GetFocused );
    
    if( ! m_punkFocused )
    {
        *ppunk = NULL;
    	Log( TEXT("No document has focus") );
        return S_OK;
    }
    else
    {
		HRESULT hr;
		hr = m_punkFocused->QueryInterface( riid, (void **)ppunk );
		if ( hr != S_OK )
		{
			TraceDebugHR( hr, TSTR() << TEXT( "QueryInterface failed for ") << riid );
			return hr;
		}
        return S_OK;
    }
}



void CAccStore::DumpInfo( DocInfo * pInfo )
{
    RECT rc = {-1,-1,-1,-1};
    HRESULT hr = pInfo->m_pDoc->GetScreenExt( NULL, & rc );

	TsViewCookie vcView;
	pInfo->m_pDoc->GetActiveView( &vcView );

    HWND hwnd = NULL;
    if( pInfo->m_pDoc->GetWnd( vcView, & hwnd ) != S_OK )
        hwnd = NULL;
    
    TCHAR str[80];
    if( hr == S_OK )
    {
        wsprintf( str, TEXT("Doc {%d,%d,%d,%d} 0x%08lX punk(0x%08lX)"), rc.left, rc.top, rc.right, rc.bottom, hwnd, pInfo->m_pCanonicalUnk );
    }
    else
    {
        wsprintf( str, TEXT("Doc {GetScreenExt failed: 0x%08lX} 0x%08lX punk(0x%08lX)"), hr, hwnd, pInfo->m_pCanonicalUnk );
    }

    Log( str );
}


void CAccStore::DumpInfo()
{
    Log( TEXT("Dumping...") );
    EraseDeadDocuments();

    for( DocList::iterator i = m_DocList.begin(); i != m_DocList.end(); i++ )
    {
        DumpInfo( *i );
    }
}





DocInfo * CAccStore::_LookupDoc( IUnknown * pCanonicalUnk )
{
	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predCanonicalUnk(pCanonicalUnk) );
	if ( it != m_DocList.end() )
		return *it;

    return NULL;
}

DocInfo * CAccStore::_LookupDoc( HWND hWnd )
{
	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predHWND(hWnd) );
	if ( it != m_DocList.end() )
		return *it;

    return NULL;
}

DocInfo * CAccStore::_LookupDoc( POINT pt )
{
    HWND hWnd = WindowFromPoint( pt );

	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predHWND(hWnd) );
	if ( it != m_DocList.end() )
		return *it;

    return NULL;
}

void CAccStore::EraseDeadDocuments()
{
	// get rid of any docs that are not here any more
	
    const int cDocList = m_DocList.size();
    int i = 1;
    for ( DocList::iterator it = m_DocList.begin(); it != m_DocList.end(); i++ )
	{
		TS_STATUS tsStatus;
		DocList::iterator DocToErase = it;

		it++;
		
		const DocInfo& di = **DocToErase;
		if ( di.m_pDoc->GetStatus( &tsStatus ) != S_OK )
		{
			m_DocList.erase( DocToErase );
	        Log( TEXT("Dead document erased") );
			TraceDebug( TEXT("Dead document erased") );
		}

        // make sure the list is OK 
        if ( i > cDocList )
        {
            Log( TEXT( "Doc list is invalid" ) );
            _ASSERT( 0 );
        }
	}
	

	return;
}

void CAccStore::Log( LPCTSTR text )
{
	if ( m_ShowDialog )
	{
		ListBox_AddString( m_hList, text );
	}
}

/*
int CAccStore::_GetText( ITextStoreAnchor * pDoc, WCHAR * pText, DWORD cchText )
{
    HRESULT hr = pDoc->RequestLock( DCLT_READ );
    if( hr != S_OK || dcr != DC_OK )
    {
        Log( TEXT("RequestLock failed") );
        return 0;
    }

    IAnchor * paStart = NULL;
    hr = pDoc->GetStart( & paStart, & dcr );
    if( hr != S_OK || paStart == NULL )
    {
        pDoc->ReleaseLock();
        Log( TEXT("GetStart failed") );
        return 0;
    }

    DWORD cchGot = 0;
    hr = pDoc->GetText( paStart, NULL, pText, cchText, & cchGot, FALSE, & dcr );
    paStart->Release();
    pDoc->ReleaseLock();

    if( hr != S_OK || dcr != S_OK )
    {
        Log( TEXT("GetText failed") );
        return 0;
    }

    return cchGot;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\msaatext.cpp ===
// MSAAText.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for MSAAText.idl by adding the following 
//      files to the Outputs.
//          MSAAText_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSAATextps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSAAText.h"
#include "dlldatax.h"

#include "MSAAStore.h"
#include "MSAAAdapter.h"
#include "MSAAClientAdapter.h"
#include "Dict.h"
#include "DocWrap.h"
#include <TextStor.h>
#include <msctfx.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AccStore, CAccStore)
OBJECT_ENTRY(CLSID_AccServerDocMgr, CAccServerDocMgr)
OBJECT_ENTRY(CLSID_AccClientDocMgr, CAccClientDocMgr)
OBJECT_ENTRY(CLSID_AccDictionary, CDict)
OBJECT_ENTRY(CLSID_DocWrap, CDocWrap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSAATEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\msaastore.h ===
// MSAAStore.h : Declaration of the CAccStore

#ifndef __MSAASTORE_H_
#define __MSAASTORE_H_

#include "resource.h"       // main symbols
#include <list>

#if ! defined( _BASETSD_H_ ) || defined( NEED_BASETSD_DEFINES )
// These allow us to compile with the pre-Win64 SDK (eg. using visual studio)
typedef unsigned long UINT_PTR;
typedef DWORD DWORD_PTR;
typedef BOOL BOOL_PTR;
#define PtrToInt  (int)
#else
typedef INT_PTR BOOL_PTR;

#endif



struct DocInfo
{
    DocInfo(IUnknown * pCanonicalUnk, ITextStoreAnchor * pDoc, IClonableWrapper * pClonableWrapper) : 
    		m_pCanonicalUnk(pCanonicalUnk), m_pDoc(pDoc), m_pClonableWrapper(pClonableWrapper)
    { 
		if ( FAILED( m_pDoc->GetWnd( NULL, &m_hWnd ) ) )
			m_hWnd = NULL;
	}

    ~DocInfo()
    {
		if (m_pCanonicalUnk)
			m_pCanonicalUnk->Release();
		if (m_pDoc)
			m_pDoc->Release();
		if (m_pClonableWrapper)
			m_pClonableWrapper->Release();
    }

    struct predCanonicalUnk 
	{
		predCanonicalUnk (const IUnknown *& punk) : m_punk(punk) { }
		bool operator ()(const DocInfo* d) 
		{ 
			return d->m_pCanonicalUnk == m_punk; 
		};
		const IUnknown *& m_punk;
	};

    struct predHWND
	{
		predHWND (const HWND &hwnd ) : m_hWnd(hwnd) { }
		bool operator ()(const DocInfo* d) 
		{ 
			if( m_hWnd == d->m_hWnd )
				return true;
			else
				return false;
		}
		const HWND &m_hWnd;
	};

	IUnknown *          m_pCanonicalUnk;    
	ITextStoreAnchor *  m_pDoc;             
	IClonableWrapper *  m_pClonableWrapper; 
	HWND                m_hWnd;
};

typedef std::list< DocInfo * > DocList;

//  this is my own copy class so I don't have to duplicate the list
template <class T>
class CopyDocs
{
public:
	static HRESULT copy(T** p1, DocInfo** p2)
	{
		*p1 = static_cast<T *>((*p2)->m_pDoc);
		if (*p1)
			(*p1)->AddRef();

		TraceDebug(TEXT("copy"));
		return S_OK;
	}
	static void init(T** ) 
	{ 
		TraceDebug(TEXT("init")); 
	}
	static void destroy(T** p) 
	{
		if (*p) (*p)->Release();  
		TraceDebug(TEXT("destroy"));
	}
};

typedef CComObject< CComEnumOnSTL< IEnumUnknown, &IID_IEnumUnknown, IUnknown *, CopyDocs<IUnknown>, DocList > > EnumDocs;

template <class T>
class CComDllClassFactorySingleton : public CComClassFactorySingleton<T>
{
public :
	void FinalRelease()
	{
	}
};


/////////////////////////////////////////////////////////////////////////////
// CAccStore
class ATL_NO_VTABLE CAccStore : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccStore, &CLSID_AccStore>,
	public IAccStore
{
public:
	CAccStore();
	~CAccStore();

DECLARE_CLASSFACTORY_EX(CComDllClassFactorySingleton<CAccStore>)

DECLARE_REGISTRY_RESOURCEID(IDR_MSAASTORE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccStore)
	COM_INTERFACE_ENTRY(IAccStore)
END_COM_MAP()

// IAccStore
public:

	HRESULT STDMETHODCALLTYPE Register (
		REFIID		riid,
		IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE Unregister (
		IUnknown *	punk
	);


	HRESULT STDMETHODCALLTYPE GetDocuments (
		IEnumUnknown ** enumUnknown
	);

	HRESULT STDMETHODCALLTYPE LookupByHWND (
		HWND		hWnd,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE LookupByPoint (
		POINT		pt,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE OnDocumentFocus (
	    IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE GetFocused (
		REFIID	riid,
		IUnknown **	ppunk
	);

	BOOL_PTR DialogProc ( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    HWND    m_hwndDlg;
    HWND    m_hList;
	DocList m_DocList;
	bool	m_ShowDialog;
    HANDLE  m_hInit;

	IUnknown * m_punkFocused;
    ITfMSAAControl *	m_pCtl;
    
    void        DumpInfo( DocInfo * pInfo );
    void        DumpInfo();
    DocInfo *   _LookupDoc( IUnknown * pCanonicalUnk );
    DocInfo *   _LookupDoc( HWND hWnd );
    DocInfo *   _LookupDoc( POINT pt );
	void		EraseDeadDocuments();
	void		Log( LPCTSTR text );

};

#endif //__MSAASTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSAAText.rc
//
#define IDS_PROJNAME                    100
#define IDR_MSAASTORE                   101
#define IDR_ACCSERVERDOCMGR				102
#define IDR_MSAADICT					103
#define IDR_DOCWRAP						104
#define IDR_ACCCLIENTDOCMGR				105
#define IDD_MAIN                        201
#define IDC_LIST                        201
#define ID_DUMP                         202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__AB799976_2AD7_4B25_9490_75001E06B1C8__INCLUDED_)
#define AFX_STDAFX_H__AB799976_2AD7_4B25_9490_75001E06B1C8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>

#include <assert.h>
#include "debug.h"

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AB799976_2AD7_4B25_9490_75001E06B1C8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\accutil.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  accutil
//
//  IAccessible proxy helper routines
//
// --------------------------------------------------------------------------


HRESULT GetWindowObject( HWND ihwndChild, VARIANT* lpvar );

HRESULT GetNoncObject( HWND hwndFrame, LONG idObject, VARIANT * lpvar );

HRESULT GetParentToNavigate( long, HWND, long, long, VARIANT* );




//
// Validate and initialization macros
//
        
BOOL ValidateNavDir(long lFlags, long idChild);
BOOL ValidateSelFlags(long flags);

#define ValidateFlags(flags, valid)         (!((flags) & ~(valid)))
#define ValidateRange(lValue, lMin, lMax)   (((lValue) > (lMin)) && ((lValue) < (lMax)))

#define InitPv(pv)              *pv = NULL
#define InitPlong(plong)        *plong = 0
#define InitPvar(pvar)           pvar->vt = VT_EMPTY
#define InitAccLocation(px, py, pcx, pcy)   {InitPlong(px); InitPlong(py); InitPlong(pcx); InitPlong(pcy);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\accutil.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  accutil
//
//  IAccessible proxy helper routines
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
//#include "accutil.h" // already in oleacc_p.h


// --------------------------------------------------------------------------
//
//  GetWindowObject
//
//  Gets an immediate child object.
//
// --------------------------------------------------------------------------
HRESULT GetWindowObject(HWND hwndChild, VARIANT * pvar)
{
    HRESULT hr;
    IDispatch * pdispChild;

    pvar->vt = VT_EMPTY;

    pdispChild = NULL;

    hr = AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
        (void **)&pdispChild);

    if (!SUCCEEDED(hr))
        return(hr);
    if (! pdispChild)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispChild;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  GetNoncObject
//
// --------------------------------------------------------------------------
HRESULT GetNoncObject(HWND hwnd, LONG idFrameEl, VARIANT *pvar)
{
    IDispatch * pdispEl;
    HRESULT hr;

    pvar->vt = VT_EMPTY;

    pdispEl = NULL;

    hr = AccessibleObjectFromWindow(hwnd, idFrameEl, IID_IDispatch,
        (void **)&pdispEl);
    if (!SUCCEEDED(hr))
        return(hr);
    if (!pdispEl)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispEl;

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  GetParentToNavigate()
//
//  Gets the parent IAccessible object, and forwards the navigation request
//  to it using the child's ID.
//
// --------------------------------------------------------------------------
HRESULT GetParentToNavigate(long idChild, HWND hwnd, long idParent, long dwNav,
    VARIANT* pvarEnd)
{
    HRESULT hr;
    IAccessible* poleacc;
    VARIANT varStart;

    //
    // Get our parent
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(hwnd, idParent, IID_IAccessible,
        (void**)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    //
    // Ask it to navigate
    //
    VariantInit(&varStart);
    varStart.vt = VT_I4;
    varStart.lVal = idChild;

    hr = poleacc->accNavigate(dwNav, varStart, pvarEnd);

    //
    // Release our parent
    //
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  ValidateNavDir
//
//  Validates navigation flags.
//
// --------------------------------------------------------------------------
BOOL ValidateNavDir(long navDir, LONG idChild)
{
	
#ifdef MAX_DEBUG
    DBPRINTF (TEXT("Navigate "));
	switch (navDir)
	{
        case NAVDIR_RIGHT:
            DBPRINTF(TEXT("Right"));
			break;
        case NAVDIR_NEXT:
            DBPRINTF (TEXT("Next"));
			break;
        case NAVDIR_LEFT:
            DBPRINTF (TEXT("Left"));
			break;
        case NAVDIR_PREVIOUS:
            DBPRINTF (TEXT("Previous"));
			break;
        case NAVDIR_UP:
            DBPRINTF (TEXT("Up"));
			break;
        case NAVDIR_DOWN:
            DBPRINTF (TEXT("Down"));
			break;
		case NAVDIR_FIRSTCHILD:
            DBPRINTF (TEXT("First Child"));
			break;
		case NAVDIR_LASTCHILD:
            DBPRINTF (TEXT("Last Child"));
			break;
		default:
            DBPRINTF (TEXT("ERROR"));
	}
    if (idChild <= OBJID_WINDOW)
    {
    TCHAR szChild[50];

        switch (idChild)
        {
            case OBJID_WINDOW:
                lstrcpy (szChild,TEXT("SELF"));
                break;
            case OBJID_SYSMENU:
                lstrcpy (szChild,TEXT("SYS MENU"));
                break;
            case OBJID_TITLEBAR:
                lstrcpy (szChild,TEXT("TITLE BAR"));
                break;
            case OBJID_MENU:
                lstrcpy (szChild,TEXT("MENU"));
                break;
            case OBJID_CLIENT:
                lstrcpy (szChild,TEXT("CLIENT"));
                break;
            case OBJID_VSCROLL:
                lstrcpy (szChild,TEXT("V SCROLL"));
                break;
            case OBJID_HSCROLL:
                lstrcpy (szChild,TEXT("H SCROLL"));
                break;
            case OBJID_SIZEGRIP:
                lstrcpy (szChild,TEXT("SIZE GRIP"));
                break;
            default:
                wsprintf (szChild,TEXT("UNKNOWN 0x%lX"),idChild);
                break;
        }
        DBPRINTF(TEXT(" from child %s\r\n"),szChild);
    }
    else
        DBPRINTF(TEXT(" from child %ld\r\n"),idChild);
#endif

    if ((navDir <= NAVDIR_MIN) || (navDir >= NAVDIR_MAX))
        return(FALSE);

    switch (navDir)
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            return(idChild == 0);
    }

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  ValidateSelFlags
//
//  Validates selection flags.
// this makes sure the only bits set are in the valid range and that you don't
// have any invalid combinations.
// Invalid combinations are
// ADDSELECTION and REMOVESELECTION
// ADDSELECTION and TAKESELECTION
// REMOVESELECTION and TAKESELECTION
// EXTENDSELECTION and TAKESELECTION
//
// --------------------------------------------------------------------------
BOOL ValidateSelFlags(long flags)
{
    if (!ValidateFlags((flags), SELFLAG_VALID))
        return (FALSE);

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_REMOVESELECTION))
        return FALSE;

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_REMOVESELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_EXTENDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\tsattrs.h ===
/*
 *
 *  Copyright (C) Microsoft Corporation, 1999-2000
 *
 *  File: tsattrs.h
 *
 *  List of ITextStore standard attributes.
 *
 */
#ifndef _TSATTRS_H_
#define _TSATTRS_H_




DEFINE_GUID(TSATTRID_OTHERS,                            0xb3c32af9,0x57d0,0x46a9,0xbc,0xa8,0xda,0xc2,0x38,0xa1,0x30,0x57);

DEFINE_GUID(TSATTRID_Font,                              0x573ea825,0x749b,0x4f8a,0x9c,0xfd,0x21,0xc3,0x60,0x5c,0xa8,0x28);
DEFINE_GUID(TSATTRID_Font_FaceName,                     0xb536aeb6,0x053b,0x4eb8,0xb6,0x5a,0x50,0xda,0x1e,0x81,0xe7,0x2e);
DEFINE_GUID(TSATTRID_Font_SizePts,                      0xc8493302,0xa5e9,0x456d,0xaf,0x04,0x80,0x05,0xe4,0x13,0x0f,0x03);
DEFINE_GUID(TSATTRID_Font_Style,                        0x68b2a77f,0x6b0e,0x4f28,0x81,0x77,0x57,0x1c,0x2f,0x3a,0x42,0xb1);
DEFINE_GUID(TSATTRID_Font_Style_Bold,                   0x48813a43,0x8a20,0x4940,0x8e,0x58,0x97,0x82,0x3f,0x7b,0x26,0x8a);
DEFINE_GUID(TSATTRID_Font_Style_Italic,                 0x8740682a,0xa765,0x48e1,0xac,0xfc,0xd2,0x22,0x22,0xb2,0xf8,0x10);
DEFINE_GUID(TSATTRID_Font_Style_SmallCaps,              0xfacb6bc6,0x9100,0x4cc6,0xb9,0x69,0x11,0xee,0xa4,0x5a,0x86,0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Capitalize,				0x7d85a3ba, 0xb4fd, 0x43b3, 0xbe, 0xfc, 0x6b, 0x98, 0x5c, 0x84, 0x31, 0x41);
DEFINE_GUID(TSATTRID_Font_Style_Uppercase,				0x33a300e8, 0xe340, 0x4937, 0xb6, 0x97, 0x8f, 0x23, 0x40, 0x45, 0xcd, 0x9a);
DEFINE_GUID(TSATTRID_Font_Style_Lowercase,				0x76d8ccb5, 0xca7b, 0x4498, 0x8e, 0xe9, 0xd5, 0xc4, 0xf6, 0xf7, 0x4c, 0x60);
DEFINE_GUID(TSATTRID_Font_Style_Animation,				0xdcf73d22, 0xe029, 0x47b7, 0xbb, 0x36, 0xf2, 0x63, 0xa3, 0xd0, 0x04, 0xcc);
DEFINE_GUID(TSATTRID_Font_Style_Animation_LasVegasLights,0xf40423d5, 0xf87, 0x4f8f, 0xba, 0xda, 0xe6, 0xd6, 0xc, 0x25, 0xe1, 0x52);
DEFINE_GUID(TSATTRID_Font_Style_Animation_BlinkingBackground,0x86e5b104, 0x0104, 0x4b10, 0xb5, 0x85, 0x00, 0xf2, 0x52, 0x75, 0x22, 0xb5);
DEFINE_GUID(TSATTRID_Font_Style_Animation_SparkleText,	0x533aad20, 0x962c, 0x4e9f, 0x8c, 0x09, 0xb4, 0x2e, 0xa4, 0x74, 0x97, 0x11);
DEFINE_GUID(TSATTRID_Font_Style_Animation_MarchingBlackAnts, 0x7644e067, 0xf186, 0x4902, 0xbf, 0xc6, 0xec, 0x81, 0x5a, 0xa2, 0x0e, 0x9d);
DEFINE_GUID(TSATTRID_Font_Style_Animation_MarchingRedAnts, 0x78368dad, 0x50fb, 0x4c6f, 0x84, 0x0b, 0xd4, 0x86, 0xbb, 0x6c, 0xf7, 0x81);
DEFINE_GUID(TSATTRID_Font_Style_Animation_Shimmer,		0x2ce31b58, 0x5293, 0x4c36, 0x88, 0x09, 0xbf, 0x8b, 0xb5, 0x1a, 0x27, 0xb3);
DEFINE_GUID(TSATTRID_Font_Style_Animation_WipeDown,		0x5872e874, 0x367b, 0x4803, 0xb1, 0x60, 0xc9, 0x0f, 0xf6, 0x25, 0x69, 0xd0);
DEFINE_GUID(TSATTRID_Font_Style_Animation_WipeRight,	0xb855cbe3, 0x3d2c, 0x4600, 0xb1, 0xe9, 0xe1, 0xc9, 0xce, 0x02, 0xf8, 0x42);
DEFINE_GUID(TSATTRID_Font_Style_Emboss,					0xbd8ed742, 0x349e, 0x4e37, 0x82, 0xfb, 0x43, 0x79, 0x79, 0xcb, 0x53, 0xa7);
DEFINE_GUID(TSATTRID_Font_Style_Engrave,				0x9c3371de, 0x8332, 0x4897, 0xbe, 0x5d, 0x89, 0x23, 0x32, 0x23, 0x17, 0x9a);
DEFINE_GUID(TSATTRID_Font_Style_Hidden,					0xb1e28770, 0x881c, 0x475f, 0x86, 0x3f, 0x88, 0x7a, 0x64, 0x7b, 0x10, 0x90);
DEFINE_GUID(TSATTRID_Font_Style_Kerning,				0xcc26e1b4, 0x2f9a, 0x47c8, 0x8b, 0xff, 0xbf, 0x1e, 0xb7, 0xcc, 0xe0, 0xdd);
DEFINE_GUID(TSATTRID_Font_Style_Outlined,				0x10e6db31, 0xdb0d, 0x4ac6, 0xa7, 0xf5, 0x9c, 0x9c, 0xff, 0x6f, 0x2a, 0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Position,				0x15cd26ab, 0xf2fb, 0x4062, 0xb5, 0xa6, 0x9a, 0x49, 0xe1, 0xa5, 0xcc, 0x0b);
DEFINE_GUID(TSATTRID_Font_Style_Protected,				0x1c557cb2, 0x14cf, 0x4554, 0xa5, 0x74, 0xec, 0xb2, 0xf7, 0xe7, 0xef, 0xd4);
DEFINE_GUID(TSATTRID_Font_Style_Shadow,					0x5f686d2f, 0xc6cd, 0x4c56, 0x8a, 0x1a, 0x99, 0x4a, 0x4b, 0x97, 0x66, 0xbe);
DEFINE_GUID(TSATTRID_Font_Style_Spacing,				0x98c1200d, 0x8f06, 0x409a, 0x8e, 0x49, 0x6a, 0x55, 0x4b, 0xf7, 0xc1, 0x53);
DEFINE_GUID(TSATTRID_Font_Style_Weight,					0x12f3189c, 0x8bb0, 0x461b, 0xb1, 0xfa, 0xea, 0xf9, 0x07, 0x04, 0x7f, 0xe0);
DEFINE_GUID(TSATTRID_Font_Style_Height,					0x7e937477, 0x12e6, 0x458b, 0x92, 0x6a, 0x1f, 0xa4, 0x4e, 0xe8, 0xf3, 0x91);
DEFINE_GUID(TSATTRID_Font_Style_Underline,              0xc3c9c9f3,0x7902,0x444b,0x9a,0x7b,0x48,0xe7,0x0f,0x4b,0x50,0xf7);
DEFINE_GUID(TSATTRID_Font_Style_Underline_Single,       0x1b6720e5,0x0f73,0x4951,0xa6,0xb3,0x6f,0x19,0xe4,0x3c,0x94,0x61);
DEFINE_GUID(TSATTRID_Font_Style_Underline_Double,       0x74d24aa6, 0x1db3, 0x4c69, 0xa1, 0x76, 0x31, 0x12, 0x0e, 0x75, 0x86, 0xd5);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough,          0x0c562193,0x2d08,0x4668,0x96,0x01,0xce,0xd4,0x13,0x09,0xd7,0xaf);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough_Single,   0x75d736b6,0x3c8f,0x4b97,0xab,0x78,0x18,0x77,0xcb,0x99,0x0d,0x31);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough_Double,   0x62489b31, 0xa3e7, 0x4f94, 0xac, 0x43, 0xeb, 0xaf, 0x8f, 0xcc, 0x7a, 0x9f);
DEFINE_GUID(TSATTRID_Font_Style_Overline,               0xe3989f4a,0x992b,0x4301,0x8c,0xe1,0xa5,0xb7,0xc6,0xd1,0xf3,0xc8);
DEFINE_GUID(TSATTRID_Font_Style_Overline_Single,        0x8440d94c,0x51ce,0x47b2,0x8d,0x4c,0x15,0x75,0x1e,0x5f,0x72,0x1b);
DEFINE_GUID(TSATTRID_Font_Style_Overline_Double,        0xdc46063a, 0xe115, 0x46e3, 0xbc, 0xd8, 0xca, 0x67, 0x72, 0xaa, 0x95, 0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Blink,         		    0xbfb2c036, 0x7acf, 0x4532, 0xb7, 0x20, 0xb4, 0x16, 0xdd, 0x77, 0x65, 0xa8);
DEFINE_GUID(TSATTRID_Font_Style_Subscript,              0x5774fb84,0x389b,0x43bc,0xa7,0x4b,0x15,0x68,0x34,0x7c,0xf0,0xf4);
DEFINE_GUID(TSATTRID_Font_Style_Superscript,            0x2ea4993c,0x563c,0x49aa,0x93,0x72,0x0b,0xef,0x09,0xa9,0x25,0x5b);
DEFINE_GUID(TSATTRID_Font_Style_Color,                  0x857a7a37,0xb8af,0x4e9a,0x81,0xb4,0xac,0xf7,0x00,0xc8,0x41,0x1b);
DEFINE_GUID(TSATTRID_Font_Style_BackgroundColor,		0xb50eaa4e, 0x3091, 0x4468, 0x81, 0xdb, 0xd7, 0x9e, 0xa1, 0x90, 0xc7, 0xc7);

DEFINE_GUID(TSATTRID_Text,              				0x7edb8e68, 0x81f9, 0x449d, 0xa1, 0x5a, 0x87, 0xa8, 0x38, 0x8f, 0xaa, 0xc0);
DEFINE_GUID(TSATTRID_Text_VerticalWriting,              0x6bba8195,0x046f,0x4ea9,0xb3,0x11,0x97,0xfd,0x66,0xc4,0x27,0x4b);
DEFINE_GUID(TSATTRID_Text_RightToLeft,                  0xca666e71,0x1b08,0x453d,0xbf,0xdd,0x28,0xe0,0x8c,0x8a,0xaf,0x7a);
DEFINE_GUID(TSATTRID_Text_Orientation,                  0x6bab707f,0x8785,0x4c39,0x8b,0x52,0x96,0xf8,0x78,0x30,0x3f,0xfb);
DEFINE_GUID(TSATTRID_Text_Language,                     0xd8c04ef1,0x5753,0x4c25,0x88,0x87,0x85,0x44,0x3f,0xe5,0xf8,0x19);
DEFINE_GUID(TSATTRID_Text_ReadOnly,                     0x85836617,0xde32,0x4afd,0xa5,0x0f,0xa2,0xdb,0x11,0x0e,0x6e,0x4d);
DEFINE_GUID(TSATTRID_Text_EmbeddedObject,               0x7edb8e68, 0x81f9, 0x449d, 0xa1, 0x5a, 0x87, 0xa8, 0x38, 0x8f, 0xaa, 0xc0);
DEFINE_GUID(TSATTRID_Text_Alignment,               		0x139941e6, 0x1767, 0x456d, 0x93, 0x8e, 0x35, 0xba, 0x56, 0x8b, 0x5c, 0xd4);
DEFINE_GUID(TSATTRID_Text_Alignment_Left,          		0x16ae95d3, 0x6361, 0x43a2, 0x84, 0x95, 0xd0, 0x0f, 0x39, 0x7f, 0x16, 0x93);
DEFINE_GUID(TSATTRID_Text_Alignment_Right,        		0xb36f0f98, 0x1b9e, 0x4360, 0x86, 0x16, 0x03, 0xfb, 0x08, 0xa7, 0x84, 0x56);
DEFINE_GUID(TSATTRID_Text_Alignment_Center,        		0xa4a95c16, 0x53bf, 0x4d55, 0x8b, 0x87, 0x4b, 0xdd, 0x8d, 0x42, 0x75, 0xfc);
DEFINE_GUID(TSATTRID_Text_Alignment_Justify,       		0xed350740, 0xa0f7, 0x42d3, 0x8e, 0xa8, 0xf8, 0x1b, 0x64, 0x88, 0xfa, 0xf0);
DEFINE_GUID(TSATTRID_Text_Link,               			0x47cd9051, 0x3722, 0x4cd8, 0xb7, 0xc8, 0x4e, 0x17, 0xca, 0x17, 0x59, 0xf5);
DEFINE_GUID(TSATTRID_Text_Hyphenation,               	0xdadf4525, 0x618e, 0x49eb, 0xb1, 0xa8, 0x3b, 0x68, 0xbd, 0x76, 0x48, 0xe3);
DEFINE_GUID(TSATTRID_Text_Para,		               		0x5edc5822, 0x99dc, 0x4dd6, 0xae, 0xc3, 0xb6, 0x2b, 0xaa, 0x5b, 0x2e, 0x7c);
DEFINE_GUID(TSATTRID_Text_Para_FirstLineIndent,         0x07c97a13, 0x7472, 0x4dd8, 0x90, 0xa9, 0x91, 0xe3, 0xd7, 0xe4, 0xf2, 0x9c);
DEFINE_GUID(TSATTRID_Text_Para_LeftIndent,              0xfb2848e9, 0x7471, 0x41c9, 0xb6, 0xb3, 0x8a, 0x14, 0x50, 0xe0, 0x18, 0x97);
DEFINE_GUID(TSATTRID_Text_Para_RightIndent,             0x2c7f26f9, 0xa5e2, 0x48da, 0xb9, 0x8a, 0x52, 0x0c, 0xb1, 0x65, 0x13, 0xbf);
DEFINE_GUID(TSATTRID_Text_Para_SpaceAfter,              0x7b0a3f55, 0x22dc, 0x425f, 0xa4, 0x11, 0x93, 0xda, 0x1d, 0x8f, 0x9b, 0xaa);
DEFINE_GUID(TSATTRID_Text_Para_SpaceBefore,             0x8df98589, 0x194a, 0x4601, 0xb2, 0x51, 0x98, 0x65, 0xa3, 0xe9, 0x06, 0xdd);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing,             0x699b380d, 0x7f8c, 0x46d6, 0xa7, 0x3b, 0xdf, 0xe3, 0xd1, 0x53, 0x8d, 0xf3);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Single,   	0xed350740, 0xa0f7, 0x42d3, 0x8e, 0xa8, 0xf8, 0x1b, 0x64, 0x88, 0xfa, 0xf0);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_OnePtFive,	0x0428a021, 0x0397, 0x4b57, 0x9a, 0x17, 0x07, 0x95, 0x99, 0x4c, 0xd3, 0xc5);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Double,  	0x82fb1805, 0xa6c4, 0x4231, 0xac, 0x12, 0x62, 0x60, 0xaf, 0x2a, 0xba, 0x28);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_AtLeast, 	0xadfedf31, 0x2d44, 0x4434, 0xa5, 0xff, 0x7f, 0x4c, 0x49, 0x90, 0xa9, 0x05);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Exactly, 	0x3d45ad40, 0x23de, 0x48d7, 0xa6, 0xb3, 0x76, 0x54, 0x20, 0xc6, 0x20, 0xcc);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Multiple, 	0x910f1e3c, 0xd6d0, 0x4f65, 0x8a, 0x3c, 0x42, 0xb4, 0xb3, 0x18, 0x68, 0xc5);

DEFINE_GUID(TSATTRID_List,                              0x436d673b, 0x26f1, 0x4aee, 0x9e, 0x65, 0x8f, 0x83, 0xa4, 0xed, 0x48, 0x84);
DEFINE_GUID(TSATTRID_List_LevelIndel,            		0x7f7cc899, 0x311f, 0x487b, 0xad, 0x5d, 0xe2, 0xa4, 0x59, 0xe1, 0x2d, 0x42);
DEFINE_GUID(TSATTRID_List_Type,             			0xae3e665e, 0x4bce, 0x49e3, 0xa0, 0xfe, 0x2d, 0xb4, 0x7d, 0x3a, 0x17, 0xae);
DEFINE_GUID(TSATTRID_List_Type_Bullet,        			0xbccd77c5, 0x4c4d, 0x4ce2, 0xb1, 0x02, 0x55, 0x9f, 0x3b, 0x2b, 0xfc, 0xea);
DEFINE_GUID(TSATTRID_List_Type_Arabic,        			0x1338c5d6, 0x98a3, 0x4fa3, 0x9b, 0xd1, 0x7a, 0x60, 0xee, 0xf8, 0xe9, 0xe0);
DEFINE_GUID(TSATTRID_List_Type_LowerLetter,    			0x96372285, 0xf3cf, 0x491e, 0xa9, 0x25, 0x38, 0x32, 0x34, 0x7f, 0xd2, 0x37);
DEFINE_GUID(TSATTRID_List_Type_UpperLetter,             0x7987b7cd, 0xce52, 0x428b, 0x9b, 0x95, 0xa3, 0x57, 0xf6, 0xf1, 0x0c, 0x45);
DEFINE_GUID(TSATTRID_List_Type_LowerRoman,             	0x90466262, 0x3980, 0x4b8e, 0x93, 0x68, 0x91, 0x8b, 0xd1, 0x21, 0x8a, 0x41);
DEFINE_GUID(TSATTRID_List_Type_UpperRoman,          	0x0f6ab552, 0x4a80, 0x467f, 0xb2, 0xf1, 0x12, 0x7e, 0x2a, 0xa3, 0xba, 0x9e);

DEFINE_GUID(TSATTRID_App,                               0xa80f77df,0x4237,0x40e5,0x84,0x9c,0xb5,0xfa,0x51,0xc1,0x3a,0xc7);
DEFINE_GUID(TSATTRID_App_IncorrectSpelling,             0xf42de43c,0xef12,0x430d,0x94,0x4c,0x9a,0x08,0x97,0x0a,0x25,0xd2);
DEFINE_GUID(TSATTRID_App_IncorrectGrammar,              0xbd54e398,0xad03,0x4b74,0xb6,0xb3,0x5e,0xdb,0x19,0x99,0x63,0x88);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\msaatext\versioninfo.h ===
#include <vector>


class ATL_NO_VTABLE CVersionInfo : public IVersionInfo
{

public:

	class Info
	{
		Info () : 
			m_Implid(GUID_NULL), 
			m_MajorVer(0), 
			m_MinorVer(0), 
			m_cComponents(0), 
			m_ComponentDescription(NULL), 
			m_InstanceDescription(NULL),
			m_punk(NULL) { }
			
		Info (GUID Implid, DWORD MajorVer, DWORD MinorVer, LPCWSTR ComponentDescription, LPCWSTR InstanceDescription, IUnknown * punk) :
				m_Implid(Implid), 
				m_MajorVer(MajorVer), 
				m_MinorVer(MinorVer), 
				m_cComponents(0), 
				m_punk(punk)
		{
			m_ComponentDescription = SysAllocString( ComponentDescription ); 
			m_InstanceDescription = SysAllocString( InstanceDescription ); 
		}

		~Info()
		{
			SysFreeString( m_ComponentDescription );
			SysFreeString( m_InstanceDescription );
		}

	private:

		friend CVersionInfo;
		GUID m_Implid;
		DWORD m_MajorVer;
		DWORD m_MinorVer;
		BSTR m_ComponentDescription;
		BSTR m_InstanceDescription;
		ULONG m_cComponents;
		IUnknown * m_punk;
		
	};

public:
	CVersionInfo() { };
	~CVersionInfo()
	{ 
		for ( int i = 0; i < m_VersionInfos.size(); i++ )
		{
			delete m_VersionInfos[i];
		}
	};

	void Add(GUID Implid, DWORD MajorVer, DWORD MinorVer, LPCWSTR ComponentDescription, LPCWSTR InstanceDescription, IUnknown * punk)
	{
		Info * pInfo = new Info( Implid, MajorVer, MinorVer, ComponentDescription, InstanceDescription, punk );
		BuildVersionInfos( *pInfo );
		m_VersionInfos[0]->m_cComponents = m_VersionInfos.size() - 1;
	}
	
	STDMETHOD(GetSubcomponentCount)( ULONG ulSub, ULONG *ulCount )
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;

		if (m_VersionInfos.empty())
			*ulCount = 0;
		else
			*ulCount = m_VersionInfos[ulSub]->m_cComponents;

	    return S_OK;
	}

	STDMETHOD(GetImplementationID)( ULONG ulSub, GUID * implid )
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;

		*implid = m_VersionInfos[ulSub]->m_Implid;
	    return S_OK;
	}

	STDMETHOD(GetBuildVersion)( ULONG ulSub, DWORD * pdwMajor, DWORD * pdwMinor)
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;

		*pdwMajor = m_VersionInfos[ulSub]->m_MajorVer;
		*pdwMinor = m_VersionInfos[ulSub]->m_MinorVer;
	    return S_OK;
	}

	// Expect string of the form "Company suite component version"
	// for human consumption only - not expected to be parsed.
	STDMETHOD(GetComponentDescription)( ULONG ulSub, BSTR * pImplStr )
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;
			
		*pImplStr = SysAllocString( m_VersionInfos[ulSub]->m_ComponentDescription );
	    return S_OK;
	}

	// Implementation can put any useful string here. (eg. internal object state)
	STDMETHOD(GetInstanceDescription)( ULONG ulSub, BSTR * pImplStr)
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;
			
		*pImplStr = SysAllocString( m_VersionInfos[ulSub]->m_InstanceDescription );
	    return S_OK;
	}

private:

	void BuildVersionInfos( Info& info )
	{
		IUnknown * punk = NULL;
		IVersionInfo * pIVer = NULL;
		HRESULT hr;

		m_VersionInfos.push_back(&info);
		
		if (!info.m_punk)
			return;
			
		hr = info.m_punk->QueryInterface( IID_IVersionInfo, (void **)&pIVer );
		if (hr != S_OK || pIVer == NULL)
			return;

		ULONG cCount = 0;
		pIVer->GetSubcomponentCount( 0, &cCount );
		if ( cCount )
		{
			info.m_cComponents = cCount;
			for ( int i = 1; i <= cCount; i++ )
			{
				
				Info * pInfo = new Info;
				
				pIVer->GetImplementationID( i, &pInfo->m_Implid );
				pIVer->GetBuildVersion( i, &pInfo->m_MajorVer, &pInfo->m_MinorVer );
				pIVer->GetComponentDescription( i, &pInfo->m_ComponentDescription );
				pIVer->GetInstanceDescription( i,&pInfo->m_InstanceDescription );
				BuildVersionInfos( *pInfo );
			}
		}
	}

private:
	std::vector < Info *> m_VersionInfos;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\alttab.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ALTTAB.H
//
//  Switch window handler
//
// --------------------------------------------------------------------------


class CAltTab : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT);

        CAltTab(HWND, long);

    protected:
        int     m_cColumns;
        int     m_cRows;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\animated.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ANIMATED.CPP
//
//  Wrapper for COMCTL32's animation control
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "animated.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOPROGRESS
#include <commctrl.h>



// --------------------------------------------------------------------------
//
//  CreateAnimatedClient()
//
// --------------------------------------------------------------------------
HRESULT CreateAnimatedClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvAnimation)
{
    CAnimation* panimated;
    HRESULT     hr;

    InitPv(ppvAnimation);

    panimated = new CAnimation(hwnd, idChildCur);
    if (!panimated)
        return(E_OUTOFMEMORY);

    hr = panimated->QueryInterface(riid, ppvAnimation);
    if (!SUCCEEDED(hr))
        delete panimated;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAnimation::CAnimation()
//
// --------------------------------------------------------------------------
CAnimation::CAnimation(HWND hwnd, long idCurChild)
    : CClient( CLASS_SwitchClient )
{
    Initialize(hwnd, idCurChild);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CAnimation::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAnimation::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_ANIMATION;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAnimation::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAnimation::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    HRESULT hr;

    // Get the client's state and add on STATE_SYSTEM_ANIMATED
    // Remove STATE_SYSTEM_FOCUSABLE
    hr = CClient::get_accState(varChild, pvarState);
    if (!SUCCEEDED(hr))
        return(hr);

    Assert(pvarState->vt == VT_I4);
    pvarState->lVal &= ~STATE_SYSTEM_FOCUSABLE;
    // BOGUS! no way to tell if it is actually animated or not,
    // so we just say it is always. 
    pvarState->lVal |= STATE_SYSTEM_ANIMATED;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\alttab.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ALTTAB.CPP
//
//  Switch window handler
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "alttab.h"



// --------------------------------------------------------------------------
//
//  CreateSwitchClient()
//
// --------------------------------------------------------------------------
HRESULT CreateSwitchClient(HWND hwnd, long idChild, REFIID riid, void** ppvSwitch)
{
    CAltTab* palttab;
    HRESULT hr;

    InitPv(ppvSwitch);

    palttab = new CAltTab(hwnd, idChild);
    if (!palttab)
        return(E_OUTOFMEMORY);

    hr = palttab->QueryInterface(riid, ppvSwitch);
    if (!SUCCEEDED(hr))
        delete palttab;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAltTab::CAltTab()
//
//  NOTE:  We initialize with the # of items at the start, not every time
//  someone makes a call.  People should never hang on to a pointer to one
//  of these babies.  On NT, the switch window is created and destroyed
//  repeatedly.
//
// --------------------------------------------------------------------------
CAltTab::CAltTab(HWND hwnd, long idChildCur)
    : CClient( CLASS_SwitchClient )
{
    ALTTABINFO  ati;

    Initialize(hwnd, idChildCur);

    if (MyGetAltTabInfo(hwnd, -1, &ati, NULL, 0))
    {
        m_cChildren = ati.cItems;
        m_cColumns = ati.cColumns;
        m_cRows = ati.cRows;
    }
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(HrCreateString(STR_ALTTAB_NAME, pszName));
    else
    {
        ALTTABINFO  ati;
        TCHAR   szItem[80];

        if (!MyGetAltTabInfo(m_hwnd, varChild.lVal-1, &ati, szItem,
            ARRAYSIZE(szItem)))
            return(S_FALSE);

        *pszName = TCharSysAllocString(szItem);
        if (! *pszName)
            return(E_OUTOFMEMORY);
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    ALTTABINFO  ati;

    InitPvar(pvarState);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    // Get the item, is this the one with the focus?
    pvarState->vt = VT_I4;

    varChild.lVal--;

    if (! MyGetAltTabInfo(m_hwnd, varChild.lVal, &ati, NULL, 0))
        pvarState->lVal = STATE_SYSTEM_INVISIBLE;
    else
    {
        pvarState->lVal = 0;

        // If this item is off the end, pretend that it's 'clipped'.
        if( varChild.lVal >= ati.cColumns * ati.cRows )
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;


        if (((varChild.lVal % ati.cColumns) == ati.iColFocus) &&
            ((varChild.lVal / ati.cColumns) == ati.iRowFocus))
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accFocus(VARIANT * pvarFocus)
{
    ALTTABINFO  ati;

    InitPvar(pvarFocus);

    //
    // Get the alt-tab info
    //
    if (!MyGetAltTabInfo(m_hwnd, -1, &ati, NULL, 0))
        return(S_FALSE);

    pvarFocus->vt = VT_I4;
    pvarFocus->lVal = (ati.iRowFocus * m_cColumns) + ati.iColFocus + 1;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accDefaultAction()
//
//  The default action of a tasklist item is to switch to its window
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDefA));

    return(HrCreateString(STR_TAB_SWITCH, pszDefA));
}



// --------------------------------------------------------------------------
//
//  CAltTab::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accSelect(long lSelFlags, VARIANT varChild)
{
    if (! ValidateChild(&varChild) ||
        ! ValidateSelFlags(lSelFlags))
        return(E_INVALIDARG);

    //
    // Bogus!  Manually change the focus in the alt-tab window.
    //
    return(E_NOTIMPL);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    ALTTABINFO  ati;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    --varChild.lVal;

    //
    // Figure out where the item is.
    //
    if (! MyGetAltTabInfo(m_hwnd, varChild.lVal, &ati, NULL, 0))
        return(S_FALSE);

    ClientToScreen(m_hwnd, &ati.ptStart);

    *pxLeft = ati.ptStart.x + ((varChild.lVal % m_cColumns)*ati.cxItem);
    *pyTop = ati.ptStart.y + ((varChild.lVal / m_cColumns)*ati.cyItem);

    *pcxWidth = ati.cxItem;
    *pcyHeight = ati.cyItem;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    int         iItem;
    int         delta;

    InitPvar(pvarEnd);

    //
    // Validate
    //
    if (!ValidateChild(&varStart)    ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    iItem = 0;

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        iItem = 1;
    else if (dwNavDir == NAVDIR_LASTCHILD)
        iItem = m_cChildren;
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));
    else
    {
        switch (dwNavDir)
        {
            case NAVDIR_NEXT:
                iItem = varStart.lVal+1;
                if (iItem > m_cChildren)
                    iItem = 0;
                break;

            case NAVDIR_PREVIOUS:
                iItem = varStart.lVal - 1;
                break;

            case NAVDIR_LEFT:
                delta = -1;
                goto MultiColumnMove;

            case NAVDIR_RIGHT:
                delta = 1;
                goto MultiColumnMove;

            case NAVDIR_UP:
                delta = -m_cColumns;
                goto MultiColumnMove;

            case NAVDIR_DOWN:
                delta = m_cColumns;

MultiColumnMove:
                iItem = varStart.lVal + delta;
                if ((iItem < 1) || (iItem > m_cChildren))
                    iItem = 0;
                break;
        }
    }

    if (iItem)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = iItem;
    }

    return(iItem ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accHitTest(long x, long y, VARIANT* pvarHit)
{
    ALTTABINFO  ati;
    RECT        rc;
    POINT       pt;
    int         iColHit, iRowHit;

    InitPvar(pvarHit);

    if (!MyGetAltTabInfo(m_hwnd, -1, &ati, NULL, 0))
        return(S_FALSE);

    //
    // Is the point in our client at all?
    //
    MyGetRect(m_hwnd, &rc, FALSE);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    if (!PtInRect(&rc, pt) ||
        (pt.x < ati.ptStart.x)   ||
        (pt.y < ati.ptStart.y))
        return(S_FALSE);

    //
    // Does this lie in an item?
    //
    iColHit = (pt.x - ati.ptStart.x) / ati.cxItem;
    iRowHit = (pt.y - ati.ptStart.y) / ati.cyItem;
    if ((iColHit >= m_cColumns) ||
        (iRowHit >= m_cRows))
        return(S_FALSE);

    //
    // Phew.  Return it.
    //
    pvarHit->vt = VT_I4;
    pvarHit->lVal = (iRowHit * m_cColumns) + iColHit + 1;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accDoDefaultAction(VARIANT varChild)
{
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

    return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\api.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// ==========================================================================
// File: A P I . C P P
// 
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.
// ==========================================================================

// Includes --------------------------------------------------------------
#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "verdefs.h"
#include "Win64Helper.h"
#include "w95trace.h"


#define CCH_ROLESTATEMAX     128

#ifndef WMOBJ_SAMETHREAD
#define WMOBJ_SAMETHREAD  0xFFFFFFFF
#endif

HRESULT CreateRemoteProxy6432(HWND hwnd, long idObject, REFIID riid, void ** ppvObject);

STDAPI
ORIGINAL_AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject);

HRESULT WrapObject( IUnknown * punk, REFIID riid, void ** ppv );

STDAPI
AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject)
{
    HRESULT hr = ORIGINAL_AccessibleObjectFromWindow(hwnd, dwId, riid, ppvObject);
    if( hr == S_OK && ppvObject && *ppvObject )
    {
        // Only wrap object if it supports IAccessible.
        // Some users of AOFW may want something other than an IAccessible -
        // eg some native OM interface - shouldn't wrap those. 
        IUnknown * punk = (IUnknown *) * ppvObject;

        IAccessible * pAcc = NULL;

        hr = punk->QueryInterface( IID_IAccessible, (void **) & pAcc );
        if( hr != S_OK || pAcc == NULL )
        {
            // Not an IAccessible - don't wrap, leave as-is...
            return S_OK;
        }
        pAcc->Release();

        // It's really an IAccessible - wrap the object...

        hr = WrapObject( punk, riid, ppvObject );
        punk->Release();
    }

    return hr;
}



// --------------------------------------------------------------------------
//
//  AccessibleObjectFromWindow()
//
//  This gets an interface pointer from the object specified by dwId inside
//  of the window.
//
//  ALL object creation takes place through this API, even for internally
//  used objects. Client-side wrapping takes place here.
//
// --------------------------------------------------------------------------
STDAPI
ORIGINAL_AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject)
{
DWORD_PTR    ref;
WPARAM      wParam = 0;

    if (IsBadWritePtr(ppvObject,sizeof(void*)))
        return (E_INVALIDARG);

    // clear out-param
    *ppvObject = NULL;
    ref = 0;

    //
    // Window can be NULL (cursor, alert, sound)
    // Window can also be bad (trying to talk to window that generated event and
    // client is getting events out of context, and window is gone)
    //
    if (IsWindow(hwnd))
    {
        if( GetWindowThreadProcessId( hwnd, NULL) == GetCurrentThreadId() )
        {
            wParam = WMOBJ_SAMETHREAD;
        }
        else
        {
            wParam = GetCurrentProcessId();
            // If, by some chance, this process's pid equals the magic 'samethread' value,
            // then fall back on the less efficient '0' technique instead.
            // (see oleacc.doc for more details...)
            if( wParam == WMOBJ_SAMETHREAD )
                wParam = 0;
        }

        SendMessageTimeout(hwnd, WM_GETOBJECT, wParam, dwId,
            SMTO_ABORTIFHUNG, 10000, &ref);

    }


    if (FAILED((HRESULT)ref))
        return (HRESULT)ref;
    else if (ref)
        return ObjectFromLresult(ref, riid, wParam, ppvObject);
    else
    {
        //
        // Is this the ID of an object we understand and a REFIID we can
        // handle?  BOGUS!  For now, we always create the object and QI
        // on it, only to fail if the riid isn't one we know.  
        //

        //-----------------------------------------------------------------
        // [v-jaycl, 5/15/97] Handle custom OBJIDs -- TODO: UNTESTED!!!
        //-----------------------------------------------------------------

//        if (fCreateDefObjs && ((LONG)dwId <= 0))
        if (fCreateDefObjs )
        {
            return CreateStdAccessibleObject(hwnd, dwId, riid, ppvObject);
        }
        
        return(E_FAIL);
    }
}


// --------------------------------------------------------------------------
//
//  GetRoleTextA()
//
//  Loads the string for the specified role.  If the role is bogus, we will
//  get nothing since the role area is at the end of the string table.  We
//  return the number of chars of the string.
//  
//  CWO: 12/3/96, we now return 0 if the string ptr passed in was bogus
//
//  The caller can pass in a NULL buffer, in which case we just return the
//  # of chars so that he can turn around and allocate something the right
//  size.
//
// --------------------------------------------------------------------------
#ifdef UNICODE
STDAPI_(UINT)   GetRoleTextW(DWORD lRole, LPWSTR lpszRole, UINT cchRoleMax)
#else
STDAPI_(UINT)   GetRoleTextA(DWORD lRole, LPSTR lpszRole, UINT cchRoleMax)
#endif
{
    TCHAR    szRoleT[CCH_ROLESTATEMAX];

    // NULL string is valid, use our temporary string and return count
    if (!lpszRole)
    {
        lpszRole = szRoleT;
        cchRoleMax = CCH_ROLESTATEMAX;
    }
    else
    {
        // CWO: Added 12/3/96, Error checking of parameters
        if (IsBadWritePtr(lpszRole,(sizeof(TCHAR) * cchRoleMax)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    
    if( cchRoleMax == 1 )
    {
        // Special case for 1-len string - we expect it to copy nothing, but
        // NUL-terminate (for consistency with other cases) - but LoadString
        // just returns 0 w/o terminating...
        *lpszRole = '\0';
        return 0;
    }
    else
        return LoadString(hinstResDll, STR_ROLEFIRST+lRole, lpszRole, cchRoleMax);
}


// --------------------------------------------------------------------------
//
//  GetStateTextA()
//
//  Loads the string for ONE particular state bit.  We return the number of
//  characters in the string.
//
//  CWO: 12/3/96, we now return 0 if the string ptr passed in was bogus
//  CWO, 12/4/96, Added parameter checking and set last error to 
//                ERROR_INVALID_PARAMETER.
//
//  Like GetRoleTextA(), the caller can pass in a NULL buffer.  We will 
//  simply return the character count necessary in that case.
//
// --------------------------------------------------------------------------
#ifdef UNICODE
STDAPI_(UINT)   GetStateTextW(DWORD lStateBit, LPWSTR lpszState, UINT cchStateMax)
#else
STDAPI_(UINT)   GetStateTextA(DWORD lStateBit, LPSTR lpszState, UINT cchStateMax)
#endif
{
    TCHAR   szStateT[CCH_ROLESTATEMAX];
    int     iStateBit;

    //
    // Figure out what state bit this is.
    //
    iStateBit = 0;
    while (lStateBit > 0)
    {
        lStateBit >>= 1;
        iStateBit++;
    }

    // NULL string is valid, use our temporary string and return count
    if (!lpszState)
    {
        lpszState = szStateT;
        cchStateMax = CCH_ROLESTATEMAX;
    }
    else
    {
        // CWO: Added 12/3/96, Error checking of parameters
        if (IsBadWritePtr(lpszState,(sizeof(TCHAR) * cchStateMax)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    if( cchStateMax == 1 )
    {
        // Special case for 1-len string - we expect it to copy nothing, but
        // NUL-terminate (for consistency with other cases) - but LoadString
        // just returns 0 w/o terminating...
        *lpszState = '\0';
        return 0;
    }
    else
        return LoadString(hinstResDll, STR_STATEFIRST+iStateBit, lpszState, cchStateMax);
}




// --------------------------------------------------------------------------
//
//  [INTERNAL]
//  GetRoleStateTextWCommon()
//
//  Calls GetRoleTextA or GetStateTextA (passed in through pfnGetRoleStateANSI
//  parameter), and converts resulting string to UNICODE.
//
//  Ensures that...
//  (1) return value equals number of chars copied, excluding terminating NUL.
//  (2) if buffer is too small, as much of string as possible will be
//      copied (truncation occurs).
//  (2) terminating NUL added, even when trucation occurs.
//
//  Eg. buffer of size 4 used when getting text for 'default'...
//  Buffer will contain  'def\0' (in unicode),
//  return value of 3, since 3 chars (excl. NUL) copied.
//
//  This ensures comsistency with the 'A' versions of GetXText().
//
//  (Note that MultiByteToWideChar is not a particularly boundary-case-
//  friendly API - if the buffer is too short, it doesn't truncate neatly -
//  it *does not* add a terminating NUL, and returns 0! - so it's effectively
//  all-or-nothing, with no way of getting partial strings, for piecemeal
//  conversion, for example. To get around this, we use MBtoWC to translate
//  into a stack allocated buf of CCH_ROLEMAX, and then copy as necessary
//  from that to the output string, terminating/truncating neatly.)
//
// --------------------------------------------------------------------------

typedef UINT (WINAPI FN_GetRoleOrStateTextT)( DWORD lVal, LPTSTR lpszText, UINT cchTextMax );


#ifdef UNICODE

STDAPI_(UINT) GetRoleStateTextACommon( FN_GetRoleOrStateTextT * pfnGetRoleStateThisCS,
                                       DWORD lVal, 
                                       LPSTR lpszTextOtherCS,
                                       UINT cchTextMax)
#else

STDAPI_(UINT) GetRoleStateTextWCommon( FN_GetRoleOrStateTextT * pfnGetRoleStateThisCS,
                                       DWORD lVal, 
                                       LPWSTR lpszTextOtherCS,
                                       UINT cchTextMax)

#endif
{
    TCHAR szTextThisCS[ CCH_ROLESTATEMAX ];
    if( pfnGetRoleStateThisCS( lVal, szTextThisCS, CCH_ROLESTATEMAX ) == 0 )
        return 0;

    // Note - cchPropLen includes the terminating nul...
#ifdef UNICODE
    CHAR szTextOtherCS[ CCH_ROLESTATEMAX ];
    int cchPropLen = WideCharToMultiByte( CP_ACP, 0, szTextThisCS, -1, szTextOtherCS, CCH_ROLESTATEMAX, NULL, NULL );
#else
    WCHAR szTextOtherCS[ CCH_ROLESTATEMAX ];
    int cchPropLen = MultiByteToWideChar( CP_ACP, 0, szTextThisCS, -1, szTextOtherCS, CCH_ROLESTATEMAX );
#endif

    // unexpected error...
    if( cchPropLen == 0 )
        return 0;

    // Ignore terminating NUL in length...
    cchPropLen--;

    // lpszRole == NULL means just return length...
    if( ! lpszTextOtherCS )
        return cchPropLen; // (number of TCHARS, not bytes)
    else
    {
        // string requested...
#ifdef UNICODE
        if( IsBadWritePtr( lpszTextOtherCS, ( sizeof(CHAR) * cchTextMax ) ) )
#else
        if( IsBadWritePtr( lpszTextOtherCS, ( sizeof(WCHAR) * cchTextMax ) ) )
#endif
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return 0;
        }

        // need space for at least terminating NUL...
        if( cchTextMax <= 0 )
        {
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return 0;
        }

        // Copy as much string as necessary (cchCopyLen excludes NUL)...
        // (-1 to reserve terminating NUL)
        int cchCopyLen = cchTextMax - 1;
        if( cchCopyLen > cchPropLen )
            cchCopyLen = cchPropLen;

#ifdef UNICODE
		// Copy/truncate the ANSI string...
		// TODO - is strncpy sufficient? Does it slice DBCS correctly?
        // +1 to add back space for terminating NUL, which lstrncpyA adds for us
		lstrcpynA( lpszTextOtherCS, szTextOtherCS, cchCopyLen + 1 );
#else
        // Since we're explicitly copying UNICODE, use of memcpy is safe...
        memcpy( lpszTextOtherCS, szTextOtherCS, cchCopyLen * sizeof( WCHAR ) );
        lpszTextOtherCS[ cchCopyLen ] = '\0';
#endif
        return cchCopyLen;
    }
}





// --------------------------------------------------------------------------
//
//  GetRoleTextW()
//
//  Like GetRoleTextA() but returns a UNICODE string.
//
//  Calls GetRoleStateTextWCommon, which just calls GetStateTextA and
//  converts the result to UNICODE.
//
// --------------------------------------------------------------------------
#ifdef UNICODE

STDAPI_(UINT)   GetRoleTextA(DWORD lRole, LPSTR lpszRole, UINT cchRoleMax)
{
    return GetRoleStateTextACommon( GetRoleTextW, lRole, lpszRole, cchRoleMax );
}

#else

STDAPI_(UINT)   GetRoleTextW(DWORD lRole, LPWSTR lpszRole, UINT cchRoleMax)
{
    return GetRoleStateTextWCommon( GetRoleTextA, lRole, lpszRole, cchRoleMax );
}

#endif

// --------------------------------------------------------------------------
//
//  GetStateTextW()
//
//  Like GetStateTextA() but returns a UNICODE string.
//
//  Calls GetRoleStateTextWCommon, which just calls GetStateTextA and
//  converts the result to UNICODE.
//
//
// --------------------------------------------------------------------------
#ifdef UNICODE

STDAPI_(UINT)   GetStateTextA(DWORD lStateBit, LPSTR lpszState, UINT cchStateMax)
{
    return GetRoleStateTextACommon( GetStateTextW, lStateBit, lpszState, cchStateMax );
}

#else

STDAPI_(UINT)   GetStateTextW(DWORD lStateBit, LPWSTR lpszState, UINT cchStateMax)
{
    return GetRoleStateTextWCommon( GetStateTextA, lStateBit, lpszState, cchStateMax );
}

#endif

// --------------------------------------------------------------------------
//
//  CreateStdAccessibleObject()
//
//  See Also: CreateStdAccessibleProxy() in default.cpp
//
//  This function takes an HWND and an OBJID.  If the OBJID is one of the
//  system reserved IDs (OBJID_WINDOW, OBJID_CURSOR, OBJID_MENU, etc.)
//  we create a default object that implements the interface whose IID we
//  ask for. This is usually IAccessible, but might also be IDispatch, IText,
//  IEnumVARIANT...
//
//  This function is used by both the AccessibleObjectFromWindow API
//  and apps that want to do a little of their own thing but let us
//  handle most of the work.
//
// --------------------------------------------------------------------------
STDAPI
CreateStdAccessibleObject(HWND hwnd, LONG idObject, REFIID riid,
    void **ppvObject)
{
    HRESULT hr;
    TCHAR   szClassName[128];
    BOOL    bFound = FALSE;

    if (IsBadWritePtr(ppvObject,sizeof(void *)))
        return (E_INVALIDARG);

    *ppvObject = NULL;

    if (!hwnd && (idObject != OBJID_CURSOR))
        return(E_FAIL);
        
    // We make an exception here for OBJID_SYSMENU and OBJID_MENU because they are bit
    // specific.  All the othe objects are bit agnostic except for OBJID_CLIENT and 
    // OBJID_WINDOW which are handled in FindAndCreateWindowClass.
    if ( idObject == OBJID_SYSMENU || idObject == OBJID_MENU )
    {
		BOOL fIsSameBitness;
		HRESULT hr = SameBitness(hwnd, &fIsSameBitness);
		if ( FAILED(hr) )
			return E_FAIL;	// this should never happen
        
		if (!fIsSameBitness)
			return CreateRemoteProxy6432( hwnd, idObject, riid, ppvObject );

        // If target window is of same bitness, fall through and create proxy locally...
    }
    
    switch(idObject)
    {
        case OBJID_SYSMENU:
            hr = CreateSysMenuBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_MENU:
            // HACK for IE4/Shell windows
            if( GetClassName (hwnd, szClassName,ARRAYSIZE(szClassName))
                && ( (0 == lstrcmp (szClassName,TEXT("IEFrame")))
                  || (0 == lstrcmp (szClassName,TEXT("CabinetWClass"))) ) )
            {
                HWND            hwndWorker;
                HWND            hwndRebar;
                HWND            hwndSysPager;
                HWND            hwndToolbar;
                VARIANT         varChild;
                VARIANT         varState;

                hwndWorker = NULL;
                while (!bFound)
                {
                    hwndWorker = FindWindowEx (hwnd,hwndWorker,TEXT("Worker"),NULL);
                    if (!hwndWorker)
                        break;

                    hwndRebar = FindWindowEx (hwndWorker,NULL,TEXT("RebarWindow32"),NULL);
                    if (!hwndRebar)
                        continue;
            
					hwndSysPager = NULL;
                    while (!bFound)
                    {
                        hwndSysPager = FindWindowEx (hwndRebar,hwndSysPager,TEXT("SysPager"),NULL);
                        if (!hwndSysPager)
                            break;
                        hwndToolbar = FindWindowEx (hwndSysPager,NULL,TEXT("ToolbarWindow32"),NULL);
                        hr = AccessibleObjectFromWindow (hwndToolbar,OBJID_MENU,
                                                         IID_IAccessible, ppvObject);
                        if (SUCCEEDED(hr))
                        {
                            varChild.vt=VT_I4;
                            varChild.lVal = CHILDID_SELF;

                            if (SUCCEEDED (((IAccessible*)*ppvObject)->get_accState(varChild,&varState)))
							{
								if (!(varState.lVal & STATE_SYSTEM_INVISIBLE))
									bFound = TRUE;
							}
                        }
						
						// If we got an IAccessible, but it's not needed here (doesn't
						// satisfy the above visibility test), then release it.
						if (!bFound && *ppvObject != NULL)
							((IAccessible*)*ppvObject)->Release ();
                    }
                }
            } // end if we are talking to an IE4/IE4 Shell window

            if (!bFound)
                hr = CreateMenuBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_CLIENT:
            hr = CreateClientObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_WINDOW:
            hr = CreateWindowObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_HSCROLL:
        case OBJID_VSCROLL:
            hr = CreateScrollBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_SIZEGRIP:
            hr = CreateSizeGripObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_TITLEBAR:
            hr = CreateTitleBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_CARET:
            hr = CreateCaretObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_CURSOR:
            hr = CreateCursorObject(hwnd, idObject, riid, ppvObject);
            break;

        default:
            //-----------------------------------------------------------------
            // [v-jaycl, 5/15/97] Handle custom OBJIDs -- 
            //  Second parameter to FindWindowClass() is irrelevant since 
            //  we're looking for a reg.handler, not an intrinsic window or client
            //-----------------------------------------------------------------

            return FindAndCreateWindowClass( hwnd, TRUE, CLASS_NONE,
                                           idObject, 0, riid, ppvObject );
    }

    return(hr);
}





// --------------------------------------------------------------------------
//
//  CreateStdAccessibleProxyA()
//
//  See Also: CreateStdAccessibleObject()
//
//  Similar to CreateStdAccessibleObject, but this version allows you to
//  give a classname to use to specify the type of proxy you want - 
//  eg. "Button" for a button proxy, and so on.
//
//  This function takes a class name and an OBJID.  If the OBJID is one of the
//  system reserved IDs (OBJID_WINDOW, OBJID_CURSOR, OBJID_MENU, etc.)
//  we create a default object that implements the interface whose IID we
//  ask for. This is usually IAccessible, but might also be IDispatch, IText,
//  IEnumVARIANT...
//
//
// --------------------------------------------------------------------------

#ifdef UNICODE

STDAPI
CreateStdAccessibleProxyW( HWND     hWnd,
                           LPCWSTR  pClassName, // UNICODE, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )

#else

STDAPI
CreateStdAccessibleProxyA( HWND     hWnd,
                           LPCSTR   pClassName, // ANSI, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )

#endif

{
    if( IsBadReadPtr( pClassName, sizeof(TCHAR) )
     || IsBadWritePtr( ppvObject, sizeof(void*) ) )
    {
        return E_INVALIDARG;
    }

    int RegHandlerIndex;
    CLASS_ENUM ceClass;

    // Try and find a native proxy or registered handler for this window/client...
    if( ! LookupWindowClassName( pClassName, FALSE, & ceClass, & RegHandlerIndex ) )
    {
        // Nope - fail!
        ppvObject = NULL;
        return E_FAIL;
    }

    // At this point, ceClass != CLASS_NONE means we've found a class above,
    // ceClass == CLASS_NONE means it's a registered handler class, using index
    // RegHandlerIndex...

    // Now create the object...
    if( ceClass != CLASS_NONE )
    {
        return g_ClassInfo[ ceClass ].lpfnCreate( hWnd, 0, riid, ppvObject );
    }
    else
    {
        return CreateRegisteredHandler( hWnd, idObject, RegHandlerIndex, riid, ppvObject );
    }
}



// --------------------------------------------------------------------------
//
//  CreateStdAccessibleProxyW/A()
//
//  UNICODE/ANSI wrappers for CreateStdAccessibleProxy above
//
// --------------------------------------------------------------------------

#ifdef UNICODE

STDAPI
CreateStdAccessibleProxyA( HWND     hWnd,
                           LPCSTR   pClassName, // ANSI, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )
{
    if( IsBadReadPtr( pClassName, sizeof(CHAR) ) )
        return E_INVALIDARG;

    WCHAR szClassNameW[ 256 ];

    if( ! MultiByteToWideChar( CP_ACP, 0, pClassName, -1, szClassNameW,
								ARRAYSIZE( szClassNameW ) ) )
        return E_FAIL;

    return CreateStdAccessibleProxyW( hWnd, szClassNameW, idObject, riid, ppvObject );
}

#else

STDAPI
CreateStdAccessibleProxyW( HWND     hWnd,
                           LPCWSTR  pClassName, // UNICODE, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )
{
    if( IsBadReadPtr( pClassName, sizeof(WCHAR) ) )
        return E_INVALIDARG;

    CHAR szClassNameA[ 256 ];

    if( ! WideCharToMultiByte( CP_ACP, 0, pClassName, -1, szClassNameA,
                    ARRAYSIZE( szClassNameA ), NULL, NULL ) )
        return E_FAIL;

    return CreateStdAccessibleProxyA( hWnd, szClassNameA, idObject, riid, ppvObject );
}

#endif



// --------------------------------------------------------------------------
//
//  AccessibleObjectFromEvent()
//
//  This takes care of getting the container and checking if the child
//  is an object in its own right.  Standard stuff that everyone would have
//  to do. Basically a wrapper that uses AccessibleObjectFromWindow and
//  then get_accChild().
//
// --------------------------------------------------------------------------
STDAPI AccessibleObjectFromEvent(HWND hwnd, DWORD dwId, DWORD dwChildId,
                                 IAccessible** ppacc, VARIANT* pvarChild)
{
HRESULT hr;
IAccessible* pacc;
IDispatch* pdispChild;
VARIANT varT;

    //CWO, 12/4/96, Added check for valid window handle
    //CWO, 12/6/96, Allow a NULL window handle
    if (IsBadWritePtr(ppacc,sizeof(void*)) || IsBadWritePtr (pvarChild,sizeof(VARIANT)) || (!IsWindow(hwnd) && hwnd != NULL))
        return (E_INVALIDARG);

    InitPv(ppacc);
    VariantInit(pvarChild);

    //
    // Try to get the object for the container
    //
    pacc = NULL;
    hr = AccessibleObjectFromWindow(hwnd, dwId, IID_IAccessible, (void**)&pacc);
    if (!SUCCEEDED(hr))
        return(hr);
    if (!pacc)
        return(E_FAIL);

    //
    // Now, is the child an object?
    //
    VariantInit(&varT);
    varT.vt = VT_I4;
    varT.lVal = dwChildId;

    pdispChild = NULL;
    hr = pacc->get_accChild(varT, &pdispChild);
    if (SUCCEEDED(hr) && pdispChild)
    {
        //
        // Yes, it is.
        //

        // Release the parent.
        pacc->Release();

        // Convert the child to an IAccessible*
        pacc = NULL;
        hr = pdispChild->QueryInterface(IID_IAccessible, (void**)&pacc);

        // Release the IDispatch* form of the child
        pdispChild->Release();

        // Did it succeed?
        if (!SUCCEEDED(hr))
            return(hr);
        if (!pacc)
            return(E_FAIL);

        // Yes.  Clear out the lVal (0 is 'container' child id)
        varT.lVal = 0;
    }

    //
    // We have something.  Return it.
    //
    *ppacc = pacc;
    VariantCopy(pvarChild, &varT);

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  AccessibleObjectFromPoint()
//
//  Walks down the OLEACC hierarchy to get the object/element that is
//  at the current screen point. Starts with AccessibleObjectFromWindow
//  using WindowFromPoint() and then uses acc_HitTest to get to the
//  innermost object.
//
// --------------------------------------------------------------------------
STDAPI AccessibleObjectFromPoint(POINT ptScreen, IAccessible **ppAcc,
                                 VARIANT * pvarChild)
{
    HRESULT hr;
    IAccessible * pAcc;
    VARIANT varChild;
    HWND    hwndPoint;

    if (IsBadWritePtr(ppAcc,sizeof(void*)) || IsBadWritePtr (pvarChild,sizeof(VARIANT)))
        return (E_INVALIDARG);
        
   
    *ppAcc = NULL;
    pvarChild->vt = VT_EMPTY;

    //
    // Is this a valid screen point?
    //
    hwndPoint = WindowFromPoint(ptScreen);
    if (!hwndPoint)
        return(E_INVALIDARG);
        
    //
    // Get the top level window of this one and work our way down.  We have
    // to do this because applications may implement Acc at an intermediate
    // level above the child window.  Our default implementation will let us
    // get there and mesh.
    //
    hwndPoint = MyGetAncestor(hwndPoint, GA_ROOT);
    if (!hwndPoint)
        return(E_FAIL);

    hr = AccessibleObjectFromWindow(hwndPoint, OBJID_WINDOW, IID_IAccessible,
        (void **)&pAcc);

    //
    // OK, now we are cooking.
    //
    while (SUCCEEDED(hr))
    {
        //
        // Get the child at this point in the container object.
        //
        VariantInit(&varChild);
        hr = pAcc->accHitTest(ptScreen.x, ptScreen.y, &varChild);
        if (!SUCCEEDED(hr))
        {
            // Uh oh, error.  This should never happen--something moved.
            pAcc->Release();
            return(hr);
        }

        //
        // Did we get back a VT_DISPATCH?  If so, there is a child object.
        // Otherwise, we have our thing (container object or child element
        // too small for object).
        //
        if (varChild.vt == VT_DISPATCH)
        {
            pAcc->Release();

            if (! varChild.pdispVal)
                return(E_POINTER);

            pAcc = NULL;
            hr = varChild.pdispVal->QueryInterface(IID_IAccessible,
                (void **)&pAcc);

            varChild.pdispVal->Release();
        }
        else if ((varChild.vt == VT_I4) || (varChild.vt == VT_EMPTY))
        {
            //
            // accHitTest should ALWAYS return an object if the child is
            // an object.  Unlike with accNavigate, where you usually
            // have to pick by-index or by_object only and intermixed means
            // get_accChild is needed.
            //
            *ppAcc = pAcc;
            VariantCopy(pvarChild, &varChild);
            return(S_OK);
        }
        else
        {
            //
            // Failure.  Shouldn't have been returned.
            //
            VariantClear(&varChild);
            pAcc->Release();
            hr = E_INVALIDARG;
        }
    }

    return(hr);
}



// --------------------------------------------------------------------------
//
//  WindowFromAccessibleObject()
//
//  This walks UP the ancestor chain until we find something who responds to
//  IOleWindow().  Then we get the HWND from it.
//
// Returns E_INVALIDARG if object cannot be read or if HWND pointer is invalid
// (CWO, 12/4/96)
// --------------------------------------------------------------------------
STDAPI WindowFromAccessibleObject(IAccessible* pacc, HWND* phwnd)
{
IAccessible* paccT;
IOleWindow* polewnd;
IDispatch* pdispParent;
HRESULT     hr;

    //CWO: 12/4/96, Added check for NULL object
    //CWO: 12/13/96, Removed NULL check, replaced with IsBadReadPtr check (#10342)
    if (phwnd == NULL || IsBadWritePtr(phwnd,sizeof(HWND*)) || pacc == NULL || IsBadReadPtr(pacc, sizeof(void*)))
        return (E_INVALIDARG);

    *phwnd = NULL;
    paccT = pacc;
    hr = S_OK;

    while (paccT && SUCCEEDED(hr))
    {
        polewnd = NULL;
        hr = paccT->QueryInterface(IID_IOleWindow, (void**)&polewnd);
        if (SUCCEEDED(hr) && polewnd)
        {
            hr = polewnd->GetWindow(phwnd);
            polewnd->Release();
            //
            // Release an interface we obtained on our own, but not the one
            // passed in.
            //
            if (paccT != pacc)
            {
                paccT->Release();
                paccT = NULL;
            }
            break;
        }

        //
        // Get our parent.
        //
        pdispParent = NULL;
        hr = paccT->get_accParent(&pdispParent);

        //
        // Release an interface we obtained on our own, but not the one
        // passed in.
        //
        if (paccT != pacc)
        {
            paccT->Release();
        }

        paccT = NULL;

        if (SUCCEEDED(hr) && pdispParent)
        {
            hr = pdispParent->QueryInterface(IID_IAccessible, (void**)&paccT);
            pdispParent->Release();
        }
    }

    return(hr);
}


// --------------------------------------------------------------------------
//
//  AccessibleChildren()
//
//  This function fills in an array of VARIANTs that refer to all the chilren
//  of an IAccessible object. This should simplify many of the test 
//  applications lives, as well as lots of other people as well.
//
//  Parameters:
//      paccContainer   This is a pointer to the IAccessible interface of the
//                      container object - the one you want to get the 
//                      children of.
//      iChildStart     The INDEX (NOT ID!!!) of the first child to get. 
//                      Usually the caller will use 0 to get all the children.
//                      If the caller wants something else, they need to remember
//                      that this expects an INDEX (0 to n-1) and not an ID
//                      (1 to n, or some private ID).
//      cChildren       Count of how many children to get. Usually the
//                      caller will first call IAccessible::get_accChildCount
//                      and use that value.
//      rgvarChildren   The array of VARIANTs that will be filled in by the
//                      function. Each VARIANT can be used to get info 
//                      about the child it references. The caller should be
//                      careful if they didn't use 0 for iChildStart, because
//                      then the index of the array and the index of the 
//                      children won't match up. 
//                      Each VARIANT will be of type either VT_I4 or 
//                      VT_DISPATCH. For a VT_I4, the caller will just ask the 
//                      container for info about the child, using the 
//                      VARIANT.lVal as a child id. For a VT_DISPATCH, the 
//                      caller should do a QueryInterface on VARIANT.pdispVal 
//                      to get an IAccessible interface and then talk to the 
//                      child object directly. 
//                  *** The caller must also do a Release on any IDispatch 
//                      Interfaces, and free this array of variants when done!! ***
//      pcObtained      This value will be filled in by the function and
//                      will indicate the number of VARIANTs in the array 
//                      that were successfully filled in. May not be NULL.
//
//  Returns:
//      S_OK if the number of elements supplied is cChildren; S_FALSE if
//      it succeeded but fewer than the number of children requested was
//      returned, or if you try to skip more children than exist. 
//      Error return values are E_INAVLIDARG if rgvarChildren is not as
//      big as cChildren, or if pcObtained is not a valid pointer.
//
// --------------------------------------------------------------------------
STDAPI AccessibleChildren (IAccessible* paccContainer, LONG iChildStart, 
                           LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained)
{
HRESULT         hr;
IEnumVARIANT*   penum;
IDispatch*      pdisp;
LONG            ArrayIndex;
LONG            ChildIndex;
LONG            celtTotal;

    Assert(paccContainer);
    if ( IsBadWritePtr(paccContainer,sizeof(void*))
      || IsBadWritePtr(rgvarChildren,sizeof(VARIANT)*cChildren)
      || IsBadWritePtr(pcObtained,sizeof(LONG)))
    {
        return E_INVALIDARG;
    }

    // start by initializing the VARIANT array
    for (ArrayIndex = 0; ArrayIndex < cChildren; ArrayIndex++)
        VariantInit (&(rgvarChildren[ArrayIndex]));
  
    //
    // Try querying for IEnumVARIANT.  If that fails, use index+1 based IDs.
    //
    penum = NULL;
    hr = paccContainer->QueryInterface(IID_IEnumVARIANT, (void**)&penum);

    if (penum)
    {
        penum->Reset();
		// SMD 4/27/98 - fix 689 regression
		// if we are doing the case of getting everything (skipping 0)
		// then don't bother calling it. Fixes a problem in CClient::Skip
		// where it returned S_FALSE when skipping 0 items. Since others
		// may accidentally do this too, we'll "fix" it here to localize
		// the change
		if (iChildStart > 0)
		{
	        hr = penum->Skip(iChildStart);
			// hr should still be set to S_OK from QI call
		}
        if (hr == S_OK)
            hr = penum->Next(cChildren,rgvarChildren,(ULONG*)pcObtained);
        else
            *pcObtained = 0;

        penum->Release();
        if (FAILED(hr))
            return (hr);
    }
    else
    {
        // okay,so it doesn't support IEnumVARIANT. We'll just have to 
        // create an array of variants with sequential Child Id's.
        celtTotal = 0;
        paccContainer->get_accChildCount((LONG*)&celtTotal);

        if (iChildStart < celtTotal)
            *pcObtained = celtTotal - iChildStart;
        else
            *pcObtained = 0;

        ChildIndex = iChildStart+1;

        for (ArrayIndex = 0;ArrayIndex < *pcObtained;ArrayIndex++)
        {
            rgvarChildren[ArrayIndex].vt = VT_I4;
            rgvarChildren[ArrayIndex].lVal = ChildIndex;
            
            ChildIndex++;
        }
    } // end else - doesn't support IEnumVARIANT


    // Now that we've filled in the array of variants, let's check each
    // item to see if it is a real object or not.
    for (ArrayIndex = 0;ArrayIndex < *pcObtained;ArrayIndex++)
    {
        // check to see if this child is an IAccessible object or not
        if (rgvarChildren[ArrayIndex].vt == VT_I4)
        {
            pdisp = NULL;
            hr = paccContainer->get_accChild(rgvarChildren[ArrayIndex], &pdisp);
            if (SUCCEEDED(hr) && pdisp)
            {
                rgvarChildren[ArrayIndex].vt = VT_DISPATCH;
                rgvarChildren[ArrayIndex].pdispVal = pdisp; 
            } // end if child seems to be an object (has an IDispatch)
        } // end if child is VT_I4
    } // end for loop through 

    if (*pcObtained == cChildren)
        return(S_OK);
    else
        return (S_FALSE);
}



WORD g_VerInfo [ 4 ]= { BUILD_VERSION_INT };

STDAPI_(VOID) GetOleaccVersionInfo(DWORD* pVer, DWORD* pBuild)
{
    if ( IsBadWritePtr(pVer,sizeof(DWORD))
      || IsBadWritePtr(pBuild,sizeof(DWORD)))
    {
        return;
    }

    *pVer = MAKELONG( g_VerInfo[1], g_VerInfo[0] ); // MAKELONG(lo, hi)
    *pBuild = MAKELONG( g_VerInfo[3], g_VerInfo[2] ); // MAKELONG(lo, hi)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\animated.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ANIMATED.H
//
// --------------------------------------------------------------------------

class   CAnimation : public CClient
{        
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP    get_accState(VARIANT varChild, VARIANT* pvarState);

        CAnimation(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\button.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  BUTTON.H
//
//  Button object
//
// --------------------------------------------------------------------------

class   CButton :   public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT *pvarRole);
        STDMETHODIMP    get_accState(VARIANT varChild, VARIANT *pvarState);
        STDMETHODIMP    get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);
		STDMETHODIMP	get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut);
		STDMETHODIMP	get_accChildCount(long *pcCount);
		STDMETHODIMP	get_accChild(VARIANT varChild, IDispatch ** ppdispChild);
		STDMETHODIMP	accNavigate(long dwNavDir, VARIANT varStart, VARIANT * pvarEnd);
        STDMETHODIMP    accDoDefaultAction(VARIANT varChild);
		// IEnumVariant
		STDMETHODIMP	Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched);
		STDMETHODIMP	Skip(ULONG celt);

		//Helpers
		void SetupChildren(void);

        CButton(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\calendar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CALENDAR.CPP
//
//  Knows how to talk to COMCTL32's calendar and date-picker controls.  These
//  are a lot like a multicolumn listbox and combobox respectively.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "calendar.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOTABCONTROL
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTOOLBAR
#define NOANIMATE
#define NOHEADER
#include <commctrl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\button.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  BUTTON.CPP
//
//  This file has the implementation of the button client
//
//  BOGUS:  In theory, just override get_accRole() and get_accState().
//  In reality, have to also override other things, mainly for the Start
//  button. 
//
//  Implements:
//      get_accChildCount
//      get_accChild
//      get_accName
//      get_accRole
//      get_accState
//      get_accDefaultAction
//      get_accKeyboardShortcut
//      accNavigate
//      accDoDefaultAction
//      Next
//      Skip
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "button.h" 
#include "menu.h"   // because start button has a child that is a menu.


// SendMessageTimeout timeout of 1/4 sec - should be enough time for a
// program to respond, but short enough to not annoy the user if we do
// block that long.
//
// See comments in CButton::DoDefaultAction for details on how this is
// used and why it is needed.
#define  SENDMESSAGE_TIMEOUT    250


// --------------------------------------------------------------------------
//
//  CreateButtonClient()
//
// --------------------------------------------------------------------------
HRESULT CreateButtonClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvButtonC)
{
    CButton * pbutton;
    HRESULT hr;

    InitPv(ppvButtonC);

    pbutton = new CButton(hwnd, idChildCur);
    if (! pbutton)
        return(E_OUTOFMEMORY);

    hr = pbutton->QueryInterface(riid, ppvButtonC);
    if (!SUCCEEDED(hr))
        delete pbutton;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CButton::CButton()
//
// --------------------------------------------------------------------------
CButton::CButton(HWND hwnd, LONG idChildCur)
    : CClient( CLASS_ButtonClient )
{
    Initialize(hwnd, idChildCur);
}


// --------------------------------------------------------------------------
//
//  SetupChildren()
//
// --------------------------------------------------------------------------
void CButton::SetupChildren(void)
{
    HWND hwndFocus;
    HWND hwndChild;

    if (!InTheShell(m_hwnd, SHELL_TRAY))
    {
        m_cChildren = 0;
        return;
    }

    // check to see if the start button has focus and a menu is shown. if so,
    // then there is one child 
    hwndFocus = MyGetFocus();
    if (m_hwnd == hwndFocus)
    {
        hwndChild = FindWindow (TEXT("#32768"),NULL);
        if (IsWindowVisible(hwndChild))
            m_cChildren = 1;
    }

}

// --------------------------------------------------------------------------
//
//  CButton::get_accName()
//
//  HACK for start button.
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::get_accName(varChild, pszName));

    return(HrCreateString(STR_STARTBUTTON, pszName));
}


// --------------------------------------------------------------------------
//
//  CButton::get_accKeyboardShortcut()
//
//  HACK for start button
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));

    return(HrCreateString(STR_STARTBUTTON_SHORTCUT, pszShortcut));
}

// --------------------------------------------------------------------------
//
//  CButton::get_accChildCount()
//
//  HACK for start button
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accChildCount(long *pcCount)
{
    SetupChildren();
    *pcCount = m_cChildren;
    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CButton::get_accChild()
//
//  HACK for start button. If the menu is visible then we'll give that 
//  back, otherwise we'll just fall back on CClient
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
HWND    hwndChild;

    InitPv(ppdispChild);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::get_accChild(varChild,ppdispChild));

    SetupChildren();
    
    if (m_cChildren > 0)
    {
        hwndChild = FindWindow (TEXT("#32768"),NULL);
        if (IsWindowVisible(hwndChild))
        {
            return (CreateMenuPopupWindow (hwndChild,0L,IID_IDispatch,(void **)ppdispChild));
        }
    }

    return S_FALSE;
}

// --------------------------------------------------------------------------
//
//  CButton::accNavigate()
//
//  HACK for start button
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::accNavigate(long dwNavDir, VARIANT varStart, VARIANT * pvarEnd)
{
    HWND    hwndChild;
    HWND    hwndNext;

    InitPvar(pvarEnd);

    //
    // Validate--this accepts an HWND id.
    //
    if (!ValidateHwnd(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::accNavigate(dwNavDir,varStart,pvarEnd));

    // so this is only for the Start button.
    // We want to find the menu that is lowest in the z order
    SetupChildren();
    if ((m_cChildren > 0) && 
        (dwNavDir == NAVDIR_FIRSTCHILD || dwNavDir == NAVDIR_LASTCHILD))
    {
        hwndChild = FindWindow(TEXT("#32768"),NULL);
        if (!hwndChild)
            return(S_FALSE);

        for( ; ; )
        {
            hwndNext = FindWindowEx(NULL,hwndChild,TEXT("#32768"),NULL);
            if (hwndNext && IsWindowVisible(hwndNext))
                hwndChild = hwndNext;
            else
                break;
        }

        if (IsWindowVisible(hwndChild))
            return(GetWindowObject(hwndChild, pvarEnd));
    }

    return(CClient::accNavigate(dwNavDir,varStart,pvarEnd));
}

// --------------------------------------------------------------------------
//
//  CButton::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    long    lStyle;

    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    //
    // Get window style
    //
    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    switch (lStyle & BS_TYPEMASK)
    {
        default:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
        case BS_3STATE:
        case BS_AUTO3STATE:
            pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            break;

        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
            pvarRole->lVal = ROLE_SYSTEM_RADIOBUTTON;
            break;

        case BS_GROUPBOX:
            pvarRole->lVal = ROLE_SYSTEM_GROUPING;
            break;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CButton::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    LRESULT lResult;
    HRESULT hr;

    InitPvar(pvarState);

    //
    // Validate parameters && get window client state.
    //
    hr = CClient::get_accState(varChild, pvarState);
    if (!SUCCEEDED(hr))
        return(hr);
    
    Assert(pvarState->vt == VT_I4);

    lResult = SendMessage(m_hwnd, BM_GETSTATE, 0, 0);

    if (lResult & BST_PUSHED)
        pvarState->lVal |= STATE_SYSTEM_PRESSED;

    if (lResult & BST_CHECKED)
        pvarState->lVal |= STATE_SYSTEM_CHECKED;

    if (lResult & BST_INDETERMINATE)
        pvarState->lVal |= STATE_SYSTEM_MIXED;

    if ((GetWindowLong(m_hwnd, GWL_STYLE) & BS_TYPEMASK) == BS_DEFPUSHBUTTON)
        pvarState->lVal |= STATE_SYSTEM_DEFAULT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CButton::get_accDefaultAction()
//
//  This is the button's name if it is a push button and not disabled.
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    long    lStyle;

    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & WS_DISABLED)
        return(S_FALSE);

    switch (lStyle & BS_TYPEMASK)
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
        case BS_PUSHBOX:
        case BS_OWNERDRAW:
        case BS_USERBUTTON:
            // Pushing a push button is the default
            return(HrCreateString(STR_BUTTON_PUSH, pszDefAction));

        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
            // Toggling a checkbox is the default
            if (SendMessage(m_hwnd, BM_GETSTATE, 0, 0) & BST_CHECKED)
                return(HrCreateString(STR_BUTTON_UNCHECK, pszDefAction));
            else
                return(HrCreateString(STR_BUTTON_CHECK, pszDefAction));
            break;

        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
            // Checking a radio button is the default
            return(HrCreateString(STR_BUTTON_CHECK, pszDefAction));

        case BS_3STATE:
        case BS_AUTO3STATE:
            switch (SendMessage(m_hwnd, BM_GETCHECK, 0, 0))
            {
                case 0:
                    return(HrCreateString(STR_BUTTON_CHECK, pszDefAction));

                case 1:
                    return(HrCreateString(STR_BUTTON_HALFCHECK, pszDefAction));

                default:
                    return(HrCreateString(STR_BUTTON_UNCHECK, pszDefAction));
            }
            break;

    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CButton::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::accDoDefaultAction(VARIANT varChild)
{
    long    lStyle;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & WS_DISABLED)
        return(S_FALSE);

    switch (lStyle & BS_TYPEMASK)
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
            if (InTheShell(m_hwnd, SHELL_TRAY))
            {
                //
                // You can't just click the start button; it won't do
                // anything if the tray isn't active except take focus
                //
                PostMessage(m_hwnd, WM_SYSCOMMAND, SC_TASKLIST, 0L);
                break;
            }
            // FALL THRU

        case BS_PUSHBOX:
        case BS_OWNERDRAW:
        case BS_USERBUTTON:
        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
        case BS_3STATE:
        case BS_AUTO3STATE:

            // This used to be a PostMessage, but that hung powerpoint on 9x.
            // (ADG#186)
            //
            // PPT has a PeekMessage-based message loop. The first time around,
            // they don't filter messages and use PM_NOREMOVE, and get the
            // message. The second time, they filter on the message that they've
            // just got, and use PM_REMOVE to remove it this time. However, on
            // 9x, this failed - so the message remained in the queue, and got
            // processed over and over again...
            //
            // Seems to be a 9x-only quirk - messages are fine, but
            // BM_CLICK and a couple of other BM_ messages (GETSTATE?) have
            // this problem.
            //
            // Anyhow, using a SendMessage variant instead of PostMessage
            // bypasses the message queue, so it's not a problem. The Timeout
            // version is used to stop oleacc clients blocking if the target
            // takes a long time to do its stuff (eg. if it starts a modal
            // dialog).

            
//So using PostMessage on 9x can hang powerpoint, but using SendMessageTimeout on NT can cause the report dialog to hang.
#ifdef NTONLYBUILD
            PostMessage( m_hwnd, BM_CLICK, 0, 0 );
#else
            DWORD_PTR dwResult;
            SendMessageTimeout( m_hwnd, BM_CLICK, 0, 0, SMTO_NORMAL, SENDMESSAGE_TIMEOUT, & dwResult );
#endif
            return S_OK;
    }

    return E_NOT_APPLICABLE;
}

// --------------------------------------------------------------------------
//
//  CButton::Next()
//
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched)
{
    HWND    hwndChild;
    VARIANT* pvar;
    long    cFetched;
    HRESULT hr;

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::Next(celt,rgvar,pceltFetched));

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;
    SetupChildren();

    // we only ever have 1 child
    if (m_idChildCur > 1)
        return (S_FALSE);

    // we only have one child if we have the focus and the menu
    // is visible
    hwndChild = FindWindow(TEXT("#32768"),NULL);
    if (!hwndChild)
        return(S_FALSE);

    if (IsWindowVisible(hwndChild))
    {
        hr = GetWindowObject(hwndChild, pvar);
        if (SUCCEEDED(hr))
        {
            ++pvar;
            ++cFetched;
        }
    }

    //
    // Advance the current position
    //
    m_idChildCur = 1;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched += cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CButton::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::Skip(ULONG celt)
{
    if (!InTheShell (m_hwnd,SHELL_TRAY))
        return (CClient::Skip(celt));

    return (CAccessible::Skip(celt));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\calendar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CALENDAR.H
//
//  Knows how to talk to COMCTL32's calendar and date-picker controls.
//
// --------------------------------------------------------------------------


class CCalendar : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accSelection(VARIANT*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        void SetupChildren(void);
        CCalendar(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\classinfo.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  classinfo
//
//  Information about the individual proxy classes
//
//  We could put this information in each class; but that would mean that
//  changes would require touching all the class files.
//  Centralizing this means that we only have a couple of files to change
//  if we need to add more information across all classes.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
#include "ctors.h"
// #include "classinfo.h" - already in oleacc_p.h


CLASSINFO g_ClassInfo[ ] =
{
    // General non-client stuff
    // These ctors can be NULL, since they're never used. Only need them for
    // classes that are in the class map.

    // ctor and bit-agnostic fields are only used for classes that are in the class map.
    // Exceptions are CreateClient and CreateWindowThing - these are the 'default'
    // client and window proxies, which are used if no classname match is found.

    // ctor                  bit-agnostic       name             annotatble?   objid
    { NULL,                     FALSE,  TEXT("CaretObject"),        TRUE,   OBJID_CARET     },
    { CreateClient,             TRUE,   TEXT("ClientObject"),       TRUE,   OBJID_CLIENT    },
    { NULL,                     FALSE,  TEXT("CursorObject"),       TRUE,   OBJID_CURSOR    },
    { NULL,                     FALSE,  TEXT("MenuBarObject"),      TRUE,   OBJID_MENU      },

    // ScrollBarObject annotation support is handled explicitly in CScrollBar::GetIdentityString,
    // so the objid field is left empty here.
    { NULL,                     FALSE,  TEXT("ScrollBarObject"),    TRUE,   0               },
    { NULL,                     FALSE,  TEXT("SizeGripObject"),     TRUE,   OBJID_SIZEGRIP  },
    { NULL,                     FALSE,  TEXT("SysMenuBarObject"),   TRUE,   OBJID_SYSMENU   },
    { NULL,                     FALSE,  TEXT("TitleBarObject"),     TRUE,   OBJID_TITLEBAR  },
    { CreateWindowThing,        TRUE,   TEXT("WindowObject"),       TRUE,   OBJID_WINDOW    },

    // Client types - USER

    { CreateButtonClient,       TRUE,   TEXT("ButtonClient"),       TRUE,   OBJID_CLIENT    },
    { CreateComboClient,        TRUE,   TEXT("ComboClient"),        TRUE,   OBJID_CLIENT    },
    { CreateDialogClient,       TRUE,   TEXT("DialogClient"),       TRUE,   OBJID_CLIENT    },
    { CreateDesktopClient,      TRUE,   TEXT("DesktopClient"),      TRUE,   OBJID_CLIENT    },
    { CreateEditClient,         TRUE,   TEXT("EditClient"),         TRUE,   OBJID_CLIENT    },
    { CreateListBoxClient,      TRUE,   TEXT("ListBoxClient"),      TRUE,   OBJID_CLIENT    },
    { CreateMDIClient,          TRUE,   TEXT("MDIClient"),          TRUE,   OBJID_CLIENT    },
    { CreateMenuPopupClient,   FALSE,   TEXT("MenuPopupClient"),    TRUE,   OBJID_CLIENT    },
    { CreateScrollBarClient,    TRUE,   TEXT("ScrollBarClient"),    TRUE,   OBJID_CLIENT    },
    { CreateStaticClient,       TRUE,   TEXT("StaticClient"),       TRUE,   OBJID_CLIENT    },
    { CreateSwitchClient,       TRUE,   TEXT("SwitchClient"),       TRUE,   OBJID_CLIENT    },

    // Client types - ComCtl32

    { CreateStatusBarClient,    TRUE,   TEXT("StatusBarClient"),    TRUE,   OBJID_CLIENT    },
    { CreateToolBarClient,      TRUE,   TEXT("ToolBarClient"),      TRUE,   OBJID_CLIENT    },
    { CreateProgressBarClient,  TRUE,   TEXT("ProgressBarClient"),  TRUE,   OBJID_CLIENT    },
    { CreateAnimatedClient,     TRUE,   TEXT("AnimatedClient"),     TRUE,   OBJID_CLIENT    },
    { CreateTabControlClient,   TRUE,   TEXT("TabControlClient"),   TRUE,   OBJID_CLIENT    },
    { CreateHotKeyClient,       TRUE,   TEXT("HotKeyClient"),       TRUE,   OBJID_CLIENT    },
    { CreateHeaderClient,       TRUE,   TEXT("HeaderClient"),       TRUE,   OBJID_CLIENT    },
    { CreateSliderClient,       TRUE,   TEXT("SliderClient"),       TRUE,   OBJID_CLIENT    },
    { CreateListViewClient,     TRUE,   TEXT("ListViewClient"),     TRUE,   OBJID_CLIENT    },
    { CreateUpDownClient,       TRUE,   TEXT("UpDownClient"),       TRUE,   OBJID_CLIENT    },
    { CreateToolTipsClient,     TRUE,   TEXT("ToolTipsClient"),     TRUE,   OBJID_CLIENT    },
    { CreateTreeViewClient,     FALSE,  TEXT("TreeViewClient"),     TRUE,   OBJID_CLIENT    },
    { NULL,                     FALSE,  TEXT("CalendarClient"),     TRUE,   OBJID_CLIENT    },
    { CreateDatePickerClient,   TRUE,   TEXT("DatePickerClient"),   TRUE,   OBJID_CLIENT    },
    { CreateIPAddressClient,    TRUE,   TEXT("IPAddressClient"),    TRUE,   OBJID_CLIENT    },


#ifndef OLEACC_NTBUILD
    { CreateHtmlClient,         FALSE,  TEXT("HtmlClient"),         TRUE,   OBJID_CLIENT    },

    // SDM32

    { CreateSdmClientA,         FALSE,  TEXT("SdmClientA"),         TRUE,   OBJID_CLIENT    },
#endif // OLEACC_NTBUILD

    // Window types

    { CreateListBoxWindow,      TRUE,   TEXT("ListBoxWindow"),      TRUE,   OBJID_WINDOW    },
    { CreateMenuPopupWindow,    FALSE,  TEXT("MenuPopupWindow"),    TRUE,   OBJID_WINDOW    },

    // Other classes - these are created directly - and don't appear in the classmaps.
    // Since they're always created directly, their ctor fn.s are NULL here...
    { NULL,                     FALSE,  TEXT("MenuObject"),         TRUE,   0               },
    { NULL,                     FALSE,  TEXT("MenuItemObject"),     TRUE,   0               },
#ifndef OLEACC_NTBUILD
    { NULL,                     FALSE,  TEXT("HtmlImageMap"),       FALSE,  0               },
    { NULL,                     FALSE,  TEXT("SdmList"),            FALSE,  0               },
#endif // OLEACC_NTBUILD
};







#ifdef _DEBUG

class RunTimeCheck
{
public:
    RunTimeCheck()
    {
        Assert( ARRAYSIZE( g_ClassInfo ) == CLASS_LAST );
    }
};

RunTimeCheck g_RunTimeCheck;

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\caret.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CARET.H
//
//  Caret OLE Accessibility implementation
//
// --------------------------------------------------------------------------


class   CCaret :    public  CAccessible
{
    public:

        CCaret()
            : CAccessible( CLASS_CaretObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR * pszName);
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP    get_accState(VARIANT varChild, VARIANT * lpState);
        STDMETHODIMP    accLocation(long* pxLeft, long* pyTop,
            long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP    accHitTest(long xLeft, long yTop, VARIANT* pvarChild);

        // IEnumVARIANT
        STDMETHODIMP    Clone(IEnumVARIANT** ppenum);

        BOOL            FInitialize(HWND hwnd);

    private:
        DWORD           m_dwThreadId;
};


HRESULT     CreateCaretThing(HWND, REFIID, void**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\classmap.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ClassMap
//
//  Contains all the funcitons and data used for mapping a window class
//  to an OLEACC proxy.
//
// --------------------------------------------------------------------------



void InitWindowClasses();
void UnInitWindowClasses();


typedef HRESULT (* LPFNCREATE)(HWND, long, REFIID, void**);

CLASS_ENUM GetWindowClass( HWND hWnd );

HRESULT FindAndCreateWindowClass( HWND        hWnd,
                                  BOOL        fWindow,
                                  CLASS_ENUM  ecDefault,
                                  long        idObject,
                                  long        idCurChild,
                                  REFIID      riid,
                                  void **     ppvObject );

//-----------------------------------------------------------------
// [v-jaycl, 6/7/97] [brendanm 9/4/98]
//  loads and initializes registered handlers.
//	Called by FindAndCreatreWindowClass
//-----------------------------------------------------------------
HRESULT CreateRegisteredHandler( HWND      hwnd,
                                 long      idObject,
                                 int       iHandlerIndex,
                                 REFIID    riid,
                                 LPVOID *  ppvObject );

BOOL LookupWindowClass( HWND          hWnd,
                        BOOL          fWindow,
                        CLASS_ENUM *  pceClass,
                        int *         pRegHandlerIndex );

BOOL LookupWindowClassName( LPCTSTR       pClassName,
                            BOOL          fWindow,
                            CLASS_ENUM *  pceClass,
                            int *         pRegHandlerIndex );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\classmap.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ClassMap
//
//  Contains all the funcitons and data used for mapping a window class
//  to an OLEACC proxy.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
#include "classmap.h"
#include "ctors.h"
#include "default.h"
#include "Win64Helper.h"
#include "RemoteProxy6432.h"


//
// Internal types & Forward decls.
//

// TODO: At some stage in future, this should be made dynamic instead of hardwired.
#define TOTAL_REG_HANDLERS                      100




typedef struct tagREGTYPEINFO
{
    CLSID   clsid;  // CLSID for this registered handler
    BOOL    bOK;    // used if there is an error - set to false if so
    TCHAR   DllName [ MAX_PATH ];
    TCHAR   ClassName [ MAX_PATH ];
    LPVOID  pClassFactory;
} REGTYPEINFO;




HRESULT CreateRemoteProxy6432(HWND hwnd, long idObject, REFIID riid, void ** ppvObject);








//
// Arrays & Class Map Data...
//


//
// These three arrays (rgAtomClasses, rgClientTypes, and rgWindowTypes)
// are used by the FindWindowClass function below. 
//
// The rgAtomClass array is filled in by the InitWindowClasses function.
// InitWindowClasses iterates through the resources, loading strings that 
// are the names of the window classes that we recognize, putting them in 
// the Global Atom Table, and putting the Atom numbers in rgAtomClass so
// that rgAtomClass[StringN] = GlobalAddAtom ("StringTable[StringN]")
//
// When FindWindowClass is called, it gets the "real" class name of the 
// window, does a GlobalFindAtom of that string, then walks though 
// rgAtomClasses to see if the atom is in the table. If it is, then we 
// use the index where we found the atom to index into either the 
// rgClientTypes or rgWindowTypes array, where a pointer to the object 
// creation function is stored. These two arrays are static arrays
// initialized below. The elements in the array must correspond to the
// elements in the string table. 
//
// The rgClientTypes array is where most of the classes are. Currently,
// all types of controls that we create have a parent control that is
// a CWindow object, except for Dropdowns and menu popups, which provide 
// a window handler as well since they do something nonstandard for 
// get_accParent().  The former returns the combobox it is in, the 
// latter returns the menu item it comes from.
//

//
// NB - ordering of these should be considered fixed - as an offset
// referring to Listbox through RichEdit20W can be returned in response
// to WM_GETOBJECT/OBJID_QUERYCLASSINDEX.
// (The index is currently used to index directly into this table,
// but if the table order must change, another mapping table can
// be created and it used instead.)
//
//


CLASS_ENUM g_ClientClassMap [ ] =
{
    CLASS_ListBoxClient,
    CLASS_MenuPopupClient,
    CLASS_ButtonClient,
    CLASS_StaticClient,
    CLASS_EditClient,
    CLASS_ComboClient,
    CLASS_DialogClient,
    CLASS_SwitchClient,
    CLASS_MDIClient,
    CLASS_DesktopClient,
    CLASS_ScrollBarClient,
    CLASS_StatusBarClient,
    CLASS_ToolBarClient,
    CLASS_ProgressBarClient,
    CLASS_AnimatedClient,
    CLASS_TabControlClient,
    CLASS_HotKeyClient,
    CLASS_HeaderClient,
    CLASS_SliderClient,
    CLASS_ListViewClient,
        CLASS_ListViewClient,
    CLASS_UpDownClient,     // msctls_updown
    CLASS_UpDownClient,     // msctls_updown32
    CLASS_ToolTipsClient,   // tooltips_class
    CLASS_ToolTipsClient,   // tooltips_class32
    CLASS_TreeViewClient,
    CLASS_NONE,             // SysMonthCal32
    CLASS_DatePickerClient, // SysDateTimePick32
    CLASS_EditClient,       // RichEdit
    CLASS_EditClient,       // RichEdit20A
    CLASS_EditClient,       // RichEdit20W
    CLASS_IPAddressClient,

#ifndef OLEACC_NTBUILD
    CLASS_HtmlClient,       // HTML_InternetExplorer
    CLASS_SdmClientA,       // Word '95 #1
    CLASS_SdmClientA,       // Word '95 #2
    CLASS_SdmClientA,       // Word '95 #3
    CLASS_SdmClientA,       // Word '95 #4
    CLASS_SdmClientA,       // Word '95 #5
    CLASS_SdmClientA,       // Excel '95 #1
    CLASS_SdmClientA,       // Excel '95 #2
    CLASS_SdmClientA,       // Excel '95 #3
    CLASS_SdmClientA,       // Excel '95 #4
    CLASS_SdmClientA,       // Excel '95 #5
    CLASS_SdmClientA,       // Word '97 #1
    CLASS_SdmClientA,       // Word '97 #2
    CLASS_SdmClientA,       // Word '97 #3
    CLASS_SdmClientA,       // Word '97 #4
    CLASS_SdmClientA,       // Word '97 #5
    CLASS_SdmClientA,       // Word 3.1 #1
    CLASS_SdmClientA,       // Word 3.1 #2
    CLASS_SdmClientA,       // Word 3.1 #3
    CLASS_SdmClientA,       // Word 3.1 #4
    CLASS_SdmClientA,       // Word 3.1 #5
    CLASS_SdmClientA,       // Office '97 #1
    CLASS_SdmClientA,       // Office '97 #2
    CLASS_SdmClientA,       // Office '97 #3
    CLASS_SdmClientA,       // Office '97 #4
    CLASS_SdmClientA,       // Office '97 #5
    CLASS_SdmClientA,       // Excel '97 #1
    CLASS_SdmClientA,       // Excel '97 #2
    CLASS_SdmClientA,       // Excel '97 #3
    CLASS_SdmClientA,       // Excel '97 #4
    CLASS_SdmClientA        // Excel '97 #5
#endif // OLEACC_NTBUILD
};

#define NUM_CLIENT_CLASSES  ARRAYSIZE( g_ClientClassMap )

CLASS_ENUM g_WindowClassMap [ ] =
{
    CLASS_ListBoxWindow,
    CLASS_MenuPopupWindow
};

#define NUM_WINDOW_CLASSES  ARRAYSIZE( g_WindowClassMap )



LPTSTR rgClassNames [ ] =
{
        TEXT( "ListBox" ),
        TEXT( "#32768" ),
        TEXT( "Button" ),
        TEXT( "Static" ),
        TEXT( "Edit" ),
        TEXT( "ComboBox" ),
        TEXT( "#32770" ),
        TEXT( "#32771" ),
        TEXT( "MDIClient" ),
        TEXT( "#32769" ),
        TEXT( "ScrollBar" ),
        TEXT( "msctls_statusbar32" ),
        TEXT( "ToolbarWindow32" ),
        TEXT( "msctls_progress32" ),
        TEXT( "SysAnimate32" ),
        TEXT( "SysTabControl32" ),
        TEXT( "msctls_hotkey32" ),
        TEXT( "SysHeader32" ),
        TEXT( "msctls_trackbar32" ),
        TEXT( "SysListView32" ),
        TEXT( "OpenListView" ),
        TEXT( "msctls_updown" ),
        TEXT( "msctls_updown32" ),
        TEXT( "tooltips_class" ),
        TEXT( "tooltips_class32" ),
        TEXT( "SysTreeView32" ),
        TEXT( "SysMonthCal32" ),
        TEXT( "SysDateTimePick32" ),
        TEXT( "RICHEDIT" ),
        TEXT( "RichEdit20A" ),
        TEXT( "RichEdit20W" ),
    TEXT( "SysIPAddress32" ),

// The above CSTR_QUERYCLASSNAME_CLASSES classes can be referred
// to by the WM_GETOBJECT/OBJID_QUERYCLASSNAMEIDX message.
// See LookupWindowClassName() for more details.

#ifndef OLEACC_NTBUILD
        TEXT( "HTML_Internet Explorer" ),

        TEXT( "bosa_sdm_Microsoft Word for Windows 95" ),
        TEXT( "osa_sdm_Microsoft Word for Windows 95" ),
        TEXT( "sa_sdm_Microsoft Word for Windows 95" ),
        TEXT( "a_sdm_Microsoft Word for Windows 95" ),
        TEXT( "_sdm_Microsoft Word for Windows 95" ),
        TEXT( "bosa_sdm_XL" ),
        TEXT( "osa_sdm_XL" ),
        TEXT( "sa_sdm_XL" ),
        TEXT( "a_sdm_XL" ),
        TEXT( "_sdm_XL" ),
        TEXT( "bosa_sdm_Microsoft Word 8.0" ),
        TEXT( "osa_sdm_Microsoft Word 8.0" ),
        TEXT( "sa_sdm_Microsoft Word 8.0" ),
        TEXT( "a_sdm_Microsoft Word 8.0" ),
        TEXT( "_sdm_Microsoft Word 8.0" ),
        TEXT( "bosa_sdm_Microsoft Word 6.0" ),
        TEXT( "osa_sdm_Microsoft Word 6.0" ),
        TEXT( "sa_sdm_Microsoft Word 6.0" ),
        TEXT( "a_sdm_Microsoft Word 6.0" ),
        TEXT( "_sdm_Microsoft Word 6.0" ),
        TEXT( "bosa_sdm_Mso96" ),
        TEXT( "osa_sdm_Mso96" ),
        TEXT( "sa_sdm_Mso96" ),
        TEXT( "a_sdm_Mso96" ),
        TEXT( "_sdm_Mso96" ),
        TEXT( "bosa_sdm_XL8" ),
        TEXT( "osa_sdm_XL8" ),
        TEXT( "sa_sdm_XL8" ),
        TEXT( "a_sdm_XL8" ),
        TEXT( "_sdm_XL8" )
#endif // OLEACC_NTBUILD
};



//-----------------------------------------------------------------
// [v-jaycl, 4/2/97] Table of registered handler CLSIDs.  
//      TODO:Make dynamic. Place at bottom of file w/ other data?
//-----------------------------------------------------------------

CLSID   rgRegisteredTypes[TOTAL_REG_HANDLERS];


//-----------------------------------------------------------------
// [v-jaycl, 4/1/97] Grow to accomodate registered handlers. 
//      TODO: Kludge!  Make this dynamic.
//-----------------------------------------------------------------

ATOM    rgAtomClasses [ ARRAYSIZE(rgClassNames) + TOTAL_REG_HANDLERS ] = { 0 };












// --------------------------------------------------------------------------
//
//  InitWindowClasses()
//
//  Adds a whole lot of classes into the Global atom table for comparison
//  purposes.
//
// --------------------------------------------------------------------------
void InitWindowClasses()
{
    int     istr;
    TCHAR   szClassName[128];

    for (istr = 0; istr < NUM_CLIENT_CLASSES; istr++)
    {
        if( rgClassNames[ istr ] == NULL )
        {
            rgAtomClasses[istr] = NULL;
        }
        else
        {
            rgAtomClasses[istr] = GlobalAddAtom( rgClassNames[ istr ] );
        }
    }

        //-----------------------------------------------------------------
        // [v-jaycl, 4/2/97] Retrieve info for registered handlers from 
        //       registry and add to global atom table. 
        //       TODO: remove hard-wired strings.
        //-----------------------------------------------------------------

        const TCHAR  szRegHandlers[]   = TEXT("SOFTWARE\\Microsoft\\Active Accessibility\\Handlers");
        TCHAR            szHandler[255], szHandlerClassKey[255];
    LONG                 lRetVal, lBuffSize;
        HKEY             hKey;


        lRetVal = RegOpenKey( HKEY_LOCAL_MACHINE, szRegHandlers, &hKey );

        if ( lRetVal != ERROR_SUCCESS )
                return;

        for ( istr = 0; istr < TOTAL_REG_HANDLERS; istr++ )
        {
                lRetVal = RegEnumKey( hKey, istr, szHandler, sizeof(szHandler)/sizeof(TCHAR));

                if ( lRetVal != ERROR_SUCCESS ) 
                        break;          

                //-----------------------------------------------------------------
                // [v-jaycl, 4/2/97] Translate string into CLSID, then get info
                //       on specific handler from HKEY_CLASSES_ROOT\CLSID  subkey.
                //-----------------------------------------------------------------

                //-----------------------------------------------------------------
                //      Get proxied window class name from 
                //      HKEY_CLASSES_ROOT\CLSID\{clsid}\AccClassName
                //-----------------------------------------------------------------

                lstrcpy( szHandlerClassKey, TEXT("CLSID\\"));
                lstrcat( szHandlerClassKey, szHandler );
                lstrcat( szHandlerClassKey, TEXT("\\AccClassName"));

                lBuffSize = sizeof(szClassName)/sizeof(TCHAR);
                lRetVal = RegQueryValue( HKEY_CLASSES_ROOT, szHandlerClassKey, szClassName, &lBuffSize );

                if ( lRetVal == ERROR_SUCCESS )
                {

                        //-------------------------------------------------------------
                        // Add CLSID to registered types table and associated class
                        //      name to global atom table and class types table.
                        //-------------------------------------------------------------

#ifdef UNICODE
                        
                        if ( CLSIDFromString( szHandler, &rgRegisteredTypes[istr] ) == NOERROR )
                        {
                                rgAtomClasses[istr + NUM_CLIENT_CLASSES] = GlobalAddAtom( szClassName );
                        }

#else

                        OLECHAR wszString[MAX_PATH];
                        MultiByteToWideChar(CP_ACP, 0, szHandler, -1, wszString, ARRAYSIZE(wszString));

                        if ( CLSIDFromString( wszString, &rgRegisteredTypes[istr] ) == NOERROR )
                        {
                                rgAtomClasses[istr + NUM_CLIENT_CLASSES] = GlobalAddAtom( szClassName );
                        }

#endif

                }
        }

        RegCloseKey( hKey );

        return;
}


// --------------------------------------------------------------------------
//
//  UnInitWindowClasses()
//
//  Cleans up the Global Atom Table.
//
// --------------------------------------------------------------------------
void UnInitWindowClasses()
{
        //-----------------------------------------------------------------
        // [v-jaycl, 4/2/97] Clean up registered handler atoms after
        //  class and window atoms have been removed.
        //-----------------------------------------------------------------

    for( int istr = 0 ; istr < NUM_CLIENT_CLASSES + TOTAL_REG_HANDLERS ; istr++ )
    {
        if( rgAtomClasses[ istr ] )
            GlobalDeleteAtom( rgAtomClasses[ istr ] );
    }
}


// --------------------------------------------------------------------------
//
//  FindWindowClass()
// - has been replaced by:
//
//  GetWindowClass
//  FindAndCreateWindowClass
//  LookupWindowClass
//  LookupWindowClassName
//
//  See comments on each function for more infotmation.
//
// --------------------------------------------------------------------------



// --------------------------------------------------------------------------
//
//  GetWindowClass()
//
//  Gets an enum for the window class of this hwnd
//
//  Paremeters:
//              hwnd        The window handle we are checking
//      CLASS_ENUM  enum for this window
//
//      Returns:
//              A HRESULT 
//
// --------------------------------------------------------------------------

CLASS_ENUM GetWindowClass( HWND hWnd )
{
    int RegHandlerIndex;
    CLASS_ENUM ceClass;
    
    // fWindow param is FALSE - only interested in client classes...
    if( ! LookupWindowClass( hWnd, FALSE, &ceClass, & RegHandlerIndex ) )
    {
        // CLASS_NONE means it's a registered handler 
        return CLASS_NONE;
    }

    return ceClass;
}


// --------------------------------------------------------------------------
//
//  FindAndCreateWindowClass()
//
//  Create an object of the appropriate class for given window.
//  If no suitable class found, use the default object creation given,
//  if any.
//  
//  Paremeters:
//              hwnd        Handle of window to create object to represent/proxy
//              fWindow     TRUE if we're interested in a window (as opposed to
//                  client) -type class
//      pfnDefault  Function to use to create object if no suitable class
//                  found.
//      riid        Interface to pass to object creation function
//      idObject    object id to pass to object creation function
//      ppvObject   Object is returned through this
//
//      Returns:
//              HRESULT resulting from object creation.
//      S_OK or other success value on success,
//      failure value on failure (surprise surprise!)
//
//      If no suitable class found, and no default creation function
//      supplied, returns E_FAIL.
//      (Note that return of E_FAIL doesn't necessarilly mean no suitable
//      class found, since it can be returned for other reasons - eg.
//      error during creation of object.)
//
// --------------------------------------------------------------------------

HRESULT FindAndCreateWindowClass( HWND        hWnd,
                                  BOOL        fWindow,
                                  CLASS_ENUM  ceDefault,
                                  long        idObject,
                                  long        idCurChild,
                                  REFIID      riid,
                                  void **     ppvObject )
{
    int RegHandlerIndex;
    CLASS_ENUM ceClass;

    // Try and find a native proxy or registered handler for this window/client...
    if( ! LookupWindowClass( hWnd, fWindow, & ceClass, & RegHandlerIndex ) )
    {
        // Unknown class - do we have a default fn to use instead?
        if( ceDefault != CLASS_NONE )
        {
            // Yup - use it...
            ceClass = ceDefault;
        }
        else
        {
            // Nope - fail!
            ppvObject = NULL;
            return E_FAIL;
        }
    }

        // If the window class cannot be handled in a bit-agnostic way then we may
        // need to call a proxy of the server's bitness to create the accessible
        // object.  CreateRemoteProxy6432 returns S_OK if ppvObject is successfully created
        // by the proxy factory.  Otherwise just try to create it the normal way.

        if( ! g_ClassInfo[ ceClass ].fBitAgnostic )
        {
                BOOL fIsSameBitness;
                if (FAILED(SameBitness(hWnd, &fIsSameBitness)))
                        return E_FAIL;  // this should never happen

                if (!fIsSameBitness)
                        return CreateRemoteProxy6432( hWnd, idObject, riid, ppvObject );

        // If target window is of same bitness, fall through and create proxy locally...
        }

    // At this point, ceClass != CLASS_NONE means we've either found a class above,
    // or we're using the supplied default.
    // ceClass == CLASS_NONE means it's a registered handler class, using index
    // RegHandlerIndex...

    // Now create the object...
    if( ceClass != CLASS_NONE )
    {
        return g_ClassInfo[ ceClass ].lpfnCreate( hWnd, idCurChild, riid, ppvObject );
    }
    else
    {
        return CreateRegisteredHandler( hWnd, idObject, RegHandlerIndex, riid, ppvObject );
    }
}


// --------------------------------------------------------------------------
//
//  CreateRemoteProxy6432()
//
//  If the client and server are not the same bitness this code gets the
//  accessible object from a proxy of the correct bitness.
//  
//  Paremeters:
//              hwnd        Handle of window to create object to represent/proxy
//      idObject    object id to pass to oleacc proxy
//      riid        Interface to QI for on returned proxy object
//      ppvObject   Object is returned through this
//
//      Returns:
//              HRESULT is S_OK if the proxy successfully creats the accessible object,
//      HRESULT if an intermediate call fails.
//
HRESULT CreateRemoteProxy6432(HWND hwnd, long idObject, REFIID riid, void ** ppvObject)
{
        HRESULT hr;

        // The server (hwnd) is not the same bitness so get a remote proxy
        // factory object and use it to return the IAccessible object

        IRemoteProxyFactory *p;
        hr = GetRemoteProxyFactory(&p);
        if (FAILED(hr))
                return hr;

        IUnknown *punk = NULL;
        hr = p->AccessibleProxyFromWindow( HandleToLong( hwnd ), idObject, &punk);
        p->Release();

        if (FAILED(hr))
                return hr;

        if (!punk)
                return E_OUTOFMEMORY;

        // TODO Performance improvement would be to do the QI on the other side
        // but that would require custom marshalling of the riid struct.

        hr = punk->QueryInterface(riid, ppvObject);
        punk->Release();

        return hr;
}


// --------------------------------------------------------------------------
//
//  LookupWindowClass()
//
//  Tries to find an internal proxy or a registered handler for the
//  window, based on class name.
//
//  If no suitable match found, it sends the window a WM_GETOBJECT
//  message with OBJID_QUERYCLASSNAMEIDX - window can respond to
//  indicate its real name. If so, a class name match is tried on
//  that new name.
//
//  If that fails, or the window doesn't respond to the QUERY message,
//  FALSE is returned.
//
//  Paremeters:
//              hwnd            The window handle we are checking
//              fWindow         This is true if...
//      pceClass        ptr to value to receive class enum
//      pRegHandlerIndex    ptr to value to receive reg.handler index
//
//      Returns:
//      Returns TRUE if match found, FALSE if none found.
//
//      When TRUE returned:
//      If internal proxy found, *pceClass points to index of class in
//      class info array (entry contains a ctor fn plus other info).
//      If reg handler found, *pceClass is set to CLASS_NONE, and
//      *pRegHandlerIndex is set to a value that can be passed to
//      CreateRegisteredHandler to create a suitable object.
//
// --------------------------------------------------------------------------

BOOL LookupWindowClass( HWND          hWnd,
                        BOOL          fWindow,
                        CLASS_ENUM *  pceClass,
                        int *         pRegHandlerIndex )
{
    TCHAR   szClassName[128];

    //  This works by looking at the class name.  It uses a private function in
    //  USER to get the "real" class name, so that we see superclassed controls
    //  like VB's 'ThunderButton' as a button. (This only works for USER controls,
    //  though...)
    if( ! MyGetWindowClass( hWnd, szClassName, ARRAYSIZE( szClassName ) ) )
        return NULL;

    // First do lookup on 'apparent' class name - this allows us to reg-handler
    // even subclassed comctrls...
    if( LookupWindowClassName( szClassName, fWindow, pceClass, pRegHandlerIndex ) )
    {
        // Found a match for the (possibly wrapped) class name - use it...
        return TRUE;
    }

    // Try sending a WM_GETOBJECT / OBJID_QUERYCLASSNAMEIDX...
    LPTSTR pClassName = szClassName;
    DWORD_PTR ref = 0;
    SendMessageTimeout( hWnd, WM_GETOBJECT, 0, OBJID_QUERYCLASSNAMEIDX,
                            SMTO_ABORTIFHUNG, 10000, &ref );

    if( ! ref )
    {
        // No response - no match found, then, so return FALSE...
        return FALSE;
    }

    // Valid / in-range response?
    // (Remember, that we go from base..base+numclasses-1 instead of
    // 0..numclasses-1 to avoid running afoul of Notes and other apps
    // that return small LRESULTS to WM_GETOBJECT...)
    if( ref >= QUERYCLASSNAME_BASE &&
         ref - QUERYCLASSNAME_BASE < QUERYCLASSNAME_CLASSES )
    {
        // Yup - valid:
        pClassName = rgClassNames[ ref - QUERYCLASSNAME_BASE ];

        if( ! pClassName )
        {
            DBPRINTF( TEXT("Warning: reply to OBJID_QUERYCLASSNAMEIDX refers to unsupported class") );
            return FALSE;
        }

        // Now try again, using 'real' COMCTRL class name.
        return LookupWindowClassName( pClassName, fWindow, pceClass, pRegHandlerIndex );
    }
    else
    {
        DBPRINTF( TEXT("Warning: out-of-range reply to OBJID_QUERYCLASSNAMEIDX received") );
        return FALSE; // TODO - add debug output
    }
}



// --------------------------------------------------------------------------
//
//  LookupWindowClassName()
//
//  Tries to find an internal proxy or a registered handler for the
//  window, based on class name.
//
//  Does so by converting class name to an 'atom', and looking through
//  our reg handler and proxy tables.
//
//  Paremeters:
//              pClassName          name of class to lookup
//              fWindow             This is true if...
//      pceClass            ptr to value to receive proxy class enum
//      pRegHandlerIndex    ptr to value to receive reg.handler index
//
//      Returns:
//      Returns TRUE if match found, FALSE if none found.
//
//      When TRUE returned:
//      If internal proxy found, *pceClass is set to class index for the
//      proxy. (Can index into classinfo table to get ctor fn.)
//      If reg handler found, *pceClass is set to CLASS_NONE, and
//      *pRegHandlerIndex is set to a value that can be passed to
//      CreateRegisteredHandler to create a suitable object.
//
// --------------------------------------------------------------------------


BOOL LookupWindowClassName( LPCTSTR       pClassName,
                            BOOL          fWindow,
                            CLASS_ENUM *  pceClass,
                            int *         pRegHandlerIndex )
{
    // Get atom from classname - use it to lookup name in registered and
    // internal proxy tables...
    ATOM atom = GlobalFindAtom( pClassName );
    if( ! atom )
        return FALSE;

    // Search registered handler table first...
    int istr;
    for( istr = NUM_CLIENT_CLASSES ; istr < NUM_CLIENT_CLASSES + TOTAL_REG_HANDLERS ; istr++ )
        {
                if( rgAtomClasses[ istr ] == atom )
                {
                        *pRegHandlerIndex = istr - NUM_CLIENT_CLASSES;
            *pceClass = CLASS_NONE;
            return TRUE;
                }
        }

    // Search internal proxy client/window table...
    int cstr = (int)(fWindow ? NUM_WINDOW_CLASSES : NUM_CLIENT_CLASSES);

    for( istr = 0; istr < cstr ; istr++ )
    {
        if( rgAtomClasses[ istr ] == atom )
                {
            *pceClass = fWindow ? g_WindowClassMap[ istr ] : g_ClientClassMap[ istr ];
            // Only want to return TRUE if there is actually a proxy class for this window class...
            return *pceClass != CLASS_NONE;
                }
    }

    return FALSE;
}





// --------------------------------------------------------------------------
//
//  CreateRegisteredHandler()
//
//  This function takes an HWND, OBJID, RIID, and a PPVOID, same as the
//  other CreateXXX functions (like CreateButtonClient, etc.) This function
//  is used by calling FindWindowClass, which sees if a registered handler 
//  for the window class of HWND is installed. If so, it sets a global variable
//  s_iHandlerIndex that is an index into the global rgRegisteredTypes
//  array. That array contains CLSID's that are used to call CoCreateInstance,
//  to create an instance of an object that supports the interface
//  IAccessibleHandler. 
//  After creating this object, this function calls the object's
//  AccesibleObjectFromId method, using the HWND and the OBJID, and filling 
//  in the PPVOID to be an IAccessible interface.
//
//  [v-jaycl, 4/2/97] Special function returned by FindWindowClass()
//      for creating registered handlers.  
//
//  [v-jaycl, 5/15/97] Renamed second parameter from idChildCur to idObject
//      because I believe that what the parameter really is, or at least how I
//      intend to use it.
//
//  [v-jaycl, 8/7/97] Changed logic such that we now get an accessible
//      factory pointer back from CoCreateInstance() which supports
//      IAccessibleHandler. This interface provides the means for getting an
//      IAccessible ptr from a HWND/OBJID pair.
//      NOTE: To support any number of IIDs requested from the caller, we 
//      try QIing on the caller-specified riid parameter if our explicit QI on
//      IID_IAccessibleHandler fails.
// 
//  [BrendanM, 9/4/98]
//  Index now passed by parameter, so global var and mutex no longer needed.
//  Called by FindAndCreateWindowClass and CreateStdAccessibleProxyA.
//
//---------------------------------------------------------------------------

HRESULT CreateRegisteredHandler( HWND      hwnd,
                                 long      idObject,
                                 int       iHandlerIndex,
                                 REFIID    riid,
                                 LPVOID *  ppvObject )
{
    HRESULT             hr;
        LPVOID          pv;

        //------------------------------------------------------------
        // TODO: optimize by caching the proxy's object factory pointer.
        //      CoCreateInstance() only needs to be called once per
        //      proxy, not for each request for an object within a proxy.
        //      For satisfying the caller-specific IID, we can just QI
        //      on the cached object factory pointer.
        //------------------------------------------------------------


        //------------------------------------------------------------
        // First QI on IAccessibleHandler directly to retrieve
        // a pointer to the proxy object factory that
        // manufactures accessible objects from object IDs.
        //------------------------------------------------------------

        hr = CoCreateInstance( rgRegisteredTypes[ iHandlerIndex ], 
                           NULL, 
                           CLSCTX_INPROC_SERVER, 
                           IID_IAccessibleHandler, 
                           &pv );

        if ( SUCCEEDED( hr ) )
        {
                //------------------------------------------------------------
                // We must have a qualified proxy since it supports 
                //      IAccessibleHandler, so get the accessible object.
                //------------------------------------------------------------
#ifndef _WIN64
                hr = ((LPACCESSIBLEHANDLER)pv)->AccessibleObjectFromID( (UINT_PTR)hwnd, 
                                                                idObject, 
                                                                (LPACCESSIBLE *)ppvObject );
#else // _WIN64
        hr = E_NOTIMPL;
#endif // _WIN64
                ((LPACCESSIBLEHANDLER)pv)->Release();
        }
        else
        {
                //------------------------------------------------------------
                // Else try using the caller-specific IID
                //------------------------------------------------------------

                hr = CoCreateInstance( rgRegisteredTypes[ iHandlerIndex ], 
                               NULL, 
                               CLSCTX_INPROC_SERVER, 
                               riid, 
                               ppvObject );
        }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\caret.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CARET.CPP
//
//  This file has the implementation of the caret system object.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "caret.h"

// --------------------------------------------------------------------------
// prototypes for local functions
// --------------------------------------------------------------------------
int AddInts (int Value1, int Value2);
BOOL GetDeviceRect (HDC hDestDC,RECT ClientRect,LPRECT lpDeviceRect);

BOOL GetEditCaretOffset( HWND hEdit, int nHeight, int * pnOffset );


BOOL Rect1IsOutsideRect2( RECT const & rc1, RECT const & rc2 );


// --------------------------------------------------------------------------
//
//  CreateCaretObject()
//
// --------------------------------------------------------------------------
HRESULT CreateCaretObject(HWND hwnd, long idObject, REFIID riid, void** ppvCaret)
{
    UNUSED(idObject);

    return(CreateCaretThing(hwnd, riid, ppvCaret));
}



// --------------------------------------------------------------------------
//
//  CreateCaretThing()
//
// --------------------------------------------------------------------------
HRESULT CreateCaretThing(HWND hwnd, REFIID riid, void **ppvCaret)
{
    CCaret * pcaret;
    HRESULT hr;

    InitPv(ppvCaret);

    pcaret = new CCaret();
    if (pcaret)
    {
        if (! pcaret->FInitialize(hwnd))
        {
            delete pcaret;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = pcaret->QueryInterface(riid, ppvCaret);
    if (!SUCCEEDED(hr))
        delete pcaret;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CCaret::FInitialize()
//
// --------------------------------------------------------------------------
BOOL CCaret::FInitialize(HWND hwnd)
{
    // Is this an OK window?
    m_dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
    if (! m_dwThreadId)
        return(FALSE);

    //
    // NOTE:  We always initialize, even if this window doesn't own the
    // caret.  We will treat it as invisible in that case.
    //
    m_hwnd = hwnd;
    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  CCaret::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::Clone(IEnumVARIANT** ppenum)
{
    return(CreateCaretThing(m_hwnd, IID_IEnumVARIANT, (void **)ppenum));
}



// --------------------------------------------------------------------------
//
//  CCaret::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_CARETNAME, pszName));
}



// --------------------------------------------------------------------------
//
//  CCaret::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_CARET;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCaret::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::get_accState(VARIANT varChild, VARIANT * pvarState)
{
    GUITHREADINFO   gui;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (! MyGetGUIThreadInfo(m_dwThreadId, &gui) ||
          (gui.hwndCaret != m_hwnd))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_FALSE);
    }

    if (!(gui.flags & GUI_CARETBLINKING))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCaret::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
GUITHREADINFO   gui;
HDC             hDC;
RECT            rcDevice;
    

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!MyGetGUIThreadInfo(m_dwThreadId, &gui) ||
        (gui.hwndCaret != m_hwnd))
    {
        return(S_FALSE);
    }


    BOOL fWindowsXPOrGreater = FALSE;

    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    osvi.dwMajorVersion = 0;
    osvi.dwMinorVersion = 0;
    GetVersionEx( &osvi );

    if ( osvi.dwMajorVersion >= 5 && osvi.dwMinorVersion >= 1 )
        fWindowsXPOrGreater = TRUE;

    if( ! fWindowsXPOrGreater )
    {
        // Instead of using MapWindowPoints, we use a private
        // function called GetDeviceRect that takes private mapping
        // modes, etc. into account.

        hDC = GetDC (m_hwnd);
        if( !hDC )
            return E_OUTOFMEMORY;

        GetDeviceRect (hDC,gui.rcCaret,&rcDevice);
        ReleaseDC (m_hwnd,hDC);
    }
    else
    {
        // On Windows XP, GDI does all the necessary mapping when
        // SetCaretPos is called, so we only need to do screen->client
        // mapping here.
        rcDevice = gui.rcCaret;
        MapWindowPoints( m_hwnd, NULL, (POINT *) & rcDevice, 2 );
    }
    




    // TODO - only do this for EDITs...
    // Suggest using MyRealGetWindowClass, stricmp against "EDIT"
    // Also get width in addition to offset - for now, assume 0.
    int nOffset;
    TCHAR szWindowClass[128];
    MyGetWindowClass( m_hwnd, szWindowClass, ARRAYSIZE(szWindowClass) );
    if ( lstrcmpi( szWindowClass, TEXT("EDIT") ) == 0 )
    {
        if( GetEditCaretOffset( m_hwnd, rcDevice.bottom - rcDevice.top, & nOffset ) )
        {
            DBPRINTF( TEXT("GetEditCaretOffset nOffset=%d\r\n"), nOffset );

            rcDevice.left -= nOffset;
            rcDevice.right = rcDevice.left + 1;
        }
    }

    // For RichEdits, use an offset of 3???
    //
    if ( lstrcmpi( szWindowClass, TEXT("RICHEDIT20A") ) == 0 ||      // Win9x
        lstrcmpi( szWindowClass, TEXT("RICHEDIT20W") ) == 0 ||      // Win2k + 
        lstrcmpi( szWindowClass, TEXT("RICHEDIT") ) == 0)           // NT4 
    {
        DBPRINTF( TEXT("This is and richedit\r\n") );
        rcDevice.left += 3;
        rcDevice.right = rcDevice.left + 1;
    }




    // Sanity check against returned rect - sometimes we get back
    // gabage cursor coords (of the order of (FFFFB205, FFFFB3C5))
    // - eg. when in notepad, place cursor at top/bottom of doc,
    // click on scrollbar arrowheads to scroll cursor off top/bottom
    // of visible area.
    // We still get back a valid hwnd and a CURSORBLINKING flag fom
    // GetGUIThreadInfo, so they aren't much use to detect this.

    RECT rcWindow;
    GetWindowRect( m_hwnd, & rcWindow );
    if( Rect1IsOutsideRect2( rcDevice, rcWindow ) )
    {
        return S_FALSE;
    }


    *pxLeft = rcDevice.left;
    *pyTop = rcDevice.top;
    *pcxWidth = rcDevice.right - rcDevice.left;
    *pcyHeight = rcDevice.bottom - rcDevice.top;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CCaret::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    GUITHREADINFO gui;
    POINT pt;

    InitPvar(pvarChild);

    if (! MyGetGUIThreadInfo(m_dwThreadId, &gui) ||
        (gui.hwndCaret != m_hwnd))
    {
        return(S_FALSE);
    }

    pt.x = xLeft;
    pt.y = yTop;
    ScreenToClient(m_hwnd, &pt);

    if (PtInRect(&gui.rcCaret, pt))
    {
        pvarChild->vt = VT_I4;
        pvarChild->lVal = 0;
        return(S_OK);
    }
    else
        return(S_FALSE);
}


//============================================================================
// This function takes a destination DC, a rectangle in client coordinates,
// and a pointer to the rectangle structure that will hold the device 
// coordinates of the rectangle. The device coordinates can be used as screen
// coordinates.
//============================================================================
BOOL GetDeviceRect (HDC hDestDC,RECT ClientRect,LPRECT lpDeviceRect)
{
POINT   aPoint;
int	    temp;
    
    lpDeviceRect->left = ClientRect.left;
    lpDeviceRect->top = ClientRect.top;
    
    // just set the device rect to the rect given and then do LPtoDP for both points
    lpDeviceRect->right = ClientRect.right;
    lpDeviceRect->bottom = ClientRect.bottom;
    LPtoDP (hDestDC,(LPPOINT)lpDeviceRect,2);
    
    // Now we need to convert from client coords to screen coords. We do this by 
    // getting the DC Origin and then using the AddInts function to add the origin 
    // of the 'drawing area' to the client coordinates. This is safer and easier 
    // than using ClientToScreen, MapWindowPoints, and/or getting the WindowRect if
    // it is a WindowDC. 
    GetDCOrgEx(hDestDC,&aPoint);
    
    lpDeviceRect->left = AddInts (lpDeviceRect->left,aPoint.x);
    lpDeviceRect->top = AddInts (lpDeviceRect->top,aPoint.y);
    lpDeviceRect->right = AddInts (lpDeviceRect->right,aPoint.x);
    lpDeviceRect->bottom = AddInts (lpDeviceRect->bottom,aPoint.y);
    
    // make sure that the top left is less than the bottom right!!!
    if (lpDeviceRect->left > lpDeviceRect->right)
    {
        temp = lpDeviceRect->right;
        lpDeviceRect->right = lpDeviceRect->left;
        lpDeviceRect->left = temp;
    }
    
    if (lpDeviceRect->top > lpDeviceRect->bottom)
    {
        temp = lpDeviceRect->bottom;
        lpDeviceRect->bottom = lpDeviceRect->top;
        lpDeviceRect->top = temp;
    }
    
    return TRUE;
} // end GetDeviceRect

//============================================================================
// AddInts adds two integers and makes sure that the result does not overflow
// the size of an integer.
// Theory: positive + positive = positive
//         negative + negative = negative
//         positive + negative = (sign of operand with greater absolute value)
//         negative + positive = (sign of operand with greater absolute value)
// On the second two cases, it can't wrap, so I don't check those.
//============================================================================
int AddInts (int Value1, int Value2)
{
int result;
    
    result = Value1 + Value2;
    
    if (Value1 > 0 && Value2 > 0 && result < 0)
        result = INT_MAX;
    
    if (Value1 < 0 && Value2 < 0 && result > 0)
        result = INT_MIN;
    
    return result;
}




#define CURSOR_USA   0xffff
#define CURSOR_LTR   0xf00c
#define CURSOR_RTL   0xf00d
#define CURSOR_THAI  0xf00e

#define LANG_ID(x)      ((DWORD)(DWORD_PTR)x & 0x000003ff);

#ifndef SPI_GETCARETWIDTH
#define SPI_GETCARETWIDTH                   0x2006
#endif


// GetEditCaretOffset
//
// Determine the offset to the actual caret bar from the start
// of the caret bitmap.
//
// Only applies to EDIT controls, not RichEdits.
//
// This code is based on \windows\core\cslpk\lpk\lpk_edit.c, (EditCreateCaret)
// which does the actual caret processing for the edit control. We mimic that
// code, leaving out the bits that we don't need.


WCHAR GetEditCursorCode( HWND hEdit )
{
    DWORD idThread = GetWindowThreadProcessId( hEdit, NULL );

    UINT uikl = LANG_ID( GetKeyboardLayout( idThread ) );

    WCHAR wcCursorCode = CURSOR_USA;

    switch( uikl )
    {
        case LANG_THAI:    wcCursorCode = CURSOR_THAI;  break;

        case LANG_ARABIC:
        case LANG_FARSI:
        case LANG_URDU:
        case LANG_HEBREW:  wcCursorCode = CURSOR_RTL;   break;

        default:

            WCHAR wcBuf[ 80 ];   // Registry read buffer
            int cBuf;
            cBuf = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_FONTSIGNATURE, wcBuf, ARRAYSIZE( wcBuf ) );
            BOOL fUserBidiLocale = ( cBuf && wcBuf[7] & 0x0800 ) ? TRUE : FALSE;

            if( fUserBidiLocale )
            {
                // Other keyboards have a left-to-right pointing caret
                // in Bidi locales.
                wcCursorCode = CURSOR_LTR;
            }
    }

    return wcCursorCode;
}


BOOL GetEditCaretOffsetFromFont( HWND hEdit, WCHAR wcCursorCode, int nHeight, int * pnOffset )
{
    if( wcCursorCode != CURSOR_RTL )
    {
        *pnOffset = 0;
        return TRUE;
    }


    BOOL fGotIt = FALSE;

    HDC hDC = GetDC( hEdit );

    int nWidth;
    SystemParametersInfo( SPI_GETCARETWIDTH, 0, (LPVOID) & nWidth, 0 );

    HFONT hFont = CreateFont( nHeight, 0, 0, 0, nWidth > 1 ? 700 : 400,
                0L, 0L, 0L, 1L, 0L, 0L, 0L, 0L, TEXT("Microsoft Sans Serif") );

    if( hFont )
    {
        HFONT hfOld = SelectFont( hDC, hFont );

        ABC abcWidth;
        if( GetCharABCWidths( hDC, wcCursorCode, wcCursorCode, & abcWidth ) )
        {
            *pnOffset = 1 - (int) abcWidth.abcB;
            fGotIt = TRUE;
        }

        SelectFont( hDC, hfOld );
        DeleteFont( hFont );
    }

    ReleaseDC( hEdit, hDC );

    return fGotIt;
}


BOOL GetEditCaretOffset( HWND hEdit, int nHeight, int * pOffset )
{
    WCHAR wcCursorCode = GetEditCursorCode( hEdit );

    if( wcCursorCode != CURSOR_USA )
    {
        return GetEditCaretOffsetFromFont( hEdit, wcCursorCode, nHeight, pOffset );
    }
    else
    {
        *pOffset = 0;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\classinfo.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  classinfo
//
//  Information about the individual proxy classes
//
//  We could put this information in each class; but that would mean that
//  changes would require touching all the class files.
//  Centralizing this means that we only have a couple of files to change
//  if we need to add more information across all classes.
//
// --------------------------------------------------------------------------


typedef HRESULT (* LPFNCREATE)(HWND, long, REFIID, void**);


//
// lpfnCreate and fBitAgnostic are only used by classes created via the classmap.
//

struct CLASSINFO
{
    LPFNCREATE  lpfnCreate;
    BOOL        fBitAgnostic;           // Works across 64/32 boundaries

    LPCTSTR     szClassName;            // Friendly name of class to use in version info


    BOOL        fSupportsAnnotation;    // Is annotation supported? 
    DWORD       dwObjId;                // Objid used when building annotation key.
};


extern CLASSINFO g_ClassInfo[ ];


// This list must be kept in sync with the array of classinfo's.
enum CLASS_ENUM
{
    CLASS_NONE = -1, // For classes that don't use the classinfo.

    // General non-client stuff

    CLASS_CaretObject = 0,
    CLASS_ClientObject,
    CLASS_CursorObject,
    CLASS_MenuBarObject,
    CLASS_ScrollBarObject,
    CLASS_SizeGripObject,
    CLASS_SysMenuBarObject,
    CLASS_TitleBarObject,
    CLASS_WindowObject,

    // Client types - USER

    CLASS_ButtonClient,
    CLASS_ComboClient,
    CLASS_DialogClient,
    CLASS_DesktopClient,
    CLASS_EditClient,
    CLASS_ListBoxClient,
    CLASS_MDIClient,
    CLASS_MenuPopupClient,
    CLASS_ScrollBarClient,
    CLASS_StaticClient,
    CLASS_SwitchClient,

    // Client types - ComCtl32

    CLASS_StatusBarClient,
    CLASS_ToolBarClient,
    CLASS_ProgressBarClient,
    CLASS_AnimatedClient,
    CLASS_TabControlClient,
    CLASS_HotKeyClient,
    CLASS_HeaderClient,
    CLASS_SliderClient,
    CLASS_ListViewClient,
    CLASS_UpDownClient,
    CLASS_ToolTipsClient,
    CLASS_TreeViewClient,
    CLASS_CalendarClient,
    CLASS_DatePickerClient,
    CLASS_IPAddressClient,

#ifndef OLEACC_NTBUILD
    CLASS_HtmlClient,

    // SDM32

    CLASS_SdmClientA,
#endif OLEACC_NTBUILD

    // Window types

    CLASS_ListBoxWindow,
    CLASS_MenuPopupWindow,

    // Other classes - these are created directly - and don't appear in the classmaps
    CLASS_MenuObject,
    CLASS_MenuItemObject,

#ifndef OLEACC_NTBUILD
    CLASS_HtmlImageMap,
    CLASS_SdmList,
#endif // OLEACC_NTBUILD

    CLASS_LAST // Must be last entry; value = # of classes.
};



// All classes up to (but excluding) this one can be referred to by index values
// when sending  WM_GETOBJECT/OBJID_QUERYCLASSNAMEIDX.
#define QUERYCLASSNAME_CLASSES     (CLASS_IPAddressClient+1)

// We actually use (index + 65536) - to keep the return value
// out of the way of apps which return small intergers for
// WM_GETOBJECT even though they shouldn't (ie. Notes)
#define QUERYCLASSNAME_BASE        65536
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\client.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CLIENT.H
//
//  Default window client OLE accessible object class
//
// --------------------------------------------------------------------------


class CClient : public CAccessible
{
        // internal ctor. Private so taht derived classes don't inadvertantly use this -
        // they should use the one below (*where they specify a CLASS_ENUM) instead.
        // CreateClient is a friend so it can create us (using new).

        CClient()
            : CAccessible( CLASS_ClientObject )
        {
            // Done.
        }

        friend HRESULT CreateClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject);

    public:

        // Used by derived classes
        CClient( CLASS_ENUM eclass )
            : CAccessible( eclass )
        {
            // Done.
        }

        // IAccessible
        virtual STDMETHODIMP        get_accChildCount(long * pcCount);

        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accFocus(VARIANT * pvarFocus);

        virtual STDMETHODIMP        accLocation(long* pxLeft, long* pyTop,
            long *pcxWidth, long *pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP        accSelect(long lSelFlags, VARIANT varChild);
        virtual STDMETHODIMP        accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd);
        virtual STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT *pvarHit);

        // IEnumVARIANT
        virtual STDMETHODIMP        Next(ULONG celt, VARIANT *rgelt, ULONG *pceltFetched);
        virtual STDMETHODIMP        Skip(ULONG celt);
        virtual STDMETHODIMP        Reset(void);
        virtual STDMETHODIMP        Clone(IEnumVARIANT **);

        void    Initialize(HWND hwnd, long idCurChild);
        BOOL    ValidateHwnd(VARIANT* pvar);

    protected:
        BOOL    m_fUseLabel;
};


extern HRESULT CreateClient(HWND hwnd, long idChild, REFIID riid, void** ppvObject);


// See comments in client.cpp for details on these.
// (A HWNDID is a HWND encoded in a DWORD idChild, these do the checking, encoding
// and decoding.)
BOOL IsHWNDID( DWORD id );
DWORD HWNDIDFromHwnd( HWND hwndParent, HWND hwnd );
HWND HwndFromHWNDID( HWND hwndParent, DWORD id );


//
// When enumerating, we loop through non-hwnd items first, then hwnd-children.
//
extern TCHAR    StripMnemonic(LPTSTR lpsz);
extern LPTSTR   GetTextString(HWND, BOOL);
extern LPTSTR   GetLabelString(HWND);
extern HRESULT  HrGetWindowName(HWND, BOOL, BSTR*);
extern HRESULT  HrGetWindowShortcut(HWND, BOOL, BSTR*);
extern HRESULT  HrMakeShortcut(LPTSTR, BSTR*);

#define SHELL_TRAY      1
#define SHELL_DESKTOP   2
#define SHELL_PROCESS   3
extern BOOL     InTheShell(HWND, int);

extern BOOL     IsComboEx(HWND);
extern HWND     IsInComboEx(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\client.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CLIENT.CPP
//
//  Window client class.
//
//  This handles navigation to other frame elements, and does its best
//  to manage the client area.  We recognize special classes, like listboxes,
//  and those have their own classes to do stuff.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "debug.h"


#define CH_PREFIX       ((TCHAR)'&')
#define CCH_WINDOW_SHORTCUTMAX  32
#define CCH_SHORTCUT            16


extern HRESULT  DirNavigate(HWND, long, VARIANT *);


// --------------------------------------------------------------------------
//
//  CreateClientObject()
//
//  EXTERNAL function for CreatStdOle...
//
// --------------------------------------------------------------------------
HRESULT CreateClientObject(HWND hwnd, long idObject, REFIID riid, void** ppvObject)
{
    UNUSED(idObject);

    InitPv(ppvObject);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateClient as default if none found.
    // (FALSE => use client, as opposed to window, classes)
    return FindAndCreateWindowClass( hwnd, FALSE, CLASS_ClientObject,
                                     OBJID_CLIENT, 0, riid, ppvObject );
}



// --------------------------------------------------------------------------
//
//  CreateClient()
//
//  INTERNAL function for CreateClientObject() and ::Clone()
//
// --------------------------------------------------------------------------
HRESULT CreateClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject)
{
    CClient * pclient;
    HRESULT hr;

    pclient = new CClient();
    if (!pclient)
        return(E_OUTOFMEMORY);

    pclient->Initialize(hwnd, idChildCur);

    hr = pclient->QueryInterface(riid, ppvObject);
    if (!SUCCEEDED(hr))
        delete pclient;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CClient::Initialize()
//
// --------------------------------------------------------------------------
void CClient::Initialize(HWND hwnd, long idChildCur)
{
    m_hwnd = hwnd;
    m_idChildCur = idChildCur;

    // If this is a comboex32, we want to pick up a preceeding
    // label, if one exists (just like we do for regular combos -
    // which set m_fUseLabel to TRUE in their own ::Initialize().
    // The combo will ask the parent comboex32 for its name, and
    // it in turn will look for a label.
    if( IsComboEx( m_hwnd ) )
    {
        m_fUseLabel = TRUE;
    }
}



// --------------------------------------------------------------------------
//
//  CClient::ValidateHwnd()
//
//  This will validate VARIANTs for both HWND-children clients and normal
//  clients.   If m_cChildren is non-zero, 
//
// --------------------------------------------------------------------------
BOOL CClient::ValidateHwnd(VARIANT* pvar)
{
    HWND    hwndChild;
    switch (pvar->vt)
    {
        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

#ifdef VT_I2_IS_VALID      // It should not be valid. That's why this is removed.
        case VT_I2:
            pvar->vt = VT_I4;
            pvar->lVal = (long)pvar->iVal;
            // FALL THROUGH
#endif

        case VT_I4:
            if (pvar->lVal == 0)
                break;

            hwndChild = HwndFromHWNDID(m_hwnd, pvar->lVal);

            // This works for top-level AND child windows
            if (MyGetAncestor(hwndChild, GA_PARENT) != m_hwnd)
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}




// --------------------------------------------------------------------------
//
//  CClient::get_accChildCount()
//
//  This handles both non-HWND and HWND children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accChildCount(long *pcCount)
{
    HWND    hwndChild;
    HRESULT hr;

    hr = CAccessible::get_accChildCount(pcCount);
    if (!SUCCEEDED(hr))
        return hr;

    // popup menus (CMenuPopup) can have a NULL hwnd if created for an 'invisible'
    // menu. We probably shouldn't create them in the first place, but don't want
    // to change what objects we expose at this stage - so instead special case
    // NULL. This is to avoid calling GetWindow( NULL ), which would produce
    // debug output complaining, and those annoy the stress team.
    if( m_hwnd != NULL )
    {
        for (hwndChild = ::GetWindow(m_hwnd, GW_CHILD); hwndChild; hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT))
            ++(*pcCount);
    }

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accName(VARIANT varChild, BSTR *pszName)
{
    InitPv(pszName);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrGetWindowName(m_hwnd, m_fUseLabel, pszName));
}



// --------------------------------------------------------------------------
//
//  CClient::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_CLIENT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    WINDOWINFO wi;
    HWND       hwndActive;

    InitPvar(pvarState);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // Are we the focus?  Are we enabled, visible, etc?
    //
    if (!MyGetWindowInfo(m_hwnd, &wi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    if (!(wi.dwStyle & WS_VISIBLE))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    if (wi.dwStyle & WS_DISABLED)
        pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

    if (MyGetFocus() == m_hwnd)
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;

    hwndActive = GetForegroundWindow();

    if (hwndActive == MyGetAncestor(m_hwnd, GA_ROOT))
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    //
    // Validate--this does NOT accept a child ID
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    // reject child elements - shortcut key only applies to the overall
    // control.
    if ( varChild.lVal != 0 )
        return(E_NOT_APPLICABLE);

    return(HrGetWindowShortcut(m_hwnd, m_fUseLabel, pszShortcut));
}


// --------------------------------------------------------------------------
//
//  CClient::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accFocus(VARIANT *pvarFocus)
{
    HWND    hwndFocus;

    InitPvar(pvarFocus);

    //
    // This RETURNS a child ID.
    //
    hwndFocus = MyGetFocus();

    //
    // Is the current focus a child of us?
    //
    if (m_hwnd == hwndFocus)
    {
        pvarFocus->vt = VT_I4;
        pvarFocus->lVal = 0;
    }
    else if (IsChild(m_hwnd, hwndFocus))
        return(GetWindowObject(hwndFocus, pvarFocus));

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    RECT    rc;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate--this does NOT take a child ID
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    MyGetRect(m_hwnd, &rc, FALSE);
    MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);

    *pxLeft = rc.left;
    *pyTop = rc.top;
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accSelect( long lSelFlags, VARIANT varChild )
{
    if( ! ValidateChild( & varChild ) ||
        ! ValidateSelFlags( lSelFlags ) )
        return E_INVALIDARG;

    if( lSelFlags != SELFLAG_TAKEFOCUS )
        return E_NOT_APPLICABLE;

    if( varChild.lVal )
        return S_FALSE;

    MySetFocus( m_hwnd );

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accNavigate(long dwNavDir, VARIANT varStart, VARIANT * pvarEnd)
{
    HWND    hwndChild;
    int     gww;

    InitPvar(pvarEnd);

    //
    // Validate--this accepts an HWND id.
    //
    if (!ValidateHwnd(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        gww = GW_HWNDNEXT;
        hwndChild = ::GetWindow(m_hwnd, GW_CHILD);
        if (!hwndChild)
            return(S_FALSE);

        goto NextPrevChild;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        gww = GW_HWNDPREV;

        hwndChild = ::GetWindow(m_hwnd, GW_CHILD);
        if (!hwndChild)
            return(S_FALSE);

        // Start at the end and work backwards
        hwndChild = ::GetWindow(hwndChild, GW_HWNDLAST);

        goto NextPrevChild;
    }
    else if (!varStart.lVal)
        return(GetParentToNavigate(OBJID_CLIENT, m_hwnd, OBJID_WINDOW,
            dwNavDir, pvarEnd));

    hwndChild = HwndFromHWNDID(m_hwnd, varStart.lVal);

    if ((dwNavDir == NAVDIR_NEXT) || (dwNavDir == NAVDIR_PREVIOUS))
    {
        gww = ((dwNavDir == NAVDIR_NEXT) ? GW_HWNDNEXT : GW_HWNDPREV);

        while (hwndChild = ::GetWindow(hwndChild, gww))
        {
NextPrevChild:
            if (IsWindowVisible(hwndChild))
                return(GetWindowObject(hwndChild, pvarEnd));
        }
    }
    else
        return(DirNavigate(hwndChild, dwNavDir, pvarEnd));

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CClient::accHitTest()
//
//  This ALWAYS returns a real object.
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    HWND    hwndChild;
    POINT   pt;

    InitPvar(pvarHit);

    pt.x = xLeft;
    pt.y = yTop;
    ScreenToClient(m_hwnd, &pt);

    hwndChild = MyRealChildWindowFromPoint(m_hwnd, pt);
    if (hwndChild)
    {
        if (hwndChild == m_hwnd)
        {
            pvarHit->vt = VT_I4;
            pvarHit->lVal = 0;
            return(S_OK);
        }
        else
            return(GetWindowObject(hwndChild, pvarHit));
    }
    else
    {
        // Null window means point isn't in us at all...
        return(S_FALSE);
    }
}



// --------------------------------------------------------------------------
//
//  CClient::Next()
//
//  This loops through non-HWND children first, then HWND children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched)
{
    HWND    hwndChild;
    VARIANT* pvar;
    long    cFetched;
    HRESULT hr;

    if( m_idChildCur == -1 )
    {
        // If we're at the end, can't return any more...
        *pceltFetched = 0;
        return celt == 0 ? S_OK : S_FALSE;
    }

    SetupChildren();

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    // Grab the non-HWND dudes first.
    if (!IsHWNDID(m_idChildCur) && (m_idChildCur < m_cChildren))
    {
        cFetched = 0;

        hr = CAccessible::Next(celt, rgvar, (ULONG*)&cFetched);
        if (!SUCCEEDED(hr))
            return hr;

        celt -= cFetched;
        rgvar += cFetched;

        if (pceltFetched)
            *pceltFetched += cFetched;

        if (!celt)
            return S_OK;
    }


    pvar = rgvar;
    cFetched = 0;

    if (!IsHWNDID(m_idChildCur))
    {
        Assert(m_idChildCur == m_cChildren);
        hwndChild = ::GetWindow(m_hwnd, GW_CHILD);
    }
    else
    {
        hwndChild = HwndFromHWNDID(m_hwnd, m_idChildCur);
    }

    //
    // Loop through our HWND children now
    //
    while (hwndChild && (cFetched < (long)celt))
    {
        hr = GetWindowObject(hwndChild, pvar);
        if (SUCCEEDED(hr))
        {
            ++pvar;
            ++cFetched;
        }
        else
        {
            // Failed - skip this one - but keep going.
            TraceWarningHR( hr, TEXT("CClient::Next - GetWindowObject failed on hwnd 0x%p, skipping"), hwndChild );
        }

        hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
    }

    // Remember current position
    // Have to special-case NULL - GetWindow(...) returns NULL
    // when we reach the end - have to store a special value
    // so we know that we're at the end the next time we're
    // called.
    if( hwndChild == NULL )
        m_idChildCur = -1;
    else
        m_idChildCur = HWNDIDFromHwnd(m_hwnd, hwndChild);

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched += cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return (cFetched < (long)celt) ? S_FALSE : S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Skip(ULONG celt)
{
    HWND    hwndT;

    if( m_idChildCur == -1 )
    {
        // If we're at the end, can't return any more...
        return celt == 0 ? S_FALSE : S_OK;
    }

    SetupChildren();

    // Skip non-HWND items
    if (!IsHWNDID(m_idChildCur) && (m_idChildCur < m_cChildren))
    {
        long    dAway;

        dAway = m_cChildren - m_idChildCur;
        if (celt >= (DWORD)dAway)
        {
            celt -= dAway;
            m_idChildCur = m_cChildren;
        }
        else
        {
            m_idChildCur += celt;
            return S_OK;
        }
    }

    // Skip the HWND children next
    if (!IsHWNDID(m_idChildCur))
    {
        Assert(m_idChildCur == m_cChildren);
        hwndT = ::GetWindow(m_hwnd, GW_CHILD);
    }
    else
        hwndT = HwndFromHWNDID(m_hwnd, m_idChildCur);

    while (hwndT && (celt-- > 0))
    {
        hwndT = ::GetWindow(hwndT, GW_HWNDNEXT);
    }

    // Remember current position
    // Have to special-case NULL - GetWindow(...) returns NULL
    // when we reach the end - have to store a special value
    // so we know that we're at the end the next time we're
    // called.
    if( hwndT == NULL )
        m_idChildCur = -1;
    else
        m_idChildCur = HWNDIDFromHwnd(m_hwnd, hwndT);

    return celt ? S_FALSE : S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Reset(void)
{
    m_idChildCur = 0;
    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Clone(IEnumVARIANT** ppenum)
{
    InitPv(ppenum);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateClient as default if none found.
    // (FALSE => use client, as opposed to window, classes)
    return FindAndCreateWindowClass( m_hwnd, FALSE, CLASS_ClientObject,
                  OBJID_CLIENT, m_idChildCur, IID_IEnumVARIANT, (void **)ppenum );
}




// --------------------------------------------------------------------------
//
//  GetTextString()
//
//  Parameters: hwnd of the window to get the text from, and a boolean
//  that indicates whether or not we should always allocate memory to
//  return. I.E., if the window says the size of the text is 0, and
//  fAllocIfEmpty is TRUE, then we'll still allocate 1 byte (size+1).
//
// This contains a bit of a hack. The way it was originally written, this
// will try to get the ENTIRE text of say, a RichEdit control, even if that
// document is HUGE. Eventually we want to support that, but we are going to 
// need to do better than LocalAlloc. With a big document, we would page
// fault sometimes, because even though the memory is allocated, it
// may not be able to be paged in. JeffBog suggested that the way to
// check is to try to read/write both ends of the allocated space, and
// assume that if that works everything in between is OK too.
//
// So here's the temporary hack (BOGUS!)
// I am putting an artificial limit of 4096 bytes on the allocation.
// I am also going to do IsBadWritePtr on the thing, instead of just 
// checking if the pointer returned by alloc is null. duh.
// --------------------------------------------------------------------------
LPTSTR GetTextString(HWND hwnd, BOOL fAllocIfEmpty)
{
    UINT    cchText;
    LPTSTR  lpText;
#define MAX_TEXT_SIZE   4096

    //
    // Look for a name property!
    //

    lpText = NULL;

    if (!IsWindow(hwnd))
        return (NULL);
    //
    // Barring that, use window text.
    // BOGUS!  Strip out the '&'.
    //
    cchText = SendMessageINT(hwnd, WM_GETTEXTLENGTH, 0, 0);

    // hack
    cchText = (cchText > MAX_TEXT_SIZE ? MAX_TEXT_SIZE : cchText);

    // Allocate a buffer
    if (cchText || fAllocIfEmpty)
    {
        lpText = (LPTSTR)LocalAlloc(LPTR, (cchText+1)*sizeof(TCHAR));
        if (IsBadWritePtr (lpText,cchText+1))
            return(NULL);


        if (cchText)
            SendMessage(hwnd, WM_GETTEXT, cchText+1, (LPARAM)lpText);
    }

    return(lpText);
}



// --------------------------------------------------------------------------
//
//  GetLabelString()
//
//  This walks backwards among peer windows to find a static field.  It stops
//  if it gets to the front or hits a group/tabstop, just like the dialog 
//  manager does.
//
// --------------------------------------------------------------------------
LPTSTR GetLabelString(HWND hwnd)
{
    HWND    hwndLabel;
    LONG    lStyle;
    LRESULT lResult;
    LPTSTR  lpszLabel;

    lpszLabel = NULL;

    if (!IsWindow(hwnd))
        return (NULL);

    hwndLabel = hwnd;

    while (hwndLabel = ::GetWindow(hwndLabel, GW_HWNDPREV))
    {
        lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

        //
        // Is this a static dude?
        //
        lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0L);
        if (lResult & DLGC_STATIC)
        {
            //
            // Great, we've found our label.
            //
            lpszLabel = GetTextString(hwndLabel, FALSE);
            break;
        }


        //
        // Skip if invisible
        // Note that we do this after checking if its a staic,
        // so that we give invisible statics a chance. Using invisible
        // statics is a easy workaround to add names to controls
        // without changing the visual UI.
        //
        if (!(lStyle & WS_VISIBLE))
            continue;

        
        //
        // Is this a tabstop or group?  If so, bail out now.
        //
        if (lStyle & (WS_GROUP | WS_TABSTOP))
            break;
    }

    return(lpszLabel);
}



// --------------------------------------------------------------------------
//
//  HrGetWindowName()
//
// --------------------------------------------------------------------------
HRESULT HrGetWindowName(HWND hwnd, BOOL fLookForLabel, BSTR* pszName)
{
    LPTSTR  lpText;

    lpText = NULL;
    if (!IsWindow(hwnd))
        return (E_INVALIDARG);

    //
    // Look for a name property!
    //

    //
    // If use a label, do that instead
    //
    if (!fLookForLabel)
    {
        // 
        // Try using a label anyway if this control has no window text
        // and the parent is a dialog.
        //
        lpText = GetTextString(hwnd, FALSE);
        if (!lpText)
        {
            HWND hwndParent = MyGetAncestor( hwnd, GA_PARENT );
            if( hwndParent && CLASS_DialogClient == GetWindowClass( hwndParent ) )
            {
                fLookForLabel = TRUE;
            }
        }
    }

    if (fLookForLabel)
        lpText = GetLabelString(hwnd);

    if (! lpText)
        return(S_FALSE);

    //
    // Strip out the mnemonic.
    //
    StripMnemonic(lpText);

    // Get a BSTR
    *pszName = TCharSysAllocString(lpText);

    // Free our buffer
    LocalFree((HANDLE)lpText);

    // Did the BSTR succeed?
    if (! *pszName)
        return(E_OUTOFMEMORY);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  HrGetWindowShortcut()
//
// --------------------------------------------------------------------------
HRESULT HrGetWindowShortcut(HWND hwnd, BOOL fUseLabel, BSTR* pszShortcut)
{
    //
    // Get the window text, and see if the '&' character is in it.
    //
    LPTSTR  lpText;
    TCHAR   chMnemonic;

    if (!IsWindow(hwnd))
        return (E_INVALIDARG);

    lpText = NULL;

    if (! fUseLabel)
    {
        //
        // Try using a label anyway if this control has no window text
        // and the parent is a dialog.
        //
        lpText = GetTextString(hwnd, FALSE);
        if (!lpText)
        {
            HWND  hwndParent = MyGetAncestor( hwnd, GA_PARENT );
            if( hwndParent && CLASS_DialogClient == GetWindowClass( hwndParent ) )
            {
                fUseLabel = TRUE;
            }
        }
    }

    if (fUseLabel)
        lpText = GetLabelString(hwnd);

    if (! lpText)
        return(S_FALSE);

    chMnemonic = StripMnemonic(lpText);
    LocalFree((HANDLE)lpText);

    //
    // Is there a mnemonic?
    //
    if (chMnemonic)
    {
        //
        // Make a string of the form "Alt+ch".
        //
        TCHAR   szKey[2];

        *szKey = chMnemonic;
        *(szKey+1) = 0;

        return(HrMakeShortcut(szKey, pszShortcut));
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  HrMakeShortcut()
//
//  This takes a string for the hotkey, then combines it with the "Alt+%s"
//  shortcut format to make the real string combination.  If asked, it will
//  free the hotkey string passed in.
//
// --------------------------------------------------------------------------
HRESULT HrMakeShortcut(LPTSTR lpszKey, BSTR* pszShortcut)
{
    TCHAR   szFormat[CCH_SHORTCUT];
    TCHAR   szResult[CCH_WINDOW_SHORTCUTMAX];

    // Get the format string
    LoadString(hinstResDll, STR_MENU_SHORTCUT_FORMAT, szFormat,
        ARRAYSIZE(szFormat));

    // Make the result
    wsprintf(szResult, szFormat, lpszKey);

    // Alloc a BSTR of the result
    *pszShortcut = TCharSysAllocString(szResult);

    // Should we free the key string?
    // Did the allocation fail?
    if (!*pszShortcut)
        return(E_OUTOFMEMORY);
    else
        return(S_OK);
}



// 'Slide' string along by one char, in-place, to effectively remove the
// char pointed to be pStr.
// eg. if pStr points to the 'd' of 'abcdefg', the string
// will be transformed to 'abcefg'.
// Note: the char pointed to by pStr is assumed to be a single-byte
// char (if compiled under ANSI - not an issue if compiled inder UNICODE)
// Note: Makes use of the fact that no DBCS char has NUL as the trail byte.
void SlideStrAndRemoveChar( LPTSTR pStr )
{
    LPTSTR pLead = pStr + 1;
    // Checking the trailing pStr ptr means that we continue until we've
    // copied (not just encountered) the terminating NUL.
    while( *pStr )
        *pStr++ = *pLead++;
}



// --------------------------------------------------------------------------
//
//  StripMnemonic()
//
//  This removes the mnemonic prefix.  However, if we see '&&', we keep
//  one '&'.
//
//
//  Modified to be DBCS 'aware' - uses CharNext() instead of ptr++ to
//  advance through the string. Will only return shortcut char if its a 
//  single byte char, though. (Would have to change all usages of this
//  function to allow return of a potentially DBCS char.) Will remove this
//  restriction in the planned-for-future fully-UNICODE OLEACC.
//  This restriction should not be much of a problem, because DBCS chars,
//  which typically require an IME to compose, are very unlikely to be
//  used as 'shortcut' chars. eg. Japanese Windows uses underlined roman
//  chars as shortcut chars.
//  (This will all be replaced by simpler code when we go UNICODE...)
// --------------------------------------------------------------------------
TCHAR StripMnemonic(LPTSTR lpszText)
{
    TCHAR   ch;
    TCHAR   chNext = 0;

    while( *lpszText == (TCHAR)' ' )
        lpszText = CharNext( lpszText );

    while( ch = *lpszText )
    {
        lpszText = CharNext( lpszText );

        if (ch == CH_PREFIX)
        {
            // Get the next character.
            chNext = *lpszText;

            // If it too is '&', then this isn't a mnemonic, it's the 
            // actual '&' character.  
            if (chNext == CH_PREFIX)
                chNext = 0;
            
            // Skip 'n' strip the '&' character
            SlideStrAndRemoveChar( lpszText - 1 );

#ifdef UNICODE
            CharLowerBuff(&chNext, 1);
#else
            if( IsDBCSLeadByte( chNext ) )
            {
                // We're ignoring DBCS chars as shortcut chars
                // - would need to change this func and all callers
                // to handle a returned DB char otherwise.
                // For the moment, we just ensure we don't return
                // an 'orphaned' lead byte...
                chNext = '\0';
            }
            else
            {
                CharLowerBuff(&chNext, 1);
            }
#endif
            break;
        }
    }

    return(chNext);
}



// --------------------------------------------------------------------------
//
//  DirNavigate()
//
//  Figures out which peer window is closest to us in the given direction.
//
// --------------------------------------------------------------------------
HRESULT DirNavigate(HWND hwndSelf, long dwNavDir, VARIANT* pvarEnd)
{
    HWND    hwndPeer;
    RECT    rcSelf;
    RECT    rcPeer;
    int     dwClosest;
    int     dwT;
    HWND    hwndClosest;

    if (!IsWindow(hwndSelf))
        return (E_INVALIDARG);

    MyGetRect(hwndSelf, &rcSelf, TRUE);

    dwClosest = 0x7FFFFFFF;
    hwndClosest = NULL;

    for (hwndPeer = ::GetWindow(hwndSelf, GW_HWNDFIRST); hwndPeer;
         hwndPeer = ::GetWindow(hwndPeer, GW_HWNDNEXT))
    {
        if ((hwndPeer == hwndSelf) || !IsWindowVisible(hwndPeer))
            continue;

        MyGetRect(hwndPeer, &rcPeer, TRUE);

        dwT = 0x7FFFFFFF;

        switch (dwNavDir)
        {
            case NAVDIR_LEFT:
                //
                // Bogus!  Only try this one if it intersects us vertically
                //
                if (rcPeer.left < rcSelf.left)
                    dwT = rcSelf.left - rcPeer.left;
                break;

            case NAVDIR_UP:
                //
                // Bogus!  Only try this one if it intersects us horizontally
                //
                if (rcPeer.top < rcSelf.top)
                    dwT = rcSelf.top - rcPeer.top;
                break;

            case NAVDIR_RIGHT:
                //
                // Bogus!  Only try this one if it intersects us vertically
                //
                if (rcPeer.right > rcSelf.right)
                    dwT = rcPeer.right - rcSelf.right;
                break;

            case NAVDIR_DOWN:
                //
                // Bogus!  Only try this one if it intersects us horizontally
                //
                if (rcPeer.bottom > rcSelf.bottom)
                    dwT = rcPeer.bottom - rcSelf.bottom;
                break;

            default:
                AssertStr( TEXT("INVALID NAVDIR") );
        }

        if (dwT < dwClosest)
        {
            dwClosest = dwT;
            hwndClosest = hwndPeer;
        }
    }

    if (hwndClosest)
        return(GetWindowObject(hwndClosest, pvarEnd));
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  InTheShell()
//
//  Returns TRUE if the object is on the shell tray, desktop, or process.
//
// --------------------------------------------------------------------------
BOOL InTheShell(HWND hwnd, int nPart)
{
    HWND    hwndShell;
    static  TCHAR szShellTray[] = TEXT("Shell_TrayWnd");
    DWORD   idProcessUs;
    DWORD   idProcessShell;

    hwndShell = GetShellWindow();

    switch (nPart)
    {
        case SHELL_TRAY:
            // Use the tray window instead.
            hwndShell = FindWindowEx(NULL, NULL, szShellTray, NULL);
            // Fall thru

        case SHELL_DESKTOP:
            if (!hwndShell)
                return(FALSE);
            return(MyGetAncestor(hwnd, GA_ROOT) == hwndShell);

        case SHELL_PROCESS:
            idProcessUs = NULL;
            idProcessShell = NULL;
            GetWindowThreadProcessId(hwnd, &idProcessUs);
            GetWindowThreadProcessId(hwndShell, &idProcessShell);
            return(idProcessUs && (idProcessUs == idProcessShell));
    }

    AssertStr( TEXT("GetShellWindow returned strange part") );
    return(FALSE);
}













// --- start of original comment ---
//
//   We need a way for HWND and non-HWND children to live in the same
//   namespace together.  Since children pass up peer-to-peer navigation to
//   their parent, we need a way for HWND children to identify themselves in
//   the navigate call.  Since HWND children are always objects, it is fine
//   for the client parent to not accept HWND ids in all other methods.  One
//   can do it, but it is a lot of work.
//
//   Examples to date of mixed:
//        (1) Comboboxes (dropdown always a window, cur item may or may not be,
//            button never is)
//        (2) Toolbars (dropdown is a window, buttons aren't)
//
//   We want the client manager to handle IEnumVARIANT, validation, etc.
//
// --- end of original comment ---
//
// A 'HWNDID' is basically a HWND squeezed (somehow) into a DWORD idChild.
//
// IsHWNDID checks if a idChild is one of these HWNDIDs, or just a regular
// idChild (ie. a 1-based child element index)
//
// HWNDIDFromHwnd and HwndFromHWNDID encode and decode HWNDs as idChilds.
//
// Previous versions of these didn't have a hwndParent parameter,
// and squeezed a HWND into bits 0..30, with bit31 set to 1 as the
// 'this is a HWND id' flag. That scheme doesn't work for HWNDs
// which have bt31 set... (these do exist on long-running systems -
// the top WORD of the HWND is a 'uniqueifier', which gets inc'd every
// time the slot - indicated by the bottom HWND - is reused. Of course,
// this implementation can change at any time in the furure, so we
// shouldn't rely on it, or rely on any bits being 'always 0' or
// otherwise.)
//
// The current sceheme still uses the high bit as a flag, but if set,
// the remaining bits are now a count into the parent window's children
// chain.
//
//
// It may be possible to remove these althogther - if the destination object
// corresponds to a full HWND, instead of returning a HWNDID, instead return
// the full IAccessible for that object. (Still have to figure out what happens
// when that IAccessible needs to navigate to one of its siblings, though.)

BOOL IsHWNDID( DWORD id )
{
    // hight bit indicates that it represents a HWND.
    return id & 0x80000000;
}

DWORD HWNDIDFromHwnd( HWND hwndParent, HWND hwnd )
{
    // Traverse the child list, counting as we go, till we hit the HWND we want...
    int i = 0;
    HWND hChild = GetWindow( hwndParent, GW_CHILD );

    while( hChild != NULL )
    {
        if( hChild == hwnd )
        {
            return i | 0x80000000;
        }

        i++;
        hChild = GetWindow( hChild, GW_HWNDNEXT );
    }

    return 0;
}

HWND HwndFromHWNDID( HWND hwndParent, DWORD id )
{
    // Traverse the child list, till we get to the one with this index...
    int i = id & ~ 0x80000000;

    HWND hChild = GetWindow( hwndParent, GW_CHILD );

    while( i != 0 && hChild != NULL )
    {
        i--;
        hChild = GetWindow( hChild, GW_HWNDNEXT );
    }

    return hChild;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\cursor.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CURSOR.CPP
//
//  This file has the implementations of the cursor system objects.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "cursor.h"

long        fCursorDataInit = FALSE;
HCURSOR     rghcurSystem[CCURSOR_SYSTEM] =
{
    (HCURSOR)IDC_ARROW,
    (HCURSOR)IDC_IBEAM,
    (HCURSOR)IDC_WAIT,
    (HCURSOR)IDC_CROSS,
    (HCURSOR)IDC_UPARROW,
    (HCURSOR)IDC_SIZENWSE,
    (HCURSOR)IDC_SIZENESW,
    (HCURSOR)IDC_SIZEWE,
    (HCURSOR)IDC_SIZENS,
    (HCURSOR)IDC_SIZEALL,
    (HCURSOR)IDC_NO,
    (HCURSOR)IDC_APPSTARTING,
    (HCURSOR)IDC_HELP,
    (HCURSOR)MAKEINTRESOURCE(32631)
};


// --------------------------------------------------------------------------
//
//  MapCursorIndex()
//
// --------------------------------------------------------------------------
long MapCursorIndex(HCURSOR hcur)
{
    long iIndex;
    int iCur;

    iIndex = CURSOR_SYSTEM_UNKNOWN;

    for (iCur = 0; iCur < CCURSOR_SYSTEM; iCur++)
    {
        if (rghcurSystem[iCur] == hcur)
        {
            iIndex = iCur+1;
            break;
        }
    }

    return(iIndex);
}



// --------------------------------------------------------------------------
//
//  CreateCursorObject()
//
// --------------------------------------------------------------------------
HRESULT CreateCursorObject(HWND hwnd, long idObject, REFIID riid, void** ppvCursor)
{
    UNUSED(hwnd);
    UNUSED(idObject);

    if (! InterlockedExchange(&fCursorDataInit, TRUE))
    {
        int icur;

        for (icur = 0; icur < CCURSOR_SYSTEM; icur++)
        {
            rghcurSystem[icur] = LoadCursor(NULL, (LPTSTR)rghcurSystem[icur]);
        }
    }

    return(CreateCursorThing(riid, ppvCursor));
}



// --------------------------------------------------------------------------
//
//  CCursor::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::Clone(IEnumVARIANT** ppenum)
{
    return(CreateCursorThing(IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  CreateCursorThing()
//
// --------------------------------------------------------------------------
HRESULT CreateCursorThing(REFIID riid, void** ppvCursor)
{
    CCursor * pcursor;
    HRESULT hr;

    InitPv(ppvCursor);

    pcursor = new CCursor();
    if (!pcursor)
        return(E_OUTOFMEMORY);

    hr = pcursor->QueryInterface(riid, ppvCursor);
    if (!SUCCEEDED(hr))
        delete pcursor;

    return(hr);
}

                                                                      

// --------------------------------------------------------------------------
//
//  CCursor::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::get_accName(VARIANT varChild, BSTR* pszName)
{
    CURSORINFO   ci;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    MyGetCursorInfo(&ci);

    return(HrCreateString(STR_CURSORNAMEFIRST+MapCursorIndex(ci.hCursor),
        pszName));
}



// --------------------------------------------------------------------------
//
//  CCursor::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_CURSOR;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCursor::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::get_accState(VARIANT varChild, VARIANT * pvarState)
{
    CURSORINFO  ci;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    MyGetCursorInfo(&ci);

    if (!(ci.flags & CURSOR_SHOWING))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    pvarState->lVal |= STATE_SYSTEM_FLOATING;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCursor::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    CURSORINFO  ci;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    MyGetCursorInfo(&ci);

    *pxLeft = ci.ptScreenPos.x;
    *pyTop = ci.ptScreenPos.y;
    *pcxWidth = 1;
    *pcyHeight = 1;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CCursor::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    CURSORINFO  ci;

    InitPvar(pvarChild);

    MyGetCursorInfo(&ci);

    if ((xLeft == ci.ptScreenPos.x) && (yTop == ci.ptScreenPos.y))
    {
        pvarChild->vt = VT_I4;
        pvarChild->lVal = 0;
        return(S_OK);
    }

    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\ctors.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  Ctors
//
//  Contains prototypes for all the CreateXXXObject functions.
//
// --------------------------------------------------------------------------


// These look up the classmap to create the appropriate proxy type.
// (CreateClient and CreateWindowThing create just the raw client/window
// proxies.)
HRESULT CreateClientObject(HWND, long, REFIID, void**);
HRESULT CreateWindowObject(HWND, long, REFIID, void**);



//
// General non-client stuff
//
HRESULT CreateCaretObject(HWND, long, REFIID, void**);
HRESULT CreateClient(HWND, long, REFIID, void**);
HRESULT CreateCursorObject(HWND, long, REFIID, void**);
HRESULT CreateMenuBarObject(HWND, long, REFIID, void**);
HRESULT CreateScrollBarObject(HWND, long, REFIID, void**);
HRESULT CreateSizeGripObject(HWND, long, REFIID, void**);
HRESULT CreateSysMenuBarObject(HWND, long, REFIID, void**);
HRESULT CreateTitleBarObject(HWND, long, REFIID, void**);
HRESULT CreateWindowThing(HWND, long, REFIID, void**);


//
// Client types
//

// USER
HRESULT CreateButtonClient(HWND, long, REFIID, void**);
HRESULT CreateComboClient(HWND, long, REFIID, void**);
HRESULT CreateDialogClient(HWND, long, REFIID, void**);
HRESULT CreateDesktopClient(HWND, long, REFIID, void**);
HRESULT CreateEditClient(HWND, long, REFIID, void**);
HRESULT CreateListBoxClient(HWND, long, REFIID, void**);
HRESULT CreateMDIClient(HWND, long, REFIID, void**);
HRESULT CreateMenuPopupClient(HWND, long, REFIID, void**);
HRESULT CreateScrollBarClient(HWND, long, REFIID, void**);
HRESULT CreateStaticClient(HWND, long, REFIID, void**);
HRESULT CreateSwitchClient(HWND, long, REFIID, void**);

// COMCTL32
HRESULT CreateStatusBarClient(HWND, long, REFIID, void**);
HRESULT CreateToolBarClient(HWND, long, REFIID, void**);
HRESULT CreateProgressBarClient(HWND, long, REFIID, void**);
HRESULT CreateAnimatedClient(HWND, long, REFIID, void**);
HRESULT CreateTabControlClient(HWND, long, REFIID, void**);
HRESULT CreateHotKeyClient(HWND, long, REFIID, void**);
HRESULT CreateHeaderClient(HWND, long, REFIID, void**);
HRESULT CreateSliderClient(HWND, long, REFIID, void**);
HRESULT CreateListViewClient(HWND, long, REFIID, void**);
HRESULT CreateUpDownClient(HWND, long, REFIID, void**);
HRESULT CreateToolTipsClient(HWND, long, REFIID, void**);
HRESULT CreateTreeViewClient(HWND, long, REFIID, void**);
HRESULT CreateCalendarClient(HWND, long, REFIID, void**);
HRESULT CreateDatePickerClient(HWND, long, REFIID, void**);
HRESULT CreateIPAddressClient(HWND, long, REFIID, void**);

#ifndef OLEACC_NTBUILD
HRESULT CreateHtmlClient(HWND, long, REFIID, void**);

// SDM32
HRESULT CreateSdmClientA(HWND, long, REFIID, void**);
#endif // OLEACC_NTBUILD


//
// Window types
//
HRESULT CreateListBoxWindow(HWND, long, REFIID, void**);
HRESULT CreateMenuPopupWindow(HWND, long, REFIID, void**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\cursor.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CURSOR.H
//
//  Cursor OLE Accessibility implementation
//
// --------------------------------------------------------------------------


class   CCursor :   public  CAccessible
{
    public:

        CCursor()
            : CAccessible( CLASS_CursorObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR * pszName);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        accLocation(long* pxLeft, long* pyTop,
            long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT * pvarChild);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT * * ppenum);
};


long    MapCursorIndex(HCURSOR hCur);
HRESULT CreateCursorThing(REFIID, void**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\combo.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  COMBO.H
//
//  Combobox object
//
// --------------------------------------------------------------------------

//
// NOTE:
// Since a combobox has a known # of children (elements and objects), we
// can simplify our life a lot by not deferring to CClient for things like
// the child count property.  We accept IDs for all relevant properties
// even if the ID is of a child object.
//
class   CCombo: public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accChildCount(long* pcCount);
        virtual STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        virtual STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        virtual STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        virtual STDMETHODIMP        accHitTest(long, long, VARIANT*);
        virtual STDMETHODIMP        accDoDefaultAction(VARIANT);

        virtual STDMETHODIMP        put_accValue(VARIANT, BSTR);

        // IEnumVARIANT
        STDMETHODIMP        Next(ULONG, VARIANT*, ULONG*);
        STDMETHODIMP        Skip(ULONG);

        CCombo(HWND, long);

    private:
        BOOL    m_fHasButton:1;
        BOOL    m_fHasEdit:1;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\combo.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  COMBO.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include <olectl.h>
#include "default.h"
#include "window.h"
#include "client.h"
#include "combo.h"


STDAPI_(LPTSTR) MyPathFindFileName(LPCTSTR pPath); // in listbox.cpp

HWND IsInComboEx(HWND hwnd); // in listbox.cpp
BOOL IsTridentControl( HWND hWnd, BOOL fCombo, BOOL fComboList ); // inlistbox.cpp

// Variation of HrGetWindowName which never uses a label
// (unlike the original HrGetWindowName which always uses a label if
// the text is an empty string - using label then is not approprite for
// combo value field.)
// Implemented near end of this file. Original is in client.cpp.
HRESULT HrGetWindowNameNoLabel(HWND hwnd, BSTR* pszName);


// --------------------------------------------------------------------------
//
//  CreateComboClient()
//
// --------------------------------------------------------------------------
HRESULT CreateComboClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvCombo)
{
    CCombo * pcombo;
    HRESULT hr;

    InitPv(ppvCombo);
    
    pcombo = new CCombo(hwnd, idChildCur);
    if (!pcombo)
        return(E_OUTOFMEMORY);

    hr = pcombo->QueryInterface(riid, ppvCombo);
    if (!SUCCEEDED(hr))
        delete pcombo;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CCombo::CCombo()
//
// --------------------------------------------------------------------------
CCombo::CCombo(HWND hwnd, long idChildCur)
    : CClient( CLASS_ComboClient )
{
    LONG    lStyle;

    Initialize(hwnd, idChildCur);

    m_cChildren = CCHILDREN_COMBOBOX;
    m_fUseLabel = TRUE;

    // If in a ComboEx, use its style, instead of our own.
    // Important, because the real Combo will be DROPDOWNLIST (doesn't
    // have edit) when the ComboEx is DROPDOWN (has edit) - the ComboEx
    // supplies an EDIT, but the Combo doesn't know about it.
    HWND hWndEx = IsInComboEx(hwnd);
    if (hWndEx)
    {
        lStyle = GetWindowLong(hWndEx, GWL_STYLE);
    }
    else
    {
        lStyle = GetWindowLong(hwnd, GWL_STYLE);
    }

    switch (lStyle & CBS_DROPDOWNLIST)
    {
        case 0:
            m_cChildren = 0;    // Window not valid!
            break;

        case CBS_SIMPLE:
            m_fHasButton = FALSE;
            m_fHasEdit = TRUE;
            break;

        case CBS_DROPDOWN:
            m_fHasButton = TRUE;
            m_fHasEdit = TRUE;
            break;

        case CBS_DROPDOWNLIST:
            m_fHasButton = TRUE;
            m_fHasEdit = FALSE;
            break;
    }
}


// --------------------------------------------------------------------------
//
//  CCombo::get_accChildCount()
//
//  Since this is a known constant, hand directly to CAccessible.  No
//  need to count up fixed + window children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accChildCount(long* pcCount)
{
    return(CAccessible::get_accChildCount(pcCount));
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accChild()
//
//  Succeeds for listbox, and for item if editable.  This is because we
//  manipulate our children by ID, since they are known.  
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accChild(VARIANT varChild, IDispatch** ppdisp)
{
    COMBOBOXINFO cbi;
    HWND    hwndChild;

    InitPv(ppdisp);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    hwndChild = NULL;

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return(E_INVALIDARG);

        case INDEX_COMBOBOX_ITEM:
            hwndChild = cbi.hwndItem;
            break;

        case INDEX_COMBOBOX_LIST:
            hwndChild = cbi.hwndList;
            break;
    }

    if (!hwndChild)
        return(S_FALSE);
    else
        return(AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
            (void**)ppdisp));
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accName(VARIANT varChild, BSTR* pszName)
{
COMBOBOXINFO cbi;

    InitPv(pszName);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // The name of the combobox, the edit inside of it, and the dropdown
    // are all the same.  The name of the button is Drop down/Pop up
    //
    if (varChild.lVal != INDEX_COMBOBOX_BUTTON)
    {
        HWND hwndComboEx = IsInComboEx(m_hwnd);
        if( ! hwndComboEx )
        {
            // combo/edit/dropdown all use the name of the client itself,
            // so call through with childid of CHILDID_SELF...
            varChild.lVal = CHILDID_SELF;
            return(CClient::get_accName(varChild, pszName));
        }
        else
        {
            // Special case if we're in a comboex - since we're one level deep,
            // reach up to parent for its name...
            IAccessible * pAcc;
            HRESULT hr = AccessibleObjectFromWindow( hwndComboEx, OBJID_CLIENT, IID_IAccessible, (void **) & pAcc );
            if( hr != S_OK )
                return hr;
            VARIANT varChild;
            varChild.vt = VT_I4;
            varChild.lVal = CHILDID_SELF;
            hr = pAcc->get_accName( varChild, pszName );
            pAcc->Release();
            return hr;
        }
    }
    else
    {
        if (! MyGetComboBoxInfo(m_hwnd, &cbi))
            return(S_FALSE);

        if (IsWindowVisible(cbi.hwndList))
            return (HrCreateString(STR_DROPDOWN_HIDE,pszName));
        else
            return(HrCreateString(STR_DROPDOWN_SHOW, pszName));
    }
}





// --------------------------------------------------------------------------
//
//  CCombo::get_accValue()
//
//  The value of the combobox and the combobox item is the current text of
//  the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
        case INDEX_COMBOBOX_ITEM:
        {
            // HACK ALERT
            // The IE4 combobox is a superclassed standard combobox,
            // but if I use SendMessageA (which I do) to get the
            // text, I get back garbage. They keep everything
            // in Unicode. It is a bug in the Trident MSHTML 
            // implementation, but even if they fixed it and gave me
            // back an ANSI string, I wouldn't know what code page to
            // use to convert the ANSI string to Unicode - web pages
            // can be in a different language than the one the user's
            // computer uses! Since they already have everything in 
            // Unicode, we decided on a private message that will fill
            // in the Unicode string, and I use that just like I would 
            // normally use WM_GETTEXT.
            // I was going to base this on the classname of the listbox
            // window, which is "Internet Explorer_TridentCmboBx", but
            // the list part of a combo doesn't have a special class
            // name, so instead I am going to base the special case on
            // the file name of the module that owns the window.
            
            // GetWindowModuleFileName(m_hwnd,szModuleName,ARRAYSIZE(szModuleName));
            // lpszModuleName = MyPathFindFileName (szModuleName);
            // if (0 == lstrcmp(lpszModuleName,TEXT("MSHTML.DLL")))
            
            // Update: (BrendanM)
            // GetWindowModuleFilename is broken on Win2k...
            // IsTridentControl goes back to using classnames, and knows
            // how to cope with ComboLBoxes...

            if( IsTridentControl( m_hwnd, TRUE, FALSE ) )
            {
                OLECHAR*    lpszUnicodeText = NULL;
                OLECHAR*    lpszLocalText = NULL;
                HANDLE      hProcess;
                UINT        cch;

                cch = SendMessageINT(m_hwnd, OCM__BASE + WM_GETTEXTLENGTH, 0, 0);

                lpszUnicodeText = (OLECHAR *)SharedAlloc((cch+1)*sizeof(OLECHAR),
                                                         m_hwnd,
                                                         &hProcess);
                lpszLocalText = (OLECHAR*)LocalAlloc(LPTR,(cch+1)*sizeof(OLECHAR));

                if (!lpszUnicodeText || !lpszLocalText)
                    return(E_OUTOFMEMORY);

                cch = SendMessageINT(m_hwnd, OCM__BASE + WM_GETTEXT, cch, (LPARAM)lpszUnicodeText);
                SharedRead (lpszUnicodeText,lpszLocalText,(cch+1)*sizeof(OLECHAR),hProcess);

                *pszValue = SysAllocString(lpszLocalText);

                SharedFree(lpszUnicodeText,hProcess);
                LocalFree(lpszLocalText);
                return (S_OK);
            }
            else
            {
                // If we're a comboex, ask the comboex instead of us...
                HWND hwnd;
                if( ! ( hwnd = IsInComboEx( m_hwnd ) ) )
                    hwnd = m_hwnd;
                    
                // uh-oh - don't want to use HrGetWindowName, since
                // it will look for a label (even though we specify FALSE)
                // if we are in a dialog and out text is "".
                if( ! IsComboEx( hwnd ) )
                {
                    // Regular combo - gettext works for both edit and droplist...
                    return HrGetWindowNameNoLabel( hwnd, pszValue);
                }
                else
                {
                    // comboex - special case for droplist...
                    DWORD dwStyle = GetWindowLong( hwnd, GWL_STYLE );
                    if( ! ( dwStyle & CBS_DROPDOWNLIST ) )
                    {
                        // Not a droplist - can use normal technique...
                        return HrGetWindowNameNoLabel( hwnd, pszValue);
                    }
                    else
                    {
                        // Get the selected item, and get its text...
                        int iSel = SendMessageINT( hwnd, CB_GETCURSEL, 0, 0 );
                        if( iSel == CB_ERR )
                            return S_FALSE; // no item selected

                        int cch = SendMessageINT( hwnd, CB_GETLBTEXTLEN, iSel, 0);

                        // Some apps do not handle CB_GETTEXTLEN correctly, and
                        // always return a small number, like 2.
		                if (cch < 1024)
			                cch = 1024;

                        LPTSTR lpszText;
                        lpszText = (LPTSTR)LocalAlloc(LPTR, (cch+1)*sizeof(TCHAR));
                        if (!lpszText)
                            return(E_OUTOFMEMORY);

                        SendMessage( hwnd, CB_GETLBTEXT, iSel, (LPARAM)lpszText);
                        *pszValue = TCharSysAllocString(lpszText);

                        LocalFree((HANDLE)lpszText);

                        return S_OK;
                    }
                }
            }
        }
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            pvarRole->lVal = ROLE_SYSTEM_COMBOBOX;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (m_fHasEdit)
                pvarRole->lVal = ROLE_SYSTEM_TEXT;
            else
                pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;
            break;

        case INDEX_COMBOBOX_BUTTON:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_COMBOBOX_LIST:
            pvarRole->lVal = ROLE_SYSTEM_LIST;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of combo box") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accState()
//
//  The state of the combo is the state of the client.
//  The state of the item is the state of the edit field if present; 
//      read-only if static.
//  The state of the button is pushed and/or hottracked.
//  The state of the dropdown is floating (if not simple) and the state
//      of the list window.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    COMBOBOXINFO    cbi;
    VARIANT         var;
    IAccessible* poleacc;
    HRESULT         hr;
    HWND            hwndActive;

    InitPvar(pvarState);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!MyGetComboBoxInfo(m_hwnd, &cbi))
    {
        pvarState->vt = VT_I4;
        pvarState->lVal = STATE_SYSTEM_INVISIBLE;
        return(S_FALSE);
    }

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return(CClient::get_accState(varChild, pvarState));

        case INDEX_COMBOBOX_BUTTON:
            pvarState->vt = VT_I4;
            pvarState->lVal = cbi.stateButton;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (!cbi.hwndItem)
            {
                pvarState->vt = VT_I4;
                pvarState->lVal = 0;
                hwndActive = GetForegroundWindow();
                if (hwndActive == MyGetAncestor(m_hwnd, GA_ROOT))
                    pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (MyGetFocus() == m_hwnd)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
            }
            else
            {
                // Forward state to edit field.
                VariantInit(&var);
                hr = GetWindowObject(cbi.hwndItem, &var);
                goto AskTheChild;
            }
            break;

        case INDEX_COMBOBOX_LIST:
            // Forward state to listbox
            VariantInit(&var);
            hr = GetWindowObject(cbi.hwndList, &var);

AskTheChild:
            if (!SUCCEEDED(hr))
                return(hr);

            Assert(var.vt == VT_DISPATCH);

            //
            // Get the child acc object
            //
            poleacc = NULL;
            hr = var.pdispVal->QueryInterface(IID_IAccessible,
                (void**)&poleacc);
            var.pdispVal->Release();

            if (!SUCCEEDED(hr))
                return(hr);

            //
            // Ask the child its state
            //
            VariantInit(&var);
            hr = poleacc->get_accState(var, pvarState);
            poleacc->Release();
            if (!SUCCEEDED(hr))
                return(hr);
            break;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    TCHAR   szKey[20];

    //
    // Shortcut for combo is label's hotkey.
    // Shortcut for dropdown (if button) is Alt+F4.
    // CWO, 12/5/96, Alt+F4? F4, by itself brings down the combo box,
    //                       but we add "Alt" to the string.  Bad!  Now use 
    //                       down arrow and add Alt to it via HrMakeShortcut()
    //                       As documented in the UI style guide.
    //
    // As always, shortcuts only apply if the container has "focus".  In other
    // words, the hotkey for the combo does nothing if the parent dialog
    // isn't active.  And the hotkey for the dropdown does nothing if the
    // combobox/edit isn't focused.
    //

    InitPv(pszShortcut);

    //
    // Validate parameters
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == INDEX_COMBOBOX || varChild.lVal == INDEX_COMBOBOX_ITEM)
    {
        HWND hwndComboEx = IsInComboEx(m_hwnd);
        if( ! hwndComboEx )
        {
            // combo/edit/dropdown all use the name of the client itself,
            // so call through with childid of CHILDID_SELF...
            varChild.lVal = CHILDID_SELF;
            return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));
        }
        else
        {
            // Special case if we're in a comboex - since we're one level deep,
            // reach up to parent for its name...
            IAccessible * pAcc;
            HRESULT hr = AccessibleObjectFromWindow( hwndComboEx, OBJID_CLIENT, IID_IAccessible, (void **) & pAcc );
            if( hr != S_OK )
                return hr;
            VARIANT varChild;
            varChild.vt = VT_I4;
            varChild.lVal = CHILDID_SELF;
            hr = pAcc->get_accKeyboardShortcut( varChild, pszShortcut );
            pAcc->Release();
            return hr;
        }
    }
    else if (varChild.lVal == INDEX_COMBOBOX_BUTTON)
    {
        if (m_fHasButton)
        {
            LoadString(hinstResDll, STR_COMBOBOX_LIST_SHORTCUT, szKey,
                ARRAYSIZE(szKey));
            return(HrMakeShortcut(szKey, pszShortcut));
        }
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accDefaultAction(VARIANT varChild, BSTR* pszDef)
{
    COMBOBOXINFO cbi;

    InitPv(pszDef);

    //
    // Validate parameters
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if ((varChild.lVal != INDEX_COMBOBOX_BUTTON) || !m_fHasButton)
        return(E_NOT_APPLICABLE);

    //
    // Default action of button is to press it.  If pressed already, pressing
    // it will pop dropdown back up.  If not pressed, pressing it will pop
    // dropdown down.
    //
    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    if (IsWindowVisible(cbi.hwndList))
        return(HrCreateString(STR_DROPDOWN_HIDE, pszDef));
    else
        return(HrCreateString(STR_DROPDOWN_SHOW, pszDef));
}



// --------------------------------------------------------------------------
//
//  CCombo::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    COMBOBOXINFO    cbi;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX_BUTTON:
            if (!m_fHasButton)
                return(S_FALSE);

            *pcxWidth = cbi.rcButton.right - cbi.rcButton.left;
            *pcyHeight = cbi.rcButton.bottom - cbi.rcButton.top;

            ClientToScreen(m_hwnd, (LPPOINT)&cbi.rcButton);

            *pxLeft = cbi.rcButton.left;
            *pyTop = cbi.rcButton.top;
            break;

        case INDEX_COMBOBOX_ITEM:
            *pcxWidth = cbi.rcItem.right - cbi.rcItem.left;
            *pcyHeight = cbi.rcItem.bottom - cbi.rcItem.top;
            
            ClientToScreen(m_hwnd, (LPPOINT)&cbi.rcItem);

            *pxLeft = cbi.rcItem.left;
            *pyTop = cbi.rcItem.top;
            break;

        case INDEX_COMBOBOX_LIST:
            MyGetRect(cbi.hwndList, &cbi.rcItem, TRUE);
            *pxLeft = cbi.rcItem.left;
            *pyTop = cbi.rcItem.top;
            *pcxWidth = cbi.rcItem.right - cbi.rcItem.left;
            *pcyHeight = cbi.rcItem.bottom - cbi.rcItem.top;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of combo box") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::accNavigate()
//
//  Navigates among children of combobox.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
{
    COMBOBOXINFO    cbi;
    long            lEnd;

    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if ((!ValidateChild(&varStart) && !ValidateHwnd(&varStart)) ||
        !ValidateNavDir(dwNav, varStart.lVal))
        return(E_INVALIDARG);

    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    lEnd = 0;

    if (dwNav == NAVDIR_FIRSTCHILD)
    {
        lEnd =  INDEX_COMBOBOX_ITEM;
        goto GetTheChild;
    }
    else if (dwNav == NAVDIR_LASTCHILD)
    {
        dwNav = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNav, varStart, pvarEnd));

    //
    // Map HWNDID to normal ID.  We work with both (it is easier).
    //
    if (IsHWNDID(varStart.lVal))
    {
        HWND hWndTemp = HwndFromHWNDID(m_hwnd, varStart.lVal);

        if (hWndTemp == cbi.hwndItem)
            varStart.lVal = INDEX_COMBOBOX_ITEM;
        else if (hWndTemp == cbi.hwndList)
            varStart.lVal = INDEX_COMBOBOX_LIST;
        else
            // Don't know what the heck this is
            return(S_FALSE);
    }

    switch (dwNav)
    {
        case NAVDIR_UP:
            if (varStart.lVal == INDEX_COMBOBOX_LIST)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_DOWN:
            if ((varStart.lVal != INDEX_COMBOBOX_LIST) &&
                IsWindowVisible(cbi.hwndList))
            {
                lEnd = INDEX_COMBOBOX_LIST;
            }
            break;

        case NAVDIR_LEFT:
            if (varStart.lVal == INDEX_COMBOBOX_BUTTON)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_RIGHT:
            if ((varStart.lVal == INDEX_COMBOBOX_ITEM) &&
               !(cbi.stateButton & STATE_SYSTEM_INVISIBLE))
            {
               lEnd = INDEX_COMBOBOX_BUTTON;
            }   
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            if ((lEnd == INDEX_COMBOBOX_LIST) && !IsWindowVisible(cbi.hwndList))
                --lEnd;
            if ((lEnd == INDEX_COMBOBOX_BUTTON) && !m_fHasButton)
                --lEnd;
            break;

        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            else
            {
                if ((lEnd == INDEX_COMBOBOX_BUTTON) && !m_fHasButton)
                    lEnd++;
                if ((lEnd == INDEX_COMBOBOX_LIST) && !IsWindowVisible(cbi.hwndList))
                    lEnd = 0;
            }
            break;
    }

GetTheChild:
    if (lEnd)
    {
        if ((lEnd == INDEX_COMBOBOX_ITEM) && cbi.hwndItem)
            return(GetWindowObject(cbi.hwndItem, pvarEnd));
        else if ((lEnd == INDEX_COMBOBOX_LIST) && cbi.hwndList)
            return(GetWindowObject(cbi.hwndList, pvarEnd));

        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CCombo::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accHitTest(long x, long y, VARIANT* pvarEnd)
{
    POINT   pt;
    COMBOBOXINFO cbi;
    RECT    rc;

    InitPvar(pvarEnd);

    if (!MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    pt.x = x;
    pt.y = y;

    // Check list first, in case it is a dropdown.
    MyGetRect(cbi.hwndList, &rc, TRUE);
    if (PtInRect(&rc, pt) && IsWindowVisible(cbi.hwndList))
        return(GetWindowObject(cbi.hwndList, pvarEnd));
    else
    {
        ScreenToClient(m_hwnd, &pt);
        MyGetRect(m_hwnd, &rc, FALSE);
        if (! PtInRect(&rc, pt))
            return(S_FALSE);

        if (PtInRect(&cbi.rcButton, pt))
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = INDEX_COMBOBOX_BUTTON;
        }
        else if (PtInRect(&cbi.rcItem, pt))
        {
            if (m_fHasEdit)
                return(GetWindowObject(cbi.hwndItem, pvarEnd));
            else
            {
                pvarEnd->vt = VT_I4;
                pvarEnd->lVal = INDEX_COMBOBOX_ITEM;
            }
        }
        else
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = 0;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::accDoDefaultAction()
//
//  The default action of the button is to toggle the dropdown list up or 
//  down.  Note that we don't just pop up the listbox, we pop it up AND
//  accept amu changes in the selected item..
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accDoDefaultAction(VARIANT varChild)
{
    COMBOBOXINFO    cbi;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if ((varChild.lVal == INDEX_COMBOBOX_BUTTON) && m_fHasButton)
    {
        if (!MyGetComboBoxInfo(m_hwnd, &cbi))
            return(S_FALSE);

        if (IsWindowVisible(cbi.hwndList))
            PostMessage(m_hwnd, WM_KEYDOWN, VK_RETURN, 0);
        else
            PostMessage(m_hwnd, CB_SHOWDROPDOWN, TRUE, 0);

        return(S_OK);
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CCombo::put_accValue()
//
//  This works if (1) the combo is editable or (2) the text matches a list
//  item exactly.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::put_accValue(VARIANT varChild, BSTR szValue)
{
    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    LPTSTR  lpszValue;

#ifdef UNICODE

	// On unicode, no conversion needed...
	lpszValue = szValue;

#else

	// On non-unicode, need to convert to multibyte...

    // We may be dealing with DBCS chars - assume worst case where every character is
    // two bytes...
    UINT cchValue = SysStringLen(szValue) * 2;
    lpszValue = (LPTSTR)LocalAlloc(LPTR, (cchValue+1)*sizeof(TCHAR));
    if (!lpszValue)
        return(E_OUTOFMEMORY);

    WideCharToMultiByte(CP_ACP, 0, szValue, -1, lpszValue, cchValue+1, NULL,
        NULL);

#endif

    //
    // If this is editable, set the text directly.  If this is a dropdown
    // list, select the exact match for this text.
    //
    if (m_fHasEdit)
        SendMessage(m_hwnd, WM_SETTEXT, 0, (LPARAM)lpszValue);
    else
        SendMessage(m_hwnd, CB_SELECTSTRING, (UINT)-1, (LPARAM)lpszValue);

#ifndef UNICODE
	// On non-unicode, free the temp string we alloc'd above...
    LocalFree((HANDLE)lpszValue);
#endif

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::Next()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched)
{
    return(CAccessible::Next(celt, rgvar, pceltFetched));
}


// --------------------------------------------------------------------------
//
//  CCombo::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::Skip(ULONG celt)
{
    return(CAccessible::Skip(celt));
}








// --------------------------------------------------------------------------
//
//  HrGetWindowNameNoLabel()
//
//  This variation of HrGetWindowName (originally from client.cpp)
//  never uses a label. (HrGetWindowName would alway use a label
//  if window text was "" and window was in a dialog. That's not
//  appropriate for getting combo value text, though...)
//
// --------------------------------------------------------------------------
HRESULT HrGetWindowNameNoLabel(HWND hwnd, BSTR* pszName)
{
    LPTSTR  lpText = NULL;

    if( ! IsWindow( hwnd ) )
        return E_INVALIDARG;

    // Look for a name property!
    lpText = GetTextString( hwnd, FALSE );
    if( ! lpText )
        return S_FALSE;

    // Strip out the mnemonic.
    StripMnemonic(lpText);

    // Get a BSTR
    *pszName = TCharSysAllocString( lpText );

    // Free our buffer
    LocalFree( (HANDLE)lpText );

    // Did the BSTR succeed?
    if( ! *pszName )
        return E_OUTOFMEMORY;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\com_atlmain.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// com_atlmain.cpp : Implementation of DLL Exports.
//
// This handles all COM-based entry points - eg.
// requests for the external CAccPropServices, or the
// internal CRemoteProxyFactory.
//
// This file is a modified ATL "mainline". The main
// exports (eg. DllGetclassObject) have had "ComATLMain_"
// prepended to their names, and are chained by the real
// entrypoints in oleacc.cpp.
//
// Note that the DllGetClassObject in this file also
// calls InitOleacc(), to ensure that OLEACC is init'd
// before it is used by the object.


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

extern CComModule _Module;
#include <atlcom.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "resource.h"
#include "RemoteProxy6432.h"

#include "RemoteProxyFactory.h"

#include "PropMgr_Impl.h"


CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
#ifdef _WIN64
	OBJECT_ENTRY(CLSID_RemoteProxyFactory64, CRemoteProxyFactory)
#else
	OBJECT_ENTRY(CLSID_RemoteProxyFactory32, CRemoteProxyFactory)
#endif
	OBJECT_ENTRY(CLSID_AccPropServices, CPropMgr)
END_OBJECT_MAP()



extern "C"
BOOL WINAPI ComATLMain_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_REMOTEPROXY6432Lib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllRegisterServer()
//
// Handles registering the proxy factory
//
extern "C"
HRESULT WINAPI ComATLMain_DllRegisterServer()
{
	// By default, ATL only registers/unregisters the first tlb in the DLL's
    // resource, but we need to explicitly reg/unreg the second one - the
    // bitness proxy factory. (The first one is the oleacc/IAccessible tlb.)
	ITypeLib *pTypeLib = NULL;
    OLECHAR	wszProxyFactoryTlb[] = L"oleacc.dll\\2";
	HRESULT hr;

	hr = LoadTypeLib( wszProxyFactoryTlb, &pTypeLib );

	if ( SUCCEEDED(hr) )
	{
		hr = RegisterTypeLib( pTypeLib, wszProxyFactoryTlb, NULL );
        pTypeLib->Release();

		// let ATL do the rest of the registration stuff.
        // FALSE here means don't register TLBs - we've done that above.
		hr = _Module.RegisterServer(FALSE);
	}

    return hr;
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllDllUnregisterServer()
//
// Handles unregistering the proxy factory
//
extern "C"
HRESULT WINAPI ComATLMain_DllUnregisterServer()
{
	// By default, ATL only registers/unregisters the first tlb in the DLL's
    // resource, but we need to explicitly reg/unreg the second one - the
    // bitness proxy factory. (The first one is the oleacc/IAccessible tlb.)
	ITypeLib *pTypeLib = NULL;
    OLECHAR	wszProxyFactoryTlb[] = L"oleacc.dll\\2";
	HRESULT hr;

	hr = LoadTypeLib( wszProxyFactoryTlb, &pTypeLib );

	if ( SUCCEEDED(hr) )
	{
        TLIBATTR * ptla;
        hr = pTypeLib->GetLibAttr( & ptla );
        if( SUCCEEDED( hr ) )
        {
    		hr = UnRegisterTypeLib( ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind );
            pTypeLib->ReleaseTLibAttr( ptla );
        }

        pTypeLib->Release();

		// let ATL do the rest of the unregistration stuff...
        // FALSE here means don't unregister TLBs - we've done that above.
		hr = _Module.UnregisterServer(FALSE);
	}

    return hr;
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllCanUnloadNow()
//
// Handles returning whether the proxy factory can be unloaded or not
//
extern "C"
HRESULT WINAPI ComATLMain_DllCanUnloadNow()
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllGetClassObject()
//
// The is the class factory for the bitness proxy factory
//
extern "C"
HRESULT WINAPI ComATLMain_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // guarrantee that oleacc is initialized prior to using it
    InitOleacc();
    return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\datepicker.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DatePicker.CPP
//
//  DatePicker client class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "window.h"
#include "DatePicker.h"


// --------------------------------------------------------------------------
//
//  CreateDatePickerClient()
//
//  EXTERNAL for CClient.
//
// --------------------------------------------------------------------------
HRESULT CreateDatePickerClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvDatePicker)
{
    CDatePicker * pDatePicker;
    HRESULT hr;

    InitPv(ppvDatePicker);

    pDatePicker = new CDatePicker( hwnd, idChildCur );
    if ( !pDatePicker )
        return(E_OUTOFMEMORY);

    hr = pDatePicker->QueryInterface( riid, ppvDatePicker );
    if ( !SUCCEEDED(hr) )
        delete ppvDatePicker;

    return hr;
}



// --------------------------------------------------------------------------
//
//  CDatePicker::CDatePicker()
//
// --------------------------------------------------------------------------
CDatePicker::CDatePicker(HWND hwnd, long idChildCur)
    : CClient( CLASS_DatePickerClient )
{
    Initialize( hwnd, idChildCur );

	m_fUseLabel = TRUE;

}


// --------------------------------------------------------------------------
//
//  CDatePicker::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDatePicker::get_accValue( VARIANT varChild, BSTR* pszValue )
{
    InitPv(pszValue);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;


    LPTSTR lpszValue = GetTextString(m_hwnd, TRUE);
    if (!lpszValue)
        return S_FALSE;

    *pszValue = TCharSysAllocString(lpszValue);
    LocalFree((HANDLE)lpszValue);

    if (! *pszValue)
        return E_OUTOFMEMORY;

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CDatePicker::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDatePicker::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
	pvarRole->lVal = ROLE_SYSTEM_DROPLIST;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\datepicker.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DatePicker.H
//
//  Default DatePicker OLE ACC Client
//
// --------------------------------------------------------------------------


class CDatePicker : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accRole( VARIANT varChild, VARIANT* pvarRole );
		STDMETHODIMP		get_accValue( VARIANT varChild, BSTR* pszValue );

        CDatePicker( HWND, long );

    protected:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\debug.cpp ===
// Copyright (c) 2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  debug
//
//  Assert, OutputDebugString-like replacements
//
//  See debug.h for usage details.
//
//
// --------------------------------------------------------------------------


#include <windows.h>

#include "debug.h"
#include <tchar.h>

#include <stdarg.h>

#include "types6432.h"


#define ARRAYLEN(a)    (sizeof(a)/sizeof(a[0]))


#define TRACE_HRESULT   0x01
#define TRACE_Win32     0x02


void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ...);

void WriteFilename( LPCTSTR pPath, LPTSTR szBuf, int cbBuf );


LPCTSTR g_pLevelStrs [ ] = 
{
    TEXT("DBG"),
    TEXT("INF"),
    TEXT("WRN"),
    TEXT("ERR"),
    TEXT("PRM"),
    TEXT("PRW"),
    TEXT("IOP"),
    TEXT("AST"),
    TEXT("AST"),
    TEXT("CAL"),
    TEXT("RET"),
    TEXT("???"),
};


DWORD g_dwTLSIndex = 0;

// enough for 10 4-space indents - 10*4 spaces
LPCTSTR g_szIndent = TEXT("                                        ");




static
void InternalTrace( LPCTSTR pszFile, ULONG uLineNo, DWORD dwLevel, DWORD dwFlags, const void * pThis, HRESULT hr, LPCTSTR pszWhere, LPCTSTR pszStr )
{
    // Only produce output if this mutex exists...
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return;
    CloseHandle( hTestMutex );


    if( dwLevel >= ARRAYLEN( g_pLevelStrs ) )
        dwLevel = ARRAYLEN( g_pLevelStrs ) - 1; // "???" unknown entry

    if( ! pszFile )
        pszFile = TEXT("[missing file]");;

    LPCTSTR pszWhereSep = ( pszWhere && pszStr ) ? TEXT(": ") : TEXT("");

    if( ! pszStr && ! pszWhere )
        pszStr = TEXT("[missing string]");
    else
    {
        if( ! pszWhere )
            pszWhere = TEXT("");

        if( ! pszStr )
            pszStr = TEXT("");
    }

    // Basic message stuff - pid, tid... (also pass this and use object ptr?)
    // TODO - allow naming of threads?

    DWORD pid = GetCurrentProcessId();
    DWORD tid = GetCurrentThreadId();

    // Generate indent for call/ret...

    // TODO - make this thread safe + atomic
    if( g_dwTLSIndex == 0 )
    {
        g_dwTLSIndex = TlsAlloc();
    }
    DWORD dwIndent = PtrToInt( TlsGetValue( g_dwTLSIndex ) );

    if( dwLevel == _TRACE_RET )
    {
        dwIndent--;
        TlsSetValue( g_dwTLSIndex, IntToPtr( dwIndent ) );
    }

    DWORD dwDisplayIndent = dwIndent;
    if( dwDisplayIndent > 10 )
        dwDisplayIndent = 10;

    if( dwLevel == _TRACE_CALL )
    {
        dwIndent++;
        TlsSetValue( g_dwTLSIndex, IntToPtr( dwIndent ) );
    }


    // Step to the end of the canned indent string, then back dwIndent*4 spaces.
    // (Don't use sizeof(), since it will include the terminating NUL)
    LPCTSTR pszIndent = (g_szIndent + 40) - (dwDisplayIndent * 4);


    // Extract filename from path:
    TCHAR szFN[ 64 ];
    WriteFilename( pszFile, szFN, ARRAYLEN( szFN ) );


    TCHAR msg[ 1025 ];
    if( pThis )
    {
        if( dwFlags & TRACE_HRESULT )
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d this=0x%lx hr=0x%lx %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                pThis, hr,
                                pszWhere, pszWhereSep, pszStr );
        }
        else
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d this=0x%lx %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                pThis,
                                pszWhere, pszWhereSep, pszStr );
        }
    }
    else
    {
        if( dwFlags & TRACE_HRESULT )
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d hr=0x%lx %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                hr,
                                pszWhere, pszWhereSep, pszStr );
        }
        else
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                pszWhere, pszWhereSep, pszStr );
        }
    }


    // 
	OutputDebugString( msg );

    // On w9x, also use the DBWIN mutex technique...
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof( VerInfo );
    if( GetVersionEx( & VerInfo )
     && VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
    {
        OutputDebugStringDBWIN( msg );
    }



#ifdef DEBUG

    if( dwLevel == _TRACE_ASSERT_D || dwLevel == _TRACE_ERR )
    {
        DebugBreak();
    }

#endif // DEBUG

}



void _Trace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, 0, pThis, 0, pszWhere, pszStr );
}

void _TraceHR( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_HRESULT, pThis, hr, pszWhere, pszStr );
}

void _TraceW32( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_Win32, pThis, 0, pszWhere, pszStr );
}



void _Trace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist )
{
    TCHAR szBuf[ 1025 ];
    LPCTSTR pszBuf;
    if( pszStr )
    {
        wvsprintf( szBuf, pszStr, alist );
        pszBuf = szBuf;
    }
    else
    {
        pszBuf = NULL;
    }

    InternalTrace( pFile, uLineNo, dwLevel, 0, pThis, 0, pszWhere, pszBuf );
}

void _TraceHR( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr, va_list alist )
{
    TCHAR szBuf[ 1025 ];
    LPCTSTR pszBuf;
    if( pszStr )
    {
        wvsprintf( szBuf, pszStr, alist );
        pszBuf = szBuf;
    }
    else
    {
        pszBuf = NULL;
    }

    InternalTrace( pFile, uLineNo, dwLevel, TRACE_HRESULT, pThis, hr, pszWhere, pszBuf );
}

void _TraceW32( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist )
{
    TCHAR szBuf[ 1025 ];
    LPCTSTR pszBuf;
    if( pszStr )
    {
        wvsprintf( szBuf, pszStr, alist );
        pszBuf = szBuf;
    }
    else
    {
        pszBuf = NULL;
    }

    InternalTrace( pFile, uLineNo, dwLevel, TRACE_Win32, pThis, 0, pszWhere, pszBuf );
}





// Add just the 'filename' part of the full path, minus base and extention.
// So for "g:\dev\vss\msaa\common\file.cpp", write "file".
// The start of this string is that last found ':', '\', or start of string if those are not present.
// The end of this string is the last '.' found after the start position, otherwise the end of the string.

void WriteFilename( LPCTSTR pPath, LPTSTR szBuf, int cBuf )
{
    LPCTSTR pScan = pPath;
    LPCTSTR pStart = pPath;
    LPCTSTR pEnd = NULL;

    // Scan through the filename till we hit the end...
    while( *pScan != '\0' )
    {
        // Found a dot - remember it - if we don't hit a directory separator,
        // then this marks the end of the name part of the path.
        if( *pScan == '.' )
        {
            pEnd = pScan;
            pScan++;
        }
        // Found a directory separator - reset markers for start and end of
        // name part...
        if( *pScan == '\\' || *pScan == '/' || *pScan == ':'  )
        {
            pScan++; // skip over separator char
            pStart = pScan;
            pEnd = NULL;
        }
        else
        {
            pScan++;
        }
    }

    if( pEnd == NULL )
        pEnd = pScan;

    // Copy as much as we can (leaving space for NUL) to out buffer
    // (int) cast keeps 64bit compiler happy
    int cToCopy = (int)(pEnd - pStart);
    if( cToCopy > cBuf - 1 )
        cToCopy = cBuf - 1;

    memcpy( szBuf, pStart, cToCopy * sizeof( TCHAR ) );
    szBuf[ cToCopy ] = '\0';
}






void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ... )
{
    // create the output buffer
    TCHAR achBuffer[1025];
    va_list args;
    va_start(args, lpOutputString);
    wvsprintf(achBuffer, lpOutputString, args);
    va_end(args);


    // make sure DBWIN is open and waiting
    HANDLE heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
    if( !heventDBWIN )
    {
        return;            
    }

    // get a handle to the data synch object
    HANDLE heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
    if ( !heventData )
    {
        CloseHandle(heventDBWIN);
        return;            
    }
    
    HANDLE hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
    if (!hSharedFile) 
    {
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    // Note - this is an ANSI CHAR pointer, not a TCHAR one.
    LPSTR lpszSharedMem = (LPSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
    if (!lpszSharedMem) 
    {
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    // wait for buffer event
    WaitForSingleObject(heventDBWIN, INFINITE);

#ifdef UNICODE
    CHAR achANSIBuffer[ 1025 ];
    WideCharToMultiByte( CP_ACP, 0, achBuffer, -1, achANSIBuffer, ARRAYLEN( achANSIBuffer ), NULL, NULL );
#else
    LPCSTR achANSIBuffer = achBuffer;
#endif

    // write it to the shared memory
    *((LPDWORD)lpszSharedMem) = GetCurrentProcessId();
    wsprintfA(lpszSharedMem + sizeof(DWORD), "%s", achANSIBuffer);

    // signal data ready event
    SetEvent(heventData);

    // clean up handles
    CloseHandle(hSharedFile);
    CloseHandle(heventData);
    CloseHandle(heventDBWIN);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\debug.h ===
// Copyright (c) 2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  debug
//
//  Assert, OutputDebugString-like replacements
//
//
//  On NT, these use OutputDebugString; on 9x, the DBWIN32 mutex is used.
//
//  These all compile away to nothing in release builds.
//  (In future releases, some of the parameter errors may remain on release
//  builds.)
//
//  On release builds, ouput is only produces if the mutex
//  "oleacc-msaa-use-dbwin" exists. (A small applet can be used to create
//  this mutex.) This prevents our debug code from annoying the NT test and
//  stress people who only want to see critical messages.
//
// --------------------------------------------------------------------------
//
//  Trace functionality - these output debug strings.
//
//
//  To log an error, use:
//
//      TraceError( format string, optional-args... );
//
//  uses printf-like format string with variable number of args.
//
//  If a HRESULT is known, use:
//      TraceErrorHR( hr, format string, args... );
//
//  If the error is the result of a failed Win32 API call, use...
//      TraceErrorW32( format string, args... );
//
//  This will call GetLastError internally.
//
//  Flavors available: (eg. TraceXXXX)
//  
//    Debug     - temporary printf debugging. Should be removed before checkin.
//    Info      - for displaying useful information during normal operation.
//    Warning   - when an unexpected recoverable error happens.
//    Error     - when system API or method calls fail unexpectedly
//    Param     - when bad parameters are passed in which result in an error
//    ParamWarn - when bad parameters are passed in which we accept for compat
//                reasons; or when soon-to-be-deprecated values are used.
//    Interop   - when API or method of some other component which we rely on 
//                fails unexpectedly
//
// --------------------------------------------------------------------------
//
//  Call/Return tracking
//
//  To track when a particular method is called and returns, use:
//
//      void Class::Method( args )
//      {
//          IMETHOD( methodname, optional-fmt-string, optional-args... );
//
//  Use SMETHOD for static methods and functions. (IMETHOD also reports the
//  value of the 'this' pointer.)
//
// --------------------------------------------------------------------------
//
//  Asserts
//
//  Assert( cond )
//    - Traditional assert.
//
//  AssertMsg( cond, fmt-string, args... )
//    - Assert which reports message. Uses printf-style format.
//
//  AssertStr( str )
//    - This exists for compat reasons - it was already used in oleacc code.
//      This is an unconditional assert, equivalent to
//      AssertMsg( FALSE, str )
//
// --------------------------------------------------------------------------
//
//  Note that all strings - format strings and method names - need TEXT()
//  to compile as Unicode.
//
// --------------------------------------------------------------------------

#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <stdarg.h>


#define _TRACE_DEBUG    0
#define _TRACE_INFO     1
#define _TRACE_WARNING  2
#define _TRACE_ERROR    3

#define _TRACE_PARAM    4
#define _TRACE_PARAWARN 5
#define _TRACE_INTEROP  6

#define _TRACE_ASSERT_D 7   // Debug-build assert - really does assert
#define _TRACE_ASSERT_R 8   // Release-build assert - only logs error, doesn't halt program

#define _TRACE_CALL     9
#define _TRACE_RET      10


// These are implemented in debug.cpp, and do the real work of outputting the
// debug message, and calling DebugBreak, if appropriate.
// 
// HR, W32 versions add messages corresponding to HRESULT or GetLastError().

void _Trace     ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist );
void _TraceHR   ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr, va_list alist );
void _TraceW32  ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist );

void _Trace     ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr );
void _TraceHR   ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr );
void _TraceW32  ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr );




// Prototypes for the macros defined here.
//
// These are not actually used - they are only here to give VC's autocomplete some
// prototypes to work with for autocomplete.
//
// The real work is done by the #defines below.
//
// Note that these must appear *before* their #defines in this file.
//
void IMETHOD( LPCTSTR pszMethodName, LPCTSTR pszStr = TEXT(""), ... );

void Assert( bool cond );
void AssertMsg( bool cond, LPCTSTR str, ... );
void AssertStr( LPCTSTR str );

void TraceDebug( LPCTSTR str, ... );
void TraceInfo( LPCTSTR str, ... );
void TraceWarning( LPCTSTR str, ... );
void TraceError( LPCTSTR str, ... );
void TraceParam( LPCTSTR str, ... );
void TraceParamWarn( LPCTSTR str, ... );
void TraceInterop( LPCTSTR str, ... );

void TraceDebugHR( HRESULT hr, LPCTSTR str, ... );
void TraceInfoHR( HRESULT hr, LPCTSTR str, ... );
void TraceWarningHR( HRESULT hr, LPCTSTR str, ... );
void TraceErrorHR( HRESULT hr, LPCTSTR str, ... );
void TraceParamHR( HRESULT hr, LPCTSTR str, ... );
void TraceParamWarnHR( HRESULT hr, LPCTSTR str, ... );
void TraceInteropHR( HRESULT hr, LPCTSTR str, ... );

void TraceDebugW32( LPCTSTR str, ... );
void TraceInfoW32( LPCTSTR str, ... );
void TraceWarningW32( LPCTSTR str, ... );
void TraceErrorW32( LPCTSTR str, ... );
void TraceParamW32( LPCTSTR str, ... );
void TraceParamWarnW32( LPCTSTR str, ... );
void TraceInteropW32( LPCTSTR str, ... );




#ifdef _DEBUG

    //  Problem - #define's can't handle variable number of arguments - so you can't do:
    //
    //      #define TraceError( str, ... )   RealTrace( __FILE__, __LINE__, str, ... )
    //
    //  Instead, we use a helper class. Its ctor takes as arguments __FILE__,
    //  __LINE__, and any other 'out of band' data. This class also has a
    //  method that takes a variable number of params. So we get something like:
    //
    //      #define TraceError               TraceClass( __FILE__, __LINE__ ).Method
    //
    //
    //  This method ends up being called with the variable list of params:
    //
    //      TraceError( "count is %d", count )
    //
    //  ...gets expanded to...
    //
    //      TraceClass( __FILE__, __LINE__ ).Method( "count is %d", count )
    //
    //  The basic idea is the we use ctor params to capture any 'out-of-band'
    //  data that's not specified in the macro parameters; and then use the
    //  method call to add in the variable-length macro params.
    //
    //  The method can use the <stdarg.h> ,acros to get a va_list for these params,
    //  and then pass that to the RealTrace function, along with the __FILE__ and
    //  __LINE__ which were collected in the ctor.

    class _TraceHelper
    {
        LPCTSTR         m_pszFile;
        ULONG           m_uLineNo;
        DWORD           m_dwLevel;
        const void *    m_pThis;
    public:

        _TraceHelper( LPCTSTR pszFile, ULONG uLineNo, DWORD dwLevel, const void * pThis )
            : m_pszFile( pszFile ),
              m_uLineNo( uLineNo ),
              m_dwLevel( dwLevel ),
              m_pThis( pThis )
        {
            // Done.
        }

        // Can't use plain "BOOL cond" here, since ptr types don't convert to BOOL
        // (which is an int), even though you can use them in an if statement.
        template < typename T >
        void TraceIfCondFails ( T cond, LPCTSTR pszStr, ... )
        {
            if( ! cond )
            {
                va_list alist;
                va_start( alist, pszStr );
                _Trace( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, pszStr, alist );
                va_end( alist );
            }
        }

        void Trace ( LPCTSTR pszStr, ... )
        {
            va_list alist;
            va_start( alist, pszStr );
            _Trace( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, pszStr, alist );
            va_end( alist );
        }

        void TraceHR ( HRESULT hr, LPCTSTR pszStr, ... )
        {
            va_list alist;
            va_start( alist, pszStr );
            _TraceHR( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, hr, pszStr, alist );
            va_end( alist );
        }

        void TraceW32 ( LPCTSTR pszStr, ... )
        {
            va_list alist;
            va_start( alist, pszStr );
            _TraceW32( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, pszStr, alist );
            va_end( alist );
        }
    };




    class _DebugCallRetTracker
    {
        const void *    m_pThis;
        LPCTSTR         m_pszMethodName;
        LPCTSTR         m_pszFile;
        ULONG           m_uLineNo;

    public:

        _DebugCallRetTracker( const void * pThis, LPCTSTR pszFile, ULONG uLineNo )
            : m_pThis( pThis ),
              m_pszMethodName( NULL ),
              m_pszFile( pszFile ),
              m_uLineNo( uLineNo )
        {
            // Done.
        }

        void Trace( LPCTSTR pszMethodName, LPCTSTR pszStr = NULL, ... )
        {
            m_pszMethodName = pszMethodName;

            va_list alist;
            va_start( alist, pszStr );
            _Trace( m_pszFile, m_uLineNo, _TRACE_CALL, m_pThis, m_pszMethodName, pszStr, alist );
            va_end( alist );
        }

        ~_DebugCallRetTracker( )
        {
            _Trace( m_pszFile, m_uLineNo, _TRACE_RET, m_pThis, m_pszMethodName, NULL ); 
        }
    };



#define IMETHOD                           _DebugCallRetTracker _CallTrack_temp_var( this, TEXT( __FILE__ ), __LINE__ ); _CallTrack_temp_var.Trace
#define SMETHOD                           _DebugCallRetTracker _CallTrack_temp_var( NULL, TEXT( __FILE__ ), __LINE__ ); _CallTrack_temp_var.Trace
#define _TraceM( file, line, level, fn )  _TraceHelper( TEXT( file ), line, level, NULL ).fn
#define _TRACE_ASSERT                     _TRACE_ASSERT_D

#else // _DEBUG

// This inline allows us to swallow a variable number of args (including 0).
// The "while(0)" in front of it stops those args from even being evaluated.
// Using _ReurnZero() avoids "conditional expression is constant" warning. 
inline void _DoNothingWithArgs( ... ) { }
inline int _ReturnZero() { return 0; }

#define IMETHOD                            while( _ReturnZero() ) _DoNothingWithArgs
#define SMETHOD                            while( _ReturnZero() ) _DoNothingWithArgs
#define _TraceM( file, line, level, fn )   while( _ReturnZero() ) _DoNothingWithArgs
#define _TRACE_ASSERT                      _TRACE_ASSERT_R

#endif // _DEBUG




// These expand as follows:
//
// Sample usage:
//
//      TraceInfo( TEXT("count = %d"), count );
//
// In debug mode, this gets expanded to:
//
//      _TraceHelper( TEXT( "filename.cpp" ), 234, _TRACE_INFO, NULL ).Trace ( TEXT("count = %d"), count );
//
// In release mode, this gets expanded to:
//
//      while( 0 ) _DoNothing ( TEXT("count = %d"), count );

#define TraceDebug          _TraceM( __FILE__, __LINE__, _TRACE_DEBUG,     Trace )
#define TraceInfo           _TraceM( __FILE__, __LINE__, _TRACE_INFO,      Trace )
#define TraceWarning        _TraceM( __FILE__, __LINE__, _TRACE_WARNING,   Trace )
#define TraceError          _TraceM( __FILE__, __LINE__, _TRACE_ERROR,     Trace )
#define TraceParam          _TraceM( __FILE__, __LINE__, _TRACE_PARAM,     Trace )
#define TraceParamWarn      _TraceM( __FILE__, __LINE__, _TRACE_PARAMWARN, Trace )
#define TraceInterop        _TraceM( __FILE__, __LINE__, _TRACE_INTEROP,   Trace )

#define TraceDebugHR        _TraceM( __FILE__, __LINE__, _TRACE_DEBUG,     TraceHR )
#define TraceInfoHR         _TraceM( __FILE__, __LINE__, _TRACE_INFO,      TraceHR )
#define TraceWarningHR      _TraceM( __FILE__, __LINE__, _TRACE_WARNING,   TraceHR )
#define TraceErrorHR        _TraceM( __FILE__, __LINE__, _TRACE_ERROR,     TraceHR )
#define TraceParamHR        _TraceM( __FILE__, __LINE__, _TRACE_PARAM,     TraceHR )
#define TraceParamWarnHR    _TraceM( __FILE__, __LINE__, _TRACE_PARAMWARN, TraceHR )
#define TraceInteropHR      _TraceM( __FILE__, __LINE__, _TRACE_INTEROP,   TraceHR )

#define TraceDebugW32       _TraceM( __FILE__, __LINE__, _TRACE_DEBUG,     TraceW32 )
#define TraceInfoW32        _TraceM( __FILE__, __LINE__, _TRACE_INFO,      TraceW32 )
#define TraceWarningW32     _TraceM( __FILE__, __LINE__, _TRACE_WARNING,   TraceW32 )
#define TraceErrorW32       _TraceM( __FILE__, __LINE__, _TRACE_ERROR,     TraceW32 )
#define TraceParamW32       _TraceM( __FILE__, __LINE__, _TRACE_PARAM,     TraceW32 )
#define TraceParamWarnW32   _TraceM( __FILE__, __LINE__, _TRACE_PARAMWARN, TraceW32 )
#define TraceInteropW32     _TraceM( __FILE__, __LINE__, _TRACE_INTEROP,   TraceW32 )


#define Assert( cond )      _TraceM(  __FILE__, __LINE__, _TRACE_ASSERT,   TraceIfCondFails ) ( cond, TEXT( # cond ) )
#define AssertMsg           _TraceM(  __FILE__, __LINE__, _TRACE_ASSERT,   TraceIfCondFails )

// Unconditional Assert with message...
#define AssertStr( str )    AssertMsg( FALSE, str )



#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\default.h ===
// --------------------------------------------------------------------------
//
//  DEFAULT.H
//
//  Standard OLE accessible object class
//
// --------------------------------------------------------------------------


class   CAccessible :
        public IAccessible,
        public IEnumVARIANT,
        public IOleWindow,
        public IServiceProvider,
        public IAccIdentity
{
    public:

        //
        // Ctor, Dtor
        //

                CAccessible( CLASS_ENUM eclass );

        // Virtual dtor ensures that dtors of derived classes
		// are called correctly when objects are deleted
        virtual ~CAccessible();


        //
        // IUnknown
        //

        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        //
        // IDispatch
        //

        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                                            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                            DISPPARAMS* pdispparams, VARIANT* pvarResult,
                                            EXCEPINFO* pexcepinfo, UINT* puArgErr);

        //
        // IAccessible
        //

        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName) = 0;
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole) = 0;
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState) = 0;
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP			get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP			get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP			get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP			accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP			accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild) = 0;
        virtual STDMETHODIMP			accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP			accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint) = 0;
        virtual STDMETHODIMP			accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP			put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP			put_accValue(VARIANT varChild, BSTR pszValue);


        //
        // IEnumVARIANT
        //

        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum) = 0;


        //
        // IOleWindow
        //

        virtual STDMETHODIMP            GetWindow(HWND* phwnd);
        virtual STDMETHODIMP            ContextSensitiveHelp(BOOL fEnterMode);


        //
        // IServiceProvider
        //

        virtual STDMETHODIMP            QueryService( REFGUID guidService, REFIID riid, void **ppv );


        //
        // IAccIdentity
        //

        virtual STDMETHODIMP            GetIdentityString ( DWORD     dwIDChild,
                                                            BYTE **   ppIDString,
                                                            DWORD *   pdwIDStringLen );


        //
        // CAccessible
        //

        virtual void SetupChildren();
        virtual BOOL ValidateChild(VARIANT*);

    protected:

        HWND        m_hwnd;
        ULONG       m_cRef;
        long        m_cChildren;        // Count of index-based children
        long        m_idChildCur;       // ID of current child in enum (may be index or hwnd based)

    private:

        // TODO - make the typeinfo a global (static), so we don't init it for each and every object.
        //      - have to be careful, since we'd need one per thread.
        ITypeInfo*  m_pTypeInfo;        // TypeInfo for IDispatch junk
        CLASSINFO * m_pClassInfo;       // ptr to this object's class info - may be NULL in some cases.

        HRESULT InitTypeInfo();
        void    TermTypeInfo();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\default.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DEFAULT.CPP
//
//  This is the default implementation for CAccessible. All other objects
//	usually inherit from this one.
//
//	Implements:
//		IUnknown
//			QueryInterface
//			AddRef
//			Release
//		IDispatch
//			GetTypeInfoCount
//			GetTypeInfo
//			GetIDsOfNames
//			Invoke
//		IAccessible
//			get_accParent
//			get_accChildCount
//			get_accChild
//			get_accName
//			get_accValue
//			get_accDescription
//			get_accRole
//			get_accState
//			get_accHelp
//			get_accHelpTopic
//			get_accKeyboardShortcut
//			get_accFocus
//			get_accSelection
//			get_accDefaultAction
//			accSelect
//			accLocation
//			accNavigate
//			accHitTest
//			accDoDefaultAction
//			put_accName
//			put_accValue
//		IEnumVARIANT
//			Next
//			Skip
//			Reset
//			Clone
//		IOleWindow
//			GetWindow
//			ContextSensitiveHelp
//
//		Helper Functions
//			SetupChildren
//			ValidateChild
//			InitTypeInfo
//			TermTypeInfo
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"

#include "PropMgr_Util.h"

CAccessible::CAccessible( CLASS_ENUM eclass )
{
    // NOTE: we rely on the fact that operator new (see memchk.cpp) uses LocalAlloc
    // with a flag specifying zero-inited memory to initialize our variables.
    // (If we want ot used cached memoey slots, we should change this to explicitly
    // init; or make sure cache slots are cleared before use.)

    if( eclass == CLASS_NONE )
        m_pClassInfo = NULL;
    else
        m_pClassInfo = & g_ClassInfo[ eclass ];
}



CAccessible::~CAccessible()
{
	// Nothing to do
	// (Dtor only exists so that the base class has a virtual dtor, so that
	// derived class dtors work properly when deleted through a base class ptr)
}


// --------------------------------------------------------------------------
//
//  CAccessible::GetWindow()
//
//  This is from IOleWindow, to let us get the HWND from an IAccessible*.
//
// ---------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetWindow(HWND* phwnd)
{
    *phwnd = m_hwnd;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::ContextSensitiveHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
	UNUSED(fEnterMode);
    return(E_NOTIMPL);
}


// --------------------------------------------------------------------------
//
//  CAccessible::InitTypeInfo()
//
//  This initializes our type info when we need it for IDispatch junk.
//
// --------------------------------------------------------------------------
HRESULT CAccessible::InitTypeInfo(void)
{
    HRESULT     hr;
    ITypeLib    *piTypeLib;

    if (m_pTypeInfo)
        return(S_OK);

    // Try getting the typelib from the registry
    hr = LoadRegTypeLib(LIBID_Accessibility, 1, 0, 0, &piTypeLib);

    if (FAILED(hr))
    {
        OLECHAR wszPath[MAX_PATH];

        // Try loading directly.
#ifdef UNICODE
        MyGetModuleFileName(NULL, wszPath, ARRAYSIZE(wszPath));
#else
        TCHAR   szPath[MAX_PATH];

        MyGetModuleFileName(NULL, szPath, ARRAYSIZE(szPath));
        MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, ARRAYSIZE(wszPath));
#endif

        hr = LoadTypeLib(wszPath, &piTypeLib);
    }

    if (SUCCEEDED(hr))
    {
        hr = piTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &m_pTypeInfo);
        piTypeLib->Release();

        if (!SUCCEEDED(hr))
            m_pTypeInfo = NULL;
    }

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAccessible::TermTypeInfo()
//
//  This frees the type info if it is around
//
// --------------------------------------------------------------------------
void CAccessible::TermTypeInfo(void)
{
    if (m_pTypeInfo)
    {
        m_pTypeInfo->Release();
        m_pTypeInfo = NULL;
    }
}



// --------------------------------------------------------------------------
//
//  CAccessible::QueryInterface()
//
//  This responds to 
//          * IUnknown 
//          * IDispatch 
//          * IEnumVARIANT
//          * IAccessible
//
//  The following comment is somewhat old and obsolte:
//    Some code will also respond to IText.  That code must override our
//    QueryInterface() implementation.
//  No current plans to support IText anywhere; but derived classes that
//  want to implement other interfaces will have to override QI.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::QueryInterface( REFIID riid, void** ppv )
{
    *ppv = NULL;

    if( riid == IID_IUnknown  ||
        riid == IID_IDispatch ||
        riid == IID_IAccessible )
    {
        *ppv = static_cast< IAccessible * >( this );
    }
    else if( riid == IID_IEnumVARIANT )
    {
        *ppv = static_cast< IEnumVARIANT * >( this );
    }
    else if( riid == IID_IOleWindow )
    {
        *ppv = static_cast< IOleWindow * >( this );
    }
    else if( riid == IID_IServiceProvider )
    {
        *ppv = static_cast< IServiceProvider * >( this );
    }
    else if( riid == IID_IAccIdentity
                && m_pClassInfo
                && m_pClassInfo->fSupportsAnnotation )
    {
        // Only allow to QI to this interface if this
        // proxy type supports it...
        
        *ppv = static_cast< IAccIdentity * >( this );
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN) *ppv)->AddRef();

    return NOERROR;
}


// --------------------------------------------------------------------------
//
//  CAccessible::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    return(++m_cRef);
}


// --------------------------------------------------------------------------
//
//  CAccessible::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    if ((--m_cRef) == 0)
    {
        TermTypeInfo();
        delete this;
        return 0;
    }

    return(m_cRef);
}



// --------------------------------------------------------------------------
//
//  CAccessible::GetTypeInfoCount()
//
//  This hands off to our typelib for IAccessible().  Note that
//  we only implement one type of object for now.  BOGUS!  What about IText?
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetTypeInfoCount(UINT * pctInfo)
{
    HRESULT hr;

    InitPv(pctInfo);

    hr = InitTypeInfo();

    if (SUCCEEDED(hr))
        *pctInfo = 1;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAccessible::GetTypeInfo()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetTypeInfo(UINT itInfo, LCID lcid,
    ITypeInfo ** ppITypeInfo)
{
    HRESULT hr;

	UNUSED(lcid);	// locale id is unused

    if (ppITypeInfo == NULL)
        return(E_POINTER);

    InitPv(ppITypeInfo);

    if (itInfo != 0)
        return(TYPE_E_ELEMENTNOTFOUND);

    hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        m_pTypeInfo->AddRef();
        *ppITypeInfo = m_pTypeInfo;
    }

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAccessible::GetIDsOfNames()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid,
    OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr;

	UNUSED(lcid);	// locale id is unused
	UNUSED(riid);	// riid is unused

    hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID));
}



// --------------------------------------------------------------------------
//
//  CAccessible::Invoke()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Invoke(DISPID dispID, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pDispParams,
    VARIANT* pvarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr;

	UNUSED(lcid);	// locale id is unused
	UNUSED(riid);	// riid is unused

    hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(m_pTypeInfo->Invoke((IAccessible *)this, dispID, wFlags,
        pDispParams, pvarResult, pExcepInfo, puArgErr));
}




// --------------------------------------------------------------------------
//
//  CAccessible::get_accParent()
//
//  NOTE:  Not only is this the default handler, it can also serve as
//  parameter checking for overriding implementations.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accParent(IDispatch ** ppdispParent)
{
    InitPv(ppdispParent);

    if (m_hwnd)
        return(AccessibleObjectFromWindow(m_hwnd, OBJID_WINDOW,
            IID_IDispatch, (void **)ppdispParent));
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accChildCount()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accChildCount(long* pChildCount)
{
    SetupChildren();
    *pChildCount = m_cChildren;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accChild()
//
//  No children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accChild(VARIANT varChild, IDispatch** ppdispChild)
{
    InitPv(ppdispChild);

    if (! ValidateChild(&varChild) || !varChild.lVal)
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR * pszValue)
{
    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR * pszDescription)
{
    InitPv(pszDescription);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    InitPv(pszHelp);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::get_accHelpTopic()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile,
    VARIANT varChild, long* pidTopic)
{
    InitPv(pszHelpFile);
    InitPv(pidTopic);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild,
    BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accFocus(VARIANT *pvarFocus)
{
    InitPvar(pvarFocus);
    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accSelection(VARIANT* pvarSelection)
{
    InitPvar(pvarSelection);
    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild,
    BSTR* pszDefaultAction)
{
    InitPv(pszDefaultAction);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accSelect(long flagsSel, VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    return(S_FALSE);
}


#if 0
// --------------------------------------------------------------------------
//
//  CAccessible::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_OK);
}
#endif


// --------------------------------------------------------------------------
//
//  CAccessible::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accNavigate(long navFlags, VARIANT varStart,
    VARIANT *pvarEnd)
{
    InitPvar(pvarEnd);

    if (! ValidateChild(&varStart))
        return(E_INVALIDARG);

    if (!ValidateNavDir(navFlags, varStart.lVal))
        return(E_INVALIDARG);

    return(S_FALSE);
}


#if 0
// --------------------------------------------------------------------------
//
//  CAccessible::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop,
    VARIANT* pvarChild)
{
    InitPvar(pvarChild);
    return(S_FALSE);
}
#endif


// --------------------------------------------------------------------------
//
//  CAccessible::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::put_accName()
//
//  CALLER frees the string
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)
{
	UNUSED(szName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::put_accValue()
//
//  CALLER frees the string
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR szValue)
{
	UNUSED(szValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::Next
//
//  Handles simple Next, where we return back indeces for child elements.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Next(ULONG celt, VARIANT* rgvar,
    ULONG* pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    SetupChildren();

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cChildren))
    {
        cFetched++;
        iCur++;

        //
        // Note this gives us (index)+1 because we incremented iCur
        //
        pvar->vt = VT_I4;
        pvar->lVal = iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Skip(ULONG celt)
{
    SetupChildren();

    m_idChildCur += celt;
    if (m_idChildCur > m_cChildren)
        m_idChildCur = m_cChildren;

    //
    // We return S_FALSE if at the end
    //
    return((m_idChildCur >= m_cChildren) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Reset(void)
{
    m_idChildCur = 0;
    return(S_OK);
}




STDMETHODIMP CAccessible::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    if( guidService == IIS_IsOleaccProxy )
    {
        return QueryInterface( riid, ppv );
    }
    else
    {
        // MSDN mentions SVC_E_UNKNOWNSERVICE as the return code, but that's not in any of the headers.
        // Returning E_INVALIDARG instead. (Don't want to use E_NOINTERFACE, since that clashes with
        // QI's return value, making it hard to distinguish between valid service+invalid interface vs
        // invalid service.
        return E_INVALIDARG;
    }
}



STDMETHODIMP CAccessible::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    if( ! m_pClassInfo || ! m_pClassInfo->fSupportsAnnotation  )
    {
        // Shouldn't get here - shouldn't QI to this interface if the above are false.
        Assert( FALSE );
        return E_FAIL;
    }

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HWNDKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    MakeHwndKey( pKeyData, m_hwnd, m_pClassInfo->dwObjId, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HWNDKEYSIZE;

    return S_OK;
}





// --------------------------------------------------------------------------
//
//  CAccessible::ValidateChild()
//
// --------------------------------------------------------------------------
BOOL CAccessible::ValidateChild(VARIANT *pvar)
{
    //
    // This validates a VARIANT parameter and translates missing/empty
    // params.
    //
    SetupChildren();

    // Missing parameter, a la VBA
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

// remove this! VT_I2 is not valid!!
#ifdef  VT_I2_IS_VALID  // it isn't now...
        case VT_I2:
            pvar->vt = VT_I4;
            pvar->lVal = (long)pvar->iVal;
            // FALL THROUGH
#endif

        case VT_I4:
            if ((pvar->lVal < 0) || (pvar->lVal > m_cChildren))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  SetupChildren()
//
//  Default implementation of SetupChildren, does nothing.
//
// --------------------------------------------------------------------------
void CAccessible::SetupChildren(void)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\fwd_macros.h ===
#ifndef _FWD_MACROS_H_
#define _FWD_MACROS_H_


#define AS_DECL_0
#define AS_CALL_0

#define AS_DECL_1(t1,a1) (t1 a1)
#define AS_CALL_1(t1,a1) (a1)

#define AS_DECL_2(t1,a1,t2,a2) (t1 a1,t2 a2)
#define AS_CALL_2(t1,a1,t2,a2) (a1,a2)

#define AS_DECL_3(t1,a1,t2,a2,t3,a3) (t1 a1,t2 a2,t3 a3)
#define AS_CALL_3(t1,a1,t2,a2,t3,a3) (a1,a2,a3)

#define AS_DECL_4(t1,a1,t2,a2,t3,a3,t4,a4) (t1 a1,t2 a2,t3 a3,t4 a4)
#define AS_CALL_4(t1,a1,t2,a2,t3,a3,t4,a4) (a1,a2,a3,a4)

#define AS_DECL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5)
#define AS_CALL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (a1,a2,a3,a4,a5)

#define AS_DECL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6)
#define AS_CALL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (a1,a2,a3,a4,a5,a6)

#define AS_DECL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7)
#define AS_CALL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (a1,a2,a3,a4,a5,a6,a7)

#define AS_DECL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8)
#define AS_CALL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (a1,a2,a3,a4,a5,a6,a7,a8)

#define AS_DECL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9)
#define AS_CALL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (a1,a2,a3,a4,a5,a6,a7,a8,a9)

#define AS_DECL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10)
#define AS_CALL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)

#define AS_DECL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10,t11 a11)
#define AS_CALL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)


#define AS_DECL( n, p )  AS_DECL_ ## n p
#define AS_CALL( n, p )  AS_CALL_ ## n p


#endif // _FWD_MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\desktop.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DESKTOP.H
//
//  (Real not shell) Desktop client support
//
// --------------------------------------------------------------------------


class CDesktop : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accFocus(VARIANT*);
        virtual STDMETHODIMP        get_accSelection(VARIANT*);

        CDesktop(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\desktop.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DESKTOP.CPP
//
//  Desktop class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "desktop.h"




// --------------------------------------------------------------------------
//
//  CreateDesktopClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateDesktopClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvDesktop)
{
    CDesktop* pdesktop;
    HRESULT   hr;

    InitPv(ppvDesktop);

    pdesktop = new CDesktop(hwnd, idChildCur);
    if (! pdesktop)
        return(E_OUTOFMEMORY);

    hr = pdesktop->QueryInterface(riid, ppvDesktop);
    if (!SUCCEEDED(hr))
        delete pdesktop;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CDesktop::CDesktop()
//
// --------------------------------------------------------------------------
CDesktop::CDesktop(HWND hwnd, long idChildCur)
    : CClient( CLASS_DesktopClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CDesktop::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDesktop::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_DESKTOP_NAME, pszName));
}



// --------------------------------------------------------------------------
//
//  CDesktop::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDesktop::get_accFocus(VARIANT* pvarFocus)
{
    return(get_accSelection(pvarFocus));
}



// --------------------------------------------------------------------------
//
//  CDesktop::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDesktop::get_accSelection(VARIANT* pvar)
{
    HWND    hwnd;

    InitPvar(pvar);

    hwnd = GetForegroundWindow();
    if (! hwnd)
        return(S_FALSE);

    return(GetWindowObject(hwnd, pvar));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\dialog.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DIALOG.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "dialog.h"




// --------------------------------------------------------------------------
//
//  CreateDialogClient()
//
//  EXTERNAL function for CreateClientObject()
//
// ------------------------------------------------------------------------